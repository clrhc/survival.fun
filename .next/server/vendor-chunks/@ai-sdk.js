"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@ai-sdk";
exports.ids = ["vendor-chunks/@ai-sdk"];
exports.modules = {

/***/ "(rsc)/./node_modules/@ai-sdk/provider-utils/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@ai-sdk/provider-utils/dist/index.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// src/index.ts\nvar src_exports = {};\n__export(src_exports, {\n  asValidator: () => asValidator,\n  combineHeaders: () => combineHeaders,\n  convertAsyncIteratorToReadableStream: () => convertAsyncIteratorToReadableStream,\n  convertBase64ToUint8Array: () => convertBase64ToUint8Array,\n  convertUint8ArrayToBase64: () => convertUint8ArrayToBase64,\n  createBinaryResponseHandler: () => createBinaryResponseHandler,\n  createEventSourceParserStream: () => createEventSourceParserStream,\n  createEventSourceResponseHandler: () => createEventSourceResponseHandler,\n  createIdGenerator: () => createIdGenerator,\n  createJsonErrorResponseHandler: () => createJsonErrorResponseHandler,\n  createJsonResponseHandler: () => createJsonResponseHandler,\n  createJsonStreamResponseHandler: () => createJsonStreamResponseHandler,\n  createStatusCodeErrorResponseHandler: () => createStatusCodeErrorResponseHandler,\n  delay: () => delay,\n  extractResponseHeaders: () => extractResponseHeaders,\n  generateId: () => generateId,\n  getErrorMessage: () => getErrorMessage,\n  getFromApi: () => getFromApi,\n  isAbortError: () => isAbortError,\n  isParsableJson: () => isParsableJson,\n  isValidator: () => isValidator,\n  loadApiKey: () => loadApiKey,\n  loadOptionalSetting: () => loadOptionalSetting,\n  loadSetting: () => loadSetting,\n  parseJSON: () => parseJSON,\n  parseProviderOptions: () => parseProviderOptions,\n  postFormDataToApi: () => postFormDataToApi,\n  postJsonToApi: () => postJsonToApi,\n  postToApi: () => postToApi,\n  removeUndefinedEntries: () => removeUndefinedEntries,\n  resolve: () => resolve,\n  safeParseJSON: () => safeParseJSON,\n  safeValidateTypes: () => safeValidateTypes,\n  validateTypes: () => validateTypes,\n  validator: () => validator,\n  validatorSymbol: () => validatorSymbol,\n  withoutTrailingSlash: () => withoutTrailingSlash,\n  zodValidator: () => zodValidator\n});\nmodule.exports = __toCommonJS(src_exports);\n\n// src/combine-headers.ts\nfunction combineHeaders(...headers) {\n  return headers.reduce(\n    (combinedHeaders, currentHeaders) => ({\n      ...combinedHeaders,\n      ...currentHeaders != null ? currentHeaders : {}\n    }),\n    {}\n  );\n}\n\n// src/convert-async-iterator-to-readable-stream.ts\nfunction convertAsyncIteratorToReadableStream(iterator) {\n  return new ReadableStream({\n    /**\n     * Called when the consumer wants to pull more data from the stream.\n     *\n     * @param {ReadableStreamDefaultController<T>} controller - The controller to enqueue data into the stream.\n     * @returns {Promise<void>}\n     */\n    async pull(controller) {\n      try {\n        const { value, done } = await iterator.next();\n        if (done) {\n          controller.close();\n        } else {\n          controller.enqueue(value);\n        }\n      } catch (error) {\n        controller.error(error);\n      }\n    },\n    /**\n     * Called when the consumer cancels the stream.\n     */\n    cancel() {\n    }\n  });\n}\n\n// src/delay.ts\nasync function delay(delayInMs) {\n  return delayInMs == null ? Promise.resolve() : new Promise((resolve2) => setTimeout(resolve2, delayInMs));\n}\n\n// src/event-source-parser-stream.ts\nfunction createEventSourceParserStream() {\n  let buffer = \"\";\n  let event = void 0;\n  let data = [];\n  let lastEventId = void 0;\n  let retry = void 0;\n  function parseLine(line, controller) {\n    if (line === \"\") {\n      dispatchEvent(controller);\n      return;\n    }\n    if (line.startsWith(\":\")) {\n      return;\n    }\n    const colonIndex = line.indexOf(\":\");\n    if (colonIndex === -1) {\n      handleField(line, \"\");\n      return;\n    }\n    const field = line.slice(0, colonIndex);\n    const valueStart = colonIndex + 1;\n    const value = valueStart < line.length && line[valueStart] === \" \" ? line.slice(valueStart + 1) : line.slice(valueStart);\n    handleField(field, value);\n  }\n  function dispatchEvent(controller) {\n    if (data.length > 0) {\n      controller.enqueue({\n        event,\n        data: data.join(\"\\n\"),\n        id: lastEventId,\n        retry\n      });\n      data = [];\n      event = void 0;\n      retry = void 0;\n    }\n  }\n  function handleField(field, value) {\n    switch (field) {\n      case \"event\":\n        event = value;\n        break;\n      case \"data\":\n        data.push(value);\n        break;\n      case \"id\":\n        lastEventId = value;\n        break;\n      case \"retry\":\n        const parsedRetry = parseInt(value, 10);\n        if (!isNaN(parsedRetry)) {\n          retry = parsedRetry;\n        }\n        break;\n    }\n  }\n  return new TransformStream({\n    transform(chunk, controller) {\n      const { lines, incompleteLine } = splitLines(buffer, chunk);\n      buffer = incompleteLine;\n      for (let i = 0; i < lines.length; i++) {\n        parseLine(lines[i], controller);\n      }\n    },\n    flush(controller) {\n      parseLine(buffer, controller);\n      dispatchEvent(controller);\n    }\n  });\n}\nfunction splitLines(buffer, chunk) {\n  const lines = [];\n  let currentLine = buffer;\n  for (let i = 0; i < chunk.length; ) {\n    const char = chunk[i++];\n    if (char === \"\\n\") {\n      lines.push(currentLine);\n      currentLine = \"\";\n    } else if (char === \"\\r\") {\n      lines.push(currentLine);\n      currentLine = \"\";\n      if (chunk[i + 1] === \"\\n\") {\n        i++;\n      }\n    } else {\n      currentLine += char;\n    }\n  }\n  return { lines, incompleteLine: currentLine };\n}\n\n// src/extract-response-headers.ts\nfunction extractResponseHeaders(response) {\n  const headers = {};\n  response.headers.forEach((value, key) => {\n    headers[key] = value;\n  });\n  return headers;\n}\n\n// src/generate-id.ts\nvar import_provider = __webpack_require__(/*! @ai-sdk/provider */ \"(rsc)/./node_modules/@ai-sdk/provider/dist/index.js\");\nvar import_non_secure = __webpack_require__(/*! nanoid/non-secure */ \"(rsc)/./node_modules/nanoid/non-secure/index.cjs\");\nvar createIdGenerator = ({\n  prefix,\n  size: defaultSize = 16,\n  alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\",\n  separator = \"-\"\n} = {}) => {\n  const generator = (0, import_non_secure.customAlphabet)(alphabet, defaultSize);\n  if (prefix == null) {\n    return generator;\n  }\n  if (alphabet.includes(separator)) {\n    throw new import_provider.InvalidArgumentError({\n      argument: \"separator\",\n      message: `The separator \"${separator}\" must not be part of the alphabet \"${alphabet}\".`\n    });\n  }\n  return (size) => `${prefix}${separator}${generator(size)}`;\n};\nvar generateId = createIdGenerator();\n\n// src/get-error-message.ts\nfunction getErrorMessage(error) {\n  if (error == null) {\n    return \"unknown error\";\n  }\n  if (typeof error === \"string\") {\n    return error;\n  }\n  if (error instanceof Error) {\n    return error.message;\n  }\n  return JSON.stringify(error);\n}\n\n// src/get-from-api.ts\nvar import_provider2 = __webpack_require__(/*! @ai-sdk/provider */ \"(rsc)/./node_modules/@ai-sdk/provider/dist/index.js\");\n\n// src/remove-undefined-entries.ts\nfunction removeUndefinedEntries(record) {\n  return Object.fromEntries(\n    Object.entries(record).filter(([_key, value]) => value != null)\n  );\n}\n\n// src/is-abort-error.ts\nfunction isAbortError(error) {\n  return error instanceof Error && (error.name === \"AbortError\" || error.name === \"TimeoutError\");\n}\n\n// src/get-from-api.ts\nvar getOriginalFetch = () => globalThis.fetch;\nvar getFromApi = async ({\n  url,\n  headers = {},\n  successfulResponseHandler,\n  failedResponseHandler,\n  abortSignal,\n  fetch = getOriginalFetch()\n}) => {\n  try {\n    const response = await fetch(url, {\n      method: \"GET\",\n      headers: removeUndefinedEntries(headers),\n      signal: abortSignal\n    });\n    const responseHeaders = extractResponseHeaders(response);\n    if (!response.ok) {\n      let errorInformation;\n      try {\n        errorInformation = await failedResponseHandler({\n          response,\n          url,\n          requestBodyValues: {}\n        });\n      } catch (error) {\n        if (isAbortError(error) || import_provider2.APICallError.isInstance(error)) {\n          throw error;\n        }\n        throw new import_provider2.APICallError({\n          message: \"Failed to process error response\",\n          cause: error,\n          statusCode: response.status,\n          url,\n          responseHeaders,\n          requestBodyValues: {}\n        });\n      }\n      throw errorInformation.value;\n    }\n    try {\n      return await successfulResponseHandler({\n        response,\n        url,\n        requestBodyValues: {}\n      });\n    } catch (error) {\n      if (error instanceof Error) {\n        if (isAbortError(error) || import_provider2.APICallError.isInstance(error)) {\n          throw error;\n        }\n      }\n      throw new import_provider2.APICallError({\n        message: \"Failed to process successful response\",\n        cause: error,\n        statusCode: response.status,\n        url,\n        responseHeaders,\n        requestBodyValues: {}\n      });\n    }\n  } catch (error) {\n    if (isAbortError(error)) {\n      throw error;\n    }\n    if (error instanceof TypeError && error.message === \"fetch failed\") {\n      const cause = error.cause;\n      if (cause != null) {\n        throw new import_provider2.APICallError({\n          message: `Cannot connect to API: ${cause.message}`,\n          cause,\n          url,\n          isRetryable: true,\n          requestBodyValues: {}\n        });\n      }\n    }\n    throw error;\n  }\n};\n\n// src/load-api-key.ts\nvar import_provider3 = __webpack_require__(/*! @ai-sdk/provider */ \"(rsc)/./node_modules/@ai-sdk/provider/dist/index.js\");\nfunction loadApiKey({\n  apiKey,\n  environmentVariableName,\n  apiKeyParameterName = \"apiKey\",\n  description\n}) {\n  if (typeof apiKey === \"string\") {\n    return apiKey;\n  }\n  if (apiKey != null) {\n    throw new import_provider3.LoadAPIKeyError({\n      message: `${description} API key must be a string.`\n    });\n  }\n  if (typeof process === \"undefined\") {\n    throw new import_provider3.LoadAPIKeyError({\n      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter. Environment variables is not supported in this environment.`\n    });\n  }\n  apiKey = process.env[environmentVariableName];\n  if (apiKey == null) {\n    throw new import_provider3.LoadAPIKeyError({\n      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter or the ${environmentVariableName} environment variable.`\n    });\n  }\n  if (typeof apiKey !== \"string\") {\n    throw new import_provider3.LoadAPIKeyError({\n      message: `${description} API key must be a string. The value of the ${environmentVariableName} environment variable is not a string.`\n    });\n  }\n  return apiKey;\n}\n\n// src/load-optional-setting.ts\nfunction loadOptionalSetting({\n  settingValue,\n  environmentVariableName\n}) {\n  if (typeof settingValue === \"string\") {\n    return settingValue;\n  }\n  if (settingValue != null || typeof process === \"undefined\") {\n    return void 0;\n  }\n  settingValue = process.env[environmentVariableName];\n  if (settingValue == null || typeof settingValue !== \"string\") {\n    return void 0;\n  }\n  return settingValue;\n}\n\n// src/load-setting.ts\nvar import_provider4 = __webpack_require__(/*! @ai-sdk/provider */ \"(rsc)/./node_modules/@ai-sdk/provider/dist/index.js\");\nfunction loadSetting({\n  settingValue,\n  environmentVariableName,\n  settingName,\n  description\n}) {\n  if (typeof settingValue === \"string\") {\n    return settingValue;\n  }\n  if (settingValue != null) {\n    throw new import_provider4.LoadSettingError({\n      message: `${description} setting must be a string.`\n    });\n  }\n  if (typeof process === \"undefined\") {\n    throw new import_provider4.LoadSettingError({\n      message: `${description} setting is missing. Pass it using the '${settingName}' parameter. Environment variables is not supported in this environment.`\n    });\n  }\n  settingValue = process.env[environmentVariableName];\n  if (settingValue == null) {\n    throw new import_provider4.LoadSettingError({\n      message: `${description} setting is missing. Pass it using the '${settingName}' parameter or the ${environmentVariableName} environment variable.`\n    });\n  }\n  if (typeof settingValue !== \"string\") {\n    throw new import_provider4.LoadSettingError({\n      message: `${description} setting must be a string. The value of the ${environmentVariableName} environment variable is not a string.`\n    });\n  }\n  return settingValue;\n}\n\n// src/parse-json.ts\nvar import_provider6 = __webpack_require__(/*! @ai-sdk/provider */ \"(rsc)/./node_modules/@ai-sdk/provider/dist/index.js\");\nvar import_secure_json_parse = __toESM(__webpack_require__(/*! secure-json-parse */ \"(rsc)/./node_modules/secure-json-parse/index.js\"));\n\n// src/validate-types.ts\nvar import_provider5 = __webpack_require__(/*! @ai-sdk/provider */ \"(rsc)/./node_modules/@ai-sdk/provider/dist/index.js\");\n\n// src/validator.ts\nvar validatorSymbol = Symbol.for(\"vercel.ai.validator\");\nfunction validator(validate) {\n  return { [validatorSymbol]: true, validate };\n}\nfunction isValidator(value) {\n  return typeof value === \"object\" && value !== null && validatorSymbol in value && value[validatorSymbol] === true && \"validate\" in value;\n}\nfunction asValidator(value) {\n  return isValidator(value) ? value : zodValidator(value);\n}\nfunction zodValidator(zodSchema) {\n  return validator((value) => {\n    const result = zodSchema.safeParse(value);\n    return result.success ? { success: true, value: result.data } : { success: false, error: result.error };\n  });\n}\n\n// src/validate-types.ts\nfunction validateTypes({\n  value,\n  schema: inputSchema\n}) {\n  const result = safeValidateTypes({ value, schema: inputSchema });\n  if (!result.success) {\n    throw import_provider5.TypeValidationError.wrap({ value, cause: result.error });\n  }\n  return result.value;\n}\nfunction safeValidateTypes({\n  value,\n  schema\n}) {\n  const validator2 = asValidator(schema);\n  try {\n    if (validator2.validate == null) {\n      return { success: true, value };\n    }\n    const result = validator2.validate(value);\n    if (result.success) {\n      return result;\n    }\n    return {\n      success: false,\n      error: import_provider5.TypeValidationError.wrap({ value, cause: result.error })\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: import_provider5.TypeValidationError.wrap({ value, cause: error })\n    };\n  }\n}\n\n// src/parse-json.ts\nfunction parseJSON({\n  text,\n  schema\n}) {\n  try {\n    const value = import_secure_json_parse.default.parse(text);\n    if (schema == null) {\n      return value;\n    }\n    return validateTypes({ value, schema });\n  } catch (error) {\n    if (import_provider6.JSONParseError.isInstance(error) || import_provider6.TypeValidationError.isInstance(error)) {\n      throw error;\n    }\n    throw new import_provider6.JSONParseError({ text, cause: error });\n  }\n}\nfunction safeParseJSON({\n  text,\n  schema\n}) {\n  try {\n    const value = import_secure_json_parse.default.parse(text);\n    if (schema == null) {\n      return { success: true, value, rawValue: value };\n    }\n    const validationResult = safeValidateTypes({ value, schema });\n    return validationResult.success ? { ...validationResult, rawValue: value } : validationResult;\n  } catch (error) {\n    return {\n      success: false,\n      error: import_provider6.JSONParseError.isInstance(error) ? error : new import_provider6.JSONParseError({ text, cause: error })\n    };\n  }\n}\nfunction isParsableJson(input) {\n  try {\n    import_secure_json_parse.default.parse(input);\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\n// src/parse-provider-options.ts\nvar import_provider7 = __webpack_require__(/*! @ai-sdk/provider */ \"(rsc)/./node_modules/@ai-sdk/provider/dist/index.js\");\nfunction parseProviderOptions({\n  provider,\n  providerOptions,\n  schema\n}) {\n  if ((providerOptions == null ? void 0 : providerOptions[provider]) == null) {\n    return void 0;\n  }\n  const parsedProviderOptions = safeValidateTypes({\n    value: providerOptions[provider],\n    schema\n  });\n  if (!parsedProviderOptions.success) {\n    throw new import_provider7.InvalidArgumentError({\n      argument: \"providerOptions\",\n      message: `invalid ${provider} provider options`,\n      cause: parsedProviderOptions.error\n    });\n  }\n  return parsedProviderOptions.value;\n}\n\n// src/post-to-api.ts\nvar import_provider8 = __webpack_require__(/*! @ai-sdk/provider */ \"(rsc)/./node_modules/@ai-sdk/provider/dist/index.js\");\nvar getOriginalFetch2 = () => globalThis.fetch;\nvar postJsonToApi = async ({\n  url,\n  headers,\n  body,\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch\n}) => postToApi({\n  url,\n  headers: {\n    \"Content-Type\": \"application/json\",\n    ...headers\n  },\n  body: {\n    content: JSON.stringify(body),\n    values: body\n  },\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch\n});\nvar postFormDataToApi = async ({\n  url,\n  headers,\n  formData,\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch\n}) => postToApi({\n  url,\n  headers,\n  body: {\n    content: formData,\n    values: Object.fromEntries(formData.entries())\n  },\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch\n});\nvar postToApi = async ({\n  url,\n  headers = {},\n  body,\n  successfulResponseHandler,\n  failedResponseHandler,\n  abortSignal,\n  fetch = getOriginalFetch2()\n}) => {\n  try {\n    const response = await fetch(url, {\n      method: \"POST\",\n      headers: removeUndefinedEntries(headers),\n      body: body.content,\n      signal: abortSignal\n    });\n    const responseHeaders = extractResponseHeaders(response);\n    if (!response.ok) {\n      let errorInformation;\n      try {\n        errorInformation = await failedResponseHandler({\n          response,\n          url,\n          requestBodyValues: body.values\n        });\n      } catch (error) {\n        if (isAbortError(error) || import_provider8.APICallError.isInstance(error)) {\n          throw error;\n        }\n        throw new import_provider8.APICallError({\n          message: \"Failed to process error response\",\n          cause: error,\n          statusCode: response.status,\n          url,\n          responseHeaders,\n          requestBodyValues: body.values\n        });\n      }\n      throw errorInformation.value;\n    }\n    try {\n      return await successfulResponseHandler({\n        response,\n        url,\n        requestBodyValues: body.values\n      });\n    } catch (error) {\n      if (error instanceof Error) {\n        if (isAbortError(error) || import_provider8.APICallError.isInstance(error)) {\n          throw error;\n        }\n      }\n      throw new import_provider8.APICallError({\n        message: \"Failed to process successful response\",\n        cause: error,\n        statusCode: response.status,\n        url,\n        responseHeaders,\n        requestBodyValues: body.values\n      });\n    }\n  } catch (error) {\n    if (isAbortError(error)) {\n      throw error;\n    }\n    if (error instanceof TypeError && error.message === \"fetch failed\") {\n      const cause = error.cause;\n      if (cause != null) {\n        throw new import_provider8.APICallError({\n          message: `Cannot connect to API: ${cause.message}`,\n          cause,\n          url,\n          requestBodyValues: body.values,\n          isRetryable: true\n          // retry when network error\n        });\n      }\n    }\n    throw error;\n  }\n};\n\n// src/resolve.ts\nasync function resolve(value) {\n  if (typeof value === \"function\") {\n    value = value();\n  }\n  return Promise.resolve(value);\n}\n\n// src/response-handler.ts\nvar import_provider9 = __webpack_require__(/*! @ai-sdk/provider */ \"(rsc)/./node_modules/@ai-sdk/provider/dist/index.js\");\nvar createJsonErrorResponseHandler = ({\n  errorSchema,\n  errorToMessage,\n  isRetryable\n}) => async ({ response, url, requestBodyValues }) => {\n  const responseBody = await response.text();\n  const responseHeaders = extractResponseHeaders(response);\n  if (responseBody.trim() === \"\") {\n    return {\n      responseHeaders,\n      value: new import_provider9.APICallError({\n        message: response.statusText,\n        url,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n        isRetryable: isRetryable == null ? void 0 : isRetryable(response)\n      })\n    };\n  }\n  try {\n    const parsedError = parseJSON({\n      text: responseBody,\n      schema: errorSchema\n    });\n    return {\n      responseHeaders,\n      value: new import_provider9.APICallError({\n        message: errorToMessage(parsedError),\n        url,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n        data: parsedError,\n        isRetryable: isRetryable == null ? void 0 : isRetryable(response, parsedError)\n      })\n    };\n  } catch (parseError) {\n    return {\n      responseHeaders,\n      value: new import_provider9.APICallError({\n        message: response.statusText,\n        url,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n        isRetryable: isRetryable == null ? void 0 : isRetryable(response)\n      })\n    };\n  }\n};\nvar createEventSourceResponseHandler = (chunkSchema) => async ({ response }) => {\n  const responseHeaders = extractResponseHeaders(response);\n  if (response.body == null) {\n    throw new import_provider9.EmptyResponseBodyError({});\n  }\n  return {\n    responseHeaders,\n    value: response.body.pipeThrough(new TextDecoderStream()).pipeThrough(createEventSourceParserStream()).pipeThrough(\n      new TransformStream({\n        transform({ data }, controller) {\n          if (data === \"[DONE]\") {\n            return;\n          }\n          controller.enqueue(\n            safeParseJSON({\n              text: data,\n              schema: chunkSchema\n            })\n          );\n        }\n      })\n    )\n  };\n};\nvar createJsonStreamResponseHandler = (chunkSchema) => async ({ response }) => {\n  const responseHeaders = extractResponseHeaders(response);\n  if (response.body == null) {\n    throw new import_provider9.EmptyResponseBodyError({});\n  }\n  let buffer = \"\";\n  return {\n    responseHeaders,\n    value: response.body.pipeThrough(new TextDecoderStream()).pipeThrough(\n      new TransformStream({\n        transform(chunkText, controller) {\n          if (chunkText.endsWith(\"\\n\")) {\n            controller.enqueue(\n              safeParseJSON({\n                text: buffer + chunkText,\n                schema: chunkSchema\n              })\n            );\n            buffer = \"\";\n          } else {\n            buffer += chunkText;\n          }\n        }\n      })\n    )\n  };\n};\nvar createJsonResponseHandler = (responseSchema) => async ({ response, url, requestBodyValues }) => {\n  const responseBody = await response.text();\n  const parsedResult = safeParseJSON({\n    text: responseBody,\n    schema: responseSchema\n  });\n  const responseHeaders = extractResponseHeaders(response);\n  if (!parsedResult.success) {\n    throw new import_provider9.APICallError({\n      message: \"Invalid JSON response\",\n      cause: parsedResult.error,\n      statusCode: response.status,\n      responseHeaders,\n      responseBody,\n      url,\n      requestBodyValues\n    });\n  }\n  return {\n    responseHeaders,\n    value: parsedResult.value,\n    rawValue: parsedResult.rawValue\n  };\n};\nvar createBinaryResponseHandler = () => async ({ response, url, requestBodyValues }) => {\n  const responseHeaders = extractResponseHeaders(response);\n  if (!response.body) {\n    throw new import_provider9.APICallError({\n      message: \"Response body is empty\",\n      url,\n      requestBodyValues,\n      statusCode: response.status,\n      responseHeaders,\n      responseBody: void 0\n    });\n  }\n  try {\n    const buffer = await response.arrayBuffer();\n    return {\n      responseHeaders,\n      value: new Uint8Array(buffer)\n    };\n  } catch (error) {\n    throw new import_provider9.APICallError({\n      message: \"Failed to read response as array buffer\",\n      url,\n      requestBodyValues,\n      statusCode: response.status,\n      responseHeaders,\n      responseBody: void 0,\n      cause: error\n    });\n  }\n};\nvar createStatusCodeErrorResponseHandler = () => async ({ response, url, requestBodyValues }) => {\n  const responseHeaders = extractResponseHeaders(response);\n  const responseBody = await response.text();\n  return {\n    responseHeaders,\n    value: new import_provider9.APICallError({\n      message: response.statusText,\n      url,\n      requestBodyValues,\n      statusCode: response.status,\n      responseHeaders,\n      responseBody\n    })\n  };\n};\n\n// src/uint8-utils.ts\nvar { btoa, atob } = globalThis;\nfunction convertBase64ToUint8Array(base64String) {\n  const base64Url = base64String.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  const latin1string = atob(base64Url);\n  return Uint8Array.from(latin1string, (byte) => byte.codePointAt(0));\n}\nfunction convertUint8ArrayToBase64(array) {\n  let latin1string = \"\";\n  for (let i = 0; i < array.length; i++) {\n    latin1string += String.fromCodePoint(array[i]);\n  }\n  return btoa(latin1string);\n}\n\n// src/without-trailing-slash.ts\nfunction withoutTrailingSlash(url) {\n  return url == null ? void 0 : url.replace(/\\/$/, \"\");\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGFpLXNkay9wcm92aWRlci11dGlscy9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0RkFBNEY7QUFDekg7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLDhCQUE4QjtBQUN2RztBQUNBO0FBQ0Esb0RBQW9ELGtCQUFrQixhQUFhOztBQUVuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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WjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELGtDQUFrQztBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxrQ0FBa0M7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDBEQUEwRCxrQ0FBa0M7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsTUFBTSxhQUFhO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxDQXVDTDtBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3Vydml2YWwtZnVuLy4vbm9kZV9tb2R1bGVzL0BhaS1zZGsvcHJvdmlkZXItdXRpbHMvZGlzdC9pbmRleC5qcz8zOWE0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2dldFByb3RvT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX2NvcHlQcm9wcyA9ICh0bywgZnJvbSwgZXhjZXB0LCBkZXNjKSA9PiB7XG4gIGlmIChmcm9tICYmIHR5cGVvZiBmcm9tID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBmcm9tID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMoZnJvbSkpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRvLCBrZXkpICYmIGtleSAhPT0gZXhjZXB0KVxuICAgICAgICBfX2RlZlByb3AodG8sIGtleSwgeyBnZXQ6ICgpID0+IGZyb21ba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhmcm9tLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRvO1xufTtcbnZhciBfX3RvRVNNID0gKG1vZCwgaXNOb2RlTW9kZSwgdGFyZ2V0KSA9PiAodGFyZ2V0ID0gbW9kICE9IG51bGwgPyBfX2NyZWF0ZShfX2dldFByb3RvT2YobW9kKSkgOiB7fSwgX19jb3B5UHJvcHMoXG4gIC8vIElmIHRoZSBpbXBvcnRlciBpcyBpbiBub2RlIGNvbXBhdGliaWxpdHkgbW9kZSBvciB0aGlzIGlzIG5vdCBhbiBFU01cbiAgLy8gZmlsZSB0aGF0IGhhcyBiZWVuIGNvbnZlcnRlZCB0byBhIENvbW1vbkpTIGZpbGUgdXNpbmcgYSBCYWJlbC1cbiAgLy8gY29tcGF0aWJsZSB0cmFuc2Zvcm0gKGkuZS4gXCJfX2VzTW9kdWxlXCIgaGFzIG5vdCBiZWVuIHNldCksIHRoZW4gc2V0XG4gIC8vIFwiZGVmYXVsdFwiIHRvIHRoZSBDb21tb25KUyBcIm1vZHVsZS5leHBvcnRzXCIgZm9yIG5vZGUgY29tcGF0aWJpbGl0eS5cbiAgaXNOb2RlTW9kZSB8fCAhbW9kIHx8ICFtb2QuX19lc01vZHVsZSA/IF9fZGVmUHJvcCh0YXJnZXQsIFwiZGVmYXVsdFwiLCB7IHZhbHVlOiBtb2QsIGVudW1lcmFibGU6IHRydWUgfSkgOiB0YXJnZXQsXG4gIG1vZFxuKSk7XG52YXIgX190b0NvbW1vbkpTID0gKG1vZCkgPT4gX19jb3B5UHJvcHMoX19kZWZQcm9wKHt9LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KSwgbW9kKTtcblxuLy8gc3JjL2luZGV4LnRzXG52YXIgc3JjX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHNyY19leHBvcnRzLCB7XG4gIGFzVmFsaWRhdG9yOiAoKSA9PiBhc1ZhbGlkYXRvcixcbiAgY29tYmluZUhlYWRlcnM6ICgpID0+IGNvbWJpbmVIZWFkZXJzLFxuICBjb252ZXJ0QXN5bmNJdGVyYXRvclRvUmVhZGFibGVTdHJlYW06ICgpID0+IGNvbnZlcnRBc3luY0l0ZXJhdG9yVG9SZWFkYWJsZVN0cmVhbSxcbiAgY29udmVydEJhc2U2NFRvVWludDhBcnJheTogKCkgPT4gY29udmVydEJhc2U2NFRvVWludDhBcnJheSxcbiAgY29udmVydFVpbnQ4QXJyYXlUb0Jhc2U2NDogKCkgPT4gY29udmVydFVpbnQ4QXJyYXlUb0Jhc2U2NCxcbiAgY3JlYXRlQmluYXJ5UmVzcG9uc2VIYW5kbGVyOiAoKSA9PiBjcmVhdGVCaW5hcnlSZXNwb25zZUhhbmRsZXIsXG4gIGNyZWF0ZUV2ZW50U291cmNlUGFyc2VyU3RyZWFtOiAoKSA9PiBjcmVhdGVFdmVudFNvdXJjZVBhcnNlclN0cmVhbSxcbiAgY3JlYXRlRXZlbnRTb3VyY2VSZXNwb25zZUhhbmRsZXI6ICgpID0+IGNyZWF0ZUV2ZW50U291cmNlUmVzcG9uc2VIYW5kbGVyLFxuICBjcmVhdGVJZEdlbmVyYXRvcjogKCkgPT4gY3JlYXRlSWRHZW5lcmF0b3IsXG4gIGNyZWF0ZUpzb25FcnJvclJlc3BvbnNlSGFuZGxlcjogKCkgPT4gY3JlYXRlSnNvbkVycm9yUmVzcG9uc2VIYW5kbGVyLFxuICBjcmVhdGVKc29uUmVzcG9uc2VIYW5kbGVyOiAoKSA9PiBjcmVhdGVKc29uUmVzcG9uc2VIYW5kbGVyLFxuICBjcmVhdGVKc29uU3RyZWFtUmVzcG9uc2VIYW5kbGVyOiAoKSA9PiBjcmVhdGVKc29uU3RyZWFtUmVzcG9uc2VIYW5kbGVyLFxuICBjcmVhdGVTdGF0dXNDb2RlRXJyb3JSZXNwb25zZUhhbmRsZXI6ICgpID0+IGNyZWF0ZVN0YXR1c0NvZGVFcnJvclJlc3BvbnNlSGFuZGxlcixcbiAgZGVsYXk6ICgpID0+IGRlbGF5LFxuICBleHRyYWN0UmVzcG9uc2VIZWFkZXJzOiAoKSA9PiBleHRyYWN0UmVzcG9uc2VIZWFkZXJzLFxuICBnZW5lcmF0ZUlkOiAoKSA9PiBnZW5lcmF0ZUlkLFxuICBnZXRFcnJvck1lc3NhZ2U6ICgpID0+IGdldEVycm9yTWVzc2FnZSxcbiAgZ2V0RnJvbUFwaTogKCkgPT4gZ2V0RnJvbUFwaSxcbiAgaXNBYm9ydEVycm9yOiAoKSA9PiBpc0Fib3J0RXJyb3IsXG4gIGlzUGFyc2FibGVKc29uOiAoKSA9PiBpc1BhcnNhYmxlSnNvbixcbiAgaXNWYWxpZGF0b3I6ICgpID0+IGlzVmFsaWRhdG9yLFxuICBsb2FkQXBpS2V5OiAoKSA9PiBsb2FkQXBpS2V5LFxuICBsb2FkT3B0aW9uYWxTZXR0aW5nOiAoKSA9PiBsb2FkT3B0aW9uYWxTZXR0aW5nLFxuICBsb2FkU2V0dGluZzogKCkgPT4gbG9hZFNldHRpbmcsXG4gIHBhcnNlSlNPTjogKCkgPT4gcGFyc2VKU09OLFxuICBwYXJzZVByb3ZpZGVyT3B0aW9uczogKCkgPT4gcGFyc2VQcm92aWRlck9wdGlvbnMsXG4gIHBvc3RGb3JtRGF0YVRvQXBpOiAoKSA9PiBwb3N0Rm9ybURhdGFUb0FwaSxcbiAgcG9zdEpzb25Ub0FwaTogKCkgPT4gcG9zdEpzb25Ub0FwaSxcbiAgcG9zdFRvQXBpOiAoKSA9PiBwb3N0VG9BcGksXG4gIHJlbW92ZVVuZGVmaW5lZEVudHJpZXM6ICgpID0+IHJlbW92ZVVuZGVmaW5lZEVudHJpZXMsXG4gIHJlc29sdmU6ICgpID0+IHJlc29sdmUsXG4gIHNhZmVQYXJzZUpTT046ICgpID0+IHNhZmVQYXJzZUpTT04sXG4gIHNhZmVWYWxpZGF0ZVR5cGVzOiAoKSA9PiBzYWZlVmFsaWRhdGVUeXBlcyxcbiAgdmFsaWRhdGVUeXBlczogKCkgPT4gdmFsaWRhdGVUeXBlcyxcbiAgdmFsaWRhdG9yOiAoKSA9PiB2YWxpZGF0b3IsXG4gIHZhbGlkYXRvclN5bWJvbDogKCkgPT4gdmFsaWRhdG9yU3ltYm9sLFxuICB3aXRob3V0VHJhaWxpbmdTbGFzaDogKCkgPT4gd2l0aG91dFRyYWlsaW5nU2xhc2gsXG4gIHpvZFZhbGlkYXRvcjogKCkgPT4gem9kVmFsaWRhdG9yXG59KTtcbm1vZHVsZS5leHBvcnRzID0gX190b0NvbW1vbkpTKHNyY19leHBvcnRzKTtcblxuLy8gc3JjL2NvbWJpbmUtaGVhZGVycy50c1xuZnVuY3Rpb24gY29tYmluZUhlYWRlcnMoLi4uaGVhZGVycykge1xuICByZXR1cm4gaGVhZGVycy5yZWR1Y2UoXG4gICAgKGNvbWJpbmVkSGVhZGVycywgY3VycmVudEhlYWRlcnMpID0+ICh7XG4gICAgICAuLi5jb21iaW5lZEhlYWRlcnMsXG4gICAgICAuLi5jdXJyZW50SGVhZGVycyAhPSBudWxsID8gY3VycmVudEhlYWRlcnMgOiB7fVxuICAgIH0pLFxuICAgIHt9XG4gICk7XG59XG5cbi8vIHNyYy9jb252ZXJ0LWFzeW5jLWl0ZXJhdG9yLXRvLXJlYWRhYmxlLXN0cmVhbS50c1xuZnVuY3Rpb24gY29udmVydEFzeW5jSXRlcmF0b3JUb1JlYWRhYmxlU3RyZWFtKGl0ZXJhdG9yKSB7XG4gIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIHRoZSBjb25zdW1lciB3YW50cyB0byBwdWxsIG1vcmUgZGF0YSBmcm9tIHRoZSBzdHJlYW0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8VD59IGNvbnRyb2xsZXIgLSBUaGUgY29udHJvbGxlciB0byBlbnF1ZXVlIGRhdGEgaW50byB0aGUgc3RyZWFtLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgICAqL1xuICAgIGFzeW5jIHB1bGwoY29udHJvbGxlcikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gYXdhaXQgaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb250cm9sbGVyLmVycm9yKGVycm9yKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIHRoZSBjb25zdW1lciBjYW5jZWxzIHRoZSBzdHJlYW0uXG4gICAgICovXG4gICAgY2FuY2VsKCkge1xuICAgIH1cbiAgfSk7XG59XG5cbi8vIHNyYy9kZWxheS50c1xuYXN5bmMgZnVuY3Rpb24gZGVsYXkoZGVsYXlJbk1zKSB7XG4gIHJldHVybiBkZWxheUluTXMgPT0gbnVsbCA/IFByb21pc2UucmVzb2x2ZSgpIDogbmV3IFByb21pc2UoKHJlc29sdmUyKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUyLCBkZWxheUluTXMpKTtcbn1cblxuLy8gc3JjL2V2ZW50LXNvdXJjZS1wYXJzZXItc3RyZWFtLnRzXG5mdW5jdGlvbiBjcmVhdGVFdmVudFNvdXJjZVBhcnNlclN0cmVhbSgpIHtcbiAgbGV0IGJ1ZmZlciA9IFwiXCI7XG4gIGxldCBldmVudCA9IHZvaWQgMDtcbiAgbGV0IGRhdGEgPSBbXTtcbiAgbGV0IGxhc3RFdmVudElkID0gdm9pZCAwO1xuICBsZXQgcmV0cnkgPSB2b2lkIDA7XG4gIGZ1bmN0aW9uIHBhcnNlTGluZShsaW5lLCBjb250cm9sbGVyKSB7XG4gICAgaWYgKGxpbmUgPT09IFwiXCIpIHtcbiAgICAgIGRpc3BhdGNoRXZlbnQoY29udHJvbGxlcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChsaW5lLnN0YXJ0c1dpdGgoXCI6XCIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNvbG9uSW5kZXggPSBsaW5lLmluZGV4T2YoXCI6XCIpO1xuICAgIGlmIChjb2xvbkluZGV4ID09PSAtMSkge1xuICAgICAgaGFuZGxlRmllbGQobGluZSwgXCJcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGZpZWxkID0gbGluZS5zbGljZSgwLCBjb2xvbkluZGV4KTtcbiAgICBjb25zdCB2YWx1ZVN0YXJ0ID0gY29sb25JbmRleCArIDE7XG4gICAgY29uc3QgdmFsdWUgPSB2YWx1ZVN0YXJ0IDwgbGluZS5sZW5ndGggJiYgbGluZVt2YWx1ZVN0YXJ0XSA9PT0gXCIgXCIgPyBsaW5lLnNsaWNlKHZhbHVlU3RhcnQgKyAxKSA6IGxpbmUuc2xpY2UodmFsdWVTdGFydCk7XG4gICAgaGFuZGxlRmllbGQoZmllbGQsIHZhbHVlKTtcbiAgfVxuICBmdW5jdGlvbiBkaXNwYXRjaEV2ZW50KGNvbnRyb2xsZXIpIHtcbiAgICBpZiAoZGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICBldmVudCxcbiAgICAgICAgZGF0YTogZGF0YS5qb2luKFwiXFxuXCIpLFxuICAgICAgICBpZDogbGFzdEV2ZW50SWQsXG4gICAgICAgIHJldHJ5XG4gICAgICB9KTtcbiAgICAgIGRhdGEgPSBbXTtcbiAgICAgIGV2ZW50ID0gdm9pZCAwO1xuICAgICAgcmV0cnkgPSB2b2lkIDA7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGhhbmRsZUZpZWxkKGZpZWxkLCB2YWx1ZSkge1xuICAgIHN3aXRjaCAoZmllbGQpIHtcbiAgICAgIGNhc2UgXCJldmVudFwiOlxuICAgICAgICBldmVudCA9IHZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJkYXRhXCI6XG4gICAgICAgIGRhdGEucHVzaCh2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImlkXCI6XG4gICAgICAgIGxhc3RFdmVudElkID0gdmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInJldHJ5XCI6XG4gICAgICAgIGNvbnN0IHBhcnNlZFJldHJ5ID0gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgICAgICAgaWYgKCFpc05hTihwYXJzZWRSZXRyeSkpIHtcbiAgICAgICAgICByZXRyeSA9IHBhcnNlZFJldHJ5O1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICBjb25zdCB7IGxpbmVzLCBpbmNvbXBsZXRlTGluZSB9ID0gc3BsaXRMaW5lcyhidWZmZXIsIGNodW5rKTtcbiAgICAgIGJ1ZmZlciA9IGluY29tcGxldGVMaW5lO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwYXJzZUxpbmUobGluZXNbaV0sIGNvbnRyb2xsZXIpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZmx1c2goY29udHJvbGxlcikge1xuICAgICAgcGFyc2VMaW5lKGJ1ZmZlciwgY29udHJvbGxlcik7XG4gICAgICBkaXNwYXRjaEV2ZW50KGNvbnRyb2xsZXIpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBzcGxpdExpbmVzKGJ1ZmZlciwgY2h1bmspIHtcbiAgY29uc3QgbGluZXMgPSBbXTtcbiAgbGV0IGN1cnJlbnRMaW5lID0gYnVmZmVyO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNodW5rLmxlbmd0aDsgKSB7XG4gICAgY29uc3QgY2hhciA9IGNodW5rW2krK107XG4gICAgaWYgKGNoYXIgPT09IFwiXFxuXCIpIHtcbiAgICAgIGxpbmVzLnB1c2goY3VycmVudExpbmUpO1xuICAgICAgY3VycmVudExpbmUgPSBcIlwiO1xuICAgIH0gZWxzZSBpZiAoY2hhciA9PT0gXCJcXHJcIikge1xuICAgICAgbGluZXMucHVzaChjdXJyZW50TGluZSk7XG4gICAgICBjdXJyZW50TGluZSA9IFwiXCI7XG4gICAgICBpZiAoY2h1bmtbaSArIDFdID09PSBcIlxcblwiKSB7XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudExpbmUgKz0gY2hhcjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHsgbGluZXMsIGluY29tcGxldGVMaW5lOiBjdXJyZW50TGluZSB9O1xufVxuXG4vLyBzcmMvZXh0cmFjdC1yZXNwb25zZS1oZWFkZXJzLnRzXG5mdW5jdGlvbiBleHRyYWN0UmVzcG9uc2VIZWFkZXJzKHJlc3BvbnNlKSB7XG4gIGNvbnN0IGhlYWRlcnMgPSB7fTtcbiAgcmVzcG9uc2UuaGVhZGVycy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgaGVhZGVyc1trZXldID0gdmFsdWU7XG4gIH0pO1xuICByZXR1cm4gaGVhZGVycztcbn1cblxuLy8gc3JjL2dlbmVyYXRlLWlkLnRzXG52YXIgaW1wb3J0X3Byb3ZpZGVyID0gcmVxdWlyZShcIkBhaS1zZGsvcHJvdmlkZXJcIik7XG52YXIgaW1wb3J0X25vbl9zZWN1cmUgPSByZXF1aXJlKFwibmFub2lkL25vbi1zZWN1cmVcIik7XG52YXIgY3JlYXRlSWRHZW5lcmF0b3IgPSAoe1xuICBwcmVmaXgsXG4gIHNpemU6IGRlZmF1bHRTaXplID0gMTYsXG4gIGFscGhhYmV0ID0gXCIwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5elwiLFxuICBzZXBhcmF0b3IgPSBcIi1cIlxufSA9IHt9KSA9PiB7XG4gIGNvbnN0IGdlbmVyYXRvciA9ICgwLCBpbXBvcnRfbm9uX3NlY3VyZS5jdXN0b21BbHBoYWJldCkoYWxwaGFiZXQsIGRlZmF1bHRTaXplKTtcbiAgaWYgKHByZWZpeCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgfVxuICBpZiAoYWxwaGFiZXQuaW5jbHVkZXMoc2VwYXJhdG9yKSkge1xuICAgIHRocm93IG5ldyBpbXBvcnRfcHJvdmlkZXIuSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgYXJndW1lbnQ6IFwic2VwYXJhdG9yXCIsXG4gICAgICBtZXNzYWdlOiBgVGhlIHNlcGFyYXRvciBcIiR7c2VwYXJhdG9yfVwiIG11c3Qgbm90IGJlIHBhcnQgb2YgdGhlIGFscGhhYmV0IFwiJHthbHBoYWJldH1cIi5gXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIChzaXplKSA9PiBgJHtwcmVmaXh9JHtzZXBhcmF0b3J9JHtnZW5lcmF0b3Ioc2l6ZSl9YDtcbn07XG52YXIgZ2VuZXJhdGVJZCA9IGNyZWF0ZUlkR2VuZXJhdG9yKCk7XG5cbi8vIHNyYy9nZXQtZXJyb3ItbWVzc2FnZS50c1xuZnVuY3Rpb24gZ2V0RXJyb3JNZXNzYWdlKGVycm9yKSB7XG4gIGlmIChlcnJvciA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFwidW5rbm93biBlcnJvclwiO1xuICB9XG4gIGlmICh0eXBlb2YgZXJyb3IgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gZXJyb3I7XG4gIH1cbiAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IubWVzc2FnZTtcbiAgfVxuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZXJyb3IpO1xufVxuXG4vLyBzcmMvZ2V0LWZyb20tYXBpLnRzXG52YXIgaW1wb3J0X3Byb3ZpZGVyMiA9IHJlcXVpcmUoXCJAYWktc2RrL3Byb3ZpZGVyXCIpO1xuXG4vLyBzcmMvcmVtb3ZlLXVuZGVmaW5lZC1lbnRyaWVzLnRzXG5mdW5jdGlvbiByZW1vdmVVbmRlZmluZWRFbnRyaWVzKHJlY29yZCkge1xuICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgIE9iamVjdC5lbnRyaWVzKHJlY29yZCkuZmlsdGVyKChbX2tleSwgdmFsdWVdKSA9PiB2YWx1ZSAhPSBudWxsKVxuICApO1xufVxuXG4vLyBzcmMvaXMtYWJvcnQtZXJyb3IudHNcbmZ1bmN0aW9uIGlzQWJvcnRFcnJvcihlcnJvcikge1xuICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiAoZXJyb3IubmFtZSA9PT0gXCJBYm9ydEVycm9yXCIgfHwgZXJyb3IubmFtZSA9PT0gXCJUaW1lb3V0RXJyb3JcIik7XG59XG5cbi8vIHNyYy9nZXQtZnJvbS1hcGkudHNcbnZhciBnZXRPcmlnaW5hbEZldGNoID0gKCkgPT4gZ2xvYmFsVGhpcy5mZXRjaDtcbnZhciBnZXRGcm9tQXBpID0gYXN5bmMgKHtcbiAgdXJsLFxuICBoZWFkZXJzID0ge30sXG4gIHN1Y2Nlc3NmdWxSZXNwb25zZUhhbmRsZXIsXG4gIGZhaWxlZFJlc3BvbnNlSGFuZGxlcixcbiAgYWJvcnRTaWduYWwsXG4gIGZldGNoID0gZ2V0T3JpZ2luYWxGZXRjaCgpXG59KSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgIGhlYWRlcnM6IHJlbW92ZVVuZGVmaW5lZEVudHJpZXMoaGVhZGVycyksXG4gICAgICBzaWduYWw6IGFib3J0U2lnbmFsXG4gICAgfSk7XG4gICAgY29uc3QgcmVzcG9uc2VIZWFkZXJzID0gZXh0cmFjdFJlc3BvbnNlSGVhZGVycyhyZXNwb25zZSk7XG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgbGV0IGVycm9ySW5mb3JtYXRpb247XG4gICAgICB0cnkge1xuICAgICAgICBlcnJvckluZm9ybWF0aW9uID0gYXdhaXQgZmFpbGVkUmVzcG9uc2VIYW5kbGVyKHtcbiAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICB1cmwsXG4gICAgICAgICAgcmVxdWVzdEJvZHlWYWx1ZXM6IHt9XG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGlzQWJvcnRFcnJvcihlcnJvcikgfHwgaW1wb3J0X3Byb3ZpZGVyMi5BUElDYWxsRXJyb3IuaXNJbnN0YW5jZShlcnJvcikpIHtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgaW1wb3J0X3Byb3ZpZGVyMi5BUElDYWxsRXJyb3Ioe1xuICAgICAgICAgIG1lc3NhZ2U6IFwiRmFpbGVkIHRvIHByb2Nlc3MgZXJyb3IgcmVzcG9uc2VcIixcbiAgICAgICAgICBjYXVzZTogZXJyb3IsXG4gICAgICAgICAgc3RhdHVzQ29kZTogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgIHVybCxcbiAgICAgICAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgICAgICAgcmVxdWVzdEJvZHlWYWx1ZXM6IHt9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdGhyb3cgZXJyb3JJbmZvcm1hdGlvbi52YWx1ZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCBzdWNjZXNzZnVsUmVzcG9uc2VIYW5kbGVyKHtcbiAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgIHVybCxcbiAgICAgICAgcmVxdWVzdEJvZHlWYWx1ZXM6IHt9XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgaWYgKGlzQWJvcnRFcnJvcihlcnJvcikgfHwgaW1wb3J0X3Byb3ZpZGVyMi5BUElDYWxsRXJyb3IuaXNJbnN0YW5jZShlcnJvcikpIHtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IGltcG9ydF9wcm92aWRlcjIuQVBJQ2FsbEVycm9yKHtcbiAgICAgICAgbWVzc2FnZTogXCJGYWlsZWQgdG8gcHJvY2VzcyBzdWNjZXNzZnVsIHJlc3BvbnNlXCIsXG4gICAgICAgIGNhdXNlOiBlcnJvcixcbiAgICAgICAgc3RhdHVzQ29kZTogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICB1cmwsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICAgICAgcmVxdWVzdEJvZHlWYWx1ZXM6IHt9XG4gICAgICB9KTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKGlzQWJvcnRFcnJvcihlcnJvcikpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBUeXBlRXJyb3IgJiYgZXJyb3IubWVzc2FnZSA9PT0gXCJmZXRjaCBmYWlsZWRcIikge1xuICAgICAgY29uc3QgY2F1c2UgPSBlcnJvci5jYXVzZTtcbiAgICAgIGlmIChjYXVzZSAhPSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBpbXBvcnRfcHJvdmlkZXIyLkFQSUNhbGxFcnJvcih7XG4gICAgICAgICAgbWVzc2FnZTogYENhbm5vdCBjb25uZWN0IHRvIEFQSTogJHtjYXVzZS5tZXNzYWdlfWAsXG4gICAgICAgICAgY2F1c2UsXG4gICAgICAgICAgdXJsLFxuICAgICAgICAgIGlzUmV0cnlhYmxlOiB0cnVlLFxuICAgICAgICAgIHJlcXVlc3RCb2R5VmFsdWVzOiB7fVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG5cbi8vIHNyYy9sb2FkLWFwaS1rZXkudHNcbnZhciBpbXBvcnRfcHJvdmlkZXIzID0gcmVxdWlyZShcIkBhaS1zZGsvcHJvdmlkZXJcIik7XG5mdW5jdGlvbiBsb2FkQXBpS2V5KHtcbiAgYXBpS2V5LFxuICBlbnZpcm9ubWVudFZhcmlhYmxlTmFtZSxcbiAgYXBpS2V5UGFyYW1ldGVyTmFtZSA9IFwiYXBpS2V5XCIsXG4gIGRlc2NyaXB0aW9uXG59KSB7XG4gIGlmICh0eXBlb2YgYXBpS2V5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGFwaUtleTtcbiAgfVxuICBpZiAoYXBpS2V5ICE9IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgaW1wb3J0X3Byb3ZpZGVyMy5Mb2FkQVBJS2V5RXJyb3Ioe1xuICAgICAgbWVzc2FnZTogYCR7ZGVzY3JpcHRpb259IEFQSSBrZXkgbXVzdCBiZSBhIHN0cmluZy5gXG4gICAgfSk7XG4gIH1cbiAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IGltcG9ydF9wcm92aWRlcjMuTG9hZEFQSUtleUVycm9yKHtcbiAgICAgIG1lc3NhZ2U6IGAke2Rlc2NyaXB0aW9ufSBBUEkga2V5IGlzIG1pc3NpbmcuIFBhc3MgaXQgdXNpbmcgdGhlICcke2FwaUtleVBhcmFtZXRlck5hbWV9JyBwYXJhbWV0ZXIuIEVudmlyb25tZW50IHZhcmlhYmxlcyBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgZW52aXJvbm1lbnQuYFxuICAgIH0pO1xuICB9XG4gIGFwaUtleSA9IHByb2Nlc3MuZW52W2Vudmlyb25tZW50VmFyaWFibGVOYW1lXTtcbiAgaWYgKGFwaUtleSA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IGltcG9ydF9wcm92aWRlcjMuTG9hZEFQSUtleUVycm9yKHtcbiAgICAgIG1lc3NhZ2U6IGAke2Rlc2NyaXB0aW9ufSBBUEkga2V5IGlzIG1pc3NpbmcuIFBhc3MgaXQgdXNpbmcgdGhlICcke2FwaUtleVBhcmFtZXRlck5hbWV9JyBwYXJhbWV0ZXIgb3IgdGhlICR7ZW52aXJvbm1lbnRWYXJpYWJsZU5hbWV9IGVudmlyb25tZW50IHZhcmlhYmxlLmBcbiAgICB9KTtcbiAgfVxuICBpZiAodHlwZW9mIGFwaUtleSAhPT0gXCJzdHJpbmdcIikge1xuICAgIHRocm93IG5ldyBpbXBvcnRfcHJvdmlkZXIzLkxvYWRBUElLZXlFcnJvcih7XG4gICAgICBtZXNzYWdlOiBgJHtkZXNjcmlwdGlvbn0gQVBJIGtleSBtdXN0IGJlIGEgc3RyaW5nLiBUaGUgdmFsdWUgb2YgdGhlICR7ZW52aXJvbm1lbnRWYXJpYWJsZU5hbWV9IGVudmlyb25tZW50IHZhcmlhYmxlIGlzIG5vdCBhIHN0cmluZy5gXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGFwaUtleTtcbn1cblxuLy8gc3JjL2xvYWQtb3B0aW9uYWwtc2V0dGluZy50c1xuZnVuY3Rpb24gbG9hZE9wdGlvbmFsU2V0dGluZyh7XG4gIHNldHRpbmdWYWx1ZSxcbiAgZW52aXJvbm1lbnRWYXJpYWJsZU5hbWVcbn0pIHtcbiAgaWYgKHR5cGVvZiBzZXR0aW5nVmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gc2V0dGluZ1ZhbHVlO1xuICB9XG4gIGlmIChzZXR0aW5nVmFsdWUgIT0gbnVsbCB8fCB0eXBlb2YgcHJvY2VzcyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgc2V0dGluZ1ZhbHVlID0gcHJvY2Vzcy5lbnZbZW52aXJvbm1lbnRWYXJpYWJsZU5hbWVdO1xuICBpZiAoc2V0dGluZ1ZhbHVlID09IG51bGwgfHwgdHlwZW9mIHNldHRpbmdWYWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgcmV0dXJuIHNldHRpbmdWYWx1ZTtcbn1cblxuLy8gc3JjL2xvYWQtc2V0dGluZy50c1xudmFyIGltcG9ydF9wcm92aWRlcjQgPSByZXF1aXJlKFwiQGFpLXNkay9wcm92aWRlclwiKTtcbmZ1bmN0aW9uIGxvYWRTZXR0aW5nKHtcbiAgc2V0dGluZ1ZhbHVlLFxuICBlbnZpcm9ubWVudFZhcmlhYmxlTmFtZSxcbiAgc2V0dGluZ05hbWUsXG4gIGRlc2NyaXB0aW9uXG59KSB7XG4gIGlmICh0eXBlb2Ygc2V0dGluZ1ZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIHNldHRpbmdWYWx1ZTtcbiAgfVxuICBpZiAoc2V0dGluZ1ZhbHVlICE9IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgaW1wb3J0X3Byb3ZpZGVyNC5Mb2FkU2V0dGluZ0Vycm9yKHtcbiAgICAgIG1lc3NhZ2U6IGAke2Rlc2NyaXB0aW9ufSBzZXR0aW5nIG11c3QgYmUgYSBzdHJpbmcuYFxuICAgIH0pO1xuICB9XG4gIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHRocm93IG5ldyBpbXBvcnRfcHJvdmlkZXI0LkxvYWRTZXR0aW5nRXJyb3Ioe1xuICAgICAgbWVzc2FnZTogYCR7ZGVzY3JpcHRpb259IHNldHRpbmcgaXMgbWlzc2luZy4gUGFzcyBpdCB1c2luZyB0aGUgJyR7c2V0dGluZ05hbWV9JyBwYXJhbWV0ZXIuIEVudmlyb25tZW50IHZhcmlhYmxlcyBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgZW52aXJvbm1lbnQuYFxuICAgIH0pO1xuICB9XG4gIHNldHRpbmdWYWx1ZSA9IHByb2Nlc3MuZW52W2Vudmlyb25tZW50VmFyaWFibGVOYW1lXTtcbiAgaWYgKHNldHRpbmdWYWx1ZSA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IGltcG9ydF9wcm92aWRlcjQuTG9hZFNldHRpbmdFcnJvcih7XG4gICAgICBtZXNzYWdlOiBgJHtkZXNjcmlwdGlvbn0gc2V0dGluZyBpcyBtaXNzaW5nLiBQYXNzIGl0IHVzaW5nIHRoZSAnJHtzZXR0aW5nTmFtZX0nIHBhcmFtZXRlciBvciB0aGUgJHtlbnZpcm9ubWVudFZhcmlhYmxlTmFtZX0gZW52aXJvbm1lbnQgdmFyaWFibGUuYFxuICAgIH0pO1xuICB9XG4gIGlmICh0eXBlb2Ygc2V0dGluZ1ZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgdGhyb3cgbmV3IGltcG9ydF9wcm92aWRlcjQuTG9hZFNldHRpbmdFcnJvcih7XG4gICAgICBtZXNzYWdlOiBgJHtkZXNjcmlwdGlvbn0gc2V0dGluZyBtdXN0IGJlIGEgc3RyaW5nLiBUaGUgdmFsdWUgb2YgdGhlICR7ZW52aXJvbm1lbnRWYXJpYWJsZU5hbWV9IGVudmlyb25tZW50IHZhcmlhYmxlIGlzIG5vdCBhIHN0cmluZy5gXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHNldHRpbmdWYWx1ZTtcbn1cblxuLy8gc3JjL3BhcnNlLWpzb24udHNcbnZhciBpbXBvcnRfcHJvdmlkZXI2ID0gcmVxdWlyZShcIkBhaS1zZGsvcHJvdmlkZXJcIik7XG52YXIgaW1wb3J0X3NlY3VyZV9qc29uX3BhcnNlID0gX190b0VTTShyZXF1aXJlKFwic2VjdXJlLWpzb24tcGFyc2VcIikpO1xuXG4vLyBzcmMvdmFsaWRhdGUtdHlwZXMudHNcbnZhciBpbXBvcnRfcHJvdmlkZXI1ID0gcmVxdWlyZShcIkBhaS1zZGsvcHJvdmlkZXJcIik7XG5cbi8vIHNyYy92YWxpZGF0b3IudHNcbnZhciB2YWxpZGF0b3JTeW1ib2wgPSBTeW1ib2wuZm9yKFwidmVyY2VsLmFpLnZhbGlkYXRvclwiKTtcbmZ1bmN0aW9uIHZhbGlkYXRvcih2YWxpZGF0ZSkge1xuICByZXR1cm4geyBbdmFsaWRhdG9yU3ltYm9sXTogdHJ1ZSwgdmFsaWRhdGUgfTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRhdG9yKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGwgJiYgdmFsaWRhdG9yU3ltYm9sIGluIHZhbHVlICYmIHZhbHVlW3ZhbGlkYXRvclN5bWJvbF0gPT09IHRydWUgJiYgXCJ2YWxpZGF0ZVwiIGluIHZhbHVlO1xufVxuZnVuY3Rpb24gYXNWYWxpZGF0b3IodmFsdWUpIHtcbiAgcmV0dXJuIGlzVmFsaWRhdG9yKHZhbHVlKSA/IHZhbHVlIDogem9kVmFsaWRhdG9yKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIHpvZFZhbGlkYXRvcih6b2RTY2hlbWEpIHtcbiAgcmV0dXJuIHZhbGlkYXRvcigodmFsdWUpID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSB6b2RTY2hlbWEuc2FmZVBhcnNlKHZhbHVlKTtcbiAgICByZXR1cm4gcmVzdWx0LnN1Y2Nlc3MgPyB7IHN1Y2Nlc3M6IHRydWUsIHZhbHVlOiByZXN1bHQuZGF0YSB9IDogeyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IHJlc3VsdC5lcnJvciB9O1xuICB9KTtcbn1cblxuLy8gc3JjL3ZhbGlkYXRlLXR5cGVzLnRzXG5mdW5jdGlvbiB2YWxpZGF0ZVR5cGVzKHtcbiAgdmFsdWUsXG4gIHNjaGVtYTogaW5wdXRTY2hlbWFcbn0pIHtcbiAgY29uc3QgcmVzdWx0ID0gc2FmZVZhbGlkYXRlVHlwZXMoeyB2YWx1ZSwgc2NoZW1hOiBpbnB1dFNjaGVtYSB9KTtcbiAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgIHRocm93IGltcG9ydF9wcm92aWRlcjUuVHlwZVZhbGlkYXRpb25FcnJvci53cmFwKHsgdmFsdWUsIGNhdXNlOiByZXN1bHQuZXJyb3IgfSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdC52YWx1ZTtcbn1cbmZ1bmN0aW9uIHNhZmVWYWxpZGF0ZVR5cGVzKHtcbiAgdmFsdWUsXG4gIHNjaGVtYVxufSkge1xuICBjb25zdCB2YWxpZGF0b3IyID0gYXNWYWxpZGF0b3Ioc2NoZW1hKTtcbiAgdHJ5IHtcbiAgICBpZiAodmFsaWRhdG9yMi52YWxpZGF0ZSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCB2YWx1ZSB9O1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSB2YWxpZGF0b3IyLnZhbGlkYXRlKHZhbHVlKTtcbiAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgIGVycm9yOiBpbXBvcnRfcHJvdmlkZXI1LlR5cGVWYWxpZGF0aW9uRXJyb3Iud3JhcCh7IHZhbHVlLCBjYXVzZTogcmVzdWx0LmVycm9yIH0pXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICBlcnJvcjogaW1wb3J0X3Byb3ZpZGVyNS5UeXBlVmFsaWRhdGlvbkVycm9yLndyYXAoeyB2YWx1ZSwgY2F1c2U6IGVycm9yIH0pXG4gICAgfTtcbiAgfVxufVxuXG4vLyBzcmMvcGFyc2UtanNvbi50c1xuZnVuY3Rpb24gcGFyc2VKU09OKHtcbiAgdGV4dCxcbiAgc2NoZW1hXG59KSB7XG4gIHRyeSB7XG4gICAgY29uc3QgdmFsdWUgPSBpbXBvcnRfc2VjdXJlX2pzb25fcGFyc2UuZGVmYXVsdC5wYXJzZSh0ZXh0KTtcbiAgICBpZiAoc2NoZW1hID09IG51bGwpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbGlkYXRlVHlwZXMoeyB2YWx1ZSwgc2NoZW1hIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChpbXBvcnRfcHJvdmlkZXI2LkpTT05QYXJzZUVycm9yLmlzSW5zdGFuY2UoZXJyb3IpIHx8IGltcG9ydF9wcm92aWRlcjYuVHlwZVZhbGlkYXRpb25FcnJvci5pc0luc3RhbmNlKGVycm9yKSkge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIHRocm93IG5ldyBpbXBvcnRfcHJvdmlkZXI2LkpTT05QYXJzZUVycm9yKHsgdGV4dCwgY2F1c2U6IGVycm9yIH0pO1xuICB9XG59XG5mdW5jdGlvbiBzYWZlUGFyc2VKU09OKHtcbiAgdGV4dCxcbiAgc2NoZW1hXG59KSB7XG4gIHRyeSB7XG4gICAgY29uc3QgdmFsdWUgPSBpbXBvcnRfc2VjdXJlX2pzb25fcGFyc2UuZGVmYXVsdC5wYXJzZSh0ZXh0KTtcbiAgICBpZiAoc2NoZW1hID09IG51bGwpIHtcbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIHZhbHVlLCByYXdWYWx1ZTogdmFsdWUgfTtcbiAgICB9XG4gICAgY29uc3QgdmFsaWRhdGlvblJlc3VsdCA9IHNhZmVWYWxpZGF0ZVR5cGVzKHsgdmFsdWUsIHNjaGVtYSB9KTtcbiAgICByZXR1cm4gdmFsaWRhdGlvblJlc3VsdC5zdWNjZXNzID8geyAuLi52YWxpZGF0aW9uUmVzdWx0LCByYXdWYWx1ZTogdmFsdWUgfSA6IHZhbGlkYXRpb25SZXN1bHQ7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgZXJyb3I6IGltcG9ydF9wcm92aWRlcjYuSlNPTlBhcnNlRXJyb3IuaXNJbnN0YW5jZShlcnJvcikgPyBlcnJvciA6IG5ldyBpbXBvcnRfcHJvdmlkZXI2LkpTT05QYXJzZUVycm9yKHsgdGV4dCwgY2F1c2U6IGVycm9yIH0pXG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gaXNQYXJzYWJsZUpzb24oaW5wdXQpIHtcbiAgdHJ5IHtcbiAgICBpbXBvcnRfc2VjdXJlX2pzb25fcGFyc2UuZGVmYXVsdC5wYXJzZShpbnB1dCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLy8gc3JjL3BhcnNlLXByb3ZpZGVyLW9wdGlvbnMudHNcbnZhciBpbXBvcnRfcHJvdmlkZXI3ID0gcmVxdWlyZShcIkBhaS1zZGsvcHJvdmlkZXJcIik7XG5mdW5jdGlvbiBwYXJzZVByb3ZpZGVyT3B0aW9ucyh7XG4gIHByb3ZpZGVyLFxuICBwcm92aWRlck9wdGlvbnMsXG4gIHNjaGVtYVxufSkge1xuICBpZiAoKHByb3ZpZGVyT3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogcHJvdmlkZXJPcHRpb25zW3Byb3ZpZGVyXSkgPT0gbnVsbCkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgY29uc3QgcGFyc2VkUHJvdmlkZXJPcHRpb25zID0gc2FmZVZhbGlkYXRlVHlwZXMoe1xuICAgIHZhbHVlOiBwcm92aWRlck9wdGlvbnNbcHJvdmlkZXJdLFxuICAgIHNjaGVtYVxuICB9KTtcbiAgaWYgKCFwYXJzZWRQcm92aWRlck9wdGlvbnMuc3VjY2Vzcykge1xuICAgIHRocm93IG5ldyBpbXBvcnRfcHJvdmlkZXI3LkludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgIGFyZ3VtZW50OiBcInByb3ZpZGVyT3B0aW9uc1wiLFxuICAgICAgbWVzc2FnZTogYGludmFsaWQgJHtwcm92aWRlcn0gcHJvdmlkZXIgb3B0aW9uc2AsXG4gICAgICBjYXVzZTogcGFyc2VkUHJvdmlkZXJPcHRpb25zLmVycm9yXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHBhcnNlZFByb3ZpZGVyT3B0aW9ucy52YWx1ZTtcbn1cblxuLy8gc3JjL3Bvc3QtdG8tYXBpLnRzXG52YXIgaW1wb3J0X3Byb3ZpZGVyOCA9IHJlcXVpcmUoXCJAYWktc2RrL3Byb3ZpZGVyXCIpO1xudmFyIGdldE9yaWdpbmFsRmV0Y2gyID0gKCkgPT4gZ2xvYmFsVGhpcy5mZXRjaDtcbnZhciBwb3N0SnNvblRvQXBpID0gYXN5bmMgKHtcbiAgdXJsLFxuICBoZWFkZXJzLFxuICBib2R5LFxuICBmYWlsZWRSZXNwb25zZUhhbmRsZXIsXG4gIHN1Y2Nlc3NmdWxSZXNwb25zZUhhbmRsZXIsXG4gIGFib3J0U2lnbmFsLFxuICBmZXRjaFxufSkgPT4gcG9zdFRvQXBpKHtcbiAgdXJsLFxuICBoZWFkZXJzOiB7XG4gICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgLi4uaGVhZGVyc1xuICB9LFxuICBib2R5OiB7XG4gICAgY29udGVudDogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgdmFsdWVzOiBib2R5XG4gIH0sXG4gIGZhaWxlZFJlc3BvbnNlSGFuZGxlcixcbiAgc3VjY2Vzc2Z1bFJlc3BvbnNlSGFuZGxlcixcbiAgYWJvcnRTaWduYWwsXG4gIGZldGNoXG59KTtcbnZhciBwb3N0Rm9ybURhdGFUb0FwaSA9IGFzeW5jICh7XG4gIHVybCxcbiAgaGVhZGVycyxcbiAgZm9ybURhdGEsXG4gIGZhaWxlZFJlc3BvbnNlSGFuZGxlcixcbiAgc3VjY2Vzc2Z1bFJlc3BvbnNlSGFuZGxlcixcbiAgYWJvcnRTaWduYWwsXG4gIGZldGNoXG59KSA9PiBwb3N0VG9BcGkoe1xuICB1cmwsXG4gIGhlYWRlcnMsXG4gIGJvZHk6IHtcbiAgICBjb250ZW50OiBmb3JtRGF0YSxcbiAgICB2YWx1ZXM6IE9iamVjdC5mcm9tRW50cmllcyhmb3JtRGF0YS5lbnRyaWVzKCkpXG4gIH0sXG4gIGZhaWxlZFJlc3BvbnNlSGFuZGxlcixcbiAgc3VjY2Vzc2Z1bFJlc3BvbnNlSGFuZGxlcixcbiAgYWJvcnRTaWduYWwsXG4gIGZldGNoXG59KTtcbnZhciBwb3N0VG9BcGkgPSBhc3luYyAoe1xuICB1cmwsXG4gIGhlYWRlcnMgPSB7fSxcbiAgYm9keSxcbiAgc3VjY2Vzc2Z1bFJlc3BvbnNlSGFuZGxlcixcbiAgZmFpbGVkUmVzcG9uc2VIYW5kbGVyLFxuICBhYm9ydFNpZ25hbCxcbiAgZmV0Y2ggPSBnZXRPcmlnaW5hbEZldGNoMigpXG59KSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBoZWFkZXJzOiByZW1vdmVVbmRlZmluZWRFbnRyaWVzKGhlYWRlcnMpLFxuICAgICAgYm9keTogYm9keS5jb250ZW50LFxuICAgICAgc2lnbmFsOiBhYm9ydFNpZ25hbFxuICAgIH0pO1xuICAgIGNvbnN0IHJlc3BvbnNlSGVhZGVycyA9IGV4dHJhY3RSZXNwb25zZUhlYWRlcnMocmVzcG9uc2UpO1xuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIGxldCBlcnJvckluZm9ybWF0aW9uO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZXJyb3JJbmZvcm1hdGlvbiA9IGF3YWl0IGZhaWxlZFJlc3BvbnNlSGFuZGxlcih7XG4gICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgdXJsLFxuICAgICAgICAgIHJlcXVlc3RCb2R5VmFsdWVzOiBib2R5LnZhbHVlc1xuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChpc0Fib3J0RXJyb3IoZXJyb3IpIHx8IGltcG9ydF9wcm92aWRlcjguQVBJQ2FsbEVycm9yLmlzSW5zdGFuY2UoZXJyb3IpKSB7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IGltcG9ydF9wcm92aWRlcjguQVBJQ2FsbEVycm9yKHtcbiAgICAgICAgICBtZXNzYWdlOiBcIkZhaWxlZCB0byBwcm9jZXNzIGVycm9yIHJlc3BvbnNlXCIsXG4gICAgICAgICAgY2F1c2U6IGVycm9yLFxuICAgICAgICAgIHN0YXR1c0NvZGU6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgICB1cmwsXG4gICAgICAgICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgICAgIHJlcXVlc3RCb2R5VmFsdWVzOiBib2R5LnZhbHVlc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRocm93IGVycm9ySW5mb3JtYXRpb24udmFsdWU7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgc3VjY2Vzc2Z1bFJlc3BvbnNlSGFuZGxlcih7XG4gICAgICAgIHJlc3BvbnNlLFxuICAgICAgICB1cmwsXG4gICAgICAgIHJlcXVlc3RCb2R5VmFsdWVzOiBib2R5LnZhbHVlc1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIGlmIChpc0Fib3J0RXJyb3IoZXJyb3IpIHx8IGltcG9ydF9wcm92aWRlcjguQVBJQ2FsbEVycm9yLmlzSW5zdGFuY2UoZXJyb3IpKSB7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBpbXBvcnRfcHJvdmlkZXI4LkFQSUNhbGxFcnJvcih7XG4gICAgICAgIG1lc3NhZ2U6IFwiRmFpbGVkIHRvIHByb2Nlc3Mgc3VjY2Vzc2Z1bCByZXNwb25zZVwiLFxuICAgICAgICBjYXVzZTogZXJyb3IsXG4gICAgICAgIHN0YXR1c0NvZGU6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgdXJsLFxuICAgICAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgICAgIHJlcXVlc3RCb2R5VmFsdWVzOiBib2R5LnZhbHVlc1xuICAgICAgfSk7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChpc0Fib3J0RXJyb3IoZXJyb3IpKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgVHlwZUVycm9yICYmIGVycm9yLm1lc3NhZ2UgPT09IFwiZmV0Y2ggZmFpbGVkXCIpIHtcbiAgICAgIGNvbnN0IGNhdXNlID0gZXJyb3IuY2F1c2U7XG4gICAgICBpZiAoY2F1c2UgIT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgaW1wb3J0X3Byb3ZpZGVyOC5BUElDYWxsRXJyb3Ioe1xuICAgICAgICAgIG1lc3NhZ2U6IGBDYW5ub3QgY29ubmVjdCB0byBBUEk6ICR7Y2F1c2UubWVzc2FnZX1gLFxuICAgICAgICAgIGNhdXNlLFxuICAgICAgICAgIHVybCxcbiAgICAgICAgICByZXF1ZXN0Qm9keVZhbHVlczogYm9keS52YWx1ZXMsXG4gICAgICAgICAgaXNSZXRyeWFibGU6IHRydWVcbiAgICAgICAgICAvLyByZXRyeSB3aGVuIG5ldHdvcmsgZXJyb3JcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRocm93IGVycm9yO1xuICB9XG59O1xuXG4vLyBzcmMvcmVzb2x2ZS50c1xuYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZSh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB2YWx1ZSA9IHZhbHVlKCk7XG4gIH1cbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZSk7XG59XG5cbi8vIHNyYy9yZXNwb25zZS1oYW5kbGVyLnRzXG52YXIgaW1wb3J0X3Byb3ZpZGVyOSA9IHJlcXVpcmUoXCJAYWktc2RrL3Byb3ZpZGVyXCIpO1xudmFyIGNyZWF0ZUpzb25FcnJvclJlc3BvbnNlSGFuZGxlciA9ICh7XG4gIGVycm9yU2NoZW1hLFxuICBlcnJvclRvTWVzc2FnZSxcbiAgaXNSZXRyeWFibGVcbn0pID0+IGFzeW5jICh7IHJlc3BvbnNlLCB1cmwsIHJlcXVlc3RCb2R5VmFsdWVzIH0pID0+IHtcbiAgY29uc3QgcmVzcG9uc2VCb2R5ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICBjb25zdCByZXNwb25zZUhlYWRlcnMgPSBleHRyYWN0UmVzcG9uc2VIZWFkZXJzKHJlc3BvbnNlKTtcbiAgaWYgKHJlc3BvbnNlQm9keS50cmltKCkgPT09IFwiXCIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgdmFsdWU6IG5ldyBpbXBvcnRfcHJvdmlkZXI5LkFQSUNhbGxFcnJvcih7XG4gICAgICAgIG1lc3NhZ2U6IHJlc3BvbnNlLnN0YXR1c1RleHQsXG4gICAgICAgIHVybCxcbiAgICAgICAgcmVxdWVzdEJvZHlWYWx1ZXMsXG4gICAgICAgIHN0YXR1c0NvZGU6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgICByZXNwb25zZUJvZHksXG4gICAgICAgIGlzUmV0cnlhYmxlOiBpc1JldHJ5YWJsZSA9PSBudWxsID8gdm9pZCAwIDogaXNSZXRyeWFibGUocmVzcG9uc2UpXG4gICAgICB9KVxuICAgIH07XG4gIH1cbiAgdHJ5IHtcbiAgICBjb25zdCBwYXJzZWRFcnJvciA9IHBhcnNlSlNPTih7XG4gICAgICB0ZXh0OiByZXNwb25zZUJvZHksXG4gICAgICBzY2hlbWE6IGVycm9yU2NoZW1hXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICAgIHZhbHVlOiBuZXcgaW1wb3J0X3Byb3ZpZGVyOS5BUElDYWxsRXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOiBlcnJvclRvTWVzc2FnZShwYXJzZWRFcnJvciksXG4gICAgICAgIHVybCxcbiAgICAgICAgcmVxdWVzdEJvZHlWYWx1ZXMsXG4gICAgICAgIHN0YXR1c0NvZGU6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgICByZXNwb25zZUJvZHksXG4gICAgICAgIGRhdGE6IHBhcnNlZEVycm9yLFxuICAgICAgICBpc1JldHJ5YWJsZTogaXNSZXRyeWFibGUgPT0gbnVsbCA/IHZvaWQgMCA6IGlzUmV0cnlhYmxlKHJlc3BvbnNlLCBwYXJzZWRFcnJvcilcbiAgICAgIH0pXG4gICAgfTtcbiAgfSBjYXRjaCAocGFyc2VFcnJvcikge1xuICAgIHJldHVybiB7XG4gICAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgICB2YWx1ZTogbmV3IGltcG9ydF9wcm92aWRlcjkuQVBJQ2FsbEVycm9yKHtcbiAgICAgICAgbWVzc2FnZTogcmVzcG9uc2Uuc3RhdHVzVGV4dCxcbiAgICAgICAgdXJsLFxuICAgICAgICByZXF1ZXN0Qm9keVZhbHVlcyxcbiAgICAgICAgc3RhdHVzQ29kZTogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgICAgIHJlc3BvbnNlQm9keSxcbiAgICAgICAgaXNSZXRyeWFibGU6IGlzUmV0cnlhYmxlID09IG51bGwgPyB2b2lkIDAgOiBpc1JldHJ5YWJsZShyZXNwb25zZSlcbiAgICAgIH0pXG4gICAgfTtcbiAgfVxufTtcbnZhciBjcmVhdGVFdmVudFNvdXJjZVJlc3BvbnNlSGFuZGxlciA9IChjaHVua1NjaGVtYSkgPT4gYXN5bmMgKHsgcmVzcG9uc2UgfSkgPT4ge1xuICBjb25zdCByZXNwb25zZUhlYWRlcnMgPSBleHRyYWN0UmVzcG9uc2VIZWFkZXJzKHJlc3BvbnNlKTtcbiAgaWYgKHJlc3BvbnNlLmJvZHkgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBpbXBvcnRfcHJvdmlkZXI5LkVtcHR5UmVzcG9uc2VCb2R5RXJyb3Ioe30pO1xuICB9XG4gIHJldHVybiB7XG4gICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgIHZhbHVlOiByZXNwb25zZS5ib2R5LnBpcGVUaHJvdWdoKG5ldyBUZXh0RGVjb2RlclN0cmVhbSgpKS5waXBlVGhyb3VnaChjcmVhdGVFdmVudFNvdXJjZVBhcnNlclN0cmVhbSgpKS5waXBlVGhyb3VnaChcbiAgICAgIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgICB0cmFuc2Zvcm0oeyBkYXRhIH0sIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICBpZiAoZGF0YSA9PT0gXCJbRE9ORV1cIikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgICBzYWZlUGFyc2VKU09OKHtcbiAgICAgICAgICAgICAgdGV4dDogZGF0YSxcbiAgICAgICAgICAgICAgc2NoZW1hOiBjaHVua1NjaGVtYVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgIClcbiAgfTtcbn07XG52YXIgY3JlYXRlSnNvblN0cmVhbVJlc3BvbnNlSGFuZGxlciA9IChjaHVua1NjaGVtYSkgPT4gYXN5bmMgKHsgcmVzcG9uc2UgfSkgPT4ge1xuICBjb25zdCByZXNwb25zZUhlYWRlcnMgPSBleHRyYWN0UmVzcG9uc2VIZWFkZXJzKHJlc3BvbnNlKTtcbiAgaWYgKHJlc3BvbnNlLmJvZHkgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBpbXBvcnRfcHJvdmlkZXI5LkVtcHR5UmVzcG9uc2VCb2R5RXJyb3Ioe30pO1xuICB9XG4gIGxldCBidWZmZXIgPSBcIlwiO1xuICByZXR1cm4ge1xuICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICB2YWx1ZTogcmVzcG9uc2UuYm9keS5waXBlVGhyb3VnaChuZXcgVGV4dERlY29kZXJTdHJlYW0oKSkucGlwZVRocm91Z2goXG4gICAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgICAgdHJhbnNmb3JtKGNodW5rVGV4dCwgY29udHJvbGxlcikge1xuICAgICAgICAgIGlmIChjaHVua1RleHQuZW5kc1dpdGgoXCJcXG5cIikpIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICAgICAgc2FmZVBhcnNlSlNPTih7XG4gICAgICAgICAgICAgICAgdGV4dDogYnVmZmVyICsgY2h1bmtUZXh0LFxuICAgICAgICAgICAgICAgIHNjaGVtYTogY2h1bmtTY2hlbWFcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBidWZmZXIgPSBcIlwiO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBidWZmZXIgKz0gY2h1bmtUZXh0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApXG4gIH07XG59O1xudmFyIGNyZWF0ZUpzb25SZXNwb25zZUhhbmRsZXIgPSAocmVzcG9uc2VTY2hlbWEpID0+IGFzeW5jICh7IHJlc3BvbnNlLCB1cmwsIHJlcXVlc3RCb2R5VmFsdWVzIH0pID0+IHtcbiAgY29uc3QgcmVzcG9uc2VCb2R5ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICBjb25zdCBwYXJzZWRSZXN1bHQgPSBzYWZlUGFyc2VKU09OKHtcbiAgICB0ZXh0OiByZXNwb25zZUJvZHksXG4gICAgc2NoZW1hOiByZXNwb25zZVNjaGVtYVxuICB9KTtcbiAgY29uc3QgcmVzcG9uc2VIZWFkZXJzID0gZXh0cmFjdFJlc3BvbnNlSGVhZGVycyhyZXNwb25zZSk7XG4gIGlmICghcGFyc2VkUmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICB0aHJvdyBuZXcgaW1wb3J0X3Byb3ZpZGVyOS5BUElDYWxsRXJyb3Ioe1xuICAgICAgbWVzc2FnZTogXCJJbnZhbGlkIEpTT04gcmVzcG9uc2VcIixcbiAgICAgIGNhdXNlOiBwYXJzZWRSZXN1bHQuZXJyb3IsXG4gICAgICBzdGF0dXNDb2RlOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgICByZXNwb25zZUJvZHksXG4gICAgICB1cmwsXG4gICAgICByZXF1ZXN0Qm9keVZhbHVlc1xuICAgIH0pO1xuICB9XG4gIHJldHVybiB7XG4gICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgIHZhbHVlOiBwYXJzZWRSZXN1bHQudmFsdWUsXG4gICAgcmF3VmFsdWU6IHBhcnNlZFJlc3VsdC5yYXdWYWx1ZVxuICB9O1xufTtcbnZhciBjcmVhdGVCaW5hcnlSZXNwb25zZUhhbmRsZXIgPSAoKSA9PiBhc3luYyAoeyByZXNwb25zZSwgdXJsLCByZXF1ZXN0Qm9keVZhbHVlcyB9KSA9PiB7XG4gIGNvbnN0IHJlc3BvbnNlSGVhZGVycyA9IGV4dHJhY3RSZXNwb25zZUhlYWRlcnMocmVzcG9uc2UpO1xuICBpZiAoIXJlc3BvbnNlLmJvZHkpIHtcbiAgICB0aHJvdyBuZXcgaW1wb3J0X3Byb3ZpZGVyOS5BUElDYWxsRXJyb3Ioe1xuICAgICAgbWVzc2FnZTogXCJSZXNwb25zZSBib2R5IGlzIGVtcHR5XCIsXG4gICAgICB1cmwsXG4gICAgICByZXF1ZXN0Qm9keVZhbHVlcyxcbiAgICAgIHN0YXR1c0NvZGU6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICAgIHJlc3BvbnNlQm9keTogdm9pZCAwXG4gICAgfSk7XG4gIH1cbiAgdHJ5IHtcbiAgICBjb25zdCBidWZmZXIgPSBhd2FpdCByZXNwb25zZS5hcnJheUJ1ZmZlcigpO1xuICAgIHJldHVybiB7XG4gICAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgICB2YWx1ZTogbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKVxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhyb3cgbmV3IGltcG9ydF9wcm92aWRlcjkuQVBJQ2FsbEVycm9yKHtcbiAgICAgIG1lc3NhZ2U6IFwiRmFpbGVkIHRvIHJlYWQgcmVzcG9uc2UgYXMgYXJyYXkgYnVmZmVyXCIsXG4gICAgICB1cmwsXG4gICAgICByZXF1ZXN0Qm9keVZhbHVlcyxcbiAgICAgIHN0YXR1c0NvZGU6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICAgIHJlc3BvbnNlQm9keTogdm9pZCAwLFxuICAgICAgY2F1c2U6IGVycm9yXG4gICAgfSk7XG4gIH1cbn07XG52YXIgY3JlYXRlU3RhdHVzQ29kZUVycm9yUmVzcG9uc2VIYW5kbGVyID0gKCkgPT4gYXN5bmMgKHsgcmVzcG9uc2UsIHVybCwgcmVxdWVzdEJvZHlWYWx1ZXMgfSkgPT4ge1xuICBjb25zdCByZXNwb25zZUhlYWRlcnMgPSBleHRyYWN0UmVzcG9uc2VIZWFkZXJzKHJlc3BvbnNlKTtcbiAgY29uc3QgcmVzcG9uc2VCb2R5ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICByZXR1cm4ge1xuICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICB2YWx1ZTogbmV3IGltcG9ydF9wcm92aWRlcjkuQVBJQ2FsbEVycm9yKHtcbiAgICAgIG1lc3NhZ2U6IHJlc3BvbnNlLnN0YXR1c1RleHQsXG4gICAgICB1cmwsXG4gICAgICByZXF1ZXN0Qm9keVZhbHVlcyxcbiAgICAgIHN0YXR1c0NvZGU6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICAgIHJlc3BvbnNlQm9keVxuICAgIH0pXG4gIH07XG59O1xuXG4vLyBzcmMvdWludDgtdXRpbHMudHNcbnZhciB7IGJ0b2EsIGF0b2IgfSA9IGdsb2JhbFRoaXM7XG5mdW5jdGlvbiBjb252ZXJ0QmFzZTY0VG9VaW50OEFycmF5KGJhc2U2NFN0cmluZykge1xuICBjb25zdCBiYXNlNjRVcmwgPSBiYXNlNjRTdHJpbmcucmVwbGFjZSgvLS9nLCBcIitcIikucmVwbGFjZSgvXy9nLCBcIi9cIik7XG4gIGNvbnN0IGxhdGluMXN0cmluZyA9IGF0b2IoYmFzZTY0VXJsKTtcbiAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShsYXRpbjFzdHJpbmcsIChieXRlKSA9PiBieXRlLmNvZGVQb2ludEF0KDApKTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRVaW50OEFycmF5VG9CYXNlNjQoYXJyYXkpIHtcbiAgbGV0IGxhdGluMXN0cmluZyA9IFwiXCI7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICBsYXRpbjFzdHJpbmcgKz0gU3RyaW5nLmZyb21Db2RlUG9pbnQoYXJyYXlbaV0pO1xuICB9XG4gIHJldHVybiBidG9hKGxhdGluMXN0cmluZyk7XG59XG5cbi8vIHNyYy93aXRob3V0LXRyYWlsaW5nLXNsYXNoLnRzXG5mdW5jdGlvbiB3aXRob3V0VHJhaWxpbmdTbGFzaCh1cmwpIHtcbiAgcmV0dXJuIHVybCA9PSBudWxsID8gdm9pZCAwIDogdXJsLnJlcGxhY2UoL1xcLyQvLCBcIlwiKTtcbn1cbi8vIEFubm90YXRlIHRoZSBDb21tb25KUyBleHBvcnQgbmFtZXMgZm9yIEVTTSBpbXBvcnQgaW4gbm9kZTpcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICBhc1ZhbGlkYXRvcixcbiAgY29tYmluZUhlYWRlcnMsXG4gIGNvbnZlcnRBc3luY0l0ZXJhdG9yVG9SZWFkYWJsZVN0cmVhbSxcbiAgY29udmVydEJhc2U2NFRvVWludDhBcnJheSxcbiAgY29udmVydFVpbnQ4QXJyYXlUb0Jhc2U2NCxcbiAgY3JlYXRlQmluYXJ5UmVzcG9uc2VIYW5kbGVyLFxuICBjcmVhdGVFdmVudFNvdXJjZVBhcnNlclN0cmVhbSxcbiAgY3JlYXRlRXZlbnRTb3VyY2VSZXNwb25zZUhhbmRsZXIsXG4gIGNyZWF0ZUlkR2VuZXJhdG9yLFxuICBjcmVhdGVKc29uRXJyb3JSZXNwb25zZUhhbmRsZXIsXG4gIGNyZWF0ZUpzb25SZXNwb25zZUhhbmRsZXIsXG4gIGNyZWF0ZUpzb25TdHJlYW1SZXNwb25zZUhhbmRsZXIsXG4gIGNyZWF0ZVN0YXR1c0NvZGVFcnJvclJlc3BvbnNlSGFuZGxlcixcbiAgZGVsYXksXG4gIGV4dHJhY3RSZXNwb25zZUhlYWRlcnMsXG4gIGdlbmVyYXRlSWQsXG4gIGdldEVycm9yTWVzc2FnZSxcbiAgZ2V0RnJvbUFwaSxcbiAgaXNBYm9ydEVycm9yLFxuICBpc1BhcnNhYmxlSnNvbixcbiAgaXNWYWxpZGF0b3IsXG4gIGxvYWRBcGlLZXksXG4gIGxvYWRPcHRpb25hbFNldHRpbmcsXG4gIGxvYWRTZXR0aW5nLFxuICBwYXJzZUpTT04sXG4gIHBhcnNlUHJvdmlkZXJPcHRpb25zLFxuICBwb3N0Rm9ybURhdGFUb0FwaSxcbiAgcG9zdEpzb25Ub0FwaSxcbiAgcG9zdFRvQXBpLFxuICByZW1vdmVVbmRlZmluZWRFbnRyaWVzLFxuICByZXNvbHZlLFxuICBzYWZlUGFyc2VKU09OLFxuICBzYWZlVmFsaWRhdGVUeXBlcyxcbiAgdmFsaWRhdGVUeXBlcyxcbiAgdmFsaWRhdG9yLFxuICB2YWxpZGF0b3JTeW1ib2wsXG4gIHdpdGhvdXRUcmFpbGluZ1NsYXNoLFxuICB6b2RWYWxpZGF0b3Jcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@ai-sdk/provider-utils/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@ai-sdk/provider/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@ai-sdk/provider/dist/index.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name14 in all)\n    __defProp(target, name14, { get: all[name14], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// src/index.ts\nvar src_exports = {};\n__export(src_exports, {\n  AISDKError: () => AISDKError,\n  APICallError: () => APICallError,\n  EmptyResponseBodyError: () => EmptyResponseBodyError,\n  InvalidArgumentError: () => InvalidArgumentError,\n  InvalidPromptError: () => InvalidPromptError,\n  InvalidResponseDataError: () => InvalidResponseDataError,\n  JSONParseError: () => JSONParseError,\n  LoadAPIKeyError: () => LoadAPIKeyError,\n  LoadSettingError: () => LoadSettingError,\n  NoContentGeneratedError: () => NoContentGeneratedError,\n  NoSuchModelError: () => NoSuchModelError,\n  TooManyEmbeddingValuesForCallError: () => TooManyEmbeddingValuesForCallError,\n  TypeValidationError: () => TypeValidationError,\n  UnsupportedFunctionalityError: () => UnsupportedFunctionalityError,\n  getErrorMessage: () => getErrorMessage,\n  isJSONArray: () => isJSONArray,\n  isJSONObject: () => isJSONObject,\n  isJSONValue: () => isJSONValue\n});\nmodule.exports = __toCommonJS(src_exports);\n\n// src/errors/ai-sdk-error.ts\nvar marker = \"vercel.ai.error\";\nvar symbol = Symbol.for(marker);\nvar _a;\nvar _AISDKError = class _AISDKError extends Error {\n  /**\n   * Creates an AI SDK Error.\n   *\n   * @param {Object} params - The parameters for creating the error.\n   * @param {string} params.name - The name of the error.\n   * @param {string} params.message - The error message.\n   * @param {unknown} [params.cause] - The underlying cause of the error.\n   */\n  constructor({\n    name: name14,\n    message,\n    cause\n  }) {\n    super(message);\n    this[_a] = true;\n    this.name = name14;\n    this.cause = cause;\n  }\n  /**\n   * Checks if the given error is an AI SDK Error.\n   * @param {unknown} error - The error to check.\n   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.\n   */\n  static isInstance(error) {\n    return _AISDKError.hasMarker(error, marker);\n  }\n  static hasMarker(error, marker15) {\n    const markerSymbol = Symbol.for(marker15);\n    return error != null && typeof error === \"object\" && markerSymbol in error && typeof error[markerSymbol] === \"boolean\" && error[markerSymbol] === true;\n  }\n};\n_a = symbol;\nvar AISDKError = _AISDKError;\n\n// src/errors/api-call-error.ts\nvar name = \"AI_APICallError\";\nvar marker2 = `vercel.ai.error.${name}`;\nvar symbol2 = Symbol.for(marker2);\nvar _a2;\nvar APICallError = class extends AISDKError {\n  constructor({\n    message,\n    url,\n    requestBodyValues,\n    statusCode,\n    responseHeaders,\n    responseBody,\n    cause,\n    isRetryable = statusCode != null && (statusCode === 408 || // request timeout\n    statusCode === 409 || // conflict\n    statusCode === 429 || // too many requests\n    statusCode >= 500),\n    // server error\n    data\n  }) {\n    super({ name, message, cause });\n    this[_a2] = true;\n    this.url = url;\n    this.requestBodyValues = requestBodyValues;\n    this.statusCode = statusCode;\n    this.responseHeaders = responseHeaders;\n    this.responseBody = responseBody;\n    this.isRetryable = isRetryable;\n    this.data = data;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker2);\n  }\n};\n_a2 = symbol2;\n\n// src/errors/empty-response-body-error.ts\nvar name2 = \"AI_EmptyResponseBodyError\";\nvar marker3 = `vercel.ai.error.${name2}`;\nvar symbol3 = Symbol.for(marker3);\nvar _a3;\nvar EmptyResponseBodyError = class extends AISDKError {\n  // used in isInstance\n  constructor({ message = \"Empty response body\" } = {}) {\n    super({ name: name2, message });\n    this[_a3] = true;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker3);\n  }\n};\n_a3 = symbol3;\n\n// src/errors/get-error-message.ts\nfunction getErrorMessage(error) {\n  if (error == null) {\n    return \"unknown error\";\n  }\n  if (typeof error === \"string\") {\n    return error;\n  }\n  if (error instanceof Error) {\n    return error.message;\n  }\n  return JSON.stringify(error);\n}\n\n// src/errors/invalid-argument-error.ts\nvar name3 = \"AI_InvalidArgumentError\";\nvar marker4 = `vercel.ai.error.${name3}`;\nvar symbol4 = Symbol.for(marker4);\nvar _a4;\nvar InvalidArgumentError = class extends AISDKError {\n  constructor({\n    message,\n    cause,\n    argument\n  }) {\n    super({ name: name3, message, cause });\n    this[_a4] = true;\n    this.argument = argument;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker4);\n  }\n};\n_a4 = symbol4;\n\n// src/errors/invalid-prompt-error.ts\nvar name4 = \"AI_InvalidPromptError\";\nvar marker5 = `vercel.ai.error.${name4}`;\nvar symbol5 = Symbol.for(marker5);\nvar _a5;\nvar InvalidPromptError = class extends AISDKError {\n  constructor({\n    prompt,\n    message,\n    cause\n  }) {\n    super({ name: name4, message: `Invalid prompt: ${message}`, cause });\n    this[_a5] = true;\n    this.prompt = prompt;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker5);\n  }\n};\n_a5 = symbol5;\n\n// src/errors/invalid-response-data-error.ts\nvar name5 = \"AI_InvalidResponseDataError\";\nvar marker6 = `vercel.ai.error.${name5}`;\nvar symbol6 = Symbol.for(marker6);\nvar _a6;\nvar InvalidResponseDataError = class extends AISDKError {\n  constructor({\n    data,\n    message = `Invalid response data: ${JSON.stringify(data)}.`\n  }) {\n    super({ name: name5, message });\n    this[_a6] = true;\n    this.data = data;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker6);\n  }\n};\n_a6 = symbol6;\n\n// src/errors/json-parse-error.ts\nvar name6 = \"AI_JSONParseError\";\nvar marker7 = `vercel.ai.error.${name6}`;\nvar symbol7 = Symbol.for(marker7);\nvar _a7;\nvar JSONParseError = class extends AISDKError {\n  constructor({ text, cause }) {\n    super({\n      name: name6,\n      message: `JSON parsing failed: Text: ${text}.\nError message: ${getErrorMessage(cause)}`,\n      cause\n    });\n    this[_a7] = true;\n    this.text = text;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker7);\n  }\n};\n_a7 = symbol7;\n\n// src/errors/load-api-key-error.ts\nvar name7 = \"AI_LoadAPIKeyError\";\nvar marker8 = `vercel.ai.error.${name7}`;\nvar symbol8 = Symbol.for(marker8);\nvar _a8;\nvar LoadAPIKeyError = class extends AISDKError {\n  // used in isInstance\n  constructor({ message }) {\n    super({ name: name7, message });\n    this[_a8] = true;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker8);\n  }\n};\n_a8 = symbol8;\n\n// src/errors/load-setting-error.ts\nvar name8 = \"AI_LoadSettingError\";\nvar marker9 = `vercel.ai.error.${name8}`;\nvar symbol9 = Symbol.for(marker9);\nvar _a9;\nvar LoadSettingError = class extends AISDKError {\n  // used in isInstance\n  constructor({ message }) {\n    super({ name: name8, message });\n    this[_a9] = true;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker9);\n  }\n};\n_a9 = symbol9;\n\n// src/errors/no-content-generated-error.ts\nvar name9 = \"AI_NoContentGeneratedError\";\nvar marker10 = `vercel.ai.error.${name9}`;\nvar symbol10 = Symbol.for(marker10);\nvar _a10;\nvar NoContentGeneratedError = class extends AISDKError {\n  // used in isInstance\n  constructor({\n    message = \"No content generated.\"\n  } = {}) {\n    super({ name: name9, message });\n    this[_a10] = true;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker10);\n  }\n};\n_a10 = symbol10;\n\n// src/errors/no-such-model-error.ts\nvar name10 = \"AI_NoSuchModelError\";\nvar marker11 = `vercel.ai.error.${name10}`;\nvar symbol11 = Symbol.for(marker11);\nvar _a11;\nvar NoSuchModelError = class extends AISDKError {\n  constructor({\n    errorName = name10,\n    modelId,\n    modelType,\n    message = `No such ${modelType}: ${modelId}`\n  }) {\n    super({ name: errorName, message });\n    this[_a11] = true;\n    this.modelId = modelId;\n    this.modelType = modelType;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker11);\n  }\n};\n_a11 = symbol11;\n\n// src/errors/too-many-embedding-values-for-call-error.ts\nvar name11 = \"AI_TooManyEmbeddingValuesForCallError\";\nvar marker12 = `vercel.ai.error.${name11}`;\nvar symbol12 = Symbol.for(marker12);\nvar _a12;\nvar TooManyEmbeddingValuesForCallError = class extends AISDKError {\n  constructor(options) {\n    super({\n      name: name11,\n      message: `Too many values for a single embedding call. The ${options.provider} model \"${options.modelId}\" can only embed up to ${options.maxEmbeddingsPerCall} values per call, but ${options.values.length} values were provided.`\n    });\n    this[_a12] = true;\n    this.provider = options.provider;\n    this.modelId = options.modelId;\n    this.maxEmbeddingsPerCall = options.maxEmbeddingsPerCall;\n    this.values = options.values;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker12);\n  }\n};\n_a12 = symbol12;\n\n// src/errors/type-validation-error.ts\nvar name12 = \"AI_TypeValidationError\";\nvar marker13 = `vercel.ai.error.${name12}`;\nvar symbol13 = Symbol.for(marker13);\nvar _a13;\nvar _TypeValidationError = class _TypeValidationError extends AISDKError {\n  constructor({ value, cause }) {\n    super({\n      name: name12,\n      message: `Type validation failed: Value: ${JSON.stringify(value)}.\nError message: ${getErrorMessage(cause)}`,\n      cause\n    });\n    this[_a13] = true;\n    this.value = value;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker13);\n  }\n  /**\n   * Wraps an error into a TypeValidationError.\n   * If the cause is already a TypeValidationError with the same value, it returns the cause.\n   * Otherwise, it creates a new TypeValidationError.\n   *\n   * @param {Object} params - The parameters for wrapping the error.\n   * @param {unknown} params.value - The value that failed validation.\n   * @param {unknown} params.cause - The original error or cause of the validation failure.\n   * @returns {TypeValidationError} A TypeValidationError instance.\n   */\n  static wrap({\n    value,\n    cause\n  }) {\n    return _TypeValidationError.isInstance(cause) && cause.value === value ? cause : new _TypeValidationError({ value, cause });\n  }\n};\n_a13 = symbol13;\nvar TypeValidationError = _TypeValidationError;\n\n// src/errors/unsupported-functionality-error.ts\nvar name13 = \"AI_UnsupportedFunctionalityError\";\nvar marker14 = `vercel.ai.error.${name13}`;\nvar symbol14 = Symbol.for(marker14);\nvar _a14;\nvar UnsupportedFunctionalityError = class extends AISDKError {\n  constructor({\n    functionality,\n    message = `'${functionality}' functionality not supported.`\n  }) {\n    super({ name: name13, message });\n    this[_a14] = true;\n    this.functionality = functionality;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker14);\n  }\n};\n_a14 = symbol14;\n\n// src/json-value/is-json.ts\nfunction isJSONValue(value) {\n  if (value === null || typeof value === \"string\" || typeof value === \"number\" || typeof value === \"boolean\") {\n    return true;\n  }\n  if (Array.isArray(value)) {\n    return value.every(isJSONValue);\n  }\n  if (typeof value === \"object\") {\n    return Object.entries(value).every(\n      ([key, val]) => typeof key === \"string\" && isJSONValue(val)\n    );\n  }\n  return false;\n}\nfunction isJSONArray(value) {\n  return Array.isArray(value) && value.every(isJSONValue);\n}\nfunction isJSONObject(value) {\n  return value != null && typeof value === \"object\" && Object.entries(value).every(\n    ([key, val]) => typeof key === \"string\" && isJSONValue(val)\n  );\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGFpLXNkay9wcm92aWRlci9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLG9DQUFvQztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDRGQUE0RjtBQUN6SDtBQUNBO0FBQ0E7QUFDQSxvREFBb0Qsa0JBQWtCLGFBQWE7O0FBRW5GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlDQUFpQyxLQUFLO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsWUFBWSxzQkFBc0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUNBQWlDLE1BQU07QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0NBQWtDLElBQUk7QUFDdEQs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Q2hDLEdBQUc7QUFDSCxZQUFZLHVCQUF1QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sQ0FtQkw7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cnZpdmFsLWZ1bi8uL25vZGVfbW9kdWxlcy9AYWktc2RrL3Byb3ZpZGVyL2Rpc3QvaW5kZXguanM/MzdlZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUxNCBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZTE0LCB7IGdldDogYWxsW25hbWUxNF0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fdG9Db21tb25KUyA9IChtb2QpID0+IF9fY29weVByb3BzKF9fZGVmUHJvcCh7fSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSksIG1vZCk7XG5cbi8vIHNyYy9pbmRleC50c1xudmFyIHNyY19leHBvcnRzID0ge307XG5fX2V4cG9ydChzcmNfZXhwb3J0cywge1xuICBBSVNES0Vycm9yOiAoKSA9PiBBSVNES0Vycm9yLFxuICBBUElDYWxsRXJyb3I6ICgpID0+IEFQSUNhbGxFcnJvcixcbiAgRW1wdHlSZXNwb25zZUJvZHlFcnJvcjogKCkgPT4gRW1wdHlSZXNwb25zZUJvZHlFcnJvcixcbiAgSW52YWxpZEFyZ3VtZW50RXJyb3I6ICgpID0+IEludmFsaWRBcmd1bWVudEVycm9yLFxuICBJbnZhbGlkUHJvbXB0RXJyb3I6ICgpID0+IEludmFsaWRQcm9tcHRFcnJvcixcbiAgSW52YWxpZFJlc3BvbnNlRGF0YUVycm9yOiAoKSA9PiBJbnZhbGlkUmVzcG9uc2VEYXRhRXJyb3IsXG4gIEpTT05QYXJzZUVycm9yOiAoKSA9PiBKU09OUGFyc2VFcnJvcixcbiAgTG9hZEFQSUtleUVycm9yOiAoKSA9PiBMb2FkQVBJS2V5RXJyb3IsXG4gIExvYWRTZXR0aW5nRXJyb3I6ICgpID0+IExvYWRTZXR0aW5nRXJyb3IsXG4gIE5vQ29udGVudEdlbmVyYXRlZEVycm9yOiAoKSA9PiBOb0NvbnRlbnRHZW5lcmF0ZWRFcnJvcixcbiAgTm9TdWNoTW9kZWxFcnJvcjogKCkgPT4gTm9TdWNoTW9kZWxFcnJvcixcbiAgVG9vTWFueUVtYmVkZGluZ1ZhbHVlc0ZvckNhbGxFcnJvcjogKCkgPT4gVG9vTWFueUVtYmVkZGluZ1ZhbHVlc0ZvckNhbGxFcnJvcixcbiAgVHlwZVZhbGlkYXRpb25FcnJvcjogKCkgPT4gVHlwZVZhbGlkYXRpb25FcnJvcixcbiAgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3I6ICgpID0+IFVuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yLFxuICBnZXRFcnJvck1lc3NhZ2U6ICgpID0+IGdldEVycm9yTWVzc2FnZSxcbiAgaXNKU09OQXJyYXk6ICgpID0+IGlzSlNPTkFycmF5LFxuICBpc0pTT05PYmplY3Q6ICgpID0+IGlzSlNPTk9iamVjdCxcbiAgaXNKU09OVmFsdWU6ICgpID0+IGlzSlNPTlZhbHVlXG59KTtcbm1vZHVsZS5leHBvcnRzID0gX190b0NvbW1vbkpTKHNyY19leHBvcnRzKTtcblxuLy8gc3JjL2Vycm9ycy9haS1zZGstZXJyb3IudHNcbnZhciBtYXJrZXIgPSBcInZlcmNlbC5haS5lcnJvclwiO1xudmFyIHN5bWJvbCA9IFN5bWJvbC5mb3IobWFya2VyKTtcbnZhciBfYTtcbnZhciBfQUlTREtFcnJvciA9IGNsYXNzIF9BSVNES0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAvKipcbiAgICogQ3JlYXRlcyBhbiBBSSBTREsgRXJyb3IuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgY3JlYXRpbmcgdGhlIGVycm9yLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLm5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZXJyb3IuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMubWVzc2FnZSAtIFRoZSBlcnJvciBtZXNzYWdlLlxuICAgKiBAcGFyYW0ge3Vua25vd259IFtwYXJhbXMuY2F1c2VdIC0gVGhlIHVuZGVybHlpbmcgY2F1c2Ugb2YgdGhlIGVycm9yLlxuICAgKi9cbiAgY29uc3RydWN0b3Ioe1xuICAgIG5hbWU6IG5hbWUxNCxcbiAgICBtZXNzYWdlLFxuICAgIGNhdXNlXG4gIH0pIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzW19hXSA9IHRydWU7XG4gICAgdGhpcy5uYW1lID0gbmFtZTE0O1xuICAgIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBlcnJvciBpcyBhbiBBSSBTREsgRXJyb3IuXG4gICAqIEBwYXJhbSB7dW5rbm93bn0gZXJyb3IgLSBUaGUgZXJyb3IgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBlcnJvciBpcyBhbiBBSSBTREsgRXJyb3IsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIF9BSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyKTtcbiAgfVxuICBzdGF0aWMgaGFzTWFya2VyKGVycm9yLCBtYXJrZXIxNSkge1xuICAgIGNvbnN0IG1hcmtlclN5bWJvbCA9IFN5bWJvbC5mb3IobWFya2VyMTUpO1xuICAgIHJldHVybiBlcnJvciAhPSBudWxsICYmIHR5cGVvZiBlcnJvciA9PT0gXCJvYmplY3RcIiAmJiBtYXJrZXJTeW1ib2wgaW4gZXJyb3IgJiYgdHlwZW9mIGVycm9yW21hcmtlclN5bWJvbF0gPT09IFwiYm9vbGVhblwiICYmIGVycm9yW21hcmtlclN5bWJvbF0gPT09IHRydWU7XG4gIH1cbn07XG5fYSA9IHN5bWJvbDtcbnZhciBBSVNES0Vycm9yID0gX0FJU0RLRXJyb3I7XG5cbi8vIHNyYy9lcnJvcnMvYXBpLWNhbGwtZXJyb3IudHNcbnZhciBuYW1lID0gXCJBSV9BUElDYWxsRXJyb3JcIjtcbnZhciBtYXJrZXIyID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWV9YDtcbnZhciBzeW1ib2wyID0gU3ltYm9sLmZvcihtYXJrZXIyKTtcbnZhciBfYTI7XG52YXIgQVBJQ2FsbEVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIG1lc3NhZ2UsXG4gICAgdXJsLFxuICAgIHJlcXVlc3RCb2R5VmFsdWVzLFxuICAgIHN0YXR1c0NvZGUsXG4gICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgIHJlc3BvbnNlQm9keSxcbiAgICBjYXVzZSxcbiAgICBpc1JldHJ5YWJsZSA9IHN0YXR1c0NvZGUgIT0gbnVsbCAmJiAoc3RhdHVzQ29kZSA9PT0gNDA4IHx8IC8vIHJlcXVlc3QgdGltZW91dFxuICAgIHN0YXR1c0NvZGUgPT09IDQwOSB8fCAvLyBjb25mbGljdFxuICAgIHN0YXR1c0NvZGUgPT09IDQyOSB8fCAvLyB0b28gbWFueSByZXF1ZXN0c1xuICAgIHN0YXR1c0NvZGUgPj0gNTAwKSxcbiAgICAvLyBzZXJ2ZXIgZXJyb3JcbiAgICBkYXRhXG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWUsIG1lc3NhZ2UsIGNhdXNlIH0pO1xuICAgIHRoaXNbX2EyXSA9IHRydWU7XG4gICAgdGhpcy51cmwgPSB1cmw7XG4gICAgdGhpcy5yZXF1ZXN0Qm9keVZhbHVlcyA9IHJlcXVlc3RCb2R5VmFsdWVzO1xuICAgIHRoaXMuc3RhdHVzQ29kZSA9IHN0YXR1c0NvZGU7XG4gICAgdGhpcy5yZXNwb25zZUhlYWRlcnMgPSByZXNwb25zZUhlYWRlcnM7XG4gICAgdGhpcy5yZXNwb25zZUJvZHkgPSByZXNwb25zZUJvZHk7XG4gICAgdGhpcy5pc1JldHJ5YWJsZSA9IGlzUmV0cnlhYmxlO1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvci5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjIpO1xuICB9XG59O1xuX2EyID0gc3ltYm9sMjtcblxuLy8gc3JjL2Vycm9ycy9lbXB0eS1yZXNwb25zZS1ib2R5LWVycm9yLnRzXG52YXIgbmFtZTIgPSBcIkFJX0VtcHR5UmVzcG9uc2VCb2R5RXJyb3JcIjtcbnZhciBtYXJrZXIzID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWUyfWA7XG52YXIgc3ltYm9sMyA9IFN5bWJvbC5mb3IobWFya2VyMyk7XG52YXIgX2EzO1xudmFyIEVtcHR5UmVzcG9uc2VCb2R5RXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3Ige1xuICAvLyB1c2VkIGluIGlzSW5zdGFuY2VcbiAgY29uc3RydWN0b3IoeyBtZXNzYWdlID0gXCJFbXB0eSByZXNwb25zZSBib2R5XCIgfSA9IHt9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lMiwgbWVzc2FnZSB9KTtcbiAgICB0aGlzW19hM10gPSB0cnVlO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIzKTtcbiAgfVxufTtcbl9hMyA9IHN5bWJvbDM7XG5cbi8vIHNyYy9lcnJvcnMvZ2V0LWVycm9yLW1lc3NhZ2UudHNcbmZ1bmN0aW9uIGdldEVycm9yTWVzc2FnZShlcnJvcikge1xuICBpZiAoZXJyb3IgPT0gbnVsbCkge1xuICAgIHJldHVybiBcInVua25vd24gZXJyb3JcIjtcbiAgfVxuICBpZiAodHlwZW9mIGVycm9yID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGVycm9yO1xuICB9XG4gIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yLm1lc3NhZ2U7XG4gIH1cbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGVycm9yKTtcbn1cblxuLy8gc3JjL2Vycm9ycy9pbnZhbGlkLWFyZ3VtZW50LWVycm9yLnRzXG52YXIgbmFtZTMgPSBcIkFJX0ludmFsaWRBcmd1bWVudEVycm9yXCI7XG52YXIgbWFya2VyNCA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lM31gO1xudmFyIHN5bWJvbDQgPSBTeW1ib2wuZm9yKG1hcmtlcjQpO1xudmFyIF9hNDtcbnZhciBJbnZhbGlkQXJndW1lbnRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBtZXNzYWdlLFxuICAgIGNhdXNlLFxuICAgIGFyZ3VtZW50XG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWUzLCBtZXNzYWdlLCBjYXVzZSB9KTtcbiAgICB0aGlzW19hNF0gPSB0cnVlO1xuICAgIHRoaXMuYXJndW1lbnQgPSBhcmd1bWVudDtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyNCk7XG4gIH1cbn07XG5fYTQgPSBzeW1ib2w0O1xuXG4vLyBzcmMvZXJyb3JzL2ludmFsaWQtcHJvbXB0LWVycm9yLnRzXG52YXIgbmFtZTQgPSBcIkFJX0ludmFsaWRQcm9tcHRFcnJvclwiO1xudmFyIG1hcmtlcjUgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTR9YDtcbnZhciBzeW1ib2w1ID0gU3ltYm9sLmZvcihtYXJrZXI1KTtcbnZhciBfYTU7XG52YXIgSW52YWxpZFByb21wdEVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHByb21wdCxcbiAgICBtZXNzYWdlLFxuICAgIGNhdXNlXG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWU0LCBtZXNzYWdlOiBgSW52YWxpZCBwcm9tcHQ6ICR7bWVzc2FnZX1gLCBjYXVzZSB9KTtcbiAgICB0aGlzW19hNV0gPSB0cnVlO1xuICAgIHRoaXMucHJvbXB0ID0gcHJvbXB0O1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXI1KTtcbiAgfVxufTtcbl9hNSA9IHN5bWJvbDU7XG5cbi8vIHNyYy9lcnJvcnMvaW52YWxpZC1yZXNwb25zZS1kYXRhLWVycm9yLnRzXG52YXIgbmFtZTUgPSBcIkFJX0ludmFsaWRSZXNwb25zZURhdGFFcnJvclwiO1xudmFyIG1hcmtlcjYgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTV9YDtcbnZhciBzeW1ib2w2ID0gU3ltYm9sLmZvcihtYXJrZXI2KTtcbnZhciBfYTY7XG52YXIgSW52YWxpZFJlc3BvbnNlRGF0YUVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGRhdGEsXG4gICAgbWVzc2FnZSA9IGBJbnZhbGlkIHJlc3BvbnNlIGRhdGE6ICR7SlNPTi5zdHJpbmdpZnkoZGF0YSl9LmBcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTUsIG1lc3NhZ2UgfSk7XG4gICAgdGhpc1tfYTZdID0gdHJ1ZTtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXI2KTtcbiAgfVxufTtcbl9hNiA9IHN5bWJvbDY7XG5cbi8vIHNyYy9lcnJvcnMvanNvbi1wYXJzZS1lcnJvci50c1xudmFyIG5hbWU2ID0gXCJBSV9KU09OUGFyc2VFcnJvclwiO1xudmFyIG1hcmtlcjcgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTZ9YDtcbnZhciBzeW1ib2w3ID0gU3ltYm9sLmZvcihtYXJrZXI3KTtcbnZhciBfYTc7XG52YXIgSlNPTlBhcnNlRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcih7IHRleHQsIGNhdXNlIH0pIHtcbiAgICBzdXBlcih7XG4gICAgICBuYW1lOiBuYW1lNixcbiAgICAgIG1lc3NhZ2U6IGBKU09OIHBhcnNpbmcgZmFpbGVkOiBUZXh0OiAke3RleHR9LlxuRXJyb3IgbWVzc2FnZTogJHtnZXRFcnJvck1lc3NhZ2UoY2F1c2UpfWAsXG4gICAgICBjYXVzZVxuICAgIH0pO1xuICAgIHRoaXNbX2E3XSA9IHRydWU7XG4gICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyNyk7XG4gIH1cbn07XG5fYTcgPSBzeW1ib2w3O1xuXG4vLyBzcmMvZXJyb3JzL2xvYWQtYXBpLWtleS1lcnJvci50c1xudmFyIG5hbWU3ID0gXCJBSV9Mb2FkQVBJS2V5RXJyb3JcIjtcbnZhciBtYXJrZXI4ID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWU3fWA7XG52YXIgc3ltYm9sOCA9IFN5bWJvbC5mb3IobWFya2VyOCk7XG52YXIgX2E4O1xudmFyIExvYWRBUElLZXlFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvciB7XG4gIC8vIHVzZWQgaW4gaXNJbnN0YW5jZVxuICBjb25zdHJ1Y3Rvcih7IG1lc3NhZ2UgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTcsIG1lc3NhZ2UgfSk7XG4gICAgdGhpc1tfYThdID0gdHJ1ZTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyOCk7XG4gIH1cbn07XG5fYTggPSBzeW1ib2w4O1xuXG4vLyBzcmMvZXJyb3JzL2xvYWQtc2V0dGluZy1lcnJvci50c1xudmFyIG5hbWU4ID0gXCJBSV9Mb2FkU2V0dGluZ0Vycm9yXCI7XG52YXIgbWFya2VyOSA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lOH1gO1xudmFyIHN5bWJvbDkgPSBTeW1ib2wuZm9yKG1hcmtlcjkpO1xudmFyIF9hOTtcbnZhciBMb2FkU2V0dGluZ0Vycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yIHtcbiAgLy8gdXNlZCBpbiBpc0luc3RhbmNlXG4gIGNvbnN0cnVjdG9yKHsgbWVzc2FnZSB9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lOCwgbWVzc2FnZSB9KTtcbiAgICB0aGlzW19hOV0gPSB0cnVlO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXI5KTtcbiAgfVxufTtcbl9hOSA9IHN5bWJvbDk7XG5cbi8vIHNyYy9lcnJvcnMvbm8tY29udGVudC1nZW5lcmF0ZWQtZXJyb3IudHNcbnZhciBuYW1lOSA9IFwiQUlfTm9Db250ZW50R2VuZXJhdGVkRXJyb3JcIjtcbnZhciBtYXJrZXIxMCA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lOX1gO1xudmFyIHN5bWJvbDEwID0gU3ltYm9sLmZvcihtYXJrZXIxMCk7XG52YXIgX2ExMDtcbnZhciBOb0NvbnRlbnRHZW5lcmF0ZWRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvciB7XG4gIC8vIHVzZWQgaW4gaXNJbnN0YW5jZVxuICBjb25zdHJ1Y3Rvcih7XG4gICAgbWVzc2FnZSA9IFwiTm8gY29udGVudCBnZW5lcmF0ZWQuXCJcbiAgfSA9IHt9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lOSwgbWVzc2FnZSB9KTtcbiAgICB0aGlzW19hMTBdID0gdHJ1ZTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyMTApO1xuICB9XG59O1xuX2ExMCA9IHN5bWJvbDEwO1xuXG4vLyBzcmMvZXJyb3JzL25vLXN1Y2gtbW9kZWwtZXJyb3IudHNcbnZhciBuYW1lMTAgPSBcIkFJX05vU3VjaE1vZGVsRXJyb3JcIjtcbnZhciBtYXJrZXIxMSA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lMTB9YDtcbnZhciBzeW1ib2wxMSA9IFN5bWJvbC5mb3IobWFya2VyMTEpO1xudmFyIF9hMTE7XG52YXIgTm9TdWNoTW9kZWxFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBlcnJvck5hbWUgPSBuYW1lMTAsXG4gICAgbW9kZWxJZCxcbiAgICBtb2RlbFR5cGUsXG4gICAgbWVzc2FnZSA9IGBObyBzdWNoICR7bW9kZWxUeXBlfTogJHttb2RlbElkfWBcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogZXJyb3JOYW1lLCBtZXNzYWdlIH0pO1xuICAgIHRoaXNbX2ExMV0gPSB0cnVlO1xuICAgIHRoaXMubW9kZWxJZCA9IG1vZGVsSWQ7XG4gICAgdGhpcy5tb2RlbFR5cGUgPSBtb2RlbFR5cGU7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvci5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjExKTtcbiAgfVxufTtcbl9hMTEgPSBzeW1ib2wxMTtcblxuLy8gc3JjL2Vycm9ycy90b28tbWFueS1lbWJlZGRpbmctdmFsdWVzLWZvci1jYWxsLWVycm9yLnRzXG52YXIgbmFtZTExID0gXCJBSV9Ub29NYW55RW1iZWRkaW5nVmFsdWVzRm9yQ2FsbEVycm9yXCI7XG52YXIgbWFya2VyMTIgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTExfWA7XG52YXIgc3ltYm9sMTIgPSBTeW1ib2wuZm9yKG1hcmtlcjEyKTtcbnZhciBfYTEyO1xudmFyIFRvb01hbnlFbWJlZGRpbmdWYWx1ZXNGb3JDYWxsRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIoe1xuICAgICAgbmFtZTogbmFtZTExLFxuICAgICAgbWVzc2FnZTogYFRvbyBtYW55IHZhbHVlcyBmb3IgYSBzaW5nbGUgZW1iZWRkaW5nIGNhbGwuIFRoZSAke29wdGlvbnMucHJvdmlkZXJ9IG1vZGVsIFwiJHtvcHRpb25zLm1vZGVsSWR9XCIgY2FuIG9ubHkgZW1iZWQgdXAgdG8gJHtvcHRpb25zLm1heEVtYmVkZGluZ3NQZXJDYWxsfSB2YWx1ZXMgcGVyIGNhbGwsIGJ1dCAke29wdGlvbnMudmFsdWVzLmxlbmd0aH0gdmFsdWVzIHdlcmUgcHJvdmlkZWQuYFxuICAgIH0pO1xuICAgIHRoaXNbX2ExMl0gPSB0cnVlO1xuICAgIHRoaXMucHJvdmlkZXIgPSBvcHRpb25zLnByb3ZpZGVyO1xuICAgIHRoaXMubW9kZWxJZCA9IG9wdGlvbnMubW9kZWxJZDtcbiAgICB0aGlzLm1heEVtYmVkZGluZ3NQZXJDYWxsID0gb3B0aW9ucy5tYXhFbWJlZGRpbmdzUGVyQ2FsbDtcbiAgICB0aGlzLnZhbHVlcyA9IG9wdGlvbnMudmFsdWVzO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIxMik7XG4gIH1cbn07XG5fYTEyID0gc3ltYm9sMTI7XG5cbi8vIHNyYy9lcnJvcnMvdHlwZS12YWxpZGF0aW9uLWVycm9yLnRzXG52YXIgbmFtZTEyID0gXCJBSV9UeXBlVmFsaWRhdGlvbkVycm9yXCI7XG52YXIgbWFya2VyMTMgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTEyfWA7XG52YXIgc3ltYm9sMTMgPSBTeW1ib2wuZm9yKG1hcmtlcjEzKTtcbnZhciBfYTEzO1xudmFyIF9UeXBlVmFsaWRhdGlvbkVycm9yID0gY2xhc3MgX1R5cGVWYWxpZGF0aW9uRXJyb3IgZXh0ZW5kcyBBSVNES0Vycm9yIHtcbiAgY29uc3RydWN0b3IoeyB2YWx1ZSwgY2F1c2UgfSkge1xuICAgIHN1cGVyKHtcbiAgICAgIG5hbWU6IG5hbWUxMixcbiAgICAgIG1lc3NhZ2U6IGBUeXBlIHZhbGlkYXRpb24gZmFpbGVkOiBWYWx1ZTogJHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9LlxuRXJyb3IgbWVzc2FnZTogJHtnZXRFcnJvck1lc3NhZ2UoY2F1c2UpfWAsXG4gICAgICBjYXVzZVxuICAgIH0pO1xuICAgIHRoaXNbX2ExM10gPSB0cnVlO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyMTMpO1xuICB9XG4gIC8qKlxuICAgKiBXcmFwcyBhbiBlcnJvciBpbnRvIGEgVHlwZVZhbGlkYXRpb25FcnJvci5cbiAgICogSWYgdGhlIGNhdXNlIGlzIGFscmVhZHkgYSBUeXBlVmFsaWRhdGlvbkVycm9yIHdpdGggdGhlIHNhbWUgdmFsdWUsIGl0IHJldHVybnMgdGhlIGNhdXNlLlxuICAgKiBPdGhlcndpc2UsIGl0IGNyZWF0ZXMgYSBuZXcgVHlwZVZhbGlkYXRpb25FcnJvci5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB3cmFwcGluZyB0aGUgZXJyb3IuXG4gICAqIEBwYXJhbSB7dW5rbm93bn0gcGFyYW1zLnZhbHVlIC0gVGhlIHZhbHVlIHRoYXQgZmFpbGVkIHZhbGlkYXRpb24uXG4gICAqIEBwYXJhbSB7dW5rbm93bn0gcGFyYW1zLmNhdXNlIC0gVGhlIG9yaWdpbmFsIGVycm9yIG9yIGNhdXNlIG9mIHRoZSB2YWxpZGF0aW9uIGZhaWx1cmUuXG4gICAqIEByZXR1cm5zIHtUeXBlVmFsaWRhdGlvbkVycm9yfSBBIFR5cGVWYWxpZGF0aW9uRXJyb3IgaW5zdGFuY2UuXG4gICAqL1xuICBzdGF0aWMgd3JhcCh7XG4gICAgdmFsdWUsXG4gICAgY2F1c2VcbiAgfSkge1xuICAgIHJldHVybiBfVHlwZVZhbGlkYXRpb25FcnJvci5pc0luc3RhbmNlKGNhdXNlKSAmJiBjYXVzZS52YWx1ZSA9PT0gdmFsdWUgPyBjYXVzZSA6IG5ldyBfVHlwZVZhbGlkYXRpb25FcnJvcih7IHZhbHVlLCBjYXVzZSB9KTtcbiAgfVxufTtcbl9hMTMgPSBzeW1ib2wxMztcbnZhciBUeXBlVmFsaWRhdGlvbkVycm9yID0gX1R5cGVWYWxpZGF0aW9uRXJyb3I7XG5cbi8vIHNyYy9lcnJvcnMvdW5zdXBwb3J0ZWQtZnVuY3Rpb25hbGl0eS1lcnJvci50c1xudmFyIG5hbWUxMyA9IFwiQUlfVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3JcIjtcbnZhciBtYXJrZXIxNCA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lMTN9YDtcbnZhciBzeW1ib2wxNCA9IFN5bWJvbC5mb3IobWFya2VyMTQpO1xudmFyIF9hMTQ7XG52YXIgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgZnVuY3Rpb25hbGl0eSxcbiAgICBtZXNzYWdlID0gYCcke2Z1bmN0aW9uYWxpdHl9JyBmdW5jdGlvbmFsaXR5IG5vdCBzdXBwb3J0ZWQuYFxuICB9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lMTMsIG1lc3NhZ2UgfSk7XG4gICAgdGhpc1tfYTE0XSA9IHRydWU7XG4gICAgdGhpcy5mdW5jdGlvbmFsaXR5ID0gZnVuY3Rpb25hbGl0eTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyMTQpO1xuICB9XG59O1xuX2ExNCA9IHN5bWJvbDE0O1xuXG4vLyBzcmMvanNvbi12YWx1ZS9pcy1qc29uLnRzXG5mdW5jdGlvbiBpc0pTT05WYWx1ZSh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlLmV2ZXJ5KGlzSlNPTlZhbHVlKTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHZhbHVlKS5ldmVyeShcbiAgICAgIChba2V5LCB2YWxdKSA9PiB0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiICYmIGlzSlNPTlZhbHVlKHZhbClcbiAgICApO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzSlNPTkFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5ldmVyeShpc0pTT05WYWx1ZSk7XG59XG5mdW5jdGlvbiBpc0pTT05PYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIE9iamVjdC5lbnRyaWVzKHZhbHVlKS5ldmVyeShcbiAgICAoW2tleSwgdmFsXSkgPT4gdHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIiAmJiBpc0pTT05WYWx1ZSh2YWwpXG4gICk7XG59XG4vLyBBbm5vdGF0ZSB0aGUgQ29tbW9uSlMgZXhwb3J0IG5hbWVzIGZvciBFU00gaW1wb3J0IGluIG5vZGU6XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgQUlTREtFcnJvcixcbiAgQVBJQ2FsbEVycm9yLFxuICBFbXB0eVJlc3BvbnNlQm9keUVycm9yLFxuICBJbnZhbGlkQXJndW1lbnRFcnJvcixcbiAgSW52YWxpZFByb21wdEVycm9yLFxuICBJbnZhbGlkUmVzcG9uc2VEYXRhRXJyb3IsXG4gIEpTT05QYXJzZUVycm9yLFxuICBMb2FkQVBJS2V5RXJyb3IsXG4gIExvYWRTZXR0aW5nRXJyb3IsXG4gIE5vQ29udGVudEdlbmVyYXRlZEVycm9yLFxuICBOb1N1Y2hNb2RlbEVycm9yLFxuICBUb29NYW55RW1iZWRkaW5nVmFsdWVzRm9yQ2FsbEVycm9yLFxuICBUeXBlVmFsaWRhdGlvbkVycm9yLFxuICBVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvcixcbiAgZ2V0RXJyb3JNZXNzYWdlLFxuICBpc0pTT05BcnJheSxcbiAgaXNKU09OT2JqZWN0LFxuICBpc0pTT05WYWx1ZVxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@ai-sdk/provider/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@ai-sdk/ui-utils/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@ai-sdk/ui-utils/dist/index.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// src/index.ts\nvar src_exports = {};\n__export(src_exports, {\n  asSchema: () => asSchema,\n  callChatApi: () => callChatApi,\n  callCompletionApi: () => callCompletionApi,\n  extractMaxToolInvocationStep: () => extractMaxToolInvocationStep,\n  fillMessageParts: () => fillMessageParts,\n  formatAssistantStreamPart: () => formatAssistantStreamPart,\n  formatDataStreamPart: () => formatDataStreamPart,\n  generateId: () => import_provider_utils5.generateId,\n  getMessageParts: () => getMessageParts,\n  getTextFromDataUrl: () => getTextFromDataUrl,\n  isAssistantMessageWithCompletedToolCalls: () => isAssistantMessageWithCompletedToolCalls,\n  isDeepEqualData: () => isDeepEqualData,\n  jsonSchema: () => jsonSchema,\n  parseAssistantStreamPart: () => parseAssistantStreamPart,\n  parseDataStreamPart: () => parseDataStreamPart,\n  parsePartialJson: () => parsePartialJson,\n  prepareAttachmentsForRequest: () => prepareAttachmentsForRequest,\n  processAssistantStream: () => processAssistantStream,\n  processDataStream: () => processDataStream,\n  processTextStream: () => processTextStream,\n  shouldResubmitMessages: () => shouldResubmitMessages,\n  updateToolCallResult: () => updateToolCallResult,\n  zodSchema: () => zodSchema\n});\nmodule.exports = __toCommonJS(src_exports);\nvar import_provider_utils5 = __webpack_require__(/*! @ai-sdk/provider-utils */ \"(rsc)/./node_modules/@ai-sdk/provider-utils/dist/index.js\");\n\n// src/assistant-stream-parts.ts\nvar textStreamPart = {\n  code: \"0\",\n  name: \"text\",\n  parse: (value) => {\n    if (typeof value !== \"string\") {\n      throw new Error('\"text\" parts expect a string value.');\n    }\n    return { type: \"text\", value };\n  }\n};\nvar errorStreamPart = {\n  code: \"3\",\n  name: \"error\",\n  parse: (value) => {\n    if (typeof value !== \"string\") {\n      throw new Error('\"error\" parts expect a string value.');\n    }\n    return { type: \"error\", value };\n  }\n};\nvar assistantMessageStreamPart = {\n  code: \"4\",\n  name: \"assistant_message\",\n  parse: (value) => {\n    if (value == null || typeof value !== \"object\" || !(\"id\" in value) || !(\"role\" in value) || !(\"content\" in value) || typeof value.id !== \"string\" || typeof value.role !== \"string\" || value.role !== \"assistant\" || !Array.isArray(value.content) || !value.content.every(\n      (item) => item != null && typeof item === \"object\" && \"type\" in item && item.type === \"text\" && \"text\" in item && item.text != null && typeof item.text === \"object\" && \"value\" in item.text && typeof item.text.value === \"string\"\n    )) {\n      throw new Error(\n        '\"assistant_message\" parts expect an object with an \"id\", \"role\", and \"content\" property.'\n      );\n    }\n    return {\n      type: \"assistant_message\",\n      value\n    };\n  }\n};\nvar assistantControlDataStreamPart = {\n  code: \"5\",\n  name: \"assistant_control_data\",\n  parse: (value) => {\n    if (value == null || typeof value !== \"object\" || !(\"threadId\" in value) || !(\"messageId\" in value) || typeof value.threadId !== \"string\" || typeof value.messageId !== \"string\") {\n      throw new Error(\n        '\"assistant_control_data\" parts expect an object with a \"threadId\" and \"messageId\" property.'\n      );\n    }\n    return {\n      type: \"assistant_control_data\",\n      value: {\n        threadId: value.threadId,\n        messageId: value.messageId\n      }\n    };\n  }\n};\nvar dataMessageStreamPart = {\n  code: \"6\",\n  name: \"data_message\",\n  parse: (value) => {\n    if (value == null || typeof value !== \"object\" || !(\"role\" in value) || !(\"data\" in value) || typeof value.role !== \"string\" || value.role !== \"data\") {\n      throw new Error(\n        '\"data_message\" parts expect an object with a \"role\" and \"data\" property.'\n      );\n    }\n    return {\n      type: \"data_message\",\n      value\n    };\n  }\n};\nvar assistantStreamParts = [\n  textStreamPart,\n  errorStreamPart,\n  assistantMessageStreamPart,\n  assistantControlDataStreamPart,\n  dataMessageStreamPart\n];\nvar assistantStreamPartsByCode = {\n  [textStreamPart.code]: textStreamPart,\n  [errorStreamPart.code]: errorStreamPart,\n  [assistantMessageStreamPart.code]: assistantMessageStreamPart,\n  [assistantControlDataStreamPart.code]: assistantControlDataStreamPart,\n  [dataMessageStreamPart.code]: dataMessageStreamPart\n};\nvar StreamStringPrefixes = {\n  [textStreamPart.name]: textStreamPart.code,\n  [errorStreamPart.name]: errorStreamPart.code,\n  [assistantMessageStreamPart.name]: assistantMessageStreamPart.code,\n  [assistantControlDataStreamPart.name]: assistantControlDataStreamPart.code,\n  [dataMessageStreamPart.name]: dataMessageStreamPart.code\n};\nvar validCodes = assistantStreamParts.map((part) => part.code);\nvar parseAssistantStreamPart = (line) => {\n  const firstSeparatorIndex = line.indexOf(\":\");\n  if (firstSeparatorIndex === -1) {\n    throw new Error(\"Failed to parse stream string. No separator found.\");\n  }\n  const prefix = line.slice(0, firstSeparatorIndex);\n  if (!validCodes.includes(prefix)) {\n    throw new Error(`Failed to parse stream string. Invalid code ${prefix}.`);\n  }\n  const code = prefix;\n  const textValue = line.slice(firstSeparatorIndex + 1);\n  const jsonValue = JSON.parse(textValue);\n  return assistantStreamPartsByCode[code].parse(jsonValue);\n};\nfunction formatAssistantStreamPart(type, value) {\n  const streamPart = assistantStreamParts.find((part) => part.name === type);\n  if (!streamPart) {\n    throw new Error(`Invalid stream part type: ${type}`);\n  }\n  return `${streamPart.code}:${JSON.stringify(value)}\n`;\n}\n\n// src/process-chat-response.ts\nvar import_provider_utils2 = __webpack_require__(/*! @ai-sdk/provider-utils */ \"(rsc)/./node_modules/@ai-sdk/provider-utils/dist/index.js\");\n\n// src/duplicated/usage.ts\nfunction calculateLanguageModelUsage({\n  promptTokens,\n  completionTokens\n}) {\n  return {\n    promptTokens,\n    completionTokens,\n    totalTokens: promptTokens + completionTokens\n  };\n}\n\n// src/parse-partial-json.ts\nvar import_provider_utils = __webpack_require__(/*! @ai-sdk/provider-utils */ \"(rsc)/./node_modules/@ai-sdk/provider-utils/dist/index.js\");\n\n// src/fix-json.ts\nfunction fixJson(input) {\n  const stack = [\"ROOT\"];\n  let lastValidIndex = -1;\n  let literalStart = null;\n  function processValueStart(char, i, swapState) {\n    {\n      switch (char) {\n        case '\"': {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_STRING\");\n          break;\n        }\n        case \"f\":\n        case \"t\":\n        case \"n\": {\n          lastValidIndex = i;\n          literalStart = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_LITERAL\");\n          break;\n        }\n        case \"-\": {\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_NUMBER\");\n          break;\n        }\n        case \"0\":\n        case \"1\":\n        case \"2\":\n        case \"3\":\n        case \"4\":\n        case \"5\":\n        case \"6\":\n        case \"7\":\n        case \"8\":\n        case \"9\": {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_NUMBER\");\n          break;\n        }\n        case \"{\": {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_OBJECT_START\");\n          break;\n        }\n        case \"[\": {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_ARRAY_START\");\n          break;\n        }\n      }\n    }\n  }\n  function processAfterObjectValue(char, i) {\n    switch (char) {\n      case \",\": {\n        stack.pop();\n        stack.push(\"INSIDE_OBJECT_AFTER_COMMA\");\n        break;\n      }\n      case \"}\": {\n        lastValidIndex = i;\n        stack.pop();\n        break;\n      }\n    }\n  }\n  function processAfterArrayValue(char, i) {\n    switch (char) {\n      case \",\": {\n        stack.pop();\n        stack.push(\"INSIDE_ARRAY_AFTER_COMMA\");\n        break;\n      }\n      case \"]\": {\n        lastValidIndex = i;\n        stack.pop();\n        break;\n      }\n    }\n  }\n  for (let i = 0; i < input.length; i++) {\n    const char = input[i];\n    const currentState = stack[stack.length - 1];\n    switch (currentState) {\n      case \"ROOT\":\n        processValueStart(char, i, \"FINISH\");\n        break;\n      case \"INSIDE_OBJECT_START\": {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            stack.push(\"INSIDE_OBJECT_KEY\");\n            break;\n          }\n          case \"}\": {\n            lastValidIndex = i;\n            stack.pop();\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_OBJECT_AFTER_COMMA\": {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            stack.push(\"INSIDE_OBJECT_KEY\");\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_OBJECT_KEY\": {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            stack.push(\"INSIDE_OBJECT_AFTER_KEY\");\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_OBJECT_AFTER_KEY\": {\n        switch (char) {\n          case \":\": {\n            stack.pop();\n            stack.push(\"INSIDE_OBJECT_BEFORE_VALUE\");\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_OBJECT_BEFORE_VALUE\": {\n        processValueStart(char, i, \"INSIDE_OBJECT_AFTER_VALUE\");\n        break;\n      }\n      case \"INSIDE_OBJECT_AFTER_VALUE\": {\n        processAfterObjectValue(char, i);\n        break;\n      }\n      case \"INSIDE_STRING\": {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            lastValidIndex = i;\n            break;\n          }\n          case \"\\\\\": {\n            stack.push(\"INSIDE_STRING_ESCAPE\");\n            break;\n          }\n          default: {\n            lastValidIndex = i;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_ARRAY_START\": {\n        switch (char) {\n          case \"]\": {\n            lastValidIndex = i;\n            stack.pop();\n            break;\n          }\n          default: {\n            lastValidIndex = i;\n            processValueStart(char, i, \"INSIDE_ARRAY_AFTER_VALUE\");\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_ARRAY_AFTER_VALUE\": {\n        switch (char) {\n          case \",\": {\n            stack.pop();\n            stack.push(\"INSIDE_ARRAY_AFTER_COMMA\");\n            break;\n          }\n          case \"]\": {\n            lastValidIndex = i;\n            stack.pop();\n            break;\n          }\n          default: {\n            lastValidIndex = i;\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_ARRAY_AFTER_COMMA\": {\n        processValueStart(char, i, \"INSIDE_ARRAY_AFTER_VALUE\");\n        break;\n      }\n      case \"INSIDE_STRING_ESCAPE\": {\n        stack.pop();\n        lastValidIndex = i;\n        break;\n      }\n      case \"INSIDE_NUMBER\": {\n        switch (char) {\n          case \"0\":\n          case \"1\":\n          case \"2\":\n          case \"3\":\n          case \"4\":\n          case \"5\":\n          case \"6\":\n          case \"7\":\n          case \"8\":\n          case \"9\": {\n            lastValidIndex = i;\n            break;\n          }\n          case \"e\":\n          case \"E\":\n          case \"-\":\n          case \".\": {\n            break;\n          }\n          case \",\": {\n            stack.pop();\n            if (stack[stack.length - 1] === \"INSIDE_ARRAY_AFTER_VALUE\") {\n              processAfterArrayValue(char, i);\n            }\n            if (stack[stack.length - 1] === \"INSIDE_OBJECT_AFTER_VALUE\") {\n              processAfterObjectValue(char, i);\n            }\n            break;\n          }\n          case \"}\": {\n            stack.pop();\n            if (stack[stack.length - 1] === \"INSIDE_OBJECT_AFTER_VALUE\") {\n              processAfterObjectValue(char, i);\n            }\n            break;\n          }\n          case \"]\": {\n            stack.pop();\n            if (stack[stack.length - 1] === \"INSIDE_ARRAY_AFTER_VALUE\") {\n              processAfterArrayValue(char, i);\n            }\n            break;\n          }\n          default: {\n            stack.pop();\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_LITERAL\": {\n        const partialLiteral = input.substring(literalStart, i + 1);\n        if (!\"false\".startsWith(partialLiteral) && !\"true\".startsWith(partialLiteral) && !\"null\".startsWith(partialLiteral)) {\n          stack.pop();\n          if (stack[stack.length - 1] === \"INSIDE_OBJECT_AFTER_VALUE\") {\n            processAfterObjectValue(char, i);\n          } else if (stack[stack.length - 1] === \"INSIDE_ARRAY_AFTER_VALUE\") {\n            processAfterArrayValue(char, i);\n          }\n        } else {\n          lastValidIndex = i;\n        }\n        break;\n      }\n    }\n  }\n  let result = input.slice(0, lastValidIndex + 1);\n  for (let i = stack.length - 1; i >= 0; i--) {\n    const state = stack[i];\n    switch (state) {\n      case \"INSIDE_STRING\": {\n        result += '\"';\n        break;\n      }\n      case \"INSIDE_OBJECT_KEY\":\n      case \"INSIDE_OBJECT_AFTER_KEY\":\n      case \"INSIDE_OBJECT_AFTER_COMMA\":\n      case \"INSIDE_OBJECT_START\":\n      case \"INSIDE_OBJECT_BEFORE_VALUE\":\n      case \"INSIDE_OBJECT_AFTER_VALUE\": {\n        result += \"}\";\n        break;\n      }\n      case \"INSIDE_ARRAY_START\":\n      case \"INSIDE_ARRAY_AFTER_COMMA\":\n      case \"INSIDE_ARRAY_AFTER_VALUE\": {\n        result += \"]\";\n        break;\n      }\n      case \"INSIDE_LITERAL\": {\n        const partialLiteral = input.substring(literalStart, input.length);\n        if (\"true\".startsWith(partialLiteral)) {\n          result += \"true\".slice(partialLiteral.length);\n        } else if (\"false\".startsWith(partialLiteral)) {\n          result += \"false\".slice(partialLiteral.length);\n        } else if (\"null\".startsWith(partialLiteral)) {\n          result += \"null\".slice(partialLiteral.length);\n        }\n      }\n    }\n  }\n  return result;\n}\n\n// src/parse-partial-json.ts\nfunction parsePartialJson(jsonText) {\n  if (jsonText === void 0) {\n    return { value: void 0, state: \"undefined-input\" };\n  }\n  let result = (0, import_provider_utils.safeParseJSON)({ text: jsonText });\n  if (result.success) {\n    return { value: result.value, state: \"successful-parse\" };\n  }\n  result = (0, import_provider_utils.safeParseJSON)({ text: fixJson(jsonText) });\n  if (result.success) {\n    return { value: result.value, state: \"repaired-parse\" };\n  }\n  return { value: void 0, state: \"failed-parse\" };\n}\n\n// src/data-stream-parts.ts\nvar textStreamPart2 = {\n  code: \"0\",\n  name: \"text\",\n  parse: (value) => {\n    if (typeof value !== \"string\") {\n      throw new Error('\"text\" parts expect a string value.');\n    }\n    return { type: \"text\", value };\n  }\n};\nvar dataStreamPart = {\n  code: \"2\",\n  name: \"data\",\n  parse: (value) => {\n    if (!Array.isArray(value)) {\n      throw new Error('\"data\" parts expect an array value.');\n    }\n    return { type: \"data\", value };\n  }\n};\nvar errorStreamPart2 = {\n  code: \"3\",\n  name: \"error\",\n  parse: (value) => {\n    if (typeof value !== \"string\") {\n      throw new Error('\"error\" parts expect a string value.');\n    }\n    return { type: \"error\", value };\n  }\n};\nvar messageAnnotationsStreamPart = {\n  code: \"8\",\n  name: \"message_annotations\",\n  parse: (value) => {\n    if (!Array.isArray(value)) {\n      throw new Error('\"message_annotations\" parts expect an array value.');\n    }\n    return { type: \"message_annotations\", value };\n  }\n};\nvar toolCallStreamPart = {\n  code: \"9\",\n  name: \"tool_call\",\n  parse: (value) => {\n    if (value == null || typeof value !== \"object\" || !(\"toolCallId\" in value) || typeof value.toolCallId !== \"string\" || !(\"toolName\" in value) || typeof value.toolName !== \"string\" || !(\"args\" in value) || typeof value.args !== \"object\") {\n      throw new Error(\n        '\"tool_call\" parts expect an object with a \"toolCallId\", \"toolName\", and \"args\" property.'\n      );\n    }\n    return {\n      type: \"tool_call\",\n      value\n    };\n  }\n};\nvar toolResultStreamPart = {\n  code: \"a\",\n  name: \"tool_result\",\n  parse: (value) => {\n    if (value == null || typeof value !== \"object\" || !(\"toolCallId\" in value) || typeof value.toolCallId !== \"string\" || !(\"result\" in value)) {\n      throw new Error(\n        '\"tool_result\" parts expect an object with a \"toolCallId\" and a \"result\" property.'\n      );\n    }\n    return {\n      type: \"tool_result\",\n      value\n    };\n  }\n};\nvar toolCallStreamingStartStreamPart = {\n  code: \"b\",\n  name: \"tool_call_streaming_start\",\n  parse: (value) => {\n    if (value == null || typeof value !== \"object\" || !(\"toolCallId\" in value) || typeof value.toolCallId !== \"string\" || !(\"toolName\" in value) || typeof value.toolName !== \"string\") {\n      throw new Error(\n        '\"tool_call_streaming_start\" parts expect an object with a \"toolCallId\" and \"toolName\" property.'\n      );\n    }\n    return {\n      type: \"tool_call_streaming_start\",\n      value\n    };\n  }\n};\nvar toolCallDeltaStreamPart = {\n  code: \"c\",\n  name: \"tool_call_delta\",\n  parse: (value) => {\n    if (value == null || typeof value !== \"object\" || !(\"toolCallId\" in value) || typeof value.toolCallId !== \"string\" || !(\"argsTextDelta\" in value) || typeof value.argsTextDelta !== \"string\") {\n      throw new Error(\n        '\"tool_call_delta\" parts expect an object with a \"toolCallId\" and \"argsTextDelta\" property.'\n      );\n    }\n    return {\n      type: \"tool_call_delta\",\n      value\n    };\n  }\n};\nvar finishMessageStreamPart = {\n  code: \"d\",\n  name: \"finish_message\",\n  parse: (value) => {\n    if (value == null || typeof value !== \"object\" || !(\"finishReason\" in value) || typeof value.finishReason !== \"string\") {\n      throw new Error(\n        '\"finish_message\" parts expect an object with a \"finishReason\" property.'\n      );\n    }\n    const result = {\n      finishReason: value.finishReason\n    };\n    if (\"usage\" in value && value.usage != null && typeof value.usage === \"object\" && \"promptTokens\" in value.usage && \"completionTokens\" in value.usage) {\n      result.usage = {\n        promptTokens: typeof value.usage.promptTokens === \"number\" ? value.usage.promptTokens : Number.NaN,\n        completionTokens: typeof value.usage.completionTokens === \"number\" ? value.usage.completionTokens : Number.NaN\n      };\n    }\n    return {\n      type: \"finish_message\",\n      value: result\n    };\n  }\n};\nvar finishStepStreamPart = {\n  code: \"e\",\n  name: \"finish_step\",\n  parse: (value) => {\n    if (value == null || typeof value !== \"object\" || !(\"finishReason\" in value) || typeof value.finishReason !== \"string\") {\n      throw new Error(\n        '\"finish_step\" parts expect an object with a \"finishReason\" property.'\n      );\n    }\n    const result = {\n      finishReason: value.finishReason,\n      isContinued: false\n    };\n    if (\"usage\" in value && value.usage != null && typeof value.usage === \"object\" && \"promptTokens\" in value.usage && \"completionTokens\" in value.usage) {\n      result.usage = {\n        promptTokens: typeof value.usage.promptTokens === \"number\" ? value.usage.promptTokens : Number.NaN,\n        completionTokens: typeof value.usage.completionTokens === \"number\" ? value.usage.completionTokens : Number.NaN\n      };\n    }\n    if (\"isContinued\" in value && typeof value.isContinued === \"boolean\") {\n      result.isContinued = value.isContinued;\n    }\n    return {\n      type: \"finish_step\",\n      value: result\n    };\n  }\n};\nvar startStepStreamPart = {\n  code: \"f\",\n  name: \"start_step\",\n  parse: (value) => {\n    if (value == null || typeof value !== \"object\" || !(\"messageId\" in value) || typeof value.messageId !== \"string\") {\n      throw new Error(\n        '\"start_step\" parts expect an object with an \"id\" property.'\n      );\n    }\n    return {\n      type: \"start_step\",\n      value: {\n        messageId: value.messageId\n      }\n    };\n  }\n};\nvar reasoningStreamPart = {\n  code: \"g\",\n  name: \"reasoning\",\n  parse: (value) => {\n    if (typeof value !== \"string\") {\n      throw new Error('\"reasoning\" parts expect a string value.');\n    }\n    return { type: \"reasoning\", value };\n  }\n};\nvar sourcePart = {\n  code: \"h\",\n  name: \"source\",\n  parse: (value) => {\n    if (value == null || typeof value !== \"object\") {\n      throw new Error('\"source\" parts expect a Source object.');\n    }\n    return {\n      type: \"source\",\n      value\n    };\n  }\n};\nvar redactedReasoningStreamPart = {\n  code: \"i\",\n  name: \"redacted_reasoning\",\n  parse: (value) => {\n    if (value == null || typeof value !== \"object\" || !(\"data\" in value) || typeof value.data !== \"string\") {\n      throw new Error(\n        '\"redacted_reasoning\" parts expect an object with a \"data\" property.'\n      );\n    }\n    return { type: \"redacted_reasoning\", value: { data: value.data } };\n  }\n};\nvar reasoningSignatureStreamPart = {\n  code: \"j\",\n  name: \"reasoning_signature\",\n  parse: (value) => {\n    if (value == null || typeof value !== \"object\" || !(\"signature\" in value) || typeof value.signature !== \"string\") {\n      throw new Error(\n        '\"reasoning_signature\" parts expect an object with a \"signature\" property.'\n      );\n    }\n    return {\n      type: \"reasoning_signature\",\n      value: { signature: value.signature }\n    };\n  }\n};\nvar fileStreamPart = {\n  code: \"k\",\n  name: \"file\",\n  parse: (value) => {\n    if (value == null || typeof value !== \"object\" || !(\"data\" in value) || typeof value.data !== \"string\" || !(\"mimeType\" in value) || typeof value.mimeType !== \"string\") {\n      throw new Error(\n        '\"file\" parts expect an object with a \"data\" and \"mimeType\" property.'\n      );\n    }\n    return { type: \"file\", value };\n  }\n};\nvar dataStreamParts = [\n  textStreamPart2,\n  dataStreamPart,\n  errorStreamPart2,\n  messageAnnotationsStreamPart,\n  toolCallStreamPart,\n  toolResultStreamPart,\n  toolCallStreamingStartStreamPart,\n  toolCallDeltaStreamPart,\n  finishMessageStreamPart,\n  finishStepStreamPart,\n  startStepStreamPart,\n  reasoningStreamPart,\n  sourcePart,\n  redactedReasoningStreamPart,\n  reasoningSignatureStreamPart,\n  fileStreamPart\n];\nvar dataStreamPartsByCode = Object.fromEntries(\n  dataStreamParts.map((part) => [part.code, part])\n);\nvar DataStreamStringPrefixes = Object.fromEntries(\n  dataStreamParts.map((part) => [part.name, part.code])\n);\nvar validCodes2 = dataStreamParts.map((part) => part.code);\nvar parseDataStreamPart = (line) => {\n  const firstSeparatorIndex = line.indexOf(\":\");\n  if (firstSeparatorIndex === -1) {\n    throw new Error(\"Failed to parse stream string. No separator found.\");\n  }\n  const prefix = line.slice(0, firstSeparatorIndex);\n  if (!validCodes2.includes(prefix)) {\n    throw new Error(`Failed to parse stream string. Invalid code ${prefix}.`);\n  }\n  const code = prefix;\n  const textValue = line.slice(firstSeparatorIndex + 1);\n  const jsonValue = JSON.parse(textValue);\n  return dataStreamPartsByCode[code].parse(jsonValue);\n};\nfunction formatDataStreamPart(type, value) {\n  const streamPart = dataStreamParts.find((part) => part.name === type);\n  if (!streamPart) {\n    throw new Error(`Invalid stream part type: ${type}`);\n  }\n  return `${streamPart.code}:${JSON.stringify(value)}\n`;\n}\n\n// src/process-data-stream.ts\nvar NEWLINE = \"\\n\".charCodeAt(0);\nfunction concatChunks(chunks, totalLength) {\n  const concatenatedChunks = new Uint8Array(totalLength);\n  let offset = 0;\n  for (const chunk of chunks) {\n    concatenatedChunks.set(chunk, offset);\n    offset += chunk.length;\n  }\n  chunks.length = 0;\n  return concatenatedChunks;\n}\nasync function processDataStream({\n  stream,\n  onTextPart,\n  onReasoningPart,\n  onReasoningSignaturePart,\n  onRedactedReasoningPart,\n  onSourcePart,\n  onFilePart,\n  onDataPart,\n  onErrorPart,\n  onToolCallStreamingStartPart,\n  onToolCallDeltaPart,\n  onToolCallPart,\n  onToolResultPart,\n  onMessageAnnotationsPart,\n  onFinishMessagePart,\n  onFinishStepPart,\n  onStartStepPart\n}) {\n  const reader = stream.getReader();\n  const decoder = new TextDecoder();\n  const chunks = [];\n  let totalLength = 0;\n  while (true) {\n    const { value } = await reader.read();\n    if (value) {\n      chunks.push(value);\n      totalLength += value.length;\n      if (value[value.length - 1] !== NEWLINE) {\n        continue;\n      }\n    }\n    if (chunks.length === 0) {\n      break;\n    }\n    const concatenatedChunks = concatChunks(chunks, totalLength);\n    totalLength = 0;\n    const streamParts = decoder.decode(concatenatedChunks, { stream: true }).split(\"\\n\").filter((line) => line !== \"\").map(parseDataStreamPart);\n    for (const { type, value: value2 } of streamParts) {\n      switch (type) {\n        case \"text\":\n          await (onTextPart == null ? void 0 : onTextPart(value2));\n          break;\n        case \"reasoning\":\n          await (onReasoningPart == null ? void 0 : onReasoningPart(value2));\n          break;\n        case \"reasoning_signature\":\n          await (onReasoningSignaturePart == null ? void 0 : onReasoningSignaturePart(value2));\n          break;\n        case \"redacted_reasoning\":\n          await (onRedactedReasoningPart == null ? void 0 : onRedactedReasoningPart(value2));\n          break;\n        case \"file\":\n          await (onFilePart == null ? void 0 : onFilePart(value2));\n          break;\n        case \"source\":\n          await (onSourcePart == null ? void 0 : onSourcePart(value2));\n          break;\n        case \"data\":\n          await (onDataPart == null ? void 0 : onDataPart(value2));\n          break;\n        case \"error\":\n          await (onErrorPart == null ? void 0 : onErrorPart(value2));\n          break;\n        case \"message_annotations\":\n          await (onMessageAnnotationsPart == null ? void 0 : onMessageAnnotationsPart(value2));\n          break;\n        case \"tool_call_streaming_start\":\n          await (onToolCallStreamingStartPart == null ? void 0 : onToolCallStreamingStartPart(value2));\n          break;\n        case \"tool_call_delta\":\n          await (onToolCallDeltaPart == null ? void 0 : onToolCallDeltaPart(value2));\n          break;\n        case \"tool_call\":\n          await (onToolCallPart == null ? void 0 : onToolCallPart(value2));\n          break;\n        case \"tool_result\":\n          await (onToolResultPart == null ? void 0 : onToolResultPart(value2));\n          break;\n        case \"finish_message\":\n          await (onFinishMessagePart == null ? void 0 : onFinishMessagePart(value2));\n          break;\n        case \"finish_step\":\n          await (onFinishStepPart == null ? void 0 : onFinishStepPart(value2));\n          break;\n        case \"start_step\":\n          await (onStartStepPart == null ? void 0 : onStartStepPart(value2));\n          break;\n        default: {\n          const exhaustiveCheck = type;\n          throw new Error(`Unknown stream part type: ${exhaustiveCheck}`);\n        }\n      }\n    }\n  }\n}\n\n// src/process-chat-response.ts\nasync function processChatResponse({\n  stream,\n  update,\n  onToolCall,\n  onFinish,\n  generateId: generateId2 = import_provider_utils2.generateId,\n  getCurrentDate = () => /* @__PURE__ */ new Date(),\n  lastMessage\n}) {\n  var _a, _b;\n  const replaceLastMessage = (lastMessage == null ? void 0 : lastMessage.role) === \"assistant\";\n  let step = replaceLastMessage ? 1 + // find max step in existing tool invocations:\n  ((_b = (_a = lastMessage.toolInvocations) == null ? void 0 : _a.reduce((max, toolInvocation) => {\n    var _a2;\n    return Math.max(max, (_a2 = toolInvocation.step) != null ? _a2 : 0);\n  }, 0)) != null ? _b : 0) : 0;\n  const message = replaceLastMessage ? structuredClone(lastMessage) : {\n    id: generateId2(),\n    createdAt: getCurrentDate(),\n    role: \"assistant\",\n    content: \"\",\n    parts: []\n  };\n  let currentTextPart = void 0;\n  let currentReasoningPart = void 0;\n  let currentReasoningTextDetail = void 0;\n  function updateToolInvocationPart(toolCallId, invocation) {\n    const part = message.parts.find(\n      (part2) => part2.type === \"tool-invocation\" && part2.toolInvocation.toolCallId === toolCallId\n    );\n    if (part != null) {\n      part.toolInvocation = invocation;\n    } else {\n      message.parts.push({\n        type: \"tool-invocation\",\n        toolInvocation: invocation\n      });\n    }\n  }\n  const data = [];\n  let messageAnnotations = replaceLastMessage ? lastMessage == null ? void 0 : lastMessage.annotations : void 0;\n  const partialToolCalls = {};\n  let usage = {\n    completionTokens: NaN,\n    promptTokens: NaN,\n    totalTokens: NaN\n  };\n  let finishReason = \"unknown\";\n  function execUpdate() {\n    const copiedData = [...data];\n    if (messageAnnotations == null ? void 0 : messageAnnotations.length) {\n      message.annotations = messageAnnotations;\n    }\n    const copiedMessage = {\n      // deep copy the message to ensure that deep changes (msg attachments) are updated\n      // with SolidJS. SolidJS uses referential integration of sub-objects to detect changes.\n      ...structuredClone(message),\n      // add a revision id to ensure that the message is updated with SWR. SWR uses a\n      // hashing approach by default to detect changes, but it only works for shallow\n      // changes. This is why we need to add a revision id to ensure that the message\n      // is updated with SWR (without it, the changes get stuck in SWR and are not\n      // forwarded to rendering):\n      revisionId: generateId2()\n    };\n    update({\n      message: copiedMessage,\n      data: copiedData,\n      replaceLastMessage\n    });\n  }\n  await processDataStream({\n    stream,\n    onTextPart(value) {\n      if (currentTextPart == null) {\n        currentTextPart = {\n          type: \"text\",\n          text: value\n        };\n        message.parts.push(currentTextPart);\n      } else {\n        currentTextPart.text += value;\n      }\n      message.content += value;\n      execUpdate();\n    },\n    onReasoningPart(value) {\n      var _a2;\n      if (currentReasoningTextDetail == null) {\n        currentReasoningTextDetail = { type: \"text\", text: value };\n        if (currentReasoningPart != null) {\n          currentReasoningPart.details.push(currentReasoningTextDetail);\n        }\n      } else {\n        currentReasoningTextDetail.text += value;\n      }\n      if (currentReasoningPart == null) {\n        currentReasoningPart = {\n          type: \"reasoning\",\n          reasoning: value,\n          details: [currentReasoningTextDetail]\n        };\n        message.parts.push(currentReasoningPart);\n      } else {\n        currentReasoningPart.reasoning += value;\n      }\n      message.reasoning = ((_a2 = message.reasoning) != null ? _a2 : \"\") + value;\n      execUpdate();\n    },\n    onReasoningSignaturePart(value) {\n      if (currentReasoningTextDetail != null) {\n        currentReasoningTextDetail.signature = value.signature;\n      }\n    },\n    onRedactedReasoningPart(value) {\n      if (currentReasoningPart == null) {\n        currentReasoningPart = {\n          type: \"reasoning\",\n          reasoning: \"\",\n          details: []\n        };\n        message.parts.push(currentReasoningPart);\n      }\n      currentReasoningPart.details.push({\n        type: \"redacted\",\n        data: value.data\n      });\n      currentReasoningTextDetail = void 0;\n      execUpdate();\n    },\n    onFilePart(value) {\n      message.parts.push({\n        type: \"file\",\n        mimeType: value.mimeType,\n        data: value.data\n      });\n      execUpdate();\n    },\n    onSourcePart(value) {\n      message.parts.push({\n        type: \"source\",\n        source: value\n      });\n      execUpdate();\n    },\n    onToolCallStreamingStartPart(value) {\n      if (message.toolInvocations == null) {\n        message.toolInvocations = [];\n      }\n      partialToolCalls[value.toolCallId] = {\n        text: \"\",\n        step,\n        toolName: value.toolName,\n        index: message.toolInvocations.length\n      };\n      const invocation = {\n        state: \"partial-call\",\n        step,\n        toolCallId: value.toolCallId,\n        toolName: value.toolName,\n        args: void 0\n      };\n      message.toolInvocations.push(invocation);\n      updateToolInvocationPart(value.toolCallId, invocation);\n      execUpdate();\n    },\n    onToolCallDeltaPart(value) {\n      const partialToolCall = partialToolCalls[value.toolCallId];\n      partialToolCall.text += value.argsTextDelta;\n      const { value: partialArgs } = parsePartialJson(partialToolCall.text);\n      const invocation = {\n        state: \"partial-call\",\n        step: partialToolCall.step,\n        toolCallId: value.toolCallId,\n        toolName: partialToolCall.toolName,\n        args: partialArgs\n      };\n      message.toolInvocations[partialToolCall.index] = invocation;\n      updateToolInvocationPart(value.toolCallId, invocation);\n      execUpdate();\n    },\n    async onToolCallPart(value) {\n      const invocation = {\n        state: \"call\",\n        step,\n        ...value\n      };\n      if (partialToolCalls[value.toolCallId] != null) {\n        message.toolInvocations[partialToolCalls[value.toolCallId].index] = invocation;\n      } else {\n        if (message.toolInvocations == null) {\n          message.toolInvocations = [];\n        }\n        message.toolInvocations.push(invocation);\n      }\n      updateToolInvocationPart(value.toolCallId, invocation);\n      execUpdate();\n      if (onToolCall) {\n        const result = await onToolCall({ toolCall: value });\n        if (result != null) {\n          const invocation2 = {\n            state: \"result\",\n            step,\n            ...value,\n            result\n          };\n          message.toolInvocations[message.toolInvocations.length - 1] = invocation2;\n          updateToolInvocationPart(value.toolCallId, invocation2);\n          execUpdate();\n        }\n      }\n    },\n    onToolResultPart(value) {\n      const toolInvocations = message.toolInvocations;\n      if (toolInvocations == null) {\n        throw new Error(\"tool_result must be preceded by a tool_call\");\n      }\n      const toolInvocationIndex = toolInvocations.findIndex(\n        (invocation2) => invocation2.toolCallId === value.toolCallId\n      );\n      if (toolInvocationIndex === -1) {\n        throw new Error(\n          \"tool_result must be preceded by a tool_call with the same toolCallId\"\n        );\n      }\n      const invocation = {\n        ...toolInvocations[toolInvocationIndex],\n        state: \"result\",\n        ...value\n      };\n      toolInvocations[toolInvocationIndex] = invocation;\n      updateToolInvocationPart(value.toolCallId, invocation);\n      execUpdate();\n    },\n    onDataPart(value) {\n      data.push(...value);\n      execUpdate();\n    },\n    onMessageAnnotationsPart(value) {\n      if (messageAnnotations == null) {\n        messageAnnotations = [...value];\n      } else {\n        messageAnnotations.push(...value);\n      }\n      execUpdate();\n    },\n    onFinishStepPart(value) {\n      step += 1;\n      currentTextPart = value.isContinued ? currentTextPart : void 0;\n      currentReasoningPart = void 0;\n      currentReasoningTextDetail = void 0;\n    },\n    onStartStepPart(value) {\n      if (!replaceLastMessage) {\n        message.id = value.messageId;\n      }\n      message.parts.push({ type: \"step-start\" });\n      execUpdate();\n    },\n    onFinishMessagePart(value) {\n      finishReason = value.finishReason;\n      if (value.usage != null) {\n        usage = calculateLanguageModelUsage(value.usage);\n      }\n    },\n    onErrorPart(error) {\n      throw new Error(error);\n    }\n  });\n  onFinish == null ? void 0 : onFinish({ message, finishReason, usage });\n}\n\n// src/process-chat-text-response.ts\nvar import_provider_utils3 = __webpack_require__(/*! @ai-sdk/provider-utils */ \"(rsc)/./node_modules/@ai-sdk/provider-utils/dist/index.js\");\n\n// src/process-text-stream.ts\nasync function processTextStream({\n  stream,\n  onTextPart\n}) {\n  const reader = stream.pipeThrough(new TextDecoderStream()).getReader();\n  while (true) {\n    const { done, value } = await reader.read();\n    if (done) {\n      break;\n    }\n    await onTextPart(value);\n  }\n}\n\n// src/process-chat-text-response.ts\nasync function processChatTextResponse({\n  stream,\n  update,\n  onFinish,\n  getCurrentDate = () => /* @__PURE__ */ new Date(),\n  generateId: generateId2 = import_provider_utils3.generateId\n}) {\n  const textPart = { type: \"text\", text: \"\" };\n  const resultMessage = {\n    id: generateId2(),\n    createdAt: getCurrentDate(),\n    role: \"assistant\",\n    content: \"\",\n    parts: [textPart]\n  };\n  await processTextStream({\n    stream,\n    onTextPart: (chunk) => {\n      resultMessage.content += chunk;\n      textPart.text += chunk;\n      update({\n        message: { ...resultMessage },\n        data: [],\n        replaceLastMessage: false\n      });\n    }\n  });\n  onFinish == null ? void 0 : onFinish(resultMessage, {\n    usage: { completionTokens: NaN, promptTokens: NaN, totalTokens: NaN },\n    finishReason: \"unknown\"\n  });\n}\n\n// src/call-chat-api.ts\nvar getOriginalFetch = () => fetch;\nasync function callChatApi({\n  api,\n  body,\n  streamProtocol = \"data\",\n  credentials,\n  headers,\n  abortController,\n  restoreMessagesOnFailure,\n  onResponse,\n  onUpdate,\n  onFinish,\n  onToolCall,\n  generateId: generateId2,\n  fetch: fetch2 = getOriginalFetch(),\n  lastMessage\n}) {\n  var _a, _b;\n  const response = await fetch2(api, {\n    method: \"POST\",\n    body: JSON.stringify(body),\n    headers: {\n      \"Content-Type\": \"application/json\",\n      ...headers\n    },\n    signal: (_a = abortController == null ? void 0 : abortController()) == null ? void 0 : _a.signal,\n    credentials\n  }).catch((err) => {\n    restoreMessagesOnFailure();\n    throw err;\n  });\n  if (onResponse) {\n    try {\n      await onResponse(response);\n    } catch (err) {\n      throw err;\n    }\n  }\n  if (!response.ok) {\n    restoreMessagesOnFailure();\n    throw new Error(\n      (_b = await response.text()) != null ? _b : \"Failed to fetch the chat response.\"\n    );\n  }\n  if (!response.body) {\n    throw new Error(\"The response body is empty.\");\n  }\n  switch (streamProtocol) {\n    case \"text\": {\n      await processChatTextResponse({\n        stream: response.body,\n        update: onUpdate,\n        onFinish,\n        generateId: generateId2\n      });\n      return;\n    }\n    case \"data\": {\n      await processChatResponse({\n        stream: response.body,\n        update: onUpdate,\n        lastMessage,\n        onToolCall,\n        onFinish({ message, finishReason, usage }) {\n          if (onFinish && message != null) {\n            onFinish(message, { usage, finishReason });\n          }\n        },\n        generateId: generateId2\n      });\n      return;\n    }\n    default: {\n      const exhaustiveCheck = streamProtocol;\n      throw new Error(`Unknown stream protocol: ${exhaustiveCheck}`);\n    }\n  }\n}\n\n// src/call-completion-api.ts\nvar getOriginalFetch2 = () => fetch;\nasync function callCompletionApi({\n  api,\n  prompt,\n  credentials,\n  headers,\n  body,\n  streamProtocol = \"data\",\n  setCompletion,\n  setLoading,\n  setError,\n  setAbortController,\n  onResponse,\n  onFinish,\n  onError,\n  onData,\n  fetch: fetch2 = getOriginalFetch2()\n}) {\n  var _a;\n  try {\n    setLoading(true);\n    setError(void 0);\n    const abortController = new AbortController();\n    setAbortController(abortController);\n    setCompletion(\"\");\n    const response = await fetch2(api, {\n      method: \"POST\",\n      body: JSON.stringify({\n        prompt,\n        ...body\n      }),\n      credentials,\n      headers: {\n        \"Content-Type\": \"application/json\",\n        ...headers\n      },\n      signal: abortController.signal\n    }).catch((err) => {\n      throw err;\n    });\n    if (onResponse) {\n      try {\n        await onResponse(response);\n      } catch (err) {\n        throw err;\n      }\n    }\n    if (!response.ok) {\n      throw new Error(\n        (_a = await response.text()) != null ? _a : \"Failed to fetch the chat response.\"\n      );\n    }\n    if (!response.body) {\n      throw new Error(\"The response body is empty.\");\n    }\n    let result = \"\";\n    switch (streamProtocol) {\n      case \"text\": {\n        await processTextStream({\n          stream: response.body,\n          onTextPart: (chunk) => {\n            result += chunk;\n            setCompletion(result);\n          }\n        });\n        break;\n      }\n      case \"data\": {\n        await processDataStream({\n          stream: response.body,\n          onTextPart(value) {\n            result += value;\n            setCompletion(result);\n          },\n          onDataPart(value) {\n            onData == null ? void 0 : onData(value);\n          },\n          onErrorPart(value) {\n            throw new Error(value);\n          }\n        });\n        break;\n      }\n      default: {\n        const exhaustiveCheck = streamProtocol;\n        throw new Error(`Unknown stream protocol: ${exhaustiveCheck}`);\n      }\n    }\n    if (onFinish) {\n      onFinish(prompt, result);\n    }\n    setAbortController(null);\n    return result;\n  } catch (err) {\n    if (err.name === \"AbortError\") {\n      setAbortController(null);\n      return null;\n    }\n    if (err instanceof Error) {\n      if (onError) {\n        onError(err);\n      }\n    }\n    setError(err);\n  } finally {\n    setLoading(false);\n  }\n}\n\n// src/data-url.ts\nfunction getTextFromDataUrl(dataUrl) {\n  const [header, base64Content] = dataUrl.split(\",\");\n  const mimeType = header.split(\";\")[0].split(\":\")[1];\n  if (mimeType == null || base64Content == null) {\n    throw new Error(\"Invalid data URL format\");\n  }\n  try {\n    return window.atob(base64Content);\n  } catch (error) {\n    throw new Error(`Error decoding data URL`);\n  }\n}\n\n// src/extract-max-tool-invocation-step.ts\nfunction extractMaxToolInvocationStep(toolInvocations) {\n  return toolInvocations == null ? void 0 : toolInvocations.reduce((max, toolInvocation) => {\n    var _a;\n    return Math.max(max, (_a = toolInvocation.step) != null ? _a : 0);\n  }, 0);\n}\n\n// src/get-message-parts.ts\nfunction getMessageParts(message) {\n  var _a;\n  return (_a = message.parts) != null ? _a : [\n    ...message.toolInvocations ? message.toolInvocations.map((toolInvocation) => ({\n      type: \"tool-invocation\",\n      toolInvocation\n    })) : [],\n    ...message.reasoning ? [\n      {\n        type: \"reasoning\",\n        reasoning: message.reasoning,\n        details: [{ type: \"text\", text: message.reasoning }]\n      }\n    ] : [],\n    ...message.content ? [{ type: \"text\", text: message.content }] : []\n  ];\n}\n\n// src/fill-message-parts.ts\nfunction fillMessageParts(messages) {\n  return messages.map((message) => ({\n    ...message,\n    parts: getMessageParts(message)\n  }));\n}\n\n// src/is-deep-equal-data.ts\nfunction isDeepEqualData(obj1, obj2) {\n  if (obj1 === obj2)\n    return true;\n  if (obj1 == null || obj2 == null)\n    return false;\n  if (typeof obj1 !== \"object\" && typeof obj2 !== \"object\")\n    return obj1 === obj2;\n  if (obj1.constructor !== obj2.constructor)\n    return false;\n  if (obj1 instanceof Date && obj2 instanceof Date) {\n    return obj1.getTime() === obj2.getTime();\n  }\n  if (Array.isArray(obj1)) {\n    if (obj1.length !== obj2.length)\n      return false;\n    for (let i = 0; i < obj1.length; i++) {\n      if (!isDeepEqualData(obj1[i], obj2[i]))\n        return false;\n    }\n    return true;\n  }\n  const keys1 = Object.keys(obj1);\n  const keys2 = Object.keys(obj2);\n  if (keys1.length !== keys2.length)\n    return false;\n  for (const key of keys1) {\n    if (!keys2.includes(key))\n      return false;\n    if (!isDeepEqualData(obj1[key], obj2[key]))\n      return false;\n  }\n  return true;\n}\n\n// src/prepare-attachments-for-request.ts\nasync function prepareAttachmentsForRequest(attachmentsFromOptions) {\n  if (!attachmentsFromOptions) {\n    return [];\n  }\n  if (attachmentsFromOptions instanceof FileList) {\n    return Promise.all(\n      Array.from(attachmentsFromOptions).map(async (attachment) => {\n        const { name, type } = attachment;\n        const dataUrl = await new Promise((resolve, reject) => {\n          const reader = new FileReader();\n          reader.onload = (readerEvent) => {\n            var _a;\n            resolve((_a = readerEvent.target) == null ? void 0 : _a.result);\n          };\n          reader.onerror = (error) => reject(error);\n          reader.readAsDataURL(attachment);\n        });\n        return {\n          name,\n          contentType: type,\n          url: dataUrl\n        };\n      })\n    );\n  }\n  if (Array.isArray(attachmentsFromOptions)) {\n    return attachmentsFromOptions;\n  }\n  throw new Error(\"Invalid attachments type\");\n}\n\n// src/process-assistant-stream.ts\nvar NEWLINE2 = \"\\n\".charCodeAt(0);\nfunction concatChunks2(chunks, totalLength) {\n  const concatenatedChunks = new Uint8Array(totalLength);\n  let offset = 0;\n  for (const chunk of chunks) {\n    concatenatedChunks.set(chunk, offset);\n    offset += chunk.length;\n  }\n  chunks.length = 0;\n  return concatenatedChunks;\n}\nasync function processAssistantStream({\n  stream,\n  onTextPart,\n  onErrorPart,\n  onAssistantMessagePart,\n  onAssistantControlDataPart,\n  onDataMessagePart\n}) {\n  const reader = stream.getReader();\n  const decoder = new TextDecoder();\n  const chunks = [];\n  let totalLength = 0;\n  while (true) {\n    const { value } = await reader.read();\n    if (value) {\n      chunks.push(value);\n      totalLength += value.length;\n      if (value[value.length - 1] !== NEWLINE2) {\n        continue;\n      }\n    }\n    if (chunks.length === 0) {\n      break;\n    }\n    const concatenatedChunks = concatChunks2(chunks, totalLength);\n    totalLength = 0;\n    const streamParts = decoder.decode(concatenatedChunks, { stream: true }).split(\"\\n\").filter((line) => line !== \"\").map(parseAssistantStreamPart);\n    for (const { type, value: value2 } of streamParts) {\n      switch (type) {\n        case \"text\":\n          await (onTextPart == null ? void 0 : onTextPart(value2));\n          break;\n        case \"error\":\n          await (onErrorPart == null ? void 0 : onErrorPart(value2));\n          break;\n        case \"assistant_message\":\n          await (onAssistantMessagePart == null ? void 0 : onAssistantMessagePart(value2));\n          break;\n        case \"assistant_control_data\":\n          await (onAssistantControlDataPart == null ? void 0 : onAssistantControlDataPart(value2));\n          break;\n        case \"data_message\":\n          await (onDataMessagePart == null ? void 0 : onDataMessagePart(value2));\n          break;\n        default: {\n          const exhaustiveCheck = type;\n          throw new Error(`Unknown stream part type: ${exhaustiveCheck}`);\n        }\n      }\n    }\n  }\n}\n\n// src/schema.ts\nvar import_provider_utils4 = __webpack_require__(/*! @ai-sdk/provider-utils */ \"(rsc)/./node_modules/@ai-sdk/provider-utils/dist/index.js\");\n\n// src/zod-schema.ts\nvar import_zod_to_json_schema = __toESM(__webpack_require__(/*! zod-to-json-schema */ \"(rsc)/./node_modules/zod-to-json-schema/dist/cjs/index.js\"));\nfunction zodSchema(zodSchema2, options) {\n  var _a;\n  const useReferences = (_a = options == null ? void 0 : options.useReferences) != null ? _a : false;\n  return jsonSchema(\n    (0, import_zod_to_json_schema.default)(zodSchema2, {\n      $refStrategy: useReferences ? \"root\" : \"none\",\n      target: \"jsonSchema7\"\n      // note: openai mode breaks various gemini conversions\n    }),\n    {\n      validate: (value) => {\n        const result = zodSchema2.safeParse(value);\n        return result.success ? { success: true, value: result.data } : { success: false, error: result.error };\n      }\n    }\n  );\n}\n\n// src/schema.ts\nvar schemaSymbol = Symbol.for(\"vercel.ai.schema\");\nfunction jsonSchema(jsonSchema2, {\n  validate\n} = {}) {\n  return {\n    [schemaSymbol]: true,\n    _type: void 0,\n    // should never be used directly\n    [import_provider_utils4.validatorSymbol]: true,\n    jsonSchema: jsonSchema2,\n    validate\n  };\n}\nfunction isSchema(value) {\n  return typeof value === \"object\" && value !== null && schemaSymbol in value && value[schemaSymbol] === true && \"jsonSchema\" in value && \"validate\" in value;\n}\nfunction asSchema(schema) {\n  return isSchema(schema) ? schema : zodSchema(schema);\n}\n\n// src/should-resubmit-messages.ts\nfunction shouldResubmitMessages({\n  originalMaxToolInvocationStep,\n  originalMessageCount,\n  maxSteps,\n  messages\n}) {\n  var _a;\n  const lastMessage = messages[messages.length - 1];\n  return (\n    // check if the feature is enabled:\n    maxSteps > 1 && // ensure there is a last message:\n    lastMessage != null && // ensure we actually have new steps (to prevent infinite loops in case of errors):\n    (messages.length > originalMessageCount || extractMaxToolInvocationStep(lastMessage.toolInvocations) !== originalMaxToolInvocationStep) && // check that next step is possible:\n    isAssistantMessageWithCompletedToolCalls(lastMessage) && // limit the number of automatic steps:\n    ((_a = extractMaxToolInvocationStep(lastMessage.toolInvocations)) != null ? _a : 0) < maxSteps\n  );\n}\nfunction isAssistantMessageWithCompletedToolCalls(message) {\n  if (message.role !== \"assistant\") {\n    return false;\n  }\n  const lastStepStartIndex = message.parts.reduce((lastIndex, part, index) => {\n    return part.type === \"step-start\" ? index : lastIndex;\n  }, -1);\n  const lastStepToolInvocations = message.parts.slice(lastStepStartIndex + 1).filter((part) => part.type === \"tool-invocation\");\n  return lastStepToolInvocations.length > 0 && lastStepToolInvocations.every((part) => \"result\" in part.toolInvocation);\n}\n\n// src/update-tool-call-result.ts\nfunction updateToolCallResult({\n  messages,\n  toolCallId,\n  toolResult: result\n}) {\n  var _a;\n  const lastMessage = messages[messages.length - 1];\n  const invocationPart = lastMessage.parts.find(\n    (part) => part.type === \"tool-invocation\" && part.toolInvocation.toolCallId === toolCallId\n  );\n  if (invocationPart == null) {\n    return;\n  }\n  const toolResult = {\n    ...invocationPart.toolInvocation,\n    state: \"result\",\n    result\n  };\n  invocationPart.toolInvocation = toolResult;\n  lastMessage.toolInvocations = (_a = lastMessage.toolInvocations) == null ? void 0 : _a.map(\n    (toolInvocation) => toolInvocation.toolCallId === toolCallId ? toolResult : toolInvocation\n  );\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGFpLXNkay91aS11dGlscy9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0RkFBNEY7QUFDekg7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLDhCQUE4QjtBQUN2RztBQUNBO0FBQ0Esb0RBQW9ELGtCQUFrQixhQUFhOztBQUVuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsNkJBQTZCLG1CQUFPLENBQUMseUZBQXdCOztBQUU3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsT0FBTztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsS0FBSztBQUN0RDtBQUNBLFlBQVksZ0JBQWdCLEdBQUc7QUFDL0I7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QixtQkFBTyxDQUFDLHlGQUF3Qjs7QUFFN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLG1CQUFPLENBQUMseUZBQXdCOztBQUU1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFFBQVE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSwwREFBMEQsZ0JBQWdCO0FBQzFFO0FBQ0EsYUFBYTtBQUNiO0FBQ0Esc0RBQXNELHlCQUF5QjtBQUMvRTtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHFDQUFxQztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsT0FBTztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsS0FBSztBQUN0RDtBQUNBLFlBQVksZ0JBQWdCLEdBQUc7QUFDL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsY0FBYztBQUMzRSxpQkFBaUIsc0JBQXNCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxnQkFBZ0I7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsY0FBYyxxQkFBcUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGlCQUFpQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QSw2REFBNkQsY0FBYztBQUMzRSxpQkFBaUIsc0JBQXNCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxnQkFBZ0I7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QixtQkFBTyxDQUFDLHlGQUF3Qjs7QUFFN0Q7QUFDQSx3Q0FBd0MsbUJBQU8sQ0FBQyxxRkFBb0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msb0NBQW9DLElBQUk7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUk7QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLENBd0JMO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXJ2aXZhbC1mdW4vLi9ub2RlX21vZHVsZXMvQGFpLXNkay91aS11dGlscy9kaXN0L2luZGV4LmpzPzlmMWYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9fZ2V0UHJvdG9PZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fdG9FU00gPSAobW9kLCBpc05vZGVNb2RlLCB0YXJnZXQpID0+ICh0YXJnZXQgPSBtb2QgIT0gbnVsbCA/IF9fY3JlYXRlKF9fZ2V0UHJvdG9PZihtb2QpKSA6IHt9LCBfX2NvcHlQcm9wcyhcbiAgLy8gSWYgdGhlIGltcG9ydGVyIGlzIGluIG5vZGUgY29tcGF0aWJpbGl0eSBtb2RlIG9yIHRoaXMgaXMgbm90IGFuIEVTTVxuICAvLyBmaWxlIHRoYXQgaGFzIGJlZW4gY29udmVydGVkIHRvIGEgQ29tbW9uSlMgZmlsZSB1c2luZyBhIEJhYmVsLVxuICAvLyBjb21wYXRpYmxlIHRyYW5zZm9ybSAoaS5lLiBcIl9fZXNNb2R1bGVcIiBoYXMgbm90IGJlZW4gc2V0KSwgdGhlbiBzZXRcbiAgLy8gXCJkZWZhdWx0XCIgdG8gdGhlIENvbW1vbkpTIFwibW9kdWxlLmV4cG9ydHNcIiBmb3Igbm9kZSBjb21wYXRpYmlsaXR5LlxuICBpc05vZGVNb2RlIHx8ICFtb2QgfHwgIW1vZC5fX2VzTW9kdWxlID8gX19kZWZQcm9wKHRhcmdldCwgXCJkZWZhdWx0XCIsIHsgdmFsdWU6IG1vZCwgZW51bWVyYWJsZTogdHJ1ZSB9KSA6IHRhcmdldCxcbiAgbW9kXG4pKTtcbnZhciBfX3RvQ29tbW9uSlMgPSAobW9kKSA9PiBfX2NvcHlQcm9wcyhfX2RlZlByb3Aoe30sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pLCBtb2QpO1xuXG4vLyBzcmMvaW5kZXgudHNcbnZhciBzcmNfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoc3JjX2V4cG9ydHMsIHtcbiAgYXNTY2hlbWE6ICgpID0+IGFzU2NoZW1hLFxuICBjYWxsQ2hhdEFwaTogKCkgPT4gY2FsbENoYXRBcGksXG4gIGNhbGxDb21wbGV0aW9uQXBpOiAoKSA9PiBjYWxsQ29tcGxldGlvbkFwaSxcbiAgZXh0cmFjdE1heFRvb2xJbnZvY2F0aW9uU3RlcDogKCkgPT4gZXh0cmFjdE1heFRvb2xJbnZvY2F0aW9uU3RlcCxcbiAgZmlsbE1lc3NhZ2VQYXJ0czogKCkgPT4gZmlsbE1lc3NhZ2VQYXJ0cyxcbiAgZm9ybWF0QXNzaXN0YW50U3RyZWFtUGFydDogKCkgPT4gZm9ybWF0QXNzaXN0YW50U3RyZWFtUGFydCxcbiAgZm9ybWF0RGF0YVN0cmVhbVBhcnQ6ICgpID0+IGZvcm1hdERhdGFTdHJlYW1QYXJ0LFxuICBnZW5lcmF0ZUlkOiAoKSA9PiBpbXBvcnRfcHJvdmlkZXJfdXRpbHM1LmdlbmVyYXRlSWQsXG4gIGdldE1lc3NhZ2VQYXJ0czogKCkgPT4gZ2V0TWVzc2FnZVBhcnRzLFxuICBnZXRUZXh0RnJvbURhdGFVcmw6ICgpID0+IGdldFRleHRGcm9tRGF0YVVybCxcbiAgaXNBc3Npc3RhbnRNZXNzYWdlV2l0aENvbXBsZXRlZFRvb2xDYWxsczogKCkgPT4gaXNBc3Npc3RhbnRNZXNzYWdlV2l0aENvbXBsZXRlZFRvb2xDYWxscyxcbiAgaXNEZWVwRXF1YWxEYXRhOiAoKSA9PiBpc0RlZXBFcXVhbERhdGEsXG4gIGpzb25TY2hlbWE6ICgpID0+IGpzb25TY2hlbWEsXG4gIHBhcnNlQXNzaXN0YW50U3RyZWFtUGFydDogKCkgPT4gcGFyc2VBc3Npc3RhbnRTdHJlYW1QYXJ0LFxuICBwYXJzZURhdGFTdHJlYW1QYXJ0OiAoKSA9PiBwYXJzZURhdGFTdHJlYW1QYXJ0LFxuICBwYXJzZVBhcnRpYWxKc29uOiAoKSA9PiBwYXJzZVBhcnRpYWxKc29uLFxuICBwcmVwYXJlQXR0YWNobWVudHNGb3JSZXF1ZXN0OiAoKSA9PiBwcmVwYXJlQXR0YWNobWVudHNGb3JSZXF1ZXN0LFxuICBwcm9jZXNzQXNzaXN0YW50U3RyZWFtOiAoKSA9PiBwcm9jZXNzQXNzaXN0YW50U3RyZWFtLFxuICBwcm9jZXNzRGF0YVN0cmVhbTogKCkgPT4gcHJvY2Vzc0RhdGFTdHJlYW0sXG4gIHByb2Nlc3NUZXh0U3RyZWFtOiAoKSA9PiBwcm9jZXNzVGV4dFN0cmVhbSxcbiAgc2hvdWxkUmVzdWJtaXRNZXNzYWdlczogKCkgPT4gc2hvdWxkUmVzdWJtaXRNZXNzYWdlcyxcbiAgdXBkYXRlVG9vbENhbGxSZXN1bHQ6ICgpID0+IHVwZGF0ZVRvb2xDYWxsUmVzdWx0LFxuICB6b2RTY2hlbWE6ICgpID0+IHpvZFNjaGVtYVxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IF9fdG9Db21tb25KUyhzcmNfZXhwb3J0cyk7XG52YXIgaW1wb3J0X3Byb3ZpZGVyX3V0aWxzNSA9IHJlcXVpcmUoXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCIpO1xuXG4vLyBzcmMvYXNzaXN0YW50LXN0cmVhbS1wYXJ0cy50c1xudmFyIHRleHRTdHJlYW1QYXJ0ID0ge1xuICBjb2RlOiBcIjBcIixcbiAgbmFtZTogXCJ0ZXh0XCIsXG4gIHBhcnNlOiAodmFsdWUpID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1widGV4dFwiIHBhcnRzIGV4cGVjdCBhIHN0cmluZyB2YWx1ZS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdHlwZTogXCJ0ZXh0XCIsIHZhbHVlIH07XG4gIH1cbn07XG52YXIgZXJyb3JTdHJlYW1QYXJ0ID0ge1xuICBjb2RlOiBcIjNcIixcbiAgbmFtZTogXCJlcnJvclwiLFxuICBwYXJzZTogKHZhbHVlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcImVycm9yXCIgcGFydHMgZXhwZWN0IGEgc3RyaW5nIHZhbHVlLicpO1xuICAgIH1cbiAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIHZhbHVlIH07XG4gIH1cbn07XG52YXIgYXNzaXN0YW50TWVzc2FnZVN0cmVhbVBhcnQgPSB7XG4gIGNvZGU6IFwiNFwiLFxuICBuYW1lOiBcImFzc2lzdGFudF9tZXNzYWdlXCIsXG4gIHBhcnNlOiAodmFsdWUpID0+IHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgIShcImlkXCIgaW4gdmFsdWUpIHx8ICEoXCJyb2xlXCIgaW4gdmFsdWUpIHx8ICEoXCJjb250ZW50XCIgaW4gdmFsdWUpIHx8IHR5cGVvZiB2YWx1ZS5pZCAhPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdmFsdWUucm9sZSAhPT0gXCJzdHJpbmdcIiB8fCB2YWx1ZS5yb2xlICE9PSBcImFzc2lzdGFudFwiIHx8ICFBcnJheS5pc0FycmF5KHZhbHVlLmNvbnRlbnQpIHx8ICF2YWx1ZS5jb250ZW50LmV2ZXJ5KFxuICAgICAgKGl0ZW0pID0+IGl0ZW0gIT0gbnVsbCAmJiB0eXBlb2YgaXRlbSA9PT0gXCJvYmplY3RcIiAmJiBcInR5cGVcIiBpbiBpdGVtICYmIGl0ZW0udHlwZSA9PT0gXCJ0ZXh0XCIgJiYgXCJ0ZXh0XCIgaW4gaXRlbSAmJiBpdGVtLnRleHQgIT0gbnVsbCAmJiB0eXBlb2YgaXRlbS50ZXh0ID09PSBcIm9iamVjdFwiICYmIFwidmFsdWVcIiBpbiBpdGVtLnRleHQgJiYgdHlwZW9mIGl0ZW0udGV4dC52YWx1ZSA9PT0gXCJzdHJpbmdcIlxuICAgICkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1wiYXNzaXN0YW50X21lc3NhZ2VcIiBwYXJ0cyBleHBlY3QgYW4gb2JqZWN0IHdpdGggYW4gXCJpZFwiLCBcInJvbGVcIiwgYW5kIFwiY29udGVudFwiIHByb3BlcnR5LidcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImFzc2lzdGFudF9tZXNzYWdlXCIsXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH1cbn07XG52YXIgYXNzaXN0YW50Q29udHJvbERhdGFTdHJlYW1QYXJ0ID0ge1xuICBjb2RlOiBcIjVcIixcbiAgbmFtZTogXCJhc3Npc3RhbnRfY29udHJvbF9kYXRhXCIsXG4gIHBhcnNlOiAodmFsdWUpID0+IHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgIShcInRocmVhZElkXCIgaW4gdmFsdWUpIHx8ICEoXCJtZXNzYWdlSWRcIiBpbiB2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlLnRocmVhZElkICE9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB2YWx1ZS5tZXNzYWdlSWQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1wiYXNzaXN0YW50X2NvbnRyb2xfZGF0YVwiIHBhcnRzIGV4cGVjdCBhbiBvYmplY3Qgd2l0aCBhIFwidGhyZWFkSWRcIiBhbmQgXCJtZXNzYWdlSWRcIiBwcm9wZXJ0eS4nXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJhc3Npc3RhbnRfY29udHJvbF9kYXRhXCIsXG4gICAgICB2YWx1ZToge1xuICAgICAgICB0aHJlYWRJZDogdmFsdWUudGhyZWFkSWQsXG4gICAgICAgIG1lc3NhZ2VJZDogdmFsdWUubWVzc2FnZUlkXG4gICAgICB9XG4gICAgfTtcbiAgfVxufTtcbnZhciBkYXRhTWVzc2FnZVN0cmVhbVBhcnQgPSB7XG4gIGNvZGU6IFwiNlwiLFxuICBuYW1lOiBcImRhdGFfbWVzc2FnZVwiLFxuICBwYXJzZTogKHZhbHVlKSA9PiB7XG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8ICEoXCJyb2xlXCIgaW4gdmFsdWUpIHx8ICEoXCJkYXRhXCIgaW4gdmFsdWUpIHx8IHR5cGVvZiB2YWx1ZS5yb2xlICE9PSBcInN0cmluZ1wiIHx8IHZhbHVlLnJvbGUgIT09IFwiZGF0YVwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdcImRhdGFfbWVzc2FnZVwiIHBhcnRzIGV4cGVjdCBhbiBvYmplY3Qgd2l0aCBhIFwicm9sZVwiIGFuZCBcImRhdGFcIiBwcm9wZXJ0eS4nXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJkYXRhX21lc3NhZ2VcIixcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgfVxufTtcbnZhciBhc3Npc3RhbnRTdHJlYW1QYXJ0cyA9IFtcbiAgdGV4dFN0cmVhbVBhcnQsXG4gIGVycm9yU3RyZWFtUGFydCxcbiAgYXNzaXN0YW50TWVzc2FnZVN0cmVhbVBhcnQsXG4gIGFzc2lzdGFudENvbnRyb2xEYXRhU3RyZWFtUGFydCxcbiAgZGF0YU1lc3NhZ2VTdHJlYW1QYXJ0XG5dO1xudmFyIGFzc2lzdGFudFN0cmVhbVBhcnRzQnlDb2RlID0ge1xuICBbdGV4dFN0cmVhbVBhcnQuY29kZV06IHRleHRTdHJlYW1QYXJ0LFxuICBbZXJyb3JTdHJlYW1QYXJ0LmNvZGVdOiBlcnJvclN0cmVhbVBhcnQsXG4gIFthc3Npc3RhbnRNZXNzYWdlU3RyZWFtUGFydC5jb2RlXTogYXNzaXN0YW50TWVzc2FnZVN0cmVhbVBhcnQsXG4gIFthc3Npc3RhbnRDb250cm9sRGF0YVN0cmVhbVBhcnQuY29kZV06IGFzc2lzdGFudENvbnRyb2xEYXRhU3RyZWFtUGFydCxcbiAgW2RhdGFNZXNzYWdlU3RyZWFtUGFydC5jb2RlXTogZGF0YU1lc3NhZ2VTdHJlYW1QYXJ0XG59O1xudmFyIFN0cmVhbVN0cmluZ1ByZWZpeGVzID0ge1xuICBbdGV4dFN0cmVhbVBhcnQubmFtZV06IHRleHRTdHJlYW1QYXJ0LmNvZGUsXG4gIFtlcnJvclN0cmVhbVBhcnQubmFtZV06IGVycm9yU3RyZWFtUGFydC5jb2RlLFxuICBbYXNzaXN0YW50TWVzc2FnZVN0cmVhbVBhcnQubmFtZV06IGFzc2lzdGFudE1lc3NhZ2VTdHJlYW1QYXJ0LmNvZGUsXG4gIFthc3Npc3RhbnRDb250cm9sRGF0YVN0cmVhbVBhcnQubmFtZV06IGFzc2lzdGFudENvbnRyb2xEYXRhU3RyZWFtUGFydC5jb2RlLFxuICBbZGF0YU1lc3NhZ2VTdHJlYW1QYXJ0Lm5hbWVdOiBkYXRhTWVzc2FnZVN0cmVhbVBhcnQuY29kZVxufTtcbnZhciB2YWxpZENvZGVzID0gYXNzaXN0YW50U3RyZWFtUGFydHMubWFwKChwYXJ0KSA9PiBwYXJ0LmNvZGUpO1xudmFyIHBhcnNlQXNzaXN0YW50U3RyZWFtUGFydCA9IChsaW5lKSA9PiB7XG4gIGNvbnN0IGZpcnN0U2VwYXJhdG9ySW5kZXggPSBsaW5lLmluZGV4T2YoXCI6XCIpO1xuICBpZiAoZmlyc3RTZXBhcmF0b3JJbmRleCA9PT0gLTEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gcGFyc2Ugc3RyZWFtIHN0cmluZy4gTm8gc2VwYXJhdG9yIGZvdW5kLlwiKTtcbiAgfVxuICBjb25zdCBwcmVmaXggPSBsaW5lLnNsaWNlKDAsIGZpcnN0U2VwYXJhdG9ySW5kZXgpO1xuICBpZiAoIXZhbGlkQ29kZXMuaW5jbHVkZXMocHJlZml4KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHBhcnNlIHN0cmVhbSBzdHJpbmcuIEludmFsaWQgY29kZSAke3ByZWZpeH0uYCk7XG4gIH1cbiAgY29uc3QgY29kZSA9IHByZWZpeDtcbiAgY29uc3QgdGV4dFZhbHVlID0gbGluZS5zbGljZShmaXJzdFNlcGFyYXRvckluZGV4ICsgMSk7XG4gIGNvbnN0IGpzb25WYWx1ZSA9IEpTT04ucGFyc2UodGV4dFZhbHVlKTtcbiAgcmV0dXJuIGFzc2lzdGFudFN0cmVhbVBhcnRzQnlDb2RlW2NvZGVdLnBhcnNlKGpzb25WYWx1ZSk7XG59O1xuZnVuY3Rpb24gZm9ybWF0QXNzaXN0YW50U3RyZWFtUGFydCh0eXBlLCB2YWx1ZSkge1xuICBjb25zdCBzdHJlYW1QYXJ0ID0gYXNzaXN0YW50U3RyZWFtUGFydHMuZmluZCgocGFydCkgPT4gcGFydC5uYW1lID09PSB0eXBlKTtcbiAgaWYgKCFzdHJlYW1QYXJ0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHN0cmVhbSBwYXJ0IHR5cGU6ICR7dHlwZX1gKTtcbiAgfVxuICByZXR1cm4gYCR7c3RyZWFtUGFydC5jb2RlfToke0pTT04uc3RyaW5naWZ5KHZhbHVlKX1cbmA7XG59XG5cbi8vIHNyYy9wcm9jZXNzLWNoYXQtcmVzcG9uc2UudHNcbnZhciBpbXBvcnRfcHJvdmlkZXJfdXRpbHMyID0gcmVxdWlyZShcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIik7XG5cbi8vIHNyYy9kdXBsaWNhdGVkL3VzYWdlLnRzXG5mdW5jdGlvbiBjYWxjdWxhdGVMYW5ndWFnZU1vZGVsVXNhZ2Uoe1xuICBwcm9tcHRUb2tlbnMsXG4gIGNvbXBsZXRpb25Ub2tlbnNcbn0pIHtcbiAgcmV0dXJuIHtcbiAgICBwcm9tcHRUb2tlbnMsXG4gICAgY29tcGxldGlvblRva2VucyxcbiAgICB0b3RhbFRva2VuczogcHJvbXB0VG9rZW5zICsgY29tcGxldGlvblRva2Vuc1xuICB9O1xufVxuXG4vLyBzcmMvcGFyc2UtcGFydGlhbC1qc29uLnRzXG52YXIgaW1wb3J0X3Byb3ZpZGVyX3V0aWxzID0gcmVxdWlyZShcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIik7XG5cbi8vIHNyYy9maXgtanNvbi50c1xuZnVuY3Rpb24gZml4SnNvbihpbnB1dCkge1xuICBjb25zdCBzdGFjayA9IFtcIlJPT1RcIl07XG4gIGxldCBsYXN0VmFsaWRJbmRleCA9IC0xO1xuICBsZXQgbGl0ZXJhbFN0YXJ0ID0gbnVsbDtcbiAgZnVuY3Rpb24gcHJvY2Vzc1ZhbHVlU3RhcnQoY2hhciwgaSwgc3dhcFN0YXRlKSB7XG4gICAge1xuICAgICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICAgIGNhc2UgJ1wiJzoge1xuICAgICAgICAgIGxhc3RWYWxpZEluZGV4ID0gaTtcbiAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICBzdGFjay5wdXNoKHN3YXBTdGF0ZSk7XG4gICAgICAgICAgc3RhY2sucHVzaChcIklOU0lERV9TVFJJTkdcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcImZcIjpcbiAgICAgICAgY2FzZSBcInRcIjpcbiAgICAgICAgY2FzZSBcIm5cIjoge1xuICAgICAgICAgIGxhc3RWYWxpZEluZGV4ID0gaTtcbiAgICAgICAgICBsaXRlcmFsU3RhcnQgPSBpO1xuICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgIHN0YWNrLnB1c2goc3dhcFN0YXRlKTtcbiAgICAgICAgICBzdGFjay5wdXNoKFwiSU5TSURFX0xJVEVSQUxcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIi1cIjoge1xuICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgIHN0YWNrLnB1c2goc3dhcFN0YXRlKTtcbiAgICAgICAgICBzdGFjay5wdXNoKFwiSU5TSURFX05VTUJFUlwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiMFwiOlxuICAgICAgICBjYXNlIFwiMVwiOlxuICAgICAgICBjYXNlIFwiMlwiOlxuICAgICAgICBjYXNlIFwiM1wiOlxuICAgICAgICBjYXNlIFwiNFwiOlxuICAgICAgICBjYXNlIFwiNVwiOlxuICAgICAgICBjYXNlIFwiNlwiOlxuICAgICAgICBjYXNlIFwiN1wiOlxuICAgICAgICBjYXNlIFwiOFwiOlxuICAgICAgICBjYXNlIFwiOVwiOiB7XG4gICAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgIHN0YWNrLnB1c2goc3dhcFN0YXRlKTtcbiAgICAgICAgICBzdGFjay5wdXNoKFwiSU5TSURFX05VTUJFUlwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwie1wiOiB7XG4gICAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgIHN0YWNrLnB1c2goc3dhcFN0YXRlKTtcbiAgICAgICAgICBzdGFjay5wdXNoKFwiSU5TSURFX09CSkVDVF9TVEFSVFwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiW1wiOiB7XG4gICAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgIHN0YWNrLnB1c2goc3dhcFN0YXRlKTtcbiAgICAgICAgICBzdGFjay5wdXNoKFwiSU5TSURFX0FSUkFZX1NUQVJUXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHByb2Nlc3NBZnRlck9iamVjdFZhbHVlKGNoYXIsIGkpIHtcbiAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgIGNhc2UgXCIsXCI6IHtcbiAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfT0JKRUNUX0FGVEVSX0NPTU1BXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJ9XCI6IHtcbiAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHByb2Nlc3NBZnRlckFycmF5VmFsdWUoY2hhciwgaSkge1xuICAgIHN3aXRjaCAoY2hhcikge1xuICAgICAgY2FzZSBcIixcIjoge1xuICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgc3RhY2sucHVzaChcIklOU0lERV9BUlJBWV9BRlRFUl9DT01NQVwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiXVwiOiB7XG4gICAgICAgIGxhc3RWYWxpZEluZGV4ID0gaTtcbiAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY2hhciA9IGlucHV0W2ldO1xuICAgIGNvbnN0IGN1cnJlbnRTdGF0ZSA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgIHN3aXRjaCAoY3VycmVudFN0YXRlKSB7XG4gICAgICBjYXNlIFwiUk9PVFwiOlxuICAgICAgICBwcm9jZXNzVmFsdWVTdGFydChjaGFyLCBpLCBcIkZJTklTSFwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiSU5TSURFX09CSkVDVF9TVEFSVFwiOiB7XG4gICAgICAgIHN3aXRjaCAoY2hhcikge1xuICAgICAgICAgIGNhc2UgJ1wiJzoge1xuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBzdGFjay5wdXNoKFwiSU5TSURFX09CSkVDVF9LRVlcIik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcIn1cIjoge1xuICAgICAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiSU5TSURFX09CSkVDVF9BRlRFUl9DT01NQVwiOiB7XG4gICAgICAgIHN3aXRjaCAoY2hhcikge1xuICAgICAgICAgIGNhc2UgJ1wiJzoge1xuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBzdGFjay5wdXNoKFwiSU5TSURFX09CSkVDVF9LRVlcIik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiSU5TSURFX09CSkVDVF9LRVlcIjoge1xuICAgICAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgICAgICBjYXNlICdcIic6IHtcbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgc3RhY2sucHVzaChcIklOU0lERV9PQkpFQ1RfQUZURVJfS0VZXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIklOU0lERV9PQkpFQ1RfQUZURVJfS0VZXCI6IHtcbiAgICAgICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICAgICAgY2FzZSBcIjpcIjoge1xuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBzdGFjay5wdXNoKFwiSU5TSURFX09CSkVDVF9CRUZPUkVfVkFMVUVcIik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiSU5TSURFX09CSkVDVF9CRUZPUkVfVkFMVUVcIjoge1xuICAgICAgICBwcm9jZXNzVmFsdWVTdGFydChjaGFyLCBpLCBcIklOU0lERV9PQkpFQ1RfQUZURVJfVkFMVUVcIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIklOU0lERV9PQkpFQ1RfQUZURVJfVkFMVUVcIjoge1xuICAgICAgICBwcm9jZXNzQWZ0ZXJPYmplY3RWYWx1ZShjaGFyLCBpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiSU5TSURFX1NUUklOR1wiOiB7XG4gICAgICAgIHN3aXRjaCAoY2hhcikge1xuICAgICAgICAgIGNhc2UgJ1wiJzoge1xuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcIlxcXFxcIjoge1xuICAgICAgICAgICAgc3RhY2sucHVzaChcIklOU0lERV9TVFJJTkdfRVNDQVBFXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIGxhc3RWYWxpZEluZGV4ID0gaTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiSU5TSURFX0FSUkFZX1NUQVJUXCI6IHtcbiAgICAgICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICAgICAgY2FzZSBcIl1cIjoge1xuICAgICAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICAgICAgcHJvY2Vzc1ZhbHVlU3RhcnQoY2hhciwgaSwgXCJJTlNJREVfQVJSQVlfQUZURVJfVkFMVUVcIik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiSU5TSURFX0FSUkFZX0FGVEVSX1ZBTFVFXCI6IHtcbiAgICAgICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICAgICAgY2FzZSBcIixcIjoge1xuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBzdGFjay5wdXNoKFwiSU5TSURFX0FSUkFZX0FGVEVSX0NPTU1BXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJdXCI6IHtcbiAgICAgICAgICAgIGxhc3RWYWxpZEluZGV4ID0gaTtcbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIGxhc3RWYWxpZEluZGV4ID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfQVJSQVlfQUZURVJfQ09NTUFcIjoge1xuICAgICAgICBwcm9jZXNzVmFsdWVTdGFydChjaGFyLCBpLCBcIklOU0lERV9BUlJBWV9BRlRFUl9WQUxVRVwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiSU5TSURFX1NUUklOR19FU0NBUEVcIjoge1xuICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfTlVNQkVSXCI6IHtcbiAgICAgICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICAgICAgY2FzZSBcIjBcIjpcbiAgICAgICAgICBjYXNlIFwiMVwiOlxuICAgICAgICAgIGNhc2UgXCIyXCI6XG4gICAgICAgICAgY2FzZSBcIjNcIjpcbiAgICAgICAgICBjYXNlIFwiNFwiOlxuICAgICAgICAgIGNhc2UgXCI1XCI6XG4gICAgICAgICAgY2FzZSBcIjZcIjpcbiAgICAgICAgICBjYXNlIFwiN1wiOlxuICAgICAgICAgIGNhc2UgXCI4XCI6XG4gICAgICAgICAgY2FzZSBcIjlcIjoge1xuICAgICAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJlXCI6XG4gICAgICAgICAgY2FzZSBcIkVcIjpcbiAgICAgICAgICBjYXNlIFwiLVwiOlxuICAgICAgICAgIGNhc2UgXCIuXCI6IHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwiLFwiOiB7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGlmIChzdGFja1tzdGFjay5sZW5ndGggLSAxXSA9PT0gXCJJTlNJREVfQVJSQVlfQUZURVJfVkFMVUVcIikge1xuICAgICAgICAgICAgICBwcm9jZXNzQWZ0ZXJBcnJheVZhbHVlKGNoYXIsIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdID09PSBcIklOU0lERV9PQkpFQ1RfQUZURVJfVkFMVUVcIikge1xuICAgICAgICAgICAgICBwcm9jZXNzQWZ0ZXJPYmplY3RWYWx1ZShjaGFyLCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwifVwiOiB7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGlmIChzdGFja1tzdGFjay5sZW5ndGggLSAxXSA9PT0gXCJJTlNJREVfT0JKRUNUX0FGVEVSX1ZBTFVFXCIpIHtcbiAgICAgICAgICAgICAgcHJvY2Vzc0FmdGVyT2JqZWN0VmFsdWUoY2hhciwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcIl1cIjoge1xuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBpZiAoc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0gPT09IFwiSU5TSURFX0FSUkFZX0FGVEVSX1ZBTFVFXCIpIHtcbiAgICAgICAgICAgICAgcHJvY2Vzc0FmdGVyQXJyYXlWYWx1ZShjaGFyLCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfTElURVJBTFwiOiB7XG4gICAgICAgIGNvbnN0IHBhcnRpYWxMaXRlcmFsID0gaW5wdXQuc3Vic3RyaW5nKGxpdGVyYWxTdGFydCwgaSArIDEpO1xuICAgICAgICBpZiAoIVwiZmFsc2VcIi5zdGFydHNXaXRoKHBhcnRpYWxMaXRlcmFsKSAmJiAhXCJ0cnVlXCIuc3RhcnRzV2l0aChwYXJ0aWFsTGl0ZXJhbCkgJiYgIVwibnVsbFwiLnN0YXJ0c1dpdGgocGFydGlhbExpdGVyYWwpKSB7XG4gICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgaWYgKHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdID09PSBcIklOU0lERV9PQkpFQ1RfQUZURVJfVkFMVUVcIikge1xuICAgICAgICAgICAgcHJvY2Vzc0FmdGVyT2JqZWN0VmFsdWUoY2hhciwgaSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChzdGFja1tzdGFjay5sZW5ndGggLSAxXSA9PT0gXCJJTlNJREVfQVJSQVlfQUZURVJfVkFMVUVcIikge1xuICAgICAgICAgICAgcHJvY2Vzc0FmdGVyQXJyYXlWYWx1ZShjaGFyLCBpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBsZXQgcmVzdWx0ID0gaW5wdXQuc2xpY2UoMCwgbGFzdFZhbGlkSW5kZXggKyAxKTtcbiAgZm9yIChsZXQgaSA9IHN0YWNrLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgY29uc3Qgc3RhdGUgPSBzdGFja1tpXTtcbiAgICBzd2l0Y2ggKHN0YXRlKSB7XG4gICAgICBjYXNlIFwiSU5TSURFX1NUUklOR1wiOiB7XG4gICAgICAgIHJlc3VsdCArPSAnXCInO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfT0JKRUNUX0tFWVwiOlxuICAgICAgY2FzZSBcIklOU0lERV9PQkpFQ1RfQUZURVJfS0VZXCI6XG4gICAgICBjYXNlIFwiSU5TSURFX09CSkVDVF9BRlRFUl9DT01NQVwiOlxuICAgICAgY2FzZSBcIklOU0lERV9PQkpFQ1RfU1RBUlRcIjpcbiAgICAgIGNhc2UgXCJJTlNJREVfT0JKRUNUX0JFRk9SRV9WQUxVRVwiOlxuICAgICAgY2FzZSBcIklOU0lERV9PQkpFQ1RfQUZURVJfVkFMVUVcIjoge1xuICAgICAgICByZXN1bHQgKz0gXCJ9XCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIklOU0lERV9BUlJBWV9TVEFSVFwiOlxuICAgICAgY2FzZSBcIklOU0lERV9BUlJBWV9BRlRFUl9DT01NQVwiOlxuICAgICAgY2FzZSBcIklOU0lERV9BUlJBWV9BRlRFUl9WQUxVRVwiOiB7XG4gICAgICAgIHJlc3VsdCArPSBcIl1cIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiSU5TSURFX0xJVEVSQUxcIjoge1xuICAgICAgICBjb25zdCBwYXJ0aWFsTGl0ZXJhbCA9IGlucHV0LnN1YnN0cmluZyhsaXRlcmFsU3RhcnQsIGlucHV0Lmxlbmd0aCk7XG4gICAgICAgIGlmIChcInRydWVcIi5zdGFydHNXaXRoKHBhcnRpYWxMaXRlcmFsKSkge1xuICAgICAgICAgIHJlc3VsdCArPSBcInRydWVcIi5zbGljZShwYXJ0aWFsTGl0ZXJhbC5sZW5ndGgpO1xuICAgICAgICB9IGVsc2UgaWYgKFwiZmFsc2VcIi5zdGFydHNXaXRoKHBhcnRpYWxMaXRlcmFsKSkge1xuICAgICAgICAgIHJlc3VsdCArPSBcImZhbHNlXCIuc2xpY2UocGFydGlhbExpdGVyYWwubGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIGlmIChcIm51bGxcIi5zdGFydHNXaXRoKHBhcnRpYWxMaXRlcmFsKSkge1xuICAgICAgICAgIHJlc3VsdCArPSBcIm51bGxcIi5zbGljZShwYXJ0aWFsTGl0ZXJhbC5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIHNyYy9wYXJzZS1wYXJ0aWFsLWpzb24udHNcbmZ1bmN0aW9uIHBhcnNlUGFydGlhbEpzb24oanNvblRleHQpIHtcbiAgaWYgKGpzb25UZXh0ID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4geyB2YWx1ZTogdm9pZCAwLCBzdGF0ZTogXCJ1bmRlZmluZWQtaW5wdXRcIiB9O1xuICB9XG4gIGxldCByZXN1bHQgPSAoMCwgaW1wb3J0X3Byb3ZpZGVyX3V0aWxzLnNhZmVQYXJzZUpTT04pKHsgdGV4dDoganNvblRleHQgfSk7XG4gIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgIHJldHVybiB7IHZhbHVlOiByZXN1bHQudmFsdWUsIHN0YXRlOiBcInN1Y2Nlc3NmdWwtcGFyc2VcIiB9O1xuICB9XG4gIHJlc3VsdCA9ICgwLCBpbXBvcnRfcHJvdmlkZXJfdXRpbHMuc2FmZVBhcnNlSlNPTikoeyB0ZXh0OiBmaXhKc29uKGpzb25UZXh0KSB9KTtcbiAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHJlc3VsdC52YWx1ZSwgc3RhdGU6IFwicmVwYWlyZWQtcGFyc2VcIiB9O1xuICB9XG4gIHJldHVybiB7IHZhbHVlOiB2b2lkIDAsIHN0YXRlOiBcImZhaWxlZC1wYXJzZVwiIH07XG59XG5cbi8vIHNyYy9kYXRhLXN0cmVhbS1wYXJ0cy50c1xudmFyIHRleHRTdHJlYW1QYXJ0MiA9IHtcbiAgY29kZTogXCIwXCIsXG4gIG5hbWU6IFwidGV4dFwiLFxuICBwYXJzZTogKHZhbHVlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcInRleHRcIiBwYXJ0cyBleHBlY3QgYSBzdHJpbmcgdmFsdWUuJyk7XG4gICAgfVxuICAgIHJldHVybiB7IHR5cGU6IFwidGV4dFwiLCB2YWx1ZSB9O1xuICB9XG59O1xudmFyIGRhdGFTdHJlYW1QYXJ0ID0ge1xuICBjb2RlOiBcIjJcIixcbiAgbmFtZTogXCJkYXRhXCIsXG4gIHBhcnNlOiAodmFsdWUpID0+IHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiZGF0YVwiIHBhcnRzIGV4cGVjdCBhbiBhcnJheSB2YWx1ZS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdHlwZTogXCJkYXRhXCIsIHZhbHVlIH07XG4gIH1cbn07XG52YXIgZXJyb3JTdHJlYW1QYXJ0MiA9IHtcbiAgY29kZTogXCIzXCIsXG4gIG5hbWU6IFwiZXJyb3JcIixcbiAgcGFyc2U6ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJlcnJvclwiIHBhcnRzIGV4cGVjdCBhIHN0cmluZyB2YWx1ZS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiLCB2YWx1ZSB9O1xuICB9XG59O1xudmFyIG1lc3NhZ2VBbm5vdGF0aW9uc1N0cmVhbVBhcnQgPSB7XG4gIGNvZGU6IFwiOFwiLFxuICBuYW1lOiBcIm1lc3NhZ2VfYW5ub3RhdGlvbnNcIixcbiAgcGFyc2U6ICh2YWx1ZSkgPT4ge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJtZXNzYWdlX2Fubm90YXRpb25zXCIgcGFydHMgZXhwZWN0IGFuIGFycmF5IHZhbHVlLicpO1xuICAgIH1cbiAgICByZXR1cm4geyB0eXBlOiBcIm1lc3NhZ2VfYW5ub3RhdGlvbnNcIiwgdmFsdWUgfTtcbiAgfVxufTtcbnZhciB0b29sQ2FsbFN0cmVhbVBhcnQgPSB7XG4gIGNvZGU6IFwiOVwiLFxuICBuYW1lOiBcInRvb2xfY2FsbFwiLFxuICBwYXJzZTogKHZhbHVlKSA9PiB7XG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8ICEoXCJ0b29sQ2FsbElkXCIgaW4gdmFsdWUpIHx8IHR5cGVvZiB2YWx1ZS50b29sQ2FsbElkICE9PSBcInN0cmluZ1wiIHx8ICEoXCJ0b29sTmFtZVwiIGluIHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUudG9vbE5hbWUgIT09IFwic3RyaW5nXCIgfHwgIShcImFyZ3NcIiBpbiB2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlLmFyZ3MgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1widG9vbF9jYWxsXCIgcGFydHMgZXhwZWN0IGFuIG9iamVjdCB3aXRoIGEgXCJ0b29sQ2FsbElkXCIsIFwidG9vbE5hbWVcIiwgYW5kIFwiYXJnc1wiIHByb3BlcnR5LidcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInRvb2xfY2FsbFwiLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9XG59O1xudmFyIHRvb2xSZXN1bHRTdHJlYW1QYXJ0ID0ge1xuICBjb2RlOiBcImFcIixcbiAgbmFtZTogXCJ0b29sX3Jlc3VsdFwiLFxuICBwYXJzZTogKHZhbHVlKSA9PiB7XG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8ICEoXCJ0b29sQ2FsbElkXCIgaW4gdmFsdWUpIHx8IHR5cGVvZiB2YWx1ZS50b29sQ2FsbElkICE9PSBcInN0cmluZ1wiIHx8ICEoXCJyZXN1bHRcIiBpbiB2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1widG9vbF9yZXN1bHRcIiBwYXJ0cyBleHBlY3QgYW4gb2JqZWN0IHdpdGggYSBcInRvb2xDYWxsSWRcIiBhbmQgYSBcInJlc3VsdFwiIHByb3BlcnR5LidcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInRvb2xfcmVzdWx0XCIsXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH1cbn07XG52YXIgdG9vbENhbGxTdHJlYW1pbmdTdGFydFN0cmVhbVBhcnQgPSB7XG4gIGNvZGU6IFwiYlwiLFxuICBuYW1lOiBcInRvb2xfY2FsbF9zdHJlYW1pbmdfc3RhcnRcIixcbiAgcGFyc2U6ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCAhKFwidG9vbENhbGxJZFwiIGluIHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUudG9vbENhbGxJZCAhPT0gXCJzdHJpbmdcIiB8fCAhKFwidG9vbE5hbWVcIiBpbiB2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlLnRvb2xOYW1lICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdcInRvb2xfY2FsbF9zdHJlYW1pbmdfc3RhcnRcIiBwYXJ0cyBleHBlY3QgYW4gb2JqZWN0IHdpdGggYSBcInRvb2xDYWxsSWRcIiBhbmQgXCJ0b29sTmFtZVwiIHByb3BlcnR5LidcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInRvb2xfY2FsbF9zdHJlYW1pbmdfc3RhcnRcIixcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgfVxufTtcbnZhciB0b29sQ2FsbERlbHRhU3RyZWFtUGFydCA9IHtcbiAgY29kZTogXCJjXCIsXG4gIG5hbWU6IFwidG9vbF9jYWxsX2RlbHRhXCIsXG4gIHBhcnNlOiAodmFsdWUpID0+IHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgIShcInRvb2xDYWxsSWRcIiBpbiB2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlLnRvb2xDYWxsSWQgIT09IFwic3RyaW5nXCIgfHwgIShcImFyZ3NUZXh0RGVsdGFcIiBpbiB2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlLmFyZ3NUZXh0RGVsdGEgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1widG9vbF9jYWxsX2RlbHRhXCIgcGFydHMgZXhwZWN0IGFuIG9iamVjdCB3aXRoIGEgXCJ0b29sQ2FsbElkXCIgYW5kIFwiYXJnc1RleHREZWx0YVwiIHByb3BlcnR5LidcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInRvb2xfY2FsbF9kZWx0YVwiLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9XG59O1xudmFyIGZpbmlzaE1lc3NhZ2VTdHJlYW1QYXJ0ID0ge1xuICBjb2RlOiBcImRcIixcbiAgbmFtZTogXCJmaW5pc2hfbWVzc2FnZVwiLFxuICBwYXJzZTogKHZhbHVlKSA9PiB7XG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8ICEoXCJmaW5pc2hSZWFzb25cIiBpbiB2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlLmZpbmlzaFJlYXNvbiAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnXCJmaW5pc2hfbWVzc2FnZVwiIHBhcnRzIGV4cGVjdCBhbiBvYmplY3Qgd2l0aCBhIFwiZmluaXNoUmVhc29uXCIgcHJvcGVydHkuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgZmluaXNoUmVhc29uOiB2YWx1ZS5maW5pc2hSZWFzb25cbiAgICB9O1xuICAgIGlmIChcInVzYWdlXCIgaW4gdmFsdWUgJiYgdmFsdWUudXNhZ2UgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUudXNhZ2UgPT09IFwib2JqZWN0XCIgJiYgXCJwcm9tcHRUb2tlbnNcIiBpbiB2YWx1ZS51c2FnZSAmJiBcImNvbXBsZXRpb25Ub2tlbnNcIiBpbiB2YWx1ZS51c2FnZSkge1xuICAgICAgcmVzdWx0LnVzYWdlID0ge1xuICAgICAgICBwcm9tcHRUb2tlbnM6IHR5cGVvZiB2YWx1ZS51c2FnZS5wcm9tcHRUb2tlbnMgPT09IFwibnVtYmVyXCIgPyB2YWx1ZS51c2FnZS5wcm9tcHRUb2tlbnMgOiBOdW1iZXIuTmFOLFxuICAgICAgICBjb21wbGV0aW9uVG9rZW5zOiB0eXBlb2YgdmFsdWUudXNhZ2UuY29tcGxldGlvblRva2VucyA9PT0gXCJudW1iZXJcIiA/IHZhbHVlLnVzYWdlLmNvbXBsZXRpb25Ub2tlbnMgOiBOdW1iZXIuTmFOXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJmaW5pc2hfbWVzc2FnZVwiLFxuICAgICAgdmFsdWU6IHJlc3VsdFxuICAgIH07XG4gIH1cbn07XG52YXIgZmluaXNoU3RlcFN0cmVhbVBhcnQgPSB7XG4gIGNvZGU6IFwiZVwiLFxuICBuYW1lOiBcImZpbmlzaF9zdGVwXCIsXG4gIHBhcnNlOiAodmFsdWUpID0+IHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgIShcImZpbmlzaFJlYXNvblwiIGluIHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUuZmluaXNoUmVhc29uICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdcImZpbmlzaF9zdGVwXCIgcGFydHMgZXhwZWN0IGFuIG9iamVjdCB3aXRoIGEgXCJmaW5pc2hSZWFzb25cIiBwcm9wZXJ0eS4nXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICBmaW5pc2hSZWFzb246IHZhbHVlLmZpbmlzaFJlYXNvbixcbiAgICAgIGlzQ29udGludWVkOiBmYWxzZVxuICAgIH07XG4gICAgaWYgKFwidXNhZ2VcIiBpbiB2YWx1ZSAmJiB2YWx1ZS51c2FnZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZS51c2FnZSA9PT0gXCJvYmplY3RcIiAmJiBcInByb21wdFRva2Vuc1wiIGluIHZhbHVlLnVzYWdlICYmIFwiY29tcGxldGlvblRva2Vuc1wiIGluIHZhbHVlLnVzYWdlKSB7XG4gICAgICByZXN1bHQudXNhZ2UgPSB7XG4gICAgICAgIHByb21wdFRva2VuczogdHlwZW9mIHZhbHVlLnVzYWdlLnByb21wdFRva2VucyA9PT0gXCJudW1iZXJcIiA/IHZhbHVlLnVzYWdlLnByb21wdFRva2VucyA6IE51bWJlci5OYU4sXG4gICAgICAgIGNvbXBsZXRpb25Ub2tlbnM6IHR5cGVvZiB2YWx1ZS51c2FnZS5jb21wbGV0aW9uVG9rZW5zID09PSBcIm51bWJlclwiID8gdmFsdWUudXNhZ2UuY29tcGxldGlvblRva2VucyA6IE51bWJlci5OYU5cbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChcImlzQ29udGludWVkXCIgaW4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlLmlzQ29udGludWVkID09PSBcImJvb2xlYW5cIikge1xuICAgICAgcmVzdWx0LmlzQ29udGludWVkID0gdmFsdWUuaXNDb250aW51ZWQ7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImZpbmlzaF9zdGVwXCIsXG4gICAgICB2YWx1ZTogcmVzdWx0XG4gICAgfTtcbiAgfVxufTtcbnZhciBzdGFydFN0ZXBTdHJlYW1QYXJ0ID0ge1xuICBjb2RlOiBcImZcIixcbiAgbmFtZTogXCJzdGFydF9zdGVwXCIsXG4gIHBhcnNlOiAodmFsdWUpID0+IHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgIShcIm1lc3NhZ2VJZFwiIGluIHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUubWVzc2FnZUlkICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdcInN0YXJ0X3N0ZXBcIiBwYXJ0cyBleHBlY3QgYW4gb2JqZWN0IHdpdGggYW4gXCJpZFwiIHByb3BlcnR5LidcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInN0YXJ0X3N0ZXBcIixcbiAgICAgIHZhbHVlOiB7XG4gICAgICAgIG1lc3NhZ2VJZDogdmFsdWUubWVzc2FnZUlkXG4gICAgICB9XG4gICAgfTtcbiAgfVxufTtcbnZhciByZWFzb25pbmdTdHJlYW1QYXJ0ID0ge1xuICBjb2RlOiBcImdcIixcbiAgbmFtZTogXCJyZWFzb25pbmdcIixcbiAgcGFyc2U6ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJyZWFzb25pbmdcIiBwYXJ0cyBleHBlY3QgYSBzdHJpbmcgdmFsdWUuJyk7XG4gICAgfVxuICAgIHJldHVybiB7IHR5cGU6IFwicmVhc29uaW5nXCIsIHZhbHVlIH07XG4gIH1cbn07XG52YXIgc291cmNlUGFydCA9IHtcbiAgY29kZTogXCJoXCIsXG4gIG5hbWU6IFwic291cmNlXCIsXG4gIHBhcnNlOiAodmFsdWUpID0+IHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJzb3VyY2VcIiBwYXJ0cyBleHBlY3QgYSBTb3VyY2Ugb2JqZWN0LicpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJzb3VyY2VcIixcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgfVxufTtcbnZhciByZWRhY3RlZFJlYXNvbmluZ1N0cmVhbVBhcnQgPSB7XG4gIGNvZGU6IFwiaVwiLFxuICBuYW1lOiBcInJlZGFjdGVkX3JlYXNvbmluZ1wiLFxuICBwYXJzZTogKHZhbHVlKSA9PiB7XG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8ICEoXCJkYXRhXCIgaW4gdmFsdWUpIHx8IHR5cGVvZiB2YWx1ZS5kYXRhICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdcInJlZGFjdGVkX3JlYXNvbmluZ1wiIHBhcnRzIGV4cGVjdCBhbiBvYmplY3Qgd2l0aCBhIFwiZGF0YVwiIHByb3BlcnR5LidcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB7IHR5cGU6IFwicmVkYWN0ZWRfcmVhc29uaW5nXCIsIHZhbHVlOiB7IGRhdGE6IHZhbHVlLmRhdGEgfSB9O1xuICB9XG59O1xudmFyIHJlYXNvbmluZ1NpZ25hdHVyZVN0cmVhbVBhcnQgPSB7XG4gIGNvZGU6IFwialwiLFxuICBuYW1lOiBcInJlYXNvbmluZ19zaWduYXR1cmVcIixcbiAgcGFyc2U6ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCAhKFwic2lnbmF0dXJlXCIgaW4gdmFsdWUpIHx8IHR5cGVvZiB2YWx1ZS5zaWduYXR1cmUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1wicmVhc29uaW5nX3NpZ25hdHVyZVwiIHBhcnRzIGV4cGVjdCBhbiBvYmplY3Qgd2l0aCBhIFwic2lnbmF0dXJlXCIgcHJvcGVydHkuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwicmVhc29uaW5nX3NpZ25hdHVyZVwiLFxuICAgICAgdmFsdWU6IHsgc2lnbmF0dXJlOiB2YWx1ZS5zaWduYXR1cmUgfVxuICAgIH07XG4gIH1cbn07XG52YXIgZmlsZVN0cmVhbVBhcnQgPSB7XG4gIGNvZGU6IFwia1wiLFxuICBuYW1lOiBcImZpbGVcIixcbiAgcGFyc2U6ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCAhKFwiZGF0YVwiIGluIHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUuZGF0YSAhPT0gXCJzdHJpbmdcIiB8fCAhKFwibWltZVR5cGVcIiBpbiB2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlLm1pbWVUeXBlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdcImZpbGVcIiBwYXJ0cyBleHBlY3QgYW4gb2JqZWN0IHdpdGggYSBcImRhdGFcIiBhbmQgXCJtaW1lVHlwZVwiIHByb3BlcnR5LidcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB7IHR5cGU6IFwiZmlsZVwiLCB2YWx1ZSB9O1xuICB9XG59O1xudmFyIGRhdGFTdHJlYW1QYXJ0cyA9IFtcbiAgdGV4dFN0cmVhbVBhcnQyLFxuICBkYXRhU3RyZWFtUGFydCxcbiAgZXJyb3JTdHJlYW1QYXJ0MixcbiAgbWVzc2FnZUFubm90YXRpb25zU3RyZWFtUGFydCxcbiAgdG9vbENhbGxTdHJlYW1QYXJ0LFxuICB0b29sUmVzdWx0U3RyZWFtUGFydCxcbiAgdG9vbENhbGxTdHJlYW1pbmdTdGFydFN0cmVhbVBhcnQsXG4gIHRvb2xDYWxsRGVsdGFTdHJlYW1QYXJ0LFxuICBmaW5pc2hNZXNzYWdlU3RyZWFtUGFydCxcbiAgZmluaXNoU3RlcFN0cmVhbVBhcnQsXG4gIHN0YXJ0U3RlcFN0cmVhbVBhcnQsXG4gIHJlYXNvbmluZ1N0cmVhbVBhcnQsXG4gIHNvdXJjZVBhcnQsXG4gIHJlZGFjdGVkUmVhc29uaW5nU3RyZWFtUGFydCxcbiAgcmVhc29uaW5nU2lnbmF0dXJlU3RyZWFtUGFydCxcbiAgZmlsZVN0cmVhbVBhcnRcbl07XG52YXIgZGF0YVN0cmVhbVBhcnRzQnlDb2RlID0gT2JqZWN0LmZyb21FbnRyaWVzKFxuICBkYXRhU3RyZWFtUGFydHMubWFwKChwYXJ0KSA9PiBbcGFydC5jb2RlLCBwYXJ0XSlcbik7XG52YXIgRGF0YVN0cmVhbVN0cmluZ1ByZWZpeGVzID0gT2JqZWN0LmZyb21FbnRyaWVzKFxuICBkYXRhU3RyZWFtUGFydHMubWFwKChwYXJ0KSA9PiBbcGFydC5uYW1lLCBwYXJ0LmNvZGVdKVxuKTtcbnZhciB2YWxpZENvZGVzMiA9IGRhdGFTdHJlYW1QYXJ0cy5tYXAoKHBhcnQpID0+IHBhcnQuY29kZSk7XG52YXIgcGFyc2VEYXRhU3RyZWFtUGFydCA9IChsaW5lKSA9PiB7XG4gIGNvbnN0IGZpcnN0U2VwYXJhdG9ySW5kZXggPSBsaW5lLmluZGV4T2YoXCI6XCIpO1xuICBpZiAoZmlyc3RTZXBhcmF0b3JJbmRleCA9PT0gLTEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gcGFyc2Ugc3RyZWFtIHN0cmluZy4gTm8gc2VwYXJhdG9yIGZvdW5kLlwiKTtcbiAgfVxuICBjb25zdCBwcmVmaXggPSBsaW5lLnNsaWNlKDAsIGZpcnN0U2VwYXJhdG9ySW5kZXgpO1xuICBpZiAoIXZhbGlkQ29kZXMyLmluY2x1ZGVzKHByZWZpeCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBwYXJzZSBzdHJlYW0gc3RyaW5nLiBJbnZhbGlkIGNvZGUgJHtwcmVmaXh9LmApO1xuICB9XG4gIGNvbnN0IGNvZGUgPSBwcmVmaXg7XG4gIGNvbnN0IHRleHRWYWx1ZSA9IGxpbmUuc2xpY2UoZmlyc3RTZXBhcmF0b3JJbmRleCArIDEpO1xuICBjb25zdCBqc29uVmFsdWUgPSBKU09OLnBhcnNlKHRleHRWYWx1ZSk7XG4gIHJldHVybiBkYXRhU3RyZWFtUGFydHNCeUNvZGVbY29kZV0ucGFyc2UoanNvblZhbHVlKTtcbn07XG5mdW5jdGlvbiBmb3JtYXREYXRhU3RyZWFtUGFydCh0eXBlLCB2YWx1ZSkge1xuICBjb25zdCBzdHJlYW1QYXJ0ID0gZGF0YVN0cmVhbVBhcnRzLmZpbmQoKHBhcnQpID0+IHBhcnQubmFtZSA9PT0gdHlwZSk7XG4gIGlmICghc3RyZWFtUGFydCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzdHJlYW0gcGFydCB0eXBlOiAke3R5cGV9YCk7XG4gIH1cbiAgcmV0dXJuIGAke3N0cmVhbVBhcnQuY29kZX06JHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9XG5gO1xufVxuXG4vLyBzcmMvcHJvY2Vzcy1kYXRhLXN0cmVhbS50c1xudmFyIE5FV0xJTkUgPSBcIlxcblwiLmNoYXJDb2RlQXQoMCk7XG5mdW5jdGlvbiBjb25jYXRDaHVua3MoY2h1bmtzLCB0b3RhbExlbmd0aCkge1xuICBjb25zdCBjb25jYXRlbmF0ZWRDaHVua3MgPSBuZXcgVWludDhBcnJheSh0b3RhbExlbmd0aCk7XG4gIGxldCBvZmZzZXQgPSAwO1xuICBmb3IgKGNvbnN0IGNodW5rIG9mIGNodW5rcykge1xuICAgIGNvbmNhdGVuYXRlZENodW5rcy5zZXQoY2h1bmssIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IGNodW5rLmxlbmd0aDtcbiAgfVxuICBjaHVua3MubGVuZ3RoID0gMDtcbiAgcmV0dXJuIGNvbmNhdGVuYXRlZENodW5rcztcbn1cbmFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NEYXRhU3RyZWFtKHtcbiAgc3RyZWFtLFxuICBvblRleHRQYXJ0LFxuICBvblJlYXNvbmluZ1BhcnQsXG4gIG9uUmVhc29uaW5nU2lnbmF0dXJlUGFydCxcbiAgb25SZWRhY3RlZFJlYXNvbmluZ1BhcnQsXG4gIG9uU291cmNlUGFydCxcbiAgb25GaWxlUGFydCxcbiAgb25EYXRhUGFydCxcbiAgb25FcnJvclBhcnQsXG4gIG9uVG9vbENhbGxTdHJlYW1pbmdTdGFydFBhcnQsXG4gIG9uVG9vbENhbGxEZWx0YVBhcnQsXG4gIG9uVG9vbENhbGxQYXJ0LFxuICBvblRvb2xSZXN1bHRQYXJ0LFxuICBvbk1lc3NhZ2VBbm5vdGF0aW9uc1BhcnQsXG4gIG9uRmluaXNoTWVzc2FnZVBhcnQsXG4gIG9uRmluaXNoU3RlcFBhcnQsXG4gIG9uU3RhcnRTdGVwUGFydFxufSkge1xuICBjb25zdCByZWFkZXIgPSBzdHJlYW0uZ2V0UmVhZGVyKCk7XG4gIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgY29uc3QgY2h1bmtzID0gW107XG4gIGxldCB0b3RhbExlbmd0aCA9IDA7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3QgeyB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGNodW5rcy5wdXNoKHZhbHVlKTtcbiAgICAgIHRvdGFsTGVuZ3RoICs9IHZhbHVlLmxlbmd0aDtcbiAgICAgIGlmICh2YWx1ZVt2YWx1ZS5sZW5ndGggLSAxXSAhPT0gTkVXTElORSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNodW5rcy5sZW5ndGggPT09IDApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjb25zdCBjb25jYXRlbmF0ZWRDaHVua3MgPSBjb25jYXRDaHVua3MoY2h1bmtzLCB0b3RhbExlbmd0aCk7XG4gICAgdG90YWxMZW5ndGggPSAwO1xuICAgIGNvbnN0IHN0cmVhbVBhcnRzID0gZGVjb2Rlci5kZWNvZGUoY29uY2F0ZW5hdGVkQ2h1bmtzLCB7IHN0cmVhbTogdHJ1ZSB9KS5zcGxpdChcIlxcblwiKS5maWx0ZXIoKGxpbmUpID0+IGxpbmUgIT09IFwiXCIpLm1hcChwYXJzZURhdGFTdHJlYW1QYXJ0KTtcbiAgICBmb3IgKGNvbnN0IHsgdHlwZSwgdmFsdWU6IHZhbHVlMiB9IG9mIHN0cmVhbVBhcnRzKSB7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcInRleHRcIjpcbiAgICAgICAgICBhd2FpdCAob25UZXh0UGFydCA9PSBudWxsID8gdm9pZCAwIDogb25UZXh0UGFydCh2YWx1ZTIpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInJlYXNvbmluZ1wiOlxuICAgICAgICAgIGF3YWl0IChvblJlYXNvbmluZ1BhcnQgPT0gbnVsbCA/IHZvaWQgMCA6IG9uUmVhc29uaW5nUGFydCh2YWx1ZTIpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInJlYXNvbmluZ19zaWduYXR1cmVcIjpcbiAgICAgICAgICBhd2FpdCAob25SZWFzb25pbmdTaWduYXR1cmVQYXJ0ID09IG51bGwgPyB2b2lkIDAgOiBvblJlYXNvbmluZ1NpZ25hdHVyZVBhcnQodmFsdWUyKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJyZWRhY3RlZF9yZWFzb25pbmdcIjpcbiAgICAgICAgICBhd2FpdCAob25SZWRhY3RlZFJlYXNvbmluZ1BhcnQgPT0gbnVsbCA/IHZvaWQgMCA6IG9uUmVkYWN0ZWRSZWFzb25pbmdQYXJ0KHZhbHVlMikpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZmlsZVwiOlxuICAgICAgICAgIGF3YWl0IChvbkZpbGVQYXJ0ID09IG51bGwgPyB2b2lkIDAgOiBvbkZpbGVQYXJ0KHZhbHVlMikpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwic291cmNlXCI6XG4gICAgICAgICAgYXdhaXQgKG9uU291cmNlUGFydCA9PSBudWxsID8gdm9pZCAwIDogb25Tb3VyY2VQYXJ0KHZhbHVlMikpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZGF0YVwiOlxuICAgICAgICAgIGF3YWl0IChvbkRhdGFQYXJ0ID09IG51bGwgPyB2b2lkIDAgOiBvbkRhdGFQYXJ0KHZhbHVlMikpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICBhd2FpdCAob25FcnJvclBhcnQgPT0gbnVsbCA/IHZvaWQgMCA6IG9uRXJyb3JQYXJ0KHZhbHVlMikpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibWVzc2FnZV9hbm5vdGF0aW9uc1wiOlxuICAgICAgICAgIGF3YWl0IChvbk1lc3NhZ2VBbm5vdGF0aW9uc1BhcnQgPT0gbnVsbCA/IHZvaWQgMCA6IG9uTWVzc2FnZUFubm90YXRpb25zUGFydCh2YWx1ZTIpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInRvb2xfY2FsbF9zdHJlYW1pbmdfc3RhcnRcIjpcbiAgICAgICAgICBhd2FpdCAob25Ub29sQ2FsbFN0cmVhbWluZ1N0YXJ0UGFydCA9PSBudWxsID8gdm9pZCAwIDogb25Ub29sQ2FsbFN0cmVhbWluZ1N0YXJ0UGFydCh2YWx1ZTIpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInRvb2xfY2FsbF9kZWx0YVwiOlxuICAgICAgICAgIGF3YWl0IChvblRvb2xDYWxsRGVsdGFQYXJ0ID09IG51bGwgPyB2b2lkIDAgOiBvblRvb2xDYWxsRGVsdGFQYXJ0KHZhbHVlMikpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwidG9vbF9jYWxsXCI6XG4gICAgICAgICAgYXdhaXQgKG9uVG9vbENhbGxQYXJ0ID09IG51bGwgPyB2b2lkIDAgOiBvblRvb2xDYWxsUGFydCh2YWx1ZTIpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInRvb2xfcmVzdWx0XCI6XG4gICAgICAgICAgYXdhaXQgKG9uVG9vbFJlc3VsdFBhcnQgPT0gbnVsbCA/IHZvaWQgMCA6IG9uVG9vbFJlc3VsdFBhcnQodmFsdWUyKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJmaW5pc2hfbWVzc2FnZVwiOlxuICAgICAgICAgIGF3YWl0IChvbkZpbmlzaE1lc3NhZ2VQYXJ0ID09IG51bGwgPyB2b2lkIDAgOiBvbkZpbmlzaE1lc3NhZ2VQYXJ0KHZhbHVlMikpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZmluaXNoX3N0ZXBcIjpcbiAgICAgICAgICBhd2FpdCAob25GaW5pc2hTdGVwUGFydCA9PSBudWxsID8gdm9pZCAwIDogb25GaW5pc2hTdGVwUGFydCh2YWx1ZTIpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInN0YXJ0X3N0ZXBcIjpcbiAgICAgICAgICBhd2FpdCAob25TdGFydFN0ZXBQYXJ0ID09IG51bGwgPyB2b2lkIDAgOiBvblN0YXJ0U3RlcFBhcnQodmFsdWUyKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICBjb25zdCBleGhhdXN0aXZlQ2hlY2sgPSB0eXBlO1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBzdHJlYW0gcGFydCB0eXBlOiAke2V4aGF1c3RpdmVDaGVja31gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyBzcmMvcHJvY2Vzcy1jaGF0LXJlc3BvbnNlLnRzXG5hc3luYyBmdW5jdGlvbiBwcm9jZXNzQ2hhdFJlc3BvbnNlKHtcbiAgc3RyZWFtLFxuICB1cGRhdGUsXG4gIG9uVG9vbENhbGwsXG4gIG9uRmluaXNoLFxuICBnZW5lcmF0ZUlkOiBnZW5lcmF0ZUlkMiA9IGltcG9ydF9wcm92aWRlcl91dGlsczIuZ2VuZXJhdGVJZCxcbiAgZ2V0Q3VycmVudERhdGUgPSAoKSA9PiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSxcbiAgbGFzdE1lc3NhZ2Vcbn0pIHtcbiAgdmFyIF9hLCBfYjtcbiAgY29uc3QgcmVwbGFjZUxhc3RNZXNzYWdlID0gKGxhc3RNZXNzYWdlID09IG51bGwgPyB2b2lkIDAgOiBsYXN0TWVzc2FnZS5yb2xlKSA9PT0gXCJhc3Npc3RhbnRcIjtcbiAgbGV0IHN0ZXAgPSByZXBsYWNlTGFzdE1lc3NhZ2UgPyAxICsgLy8gZmluZCBtYXggc3RlcCBpbiBleGlzdGluZyB0b29sIGludm9jYXRpb25zOlxuICAoKF9iID0gKF9hID0gbGFzdE1lc3NhZ2UudG9vbEludm9jYXRpb25zKSA9PSBudWxsID8gdm9pZCAwIDogX2EucmVkdWNlKChtYXgsIHRvb2xJbnZvY2F0aW9uKSA9PiB7XG4gICAgdmFyIF9hMjtcbiAgICByZXR1cm4gTWF0aC5tYXgobWF4LCAoX2EyID0gdG9vbEludm9jYXRpb24uc3RlcCkgIT0gbnVsbCA/IF9hMiA6IDApO1xuICB9LCAwKSkgIT0gbnVsbCA/IF9iIDogMCkgOiAwO1xuICBjb25zdCBtZXNzYWdlID0gcmVwbGFjZUxhc3RNZXNzYWdlID8gc3RydWN0dXJlZENsb25lKGxhc3RNZXNzYWdlKSA6IHtcbiAgICBpZDogZ2VuZXJhdGVJZDIoKSxcbiAgICBjcmVhdGVkQXQ6IGdldEN1cnJlbnREYXRlKCksXG4gICAgcm9sZTogXCJhc3Npc3RhbnRcIixcbiAgICBjb250ZW50OiBcIlwiLFxuICAgIHBhcnRzOiBbXVxuICB9O1xuICBsZXQgY3VycmVudFRleHRQYXJ0ID0gdm9pZCAwO1xuICBsZXQgY3VycmVudFJlYXNvbmluZ1BhcnQgPSB2b2lkIDA7XG4gIGxldCBjdXJyZW50UmVhc29uaW5nVGV4dERldGFpbCA9IHZvaWQgMDtcbiAgZnVuY3Rpb24gdXBkYXRlVG9vbEludm9jYXRpb25QYXJ0KHRvb2xDYWxsSWQsIGludm9jYXRpb24pIHtcbiAgICBjb25zdCBwYXJ0ID0gbWVzc2FnZS5wYXJ0cy5maW5kKFxuICAgICAgKHBhcnQyKSA9PiBwYXJ0Mi50eXBlID09PSBcInRvb2wtaW52b2NhdGlvblwiICYmIHBhcnQyLnRvb2xJbnZvY2F0aW9uLnRvb2xDYWxsSWQgPT09IHRvb2xDYWxsSWRcbiAgICApO1xuICAgIGlmIChwYXJ0ICE9IG51bGwpIHtcbiAgICAgIHBhcnQudG9vbEludm9jYXRpb24gPSBpbnZvY2F0aW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICBtZXNzYWdlLnBhcnRzLnB1c2goe1xuICAgICAgICB0eXBlOiBcInRvb2wtaW52b2NhdGlvblwiLFxuICAgICAgICB0b29sSW52b2NhdGlvbjogaW52b2NhdGlvblxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGRhdGEgPSBbXTtcbiAgbGV0IG1lc3NhZ2VBbm5vdGF0aW9ucyA9IHJlcGxhY2VMYXN0TWVzc2FnZSA/IGxhc3RNZXNzYWdlID09IG51bGwgPyB2b2lkIDAgOiBsYXN0TWVzc2FnZS5hbm5vdGF0aW9ucyA6IHZvaWQgMDtcbiAgY29uc3QgcGFydGlhbFRvb2xDYWxscyA9IHt9O1xuICBsZXQgdXNhZ2UgPSB7XG4gICAgY29tcGxldGlvblRva2VuczogTmFOLFxuICAgIHByb21wdFRva2VuczogTmFOLFxuICAgIHRvdGFsVG9rZW5zOiBOYU5cbiAgfTtcbiAgbGV0IGZpbmlzaFJlYXNvbiA9IFwidW5rbm93blwiO1xuICBmdW5jdGlvbiBleGVjVXBkYXRlKCkge1xuICAgIGNvbnN0IGNvcGllZERhdGEgPSBbLi4uZGF0YV07XG4gICAgaWYgKG1lc3NhZ2VBbm5vdGF0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogbWVzc2FnZUFubm90YXRpb25zLmxlbmd0aCkge1xuICAgICAgbWVzc2FnZS5hbm5vdGF0aW9ucyA9IG1lc3NhZ2VBbm5vdGF0aW9ucztcbiAgICB9XG4gICAgY29uc3QgY29waWVkTWVzc2FnZSA9IHtcbiAgICAgIC8vIGRlZXAgY29weSB0aGUgbWVzc2FnZSB0byBlbnN1cmUgdGhhdCBkZWVwIGNoYW5nZXMgKG1zZyBhdHRhY2htZW50cykgYXJlIHVwZGF0ZWRcbiAgICAgIC8vIHdpdGggU29saWRKUy4gU29saWRKUyB1c2VzIHJlZmVyZW50aWFsIGludGVncmF0aW9uIG9mIHN1Yi1vYmplY3RzIHRvIGRldGVjdCBjaGFuZ2VzLlxuICAgICAgLi4uc3RydWN0dXJlZENsb25lKG1lc3NhZ2UpLFxuICAgICAgLy8gYWRkIGEgcmV2aXNpb24gaWQgdG8gZW5zdXJlIHRoYXQgdGhlIG1lc3NhZ2UgaXMgdXBkYXRlZCB3aXRoIFNXUi4gU1dSIHVzZXMgYVxuICAgICAgLy8gaGFzaGluZyBhcHByb2FjaCBieSBkZWZhdWx0IHRvIGRldGVjdCBjaGFuZ2VzLCBidXQgaXQgb25seSB3b3JrcyBmb3Igc2hhbGxvd1xuICAgICAgLy8gY2hhbmdlcy4gVGhpcyBpcyB3aHkgd2UgbmVlZCB0byBhZGQgYSByZXZpc2lvbiBpZCB0byBlbnN1cmUgdGhhdCB0aGUgbWVzc2FnZVxuICAgICAgLy8gaXMgdXBkYXRlZCB3aXRoIFNXUiAod2l0aG91dCBpdCwgdGhlIGNoYW5nZXMgZ2V0IHN0dWNrIGluIFNXUiBhbmQgYXJlIG5vdFxuICAgICAgLy8gZm9yd2FyZGVkIHRvIHJlbmRlcmluZyk6XG4gICAgICByZXZpc2lvbklkOiBnZW5lcmF0ZUlkMigpXG4gICAgfTtcbiAgICB1cGRhdGUoe1xuICAgICAgbWVzc2FnZTogY29waWVkTWVzc2FnZSxcbiAgICAgIGRhdGE6IGNvcGllZERhdGEsXG4gICAgICByZXBsYWNlTGFzdE1lc3NhZ2VcbiAgICB9KTtcbiAgfVxuICBhd2FpdCBwcm9jZXNzRGF0YVN0cmVhbSh7XG4gICAgc3RyZWFtLFxuICAgIG9uVGV4dFBhcnQodmFsdWUpIHtcbiAgICAgIGlmIChjdXJyZW50VGV4dFBhcnQgPT0gbnVsbCkge1xuICAgICAgICBjdXJyZW50VGV4dFBhcnQgPSB7XG4gICAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgdGV4dDogdmFsdWVcbiAgICAgICAgfTtcbiAgICAgICAgbWVzc2FnZS5wYXJ0cy5wdXNoKGN1cnJlbnRUZXh0UGFydCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJyZW50VGV4dFBhcnQudGV4dCArPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIG1lc3NhZ2UuY29udGVudCArPSB2YWx1ZTtcbiAgICAgIGV4ZWNVcGRhdGUoKTtcbiAgICB9LFxuICAgIG9uUmVhc29uaW5nUGFydCh2YWx1ZSkge1xuICAgICAgdmFyIF9hMjtcbiAgICAgIGlmIChjdXJyZW50UmVhc29uaW5nVGV4dERldGFpbCA9PSBudWxsKSB7XG4gICAgICAgIGN1cnJlbnRSZWFzb25pbmdUZXh0RGV0YWlsID0geyB0eXBlOiBcInRleHRcIiwgdGV4dDogdmFsdWUgfTtcbiAgICAgICAgaWYgKGN1cnJlbnRSZWFzb25pbmdQYXJ0ICE9IG51bGwpIHtcbiAgICAgICAgICBjdXJyZW50UmVhc29uaW5nUGFydC5kZXRhaWxzLnB1c2goY3VycmVudFJlYXNvbmluZ1RleHREZXRhaWwpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJyZW50UmVhc29uaW5nVGV4dERldGFpbC50ZXh0ICs9IHZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnRSZWFzb25pbmdQYXJ0ID09IG51bGwpIHtcbiAgICAgICAgY3VycmVudFJlYXNvbmluZ1BhcnQgPSB7XG4gICAgICAgICAgdHlwZTogXCJyZWFzb25pbmdcIixcbiAgICAgICAgICByZWFzb25pbmc6IHZhbHVlLFxuICAgICAgICAgIGRldGFpbHM6IFtjdXJyZW50UmVhc29uaW5nVGV4dERldGFpbF1cbiAgICAgICAgfTtcbiAgICAgICAgbWVzc2FnZS5wYXJ0cy5wdXNoKGN1cnJlbnRSZWFzb25pbmdQYXJ0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnJlbnRSZWFzb25pbmdQYXJ0LnJlYXNvbmluZyArPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIG1lc3NhZ2UucmVhc29uaW5nID0gKChfYTIgPSBtZXNzYWdlLnJlYXNvbmluZykgIT0gbnVsbCA/IF9hMiA6IFwiXCIpICsgdmFsdWU7XG4gICAgICBleGVjVXBkYXRlKCk7XG4gICAgfSxcbiAgICBvblJlYXNvbmluZ1NpZ25hdHVyZVBhcnQodmFsdWUpIHtcbiAgICAgIGlmIChjdXJyZW50UmVhc29uaW5nVGV4dERldGFpbCAhPSBudWxsKSB7XG4gICAgICAgIGN1cnJlbnRSZWFzb25pbmdUZXh0RGV0YWlsLnNpZ25hdHVyZSA9IHZhbHVlLnNpZ25hdHVyZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG9uUmVkYWN0ZWRSZWFzb25pbmdQYXJ0KHZhbHVlKSB7XG4gICAgICBpZiAoY3VycmVudFJlYXNvbmluZ1BhcnQgPT0gbnVsbCkge1xuICAgICAgICBjdXJyZW50UmVhc29uaW5nUGFydCA9IHtcbiAgICAgICAgICB0eXBlOiBcInJlYXNvbmluZ1wiLFxuICAgICAgICAgIHJlYXNvbmluZzogXCJcIixcbiAgICAgICAgICBkZXRhaWxzOiBbXVxuICAgICAgICB9O1xuICAgICAgICBtZXNzYWdlLnBhcnRzLnB1c2goY3VycmVudFJlYXNvbmluZ1BhcnQpO1xuICAgICAgfVxuICAgICAgY3VycmVudFJlYXNvbmluZ1BhcnQuZGV0YWlscy5wdXNoKHtcbiAgICAgICAgdHlwZTogXCJyZWRhY3RlZFwiLFxuICAgICAgICBkYXRhOiB2YWx1ZS5kYXRhXG4gICAgICB9KTtcbiAgICAgIGN1cnJlbnRSZWFzb25pbmdUZXh0RGV0YWlsID0gdm9pZCAwO1xuICAgICAgZXhlY1VwZGF0ZSgpO1xuICAgIH0sXG4gICAgb25GaWxlUGFydCh2YWx1ZSkge1xuICAgICAgbWVzc2FnZS5wYXJ0cy5wdXNoKHtcbiAgICAgICAgdHlwZTogXCJmaWxlXCIsXG4gICAgICAgIG1pbWVUeXBlOiB2YWx1ZS5taW1lVHlwZSxcbiAgICAgICAgZGF0YTogdmFsdWUuZGF0YVxuICAgICAgfSk7XG4gICAgICBleGVjVXBkYXRlKCk7XG4gICAgfSxcbiAgICBvblNvdXJjZVBhcnQodmFsdWUpIHtcbiAgICAgIG1lc3NhZ2UucGFydHMucHVzaCh7XG4gICAgICAgIHR5cGU6IFwic291cmNlXCIsXG4gICAgICAgIHNvdXJjZTogdmFsdWVcbiAgICAgIH0pO1xuICAgICAgZXhlY1VwZGF0ZSgpO1xuICAgIH0sXG4gICAgb25Ub29sQ2FsbFN0cmVhbWluZ1N0YXJ0UGFydCh2YWx1ZSkge1xuICAgICAgaWYgKG1lc3NhZ2UudG9vbEludm9jYXRpb25zID09IG51bGwpIHtcbiAgICAgICAgbWVzc2FnZS50b29sSW52b2NhdGlvbnMgPSBbXTtcbiAgICAgIH1cbiAgICAgIHBhcnRpYWxUb29sQ2FsbHNbdmFsdWUudG9vbENhbGxJZF0gPSB7XG4gICAgICAgIHRleHQ6IFwiXCIsXG4gICAgICAgIHN0ZXAsXG4gICAgICAgIHRvb2xOYW1lOiB2YWx1ZS50b29sTmFtZSxcbiAgICAgICAgaW5kZXg6IG1lc3NhZ2UudG9vbEludm9jYXRpb25zLmxlbmd0aFxuICAgICAgfTtcbiAgICAgIGNvbnN0IGludm9jYXRpb24gPSB7XG4gICAgICAgIHN0YXRlOiBcInBhcnRpYWwtY2FsbFwiLFxuICAgICAgICBzdGVwLFxuICAgICAgICB0b29sQ2FsbElkOiB2YWx1ZS50b29sQ2FsbElkLFxuICAgICAgICB0b29sTmFtZTogdmFsdWUudG9vbE5hbWUsXG4gICAgICAgIGFyZ3M6IHZvaWQgMFxuICAgICAgfTtcbiAgICAgIG1lc3NhZ2UudG9vbEludm9jYXRpb25zLnB1c2goaW52b2NhdGlvbik7XG4gICAgICB1cGRhdGVUb29sSW52b2NhdGlvblBhcnQodmFsdWUudG9vbENhbGxJZCwgaW52b2NhdGlvbik7XG4gICAgICBleGVjVXBkYXRlKCk7XG4gICAgfSxcbiAgICBvblRvb2xDYWxsRGVsdGFQYXJ0KHZhbHVlKSB7XG4gICAgICBjb25zdCBwYXJ0aWFsVG9vbENhbGwgPSBwYXJ0aWFsVG9vbENhbGxzW3ZhbHVlLnRvb2xDYWxsSWRdO1xuICAgICAgcGFydGlhbFRvb2xDYWxsLnRleHQgKz0gdmFsdWUuYXJnc1RleHREZWx0YTtcbiAgICAgIGNvbnN0IHsgdmFsdWU6IHBhcnRpYWxBcmdzIH0gPSBwYXJzZVBhcnRpYWxKc29uKHBhcnRpYWxUb29sQ2FsbC50ZXh0KTtcbiAgICAgIGNvbnN0IGludm9jYXRpb24gPSB7XG4gICAgICAgIHN0YXRlOiBcInBhcnRpYWwtY2FsbFwiLFxuICAgICAgICBzdGVwOiBwYXJ0aWFsVG9vbENhbGwuc3RlcCxcbiAgICAgICAgdG9vbENhbGxJZDogdmFsdWUudG9vbENhbGxJZCxcbiAgICAgICAgdG9vbE5hbWU6IHBhcnRpYWxUb29sQ2FsbC50b29sTmFtZSxcbiAgICAgICAgYXJnczogcGFydGlhbEFyZ3NcbiAgICAgIH07XG4gICAgICBtZXNzYWdlLnRvb2xJbnZvY2F0aW9uc1twYXJ0aWFsVG9vbENhbGwuaW5kZXhdID0gaW52b2NhdGlvbjtcbiAgICAgIHVwZGF0ZVRvb2xJbnZvY2F0aW9uUGFydCh2YWx1ZS50b29sQ2FsbElkLCBpbnZvY2F0aW9uKTtcbiAgICAgIGV4ZWNVcGRhdGUoKTtcbiAgICB9LFxuICAgIGFzeW5jIG9uVG9vbENhbGxQYXJ0KHZhbHVlKSB7XG4gICAgICBjb25zdCBpbnZvY2F0aW9uID0ge1xuICAgICAgICBzdGF0ZTogXCJjYWxsXCIsXG4gICAgICAgIHN0ZXAsXG4gICAgICAgIC4uLnZhbHVlXG4gICAgICB9O1xuICAgICAgaWYgKHBhcnRpYWxUb29sQ2FsbHNbdmFsdWUudG9vbENhbGxJZF0gIT0gbnVsbCkge1xuICAgICAgICBtZXNzYWdlLnRvb2xJbnZvY2F0aW9uc1twYXJ0aWFsVG9vbENhbGxzW3ZhbHVlLnRvb2xDYWxsSWRdLmluZGV4XSA9IGludm9jYXRpb247XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobWVzc2FnZS50b29sSW52b2NhdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICAgIG1lc3NhZ2UudG9vbEludm9jYXRpb25zID0gW107XG4gICAgICAgIH1cbiAgICAgICAgbWVzc2FnZS50b29sSW52b2NhdGlvbnMucHVzaChpbnZvY2F0aW9uKTtcbiAgICAgIH1cbiAgICAgIHVwZGF0ZVRvb2xJbnZvY2F0aW9uUGFydCh2YWx1ZS50b29sQ2FsbElkLCBpbnZvY2F0aW9uKTtcbiAgICAgIGV4ZWNVcGRhdGUoKTtcbiAgICAgIGlmIChvblRvb2xDYWxsKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG9uVG9vbENhbGwoeyB0b29sQ2FsbDogdmFsdWUgfSk7XG4gICAgICAgIGlmIChyZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICAgIGNvbnN0IGludm9jYXRpb24yID0ge1xuICAgICAgICAgICAgc3RhdGU6IFwicmVzdWx0XCIsXG4gICAgICAgICAgICBzdGVwLFxuICAgICAgICAgICAgLi4udmFsdWUsXG4gICAgICAgICAgICByZXN1bHRcbiAgICAgICAgICB9O1xuICAgICAgICAgIG1lc3NhZ2UudG9vbEludm9jYXRpb25zW21lc3NhZ2UudG9vbEludm9jYXRpb25zLmxlbmd0aCAtIDFdID0gaW52b2NhdGlvbjI7XG4gICAgICAgICAgdXBkYXRlVG9vbEludm9jYXRpb25QYXJ0KHZhbHVlLnRvb2xDYWxsSWQsIGludm9jYXRpb24yKTtcbiAgICAgICAgICBleGVjVXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIG9uVG9vbFJlc3VsdFBhcnQodmFsdWUpIHtcbiAgICAgIGNvbnN0IHRvb2xJbnZvY2F0aW9ucyA9IG1lc3NhZ2UudG9vbEludm9jYXRpb25zO1xuICAgICAgaWYgKHRvb2xJbnZvY2F0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInRvb2xfcmVzdWx0IG11c3QgYmUgcHJlY2VkZWQgYnkgYSB0b29sX2NhbGxcIik7XG4gICAgICB9XG4gICAgICBjb25zdCB0b29sSW52b2NhdGlvbkluZGV4ID0gdG9vbEludm9jYXRpb25zLmZpbmRJbmRleChcbiAgICAgICAgKGludm9jYXRpb24yKSA9PiBpbnZvY2F0aW9uMi50b29sQ2FsbElkID09PSB2YWx1ZS50b29sQ2FsbElkXG4gICAgICApO1xuICAgICAgaWYgKHRvb2xJbnZvY2F0aW9uSW5kZXggPT09IC0xKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBcInRvb2xfcmVzdWx0IG11c3QgYmUgcHJlY2VkZWQgYnkgYSB0b29sX2NhbGwgd2l0aCB0aGUgc2FtZSB0b29sQ2FsbElkXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGludm9jYXRpb24gPSB7XG4gICAgICAgIC4uLnRvb2xJbnZvY2F0aW9uc1t0b29sSW52b2NhdGlvbkluZGV4XSxcbiAgICAgICAgc3RhdGU6IFwicmVzdWx0XCIsXG4gICAgICAgIC4uLnZhbHVlXG4gICAgICB9O1xuICAgICAgdG9vbEludm9jYXRpb25zW3Rvb2xJbnZvY2F0aW9uSW5kZXhdID0gaW52b2NhdGlvbjtcbiAgICAgIHVwZGF0ZVRvb2xJbnZvY2F0aW9uUGFydCh2YWx1ZS50b29sQ2FsbElkLCBpbnZvY2F0aW9uKTtcbiAgICAgIGV4ZWNVcGRhdGUoKTtcbiAgICB9LFxuICAgIG9uRGF0YVBhcnQodmFsdWUpIHtcbiAgICAgIGRhdGEucHVzaCguLi52YWx1ZSk7XG4gICAgICBleGVjVXBkYXRlKCk7XG4gICAgfSxcbiAgICBvbk1lc3NhZ2VBbm5vdGF0aW9uc1BhcnQodmFsdWUpIHtcbiAgICAgIGlmIChtZXNzYWdlQW5ub3RhdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICBtZXNzYWdlQW5ub3RhdGlvbnMgPSBbLi4udmFsdWVdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWVzc2FnZUFubm90YXRpb25zLnB1c2goLi4udmFsdWUpO1xuICAgICAgfVxuICAgICAgZXhlY1VwZGF0ZSgpO1xuICAgIH0sXG4gICAgb25GaW5pc2hTdGVwUGFydCh2YWx1ZSkge1xuICAgICAgc3RlcCArPSAxO1xuICAgICAgY3VycmVudFRleHRQYXJ0ID0gdmFsdWUuaXNDb250aW51ZWQgPyBjdXJyZW50VGV4dFBhcnQgOiB2b2lkIDA7XG4gICAgICBjdXJyZW50UmVhc29uaW5nUGFydCA9IHZvaWQgMDtcbiAgICAgIGN1cnJlbnRSZWFzb25pbmdUZXh0RGV0YWlsID0gdm9pZCAwO1xuICAgIH0sXG4gICAgb25TdGFydFN0ZXBQYXJ0KHZhbHVlKSB7XG4gICAgICBpZiAoIXJlcGxhY2VMYXN0TWVzc2FnZSkge1xuICAgICAgICBtZXNzYWdlLmlkID0gdmFsdWUubWVzc2FnZUlkO1xuICAgICAgfVxuICAgICAgbWVzc2FnZS5wYXJ0cy5wdXNoKHsgdHlwZTogXCJzdGVwLXN0YXJ0XCIgfSk7XG4gICAgICBleGVjVXBkYXRlKCk7XG4gICAgfSxcbiAgICBvbkZpbmlzaE1lc3NhZ2VQYXJ0KHZhbHVlKSB7XG4gICAgICBmaW5pc2hSZWFzb24gPSB2YWx1ZS5maW5pc2hSZWFzb247XG4gICAgICBpZiAodmFsdWUudXNhZ2UgIT0gbnVsbCkge1xuICAgICAgICB1c2FnZSA9IGNhbGN1bGF0ZUxhbmd1YWdlTW9kZWxVc2FnZSh2YWx1ZS51c2FnZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBvbkVycm9yUGFydChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yKTtcbiAgICB9XG4gIH0pO1xuICBvbkZpbmlzaCA9PSBudWxsID8gdm9pZCAwIDogb25GaW5pc2goeyBtZXNzYWdlLCBmaW5pc2hSZWFzb24sIHVzYWdlIH0pO1xufVxuXG4vLyBzcmMvcHJvY2Vzcy1jaGF0LXRleHQtcmVzcG9uc2UudHNcbnZhciBpbXBvcnRfcHJvdmlkZXJfdXRpbHMzID0gcmVxdWlyZShcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIik7XG5cbi8vIHNyYy9wcm9jZXNzLXRleHQtc3RyZWFtLnRzXG5hc3luYyBmdW5jdGlvbiBwcm9jZXNzVGV4dFN0cmVhbSh7XG4gIHN0cmVhbSxcbiAgb25UZXh0UGFydFxufSkge1xuICBjb25zdCByZWFkZXIgPSBzdHJlYW0ucGlwZVRocm91Z2gobmV3IFRleHREZWNvZGVyU3RyZWFtKCkpLmdldFJlYWRlcigpO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgaWYgKGRvbmUpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBhd2FpdCBvblRleHRQYXJ0KHZhbHVlKTtcbiAgfVxufVxuXG4vLyBzcmMvcHJvY2Vzcy1jaGF0LXRleHQtcmVzcG9uc2UudHNcbmFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NDaGF0VGV4dFJlc3BvbnNlKHtcbiAgc3RyZWFtLFxuICB1cGRhdGUsXG4gIG9uRmluaXNoLFxuICBnZXRDdXJyZW50RGF0ZSA9ICgpID0+IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpLFxuICBnZW5lcmF0ZUlkOiBnZW5lcmF0ZUlkMiA9IGltcG9ydF9wcm92aWRlcl91dGlsczMuZ2VuZXJhdGVJZFxufSkge1xuICBjb25zdCB0ZXh0UGFydCA9IHsgdHlwZTogXCJ0ZXh0XCIsIHRleHQ6IFwiXCIgfTtcbiAgY29uc3QgcmVzdWx0TWVzc2FnZSA9IHtcbiAgICBpZDogZ2VuZXJhdGVJZDIoKSxcbiAgICBjcmVhdGVkQXQ6IGdldEN1cnJlbnREYXRlKCksXG4gICAgcm9sZTogXCJhc3Npc3RhbnRcIixcbiAgICBjb250ZW50OiBcIlwiLFxuICAgIHBhcnRzOiBbdGV4dFBhcnRdXG4gIH07XG4gIGF3YWl0IHByb2Nlc3NUZXh0U3RyZWFtKHtcbiAgICBzdHJlYW0sXG4gICAgb25UZXh0UGFydDogKGNodW5rKSA9PiB7XG4gICAgICByZXN1bHRNZXNzYWdlLmNvbnRlbnQgKz0gY2h1bms7XG4gICAgICB0ZXh0UGFydC50ZXh0ICs9IGNodW5rO1xuICAgICAgdXBkYXRlKHtcbiAgICAgICAgbWVzc2FnZTogeyAuLi5yZXN1bHRNZXNzYWdlIH0sXG4gICAgICAgIGRhdGE6IFtdLFxuICAgICAgICByZXBsYWNlTGFzdE1lc3NhZ2U6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICBvbkZpbmlzaCA9PSBudWxsID8gdm9pZCAwIDogb25GaW5pc2gocmVzdWx0TWVzc2FnZSwge1xuICAgIHVzYWdlOiB7IGNvbXBsZXRpb25Ub2tlbnM6IE5hTiwgcHJvbXB0VG9rZW5zOiBOYU4sIHRvdGFsVG9rZW5zOiBOYU4gfSxcbiAgICBmaW5pc2hSZWFzb246IFwidW5rbm93blwiXG4gIH0pO1xufVxuXG4vLyBzcmMvY2FsbC1jaGF0LWFwaS50c1xudmFyIGdldE9yaWdpbmFsRmV0Y2ggPSAoKSA9PiBmZXRjaDtcbmFzeW5jIGZ1bmN0aW9uIGNhbGxDaGF0QXBpKHtcbiAgYXBpLFxuICBib2R5LFxuICBzdHJlYW1Qcm90b2NvbCA9IFwiZGF0YVwiLFxuICBjcmVkZW50aWFscyxcbiAgaGVhZGVycyxcbiAgYWJvcnRDb250cm9sbGVyLFxuICByZXN0b3JlTWVzc2FnZXNPbkZhaWx1cmUsXG4gIG9uUmVzcG9uc2UsXG4gIG9uVXBkYXRlLFxuICBvbkZpbmlzaCxcbiAgb25Ub29sQ2FsbCxcbiAgZ2VuZXJhdGVJZDogZ2VuZXJhdGVJZDIsXG4gIGZldGNoOiBmZXRjaDIgPSBnZXRPcmlnaW5hbEZldGNoKCksXG4gIGxhc3RNZXNzYWdlXG59KSB7XG4gIHZhciBfYSwgX2I7XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2gyKGFwaSwge1xuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgaGVhZGVyczoge1xuICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAuLi5oZWFkZXJzXG4gICAgfSxcbiAgICBzaWduYWw6IChfYSA9IGFib3J0Q29udHJvbGxlciA9PSBudWxsID8gdm9pZCAwIDogYWJvcnRDb250cm9sbGVyKCkpID09IG51bGwgPyB2b2lkIDAgOiBfYS5zaWduYWwsXG4gICAgY3JlZGVudGlhbHNcbiAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgIHJlc3RvcmVNZXNzYWdlc09uRmFpbHVyZSgpO1xuICAgIHRocm93IGVycjtcbiAgfSk7XG4gIGlmIChvblJlc3BvbnNlKSB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IG9uUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgfVxuICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgcmVzdG9yZU1lc3NhZ2VzT25GYWlsdXJlKCk7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgKF9iID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpKSAhPSBudWxsID8gX2IgOiBcIkZhaWxlZCB0byBmZXRjaCB0aGUgY2hhdCByZXNwb25zZS5cIlxuICAgICk7XG4gIH1cbiAgaWYgKCFyZXNwb25zZS5ib2R5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHJlc3BvbnNlIGJvZHkgaXMgZW1wdHkuXCIpO1xuICB9XG4gIHN3aXRjaCAoc3RyZWFtUHJvdG9jb2wpIHtcbiAgICBjYXNlIFwidGV4dFwiOiB7XG4gICAgICBhd2FpdCBwcm9jZXNzQ2hhdFRleHRSZXNwb25zZSh7XG4gICAgICAgIHN0cmVhbTogcmVzcG9uc2UuYm9keSxcbiAgICAgICAgdXBkYXRlOiBvblVwZGF0ZSxcbiAgICAgICAgb25GaW5pc2gsXG4gICAgICAgIGdlbmVyYXRlSWQ6IGdlbmVyYXRlSWQyXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FzZSBcImRhdGFcIjoge1xuICAgICAgYXdhaXQgcHJvY2Vzc0NoYXRSZXNwb25zZSh7XG4gICAgICAgIHN0cmVhbTogcmVzcG9uc2UuYm9keSxcbiAgICAgICAgdXBkYXRlOiBvblVwZGF0ZSxcbiAgICAgICAgbGFzdE1lc3NhZ2UsXG4gICAgICAgIG9uVG9vbENhbGwsXG4gICAgICAgIG9uRmluaXNoKHsgbWVzc2FnZSwgZmluaXNoUmVhc29uLCB1c2FnZSB9KSB7XG4gICAgICAgICAgaWYgKG9uRmluaXNoICYmIG1lc3NhZ2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgb25GaW5pc2gobWVzc2FnZSwgeyB1c2FnZSwgZmluaXNoUmVhc29uIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZ2VuZXJhdGVJZDogZ2VuZXJhdGVJZDJcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICBjb25zdCBleGhhdXN0aXZlQ2hlY2sgPSBzdHJlYW1Qcm90b2NvbDtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBzdHJlYW0gcHJvdG9jb2w6ICR7ZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgIH1cbiAgfVxufVxuXG4vLyBzcmMvY2FsbC1jb21wbGV0aW9uLWFwaS50c1xudmFyIGdldE9yaWdpbmFsRmV0Y2gyID0gKCkgPT4gZmV0Y2g7XG5hc3luYyBmdW5jdGlvbiBjYWxsQ29tcGxldGlvbkFwaSh7XG4gIGFwaSxcbiAgcHJvbXB0LFxuICBjcmVkZW50aWFscyxcbiAgaGVhZGVycyxcbiAgYm9keSxcbiAgc3RyZWFtUHJvdG9jb2wgPSBcImRhdGFcIixcbiAgc2V0Q29tcGxldGlvbixcbiAgc2V0TG9hZGluZyxcbiAgc2V0RXJyb3IsXG4gIHNldEFib3J0Q29udHJvbGxlcixcbiAgb25SZXNwb25zZSxcbiAgb25GaW5pc2gsXG4gIG9uRXJyb3IsXG4gIG9uRGF0YSxcbiAgZmV0Y2g6IGZldGNoMiA9IGdldE9yaWdpbmFsRmV0Y2gyKClcbn0pIHtcbiAgdmFyIF9hO1xuICB0cnkge1xuICAgIHNldExvYWRpbmcodHJ1ZSk7XG4gICAgc2V0RXJyb3Iodm9pZCAwKTtcbiAgICBjb25zdCBhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgc2V0QWJvcnRDb250cm9sbGVyKGFib3J0Q29udHJvbGxlcik7XG4gICAgc2V0Q29tcGxldGlvbihcIlwiKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoMihhcGksIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIHByb21wdCxcbiAgICAgICAgLi4uYm9keVxuICAgICAgfSksXG4gICAgICBjcmVkZW50aWFscyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgIC4uLmhlYWRlcnNcbiAgICAgIH0sXG4gICAgICBzaWduYWw6IGFib3J0Q29udHJvbGxlci5zaWduYWxcbiAgICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfSk7XG4gICAgaWYgKG9uUmVzcG9uc2UpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IG9uUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAoX2EgPSBhd2FpdCByZXNwb25zZS50ZXh0KCkpICE9IG51bGwgPyBfYSA6IFwiRmFpbGVkIHRvIGZldGNoIHRoZSBjaGF0IHJlc3BvbnNlLlwiXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoIXJlc3BvbnNlLmJvZHkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSByZXNwb25zZSBib2R5IGlzIGVtcHR5LlwiKTtcbiAgICB9XG4gICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgc3dpdGNoIChzdHJlYW1Qcm90b2NvbCkge1xuICAgICAgY2FzZSBcInRleHRcIjoge1xuICAgICAgICBhd2FpdCBwcm9jZXNzVGV4dFN0cmVhbSh7XG4gICAgICAgICAgc3RyZWFtOiByZXNwb25zZS5ib2R5LFxuICAgICAgICAgIG9uVGV4dFBhcnQ6IChjaHVuaykgPT4ge1xuICAgICAgICAgICAgcmVzdWx0ICs9IGNodW5rO1xuICAgICAgICAgICAgc2V0Q29tcGxldGlvbihyZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcImRhdGFcIjoge1xuICAgICAgICBhd2FpdCBwcm9jZXNzRGF0YVN0cmVhbSh7XG4gICAgICAgICAgc3RyZWFtOiByZXNwb25zZS5ib2R5LFxuICAgICAgICAgIG9uVGV4dFBhcnQodmFsdWUpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSB2YWx1ZTtcbiAgICAgICAgICAgIHNldENvbXBsZXRpb24ocmVzdWx0KTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9uRGF0YVBhcnQodmFsdWUpIHtcbiAgICAgICAgICAgIG9uRGF0YSA9PSBudWxsID8gdm9pZCAwIDogb25EYXRhKHZhbHVlKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9uRXJyb3JQYXJ0KHZhbHVlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICBjb25zdCBleGhhdXN0aXZlQ2hlY2sgPSBzdHJlYW1Qcm90b2NvbDtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHN0cmVhbSBwcm90b2NvbDogJHtleGhhdXN0aXZlQ2hlY2t9YCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvbkZpbmlzaCkge1xuICAgICAgb25GaW5pc2gocHJvbXB0LCByZXN1bHQpO1xuICAgIH1cbiAgICBzZXRBYm9ydENvbnRyb2xsZXIobnVsbCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKGVyci5uYW1lID09PSBcIkFib3J0RXJyb3JcIikge1xuICAgICAgc2V0QWJvcnRDb250cm9sbGVyKG51bGwpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgaWYgKG9uRXJyb3IpIHtcbiAgICAgICAgb25FcnJvcihlcnIpO1xuICAgICAgfVxuICAgIH1cbiAgICBzZXRFcnJvcihlcnIpO1xuICB9IGZpbmFsbHkge1xuICAgIHNldExvYWRpbmcoZmFsc2UpO1xuICB9XG59XG5cbi8vIHNyYy9kYXRhLXVybC50c1xuZnVuY3Rpb24gZ2V0VGV4dEZyb21EYXRhVXJsKGRhdGFVcmwpIHtcbiAgY29uc3QgW2hlYWRlciwgYmFzZTY0Q29udGVudF0gPSBkYXRhVXJsLnNwbGl0KFwiLFwiKTtcbiAgY29uc3QgbWltZVR5cGUgPSBoZWFkZXIuc3BsaXQoXCI7XCIpWzBdLnNwbGl0KFwiOlwiKVsxXTtcbiAgaWYgKG1pbWVUeXBlID09IG51bGwgfHwgYmFzZTY0Q29udGVudCA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBkYXRhIFVSTCBmb3JtYXRcIik7XG4gIH1cbiAgdHJ5IHtcbiAgICByZXR1cm4gd2luZG93LmF0b2IoYmFzZTY0Q29udGVudCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBkZWNvZGluZyBkYXRhIFVSTGApO1xuICB9XG59XG5cbi8vIHNyYy9leHRyYWN0LW1heC10b29sLWludm9jYXRpb24tc3RlcC50c1xuZnVuY3Rpb24gZXh0cmFjdE1heFRvb2xJbnZvY2F0aW9uU3RlcCh0b29sSW52b2NhdGlvbnMpIHtcbiAgcmV0dXJuIHRvb2xJbnZvY2F0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogdG9vbEludm9jYXRpb25zLnJlZHVjZSgobWF4LCB0b29sSW52b2NhdGlvbikgPT4ge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gTWF0aC5tYXgobWF4LCAoX2EgPSB0b29sSW52b2NhdGlvbi5zdGVwKSAhPSBudWxsID8gX2EgOiAwKTtcbiAgfSwgMCk7XG59XG5cbi8vIHNyYy9nZXQtbWVzc2FnZS1wYXJ0cy50c1xuZnVuY3Rpb24gZ2V0TWVzc2FnZVBhcnRzKG1lc3NhZ2UpIHtcbiAgdmFyIF9hO1xuICByZXR1cm4gKF9hID0gbWVzc2FnZS5wYXJ0cykgIT0gbnVsbCA/IF9hIDogW1xuICAgIC4uLm1lc3NhZ2UudG9vbEludm9jYXRpb25zID8gbWVzc2FnZS50b29sSW52b2NhdGlvbnMubWFwKCh0b29sSW52b2NhdGlvbikgPT4gKHtcbiAgICAgIHR5cGU6IFwidG9vbC1pbnZvY2F0aW9uXCIsXG4gICAgICB0b29sSW52b2NhdGlvblxuICAgIH0pKSA6IFtdLFxuICAgIC4uLm1lc3NhZ2UucmVhc29uaW5nID8gW1xuICAgICAge1xuICAgICAgICB0eXBlOiBcInJlYXNvbmluZ1wiLFxuICAgICAgICByZWFzb25pbmc6IG1lc3NhZ2UucmVhc29uaW5nLFxuICAgICAgICBkZXRhaWxzOiBbeyB0eXBlOiBcInRleHRcIiwgdGV4dDogbWVzc2FnZS5yZWFzb25pbmcgfV1cbiAgICAgIH1cbiAgICBdIDogW10sXG4gICAgLi4ubWVzc2FnZS5jb250ZW50ID8gW3sgdHlwZTogXCJ0ZXh0XCIsIHRleHQ6IG1lc3NhZ2UuY29udGVudCB9XSA6IFtdXG4gIF07XG59XG5cbi8vIHNyYy9maWxsLW1lc3NhZ2UtcGFydHMudHNcbmZ1bmN0aW9uIGZpbGxNZXNzYWdlUGFydHMobWVzc2FnZXMpIHtcbiAgcmV0dXJuIG1lc3NhZ2VzLm1hcCgobWVzc2FnZSkgPT4gKHtcbiAgICAuLi5tZXNzYWdlLFxuICAgIHBhcnRzOiBnZXRNZXNzYWdlUGFydHMobWVzc2FnZSlcbiAgfSkpO1xufVxuXG4vLyBzcmMvaXMtZGVlcC1lcXVhbC1kYXRhLnRzXG5mdW5jdGlvbiBpc0RlZXBFcXVhbERhdGEob2JqMSwgb2JqMikge1xuICBpZiAob2JqMSA9PT0gb2JqMilcbiAgICByZXR1cm4gdHJ1ZTtcbiAgaWYgKG9iajEgPT0gbnVsbCB8fCBvYmoyID09IG51bGwpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIG9iajEgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iajIgIT09IFwib2JqZWN0XCIpXG4gICAgcmV0dXJuIG9iajEgPT09IG9iajI7XG4gIGlmIChvYmoxLmNvbnN0cnVjdG9yICE9PSBvYmoyLmNvbnN0cnVjdG9yKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKG9iajEgaW5zdGFuY2VvZiBEYXRlICYmIG9iajIgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgcmV0dXJuIG9iajEuZ2V0VGltZSgpID09PSBvYmoyLmdldFRpbWUoKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShvYmoxKSkge1xuICAgIGlmIChvYmoxLmxlbmd0aCAhPT0gb2JqMi5sZW5ndGgpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvYmoxLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIWlzRGVlcEVxdWFsRGF0YShvYmoxW2ldLCBvYmoyW2ldKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBrZXlzMSA9IE9iamVjdC5rZXlzKG9iajEpO1xuICBjb25zdCBrZXlzMiA9IE9iamVjdC5rZXlzKG9iajIpO1xuICBpZiAoa2V5czEubGVuZ3RoICE9PSBrZXlzMi5sZW5ndGgpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzMSkge1xuICAgIGlmICgha2V5czIuaW5jbHVkZXMoa2V5KSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoIWlzRGVlcEVxdWFsRGF0YShvYmoxW2tleV0sIG9iajJba2V5XSkpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIHNyYy9wcmVwYXJlLWF0dGFjaG1lbnRzLWZvci1yZXF1ZXN0LnRzXG5hc3luYyBmdW5jdGlvbiBwcmVwYXJlQXR0YWNobWVudHNGb3JSZXF1ZXN0KGF0dGFjaG1lbnRzRnJvbU9wdGlvbnMpIHtcbiAgaWYgKCFhdHRhY2htZW50c0Zyb21PcHRpb25zKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGlmIChhdHRhY2htZW50c0Zyb21PcHRpb25zIGluc3RhbmNlb2YgRmlsZUxpc3QpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoXG4gICAgICBBcnJheS5mcm9tKGF0dGFjaG1lbnRzRnJvbU9wdGlvbnMpLm1hcChhc3luYyAoYXR0YWNobWVudCkgPT4ge1xuICAgICAgICBjb25zdCB7IG5hbWUsIHR5cGUgfSA9IGF0dGFjaG1lbnQ7XG4gICAgICAgIGNvbnN0IGRhdGFVcmwgPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgY29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgICAgICByZWFkZXIub25sb2FkID0gKHJlYWRlckV2ZW50KSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICByZXNvbHZlKChfYSA9IHJlYWRlckV2ZW50LnRhcmdldCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnJlc3VsdCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICByZWFkZXIub25lcnJvciA9IChlcnJvcikgPT4gcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICByZWFkZXIucmVhZEFzRGF0YVVSTChhdHRhY2htZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBjb250ZW50VHlwZTogdHlwZSxcbiAgICAgICAgICB1cmw6IGRhdGFVcmxcbiAgICAgICAgfTtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShhdHRhY2htZW50c0Zyb21PcHRpb25zKSkge1xuICAgIHJldHVybiBhdHRhY2htZW50c0Zyb21PcHRpb25zO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYXR0YWNobWVudHMgdHlwZVwiKTtcbn1cblxuLy8gc3JjL3Byb2Nlc3MtYXNzaXN0YW50LXN0cmVhbS50c1xudmFyIE5FV0xJTkUyID0gXCJcXG5cIi5jaGFyQ29kZUF0KDApO1xuZnVuY3Rpb24gY29uY2F0Q2h1bmtzMihjaHVua3MsIHRvdGFsTGVuZ3RoKSB7XG4gIGNvbnN0IGNvbmNhdGVuYXRlZENodW5rcyA9IG5ldyBVaW50OEFycmF5KHRvdGFsTGVuZ3RoKTtcbiAgbGV0IG9mZnNldCA9IDA7XG4gIGZvciAoY29uc3QgY2h1bmsgb2YgY2h1bmtzKSB7XG4gICAgY29uY2F0ZW5hdGVkQ2h1bmtzLnNldChjaHVuaywgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gY2h1bmsubGVuZ3RoO1xuICB9XG4gIGNodW5rcy5sZW5ndGggPSAwO1xuICByZXR1cm4gY29uY2F0ZW5hdGVkQ2h1bmtzO1xufVxuYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc0Fzc2lzdGFudFN0cmVhbSh7XG4gIHN0cmVhbSxcbiAgb25UZXh0UGFydCxcbiAgb25FcnJvclBhcnQsXG4gIG9uQXNzaXN0YW50TWVzc2FnZVBhcnQsXG4gIG9uQXNzaXN0YW50Q29udHJvbERhdGFQYXJ0LFxuICBvbkRhdGFNZXNzYWdlUGFydFxufSkge1xuICBjb25zdCByZWFkZXIgPSBzdHJlYW0uZ2V0UmVhZGVyKCk7XG4gIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgY29uc3QgY2h1bmtzID0gW107XG4gIGxldCB0b3RhbExlbmd0aCA9IDA7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3QgeyB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGNodW5rcy5wdXNoKHZhbHVlKTtcbiAgICAgIHRvdGFsTGVuZ3RoICs9IHZhbHVlLmxlbmd0aDtcbiAgICAgIGlmICh2YWx1ZVt2YWx1ZS5sZW5ndGggLSAxXSAhPT0gTkVXTElORTIpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjaHVua3MubGVuZ3RoID09PSAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY29uc3QgY29uY2F0ZW5hdGVkQ2h1bmtzID0gY29uY2F0Q2h1bmtzMihjaHVua3MsIHRvdGFsTGVuZ3RoKTtcbiAgICB0b3RhbExlbmd0aCA9IDA7XG4gICAgY29uc3Qgc3RyZWFtUGFydHMgPSBkZWNvZGVyLmRlY29kZShjb25jYXRlbmF0ZWRDaHVua3MsIHsgc3RyZWFtOiB0cnVlIH0pLnNwbGl0KFwiXFxuXCIpLmZpbHRlcigobGluZSkgPT4gbGluZSAhPT0gXCJcIikubWFwKHBhcnNlQXNzaXN0YW50U3RyZWFtUGFydCk7XG4gICAgZm9yIChjb25zdCB7IHR5cGUsIHZhbHVlOiB2YWx1ZTIgfSBvZiBzdHJlYW1QYXJ0cykge1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJ0ZXh0XCI6XG4gICAgICAgICAgYXdhaXQgKG9uVGV4dFBhcnQgPT0gbnVsbCA/IHZvaWQgMCA6IG9uVGV4dFBhcnQodmFsdWUyKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJlcnJvclwiOlxuICAgICAgICAgIGF3YWl0IChvbkVycm9yUGFydCA9PSBudWxsID8gdm9pZCAwIDogb25FcnJvclBhcnQodmFsdWUyKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJhc3Npc3RhbnRfbWVzc2FnZVwiOlxuICAgICAgICAgIGF3YWl0IChvbkFzc2lzdGFudE1lc3NhZ2VQYXJ0ID09IG51bGwgPyB2b2lkIDAgOiBvbkFzc2lzdGFudE1lc3NhZ2VQYXJ0KHZhbHVlMikpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiYXNzaXN0YW50X2NvbnRyb2xfZGF0YVwiOlxuICAgICAgICAgIGF3YWl0IChvbkFzc2lzdGFudENvbnRyb2xEYXRhUGFydCA9PSBudWxsID8gdm9pZCAwIDogb25Bc3Npc3RhbnRDb250cm9sRGF0YVBhcnQodmFsdWUyKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJkYXRhX21lc3NhZ2VcIjpcbiAgICAgICAgICBhd2FpdCAob25EYXRhTWVzc2FnZVBhcnQgPT0gbnVsbCA/IHZvaWQgMCA6IG9uRGF0YU1lc3NhZ2VQYXJ0KHZhbHVlMikpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgY29uc3QgZXhoYXVzdGl2ZUNoZWNrID0gdHlwZTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gc3RyZWFtIHBhcnQgdHlwZTogJHtleGhhdXN0aXZlQ2hlY2t9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gc3JjL3NjaGVtYS50c1xudmFyIGltcG9ydF9wcm92aWRlcl91dGlsczQgPSByZXF1aXJlKFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiKTtcblxuLy8gc3JjL3pvZC1zY2hlbWEudHNcbnZhciBpbXBvcnRfem9kX3RvX2pzb25fc2NoZW1hID0gX190b0VTTShyZXF1aXJlKFwiem9kLXRvLWpzb24tc2NoZW1hXCIpKTtcbmZ1bmN0aW9uIHpvZFNjaGVtYSh6b2RTY2hlbWEyLCBvcHRpb25zKSB7XG4gIHZhciBfYTtcbiAgY29uc3QgdXNlUmVmZXJlbmNlcyA9IChfYSA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMudXNlUmVmZXJlbmNlcykgIT0gbnVsbCA/IF9hIDogZmFsc2U7XG4gIHJldHVybiBqc29uU2NoZW1hKFxuICAgICgwLCBpbXBvcnRfem9kX3RvX2pzb25fc2NoZW1hLmRlZmF1bHQpKHpvZFNjaGVtYTIsIHtcbiAgICAgICRyZWZTdHJhdGVneTogdXNlUmVmZXJlbmNlcyA/IFwicm9vdFwiIDogXCJub25lXCIsXG4gICAgICB0YXJnZXQ6IFwianNvblNjaGVtYTdcIlxuICAgICAgLy8gbm90ZTogb3BlbmFpIG1vZGUgYnJlYWtzIHZhcmlvdXMgZ2VtaW5pIGNvbnZlcnNpb25zXG4gICAgfSksXG4gICAge1xuICAgICAgdmFsaWRhdGU6ICh2YWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB6b2RTY2hlbWEyLnNhZmVQYXJzZSh2YWx1ZSk7XG4gICAgICAgIHJldHVybiByZXN1bHQuc3VjY2VzcyA/IHsgc3VjY2VzczogdHJ1ZSwgdmFsdWU6IHJlc3VsdC5kYXRhIH0gOiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogcmVzdWx0LmVycm9yIH07XG4gICAgICB9XG4gICAgfVxuICApO1xufVxuXG4vLyBzcmMvc2NoZW1hLnRzXG52YXIgc2NoZW1hU3ltYm9sID0gU3ltYm9sLmZvcihcInZlcmNlbC5haS5zY2hlbWFcIik7XG5mdW5jdGlvbiBqc29uU2NoZW1hKGpzb25TY2hlbWEyLCB7XG4gIHZhbGlkYXRlXG59ID0ge30pIHtcbiAgcmV0dXJuIHtcbiAgICBbc2NoZW1hU3ltYm9sXTogdHJ1ZSxcbiAgICBfdHlwZTogdm9pZCAwLFxuICAgIC8vIHNob3VsZCBuZXZlciBiZSB1c2VkIGRpcmVjdGx5XG4gICAgW2ltcG9ydF9wcm92aWRlcl91dGlsczQudmFsaWRhdG9yU3ltYm9sXTogdHJ1ZSxcbiAgICBqc29uU2NoZW1hOiBqc29uU2NoZW1hMixcbiAgICB2YWxpZGF0ZVxuICB9O1xufVxuZnVuY3Rpb24gaXNTY2hlbWEodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbCAmJiBzY2hlbWFTeW1ib2wgaW4gdmFsdWUgJiYgdmFsdWVbc2NoZW1hU3ltYm9sXSA9PT0gdHJ1ZSAmJiBcImpzb25TY2hlbWFcIiBpbiB2YWx1ZSAmJiBcInZhbGlkYXRlXCIgaW4gdmFsdWU7XG59XG5mdW5jdGlvbiBhc1NjaGVtYShzY2hlbWEpIHtcbiAgcmV0dXJuIGlzU2NoZW1hKHNjaGVtYSkgPyBzY2hlbWEgOiB6b2RTY2hlbWEoc2NoZW1hKTtcbn1cblxuLy8gc3JjL3Nob3VsZC1yZXN1Ym1pdC1tZXNzYWdlcy50c1xuZnVuY3Rpb24gc2hvdWxkUmVzdWJtaXRNZXNzYWdlcyh7XG4gIG9yaWdpbmFsTWF4VG9vbEludm9jYXRpb25TdGVwLFxuICBvcmlnaW5hbE1lc3NhZ2VDb3VudCxcbiAgbWF4U3RlcHMsXG4gIG1lc3NhZ2VzXG59KSB7XG4gIHZhciBfYTtcbiAgY29uc3QgbGFzdE1lc3NhZ2UgPSBtZXNzYWdlc1ttZXNzYWdlcy5sZW5ndGggLSAxXTtcbiAgcmV0dXJuIChcbiAgICAvLyBjaGVjayBpZiB0aGUgZmVhdHVyZSBpcyBlbmFibGVkOlxuICAgIG1heFN0ZXBzID4gMSAmJiAvLyBlbnN1cmUgdGhlcmUgaXMgYSBsYXN0IG1lc3NhZ2U6XG4gICAgbGFzdE1lc3NhZ2UgIT0gbnVsbCAmJiAvLyBlbnN1cmUgd2UgYWN0dWFsbHkgaGF2ZSBuZXcgc3RlcHMgKHRvIHByZXZlbnQgaW5maW5pdGUgbG9vcHMgaW4gY2FzZSBvZiBlcnJvcnMpOlxuICAgIChtZXNzYWdlcy5sZW5ndGggPiBvcmlnaW5hbE1lc3NhZ2VDb3VudCB8fCBleHRyYWN0TWF4VG9vbEludm9jYXRpb25TdGVwKGxhc3RNZXNzYWdlLnRvb2xJbnZvY2F0aW9ucykgIT09IG9yaWdpbmFsTWF4VG9vbEludm9jYXRpb25TdGVwKSAmJiAvLyBjaGVjayB0aGF0IG5leHQgc3RlcCBpcyBwb3NzaWJsZTpcbiAgICBpc0Fzc2lzdGFudE1lc3NhZ2VXaXRoQ29tcGxldGVkVG9vbENhbGxzKGxhc3RNZXNzYWdlKSAmJiAvLyBsaW1pdCB0aGUgbnVtYmVyIG9mIGF1dG9tYXRpYyBzdGVwczpcbiAgICAoKF9hID0gZXh0cmFjdE1heFRvb2xJbnZvY2F0aW9uU3RlcChsYXN0TWVzc2FnZS50b29sSW52b2NhdGlvbnMpKSAhPSBudWxsID8gX2EgOiAwKSA8IG1heFN0ZXBzXG4gICk7XG59XG5mdW5jdGlvbiBpc0Fzc2lzdGFudE1lc3NhZ2VXaXRoQ29tcGxldGVkVG9vbENhbGxzKG1lc3NhZ2UpIHtcbiAgaWYgKG1lc3NhZ2Uucm9sZSAhPT0gXCJhc3Npc3RhbnRcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBsYXN0U3RlcFN0YXJ0SW5kZXggPSBtZXNzYWdlLnBhcnRzLnJlZHVjZSgobGFzdEluZGV4LCBwYXJ0LCBpbmRleCkgPT4ge1xuICAgIHJldHVybiBwYXJ0LnR5cGUgPT09IFwic3RlcC1zdGFydFwiID8gaW5kZXggOiBsYXN0SW5kZXg7XG4gIH0sIC0xKTtcbiAgY29uc3QgbGFzdFN0ZXBUb29sSW52b2NhdGlvbnMgPSBtZXNzYWdlLnBhcnRzLnNsaWNlKGxhc3RTdGVwU3RhcnRJbmRleCArIDEpLmZpbHRlcigocGFydCkgPT4gcGFydC50eXBlID09PSBcInRvb2wtaW52b2NhdGlvblwiKTtcbiAgcmV0dXJuIGxhc3RTdGVwVG9vbEludm9jYXRpb25zLmxlbmd0aCA+IDAgJiYgbGFzdFN0ZXBUb29sSW52b2NhdGlvbnMuZXZlcnkoKHBhcnQpID0+IFwicmVzdWx0XCIgaW4gcGFydC50b29sSW52b2NhdGlvbik7XG59XG5cbi8vIHNyYy91cGRhdGUtdG9vbC1jYWxsLXJlc3VsdC50c1xuZnVuY3Rpb24gdXBkYXRlVG9vbENhbGxSZXN1bHQoe1xuICBtZXNzYWdlcyxcbiAgdG9vbENhbGxJZCxcbiAgdG9vbFJlc3VsdDogcmVzdWx0XG59KSB7XG4gIHZhciBfYTtcbiAgY29uc3QgbGFzdE1lc3NhZ2UgPSBtZXNzYWdlc1ttZXNzYWdlcy5sZW5ndGggLSAxXTtcbiAgY29uc3QgaW52b2NhdGlvblBhcnQgPSBsYXN0TWVzc2FnZS5wYXJ0cy5maW5kKFxuICAgIChwYXJ0KSA9PiBwYXJ0LnR5cGUgPT09IFwidG9vbC1pbnZvY2F0aW9uXCIgJiYgcGFydC50b29sSW52b2NhdGlvbi50b29sQ2FsbElkID09PSB0b29sQ2FsbElkXG4gICk7XG4gIGlmIChpbnZvY2F0aW9uUGFydCA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHRvb2xSZXN1bHQgPSB7XG4gICAgLi4uaW52b2NhdGlvblBhcnQudG9vbEludm9jYXRpb24sXG4gICAgc3RhdGU6IFwicmVzdWx0XCIsXG4gICAgcmVzdWx0XG4gIH07XG4gIGludm9jYXRpb25QYXJ0LnRvb2xJbnZvY2F0aW9uID0gdG9vbFJlc3VsdDtcbiAgbGFzdE1lc3NhZ2UudG9vbEludm9jYXRpb25zID0gKF9hID0gbGFzdE1lc3NhZ2UudG9vbEludm9jYXRpb25zKSA9PSBudWxsID8gdm9pZCAwIDogX2EubWFwKFxuICAgICh0b29sSW52b2NhdGlvbikgPT4gdG9vbEludm9jYXRpb24udG9vbENhbGxJZCA9PT0gdG9vbENhbGxJZCA/IHRvb2xSZXN1bHQgOiB0b29sSW52b2NhdGlvblxuICApO1xufVxuLy8gQW5ub3RhdGUgdGhlIENvbW1vbkpTIGV4cG9ydCBuYW1lcyBmb3IgRVNNIGltcG9ydCBpbiBub2RlOlxuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gIGFzU2NoZW1hLFxuICBjYWxsQ2hhdEFwaSxcbiAgY2FsbENvbXBsZXRpb25BcGksXG4gIGV4dHJhY3RNYXhUb29sSW52b2NhdGlvblN0ZXAsXG4gIGZpbGxNZXNzYWdlUGFydHMsXG4gIGZvcm1hdEFzc2lzdGFudFN0cmVhbVBhcnQsXG4gIGZvcm1hdERhdGFTdHJlYW1QYXJ0LFxuICBnZW5lcmF0ZUlkLFxuICBnZXRNZXNzYWdlUGFydHMsXG4gIGdldFRleHRGcm9tRGF0YVVybCxcbiAgaXNBc3Npc3RhbnRNZXNzYWdlV2l0aENvbXBsZXRlZFRvb2xDYWxscyxcbiAgaXNEZWVwRXF1YWxEYXRhLFxuICBqc29uU2NoZW1hLFxuICBwYXJzZUFzc2lzdGFudFN0cmVhbVBhcnQsXG4gIHBhcnNlRGF0YVN0cmVhbVBhcnQsXG4gIHBhcnNlUGFydGlhbEpzb24sXG4gIHByZXBhcmVBdHRhY2htZW50c0ZvclJlcXVlc3QsXG4gIHByb2Nlc3NBc3Npc3RhbnRTdHJlYW0sXG4gIHByb2Nlc3NEYXRhU3RyZWFtLFxuICBwcm9jZXNzVGV4dFN0cmVhbSxcbiAgc2hvdWxkUmVzdWJtaXRNZXNzYWdlcyxcbiAgdXBkYXRlVG9vbENhbGxSZXN1bHQsXG4gIHpvZFNjaGVtYVxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@ai-sdk/ui-utils/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@ai-sdk/openai/dist/index.mjs":
/*!****************************************************!*\
  !*** ./node_modules/@ai-sdk/openai/dist/index.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createOpenAI: () => (/* binding */ createOpenAI),\n/* harmony export */   openai: () => (/* binding */ openai)\n/* harmony export */ });\n/* harmony import */ var _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ai-sdk/provider-utils */ \"(rsc)/./node_modules/@ai-sdk/provider-utils/dist/index.mjs\");\n/* harmony import */ var _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ai-sdk/provider */ \"(rsc)/./node_modules/@ai-sdk/provider/dist/index.mjs\");\n/* harmony import */ var zod__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/lib/index.mjs\");\n// src/openai-provider.ts\n\n\n// src/openai-chat-language-model.ts\n\n\n\n\n// src/convert-to-openai-chat-messages.ts\n\n\nfunction convertToOpenAIChatMessages({\n  prompt,\n  useLegacyFunctionCalling = false,\n  systemMessageMode = \"system\"\n}) {\n  const messages = [];\n  const warnings = [];\n  for (const { role, content } of prompt) {\n    switch (role) {\n      case \"system\": {\n        switch (systemMessageMode) {\n          case \"system\": {\n            messages.push({ role: \"system\", content });\n            break;\n          }\n          case \"developer\": {\n            messages.push({ role: \"developer\", content });\n            break;\n          }\n          case \"remove\": {\n            warnings.push({\n              type: \"other\",\n              message: \"system messages are removed for this model\"\n            });\n            break;\n          }\n          default: {\n            const _exhaustiveCheck = systemMessageMode;\n            throw new Error(\n              `Unsupported system message mode: ${_exhaustiveCheck}`\n            );\n          }\n        }\n        break;\n      }\n      case \"user\": {\n        if (content.length === 1 && content[0].type === \"text\") {\n          messages.push({ role: \"user\", content: content[0].text });\n          break;\n        }\n        messages.push({\n          role: \"user\",\n          content: content.map((part, index) => {\n            var _a, _b, _c, _d;\n            switch (part.type) {\n              case \"text\": {\n                return { type: \"text\", text: part.text };\n              }\n              case \"image\": {\n                return {\n                  type: \"image_url\",\n                  image_url: {\n                    url: part.image instanceof URL ? part.image.toString() : `data:${(_a = part.mimeType) != null ? _a : \"image/jpeg\"};base64,${(0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.convertUint8ArrayToBase64)(part.image)}`,\n                    // OpenAI specific extension: image detail\n                    detail: (_c = (_b = part.providerMetadata) == null ? void 0 : _b.openai) == null ? void 0 : _c.imageDetail\n                  }\n                };\n              }\n              case \"file\": {\n                if (part.data instanceof URL) {\n                  throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.UnsupportedFunctionalityError({\n                    functionality: \"'File content parts with URL data' functionality not supported.\"\n                  });\n                }\n                switch (part.mimeType) {\n                  case \"audio/wav\": {\n                    return {\n                      type: \"input_audio\",\n                      input_audio: { data: part.data, format: \"wav\" }\n                    };\n                  }\n                  case \"audio/mp3\":\n                  case \"audio/mpeg\": {\n                    return {\n                      type: \"input_audio\",\n                      input_audio: { data: part.data, format: \"mp3\" }\n                    };\n                  }\n                  case \"application/pdf\": {\n                    return {\n                      type: \"file\",\n                      file: {\n                        filename: (_d = part.filename) != null ? _d : `part-${index}.pdf`,\n                        file_data: `data:application/pdf;base64,${part.data}`\n                      }\n                    };\n                  }\n                  default: {\n                    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.UnsupportedFunctionalityError({\n                      functionality: `File content part type ${part.mimeType} in user messages`\n                    });\n                  }\n                }\n              }\n            }\n          })\n        });\n        break;\n      }\n      case \"assistant\": {\n        let text = \"\";\n        const toolCalls = [];\n        for (const part of content) {\n          switch (part.type) {\n            case \"text\": {\n              text += part.text;\n              break;\n            }\n            case \"tool-call\": {\n              toolCalls.push({\n                id: part.toolCallId,\n                type: \"function\",\n                function: {\n                  name: part.toolName,\n                  arguments: JSON.stringify(part.args)\n                }\n              });\n              break;\n            }\n          }\n        }\n        if (useLegacyFunctionCalling) {\n          if (toolCalls.length > 1) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.UnsupportedFunctionalityError({\n              functionality: \"useLegacyFunctionCalling with multiple tool calls in one message\"\n            });\n          }\n          messages.push({\n            role: \"assistant\",\n            content: text,\n            function_call: toolCalls.length > 0 ? toolCalls[0].function : void 0\n          });\n        } else {\n          messages.push({\n            role: \"assistant\",\n            content: text,\n            tool_calls: toolCalls.length > 0 ? toolCalls : void 0\n          });\n        }\n        break;\n      }\n      case \"tool\": {\n        for (const toolResponse of content) {\n          if (useLegacyFunctionCalling) {\n            messages.push({\n              role: \"function\",\n              name: toolResponse.toolName,\n              content: JSON.stringify(toolResponse.result)\n            });\n          } else {\n            messages.push({\n              role: \"tool\",\n              tool_call_id: toolResponse.toolCallId,\n              content: JSON.stringify(toolResponse.result)\n            });\n          }\n        }\n        break;\n      }\n      default: {\n        const _exhaustiveCheck = role;\n        throw new Error(`Unsupported role: ${_exhaustiveCheck}`);\n      }\n    }\n  }\n  return { messages, warnings };\n}\n\n// src/map-openai-chat-logprobs.ts\nfunction mapOpenAIChatLogProbsOutput(logprobs) {\n  var _a, _b;\n  return (_b = (_a = logprobs == null ? void 0 : logprobs.content) == null ? void 0 : _a.map(({ token, logprob, top_logprobs }) => ({\n    token,\n    logprob,\n    topLogprobs: top_logprobs ? top_logprobs.map(({ token: token2, logprob: logprob2 }) => ({\n      token: token2,\n      logprob: logprob2\n    })) : []\n  }))) != null ? _b : void 0;\n}\n\n// src/map-openai-finish-reason.ts\nfunction mapOpenAIFinishReason(finishReason) {\n  switch (finishReason) {\n    case \"stop\":\n      return \"stop\";\n    case \"length\":\n      return \"length\";\n    case \"content_filter\":\n      return \"content-filter\";\n    case \"function_call\":\n    case \"tool_calls\":\n      return \"tool-calls\";\n    default:\n      return \"unknown\";\n  }\n}\n\n// src/openai-error.ts\n\n\nvar openaiErrorDataSchema = zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n  error: zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n    message: zod__WEBPACK_IMPORTED_MODULE_2__.z.string(),\n    // The additional information below is handled loosely to support\n    // OpenAI-compatible providers that have slightly different error\n    // responses:\n    type: zod__WEBPACK_IMPORTED_MODULE_2__.z.string().nullish(),\n    param: zod__WEBPACK_IMPORTED_MODULE_2__.z.any().nullish(),\n    code: zod__WEBPACK_IMPORTED_MODULE_2__.z.union([zod__WEBPACK_IMPORTED_MODULE_2__.z.string(), zod__WEBPACK_IMPORTED_MODULE_2__.z.number()]).nullish()\n  })\n});\nvar openaiFailedResponseHandler = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.createJsonErrorResponseHandler)({\n  errorSchema: openaiErrorDataSchema,\n  errorToMessage: (data) => data.error.message\n});\n\n// src/get-response-metadata.ts\nfunction getResponseMetadata({\n  id,\n  model,\n  created\n}) {\n  return {\n    id: id != null ? id : void 0,\n    modelId: model != null ? model : void 0,\n    timestamp: created != null ? new Date(created * 1e3) : void 0\n  };\n}\n\n// src/openai-prepare-tools.ts\n\nfunction prepareTools({\n  mode,\n  useLegacyFunctionCalling = false,\n  structuredOutputs\n}) {\n  var _a;\n  const tools = ((_a = mode.tools) == null ? void 0 : _a.length) ? mode.tools : void 0;\n  const toolWarnings = [];\n  if (tools == null) {\n    return { tools: void 0, tool_choice: void 0, toolWarnings };\n  }\n  const toolChoice = mode.toolChoice;\n  if (useLegacyFunctionCalling) {\n    const openaiFunctions = [];\n    for (const tool of tools) {\n      if (tool.type === \"provider-defined\") {\n        toolWarnings.push({ type: \"unsupported-tool\", tool });\n      } else {\n        openaiFunctions.push({\n          name: tool.name,\n          description: tool.description,\n          parameters: tool.parameters\n        });\n      }\n    }\n    if (toolChoice == null) {\n      return {\n        functions: openaiFunctions,\n        function_call: void 0,\n        toolWarnings\n      };\n    }\n    const type2 = toolChoice.type;\n    switch (type2) {\n      case \"auto\":\n      case \"none\":\n      case void 0:\n        return {\n          functions: openaiFunctions,\n          function_call: void 0,\n          toolWarnings\n        };\n      case \"required\":\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.UnsupportedFunctionalityError({\n          functionality: \"useLegacyFunctionCalling and toolChoice: required\"\n        });\n      default:\n        return {\n          functions: openaiFunctions,\n          function_call: { name: toolChoice.toolName },\n          toolWarnings\n        };\n    }\n  }\n  const openaiTools2 = [];\n  for (const tool of tools) {\n    if (tool.type === \"provider-defined\") {\n      toolWarnings.push({ type: \"unsupported-tool\", tool });\n    } else {\n      openaiTools2.push({\n        type: \"function\",\n        function: {\n          name: tool.name,\n          description: tool.description,\n          parameters: tool.parameters,\n          strict: structuredOutputs ? true : void 0\n        }\n      });\n    }\n  }\n  if (toolChoice == null) {\n    return { tools: openaiTools2, tool_choice: void 0, toolWarnings };\n  }\n  const type = toolChoice.type;\n  switch (type) {\n    case \"auto\":\n    case \"none\":\n    case \"required\":\n      return { tools: openaiTools2, tool_choice: type, toolWarnings };\n    case \"tool\":\n      return {\n        tools: openaiTools2,\n        tool_choice: {\n          type: \"function\",\n          function: {\n            name: toolChoice.toolName\n          }\n        },\n        toolWarnings\n      };\n    default: {\n      const _exhaustiveCheck = type;\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.UnsupportedFunctionalityError({\n        functionality: `Unsupported tool choice type: ${_exhaustiveCheck}`\n      });\n    }\n  }\n}\n\n// src/openai-chat-language-model.ts\nvar OpenAIChatLanguageModel = class {\n  constructor(modelId, settings, config) {\n    this.specificationVersion = \"v1\";\n    this.modelId = modelId;\n    this.settings = settings;\n    this.config = config;\n  }\n  get supportsStructuredOutputs() {\n    var _a;\n    return (_a = this.settings.structuredOutputs) != null ? _a : isReasoningModel(this.modelId);\n  }\n  get defaultObjectGenerationMode() {\n    if (isAudioModel(this.modelId)) {\n      return \"tool\";\n    }\n    return this.supportsStructuredOutputs ? \"json\" : \"tool\";\n  }\n  get provider() {\n    return this.config.provider;\n  }\n  get supportsImageUrls() {\n    return !this.settings.downloadImages;\n  }\n  getArgs({\n    mode,\n    prompt,\n    maxTokens,\n    temperature,\n    topP,\n    topK,\n    frequencyPenalty,\n    presencePenalty,\n    stopSequences,\n    responseFormat,\n    seed,\n    providerMetadata\n  }) {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n    const type = mode.type;\n    const warnings = [];\n    if (topK != null) {\n      warnings.push({\n        type: \"unsupported-setting\",\n        setting: \"topK\"\n      });\n    }\n    if ((responseFormat == null ? void 0 : responseFormat.type) === \"json\" && responseFormat.schema != null && !this.supportsStructuredOutputs) {\n      warnings.push({\n        type: \"unsupported-setting\",\n        setting: \"responseFormat\",\n        details: \"JSON response format schema is only supported with structuredOutputs\"\n      });\n    }\n    const useLegacyFunctionCalling = this.settings.useLegacyFunctionCalling;\n    if (useLegacyFunctionCalling && this.settings.parallelToolCalls === true) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.UnsupportedFunctionalityError({\n        functionality: \"useLegacyFunctionCalling with parallelToolCalls\"\n      });\n    }\n    if (useLegacyFunctionCalling && this.supportsStructuredOutputs) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.UnsupportedFunctionalityError({\n        functionality: \"structuredOutputs with useLegacyFunctionCalling\"\n      });\n    }\n    const { messages, warnings: messageWarnings } = convertToOpenAIChatMessages(\n      {\n        prompt,\n        useLegacyFunctionCalling,\n        systemMessageMode: getSystemMessageMode(this.modelId)\n      }\n    );\n    warnings.push(...messageWarnings);\n    const baseArgs = {\n      // model id:\n      model: this.modelId,\n      // model specific settings:\n      logit_bias: this.settings.logitBias,\n      logprobs: this.settings.logprobs === true || typeof this.settings.logprobs === \"number\" ? true : void 0,\n      top_logprobs: typeof this.settings.logprobs === \"number\" ? this.settings.logprobs : typeof this.settings.logprobs === \"boolean\" ? this.settings.logprobs ? 0 : void 0 : void 0,\n      user: this.settings.user,\n      parallel_tool_calls: this.settings.parallelToolCalls,\n      // standardized settings:\n      max_tokens: maxTokens,\n      temperature,\n      top_p: topP,\n      frequency_penalty: frequencyPenalty,\n      presence_penalty: presencePenalty,\n      response_format: (responseFormat == null ? void 0 : responseFormat.type) === \"json\" ? this.supportsStructuredOutputs && responseFormat.schema != null ? {\n        type: \"json_schema\",\n        json_schema: {\n          schema: responseFormat.schema,\n          strict: true,\n          name: (_a = responseFormat.name) != null ? _a : \"response\",\n          description: responseFormat.description\n        }\n      } : { type: \"json_object\" } : void 0,\n      stop: stopSequences,\n      seed,\n      // openai specific settings:\n      // TODO remove in next major version; we auto-map maxTokens now\n      max_completion_tokens: (_b = providerMetadata == null ? void 0 : providerMetadata.openai) == null ? void 0 : _b.maxCompletionTokens,\n      store: (_c = providerMetadata == null ? void 0 : providerMetadata.openai) == null ? void 0 : _c.store,\n      metadata: (_d = providerMetadata == null ? void 0 : providerMetadata.openai) == null ? void 0 : _d.metadata,\n      prediction: (_e = providerMetadata == null ? void 0 : providerMetadata.openai) == null ? void 0 : _e.prediction,\n      reasoning_effort: (_g = (_f = providerMetadata == null ? void 0 : providerMetadata.openai) == null ? void 0 : _f.reasoningEffort) != null ? _g : this.settings.reasoningEffort,\n      // messages:\n      messages\n    };\n    if (isReasoningModel(this.modelId)) {\n      if (baseArgs.temperature != null) {\n        baseArgs.temperature = void 0;\n        warnings.push({\n          type: \"unsupported-setting\",\n          setting: \"temperature\",\n          details: \"temperature is not supported for reasoning models\"\n        });\n      }\n      if (baseArgs.top_p != null) {\n        baseArgs.top_p = void 0;\n        warnings.push({\n          type: \"unsupported-setting\",\n          setting: \"topP\",\n          details: \"topP is not supported for reasoning models\"\n        });\n      }\n      if (baseArgs.frequency_penalty != null) {\n        baseArgs.frequency_penalty = void 0;\n        warnings.push({\n          type: \"unsupported-setting\",\n          setting: \"frequencyPenalty\",\n          details: \"frequencyPenalty is not supported for reasoning models\"\n        });\n      }\n      if (baseArgs.presence_penalty != null) {\n        baseArgs.presence_penalty = void 0;\n        warnings.push({\n          type: \"unsupported-setting\",\n          setting: \"presencePenalty\",\n          details: \"presencePenalty is not supported for reasoning models\"\n        });\n      }\n      if (baseArgs.logit_bias != null) {\n        baseArgs.logit_bias = void 0;\n        warnings.push({\n          type: \"other\",\n          message: \"logitBias is not supported for reasoning models\"\n        });\n      }\n      if (baseArgs.logprobs != null) {\n        baseArgs.logprobs = void 0;\n        warnings.push({\n          type: \"other\",\n          message: \"logprobs is not supported for reasoning models\"\n        });\n      }\n      if (baseArgs.top_logprobs != null) {\n        baseArgs.top_logprobs = void 0;\n        warnings.push({\n          type: \"other\",\n          message: \"topLogprobs is not supported for reasoning models\"\n        });\n      }\n      if (baseArgs.max_tokens != null) {\n        if (baseArgs.max_completion_tokens == null) {\n          baseArgs.max_completion_tokens = baseArgs.max_tokens;\n        }\n        baseArgs.max_tokens = void 0;\n      }\n    } else if (this.modelId.startsWith(\"gpt-4o-search-preview\") || this.modelId.startsWith(\"gpt-4o-mini-search-preview\")) {\n      if (baseArgs.temperature != null) {\n        baseArgs.temperature = void 0;\n        warnings.push({\n          type: \"unsupported-setting\",\n          setting: \"temperature\",\n          details: \"temperature is not supported for the search preview models and has been removed.\"\n        });\n      }\n    }\n    switch (type) {\n      case \"regular\": {\n        const { tools, tool_choice, functions, function_call, toolWarnings } = prepareTools({\n          mode,\n          useLegacyFunctionCalling,\n          structuredOutputs: this.supportsStructuredOutputs\n        });\n        return {\n          args: {\n            ...baseArgs,\n            tools,\n            tool_choice,\n            functions,\n            function_call\n          },\n          warnings: [...warnings, ...toolWarnings]\n        };\n      }\n      case \"object-json\": {\n        return {\n          args: {\n            ...baseArgs,\n            response_format: this.supportsStructuredOutputs && mode.schema != null ? {\n              type: \"json_schema\",\n              json_schema: {\n                schema: mode.schema,\n                strict: true,\n                name: (_h = mode.name) != null ? _h : \"response\",\n                description: mode.description\n              }\n            } : { type: \"json_object\" }\n          },\n          warnings\n        };\n      }\n      case \"object-tool\": {\n        return {\n          args: useLegacyFunctionCalling ? {\n            ...baseArgs,\n            function_call: {\n              name: mode.tool.name\n            },\n            functions: [\n              {\n                name: mode.tool.name,\n                description: mode.tool.description,\n                parameters: mode.tool.parameters\n              }\n            ]\n          } : {\n            ...baseArgs,\n            tool_choice: {\n              type: \"function\",\n              function: { name: mode.tool.name }\n            },\n            tools: [\n              {\n                type: \"function\",\n                function: {\n                  name: mode.tool.name,\n                  description: mode.tool.description,\n                  parameters: mode.tool.parameters,\n                  strict: this.supportsStructuredOutputs ? true : void 0\n                }\n              }\n            ]\n          },\n          warnings\n        };\n      }\n      default: {\n        const _exhaustiveCheck = type;\n        throw new Error(`Unsupported type: ${_exhaustiveCheck}`);\n      }\n    }\n  }\n  async doGenerate(options) {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n    const { args: body, warnings } = this.getArgs(options);\n    const {\n      responseHeaders,\n      value: response,\n      rawValue: rawResponse\n    } = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.postJsonToApi)({\n      url: this.config.url({\n        path: \"/chat/completions\",\n        modelId: this.modelId\n      }),\n      headers: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.combineHeaders)(this.config.headers(), options.headers),\n      body,\n      failedResponseHandler: openaiFailedResponseHandler,\n      successfulResponseHandler: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.createJsonResponseHandler)(\n        openaiChatResponseSchema\n      ),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch\n    });\n    const { messages: rawPrompt, ...rawSettings } = body;\n    const choice = response.choices[0];\n    const completionTokenDetails = (_a = response.usage) == null ? void 0 : _a.completion_tokens_details;\n    const promptTokenDetails = (_b = response.usage) == null ? void 0 : _b.prompt_tokens_details;\n    const providerMetadata = { openai: {} };\n    if ((completionTokenDetails == null ? void 0 : completionTokenDetails.reasoning_tokens) != null) {\n      providerMetadata.openai.reasoningTokens = completionTokenDetails == null ? void 0 : completionTokenDetails.reasoning_tokens;\n    }\n    if ((completionTokenDetails == null ? void 0 : completionTokenDetails.accepted_prediction_tokens) != null) {\n      providerMetadata.openai.acceptedPredictionTokens = completionTokenDetails == null ? void 0 : completionTokenDetails.accepted_prediction_tokens;\n    }\n    if ((completionTokenDetails == null ? void 0 : completionTokenDetails.rejected_prediction_tokens) != null) {\n      providerMetadata.openai.rejectedPredictionTokens = completionTokenDetails == null ? void 0 : completionTokenDetails.rejected_prediction_tokens;\n    }\n    if ((promptTokenDetails == null ? void 0 : promptTokenDetails.cached_tokens) != null) {\n      providerMetadata.openai.cachedPromptTokens = promptTokenDetails == null ? void 0 : promptTokenDetails.cached_tokens;\n    }\n    return {\n      text: (_c = choice.message.content) != null ? _c : void 0,\n      toolCalls: this.settings.useLegacyFunctionCalling && choice.message.function_call ? [\n        {\n          toolCallType: \"function\",\n          toolCallId: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.generateId)(),\n          toolName: choice.message.function_call.name,\n          args: choice.message.function_call.arguments\n        }\n      ] : (_d = choice.message.tool_calls) == null ? void 0 : _d.map((toolCall) => {\n        var _a2;\n        return {\n          toolCallType: \"function\",\n          toolCallId: (_a2 = toolCall.id) != null ? _a2 : (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.generateId)(),\n          toolName: toolCall.function.name,\n          args: toolCall.function.arguments\n        };\n      }),\n      finishReason: mapOpenAIFinishReason(choice.finish_reason),\n      usage: {\n        promptTokens: (_f = (_e = response.usage) == null ? void 0 : _e.prompt_tokens) != null ? _f : NaN,\n        completionTokens: (_h = (_g = response.usage) == null ? void 0 : _g.completion_tokens) != null ? _h : NaN\n      },\n      rawCall: { rawPrompt, rawSettings },\n      rawResponse: { headers: responseHeaders, body: rawResponse },\n      request: { body: JSON.stringify(body) },\n      response: getResponseMetadata(response),\n      warnings,\n      logprobs: mapOpenAIChatLogProbsOutput(choice.logprobs),\n      providerMetadata\n    };\n  }\n  async doStream(options) {\n    if (this.settings.simulateStreaming) {\n      const result = await this.doGenerate(options);\n      const simulatedStream = new ReadableStream({\n        start(controller) {\n          controller.enqueue({ type: \"response-metadata\", ...result.response });\n          if (result.text) {\n            controller.enqueue({\n              type: \"text-delta\",\n              textDelta: result.text\n            });\n          }\n          if (result.toolCalls) {\n            for (const toolCall of result.toolCalls) {\n              controller.enqueue({\n                type: \"tool-call-delta\",\n                toolCallType: \"function\",\n                toolCallId: toolCall.toolCallId,\n                toolName: toolCall.toolName,\n                argsTextDelta: toolCall.args\n              });\n              controller.enqueue({\n                type: \"tool-call\",\n                ...toolCall\n              });\n            }\n          }\n          controller.enqueue({\n            type: \"finish\",\n            finishReason: result.finishReason,\n            usage: result.usage,\n            logprobs: result.logprobs,\n            providerMetadata: result.providerMetadata\n          });\n          controller.close();\n        }\n      });\n      return {\n        stream: simulatedStream,\n        rawCall: result.rawCall,\n        rawResponse: result.rawResponse,\n        warnings: result.warnings\n      };\n    }\n    const { args, warnings } = this.getArgs(options);\n    const body = {\n      ...args,\n      stream: true,\n      // only include stream_options when in strict compatibility mode:\n      stream_options: this.config.compatibility === \"strict\" ? { include_usage: true } : void 0\n    };\n    const { responseHeaders, value: response } = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.postJsonToApi)({\n      url: this.config.url({\n        path: \"/chat/completions\",\n        modelId: this.modelId\n      }),\n      headers: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.combineHeaders)(this.config.headers(), options.headers),\n      body,\n      failedResponseHandler: openaiFailedResponseHandler,\n      successfulResponseHandler: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.createEventSourceResponseHandler)(\n        openaiChatChunkSchema\n      ),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch\n    });\n    const { messages: rawPrompt, ...rawSettings } = args;\n    const toolCalls = [];\n    let finishReason = \"unknown\";\n    let usage = {\n      promptTokens: void 0,\n      completionTokens: void 0\n    };\n    let logprobs;\n    let isFirstChunk = true;\n    const { useLegacyFunctionCalling } = this.settings;\n    const providerMetadata = { openai: {} };\n    return {\n      stream: response.pipeThrough(\n        new TransformStream({\n          transform(chunk, controller) {\n            var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;\n            if (!chunk.success) {\n              finishReason = \"error\";\n              controller.enqueue({ type: \"error\", error: chunk.error });\n              return;\n            }\n            const value = chunk.value;\n            if (\"error\" in value) {\n              finishReason = \"error\";\n              controller.enqueue({ type: \"error\", error: value.error });\n              return;\n            }\n            if (isFirstChunk) {\n              isFirstChunk = false;\n              controller.enqueue({\n                type: \"response-metadata\",\n                ...getResponseMetadata(value)\n              });\n            }\n            if (value.usage != null) {\n              const {\n                prompt_tokens,\n                completion_tokens,\n                prompt_tokens_details,\n                completion_tokens_details\n              } = value.usage;\n              usage = {\n                promptTokens: prompt_tokens != null ? prompt_tokens : void 0,\n                completionTokens: completion_tokens != null ? completion_tokens : void 0\n              };\n              if ((completion_tokens_details == null ? void 0 : completion_tokens_details.reasoning_tokens) != null) {\n                providerMetadata.openai.reasoningTokens = completion_tokens_details == null ? void 0 : completion_tokens_details.reasoning_tokens;\n              }\n              if ((completion_tokens_details == null ? void 0 : completion_tokens_details.accepted_prediction_tokens) != null) {\n                providerMetadata.openai.acceptedPredictionTokens = completion_tokens_details == null ? void 0 : completion_tokens_details.accepted_prediction_tokens;\n              }\n              if ((completion_tokens_details == null ? void 0 : completion_tokens_details.rejected_prediction_tokens) != null) {\n                providerMetadata.openai.rejectedPredictionTokens = completion_tokens_details == null ? void 0 : completion_tokens_details.rejected_prediction_tokens;\n              }\n              if ((prompt_tokens_details == null ? void 0 : prompt_tokens_details.cached_tokens) != null) {\n                providerMetadata.openai.cachedPromptTokens = prompt_tokens_details == null ? void 0 : prompt_tokens_details.cached_tokens;\n              }\n            }\n            const choice = value.choices[0];\n            if ((choice == null ? void 0 : choice.finish_reason) != null) {\n              finishReason = mapOpenAIFinishReason(choice.finish_reason);\n            }\n            if ((choice == null ? void 0 : choice.delta) == null) {\n              return;\n            }\n            const delta = choice.delta;\n            if (delta.content != null) {\n              controller.enqueue({\n                type: \"text-delta\",\n                textDelta: delta.content\n              });\n            }\n            const mappedLogprobs = mapOpenAIChatLogProbsOutput(\n              choice == null ? void 0 : choice.logprobs\n            );\n            if (mappedLogprobs == null ? void 0 : mappedLogprobs.length) {\n              if (logprobs === void 0) logprobs = [];\n              logprobs.push(...mappedLogprobs);\n            }\n            const mappedToolCalls = useLegacyFunctionCalling && delta.function_call != null ? [\n              {\n                type: \"function\",\n                id: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.generateId)(),\n                function: delta.function_call,\n                index: 0\n              }\n            ] : delta.tool_calls;\n            if (mappedToolCalls != null) {\n              for (const toolCallDelta of mappedToolCalls) {\n                const index = toolCallDelta.index;\n                if (toolCalls[index] == null) {\n                  if (toolCallDelta.type !== \"function\") {\n                    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidResponseDataError({\n                      data: toolCallDelta,\n                      message: `Expected 'function' type.`\n                    });\n                  }\n                  if (toolCallDelta.id == null) {\n                    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidResponseDataError({\n                      data: toolCallDelta,\n                      message: `Expected 'id' to be a string.`\n                    });\n                  }\n                  if (((_a = toolCallDelta.function) == null ? void 0 : _a.name) == null) {\n                    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidResponseDataError({\n                      data: toolCallDelta,\n                      message: `Expected 'function.name' to be a string.`\n                    });\n                  }\n                  toolCalls[index] = {\n                    id: toolCallDelta.id,\n                    type: \"function\",\n                    function: {\n                      name: toolCallDelta.function.name,\n                      arguments: (_b = toolCallDelta.function.arguments) != null ? _b : \"\"\n                    },\n                    hasFinished: false\n                  };\n                  const toolCall2 = toolCalls[index];\n                  if (((_c = toolCall2.function) == null ? void 0 : _c.name) != null && ((_d = toolCall2.function) == null ? void 0 : _d.arguments) != null) {\n                    if (toolCall2.function.arguments.length > 0) {\n                      controller.enqueue({\n                        type: \"tool-call-delta\",\n                        toolCallType: \"function\",\n                        toolCallId: toolCall2.id,\n                        toolName: toolCall2.function.name,\n                        argsTextDelta: toolCall2.function.arguments\n                      });\n                    }\n                    if ((0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.isParsableJson)(toolCall2.function.arguments)) {\n                      controller.enqueue({\n                        type: \"tool-call\",\n                        toolCallType: \"function\",\n                        toolCallId: (_e = toolCall2.id) != null ? _e : (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.generateId)(),\n                        toolName: toolCall2.function.name,\n                        args: toolCall2.function.arguments\n                      });\n                      toolCall2.hasFinished = true;\n                    }\n                  }\n                  continue;\n                }\n                const toolCall = toolCalls[index];\n                if (toolCall.hasFinished) {\n                  continue;\n                }\n                if (((_f = toolCallDelta.function) == null ? void 0 : _f.arguments) != null) {\n                  toolCall.function.arguments += (_h = (_g = toolCallDelta.function) == null ? void 0 : _g.arguments) != null ? _h : \"\";\n                }\n                controller.enqueue({\n                  type: \"tool-call-delta\",\n                  toolCallType: \"function\",\n                  toolCallId: toolCall.id,\n                  toolName: toolCall.function.name,\n                  argsTextDelta: (_i = toolCallDelta.function.arguments) != null ? _i : \"\"\n                });\n                if (((_j = toolCall.function) == null ? void 0 : _j.name) != null && ((_k = toolCall.function) == null ? void 0 : _k.arguments) != null && (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.isParsableJson)(toolCall.function.arguments)) {\n                  controller.enqueue({\n                    type: \"tool-call\",\n                    toolCallType: \"function\",\n                    toolCallId: (_l = toolCall.id) != null ? _l : (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.generateId)(),\n                    toolName: toolCall.function.name,\n                    args: toolCall.function.arguments\n                  });\n                  toolCall.hasFinished = true;\n                }\n              }\n            }\n          },\n          flush(controller) {\n            var _a, _b;\n            controller.enqueue({\n              type: \"finish\",\n              finishReason,\n              logprobs,\n              usage: {\n                promptTokens: (_a = usage.promptTokens) != null ? _a : NaN,\n                completionTokens: (_b = usage.completionTokens) != null ? _b : NaN\n              },\n              ...providerMetadata != null ? { providerMetadata } : {}\n            });\n          }\n        })\n      ),\n      rawCall: { rawPrompt, rawSettings },\n      rawResponse: { headers: responseHeaders },\n      request: { body: JSON.stringify(body) },\n      warnings\n    };\n  }\n};\nvar openaiTokenUsageSchema = zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n  prompt_tokens: zod__WEBPACK_IMPORTED_MODULE_2__.z.number().nullish(),\n  completion_tokens: zod__WEBPACK_IMPORTED_MODULE_2__.z.number().nullish(),\n  prompt_tokens_details: zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n    cached_tokens: zod__WEBPACK_IMPORTED_MODULE_2__.z.number().nullish()\n  }).nullish(),\n  completion_tokens_details: zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n    reasoning_tokens: zod__WEBPACK_IMPORTED_MODULE_2__.z.number().nullish(),\n    accepted_prediction_tokens: zod__WEBPACK_IMPORTED_MODULE_2__.z.number().nullish(),\n    rejected_prediction_tokens: zod__WEBPACK_IMPORTED_MODULE_2__.z.number().nullish()\n  }).nullish()\n}).nullish();\nvar openaiChatResponseSchema = zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n  id: zod__WEBPACK_IMPORTED_MODULE_2__.z.string().nullish(),\n  created: zod__WEBPACK_IMPORTED_MODULE_2__.z.number().nullish(),\n  model: zod__WEBPACK_IMPORTED_MODULE_2__.z.string().nullish(),\n  choices: zod__WEBPACK_IMPORTED_MODULE_2__.z.array(\n    zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n      message: zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n        role: zod__WEBPACK_IMPORTED_MODULE_2__.z.literal(\"assistant\").nullish(),\n        content: zod__WEBPACK_IMPORTED_MODULE_2__.z.string().nullish(),\n        function_call: zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n          arguments: zod__WEBPACK_IMPORTED_MODULE_2__.z.string(),\n          name: zod__WEBPACK_IMPORTED_MODULE_2__.z.string()\n        }).nullish(),\n        tool_calls: zod__WEBPACK_IMPORTED_MODULE_2__.z.array(\n          zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n            id: zod__WEBPACK_IMPORTED_MODULE_2__.z.string().nullish(),\n            type: zod__WEBPACK_IMPORTED_MODULE_2__.z.literal(\"function\"),\n            function: zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n              name: zod__WEBPACK_IMPORTED_MODULE_2__.z.string(),\n              arguments: zod__WEBPACK_IMPORTED_MODULE_2__.z.string()\n            })\n          })\n        ).nullish()\n      }),\n      index: zod__WEBPACK_IMPORTED_MODULE_2__.z.number(),\n      logprobs: zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n        content: zod__WEBPACK_IMPORTED_MODULE_2__.z.array(\n          zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n            token: zod__WEBPACK_IMPORTED_MODULE_2__.z.string(),\n            logprob: zod__WEBPACK_IMPORTED_MODULE_2__.z.number(),\n            top_logprobs: zod__WEBPACK_IMPORTED_MODULE_2__.z.array(\n              zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n                token: zod__WEBPACK_IMPORTED_MODULE_2__.z.string(),\n                logprob: zod__WEBPACK_IMPORTED_MODULE_2__.z.number()\n              })\n            )\n          })\n        ).nullable()\n      }).nullish(),\n      finish_reason: zod__WEBPACK_IMPORTED_MODULE_2__.z.string().nullish()\n    })\n  ),\n  usage: openaiTokenUsageSchema\n});\nvar openaiChatChunkSchema = zod__WEBPACK_IMPORTED_MODULE_2__.z.union([\n  zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n    id: zod__WEBPACK_IMPORTED_MODULE_2__.z.string().nullish(),\n    created: zod__WEBPACK_IMPORTED_MODULE_2__.z.number().nullish(),\n    model: zod__WEBPACK_IMPORTED_MODULE_2__.z.string().nullish(),\n    choices: zod__WEBPACK_IMPORTED_MODULE_2__.z.array(\n      zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n        delta: zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n          role: zod__WEBPACK_IMPORTED_MODULE_2__.z.enum([\"assistant\"]).nullish(),\n          content: zod__WEBPACK_IMPORTED_MODULE_2__.z.string().nullish(),\n          function_call: zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n            name: zod__WEBPACK_IMPORTED_MODULE_2__.z.string().optional(),\n            arguments: zod__WEBPACK_IMPORTED_MODULE_2__.z.string().optional()\n          }).nullish(),\n          tool_calls: zod__WEBPACK_IMPORTED_MODULE_2__.z.array(\n            zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n              index: zod__WEBPACK_IMPORTED_MODULE_2__.z.number(),\n              id: zod__WEBPACK_IMPORTED_MODULE_2__.z.string().nullish(),\n              type: zod__WEBPACK_IMPORTED_MODULE_2__.z.literal(\"function\").optional(),\n              function: zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n                name: zod__WEBPACK_IMPORTED_MODULE_2__.z.string().nullish(),\n                arguments: zod__WEBPACK_IMPORTED_MODULE_2__.z.string().nullish()\n              })\n            })\n          ).nullish()\n        }).nullish(),\n        logprobs: zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n          content: zod__WEBPACK_IMPORTED_MODULE_2__.z.array(\n            zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n              token: zod__WEBPACK_IMPORTED_MODULE_2__.z.string(),\n              logprob: zod__WEBPACK_IMPORTED_MODULE_2__.z.number(),\n              top_logprobs: zod__WEBPACK_IMPORTED_MODULE_2__.z.array(\n                zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n                  token: zod__WEBPACK_IMPORTED_MODULE_2__.z.string(),\n                  logprob: zod__WEBPACK_IMPORTED_MODULE_2__.z.number()\n                })\n              )\n            })\n          ).nullable()\n        }).nullish(),\n        finish_reason: zod__WEBPACK_IMPORTED_MODULE_2__.z.string().nullable().optional(),\n        index: zod__WEBPACK_IMPORTED_MODULE_2__.z.number()\n      })\n    ),\n    usage: openaiTokenUsageSchema\n  }),\n  openaiErrorDataSchema\n]);\nfunction isReasoningModel(modelId) {\n  return modelId.startsWith(\"o\");\n}\nfunction isAudioModel(modelId) {\n  return modelId.startsWith(\"gpt-4o-audio-preview\");\n}\nfunction getSystemMessageMode(modelId) {\n  var _a, _b;\n  if (!isReasoningModel(modelId)) {\n    return \"system\";\n  }\n  return (_b = (_a = reasoningModels[modelId]) == null ? void 0 : _a.systemMessageMode) != null ? _b : \"developer\";\n}\nvar reasoningModels = {\n  \"o1-mini\": {\n    systemMessageMode: \"remove\"\n  },\n  \"o1-mini-2024-09-12\": {\n    systemMessageMode: \"remove\"\n  },\n  \"o1-preview\": {\n    systemMessageMode: \"remove\"\n  },\n  \"o1-preview-2024-09-12\": {\n    systemMessageMode: \"remove\"\n  },\n  o3: {\n    systemMessageMode: \"developer\"\n  },\n  \"o3-2025-04-16\": {\n    systemMessageMode: \"developer\"\n  },\n  \"o3-mini\": {\n    systemMessageMode: \"developer\"\n  },\n  \"o3-mini-2025-01-31\": {\n    systemMessageMode: \"developer\"\n  },\n  \"o4-mini\": {\n    systemMessageMode: \"developer\"\n  },\n  \"o4-mini-2025-04-16\": {\n    systemMessageMode: \"developer\"\n  }\n};\n\n// src/openai-completion-language-model.ts\n\n\n\n\n// src/convert-to-openai-completion-prompt.ts\n\nfunction convertToOpenAICompletionPrompt({\n  prompt,\n  inputFormat,\n  user = \"user\",\n  assistant = \"assistant\"\n}) {\n  if (inputFormat === \"prompt\" && prompt.length === 1 && prompt[0].role === \"user\" && prompt[0].content.length === 1 && prompt[0].content[0].type === \"text\") {\n    return { prompt: prompt[0].content[0].text };\n  }\n  let text = \"\";\n  if (prompt[0].role === \"system\") {\n    text += `${prompt[0].content}\n\n`;\n    prompt = prompt.slice(1);\n  }\n  for (const { role, content } of prompt) {\n    switch (role) {\n      case \"system\": {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidPromptError({\n          message: \"Unexpected system message in prompt: ${content}\",\n          prompt\n        });\n      }\n      case \"user\": {\n        const userMessage = content.map((part) => {\n          switch (part.type) {\n            case \"text\": {\n              return part.text;\n            }\n            case \"image\": {\n              throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.UnsupportedFunctionalityError({\n                functionality: \"images\"\n              });\n            }\n          }\n        }).join(\"\");\n        text += `${user}:\n${userMessage}\n\n`;\n        break;\n      }\n      case \"assistant\": {\n        const assistantMessage = content.map((part) => {\n          switch (part.type) {\n            case \"text\": {\n              return part.text;\n            }\n            case \"tool-call\": {\n              throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.UnsupportedFunctionalityError({\n                functionality: \"tool-call messages\"\n              });\n            }\n          }\n        }).join(\"\");\n        text += `${assistant}:\n${assistantMessage}\n\n`;\n        break;\n      }\n      case \"tool\": {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.UnsupportedFunctionalityError({\n          functionality: \"tool messages\"\n        });\n      }\n      default: {\n        const _exhaustiveCheck = role;\n        throw new Error(`Unsupported role: ${_exhaustiveCheck}`);\n      }\n    }\n  }\n  text += `${assistant}:\n`;\n  return {\n    prompt: text,\n    stopSequences: [`\n${user}:`]\n  };\n}\n\n// src/map-openai-completion-logprobs.ts\nfunction mapOpenAICompletionLogProbs(logprobs) {\n  return logprobs == null ? void 0 : logprobs.tokens.map((token, index) => ({\n    token,\n    logprob: logprobs.token_logprobs[index],\n    topLogprobs: logprobs.top_logprobs ? Object.entries(logprobs.top_logprobs[index]).map(\n      ([token2, logprob]) => ({\n        token: token2,\n        logprob\n      })\n    ) : []\n  }));\n}\n\n// src/openai-completion-language-model.ts\nvar OpenAICompletionLanguageModel = class {\n  constructor(modelId, settings, config) {\n    this.specificationVersion = \"v1\";\n    this.defaultObjectGenerationMode = void 0;\n    this.modelId = modelId;\n    this.settings = settings;\n    this.config = config;\n  }\n  get provider() {\n    return this.config.provider;\n  }\n  getArgs({\n    mode,\n    inputFormat,\n    prompt,\n    maxTokens,\n    temperature,\n    topP,\n    topK,\n    frequencyPenalty,\n    presencePenalty,\n    stopSequences: userStopSequences,\n    responseFormat,\n    seed\n  }) {\n    var _a;\n    const type = mode.type;\n    const warnings = [];\n    if (topK != null) {\n      warnings.push({\n        type: \"unsupported-setting\",\n        setting: \"topK\"\n      });\n    }\n    if (responseFormat != null && responseFormat.type !== \"text\") {\n      warnings.push({\n        type: \"unsupported-setting\",\n        setting: \"responseFormat\",\n        details: \"JSON response format is not supported.\"\n      });\n    }\n    const { prompt: completionPrompt, stopSequences } = convertToOpenAICompletionPrompt({ prompt, inputFormat });\n    const stop = [...stopSequences != null ? stopSequences : [], ...userStopSequences != null ? userStopSequences : []];\n    const baseArgs = {\n      // model id:\n      model: this.modelId,\n      // model specific settings:\n      echo: this.settings.echo,\n      logit_bias: this.settings.logitBias,\n      logprobs: typeof this.settings.logprobs === \"number\" ? this.settings.logprobs : typeof this.settings.logprobs === \"boolean\" ? this.settings.logprobs ? 0 : void 0 : void 0,\n      suffix: this.settings.suffix,\n      user: this.settings.user,\n      // standardized settings:\n      max_tokens: maxTokens,\n      temperature,\n      top_p: topP,\n      frequency_penalty: frequencyPenalty,\n      presence_penalty: presencePenalty,\n      seed,\n      // prompt:\n      prompt: completionPrompt,\n      // stop sequences:\n      stop: stop.length > 0 ? stop : void 0\n    };\n    switch (type) {\n      case \"regular\": {\n        if ((_a = mode.tools) == null ? void 0 : _a.length) {\n          throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.UnsupportedFunctionalityError({\n            functionality: \"tools\"\n          });\n        }\n        if (mode.toolChoice) {\n          throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.UnsupportedFunctionalityError({\n            functionality: \"toolChoice\"\n          });\n        }\n        return { args: baseArgs, warnings };\n      }\n      case \"object-json\": {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.UnsupportedFunctionalityError({\n          functionality: \"object-json mode\"\n        });\n      }\n      case \"object-tool\": {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.UnsupportedFunctionalityError({\n          functionality: \"object-tool mode\"\n        });\n      }\n      default: {\n        const _exhaustiveCheck = type;\n        throw new Error(`Unsupported type: ${_exhaustiveCheck}`);\n      }\n    }\n  }\n  async doGenerate(options) {\n    const { args, warnings } = this.getArgs(options);\n    const {\n      responseHeaders,\n      value: response,\n      rawValue: rawResponse\n    } = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.postJsonToApi)({\n      url: this.config.url({\n        path: \"/completions\",\n        modelId: this.modelId\n      }),\n      headers: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.combineHeaders)(this.config.headers(), options.headers),\n      body: args,\n      failedResponseHandler: openaiFailedResponseHandler,\n      successfulResponseHandler: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.createJsonResponseHandler)(\n        openaiCompletionResponseSchema\n      ),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch\n    });\n    const { prompt: rawPrompt, ...rawSettings } = args;\n    const choice = response.choices[0];\n    return {\n      text: choice.text,\n      usage: {\n        promptTokens: response.usage.prompt_tokens,\n        completionTokens: response.usage.completion_tokens\n      },\n      finishReason: mapOpenAIFinishReason(choice.finish_reason),\n      logprobs: mapOpenAICompletionLogProbs(choice.logprobs),\n      rawCall: { rawPrompt, rawSettings },\n      rawResponse: { headers: responseHeaders, body: rawResponse },\n      response: getResponseMetadata(response),\n      warnings,\n      request: { body: JSON.stringify(args) }\n    };\n  }\n  async doStream(options) {\n    const { args, warnings } = this.getArgs(options);\n    const body = {\n      ...args,\n      stream: true,\n      // only include stream_options when in strict compatibility mode:\n      stream_options: this.config.compatibility === \"strict\" ? { include_usage: true } : void 0\n    };\n    const { responseHeaders, value: response } = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.postJsonToApi)({\n      url: this.config.url({\n        path: \"/completions\",\n        modelId: this.modelId\n      }),\n      headers: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.combineHeaders)(this.config.headers(), options.headers),\n      body,\n      failedResponseHandler: openaiFailedResponseHandler,\n      successfulResponseHandler: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.createEventSourceResponseHandler)(\n        openaiCompletionChunkSchema\n      ),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch\n    });\n    const { prompt: rawPrompt, ...rawSettings } = args;\n    let finishReason = \"unknown\";\n    let usage = {\n      promptTokens: Number.NaN,\n      completionTokens: Number.NaN\n    };\n    let logprobs;\n    let isFirstChunk = true;\n    return {\n      stream: response.pipeThrough(\n        new TransformStream({\n          transform(chunk, controller) {\n            if (!chunk.success) {\n              finishReason = \"error\";\n              controller.enqueue({ type: \"error\", error: chunk.error });\n              return;\n            }\n            const value = chunk.value;\n            if (\"error\" in value) {\n              finishReason = \"error\";\n              controller.enqueue({ type: \"error\", error: value.error });\n              return;\n            }\n            if (isFirstChunk) {\n              isFirstChunk = false;\n              controller.enqueue({\n                type: \"response-metadata\",\n                ...getResponseMetadata(value)\n              });\n            }\n            if (value.usage != null) {\n              usage = {\n                promptTokens: value.usage.prompt_tokens,\n                completionTokens: value.usage.completion_tokens\n              };\n            }\n            const choice = value.choices[0];\n            if ((choice == null ? void 0 : choice.finish_reason) != null) {\n              finishReason = mapOpenAIFinishReason(choice.finish_reason);\n            }\n            if ((choice == null ? void 0 : choice.text) != null) {\n              controller.enqueue({\n                type: \"text-delta\",\n                textDelta: choice.text\n              });\n            }\n            const mappedLogprobs = mapOpenAICompletionLogProbs(\n              choice == null ? void 0 : choice.logprobs\n            );\n            if (mappedLogprobs == null ? void 0 : mappedLogprobs.length) {\n              if (logprobs === void 0) logprobs = [];\n              logprobs.push(...mappedLogprobs);\n            }\n          },\n          flush(controller) {\n            controller.enqueue({\n              type: \"finish\",\n              finishReason,\n              logprobs,\n              usage\n            });\n          }\n        })\n      ),\n      rawCall: { rawPrompt, rawSettings },\n      rawResponse: { headers: responseHeaders },\n      warnings,\n      request: { body: JSON.stringify(body) }\n    };\n  }\n};\nvar openaiCompletionResponseSchema = zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n  id: zod__WEBPACK_IMPORTED_MODULE_2__.z.string().nullish(),\n  created: zod__WEBPACK_IMPORTED_MODULE_2__.z.number().nullish(),\n  model: zod__WEBPACK_IMPORTED_MODULE_2__.z.string().nullish(),\n  choices: zod__WEBPACK_IMPORTED_MODULE_2__.z.array(\n    zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n      text: zod__WEBPACK_IMPORTED_MODULE_2__.z.string(),\n      finish_reason: zod__WEBPACK_IMPORTED_MODULE_2__.z.string(),\n      logprobs: zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n        tokens: zod__WEBPACK_IMPORTED_MODULE_2__.z.array(zod__WEBPACK_IMPORTED_MODULE_2__.z.string()),\n        token_logprobs: zod__WEBPACK_IMPORTED_MODULE_2__.z.array(zod__WEBPACK_IMPORTED_MODULE_2__.z.number()),\n        top_logprobs: zod__WEBPACK_IMPORTED_MODULE_2__.z.array(zod__WEBPACK_IMPORTED_MODULE_2__.z.record(zod__WEBPACK_IMPORTED_MODULE_2__.z.string(), zod__WEBPACK_IMPORTED_MODULE_2__.z.number())).nullable()\n      }).nullish()\n    })\n  ),\n  usage: zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n    prompt_tokens: zod__WEBPACK_IMPORTED_MODULE_2__.z.number(),\n    completion_tokens: zod__WEBPACK_IMPORTED_MODULE_2__.z.number()\n  })\n});\nvar openaiCompletionChunkSchema = zod__WEBPACK_IMPORTED_MODULE_2__.z.union([\n  zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n    id: zod__WEBPACK_IMPORTED_MODULE_2__.z.string().nullish(),\n    created: zod__WEBPACK_IMPORTED_MODULE_2__.z.number().nullish(),\n    model: zod__WEBPACK_IMPORTED_MODULE_2__.z.string().nullish(),\n    choices: zod__WEBPACK_IMPORTED_MODULE_2__.z.array(\n      zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n        text: zod__WEBPACK_IMPORTED_MODULE_2__.z.string(),\n        finish_reason: zod__WEBPACK_IMPORTED_MODULE_2__.z.string().nullish(),\n        index: zod__WEBPACK_IMPORTED_MODULE_2__.z.number(),\n        logprobs: zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n          tokens: zod__WEBPACK_IMPORTED_MODULE_2__.z.array(zod__WEBPACK_IMPORTED_MODULE_2__.z.string()),\n          token_logprobs: zod__WEBPACK_IMPORTED_MODULE_2__.z.array(zod__WEBPACK_IMPORTED_MODULE_2__.z.number()),\n          top_logprobs: zod__WEBPACK_IMPORTED_MODULE_2__.z.array(zod__WEBPACK_IMPORTED_MODULE_2__.z.record(zod__WEBPACK_IMPORTED_MODULE_2__.z.string(), zod__WEBPACK_IMPORTED_MODULE_2__.z.number())).nullable()\n        }).nullish()\n      })\n    ),\n    usage: zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n      prompt_tokens: zod__WEBPACK_IMPORTED_MODULE_2__.z.number(),\n      completion_tokens: zod__WEBPACK_IMPORTED_MODULE_2__.z.number()\n    }).nullish()\n  }),\n  openaiErrorDataSchema\n]);\n\n// src/openai-embedding-model.ts\n\n\n\nvar OpenAIEmbeddingModel = class {\n  constructor(modelId, settings, config) {\n    this.specificationVersion = \"v1\";\n    this.modelId = modelId;\n    this.settings = settings;\n    this.config = config;\n  }\n  get provider() {\n    return this.config.provider;\n  }\n  get maxEmbeddingsPerCall() {\n    var _a;\n    return (_a = this.settings.maxEmbeddingsPerCall) != null ? _a : 2048;\n  }\n  get supportsParallelCalls() {\n    var _a;\n    return (_a = this.settings.supportsParallelCalls) != null ? _a : true;\n  }\n  async doEmbed({\n    values,\n    headers,\n    abortSignal\n  }) {\n    if (values.length > this.maxEmbeddingsPerCall) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.TooManyEmbeddingValuesForCallError({\n        provider: this.provider,\n        modelId: this.modelId,\n        maxEmbeddingsPerCall: this.maxEmbeddingsPerCall,\n        values\n      });\n    }\n    const { responseHeaders, value: response } = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.postJsonToApi)({\n      url: this.config.url({\n        path: \"/embeddings\",\n        modelId: this.modelId\n      }),\n      headers: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.combineHeaders)(this.config.headers(), headers),\n      body: {\n        model: this.modelId,\n        input: values,\n        encoding_format: \"float\",\n        dimensions: this.settings.dimensions,\n        user: this.settings.user\n      },\n      failedResponseHandler: openaiFailedResponseHandler,\n      successfulResponseHandler: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.createJsonResponseHandler)(\n        openaiTextEmbeddingResponseSchema\n      ),\n      abortSignal,\n      fetch: this.config.fetch\n    });\n    return {\n      embeddings: response.data.map((item) => item.embedding),\n      usage: response.usage ? { tokens: response.usage.prompt_tokens } : void 0,\n      rawResponse: { headers: responseHeaders }\n    };\n  }\n};\nvar openaiTextEmbeddingResponseSchema = zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n  data: zod__WEBPACK_IMPORTED_MODULE_2__.z.array(zod__WEBPACK_IMPORTED_MODULE_2__.z.object({ embedding: zod__WEBPACK_IMPORTED_MODULE_2__.z.array(zod__WEBPACK_IMPORTED_MODULE_2__.z.number()) })),\n  usage: zod__WEBPACK_IMPORTED_MODULE_2__.z.object({ prompt_tokens: zod__WEBPACK_IMPORTED_MODULE_2__.z.number() }).nullish()\n});\n\n// src/openai-image-model.ts\n\n\n\n// src/openai-image-settings.ts\nvar modelMaxImagesPerCall = {\n  \"dall-e-3\": 1,\n  \"dall-e-2\": 10,\n  \"gpt-image-1\": 10\n};\nvar hasDefaultResponseFormat = /* @__PURE__ */ new Set([\"gpt-image-1\"]);\n\n// src/openai-image-model.ts\nvar OpenAIImageModel = class {\n  constructor(modelId, settings, config) {\n    this.modelId = modelId;\n    this.settings = settings;\n    this.config = config;\n    this.specificationVersion = \"v1\";\n  }\n  get maxImagesPerCall() {\n    var _a, _b;\n    return (_b = (_a = this.settings.maxImagesPerCall) != null ? _a : modelMaxImagesPerCall[this.modelId]) != null ? _b : 1;\n  }\n  get provider() {\n    return this.config.provider;\n  }\n  async doGenerate({\n    prompt,\n    n,\n    size,\n    aspectRatio,\n    seed,\n    providerOptions,\n    headers,\n    abortSignal\n  }) {\n    var _a, _b, _c, _d;\n    const warnings = [];\n    if (aspectRatio != null) {\n      warnings.push({\n        type: \"unsupported-setting\",\n        setting: \"aspectRatio\",\n        details: \"This model does not support aspect ratio. Use `size` instead.\"\n      });\n    }\n    if (seed != null) {\n      warnings.push({ type: \"unsupported-setting\", setting: \"seed\" });\n    }\n    const currentDate = (_c = (_b = (_a = this.config._internal) == null ? void 0 : _a.currentDate) == null ? void 0 : _b.call(_a)) != null ? _c : /* @__PURE__ */ new Date();\n    const { value: response, responseHeaders } = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.postJsonToApi)({\n      url: this.config.url({\n        path: \"/images/generations\",\n        modelId: this.modelId\n      }),\n      headers: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.combineHeaders)(this.config.headers(), headers),\n      body: {\n        model: this.modelId,\n        prompt,\n        n,\n        size,\n        ...(_d = providerOptions.openai) != null ? _d : {},\n        ...!hasDefaultResponseFormat.has(this.modelId) ? { response_format: \"b64_json\" } : {}\n      },\n      failedResponseHandler: openaiFailedResponseHandler,\n      successfulResponseHandler: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.createJsonResponseHandler)(\n        openaiImageResponseSchema\n      ),\n      abortSignal,\n      fetch: this.config.fetch\n    });\n    return {\n      images: response.data.map((item) => item.b64_json),\n      warnings,\n      response: {\n        timestamp: currentDate,\n        modelId: this.modelId,\n        headers: responseHeaders\n      }\n    };\n  }\n};\nvar openaiImageResponseSchema = zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n  data: zod__WEBPACK_IMPORTED_MODULE_2__.z.array(zod__WEBPACK_IMPORTED_MODULE_2__.z.object({ b64_json: zod__WEBPACK_IMPORTED_MODULE_2__.z.string() }))\n});\n\n// src/openai-transcription-model.ts\n\n\nvar openAIProviderOptionsSchema = zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n  include: zod__WEBPACK_IMPORTED_MODULE_2__.z.array(zod__WEBPACK_IMPORTED_MODULE_2__.z.string()).nullish(),\n  language: zod__WEBPACK_IMPORTED_MODULE_2__.z.string().nullish(),\n  prompt: zod__WEBPACK_IMPORTED_MODULE_2__.z.string().nullish(),\n  temperature: zod__WEBPACK_IMPORTED_MODULE_2__.z.number().min(0).max(1).nullish().default(0),\n  timestampGranularities: zod__WEBPACK_IMPORTED_MODULE_2__.z.array(zod__WEBPACK_IMPORTED_MODULE_2__.z.enum([\"word\", \"segment\"])).nullish().default([\"segment\"])\n});\nvar languageMap = {\n  afrikaans: \"af\",\n  arabic: \"ar\",\n  armenian: \"hy\",\n  azerbaijani: \"az\",\n  belarusian: \"be\",\n  bosnian: \"bs\",\n  bulgarian: \"bg\",\n  catalan: \"ca\",\n  chinese: \"zh\",\n  croatian: \"hr\",\n  czech: \"cs\",\n  danish: \"da\",\n  dutch: \"nl\",\n  english: \"en\",\n  estonian: \"et\",\n  finnish: \"fi\",\n  french: \"fr\",\n  galician: \"gl\",\n  german: \"de\",\n  greek: \"el\",\n  hebrew: \"he\",\n  hindi: \"hi\",\n  hungarian: \"hu\",\n  icelandic: \"is\",\n  indonesian: \"id\",\n  italian: \"it\",\n  japanese: \"ja\",\n  kannada: \"kn\",\n  kazakh: \"kk\",\n  korean: \"ko\",\n  latvian: \"lv\",\n  lithuanian: \"lt\",\n  macedonian: \"mk\",\n  malay: \"ms\",\n  marathi: \"mr\",\n  maori: \"mi\",\n  nepali: \"ne\",\n  norwegian: \"no\",\n  persian: \"fa\",\n  polish: \"pl\",\n  portuguese: \"pt\",\n  romanian: \"ro\",\n  russian: \"ru\",\n  serbian: \"sr\",\n  slovak: \"sk\",\n  slovenian: \"sl\",\n  spanish: \"es\",\n  swahili: \"sw\",\n  swedish: \"sv\",\n  tagalog: \"tl\",\n  tamil: \"ta\",\n  thai: \"th\",\n  turkish: \"tr\",\n  ukrainian: \"uk\",\n  urdu: \"ur\",\n  vietnamese: \"vi\",\n  welsh: \"cy\"\n};\nvar OpenAITranscriptionModel = class {\n  constructor(modelId, config) {\n    this.modelId = modelId;\n    this.config = config;\n    this.specificationVersion = \"v1\";\n  }\n  get provider() {\n    return this.config.provider;\n  }\n  getArgs({\n    audio,\n    mediaType,\n    providerOptions\n  }) {\n    var _a, _b, _c, _d, _e;\n    const warnings = [];\n    const openAIOptions = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.parseProviderOptions)({\n      provider: \"openai\",\n      providerOptions,\n      schema: openAIProviderOptionsSchema\n    });\n    const formData = new FormData();\n    const blob = audio instanceof Uint8Array ? new Blob([audio]) : new Blob([(0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.convertBase64ToUint8Array)(audio)]);\n    formData.append(\"model\", this.modelId);\n    formData.append(\"file\", new File([blob], \"audio\", { type: mediaType }));\n    if (openAIOptions) {\n      const transcriptionModelOptions = {\n        include: (_a = openAIOptions.include) != null ? _a : void 0,\n        language: (_b = openAIOptions.language) != null ? _b : void 0,\n        prompt: (_c = openAIOptions.prompt) != null ? _c : void 0,\n        temperature: (_d = openAIOptions.temperature) != null ? _d : void 0,\n        timestamp_granularities: (_e = openAIOptions.timestampGranularities) != null ? _e : void 0\n      };\n      for (const key in transcriptionModelOptions) {\n        const value = transcriptionModelOptions[key];\n        if (value !== void 0) {\n          formData.append(key, String(value));\n        }\n      }\n    }\n    return {\n      formData,\n      warnings\n    };\n  }\n  async doGenerate(options) {\n    var _a, _b, _c, _d, _e, _f;\n    const currentDate = (_c = (_b = (_a = this.config._internal) == null ? void 0 : _a.currentDate) == null ? void 0 : _b.call(_a)) != null ? _c : /* @__PURE__ */ new Date();\n    const { formData, warnings } = this.getArgs(options);\n    const {\n      value: response,\n      responseHeaders,\n      rawValue: rawResponse\n    } = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.postFormDataToApi)({\n      url: this.config.url({\n        path: \"/audio/transcriptions\",\n        modelId: this.modelId\n      }),\n      headers: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.combineHeaders)(this.config.headers(), options.headers),\n      formData,\n      failedResponseHandler: openaiFailedResponseHandler,\n      successfulResponseHandler: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.createJsonResponseHandler)(\n        openaiTranscriptionResponseSchema\n      ),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch\n    });\n    const language = response.language != null && response.language in languageMap ? languageMap[response.language] : void 0;\n    return {\n      text: response.text,\n      segments: (_e = (_d = response.words) == null ? void 0 : _d.map((word) => ({\n        text: word.word,\n        startSecond: word.start,\n        endSecond: word.end\n      }))) != null ? _e : [],\n      language,\n      durationInSeconds: (_f = response.duration) != null ? _f : void 0,\n      warnings,\n      response: {\n        timestamp: currentDate,\n        modelId: this.modelId,\n        headers: responseHeaders,\n        body: rawResponse\n      }\n    };\n  }\n};\nvar openaiTranscriptionResponseSchema = zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n  text: zod__WEBPACK_IMPORTED_MODULE_2__.z.string(),\n  language: zod__WEBPACK_IMPORTED_MODULE_2__.z.string().nullish(),\n  duration: zod__WEBPACK_IMPORTED_MODULE_2__.z.number().nullish(),\n  words: zod__WEBPACK_IMPORTED_MODULE_2__.z.array(\n    zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n      word: zod__WEBPACK_IMPORTED_MODULE_2__.z.string(),\n      start: zod__WEBPACK_IMPORTED_MODULE_2__.z.number(),\n      end: zod__WEBPACK_IMPORTED_MODULE_2__.z.number()\n    })\n  ).nullish()\n});\n\n// src/responses/openai-responses-language-model.ts\n\n\n\n// src/responses/convert-to-openai-responses-messages.ts\n\n\nfunction convertToOpenAIResponsesMessages({\n  prompt,\n  systemMessageMode\n}) {\n  const messages = [];\n  const warnings = [];\n  for (const { role, content } of prompt) {\n    switch (role) {\n      case \"system\": {\n        switch (systemMessageMode) {\n          case \"system\": {\n            messages.push({ role: \"system\", content });\n            break;\n          }\n          case \"developer\": {\n            messages.push({ role: \"developer\", content });\n            break;\n          }\n          case \"remove\": {\n            warnings.push({\n              type: \"other\",\n              message: \"system messages are removed for this model\"\n            });\n            break;\n          }\n          default: {\n            const _exhaustiveCheck = systemMessageMode;\n            throw new Error(\n              `Unsupported system message mode: ${_exhaustiveCheck}`\n            );\n          }\n        }\n        break;\n      }\n      case \"user\": {\n        messages.push({\n          role: \"user\",\n          content: content.map((part, index) => {\n            var _a, _b, _c, _d;\n            switch (part.type) {\n              case \"text\": {\n                return { type: \"input_text\", text: part.text };\n              }\n              case \"image\": {\n                return {\n                  type: \"input_image\",\n                  image_url: part.image instanceof URL ? part.image.toString() : `data:${(_a = part.mimeType) != null ? _a : \"image/jpeg\"};base64,${(0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.convertUint8ArrayToBase64)(part.image)}`,\n                  // OpenAI specific extension: image detail\n                  detail: (_c = (_b = part.providerMetadata) == null ? void 0 : _b.openai) == null ? void 0 : _c.imageDetail\n                };\n              }\n              case \"file\": {\n                if (part.data instanceof URL) {\n                  throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.UnsupportedFunctionalityError({\n                    functionality: \"File URLs in user messages\"\n                  });\n                }\n                switch (part.mimeType) {\n                  case \"application/pdf\": {\n                    return {\n                      type: \"input_file\",\n                      filename: (_d = part.filename) != null ? _d : `part-${index}.pdf`,\n                      file_data: `data:application/pdf;base64,${part.data}`\n                    };\n                  }\n                  default: {\n                    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.UnsupportedFunctionalityError({\n                      functionality: \"Only PDF files are supported in user messages\"\n                    });\n                  }\n                }\n              }\n            }\n          })\n        });\n        break;\n      }\n      case \"assistant\": {\n        for (const part of content) {\n          switch (part.type) {\n            case \"text\": {\n              messages.push({\n                role: \"assistant\",\n                content: [{ type: \"output_text\", text: part.text }]\n              });\n              break;\n            }\n            case \"tool-call\": {\n              messages.push({\n                type: \"function_call\",\n                call_id: part.toolCallId,\n                name: part.toolName,\n                arguments: JSON.stringify(part.args)\n              });\n              break;\n            }\n          }\n        }\n        break;\n      }\n      case \"tool\": {\n        for (const part of content) {\n          messages.push({\n            type: \"function_call_output\",\n            call_id: part.toolCallId,\n            output: JSON.stringify(part.result)\n          });\n        }\n        break;\n      }\n      default: {\n        const _exhaustiveCheck = role;\n        throw new Error(`Unsupported role: ${_exhaustiveCheck}`);\n      }\n    }\n  }\n  return { messages, warnings };\n}\n\n// src/responses/map-openai-responses-finish-reason.ts\nfunction mapOpenAIResponseFinishReason({\n  finishReason,\n  hasToolCalls\n}) {\n  switch (finishReason) {\n    case void 0:\n    case null:\n      return hasToolCalls ? \"tool-calls\" : \"stop\";\n    case \"max_output_tokens\":\n      return \"length\";\n    case \"content_filter\":\n      return \"content-filter\";\n    default:\n      return hasToolCalls ? \"tool-calls\" : \"unknown\";\n  }\n}\n\n// src/responses/openai-responses-prepare-tools.ts\n\nfunction prepareResponsesTools({\n  mode,\n  strict\n}) {\n  var _a;\n  const tools = ((_a = mode.tools) == null ? void 0 : _a.length) ? mode.tools : void 0;\n  const toolWarnings = [];\n  if (tools == null) {\n    return { tools: void 0, tool_choice: void 0, toolWarnings };\n  }\n  const toolChoice = mode.toolChoice;\n  const openaiTools2 = [];\n  for (const tool of tools) {\n    switch (tool.type) {\n      case \"function\":\n        openaiTools2.push({\n          type: \"function\",\n          name: tool.name,\n          description: tool.description,\n          parameters: tool.parameters,\n          strict: strict ? true : void 0\n        });\n        break;\n      case \"provider-defined\":\n        switch (tool.id) {\n          case \"openai.web_search_preview\":\n            openaiTools2.push({\n              type: \"web_search_preview\",\n              search_context_size: tool.args.searchContextSize,\n              user_location: tool.args.userLocation\n            });\n            break;\n          default:\n            toolWarnings.push({ type: \"unsupported-tool\", tool });\n            break;\n        }\n        break;\n      default:\n        toolWarnings.push({ type: \"unsupported-tool\", tool });\n        break;\n    }\n  }\n  if (toolChoice == null) {\n    return { tools: openaiTools2, tool_choice: void 0, toolWarnings };\n  }\n  const type = toolChoice.type;\n  switch (type) {\n    case \"auto\":\n    case \"none\":\n    case \"required\":\n      return { tools: openaiTools2, tool_choice: type, toolWarnings };\n    case \"tool\": {\n      if (toolChoice.toolName === \"web_search_preview\") {\n        return {\n          tools: openaiTools2,\n          tool_choice: {\n            type: \"web_search_preview\"\n          },\n          toolWarnings\n        };\n      }\n      return {\n        tools: openaiTools2,\n        tool_choice: {\n          type: \"function\",\n          name: toolChoice.toolName\n        },\n        toolWarnings\n      };\n    }\n    default: {\n      const _exhaustiveCheck = type;\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.UnsupportedFunctionalityError({\n        functionality: `Unsupported tool choice type: ${_exhaustiveCheck}`\n      });\n    }\n  }\n}\n\n// src/responses/openai-responses-language-model.ts\nvar OpenAIResponsesLanguageModel = class {\n  constructor(modelId, config) {\n    this.specificationVersion = \"v1\";\n    this.defaultObjectGenerationMode = \"json\";\n    this.supportsStructuredOutputs = true;\n    this.modelId = modelId;\n    this.config = config;\n  }\n  get provider() {\n    return this.config.provider;\n  }\n  getArgs({\n    mode,\n    maxTokens,\n    temperature,\n    stopSequences,\n    topP,\n    topK,\n    presencePenalty,\n    frequencyPenalty,\n    seed,\n    prompt,\n    providerMetadata,\n    responseFormat\n  }) {\n    var _a, _b, _c;\n    const warnings = [];\n    const modelConfig = getResponsesModelConfig(this.modelId);\n    const type = mode.type;\n    if (topK != null) {\n      warnings.push({\n        type: \"unsupported-setting\",\n        setting: \"topK\"\n      });\n    }\n    if (seed != null) {\n      warnings.push({\n        type: \"unsupported-setting\",\n        setting: \"seed\"\n      });\n    }\n    if (presencePenalty != null) {\n      warnings.push({\n        type: \"unsupported-setting\",\n        setting: \"presencePenalty\"\n      });\n    }\n    if (frequencyPenalty != null) {\n      warnings.push({\n        type: \"unsupported-setting\",\n        setting: \"frequencyPenalty\"\n      });\n    }\n    if (stopSequences != null) {\n      warnings.push({\n        type: \"unsupported-setting\",\n        setting: \"stopSequences\"\n      });\n    }\n    const { messages, warnings: messageWarnings } = convertToOpenAIResponsesMessages({\n      prompt,\n      systemMessageMode: modelConfig.systemMessageMode\n    });\n    warnings.push(...messageWarnings);\n    const openaiOptions = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.parseProviderOptions)({\n      provider: \"openai\",\n      providerOptions: providerMetadata,\n      schema: openaiResponsesProviderOptionsSchema\n    });\n    const isStrict = (_a = openaiOptions == null ? void 0 : openaiOptions.strictSchemas) != null ? _a : true;\n    const baseArgs = {\n      model: this.modelId,\n      input: messages,\n      temperature,\n      top_p: topP,\n      max_output_tokens: maxTokens,\n      ...(responseFormat == null ? void 0 : responseFormat.type) === \"json\" && {\n        text: {\n          format: responseFormat.schema != null ? {\n            type: \"json_schema\",\n            strict: isStrict,\n            name: (_b = responseFormat.name) != null ? _b : \"response\",\n            description: responseFormat.description,\n            schema: responseFormat.schema\n          } : { type: \"json_object\" }\n        }\n      },\n      // provider options:\n      metadata: openaiOptions == null ? void 0 : openaiOptions.metadata,\n      parallel_tool_calls: openaiOptions == null ? void 0 : openaiOptions.parallelToolCalls,\n      previous_response_id: openaiOptions == null ? void 0 : openaiOptions.previousResponseId,\n      store: openaiOptions == null ? void 0 : openaiOptions.store,\n      user: openaiOptions == null ? void 0 : openaiOptions.user,\n      instructions: openaiOptions == null ? void 0 : openaiOptions.instructions,\n      // model-specific settings:\n      ...modelConfig.isReasoningModel && ((openaiOptions == null ? void 0 : openaiOptions.reasoningEffort) != null || (openaiOptions == null ? void 0 : openaiOptions.reasoningSummary) != null) && {\n        reasoning: {\n          ...(openaiOptions == null ? void 0 : openaiOptions.reasoningEffort) != null && {\n            effort: openaiOptions.reasoningEffort\n          },\n          ...(openaiOptions == null ? void 0 : openaiOptions.reasoningSummary) != null && {\n            summary: openaiOptions.reasoningSummary\n          }\n        }\n      },\n      ...modelConfig.requiredAutoTruncation && {\n        truncation: \"auto\"\n      }\n    };\n    if (modelConfig.isReasoningModel) {\n      if (baseArgs.temperature != null) {\n        baseArgs.temperature = void 0;\n        warnings.push({\n          type: \"unsupported-setting\",\n          setting: \"temperature\",\n          details: \"temperature is not supported for reasoning models\"\n        });\n      }\n      if (baseArgs.top_p != null) {\n        baseArgs.top_p = void 0;\n        warnings.push({\n          type: \"unsupported-setting\",\n          setting: \"topP\",\n          details: \"topP is not supported for reasoning models\"\n        });\n      }\n    }\n    switch (type) {\n      case \"regular\": {\n        const { tools, tool_choice, toolWarnings } = prepareResponsesTools({\n          mode,\n          strict: isStrict\n          // TODO support provider options on tools\n        });\n        return {\n          args: {\n            ...baseArgs,\n            tools,\n            tool_choice\n          },\n          warnings: [...warnings, ...toolWarnings]\n        };\n      }\n      case \"object-json\": {\n        return {\n          args: {\n            ...baseArgs,\n            text: {\n              format: mode.schema != null ? {\n                type: \"json_schema\",\n                strict: isStrict,\n                name: (_c = mode.name) != null ? _c : \"response\",\n                description: mode.description,\n                schema: mode.schema\n              } : { type: \"json_object\" }\n            }\n          },\n          warnings\n        };\n      }\n      case \"object-tool\": {\n        return {\n          args: {\n            ...baseArgs,\n            tool_choice: { type: \"function\", name: mode.tool.name },\n            tools: [\n              {\n                type: \"function\",\n                name: mode.tool.name,\n                description: mode.tool.description,\n                parameters: mode.tool.parameters,\n                strict: isStrict\n              }\n            ]\n          },\n          warnings\n        };\n      }\n      default: {\n        const _exhaustiveCheck = type;\n        throw new Error(`Unsupported type: ${_exhaustiveCheck}`);\n      }\n    }\n  }\n  async doGenerate(options) {\n    var _a, _b, _c, _d, _e, _f, _g;\n    const { args: body, warnings } = this.getArgs(options);\n    const {\n      responseHeaders,\n      value: response,\n      rawValue: rawResponse\n    } = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.postJsonToApi)({\n      url: this.config.url({\n        path: \"/responses\",\n        modelId: this.modelId\n      }),\n      headers: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.combineHeaders)(this.config.headers(), options.headers),\n      body,\n      failedResponseHandler: openaiFailedResponseHandler,\n      successfulResponseHandler: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.createJsonResponseHandler)(\n        zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n          id: zod__WEBPACK_IMPORTED_MODULE_2__.z.string(),\n          created_at: zod__WEBPACK_IMPORTED_MODULE_2__.z.number(),\n          model: zod__WEBPACK_IMPORTED_MODULE_2__.z.string(),\n          output: zod__WEBPACK_IMPORTED_MODULE_2__.z.array(\n            zod__WEBPACK_IMPORTED_MODULE_2__.z.discriminatedUnion(\"type\", [\n              zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n                type: zod__WEBPACK_IMPORTED_MODULE_2__.z.literal(\"message\"),\n                role: zod__WEBPACK_IMPORTED_MODULE_2__.z.literal(\"assistant\"),\n                content: zod__WEBPACK_IMPORTED_MODULE_2__.z.array(\n                  zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n                    type: zod__WEBPACK_IMPORTED_MODULE_2__.z.literal(\"output_text\"),\n                    text: zod__WEBPACK_IMPORTED_MODULE_2__.z.string(),\n                    annotations: zod__WEBPACK_IMPORTED_MODULE_2__.z.array(\n                      zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n                        type: zod__WEBPACK_IMPORTED_MODULE_2__.z.literal(\"url_citation\"),\n                        start_index: zod__WEBPACK_IMPORTED_MODULE_2__.z.number(),\n                        end_index: zod__WEBPACK_IMPORTED_MODULE_2__.z.number(),\n                        url: zod__WEBPACK_IMPORTED_MODULE_2__.z.string(),\n                        title: zod__WEBPACK_IMPORTED_MODULE_2__.z.string()\n                      })\n                    )\n                  })\n                )\n              }),\n              zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n                type: zod__WEBPACK_IMPORTED_MODULE_2__.z.literal(\"function_call\"),\n                call_id: zod__WEBPACK_IMPORTED_MODULE_2__.z.string(),\n                name: zod__WEBPACK_IMPORTED_MODULE_2__.z.string(),\n                arguments: zod__WEBPACK_IMPORTED_MODULE_2__.z.string()\n              }),\n              zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n                type: zod__WEBPACK_IMPORTED_MODULE_2__.z.literal(\"web_search_call\")\n              }),\n              zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n                type: zod__WEBPACK_IMPORTED_MODULE_2__.z.literal(\"computer_call\")\n              }),\n              zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n                type: zod__WEBPACK_IMPORTED_MODULE_2__.z.literal(\"reasoning\"),\n                summary: zod__WEBPACK_IMPORTED_MODULE_2__.z.array(\n                  zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n                    type: zod__WEBPACK_IMPORTED_MODULE_2__.z.literal(\"summary_text\"),\n                    text: zod__WEBPACK_IMPORTED_MODULE_2__.z.string()\n                  })\n                )\n              })\n            ])\n          ),\n          incomplete_details: zod__WEBPACK_IMPORTED_MODULE_2__.z.object({ reason: zod__WEBPACK_IMPORTED_MODULE_2__.z.string() }).nullable(),\n          usage: usageSchema\n        })\n      ),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch\n    });\n    const outputTextElements = response.output.filter((output) => output.type === \"message\").flatMap((output) => output.content).filter((content) => content.type === \"output_text\");\n    const toolCalls = response.output.filter((output) => output.type === \"function_call\").map((output) => ({\n      toolCallType: \"function\",\n      toolCallId: output.call_id,\n      toolName: output.name,\n      args: output.arguments\n    }));\n    const reasoningSummary = (_b = (_a = response.output.find((item) => item.type === \"reasoning\")) == null ? void 0 : _a.summary) != null ? _b : null;\n    return {\n      text: outputTextElements.map((content) => content.text).join(\"\\n\"),\n      sources: outputTextElements.flatMap(\n        (content) => content.annotations.map((annotation) => {\n          var _a2, _b2, _c2;\n          return {\n            sourceType: \"url\",\n            id: (_c2 = (_b2 = (_a2 = this.config).generateId) == null ? void 0 : _b2.call(_a2)) != null ? _c2 : (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.generateId)(),\n            url: annotation.url,\n            title: annotation.title\n          };\n        })\n      ),\n      finishReason: mapOpenAIResponseFinishReason({\n        finishReason: (_c = response.incomplete_details) == null ? void 0 : _c.reason,\n        hasToolCalls: toolCalls.length > 0\n      }),\n      toolCalls: toolCalls.length > 0 ? toolCalls : void 0,\n      reasoning: reasoningSummary ? reasoningSummary.map((summary) => ({\n        type: \"text\",\n        text: summary.text\n      })) : void 0,\n      usage: {\n        promptTokens: response.usage.input_tokens,\n        completionTokens: response.usage.output_tokens\n      },\n      rawCall: {\n        rawPrompt: void 0,\n        rawSettings: {}\n      },\n      rawResponse: {\n        headers: responseHeaders,\n        body: rawResponse\n      },\n      request: {\n        body: JSON.stringify(body)\n      },\n      response: {\n        id: response.id,\n        timestamp: new Date(response.created_at * 1e3),\n        modelId: response.model\n      },\n      providerMetadata: {\n        openai: {\n          responseId: response.id,\n          cachedPromptTokens: (_e = (_d = response.usage.input_tokens_details) == null ? void 0 : _d.cached_tokens) != null ? _e : null,\n          reasoningTokens: (_g = (_f = response.usage.output_tokens_details) == null ? void 0 : _f.reasoning_tokens) != null ? _g : null\n        }\n      },\n      warnings\n    };\n  }\n  async doStream(options) {\n    const { args: body, warnings } = this.getArgs(options);\n    const { responseHeaders, value: response } = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.postJsonToApi)({\n      url: this.config.url({\n        path: \"/responses\",\n        modelId: this.modelId\n      }),\n      headers: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.combineHeaders)(this.config.headers(), options.headers),\n      body: {\n        ...body,\n        stream: true\n      },\n      failedResponseHandler: openaiFailedResponseHandler,\n      successfulResponseHandler: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.createEventSourceResponseHandler)(\n        openaiResponsesChunkSchema\n      ),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch\n    });\n    const self = this;\n    let finishReason = \"unknown\";\n    let promptTokens = NaN;\n    let completionTokens = NaN;\n    let cachedPromptTokens = null;\n    let reasoningTokens = null;\n    let responseId = null;\n    const ongoingToolCalls = {};\n    let hasToolCalls = false;\n    return {\n      stream: response.pipeThrough(\n        new TransformStream({\n          transform(chunk, controller) {\n            var _a, _b, _c, _d, _e, _f, _g, _h;\n            if (!chunk.success) {\n              finishReason = \"error\";\n              controller.enqueue({ type: \"error\", error: chunk.error });\n              return;\n            }\n            const value = chunk.value;\n            if (isResponseOutputItemAddedChunk(value)) {\n              if (value.item.type === \"function_call\") {\n                ongoingToolCalls[value.output_index] = {\n                  toolName: value.item.name,\n                  toolCallId: value.item.call_id\n                };\n                controller.enqueue({\n                  type: \"tool-call-delta\",\n                  toolCallType: \"function\",\n                  toolCallId: value.item.call_id,\n                  toolName: value.item.name,\n                  argsTextDelta: value.item.arguments\n                });\n              }\n            } else if (isResponseFunctionCallArgumentsDeltaChunk(value)) {\n              const toolCall = ongoingToolCalls[value.output_index];\n              if (toolCall != null) {\n                controller.enqueue({\n                  type: \"tool-call-delta\",\n                  toolCallType: \"function\",\n                  toolCallId: toolCall.toolCallId,\n                  toolName: toolCall.toolName,\n                  argsTextDelta: value.delta\n                });\n              }\n            } else if (isResponseCreatedChunk(value)) {\n              responseId = value.response.id;\n              controller.enqueue({\n                type: \"response-metadata\",\n                id: value.response.id,\n                timestamp: new Date(value.response.created_at * 1e3),\n                modelId: value.response.model\n              });\n            } else if (isTextDeltaChunk(value)) {\n              controller.enqueue({\n                type: \"text-delta\",\n                textDelta: value.delta\n              });\n            } else if (isResponseReasoningSummaryTextDeltaChunk(value)) {\n              controller.enqueue({\n                type: \"reasoning\",\n                textDelta: value.delta\n              });\n            } else if (isResponseOutputItemDoneChunk(value) && value.item.type === \"function_call\") {\n              ongoingToolCalls[value.output_index] = void 0;\n              hasToolCalls = true;\n              controller.enqueue({\n                type: \"tool-call\",\n                toolCallType: \"function\",\n                toolCallId: value.item.call_id,\n                toolName: value.item.name,\n                args: value.item.arguments\n              });\n            } else if (isResponseFinishedChunk(value)) {\n              finishReason = mapOpenAIResponseFinishReason({\n                finishReason: (_a = value.response.incomplete_details) == null ? void 0 : _a.reason,\n                hasToolCalls\n              });\n              promptTokens = value.response.usage.input_tokens;\n              completionTokens = value.response.usage.output_tokens;\n              cachedPromptTokens = (_c = (_b = value.response.usage.input_tokens_details) == null ? void 0 : _b.cached_tokens) != null ? _c : cachedPromptTokens;\n              reasoningTokens = (_e = (_d = value.response.usage.output_tokens_details) == null ? void 0 : _d.reasoning_tokens) != null ? _e : reasoningTokens;\n            } else if (isResponseAnnotationAddedChunk(value)) {\n              controller.enqueue({\n                type: \"source\",\n                source: {\n                  sourceType: \"url\",\n                  id: (_h = (_g = (_f = self.config).generateId) == null ? void 0 : _g.call(_f)) != null ? _h : (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.generateId)(),\n                  url: value.annotation.url,\n                  title: value.annotation.title\n                }\n              });\n            }\n          },\n          flush(controller) {\n            controller.enqueue({\n              type: \"finish\",\n              finishReason,\n              usage: { promptTokens, completionTokens },\n              ...(cachedPromptTokens != null || reasoningTokens != null) && {\n                providerMetadata: {\n                  openai: {\n                    responseId,\n                    cachedPromptTokens,\n                    reasoningTokens\n                  }\n                }\n              }\n            });\n          }\n        })\n      ),\n      rawCall: {\n        rawPrompt: void 0,\n        rawSettings: {}\n      },\n      rawResponse: { headers: responseHeaders },\n      request: { body: JSON.stringify(body) },\n      warnings\n    };\n  }\n};\nvar usageSchema = zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n  input_tokens: zod__WEBPACK_IMPORTED_MODULE_2__.z.number(),\n  input_tokens_details: zod__WEBPACK_IMPORTED_MODULE_2__.z.object({ cached_tokens: zod__WEBPACK_IMPORTED_MODULE_2__.z.number().nullish() }).nullish(),\n  output_tokens: zod__WEBPACK_IMPORTED_MODULE_2__.z.number(),\n  output_tokens_details: zod__WEBPACK_IMPORTED_MODULE_2__.z.object({ reasoning_tokens: zod__WEBPACK_IMPORTED_MODULE_2__.z.number().nullish() }).nullish()\n});\nvar textDeltaChunkSchema = zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n  type: zod__WEBPACK_IMPORTED_MODULE_2__.z.literal(\"response.output_text.delta\"),\n  delta: zod__WEBPACK_IMPORTED_MODULE_2__.z.string()\n});\nvar responseFinishedChunkSchema = zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n  type: zod__WEBPACK_IMPORTED_MODULE_2__.z.enum([\"response.completed\", \"response.incomplete\"]),\n  response: zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n    incomplete_details: zod__WEBPACK_IMPORTED_MODULE_2__.z.object({ reason: zod__WEBPACK_IMPORTED_MODULE_2__.z.string() }).nullish(),\n    usage: usageSchema\n  })\n});\nvar responseCreatedChunkSchema = zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n  type: zod__WEBPACK_IMPORTED_MODULE_2__.z.literal(\"response.created\"),\n  response: zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n    id: zod__WEBPACK_IMPORTED_MODULE_2__.z.string(),\n    created_at: zod__WEBPACK_IMPORTED_MODULE_2__.z.number(),\n    model: zod__WEBPACK_IMPORTED_MODULE_2__.z.string()\n  })\n});\nvar responseOutputItemDoneSchema = zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n  type: zod__WEBPACK_IMPORTED_MODULE_2__.z.literal(\"response.output_item.done\"),\n  output_index: zod__WEBPACK_IMPORTED_MODULE_2__.z.number(),\n  item: zod__WEBPACK_IMPORTED_MODULE_2__.z.discriminatedUnion(\"type\", [\n    zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n      type: zod__WEBPACK_IMPORTED_MODULE_2__.z.literal(\"message\")\n    }),\n    zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n      type: zod__WEBPACK_IMPORTED_MODULE_2__.z.literal(\"function_call\"),\n      id: zod__WEBPACK_IMPORTED_MODULE_2__.z.string(),\n      call_id: zod__WEBPACK_IMPORTED_MODULE_2__.z.string(),\n      name: zod__WEBPACK_IMPORTED_MODULE_2__.z.string(),\n      arguments: zod__WEBPACK_IMPORTED_MODULE_2__.z.string(),\n      status: zod__WEBPACK_IMPORTED_MODULE_2__.z.literal(\"completed\")\n    })\n  ])\n});\nvar responseFunctionCallArgumentsDeltaSchema = zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n  type: zod__WEBPACK_IMPORTED_MODULE_2__.z.literal(\"response.function_call_arguments.delta\"),\n  item_id: zod__WEBPACK_IMPORTED_MODULE_2__.z.string(),\n  output_index: zod__WEBPACK_IMPORTED_MODULE_2__.z.number(),\n  delta: zod__WEBPACK_IMPORTED_MODULE_2__.z.string()\n});\nvar responseOutputItemAddedSchema = zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n  type: zod__WEBPACK_IMPORTED_MODULE_2__.z.literal(\"response.output_item.added\"),\n  output_index: zod__WEBPACK_IMPORTED_MODULE_2__.z.number(),\n  item: zod__WEBPACK_IMPORTED_MODULE_2__.z.discriminatedUnion(\"type\", [\n    zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n      type: zod__WEBPACK_IMPORTED_MODULE_2__.z.literal(\"message\")\n    }),\n    zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n      type: zod__WEBPACK_IMPORTED_MODULE_2__.z.literal(\"function_call\"),\n      id: zod__WEBPACK_IMPORTED_MODULE_2__.z.string(),\n      call_id: zod__WEBPACK_IMPORTED_MODULE_2__.z.string(),\n      name: zod__WEBPACK_IMPORTED_MODULE_2__.z.string(),\n      arguments: zod__WEBPACK_IMPORTED_MODULE_2__.z.string()\n    })\n  ])\n});\nvar responseAnnotationAddedSchema = zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n  type: zod__WEBPACK_IMPORTED_MODULE_2__.z.literal(\"response.output_text.annotation.added\"),\n  annotation: zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n    type: zod__WEBPACK_IMPORTED_MODULE_2__.z.literal(\"url_citation\"),\n    url: zod__WEBPACK_IMPORTED_MODULE_2__.z.string(),\n    title: zod__WEBPACK_IMPORTED_MODULE_2__.z.string()\n  })\n});\nvar responseReasoningSummaryTextDeltaSchema = zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n  type: zod__WEBPACK_IMPORTED_MODULE_2__.z.literal(\"response.reasoning_summary_text.delta\"),\n  item_id: zod__WEBPACK_IMPORTED_MODULE_2__.z.string(),\n  output_index: zod__WEBPACK_IMPORTED_MODULE_2__.z.number(),\n  summary_index: zod__WEBPACK_IMPORTED_MODULE_2__.z.number(),\n  delta: zod__WEBPACK_IMPORTED_MODULE_2__.z.string()\n});\nvar openaiResponsesChunkSchema = zod__WEBPACK_IMPORTED_MODULE_2__.z.union([\n  textDeltaChunkSchema,\n  responseFinishedChunkSchema,\n  responseCreatedChunkSchema,\n  responseOutputItemDoneSchema,\n  responseFunctionCallArgumentsDeltaSchema,\n  responseOutputItemAddedSchema,\n  responseAnnotationAddedSchema,\n  responseReasoningSummaryTextDeltaSchema,\n  zod__WEBPACK_IMPORTED_MODULE_2__.z.object({ type: zod__WEBPACK_IMPORTED_MODULE_2__.z.string() }).passthrough()\n  // fallback for unknown chunks\n]);\nfunction isTextDeltaChunk(chunk) {\n  return chunk.type === \"response.output_text.delta\";\n}\nfunction isResponseOutputItemDoneChunk(chunk) {\n  return chunk.type === \"response.output_item.done\";\n}\nfunction isResponseFinishedChunk(chunk) {\n  return chunk.type === \"response.completed\" || chunk.type === \"response.incomplete\";\n}\nfunction isResponseCreatedChunk(chunk) {\n  return chunk.type === \"response.created\";\n}\nfunction isResponseFunctionCallArgumentsDeltaChunk(chunk) {\n  return chunk.type === \"response.function_call_arguments.delta\";\n}\nfunction isResponseOutputItemAddedChunk(chunk) {\n  return chunk.type === \"response.output_item.added\";\n}\nfunction isResponseAnnotationAddedChunk(chunk) {\n  return chunk.type === \"response.output_text.annotation.added\";\n}\nfunction isResponseReasoningSummaryTextDeltaChunk(chunk) {\n  return chunk.type === \"response.reasoning_summary_text.delta\";\n}\nfunction getResponsesModelConfig(modelId) {\n  if (modelId.startsWith(\"o\")) {\n    if (modelId.startsWith(\"o1-mini\") || modelId.startsWith(\"o1-preview\")) {\n      return {\n        isReasoningModel: true,\n        systemMessageMode: \"remove\",\n        requiredAutoTruncation: false\n      };\n    }\n    return {\n      isReasoningModel: true,\n      systemMessageMode: \"developer\",\n      requiredAutoTruncation: false\n    };\n  }\n  return {\n    isReasoningModel: false,\n    systemMessageMode: \"system\",\n    requiredAutoTruncation: false\n  };\n}\nvar openaiResponsesProviderOptionsSchema = zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n  metadata: zod__WEBPACK_IMPORTED_MODULE_2__.z.any().nullish(),\n  parallelToolCalls: zod__WEBPACK_IMPORTED_MODULE_2__.z.boolean().nullish(),\n  previousResponseId: zod__WEBPACK_IMPORTED_MODULE_2__.z.string().nullish(),\n  store: zod__WEBPACK_IMPORTED_MODULE_2__.z.boolean().nullish(),\n  user: zod__WEBPACK_IMPORTED_MODULE_2__.z.string().nullish(),\n  reasoningEffort: zod__WEBPACK_IMPORTED_MODULE_2__.z.string().nullish(),\n  strictSchemas: zod__WEBPACK_IMPORTED_MODULE_2__.z.boolean().nullish(),\n  instructions: zod__WEBPACK_IMPORTED_MODULE_2__.z.string().nullish(),\n  reasoningSummary: zod__WEBPACK_IMPORTED_MODULE_2__.z.string().nullish()\n});\n\n// src/openai-tools.ts\n\nvar WebSearchPreviewParameters = zod__WEBPACK_IMPORTED_MODULE_2__.z.object({});\nfunction webSearchPreviewTool({\n  searchContextSize,\n  userLocation\n} = {}) {\n  return {\n    type: \"provider-defined\",\n    id: \"openai.web_search_preview\",\n    args: {\n      searchContextSize,\n      userLocation\n    },\n    parameters: WebSearchPreviewParameters\n  };\n}\nvar openaiTools = {\n  webSearchPreview: webSearchPreviewTool\n};\n\n// src/openai-speech-model.ts\n\n\nvar OpenAIProviderOptionsSchema = zod__WEBPACK_IMPORTED_MODULE_2__.z.object({\n  instructions: zod__WEBPACK_IMPORTED_MODULE_2__.z.string().nullish(),\n  speed: zod__WEBPACK_IMPORTED_MODULE_2__.z.number().min(0.25).max(4).default(1).nullish()\n});\nvar OpenAISpeechModel = class {\n  constructor(modelId, config) {\n    this.modelId = modelId;\n    this.config = config;\n    this.specificationVersion = \"v1\";\n  }\n  get provider() {\n    return this.config.provider;\n  }\n  getArgs({\n    text,\n    voice = \"alloy\",\n    outputFormat = \"mp3\",\n    speed,\n    instructions,\n    providerOptions\n  }) {\n    const warnings = [];\n    const openAIOptions = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.parseProviderOptions)({\n      provider: \"openai\",\n      providerOptions,\n      schema: OpenAIProviderOptionsSchema\n    });\n    const requestBody = {\n      model: this.modelId,\n      input: text,\n      voice,\n      response_format: \"mp3\",\n      speed,\n      instructions\n    };\n    if (outputFormat) {\n      if ([\"mp3\", \"opus\", \"aac\", \"flac\", \"wav\", \"pcm\"].includes(outputFormat)) {\n        requestBody.response_format = outputFormat;\n      } else {\n        warnings.push({\n          type: \"unsupported-setting\",\n          setting: \"outputFormat\",\n          details: `Unsupported output format: ${outputFormat}. Using mp3 instead.`\n        });\n      }\n    }\n    if (openAIOptions) {\n      const speechModelOptions = {};\n      for (const key in speechModelOptions) {\n        const value = speechModelOptions[key];\n        if (value !== void 0) {\n          requestBody[key] = value;\n        }\n      }\n    }\n    return {\n      requestBody,\n      warnings\n    };\n  }\n  async doGenerate(options) {\n    var _a, _b, _c;\n    const currentDate = (_c = (_b = (_a = this.config._internal) == null ? void 0 : _a.currentDate) == null ? void 0 : _b.call(_a)) != null ? _c : /* @__PURE__ */ new Date();\n    const { requestBody, warnings } = this.getArgs(options);\n    const {\n      value: audio,\n      responseHeaders,\n      rawValue: rawResponse\n    } = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.postJsonToApi)({\n      url: this.config.url({\n        path: \"/audio/speech\",\n        modelId: this.modelId\n      }),\n      headers: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.combineHeaders)(this.config.headers(), options.headers),\n      body: requestBody,\n      failedResponseHandler: openaiFailedResponseHandler,\n      successfulResponseHandler: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.createBinaryResponseHandler)(),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch\n    });\n    return {\n      audio,\n      warnings,\n      request: {\n        body: JSON.stringify(requestBody)\n      },\n      response: {\n        timestamp: currentDate,\n        modelId: this.modelId,\n        headers: responseHeaders,\n        body: rawResponse\n      }\n    };\n  }\n};\n\n// src/openai-provider.ts\nfunction createOpenAI(options = {}) {\n  var _a, _b, _c;\n  const baseURL = (_a = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.withoutTrailingSlash)(options.baseURL)) != null ? _a : \"https://api.openai.com/v1\";\n  const compatibility = (_b = options.compatibility) != null ? _b : \"compatible\";\n  const providerName = (_c = options.name) != null ? _c : \"openai\";\n  const getHeaders = () => ({\n    Authorization: `Bearer ${(0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.loadApiKey)({\n      apiKey: options.apiKey,\n      environmentVariableName: \"OPENAI_API_KEY\",\n      description: \"OpenAI\"\n    })}`,\n    \"OpenAI-Organization\": options.organization,\n    \"OpenAI-Project\": options.project,\n    ...options.headers\n  });\n  const createChatModel = (modelId, settings = {}) => new OpenAIChatLanguageModel(modelId, settings, {\n    provider: `${providerName}.chat`,\n    url: ({ path }) => `${baseURL}${path}`,\n    headers: getHeaders,\n    compatibility,\n    fetch: options.fetch\n  });\n  const createCompletionModel = (modelId, settings = {}) => new OpenAICompletionLanguageModel(modelId, settings, {\n    provider: `${providerName}.completion`,\n    url: ({ path }) => `${baseURL}${path}`,\n    headers: getHeaders,\n    compatibility,\n    fetch: options.fetch\n  });\n  const createEmbeddingModel = (modelId, settings = {}) => new OpenAIEmbeddingModel(modelId, settings, {\n    provider: `${providerName}.embedding`,\n    url: ({ path }) => `${baseURL}${path}`,\n    headers: getHeaders,\n    fetch: options.fetch\n  });\n  const createImageModel = (modelId, settings = {}) => new OpenAIImageModel(modelId, settings, {\n    provider: `${providerName}.image`,\n    url: ({ path }) => `${baseURL}${path}`,\n    headers: getHeaders,\n    fetch: options.fetch\n  });\n  const createTranscriptionModel = (modelId) => new OpenAITranscriptionModel(modelId, {\n    provider: `${providerName}.transcription`,\n    url: ({ path }) => `${baseURL}${path}`,\n    headers: getHeaders,\n    fetch: options.fetch\n  });\n  const createSpeechModel = (modelId) => new OpenAISpeechModel(modelId, {\n    provider: `${providerName}.speech`,\n    url: ({ path }) => `${baseURL}${path}`,\n    headers: getHeaders,\n    fetch: options.fetch\n  });\n  const createLanguageModel = (modelId, settings) => {\n    if (new.target) {\n      throw new Error(\n        \"The OpenAI model function cannot be called with the new keyword.\"\n      );\n    }\n    if (modelId === \"gpt-3.5-turbo-instruct\") {\n      return createCompletionModel(\n        modelId,\n        settings\n      );\n    }\n    return createChatModel(modelId, settings);\n  };\n  const createResponsesModel = (modelId) => {\n    return new OpenAIResponsesLanguageModel(modelId, {\n      provider: `${providerName}.responses`,\n      url: ({ path }) => `${baseURL}${path}`,\n      headers: getHeaders,\n      fetch: options.fetch\n    });\n  };\n  const provider = function(modelId, settings) {\n    return createLanguageModel(modelId, settings);\n  };\n  provider.languageModel = createLanguageModel;\n  provider.chat = createChatModel;\n  provider.completion = createCompletionModel;\n  provider.responses = createResponsesModel;\n  provider.embedding = createEmbeddingModel;\n  provider.textEmbedding = createEmbeddingModel;\n  provider.textEmbeddingModel = createEmbeddingModel;\n  provider.image = createImageModel;\n  provider.imageModel = createImageModel;\n  provider.transcription = createTranscriptionModel;\n  provider.transcriptionModel = createTranscriptionModel;\n  provider.speech = createSpeechModel;\n  provider.speechModel = createSpeechModel;\n  provider.tools = openaiTools;\n  return provider;\n}\nvar openai = createOpenAI({\n  compatibility: \"strict\"\n  // strict for OpenAI API\n});\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGFpLXNkay9vcGVuYWkvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUlnQzs7QUFFaEM7QUFJMEI7QUFRTTtBQUNGOztBQUU5QjtBQUcwQjtBQUN5QztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIseUJBQXlCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw0QkFBNEI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsaUJBQWlCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHdDQUF3QztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRkFBcUYsa0RBQWtELFNBQVMsaUZBQXlCLGFBQWE7QUFDdEw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMkVBQTZCO0FBQ3pEO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSxNQUFNO0FBQ3BGLHlEQUF5RCxTQUFTLFVBQVU7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsMkVBQTZCO0FBQzNELCtEQUErRCxlQUFlO0FBQzlFLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0EsZ0JBQWdCLDJFQUE4QjtBQUM5QztBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsZ0JBQWdCLDJFQUE4QjtBQUM5QztBQUNBLE9BQU87QUFDUDtBQUNBLFlBQVksc0NBQXNDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsSUFBSSxzQkFBc0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNkRBQTZEO0FBQzdFO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsYUFBYTtBQUNoQyxjQUFjLE1BQU0sUUFBUSxRQUFRLEVBQUUsS0FBSztBQUMzQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBSUM7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cnZpdmFsLWZ1bi8uL25vZGVfbW9kdWxlcy9AYWktc2RrL29wZW5haS9kaXN0L2luZGV4Lm1qcz83MGY2Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9vcGVuYWktcHJvdmlkZXIudHNcbmltcG9ydCB7XG4gIGxvYWRBcGlLZXksXG4gIHdpdGhvdXRUcmFpbGluZ1NsYXNoXG59IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5cbi8vIHNyYy9vcGVuYWktY2hhdC1sYW5ndWFnZS1tb2RlbC50c1xuaW1wb3J0IHtcbiAgSW52YWxpZFJlc3BvbnNlRGF0YUVycm9yLFxuICBVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvciBhcyBVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvcjNcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbmltcG9ydCB7XG4gIGNvbWJpbmVIZWFkZXJzLFxuICBjcmVhdGVFdmVudFNvdXJjZVJlc3BvbnNlSGFuZGxlcixcbiAgY3JlYXRlSnNvblJlc3BvbnNlSGFuZGxlcixcbiAgZ2VuZXJhdGVJZCxcbiAgaXNQYXJzYWJsZUpzb24sXG4gIHBvc3RKc29uVG9BcGlcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbmltcG9ydCB7IHogYXMgejIgfSBmcm9tIFwiem9kXCI7XG5cbi8vIHNyYy9jb252ZXJ0LXRvLW9wZW5haS1jaGF0LW1lc3NhZ2VzLnRzXG5pbXBvcnQge1xuICBVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvclxufSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuaW1wb3J0IHsgY29udmVydFVpbnQ4QXJyYXlUb0Jhc2U2NCB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5mdW5jdGlvbiBjb252ZXJ0VG9PcGVuQUlDaGF0TWVzc2FnZXMoe1xuICBwcm9tcHQsXG4gIHVzZUxlZ2FjeUZ1bmN0aW9uQ2FsbGluZyA9IGZhbHNlLFxuICBzeXN0ZW1NZXNzYWdlTW9kZSA9IFwic3lzdGVtXCJcbn0pIHtcbiAgY29uc3QgbWVzc2FnZXMgPSBbXTtcbiAgY29uc3Qgd2FybmluZ3MgPSBbXTtcbiAgZm9yIChjb25zdCB7IHJvbGUsIGNvbnRlbnQgfSBvZiBwcm9tcHQpIHtcbiAgICBzd2l0Y2ggKHJvbGUpIHtcbiAgICAgIGNhc2UgXCJzeXN0ZW1cIjoge1xuICAgICAgICBzd2l0Y2ggKHN5c3RlbU1lc3NhZ2VNb2RlKSB7XG4gICAgICAgICAgY2FzZSBcInN5c3RlbVwiOiB7XG4gICAgICAgICAgICBtZXNzYWdlcy5wdXNoKHsgcm9sZTogXCJzeXN0ZW1cIiwgY29udGVudCB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwiZGV2ZWxvcGVyXCI6IHtcbiAgICAgICAgICAgIG1lc3NhZ2VzLnB1c2goeyByb2xlOiBcImRldmVsb3BlclwiLCBjb250ZW50IH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJyZW1vdmVcIjoge1xuICAgICAgICAgICAgd2FybmluZ3MucHVzaCh7XG4gICAgICAgICAgICAgIHR5cGU6IFwib3RoZXJcIixcbiAgICAgICAgICAgICAgbWVzc2FnZTogXCJzeXN0ZW0gbWVzc2FnZXMgYXJlIHJlbW92ZWQgZm9yIHRoaXMgbW9kZWxcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgY29uc3QgX2V4aGF1c3RpdmVDaGVjayA9IHN5c3RlbU1lc3NhZ2VNb2RlO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICBgVW5zdXBwb3J0ZWQgc3lzdGVtIG1lc3NhZ2UgbW9kZTogJHtfZXhoYXVzdGl2ZUNoZWNrfWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcInVzZXJcIjoge1xuICAgICAgICBpZiAoY29udGVudC5sZW5ndGggPT09IDEgJiYgY29udGVudFswXS50eXBlID09PSBcInRleHRcIikge1xuICAgICAgICAgIG1lc3NhZ2VzLnB1c2goeyByb2xlOiBcInVzZXJcIiwgY29udGVudDogY29udGVudFswXS50ZXh0IH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIG1lc3NhZ2VzLnB1c2goe1xuICAgICAgICAgIHJvbGU6IFwidXNlclwiLFxuICAgICAgICAgIGNvbnRlbnQ6IGNvbnRlbnQubWFwKChwYXJ0LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICAgICAgc3dpdGNoIChwYXJ0LnR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSBcInRleHRcIjoge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwidGV4dFwiLCB0ZXh0OiBwYXJ0LnRleHQgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIFwiaW1hZ2VcIjoge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcImltYWdlX3VybFwiLFxuICAgICAgICAgICAgICAgICAgaW1hZ2VfdXJsOiB7XG4gICAgICAgICAgICAgICAgICAgIHVybDogcGFydC5pbWFnZSBpbnN0YW5jZW9mIFVSTCA/IHBhcnQuaW1hZ2UudG9TdHJpbmcoKSA6IGBkYXRhOiR7KF9hID0gcGFydC5taW1lVHlwZSkgIT0gbnVsbCA/IF9hIDogXCJpbWFnZS9qcGVnXCJ9O2Jhc2U2NCwke2NvbnZlcnRVaW50OEFycmF5VG9CYXNlNjQocGFydC5pbWFnZSl9YCxcbiAgICAgICAgICAgICAgICAgICAgLy8gT3BlbkFJIHNwZWNpZmljIGV4dGVuc2lvbjogaW1hZ2UgZGV0YWlsXG4gICAgICAgICAgICAgICAgICAgIGRldGFpbDogKF9jID0gKF9iID0gcGFydC5wcm92aWRlck1ldGFkYXRhKSA9PSBudWxsID8gdm9pZCAwIDogX2Iub3BlbmFpKSA9PSBudWxsID8gdm9pZCAwIDogX2MuaW1hZ2VEZXRhaWxcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgXCJmaWxlXCI6IHtcbiAgICAgICAgICAgICAgICBpZiAocGFydC5kYXRhIGluc3RhbmNlb2YgVVJMKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbmFsaXR5OiBcIidGaWxlIGNvbnRlbnQgcGFydHMgd2l0aCBVUkwgZGF0YScgZnVuY3Rpb25hbGl0eSBub3Qgc3VwcG9ydGVkLlwiXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3dpdGNoIChwYXJ0Lm1pbWVUeXBlKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiYXVkaW8vd2F2XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImlucHV0X2F1ZGlvXCIsXG4gICAgICAgICAgICAgICAgICAgICAgaW5wdXRfYXVkaW86IHsgZGF0YTogcGFydC5kYXRhLCBmb3JtYXQ6IFwid2F2XCIgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgY2FzZSBcImF1ZGlvL21wM1wiOlxuICAgICAgICAgICAgICAgICAgY2FzZSBcImF1ZGlvL21wZWdcIjoge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiaW5wdXRfYXVkaW9cIixcbiAgICAgICAgICAgICAgICAgICAgICBpbnB1dF9hdWRpbzogeyBkYXRhOiBwYXJ0LmRhdGEsIGZvcm1hdDogXCJtcDNcIiB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiYXBwbGljYXRpb24vcGRmXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImZpbGVcIixcbiAgICAgICAgICAgICAgICAgICAgICBmaWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlbmFtZTogKF9kID0gcGFydC5maWxlbmFtZSkgIT0gbnVsbCA/IF9kIDogYHBhcnQtJHtpbmRleH0ucGRmYCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVfZGF0YTogYGRhdGE6YXBwbGljYXRpb24vcGRmO2Jhc2U2NCwke3BhcnQuZGF0YX1gXG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uYWxpdHk6IGBGaWxlIGNvbnRlbnQgcGFydCB0eXBlICR7cGFydC5taW1lVHlwZX0gaW4gdXNlciBtZXNzYWdlc2BcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcImFzc2lzdGFudFwiOiB7XG4gICAgICAgIGxldCB0ZXh0ID0gXCJcIjtcbiAgICAgICAgY29uc3QgdG9vbENhbGxzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcGFydCBvZiBjb250ZW50KSB7XG4gICAgICAgICAgc3dpdGNoIChwYXJ0LnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ0ZXh0XCI6IHtcbiAgICAgICAgICAgICAgdGV4dCArPSBwYXJ0LnRleHQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInRvb2wtY2FsbFwiOiB7XG4gICAgICAgICAgICAgIHRvb2xDYWxscy5wdXNoKHtcbiAgICAgICAgICAgICAgICBpZDogcGFydC50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgICAgICBmdW5jdGlvbjoge1xuICAgICAgICAgICAgICAgICAgbmFtZTogcGFydC50b29sTmFtZSxcbiAgICAgICAgICAgICAgICAgIGFyZ3VtZW50czogSlNPTi5zdHJpbmdpZnkocGFydC5hcmdzKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodXNlTGVnYWN5RnVuY3Rpb25DYWxsaW5nKSB7XG4gICAgICAgICAgaWYgKHRvb2xDYWxscy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3Ioe1xuICAgICAgICAgICAgICBmdW5jdGlvbmFsaXR5OiBcInVzZUxlZ2FjeUZ1bmN0aW9uQ2FsbGluZyB3aXRoIG11bHRpcGxlIHRvb2wgY2FsbHMgaW4gb25lIG1lc3NhZ2VcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1lc3NhZ2VzLnB1c2goe1xuICAgICAgICAgICAgcm9sZTogXCJhc3Npc3RhbnRcIixcbiAgICAgICAgICAgIGNvbnRlbnQ6IHRleHQsXG4gICAgICAgICAgICBmdW5jdGlvbl9jYWxsOiB0b29sQ2FsbHMubGVuZ3RoID4gMCA/IHRvb2xDYWxsc1swXS5mdW5jdGlvbiA6IHZvaWQgMFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1lc3NhZ2VzLnB1c2goe1xuICAgICAgICAgICAgcm9sZTogXCJhc3Npc3RhbnRcIixcbiAgICAgICAgICAgIGNvbnRlbnQ6IHRleHQsXG4gICAgICAgICAgICB0b29sX2NhbGxzOiB0b29sQ2FsbHMubGVuZ3RoID4gMCA/IHRvb2xDYWxscyA6IHZvaWQgMFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcInRvb2xcIjoge1xuICAgICAgICBmb3IgKGNvbnN0IHRvb2xSZXNwb25zZSBvZiBjb250ZW50KSB7XG4gICAgICAgICAgaWYgKHVzZUxlZ2FjeUZ1bmN0aW9uQ2FsbGluZykge1xuICAgICAgICAgICAgbWVzc2FnZXMucHVzaCh7XG4gICAgICAgICAgICAgIHJvbGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgICAgbmFtZTogdG9vbFJlc3BvbnNlLnRvb2xOYW1lLFxuICAgICAgICAgICAgICBjb250ZW50OiBKU09OLnN0cmluZ2lmeSh0b29sUmVzcG9uc2UucmVzdWx0KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lc3NhZ2VzLnB1c2goe1xuICAgICAgICAgICAgICByb2xlOiBcInRvb2xcIixcbiAgICAgICAgICAgICAgdG9vbF9jYWxsX2lkOiB0b29sUmVzcG9uc2UudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgY29udGVudDogSlNPTi5zdHJpbmdpZnkodG9vbFJlc3BvbnNlLnJlc3VsdClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgY29uc3QgX2V4aGF1c3RpdmVDaGVjayA9IHJvbGU7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgcm9sZTogJHtfZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4geyBtZXNzYWdlcywgd2FybmluZ3MgfTtcbn1cblxuLy8gc3JjL21hcC1vcGVuYWktY2hhdC1sb2dwcm9icy50c1xuZnVuY3Rpb24gbWFwT3BlbkFJQ2hhdExvZ1Byb2JzT3V0cHV0KGxvZ3Byb2JzKSB7XG4gIHZhciBfYSwgX2I7XG4gIHJldHVybiAoX2IgPSAoX2EgPSBsb2dwcm9icyA9PSBudWxsID8gdm9pZCAwIDogbG9ncHJvYnMuY29udGVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLm1hcCgoeyB0b2tlbiwgbG9ncHJvYiwgdG9wX2xvZ3Byb2JzIH0pID0+ICh7XG4gICAgdG9rZW4sXG4gICAgbG9ncHJvYixcbiAgICB0b3BMb2dwcm9iczogdG9wX2xvZ3Byb2JzID8gdG9wX2xvZ3Byb2JzLm1hcCgoeyB0b2tlbjogdG9rZW4yLCBsb2dwcm9iOiBsb2dwcm9iMiB9KSA9PiAoe1xuICAgICAgdG9rZW46IHRva2VuMixcbiAgICAgIGxvZ3Byb2I6IGxvZ3Byb2IyXG4gICAgfSkpIDogW11cbiAgfSkpKSAhPSBudWxsID8gX2IgOiB2b2lkIDA7XG59XG5cbi8vIHNyYy9tYXAtb3BlbmFpLWZpbmlzaC1yZWFzb24udHNcbmZ1bmN0aW9uIG1hcE9wZW5BSUZpbmlzaFJlYXNvbihmaW5pc2hSZWFzb24pIHtcbiAgc3dpdGNoIChmaW5pc2hSZWFzb24pIHtcbiAgICBjYXNlIFwic3RvcFwiOlxuICAgICAgcmV0dXJuIFwic3RvcFwiO1xuICAgIGNhc2UgXCJsZW5ndGhcIjpcbiAgICAgIHJldHVybiBcImxlbmd0aFwiO1xuICAgIGNhc2UgXCJjb250ZW50X2ZpbHRlclwiOlxuICAgICAgcmV0dXJuIFwiY29udGVudC1maWx0ZXJcIjtcbiAgICBjYXNlIFwiZnVuY3Rpb25fY2FsbFwiOlxuICAgIGNhc2UgXCJ0b29sX2NhbGxzXCI6XG4gICAgICByZXR1cm4gXCJ0b29sLWNhbGxzXCI7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBcInVua25vd25cIjtcbiAgfVxufVxuXG4vLyBzcmMvb3BlbmFpLWVycm9yLnRzXG5pbXBvcnQgeyB6IH0gZnJvbSBcInpvZFwiO1xuaW1wb3J0IHsgY3JlYXRlSnNvbkVycm9yUmVzcG9uc2VIYW5kbGVyIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbnZhciBvcGVuYWlFcnJvckRhdGFTY2hlbWEgPSB6Lm9iamVjdCh7XG4gIGVycm9yOiB6Lm9iamVjdCh7XG4gICAgbWVzc2FnZTogei5zdHJpbmcoKSxcbiAgICAvLyBUaGUgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBiZWxvdyBpcyBoYW5kbGVkIGxvb3NlbHkgdG8gc3VwcG9ydFxuICAgIC8vIE9wZW5BSS1jb21wYXRpYmxlIHByb3ZpZGVycyB0aGF0IGhhdmUgc2xpZ2h0bHkgZGlmZmVyZW50IGVycm9yXG4gICAgLy8gcmVzcG9uc2VzOlxuICAgIHR5cGU6IHouc3RyaW5nKCkubnVsbGlzaCgpLFxuICAgIHBhcmFtOiB6LmFueSgpLm51bGxpc2goKSxcbiAgICBjb2RlOiB6LnVuaW9uKFt6LnN0cmluZygpLCB6Lm51bWJlcigpXSkubnVsbGlzaCgpXG4gIH0pXG59KTtcbnZhciBvcGVuYWlGYWlsZWRSZXNwb25zZUhhbmRsZXIgPSBjcmVhdGVKc29uRXJyb3JSZXNwb25zZUhhbmRsZXIoe1xuICBlcnJvclNjaGVtYTogb3BlbmFpRXJyb3JEYXRhU2NoZW1hLFxuICBlcnJvclRvTWVzc2FnZTogKGRhdGEpID0+IGRhdGEuZXJyb3IubWVzc2FnZVxufSk7XG5cbi8vIHNyYy9nZXQtcmVzcG9uc2UtbWV0YWRhdGEudHNcbmZ1bmN0aW9uIGdldFJlc3BvbnNlTWV0YWRhdGEoe1xuICBpZCxcbiAgbW9kZWwsXG4gIGNyZWF0ZWRcbn0pIHtcbiAgcmV0dXJuIHtcbiAgICBpZDogaWQgIT0gbnVsbCA/IGlkIDogdm9pZCAwLFxuICAgIG1vZGVsSWQ6IG1vZGVsICE9IG51bGwgPyBtb2RlbCA6IHZvaWQgMCxcbiAgICB0aW1lc3RhbXA6IGNyZWF0ZWQgIT0gbnVsbCA/IG5ldyBEYXRlKGNyZWF0ZWQgKiAxZTMpIDogdm9pZCAwXG4gIH07XG59XG5cbi8vIHNyYy9vcGVuYWktcHJlcGFyZS10b29scy50c1xuaW1wb3J0IHtcbiAgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3IgYXMgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3IyXG59IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5mdW5jdGlvbiBwcmVwYXJlVG9vbHMoe1xuICBtb2RlLFxuICB1c2VMZWdhY3lGdW5jdGlvbkNhbGxpbmcgPSBmYWxzZSxcbiAgc3RydWN0dXJlZE91dHB1dHNcbn0pIHtcbiAgdmFyIF9hO1xuICBjb25zdCB0b29scyA9ICgoX2EgPSBtb2RlLnRvb2xzKSA9PSBudWxsID8gdm9pZCAwIDogX2EubGVuZ3RoKSA/IG1vZGUudG9vbHMgOiB2b2lkIDA7XG4gIGNvbnN0IHRvb2xXYXJuaW5ncyA9IFtdO1xuICBpZiAodG9vbHMgPT0gbnVsbCkge1xuICAgIHJldHVybiB7IHRvb2xzOiB2b2lkIDAsIHRvb2xfY2hvaWNlOiB2b2lkIDAsIHRvb2xXYXJuaW5ncyB9O1xuICB9XG4gIGNvbnN0IHRvb2xDaG9pY2UgPSBtb2RlLnRvb2xDaG9pY2U7XG4gIGlmICh1c2VMZWdhY3lGdW5jdGlvbkNhbGxpbmcpIHtcbiAgICBjb25zdCBvcGVuYWlGdW5jdGlvbnMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHRvb2wgb2YgdG9vbHMpIHtcbiAgICAgIGlmICh0b29sLnR5cGUgPT09IFwicHJvdmlkZXItZGVmaW5lZFwiKSB7XG4gICAgICAgIHRvb2xXYXJuaW5ncy5wdXNoKHsgdHlwZTogXCJ1bnN1cHBvcnRlZC10b29sXCIsIHRvb2wgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcGVuYWlGdW5jdGlvbnMucHVzaCh7XG4gICAgICAgICAgbmFtZTogdG9vbC5uYW1lLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiB0b29sLmRlc2NyaXB0aW9uLFxuICAgICAgICAgIHBhcmFtZXRlcnM6IHRvb2wucGFyYW1ldGVyc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRvb2xDaG9pY2UgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZnVuY3Rpb25zOiBvcGVuYWlGdW5jdGlvbnMsXG4gICAgICAgIGZ1bmN0aW9uX2NhbGw6IHZvaWQgMCxcbiAgICAgICAgdG9vbFdhcm5pbmdzXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCB0eXBlMiA9IHRvb2xDaG9pY2UudHlwZTtcbiAgICBzd2l0Y2ggKHR5cGUyKSB7XG4gICAgICBjYXNlIFwiYXV0b1wiOlxuICAgICAgY2FzZSBcIm5vbmVcIjpcbiAgICAgIGNhc2Ugdm9pZCAwOlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGZ1bmN0aW9uczogb3BlbmFpRnVuY3Rpb25zLFxuICAgICAgICAgIGZ1bmN0aW9uX2NhbGw6IHZvaWQgMCxcbiAgICAgICAgICB0b29sV2FybmluZ3NcbiAgICAgICAgfTtcbiAgICAgIGNhc2UgXCJyZXF1aXJlZFwiOlxuICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3IyKHtcbiAgICAgICAgICBmdW5jdGlvbmFsaXR5OiBcInVzZUxlZ2FjeUZ1bmN0aW9uQ2FsbGluZyBhbmQgdG9vbENob2ljZTogcmVxdWlyZWRcIlxuICAgICAgICB9KTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZnVuY3Rpb25zOiBvcGVuYWlGdW5jdGlvbnMsXG4gICAgICAgICAgZnVuY3Rpb25fY2FsbDogeyBuYW1lOiB0b29sQ2hvaWNlLnRvb2xOYW1lIH0sXG4gICAgICAgICAgdG9vbFdhcm5pbmdzXG4gICAgICAgIH07XG4gICAgfVxuICB9XG4gIGNvbnN0IG9wZW5haVRvb2xzMiA9IFtdO1xuICBmb3IgKGNvbnN0IHRvb2wgb2YgdG9vbHMpIHtcbiAgICBpZiAodG9vbC50eXBlID09PSBcInByb3ZpZGVyLWRlZmluZWRcIikge1xuICAgICAgdG9vbFdhcm5pbmdzLnB1c2goeyB0eXBlOiBcInVuc3VwcG9ydGVkLXRvb2xcIiwgdG9vbCB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3BlbmFpVG9vbHMyLnB1c2goe1xuICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgIGZ1bmN0aW9uOiB7XG4gICAgICAgICAgbmFtZTogdG9vbC5uYW1lLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiB0b29sLmRlc2NyaXB0aW9uLFxuICAgICAgICAgIHBhcmFtZXRlcnM6IHRvb2wucGFyYW1ldGVycyxcbiAgICAgICAgICBzdHJpY3Q6IHN0cnVjdHVyZWRPdXRwdXRzID8gdHJ1ZSA6IHZvaWQgMFxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKHRvb2xDaG9pY2UgPT0gbnVsbCkge1xuICAgIHJldHVybiB7IHRvb2xzOiBvcGVuYWlUb29sczIsIHRvb2xfY2hvaWNlOiB2b2lkIDAsIHRvb2xXYXJuaW5ncyB9O1xuICB9XG4gIGNvbnN0IHR5cGUgPSB0b29sQ2hvaWNlLnR5cGU7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgXCJhdXRvXCI6XG4gICAgY2FzZSBcIm5vbmVcIjpcbiAgICBjYXNlIFwicmVxdWlyZWRcIjpcbiAgICAgIHJldHVybiB7IHRvb2xzOiBvcGVuYWlUb29sczIsIHRvb2xfY2hvaWNlOiB0eXBlLCB0b29sV2FybmluZ3MgfTtcbiAgICBjYXNlIFwidG9vbFwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG9vbHM6IG9wZW5haVRvb2xzMixcbiAgICAgICAgdG9vbF9jaG9pY2U6IHtcbiAgICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgZnVuY3Rpb246IHtcbiAgICAgICAgICAgIG5hbWU6IHRvb2xDaG9pY2UudG9vbE5hbWVcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHRvb2xXYXJuaW5nc1xuICAgICAgfTtcbiAgICBkZWZhdWx0OiB7XG4gICAgICBjb25zdCBfZXhoYXVzdGl2ZUNoZWNrID0gdHlwZTtcbiAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvcjIoe1xuICAgICAgICBmdW5jdGlvbmFsaXR5OiBgVW5zdXBwb3J0ZWQgdG9vbCBjaG9pY2UgdHlwZTogJHtfZXhoYXVzdGl2ZUNoZWNrfWBcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuXG4vLyBzcmMvb3BlbmFpLWNoYXQtbGFuZ3VhZ2UtbW9kZWwudHNcbnZhciBPcGVuQUlDaGF0TGFuZ3VhZ2VNb2RlbCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IobW9kZWxJZCwgc2V0dGluZ3MsIGNvbmZpZykge1xuICAgIHRoaXMuc3BlY2lmaWNhdGlvblZlcnNpb24gPSBcInYxXCI7XG4gICAgdGhpcy5tb2RlbElkID0gbW9kZWxJZDtcbiAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gIH1cbiAgZ2V0IHN1cHBvcnRzU3RydWN0dXJlZE91dHB1dHMoKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoX2EgPSB0aGlzLnNldHRpbmdzLnN0cnVjdHVyZWRPdXRwdXRzKSAhPSBudWxsID8gX2EgOiBpc1JlYXNvbmluZ01vZGVsKHRoaXMubW9kZWxJZCk7XG4gIH1cbiAgZ2V0IGRlZmF1bHRPYmplY3RHZW5lcmF0aW9uTW9kZSgpIHtcbiAgICBpZiAoaXNBdWRpb01vZGVsKHRoaXMubW9kZWxJZCkpIHtcbiAgICAgIHJldHVybiBcInRvb2xcIjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc3VwcG9ydHNTdHJ1Y3R1cmVkT3V0cHV0cyA/IFwianNvblwiIDogXCJ0b29sXCI7XG4gIH1cbiAgZ2V0IHByb3ZpZGVyKCkge1xuICAgIHJldHVybiB0aGlzLmNvbmZpZy5wcm92aWRlcjtcbiAgfVxuICBnZXQgc3VwcG9ydHNJbWFnZVVybHMoKSB7XG4gICAgcmV0dXJuICF0aGlzLnNldHRpbmdzLmRvd25sb2FkSW1hZ2VzO1xuICB9XG4gIGdldEFyZ3Moe1xuICAgIG1vZGUsXG4gICAgcHJvbXB0LFxuICAgIG1heFRva2VucyxcbiAgICB0ZW1wZXJhdHVyZSxcbiAgICB0b3BQLFxuICAgIHRvcEssXG4gICAgZnJlcXVlbmN5UGVuYWx0eSxcbiAgICBwcmVzZW5jZVBlbmFsdHksXG4gICAgc3RvcFNlcXVlbmNlcyxcbiAgICByZXNwb25zZUZvcm1hdCxcbiAgICBzZWVkLFxuICAgIHByb3ZpZGVyTWV0YWRhdGFcbiAgfSkge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2g7XG4gICAgY29uc3QgdHlwZSA9IG1vZGUudHlwZTtcbiAgICBjb25zdCB3YXJuaW5ncyA9IFtdO1xuICAgIGlmICh0b3BLICE9IG51bGwpIHtcbiAgICAgIHdhcm5pbmdzLnB1c2goe1xuICAgICAgICB0eXBlOiBcInVuc3VwcG9ydGVkLXNldHRpbmdcIixcbiAgICAgICAgc2V0dGluZzogXCJ0b3BLXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoKHJlc3BvbnNlRm9ybWF0ID09IG51bGwgPyB2b2lkIDAgOiByZXNwb25zZUZvcm1hdC50eXBlKSA9PT0gXCJqc29uXCIgJiYgcmVzcG9uc2VGb3JtYXQuc2NoZW1hICE9IG51bGwgJiYgIXRoaXMuc3VwcG9ydHNTdHJ1Y3R1cmVkT3V0cHV0cykge1xuICAgICAgd2FybmluZ3MucHVzaCh7XG4gICAgICAgIHR5cGU6IFwidW5zdXBwb3J0ZWQtc2V0dGluZ1wiLFxuICAgICAgICBzZXR0aW5nOiBcInJlc3BvbnNlRm9ybWF0XCIsXG4gICAgICAgIGRldGFpbHM6IFwiSlNPTiByZXNwb25zZSBmb3JtYXQgc2NoZW1hIGlzIG9ubHkgc3VwcG9ydGVkIHdpdGggc3RydWN0dXJlZE91dHB1dHNcIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHVzZUxlZ2FjeUZ1bmN0aW9uQ2FsbGluZyA9IHRoaXMuc2V0dGluZ3MudXNlTGVnYWN5RnVuY3Rpb25DYWxsaW5nO1xuICAgIGlmICh1c2VMZWdhY3lGdW5jdGlvbkNhbGxpbmcgJiYgdGhpcy5zZXR0aW5ncy5wYXJhbGxlbFRvb2xDYWxscyA9PT0gdHJ1ZSkge1xuICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yMyh7XG4gICAgICAgIGZ1bmN0aW9uYWxpdHk6IFwidXNlTGVnYWN5RnVuY3Rpb25DYWxsaW5nIHdpdGggcGFyYWxsZWxUb29sQ2FsbHNcIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh1c2VMZWdhY3lGdW5jdGlvbkNhbGxpbmcgJiYgdGhpcy5zdXBwb3J0c1N0cnVjdHVyZWRPdXRwdXRzKSB7XG4gICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3IzKHtcbiAgICAgICAgZnVuY3Rpb25hbGl0eTogXCJzdHJ1Y3R1cmVkT3V0cHV0cyB3aXRoIHVzZUxlZ2FjeUZ1bmN0aW9uQ2FsbGluZ1wiXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgeyBtZXNzYWdlcywgd2FybmluZ3M6IG1lc3NhZ2VXYXJuaW5ncyB9ID0gY29udmVydFRvT3BlbkFJQ2hhdE1lc3NhZ2VzKFxuICAgICAge1xuICAgICAgICBwcm9tcHQsXG4gICAgICAgIHVzZUxlZ2FjeUZ1bmN0aW9uQ2FsbGluZyxcbiAgICAgICAgc3lzdGVtTWVzc2FnZU1vZGU6IGdldFN5c3RlbU1lc3NhZ2VNb2RlKHRoaXMubW9kZWxJZClcbiAgICAgIH1cbiAgICApO1xuICAgIHdhcm5pbmdzLnB1c2goLi4ubWVzc2FnZVdhcm5pbmdzKTtcbiAgICBjb25zdCBiYXNlQXJncyA9IHtcbiAgICAgIC8vIG1vZGVsIGlkOlxuICAgICAgbW9kZWw6IHRoaXMubW9kZWxJZCxcbiAgICAgIC8vIG1vZGVsIHNwZWNpZmljIHNldHRpbmdzOlxuICAgICAgbG9naXRfYmlhczogdGhpcy5zZXR0aW5ncy5sb2dpdEJpYXMsXG4gICAgICBsb2dwcm9iczogdGhpcy5zZXR0aW5ncy5sb2dwcm9icyA9PT0gdHJ1ZSB8fCB0eXBlb2YgdGhpcy5zZXR0aW5ncy5sb2dwcm9icyA9PT0gXCJudW1iZXJcIiA/IHRydWUgOiB2b2lkIDAsXG4gICAgICB0b3BfbG9ncHJvYnM6IHR5cGVvZiB0aGlzLnNldHRpbmdzLmxvZ3Byb2JzID09PSBcIm51bWJlclwiID8gdGhpcy5zZXR0aW5ncy5sb2dwcm9icyA6IHR5cGVvZiB0aGlzLnNldHRpbmdzLmxvZ3Byb2JzID09PSBcImJvb2xlYW5cIiA/IHRoaXMuc2V0dGluZ3MubG9ncHJvYnMgPyAwIDogdm9pZCAwIDogdm9pZCAwLFxuICAgICAgdXNlcjogdGhpcy5zZXR0aW5ncy51c2VyLFxuICAgICAgcGFyYWxsZWxfdG9vbF9jYWxsczogdGhpcy5zZXR0aW5ncy5wYXJhbGxlbFRvb2xDYWxscyxcbiAgICAgIC8vIHN0YW5kYXJkaXplZCBzZXR0aW5nczpcbiAgICAgIG1heF90b2tlbnM6IG1heFRva2VucyxcbiAgICAgIHRlbXBlcmF0dXJlLFxuICAgICAgdG9wX3A6IHRvcFAsXG4gICAgICBmcmVxdWVuY3lfcGVuYWx0eTogZnJlcXVlbmN5UGVuYWx0eSxcbiAgICAgIHByZXNlbmNlX3BlbmFsdHk6IHByZXNlbmNlUGVuYWx0eSxcbiAgICAgIHJlc3BvbnNlX2Zvcm1hdDogKHJlc3BvbnNlRm9ybWF0ID09IG51bGwgPyB2b2lkIDAgOiByZXNwb25zZUZvcm1hdC50eXBlKSA9PT0gXCJqc29uXCIgPyB0aGlzLnN1cHBvcnRzU3RydWN0dXJlZE91dHB1dHMgJiYgcmVzcG9uc2VGb3JtYXQuc2NoZW1hICE9IG51bGwgPyB7XG4gICAgICAgIHR5cGU6IFwianNvbl9zY2hlbWFcIixcbiAgICAgICAganNvbl9zY2hlbWE6IHtcbiAgICAgICAgICBzY2hlbWE6IHJlc3BvbnNlRm9ybWF0LnNjaGVtYSxcbiAgICAgICAgICBzdHJpY3Q6IHRydWUsXG4gICAgICAgICAgbmFtZTogKF9hID0gcmVzcG9uc2VGb3JtYXQubmFtZSkgIT0gbnVsbCA/IF9hIDogXCJyZXNwb25zZVwiLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiByZXNwb25zZUZvcm1hdC5kZXNjcmlwdGlvblxuICAgICAgICB9XG4gICAgICB9IDogeyB0eXBlOiBcImpzb25fb2JqZWN0XCIgfSA6IHZvaWQgMCxcbiAgICAgIHN0b3A6IHN0b3BTZXF1ZW5jZXMsXG4gICAgICBzZWVkLFxuICAgICAgLy8gb3BlbmFpIHNwZWNpZmljIHNldHRpbmdzOlxuICAgICAgLy8gVE9ETyByZW1vdmUgaW4gbmV4dCBtYWpvciB2ZXJzaW9uOyB3ZSBhdXRvLW1hcCBtYXhUb2tlbnMgbm93XG4gICAgICBtYXhfY29tcGxldGlvbl90b2tlbnM6IChfYiA9IHByb3ZpZGVyTWV0YWRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IHByb3ZpZGVyTWV0YWRhdGEub3BlbmFpKSA9PSBudWxsID8gdm9pZCAwIDogX2IubWF4Q29tcGxldGlvblRva2VucyxcbiAgICAgIHN0b3JlOiAoX2MgPSBwcm92aWRlck1ldGFkYXRhID09IG51bGwgPyB2b2lkIDAgOiBwcm92aWRlck1ldGFkYXRhLm9wZW5haSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLnN0b3JlLFxuICAgICAgbWV0YWRhdGE6IChfZCA9IHByb3ZpZGVyTWV0YWRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IHByb3ZpZGVyTWV0YWRhdGEub3BlbmFpKSA9PSBudWxsID8gdm9pZCAwIDogX2QubWV0YWRhdGEsXG4gICAgICBwcmVkaWN0aW9uOiAoX2UgPSBwcm92aWRlck1ldGFkYXRhID09IG51bGwgPyB2b2lkIDAgOiBwcm92aWRlck1ldGFkYXRhLm9wZW5haSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lLnByZWRpY3Rpb24sXG4gICAgICByZWFzb25pbmdfZWZmb3J0OiAoX2cgPSAoX2YgPSBwcm92aWRlck1ldGFkYXRhID09IG51bGwgPyB2b2lkIDAgOiBwcm92aWRlck1ldGFkYXRhLm9wZW5haSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9mLnJlYXNvbmluZ0VmZm9ydCkgIT0gbnVsbCA/IF9nIDogdGhpcy5zZXR0aW5ncy5yZWFzb25pbmdFZmZvcnQsXG4gICAgICAvLyBtZXNzYWdlczpcbiAgICAgIG1lc3NhZ2VzXG4gICAgfTtcbiAgICBpZiAoaXNSZWFzb25pbmdNb2RlbCh0aGlzLm1vZGVsSWQpKSB7XG4gICAgICBpZiAoYmFzZUFyZ3MudGVtcGVyYXR1cmUgIT0gbnVsbCkge1xuICAgICAgICBiYXNlQXJncy50ZW1wZXJhdHVyZSA9IHZvaWQgMDtcbiAgICAgICAgd2FybmluZ3MucHVzaCh7XG4gICAgICAgICAgdHlwZTogXCJ1bnN1cHBvcnRlZC1zZXR0aW5nXCIsXG4gICAgICAgICAgc2V0dGluZzogXCJ0ZW1wZXJhdHVyZVwiLFxuICAgICAgICAgIGRldGFpbHM6IFwidGVtcGVyYXR1cmUgaXMgbm90IHN1cHBvcnRlZCBmb3IgcmVhc29uaW5nIG1vZGVsc1wiXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKGJhc2VBcmdzLnRvcF9wICE9IG51bGwpIHtcbiAgICAgICAgYmFzZUFyZ3MudG9wX3AgPSB2b2lkIDA7XG4gICAgICAgIHdhcm5pbmdzLnB1c2goe1xuICAgICAgICAgIHR5cGU6IFwidW5zdXBwb3J0ZWQtc2V0dGluZ1wiLFxuICAgICAgICAgIHNldHRpbmc6IFwidG9wUFwiLFxuICAgICAgICAgIGRldGFpbHM6IFwidG9wUCBpcyBub3Qgc3VwcG9ydGVkIGZvciByZWFzb25pbmcgbW9kZWxzXCJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoYmFzZUFyZ3MuZnJlcXVlbmN5X3BlbmFsdHkgIT0gbnVsbCkge1xuICAgICAgICBiYXNlQXJncy5mcmVxdWVuY3lfcGVuYWx0eSA9IHZvaWQgMDtcbiAgICAgICAgd2FybmluZ3MucHVzaCh7XG4gICAgICAgICAgdHlwZTogXCJ1bnN1cHBvcnRlZC1zZXR0aW5nXCIsXG4gICAgICAgICAgc2V0dGluZzogXCJmcmVxdWVuY3lQZW5hbHR5XCIsXG4gICAgICAgICAgZGV0YWlsczogXCJmcmVxdWVuY3lQZW5hbHR5IGlzIG5vdCBzdXBwb3J0ZWQgZm9yIHJlYXNvbmluZyBtb2RlbHNcIlxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChiYXNlQXJncy5wcmVzZW5jZV9wZW5hbHR5ICE9IG51bGwpIHtcbiAgICAgICAgYmFzZUFyZ3MucHJlc2VuY2VfcGVuYWx0eSA9IHZvaWQgMDtcbiAgICAgICAgd2FybmluZ3MucHVzaCh7XG4gICAgICAgICAgdHlwZTogXCJ1bnN1cHBvcnRlZC1zZXR0aW5nXCIsXG4gICAgICAgICAgc2V0dGluZzogXCJwcmVzZW5jZVBlbmFsdHlcIixcbiAgICAgICAgICBkZXRhaWxzOiBcInByZXNlbmNlUGVuYWx0eSBpcyBub3Qgc3VwcG9ydGVkIGZvciByZWFzb25pbmcgbW9kZWxzXCJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoYmFzZUFyZ3MubG9naXRfYmlhcyAhPSBudWxsKSB7XG4gICAgICAgIGJhc2VBcmdzLmxvZ2l0X2JpYXMgPSB2b2lkIDA7XG4gICAgICAgIHdhcm5pbmdzLnB1c2goe1xuICAgICAgICAgIHR5cGU6IFwib3RoZXJcIixcbiAgICAgICAgICBtZXNzYWdlOiBcImxvZ2l0QmlhcyBpcyBub3Qgc3VwcG9ydGVkIGZvciByZWFzb25pbmcgbW9kZWxzXCJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoYmFzZUFyZ3MubG9ncHJvYnMgIT0gbnVsbCkge1xuICAgICAgICBiYXNlQXJncy5sb2dwcm9icyA9IHZvaWQgMDtcbiAgICAgICAgd2FybmluZ3MucHVzaCh7XG4gICAgICAgICAgdHlwZTogXCJvdGhlclwiLFxuICAgICAgICAgIG1lc3NhZ2U6IFwibG9ncHJvYnMgaXMgbm90IHN1cHBvcnRlZCBmb3IgcmVhc29uaW5nIG1vZGVsc1wiXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKGJhc2VBcmdzLnRvcF9sb2dwcm9icyAhPSBudWxsKSB7XG4gICAgICAgIGJhc2VBcmdzLnRvcF9sb2dwcm9icyA9IHZvaWQgMDtcbiAgICAgICAgd2FybmluZ3MucHVzaCh7XG4gICAgICAgICAgdHlwZTogXCJvdGhlclwiLFxuICAgICAgICAgIG1lc3NhZ2U6IFwidG9wTG9ncHJvYnMgaXMgbm90IHN1cHBvcnRlZCBmb3IgcmVhc29uaW5nIG1vZGVsc1wiXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKGJhc2VBcmdzLm1heF90b2tlbnMgIT0gbnVsbCkge1xuICAgICAgICBpZiAoYmFzZUFyZ3MubWF4X2NvbXBsZXRpb25fdG9rZW5zID09IG51bGwpIHtcbiAgICAgICAgICBiYXNlQXJncy5tYXhfY29tcGxldGlvbl90b2tlbnMgPSBiYXNlQXJncy5tYXhfdG9rZW5zO1xuICAgICAgICB9XG4gICAgICAgIGJhc2VBcmdzLm1heF90b2tlbnMgPSB2b2lkIDA7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLm1vZGVsSWQuc3RhcnRzV2l0aChcImdwdC00by1zZWFyY2gtcHJldmlld1wiKSB8fCB0aGlzLm1vZGVsSWQuc3RhcnRzV2l0aChcImdwdC00by1taW5pLXNlYXJjaC1wcmV2aWV3XCIpKSB7XG4gICAgICBpZiAoYmFzZUFyZ3MudGVtcGVyYXR1cmUgIT0gbnVsbCkge1xuICAgICAgICBiYXNlQXJncy50ZW1wZXJhdHVyZSA9IHZvaWQgMDtcbiAgICAgICAgd2FybmluZ3MucHVzaCh7XG4gICAgICAgICAgdHlwZTogXCJ1bnN1cHBvcnRlZC1zZXR0aW5nXCIsXG4gICAgICAgICAgc2V0dGluZzogXCJ0ZW1wZXJhdHVyZVwiLFxuICAgICAgICAgIGRldGFpbHM6IFwidGVtcGVyYXR1cmUgaXMgbm90IHN1cHBvcnRlZCBmb3IgdGhlIHNlYXJjaCBwcmV2aWV3IG1vZGVscyBhbmQgaGFzIGJlZW4gcmVtb3ZlZC5cIlxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFwicmVndWxhclwiOiB7XG4gICAgICAgIGNvbnN0IHsgdG9vbHMsIHRvb2xfY2hvaWNlLCBmdW5jdGlvbnMsIGZ1bmN0aW9uX2NhbGwsIHRvb2xXYXJuaW5ncyB9ID0gcHJlcGFyZVRvb2xzKHtcbiAgICAgICAgICBtb2RlLFxuICAgICAgICAgIHVzZUxlZ2FjeUZ1bmN0aW9uQ2FsbGluZyxcbiAgICAgICAgICBzdHJ1Y3R1cmVkT3V0cHV0czogdGhpcy5zdXBwb3J0c1N0cnVjdHVyZWRPdXRwdXRzXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGFyZ3M6IHtcbiAgICAgICAgICAgIC4uLmJhc2VBcmdzLFxuICAgICAgICAgICAgdG9vbHMsXG4gICAgICAgICAgICB0b29sX2Nob2ljZSxcbiAgICAgICAgICAgIGZ1bmN0aW9ucyxcbiAgICAgICAgICAgIGZ1bmN0aW9uX2NhbGxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHdhcm5pbmdzOiBbLi4ud2FybmluZ3MsIC4uLnRvb2xXYXJuaW5nc11cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJvYmplY3QtanNvblwiOiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYXJnczoge1xuICAgICAgICAgICAgLi4uYmFzZUFyZ3MsXG4gICAgICAgICAgICByZXNwb25zZV9mb3JtYXQ6IHRoaXMuc3VwcG9ydHNTdHJ1Y3R1cmVkT3V0cHV0cyAmJiBtb2RlLnNjaGVtYSAhPSBudWxsID8ge1xuICAgICAgICAgICAgICB0eXBlOiBcImpzb25fc2NoZW1hXCIsXG4gICAgICAgICAgICAgIGpzb25fc2NoZW1hOiB7XG4gICAgICAgICAgICAgICAgc2NoZW1hOiBtb2RlLnNjaGVtYSxcbiAgICAgICAgICAgICAgICBzdHJpY3Q6IHRydWUsXG4gICAgICAgICAgICAgICAgbmFtZTogKF9oID0gbW9kZS5uYW1lKSAhPSBudWxsID8gX2ggOiBcInJlc3BvbnNlXCIsXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IG1vZGUuZGVzY3JpcHRpb25cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSA6IHsgdHlwZTogXCJqc29uX29iamVjdFwiIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHdhcm5pbmdzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjYXNlIFwib2JqZWN0LXRvb2xcIjoge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGFyZ3M6IHVzZUxlZ2FjeUZ1bmN0aW9uQ2FsbGluZyA/IHtcbiAgICAgICAgICAgIC4uLmJhc2VBcmdzLFxuICAgICAgICAgICAgZnVuY3Rpb25fY2FsbDoge1xuICAgICAgICAgICAgICBuYW1lOiBtb2RlLnRvb2wubmFtZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uczogW1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogbW9kZS50b29sLm5hbWUsXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IG1vZGUudG9vbC5kZXNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiBtb2RlLnRvb2wucGFyYW1ldGVyc1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgICAgfSA6IHtcbiAgICAgICAgICAgIC4uLmJhc2VBcmdzLFxuICAgICAgICAgICAgdG9vbF9jaG9pY2U6IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgICBmdW5jdGlvbjogeyBuYW1lOiBtb2RlLnRvb2wubmFtZSB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdG9vbHM6IFtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgICAgICBmdW5jdGlvbjoge1xuICAgICAgICAgICAgICAgICAgbmFtZTogbW9kZS50b29sLm5hbWUsXG4gICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogbW9kZS50b29sLmRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgICAgcGFyYW1ldGVyczogbW9kZS50b29sLnBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgICBzdHJpY3Q6IHRoaXMuc3VwcG9ydHNTdHJ1Y3R1cmVkT3V0cHV0cyA/IHRydWUgOiB2b2lkIDBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHdhcm5pbmdzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIGNvbnN0IF9leGhhdXN0aXZlQ2hlY2sgPSB0eXBlO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHR5cGU6ICR7X2V4aGF1c3RpdmVDaGVja31gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgYXN5bmMgZG9HZW5lcmF0ZShvcHRpb25zKSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaDtcbiAgICBjb25zdCB7IGFyZ3M6IGJvZHksIHdhcm5pbmdzIH0gPSB0aGlzLmdldEFyZ3Mob3B0aW9ucyk7XG4gICAgY29uc3Qge1xuICAgICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgdmFsdWU6IHJlc3BvbnNlLFxuICAgICAgcmF3VmFsdWU6IHJhd1Jlc3BvbnNlXG4gICAgfSA9IGF3YWl0IHBvc3RKc29uVG9BcGkoe1xuICAgICAgdXJsOiB0aGlzLmNvbmZpZy51cmwoe1xuICAgICAgICBwYXRoOiBcIi9jaGF0L2NvbXBsZXRpb25zXCIsXG4gICAgICAgIG1vZGVsSWQ6IHRoaXMubW9kZWxJZFxuICAgICAgfSksXG4gICAgICBoZWFkZXJzOiBjb21iaW5lSGVhZGVycyh0aGlzLmNvbmZpZy5oZWFkZXJzKCksIG9wdGlvbnMuaGVhZGVycyksXG4gICAgICBib2R5LFxuICAgICAgZmFpbGVkUmVzcG9uc2VIYW5kbGVyOiBvcGVuYWlGYWlsZWRSZXNwb25zZUhhbmRsZXIsXG4gICAgICBzdWNjZXNzZnVsUmVzcG9uc2VIYW5kbGVyOiBjcmVhdGVKc29uUmVzcG9uc2VIYW5kbGVyKFxuICAgICAgICBvcGVuYWlDaGF0UmVzcG9uc2VTY2hlbWFcbiAgICAgICksXG4gICAgICBhYm9ydFNpZ25hbDogb3B0aW9ucy5hYm9ydFNpZ25hbCxcbiAgICAgIGZldGNoOiB0aGlzLmNvbmZpZy5mZXRjaFxuICAgIH0pO1xuICAgIGNvbnN0IHsgbWVzc2FnZXM6IHJhd1Byb21wdCwgLi4ucmF3U2V0dGluZ3MgfSA9IGJvZHk7XG4gICAgY29uc3QgY2hvaWNlID0gcmVzcG9uc2UuY2hvaWNlc1swXTtcbiAgICBjb25zdCBjb21wbGV0aW9uVG9rZW5EZXRhaWxzID0gKF9hID0gcmVzcG9uc2UudXNhZ2UpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jb21wbGV0aW9uX3Rva2Vuc19kZXRhaWxzO1xuICAgIGNvbnN0IHByb21wdFRva2VuRGV0YWlscyA9IChfYiA9IHJlc3BvbnNlLnVzYWdlKSA9PSBudWxsID8gdm9pZCAwIDogX2IucHJvbXB0X3Rva2Vuc19kZXRhaWxzO1xuICAgIGNvbnN0IHByb3ZpZGVyTWV0YWRhdGEgPSB7IG9wZW5haToge30gfTtcbiAgICBpZiAoKGNvbXBsZXRpb25Ub2tlbkRldGFpbHMgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbXBsZXRpb25Ub2tlbkRldGFpbHMucmVhc29uaW5nX3Rva2VucykgIT0gbnVsbCkge1xuICAgICAgcHJvdmlkZXJNZXRhZGF0YS5vcGVuYWkucmVhc29uaW5nVG9rZW5zID0gY29tcGxldGlvblRva2VuRGV0YWlscyA9PSBudWxsID8gdm9pZCAwIDogY29tcGxldGlvblRva2VuRGV0YWlscy5yZWFzb25pbmdfdG9rZW5zO1xuICAgIH1cbiAgICBpZiAoKGNvbXBsZXRpb25Ub2tlbkRldGFpbHMgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbXBsZXRpb25Ub2tlbkRldGFpbHMuYWNjZXB0ZWRfcHJlZGljdGlvbl90b2tlbnMpICE9IG51bGwpIHtcbiAgICAgIHByb3ZpZGVyTWV0YWRhdGEub3BlbmFpLmFjY2VwdGVkUHJlZGljdGlvblRva2VucyA9IGNvbXBsZXRpb25Ub2tlbkRldGFpbHMgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbXBsZXRpb25Ub2tlbkRldGFpbHMuYWNjZXB0ZWRfcHJlZGljdGlvbl90b2tlbnM7XG4gICAgfVxuICAgIGlmICgoY29tcGxldGlvblRva2VuRGV0YWlscyA9PSBudWxsID8gdm9pZCAwIDogY29tcGxldGlvblRva2VuRGV0YWlscy5yZWplY3RlZF9wcmVkaWN0aW9uX3Rva2VucykgIT0gbnVsbCkge1xuICAgICAgcHJvdmlkZXJNZXRhZGF0YS5vcGVuYWkucmVqZWN0ZWRQcmVkaWN0aW9uVG9rZW5zID0gY29tcGxldGlvblRva2VuRGV0YWlscyA9PSBudWxsID8gdm9pZCAwIDogY29tcGxldGlvblRva2VuRGV0YWlscy5yZWplY3RlZF9wcmVkaWN0aW9uX3Rva2VucztcbiAgICB9XG4gICAgaWYgKChwcm9tcHRUb2tlbkRldGFpbHMgPT0gbnVsbCA/IHZvaWQgMCA6IHByb21wdFRva2VuRGV0YWlscy5jYWNoZWRfdG9rZW5zKSAhPSBudWxsKSB7XG4gICAgICBwcm92aWRlck1ldGFkYXRhLm9wZW5haS5jYWNoZWRQcm9tcHRUb2tlbnMgPSBwcm9tcHRUb2tlbkRldGFpbHMgPT0gbnVsbCA/IHZvaWQgMCA6IHByb21wdFRva2VuRGV0YWlscy5jYWNoZWRfdG9rZW5zO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdGV4dDogKF9jID0gY2hvaWNlLm1lc3NhZ2UuY29udGVudCkgIT0gbnVsbCA/IF9jIDogdm9pZCAwLFxuICAgICAgdG9vbENhbGxzOiB0aGlzLnNldHRpbmdzLnVzZUxlZ2FjeUZ1bmN0aW9uQ2FsbGluZyAmJiBjaG9pY2UubWVzc2FnZS5mdW5jdGlvbl9jYWxsID8gW1xuICAgICAgICB7XG4gICAgICAgICAgdG9vbENhbGxUeXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgdG9vbENhbGxJZDogZ2VuZXJhdGVJZCgpLFxuICAgICAgICAgIHRvb2xOYW1lOiBjaG9pY2UubWVzc2FnZS5mdW5jdGlvbl9jYWxsLm5hbWUsXG4gICAgICAgICAgYXJnczogY2hvaWNlLm1lc3NhZ2UuZnVuY3Rpb25fY2FsbC5hcmd1bWVudHNcbiAgICAgICAgfVxuICAgICAgXSA6IChfZCA9IGNob2ljZS5tZXNzYWdlLnRvb2xfY2FsbHMpID09IG51bGwgPyB2b2lkIDAgOiBfZC5tYXAoKHRvb2xDYWxsKSA9PiB7XG4gICAgICAgIHZhciBfYTI7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdG9vbENhbGxUeXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgdG9vbENhbGxJZDogKF9hMiA9IHRvb2xDYWxsLmlkKSAhPSBudWxsID8gX2EyIDogZ2VuZXJhdGVJZCgpLFxuICAgICAgICAgIHRvb2xOYW1lOiB0b29sQ2FsbC5mdW5jdGlvbi5uYW1lLFxuICAgICAgICAgIGFyZ3M6IHRvb2xDYWxsLmZ1bmN0aW9uLmFyZ3VtZW50c1xuICAgICAgICB9O1xuICAgICAgfSksXG4gICAgICBmaW5pc2hSZWFzb246IG1hcE9wZW5BSUZpbmlzaFJlYXNvbihjaG9pY2UuZmluaXNoX3JlYXNvbiksXG4gICAgICB1c2FnZToge1xuICAgICAgICBwcm9tcHRUb2tlbnM6IChfZiA9IChfZSA9IHJlc3BvbnNlLnVzYWdlKSA9PSBudWxsID8gdm9pZCAwIDogX2UucHJvbXB0X3Rva2VucykgIT0gbnVsbCA/IF9mIDogTmFOLFxuICAgICAgICBjb21wbGV0aW9uVG9rZW5zOiAoX2ggPSAoX2cgPSByZXNwb25zZS51c2FnZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9nLmNvbXBsZXRpb25fdG9rZW5zKSAhPSBudWxsID8gX2ggOiBOYU5cbiAgICAgIH0sXG4gICAgICByYXdDYWxsOiB7IHJhd1Byb21wdCwgcmF3U2V0dGluZ3MgfSxcbiAgICAgIHJhd1Jlc3BvbnNlOiB7IGhlYWRlcnM6IHJlc3BvbnNlSGVhZGVycywgYm9keTogcmF3UmVzcG9uc2UgfSxcbiAgICAgIHJlcXVlc3Q6IHsgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSkgfSxcbiAgICAgIHJlc3BvbnNlOiBnZXRSZXNwb25zZU1ldGFkYXRhKHJlc3BvbnNlKSxcbiAgICAgIHdhcm5pbmdzLFxuICAgICAgbG9ncHJvYnM6IG1hcE9wZW5BSUNoYXRMb2dQcm9ic091dHB1dChjaG9pY2UubG9ncHJvYnMpLFxuICAgICAgcHJvdmlkZXJNZXRhZGF0YVxuICAgIH07XG4gIH1cbiAgYXN5bmMgZG9TdHJlYW0ob3B0aW9ucykge1xuICAgIGlmICh0aGlzLnNldHRpbmdzLnNpbXVsYXRlU3RyZWFtaW5nKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmRvR2VuZXJhdGUob3B0aW9ucyk7XG4gICAgICBjb25zdCBzaW11bGF0ZWRTdHJlYW0gPSBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgICBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHsgdHlwZTogXCJyZXNwb25zZS1tZXRhZGF0YVwiLCAuLi5yZXN1bHQucmVzcG9uc2UgfSk7XG4gICAgICAgICAgaWYgKHJlc3VsdC50ZXh0KSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICB0eXBlOiBcInRleHQtZGVsdGFcIixcbiAgICAgICAgICAgICAgdGV4dERlbHRhOiByZXN1bHQudGV4dFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQudG9vbENhbGxzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRvb2xDYWxsIG9mIHJlc3VsdC50b29sQ2FsbHMpIHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtY2FsbC1kZWx0YVwiLFxuICAgICAgICAgICAgICAgIHRvb2xDYWxsVHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHRvb2xDYWxsLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgdG9vbE5hbWU6IHRvb2xDYWxsLnRvb2xOYW1lLFxuICAgICAgICAgICAgICAgIGFyZ3NUZXh0RGVsdGE6IHRvb2xDYWxsLmFyZ3NcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLWNhbGxcIixcbiAgICAgICAgICAgICAgICAuLi50b29sQ2FsbFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgIHR5cGU6IFwiZmluaXNoXCIsXG4gICAgICAgICAgICBmaW5pc2hSZWFzb246IHJlc3VsdC5maW5pc2hSZWFzb24sXG4gICAgICAgICAgICB1c2FnZTogcmVzdWx0LnVzYWdlLFxuICAgICAgICAgICAgbG9ncHJvYnM6IHJlc3VsdC5sb2dwcm9icyxcbiAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IHJlc3VsdC5wcm92aWRlck1ldGFkYXRhXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0cmVhbTogc2ltdWxhdGVkU3RyZWFtLFxuICAgICAgICByYXdDYWxsOiByZXN1bHQucmF3Q2FsbCxcbiAgICAgICAgcmF3UmVzcG9uc2U6IHJlc3VsdC5yYXdSZXNwb25zZSxcbiAgICAgICAgd2FybmluZ3M6IHJlc3VsdC53YXJuaW5nc1xuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgeyBhcmdzLCB3YXJuaW5ncyB9ID0gdGhpcy5nZXRBcmdzKG9wdGlvbnMpO1xuICAgIGNvbnN0IGJvZHkgPSB7XG4gICAgICAuLi5hcmdzLFxuICAgICAgc3RyZWFtOiB0cnVlLFxuICAgICAgLy8gb25seSBpbmNsdWRlIHN0cmVhbV9vcHRpb25zIHdoZW4gaW4gc3RyaWN0IGNvbXBhdGliaWxpdHkgbW9kZTpcbiAgICAgIHN0cmVhbV9vcHRpb25zOiB0aGlzLmNvbmZpZy5jb21wYXRpYmlsaXR5ID09PSBcInN0cmljdFwiID8geyBpbmNsdWRlX3VzYWdlOiB0cnVlIH0gOiB2b2lkIDBcbiAgICB9O1xuICAgIGNvbnN0IHsgcmVzcG9uc2VIZWFkZXJzLCB2YWx1ZTogcmVzcG9uc2UgfSA9IGF3YWl0IHBvc3RKc29uVG9BcGkoe1xuICAgICAgdXJsOiB0aGlzLmNvbmZpZy51cmwoe1xuICAgICAgICBwYXRoOiBcIi9jaGF0L2NvbXBsZXRpb25zXCIsXG4gICAgICAgIG1vZGVsSWQ6IHRoaXMubW9kZWxJZFxuICAgICAgfSksXG4gICAgICBoZWFkZXJzOiBjb21iaW5lSGVhZGVycyh0aGlzLmNvbmZpZy5oZWFkZXJzKCksIG9wdGlvbnMuaGVhZGVycyksXG4gICAgICBib2R5LFxuICAgICAgZmFpbGVkUmVzcG9uc2VIYW5kbGVyOiBvcGVuYWlGYWlsZWRSZXNwb25zZUhhbmRsZXIsXG4gICAgICBzdWNjZXNzZnVsUmVzcG9uc2VIYW5kbGVyOiBjcmVhdGVFdmVudFNvdXJjZVJlc3BvbnNlSGFuZGxlcihcbiAgICAgICAgb3BlbmFpQ2hhdENodW5rU2NoZW1hXG4gICAgICApLFxuICAgICAgYWJvcnRTaWduYWw6IG9wdGlvbnMuYWJvcnRTaWduYWwsXG4gICAgICBmZXRjaDogdGhpcy5jb25maWcuZmV0Y2hcbiAgICB9KTtcbiAgICBjb25zdCB7IG1lc3NhZ2VzOiByYXdQcm9tcHQsIC4uLnJhd1NldHRpbmdzIH0gPSBhcmdzO1xuICAgIGNvbnN0IHRvb2xDYWxscyA9IFtdO1xuICAgIGxldCBmaW5pc2hSZWFzb24gPSBcInVua25vd25cIjtcbiAgICBsZXQgdXNhZ2UgPSB7XG4gICAgICBwcm9tcHRUb2tlbnM6IHZvaWQgMCxcbiAgICAgIGNvbXBsZXRpb25Ub2tlbnM6IHZvaWQgMFxuICAgIH07XG4gICAgbGV0IGxvZ3Byb2JzO1xuICAgIGxldCBpc0ZpcnN0Q2h1bmsgPSB0cnVlO1xuICAgIGNvbnN0IHsgdXNlTGVnYWN5RnVuY3Rpb25DYWxsaW5nIH0gPSB0aGlzLnNldHRpbmdzO1xuICAgIGNvbnN0IHByb3ZpZGVyTWV0YWRhdGEgPSB7IG9wZW5haToge30gfTtcbiAgICByZXR1cm4ge1xuICAgICAgc3RyZWFtOiByZXNwb25zZS5waXBlVGhyb3VnaChcbiAgICAgICAgbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICAgICAgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfaSwgX2osIF9rLCBfbDtcbiAgICAgICAgICAgIGlmICghY2h1bmsuc3VjY2Vzcykge1xuICAgICAgICAgICAgICBmaW5pc2hSZWFzb24gPSBcImVycm9yXCI7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7IHR5cGU6IFwiZXJyb3JcIiwgZXJyb3I6IGNodW5rLmVycm9yIH0pO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGNodW5rLnZhbHVlO1xuICAgICAgICAgICAgaWYgKFwiZXJyb3JcIiBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICBmaW5pc2hSZWFzb24gPSBcImVycm9yXCI7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7IHR5cGU6IFwiZXJyb3JcIiwgZXJyb3I6IHZhbHVlLmVycm9yIH0pO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNGaXJzdENodW5rKSB7XG4gICAgICAgICAgICAgIGlzRmlyc3RDaHVuayA9IGZhbHNlO1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwicmVzcG9uc2UtbWV0YWRhdGFcIixcbiAgICAgICAgICAgICAgICAuLi5nZXRSZXNwb25zZU1ldGFkYXRhKHZhbHVlKVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZS51c2FnZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgICBwcm9tcHRfdG9rZW5zLFxuICAgICAgICAgICAgICAgIGNvbXBsZXRpb25fdG9rZW5zLFxuICAgICAgICAgICAgICAgIHByb21wdF90b2tlbnNfZGV0YWlscyxcbiAgICAgICAgICAgICAgICBjb21wbGV0aW9uX3Rva2Vuc19kZXRhaWxzXG4gICAgICAgICAgICAgIH0gPSB2YWx1ZS51c2FnZTtcbiAgICAgICAgICAgICAgdXNhZ2UgPSB7XG4gICAgICAgICAgICAgICAgcHJvbXB0VG9rZW5zOiBwcm9tcHRfdG9rZW5zICE9IG51bGwgPyBwcm9tcHRfdG9rZW5zIDogdm9pZCAwLFxuICAgICAgICAgICAgICAgIGNvbXBsZXRpb25Ub2tlbnM6IGNvbXBsZXRpb25fdG9rZW5zICE9IG51bGwgPyBjb21wbGV0aW9uX3Rva2VucyA6IHZvaWQgMFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBpZiAoKGNvbXBsZXRpb25fdG9rZW5zX2RldGFpbHMgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbXBsZXRpb25fdG9rZW5zX2RldGFpbHMucmVhc29uaW5nX3Rva2VucykgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGEub3BlbmFpLnJlYXNvbmluZ1Rva2VucyA9IGNvbXBsZXRpb25fdG9rZW5zX2RldGFpbHMgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbXBsZXRpb25fdG9rZW5zX2RldGFpbHMucmVhc29uaW5nX3Rva2VucztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoKGNvbXBsZXRpb25fdG9rZW5zX2RldGFpbHMgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbXBsZXRpb25fdG9rZW5zX2RldGFpbHMuYWNjZXB0ZWRfcHJlZGljdGlvbl90b2tlbnMpICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhLm9wZW5haS5hY2NlcHRlZFByZWRpY3Rpb25Ub2tlbnMgPSBjb21wbGV0aW9uX3Rva2Vuc19kZXRhaWxzID09IG51bGwgPyB2b2lkIDAgOiBjb21wbGV0aW9uX3Rva2Vuc19kZXRhaWxzLmFjY2VwdGVkX3ByZWRpY3Rpb25fdG9rZW5zO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICgoY29tcGxldGlvbl90b2tlbnNfZGV0YWlscyA9PSBudWxsID8gdm9pZCAwIDogY29tcGxldGlvbl90b2tlbnNfZGV0YWlscy5yZWplY3RlZF9wcmVkaWN0aW9uX3Rva2VucykgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGEub3BlbmFpLnJlamVjdGVkUHJlZGljdGlvblRva2VucyA9IGNvbXBsZXRpb25fdG9rZW5zX2RldGFpbHMgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbXBsZXRpb25fdG9rZW5zX2RldGFpbHMucmVqZWN0ZWRfcHJlZGljdGlvbl90b2tlbnM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKChwcm9tcHRfdG9rZW5zX2RldGFpbHMgPT0gbnVsbCA/IHZvaWQgMCA6IHByb21wdF90b2tlbnNfZGV0YWlscy5jYWNoZWRfdG9rZW5zKSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YS5vcGVuYWkuY2FjaGVkUHJvbXB0VG9rZW5zID0gcHJvbXB0X3Rva2Vuc19kZXRhaWxzID09IG51bGwgPyB2b2lkIDAgOiBwcm9tcHRfdG9rZW5zX2RldGFpbHMuY2FjaGVkX3Rva2VucztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY2hvaWNlID0gdmFsdWUuY2hvaWNlc1swXTtcbiAgICAgICAgICAgIGlmICgoY2hvaWNlID09IG51bGwgPyB2b2lkIDAgOiBjaG9pY2UuZmluaXNoX3JlYXNvbikgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBmaW5pc2hSZWFzb24gPSBtYXBPcGVuQUlGaW5pc2hSZWFzb24oY2hvaWNlLmZpbmlzaF9yZWFzb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChjaG9pY2UgPT0gbnVsbCA/IHZvaWQgMCA6IGNob2ljZS5kZWx0YSkgPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkZWx0YSA9IGNob2ljZS5kZWx0YTtcbiAgICAgICAgICAgIGlmIChkZWx0YS5jb250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInRleHQtZGVsdGFcIixcbiAgICAgICAgICAgICAgICB0ZXh0RGVsdGE6IGRlbHRhLmNvbnRlbnRcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtYXBwZWRMb2dwcm9icyA9IG1hcE9wZW5BSUNoYXRMb2dQcm9ic091dHB1dChcbiAgICAgICAgICAgICAgY2hvaWNlID09IG51bGwgPyB2b2lkIDAgOiBjaG9pY2UubG9ncHJvYnNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAobWFwcGVkTG9ncHJvYnMgPT0gbnVsbCA/IHZvaWQgMCA6IG1hcHBlZExvZ3Byb2JzLmxlbmd0aCkge1xuICAgICAgICAgICAgICBpZiAobG9ncHJvYnMgPT09IHZvaWQgMCkgbG9ncHJvYnMgPSBbXTtcbiAgICAgICAgICAgICAgbG9ncHJvYnMucHVzaCguLi5tYXBwZWRMb2dwcm9icyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtYXBwZWRUb29sQ2FsbHMgPSB1c2VMZWdhY3lGdW5jdGlvbkNhbGxpbmcgJiYgZGVsdGEuZnVuY3Rpb25fY2FsbCAhPSBudWxsID8gW1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgIGlkOiBnZW5lcmF0ZUlkKCksXG4gICAgICAgICAgICAgICAgZnVuY3Rpb246IGRlbHRhLmZ1bmN0aW9uX2NhbGwsXG4gICAgICAgICAgICAgICAgaW5kZXg6IDBcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXSA6IGRlbHRhLnRvb2xfY2FsbHM7XG4gICAgICAgICAgICBpZiAobWFwcGVkVG9vbENhbGxzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgZm9yIChjb25zdCB0b29sQ2FsbERlbHRhIG9mIG1hcHBlZFRvb2xDYWxscykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gdG9vbENhbGxEZWx0YS5pbmRleDtcbiAgICAgICAgICAgICAgICBpZiAodG9vbENhbGxzW2luZGV4XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBpZiAodG9vbENhbGxEZWx0YS50eXBlICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRSZXNwb25zZURhdGFFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgZGF0YTogdG9vbENhbGxEZWx0YSxcbiAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBgRXhwZWN0ZWQgJ2Z1bmN0aW9uJyB0eXBlLmBcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAodG9vbENhbGxEZWx0YS5pZCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkUmVzcG9uc2VEYXRhRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHRvb2xDYWxsRGVsdGEsXG4gICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogYEV4cGVjdGVkICdpZCcgdG8gYmUgYSBzdHJpbmcuYFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmICgoKF9hID0gdG9vbENhbGxEZWx0YS5mdW5jdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLm5hbWUpID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRSZXNwb25zZURhdGFFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgZGF0YTogdG9vbENhbGxEZWx0YSxcbiAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBgRXhwZWN0ZWQgJ2Z1bmN0aW9uLm5hbWUnIHRvIGJlIGEgc3RyaW5nLmBcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB0b29sQ2FsbHNbaW5kZXhdID0ge1xuICAgICAgICAgICAgICAgICAgICBpZDogdG9vbENhbGxEZWx0YS5pZCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHRvb2xDYWxsRGVsdGEuZnVuY3Rpb24ubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHM6IChfYiA9IHRvb2xDYWxsRGVsdGEuZnVuY3Rpb24uYXJndW1lbnRzKSAhPSBudWxsID8gX2IgOiBcIlwiXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGhhc0ZpbmlzaGVkOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHRvb2xDYWxsMiA9IHRvb2xDYWxsc1tpbmRleF07XG4gICAgICAgICAgICAgICAgICBpZiAoKChfYyA9IHRvb2xDYWxsMi5mdW5jdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLm5hbWUpICE9IG51bGwgJiYgKChfZCA9IHRvb2xDYWxsMi5mdW5jdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9kLmFyZ3VtZW50cykgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9vbENhbGwyLmZ1bmN0aW9uLmFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1jYWxsLWRlbHRhXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b29sQ2FsbFR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHRvb2xDYWxsMi5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvb2xOYW1lOiB0b29sQ2FsbDIuZnVuY3Rpb24ubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3NUZXh0RGVsdGE6IHRvb2xDYWxsMi5mdW5jdGlvbi5hcmd1bWVudHNcbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNQYXJzYWJsZUpzb24odG9vbENhbGwyLmZ1bmN0aW9uLmFyZ3VtZW50cykpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLWNhbGxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvb2xDYWxsVHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9vbENhbGxJZDogKF9lID0gdG9vbENhbGwyLmlkKSAhPSBudWxsID8gX2UgOiBnZW5lcmF0ZUlkKCksXG4gICAgICAgICAgICAgICAgICAgICAgICB0b29sTmFtZTogdG9vbENhbGwyLmZ1bmN0aW9uLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiB0b29sQ2FsbDIuZnVuY3Rpb24uYXJndW1lbnRzXG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgdG9vbENhbGwyLmhhc0ZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHRvb2xDYWxsID0gdG9vbENhbGxzW2luZGV4XTtcbiAgICAgICAgICAgICAgICBpZiAodG9vbENhbGwuaGFzRmluaXNoZWQpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoKChfZiA9IHRvb2xDYWxsRGVsdGEuZnVuY3Rpb24pID09IG51bGwgPyB2b2lkIDAgOiBfZi5hcmd1bWVudHMpICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIHRvb2xDYWxsLmZ1bmN0aW9uLmFyZ3VtZW50cyArPSAoX2ggPSAoX2cgPSB0b29sQ2FsbERlbHRhLmZ1bmN0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogX2cuYXJndW1lbnRzKSAhPSBudWxsID8gX2ggOiBcIlwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLWNhbGwtZGVsdGFcIixcbiAgICAgICAgICAgICAgICAgIHRvb2xDYWxsVHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgICAgdG9vbENhbGxJZDogdG9vbENhbGwuaWQsXG4gICAgICAgICAgICAgICAgICB0b29sTmFtZTogdG9vbENhbGwuZnVuY3Rpb24ubmFtZSxcbiAgICAgICAgICAgICAgICAgIGFyZ3NUZXh0RGVsdGE6IChfaSA9IHRvb2xDYWxsRGVsdGEuZnVuY3Rpb24uYXJndW1lbnRzKSAhPSBudWxsID8gX2kgOiBcIlwiXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKCgoX2ogPSB0b29sQ2FsbC5mdW5jdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9qLm5hbWUpICE9IG51bGwgJiYgKChfayA9IHRvb2xDYWxsLmZ1bmN0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogX2suYXJndW1lbnRzKSAhPSBudWxsICYmIGlzUGFyc2FibGVKc29uKHRvb2xDYWxsLmZ1bmN0aW9uLmFyZ3VtZW50cykpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1jYWxsXCIsXG4gICAgICAgICAgICAgICAgICAgIHRvb2xDYWxsVHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiAoX2wgPSB0b29sQ2FsbC5pZCkgIT0gbnVsbCA/IF9sIDogZ2VuZXJhdGVJZCgpLFxuICAgICAgICAgICAgICAgICAgICB0b29sTmFtZTogdG9vbENhbGwuZnVuY3Rpb24ubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgYXJnczogdG9vbENhbGwuZnVuY3Rpb24uYXJndW1lbnRzXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIHRvb2xDYWxsLmhhc0ZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIGZsdXNoKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICB0eXBlOiBcImZpbmlzaFwiLFxuICAgICAgICAgICAgICBmaW5pc2hSZWFzb24sXG4gICAgICAgICAgICAgIGxvZ3Byb2JzLFxuICAgICAgICAgICAgICB1c2FnZToge1xuICAgICAgICAgICAgICAgIHByb21wdFRva2VuczogKF9hID0gdXNhZ2UucHJvbXB0VG9rZW5zKSAhPSBudWxsID8gX2EgOiBOYU4sXG4gICAgICAgICAgICAgICAgY29tcGxldGlvblRva2VuczogKF9iID0gdXNhZ2UuY29tcGxldGlvblRva2VucykgIT0gbnVsbCA/IF9iIDogTmFOXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIC4uLnByb3ZpZGVyTWV0YWRhdGEgIT0gbnVsbCA/IHsgcHJvdmlkZXJNZXRhZGF0YSB9IDoge31cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICksXG4gICAgICByYXdDYWxsOiB7IHJhd1Byb21wdCwgcmF3U2V0dGluZ3MgfSxcbiAgICAgIHJhd1Jlc3BvbnNlOiB7IGhlYWRlcnM6IHJlc3BvbnNlSGVhZGVycyB9LFxuICAgICAgcmVxdWVzdDogeyBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSB9LFxuICAgICAgd2FybmluZ3NcbiAgICB9O1xuICB9XG59O1xudmFyIG9wZW5haVRva2VuVXNhZ2VTY2hlbWEgPSB6Mi5vYmplY3Qoe1xuICBwcm9tcHRfdG9rZW5zOiB6Mi5udW1iZXIoKS5udWxsaXNoKCksXG4gIGNvbXBsZXRpb25fdG9rZW5zOiB6Mi5udW1iZXIoKS5udWxsaXNoKCksXG4gIHByb21wdF90b2tlbnNfZGV0YWlsczogejIub2JqZWN0KHtcbiAgICBjYWNoZWRfdG9rZW5zOiB6Mi5udW1iZXIoKS5udWxsaXNoKClcbiAgfSkubnVsbGlzaCgpLFxuICBjb21wbGV0aW9uX3Rva2Vuc19kZXRhaWxzOiB6Mi5vYmplY3Qoe1xuICAgIHJlYXNvbmluZ190b2tlbnM6IHoyLm51bWJlcigpLm51bGxpc2goKSxcbiAgICBhY2NlcHRlZF9wcmVkaWN0aW9uX3Rva2VuczogejIubnVtYmVyKCkubnVsbGlzaCgpLFxuICAgIHJlamVjdGVkX3ByZWRpY3Rpb25fdG9rZW5zOiB6Mi5udW1iZXIoKS5udWxsaXNoKClcbiAgfSkubnVsbGlzaCgpXG59KS5udWxsaXNoKCk7XG52YXIgb3BlbmFpQ2hhdFJlc3BvbnNlU2NoZW1hID0gejIub2JqZWN0KHtcbiAgaWQ6IHoyLnN0cmluZygpLm51bGxpc2goKSxcbiAgY3JlYXRlZDogejIubnVtYmVyKCkubnVsbGlzaCgpLFxuICBtb2RlbDogejIuc3RyaW5nKCkubnVsbGlzaCgpLFxuICBjaG9pY2VzOiB6Mi5hcnJheShcbiAgICB6Mi5vYmplY3Qoe1xuICAgICAgbWVzc2FnZTogejIub2JqZWN0KHtcbiAgICAgICAgcm9sZTogejIubGl0ZXJhbChcImFzc2lzdGFudFwiKS5udWxsaXNoKCksXG4gICAgICAgIGNvbnRlbnQ6IHoyLnN0cmluZygpLm51bGxpc2goKSxcbiAgICAgICAgZnVuY3Rpb25fY2FsbDogejIub2JqZWN0KHtcbiAgICAgICAgICBhcmd1bWVudHM6IHoyLnN0cmluZygpLFxuICAgICAgICAgIG5hbWU6IHoyLnN0cmluZygpXG4gICAgICAgIH0pLm51bGxpc2goKSxcbiAgICAgICAgdG9vbF9jYWxsczogejIuYXJyYXkoXG4gICAgICAgICAgejIub2JqZWN0KHtcbiAgICAgICAgICAgIGlkOiB6Mi5zdHJpbmcoKS5udWxsaXNoKCksXG4gICAgICAgICAgICB0eXBlOiB6Mi5saXRlcmFsKFwiZnVuY3Rpb25cIiksXG4gICAgICAgICAgICBmdW5jdGlvbjogejIub2JqZWN0KHtcbiAgICAgICAgICAgICAgbmFtZTogejIuc3RyaW5nKCksXG4gICAgICAgICAgICAgIGFyZ3VtZW50czogejIuc3RyaW5nKClcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSlcbiAgICAgICAgKS5udWxsaXNoKClcbiAgICAgIH0pLFxuICAgICAgaW5kZXg6IHoyLm51bWJlcigpLFxuICAgICAgbG9ncHJvYnM6IHoyLm9iamVjdCh7XG4gICAgICAgIGNvbnRlbnQ6IHoyLmFycmF5KFxuICAgICAgICAgIHoyLm9iamVjdCh7XG4gICAgICAgICAgICB0b2tlbjogejIuc3RyaW5nKCksXG4gICAgICAgICAgICBsb2dwcm9iOiB6Mi5udW1iZXIoKSxcbiAgICAgICAgICAgIHRvcF9sb2dwcm9iczogejIuYXJyYXkoXG4gICAgICAgICAgICAgIHoyLm9iamVjdCh7XG4gICAgICAgICAgICAgICAgdG9rZW46IHoyLnN0cmluZygpLFxuICAgICAgICAgICAgICAgIGxvZ3Byb2I6IHoyLm51bWJlcigpXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApXG4gICAgICAgICAgfSlcbiAgICAgICAgKS5udWxsYWJsZSgpXG4gICAgICB9KS5udWxsaXNoKCksXG4gICAgICBmaW5pc2hfcmVhc29uOiB6Mi5zdHJpbmcoKS5udWxsaXNoKClcbiAgICB9KVxuICApLFxuICB1c2FnZTogb3BlbmFpVG9rZW5Vc2FnZVNjaGVtYVxufSk7XG52YXIgb3BlbmFpQ2hhdENodW5rU2NoZW1hID0gejIudW5pb24oW1xuICB6Mi5vYmplY3Qoe1xuICAgIGlkOiB6Mi5zdHJpbmcoKS5udWxsaXNoKCksXG4gICAgY3JlYXRlZDogejIubnVtYmVyKCkubnVsbGlzaCgpLFxuICAgIG1vZGVsOiB6Mi5zdHJpbmcoKS5udWxsaXNoKCksXG4gICAgY2hvaWNlczogejIuYXJyYXkoXG4gICAgICB6Mi5vYmplY3Qoe1xuICAgICAgICBkZWx0YTogejIub2JqZWN0KHtcbiAgICAgICAgICByb2xlOiB6Mi5lbnVtKFtcImFzc2lzdGFudFwiXSkubnVsbGlzaCgpLFxuICAgICAgICAgIGNvbnRlbnQ6IHoyLnN0cmluZygpLm51bGxpc2goKSxcbiAgICAgICAgICBmdW5jdGlvbl9jYWxsOiB6Mi5vYmplY3Qoe1xuICAgICAgICAgICAgbmFtZTogejIuc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgICAgICAgICAgIGFyZ3VtZW50czogejIuc3RyaW5nKCkub3B0aW9uYWwoKVxuICAgICAgICAgIH0pLm51bGxpc2goKSxcbiAgICAgICAgICB0b29sX2NhbGxzOiB6Mi5hcnJheShcbiAgICAgICAgICAgIHoyLm9iamVjdCh7XG4gICAgICAgICAgICAgIGluZGV4OiB6Mi5udW1iZXIoKSxcbiAgICAgICAgICAgICAgaWQ6IHoyLnN0cmluZygpLm51bGxpc2goKSxcbiAgICAgICAgICAgICAgdHlwZTogejIubGl0ZXJhbChcImZ1bmN0aW9uXCIpLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIGZ1bmN0aW9uOiB6Mi5vYmplY3Qoe1xuICAgICAgICAgICAgICAgIG5hbWU6IHoyLnN0cmluZygpLm51bGxpc2goKSxcbiAgICAgICAgICAgICAgICBhcmd1bWVudHM6IHoyLnN0cmluZygpLm51bGxpc2goKVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApLm51bGxpc2goKVxuICAgICAgICB9KS5udWxsaXNoKCksXG4gICAgICAgIGxvZ3Byb2JzOiB6Mi5vYmplY3Qoe1xuICAgICAgICAgIGNvbnRlbnQ6IHoyLmFycmF5KFxuICAgICAgICAgICAgejIub2JqZWN0KHtcbiAgICAgICAgICAgICAgdG9rZW46IHoyLnN0cmluZygpLFxuICAgICAgICAgICAgICBsb2dwcm9iOiB6Mi5udW1iZXIoKSxcbiAgICAgICAgICAgICAgdG9wX2xvZ3Byb2JzOiB6Mi5hcnJheShcbiAgICAgICAgICAgICAgICB6Mi5vYmplY3Qoe1xuICAgICAgICAgICAgICAgICAgdG9rZW46IHoyLnN0cmluZygpLFxuICAgICAgICAgICAgICAgICAgbG9ncHJvYjogejIubnVtYmVyKClcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICkubnVsbGFibGUoKVxuICAgICAgICB9KS5udWxsaXNoKCksXG4gICAgICAgIGZpbmlzaF9yZWFzb246IHoyLnN0cmluZygpLm51bGxhYmxlKCkub3B0aW9uYWwoKSxcbiAgICAgICAgaW5kZXg6IHoyLm51bWJlcigpXG4gICAgICB9KVxuICAgICksXG4gICAgdXNhZ2U6IG9wZW5haVRva2VuVXNhZ2VTY2hlbWFcbiAgfSksXG4gIG9wZW5haUVycm9yRGF0YVNjaGVtYVxuXSk7XG5mdW5jdGlvbiBpc1JlYXNvbmluZ01vZGVsKG1vZGVsSWQpIHtcbiAgcmV0dXJuIG1vZGVsSWQuc3RhcnRzV2l0aChcIm9cIik7XG59XG5mdW5jdGlvbiBpc0F1ZGlvTW9kZWwobW9kZWxJZCkge1xuICByZXR1cm4gbW9kZWxJZC5zdGFydHNXaXRoKFwiZ3B0LTRvLWF1ZGlvLXByZXZpZXdcIik7XG59XG5mdW5jdGlvbiBnZXRTeXN0ZW1NZXNzYWdlTW9kZShtb2RlbElkKSB7XG4gIHZhciBfYSwgX2I7XG4gIGlmICghaXNSZWFzb25pbmdNb2RlbChtb2RlbElkKSkge1xuICAgIHJldHVybiBcInN5c3RlbVwiO1xuICB9XG4gIHJldHVybiAoX2IgPSAoX2EgPSByZWFzb25pbmdNb2RlbHNbbW9kZWxJZF0pID09IG51bGwgPyB2b2lkIDAgOiBfYS5zeXN0ZW1NZXNzYWdlTW9kZSkgIT0gbnVsbCA/IF9iIDogXCJkZXZlbG9wZXJcIjtcbn1cbnZhciByZWFzb25pbmdNb2RlbHMgPSB7XG4gIFwibzEtbWluaVwiOiB7XG4gICAgc3lzdGVtTWVzc2FnZU1vZGU6IFwicmVtb3ZlXCJcbiAgfSxcbiAgXCJvMS1taW5pLTIwMjQtMDktMTJcIjoge1xuICAgIHN5c3RlbU1lc3NhZ2VNb2RlOiBcInJlbW92ZVwiXG4gIH0sXG4gIFwibzEtcHJldmlld1wiOiB7XG4gICAgc3lzdGVtTWVzc2FnZU1vZGU6IFwicmVtb3ZlXCJcbiAgfSxcbiAgXCJvMS1wcmV2aWV3LTIwMjQtMDktMTJcIjoge1xuICAgIHN5c3RlbU1lc3NhZ2VNb2RlOiBcInJlbW92ZVwiXG4gIH0sXG4gIG8zOiB7XG4gICAgc3lzdGVtTWVzc2FnZU1vZGU6IFwiZGV2ZWxvcGVyXCJcbiAgfSxcbiAgXCJvMy0yMDI1LTA0LTE2XCI6IHtcbiAgICBzeXN0ZW1NZXNzYWdlTW9kZTogXCJkZXZlbG9wZXJcIlxuICB9LFxuICBcIm8zLW1pbmlcIjoge1xuICAgIHN5c3RlbU1lc3NhZ2VNb2RlOiBcImRldmVsb3BlclwiXG4gIH0sXG4gIFwibzMtbWluaS0yMDI1LTAxLTMxXCI6IHtcbiAgICBzeXN0ZW1NZXNzYWdlTW9kZTogXCJkZXZlbG9wZXJcIlxuICB9LFxuICBcIm80LW1pbmlcIjoge1xuICAgIHN5c3RlbU1lc3NhZ2VNb2RlOiBcImRldmVsb3BlclwiXG4gIH0sXG4gIFwibzQtbWluaS0yMDI1LTA0LTE2XCI6IHtcbiAgICBzeXN0ZW1NZXNzYWdlTW9kZTogXCJkZXZlbG9wZXJcIlxuICB9XG59O1xuXG4vLyBzcmMvb3BlbmFpLWNvbXBsZXRpb24tbGFuZ3VhZ2UtbW9kZWwudHNcbmltcG9ydCB7XG4gIFVuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yIGFzIFVuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yNVxufSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuaW1wb3J0IHtcbiAgY29tYmluZUhlYWRlcnMgYXMgY29tYmluZUhlYWRlcnMyLFxuICBjcmVhdGVFdmVudFNvdXJjZVJlc3BvbnNlSGFuZGxlciBhcyBjcmVhdGVFdmVudFNvdXJjZVJlc3BvbnNlSGFuZGxlcjIsXG4gIGNyZWF0ZUpzb25SZXNwb25zZUhhbmRsZXIgYXMgY3JlYXRlSnNvblJlc3BvbnNlSGFuZGxlcjIsXG4gIHBvc3RKc29uVG9BcGkgYXMgcG9zdEpzb25Ub0FwaTJcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbmltcG9ydCB7IHogYXMgejMgfSBmcm9tIFwiem9kXCI7XG5cbi8vIHNyYy9jb252ZXJ0LXRvLW9wZW5haS1jb21wbGV0aW9uLXByb21wdC50c1xuaW1wb3J0IHtcbiAgSW52YWxpZFByb21wdEVycm9yLFxuICBVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvciBhcyBVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvcjRcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbmZ1bmN0aW9uIGNvbnZlcnRUb09wZW5BSUNvbXBsZXRpb25Qcm9tcHQoe1xuICBwcm9tcHQsXG4gIGlucHV0Rm9ybWF0LFxuICB1c2VyID0gXCJ1c2VyXCIsXG4gIGFzc2lzdGFudCA9IFwiYXNzaXN0YW50XCJcbn0pIHtcbiAgaWYgKGlucHV0Rm9ybWF0ID09PSBcInByb21wdFwiICYmIHByb21wdC5sZW5ndGggPT09IDEgJiYgcHJvbXB0WzBdLnJvbGUgPT09IFwidXNlclwiICYmIHByb21wdFswXS5jb250ZW50Lmxlbmd0aCA9PT0gMSAmJiBwcm9tcHRbMF0uY29udGVudFswXS50eXBlID09PSBcInRleHRcIikge1xuICAgIHJldHVybiB7IHByb21wdDogcHJvbXB0WzBdLmNvbnRlbnRbMF0udGV4dCB9O1xuICB9XG4gIGxldCB0ZXh0ID0gXCJcIjtcbiAgaWYgKHByb21wdFswXS5yb2xlID09PSBcInN5c3RlbVwiKSB7XG4gICAgdGV4dCArPSBgJHtwcm9tcHRbMF0uY29udGVudH1cblxuYDtcbiAgICBwcm9tcHQgPSBwcm9tcHQuc2xpY2UoMSk7XG4gIH1cbiAgZm9yIChjb25zdCB7IHJvbGUsIGNvbnRlbnQgfSBvZiBwcm9tcHQpIHtcbiAgICBzd2l0Y2ggKHJvbGUpIHtcbiAgICAgIGNhc2UgXCJzeXN0ZW1cIjoge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFByb21wdEVycm9yKHtcbiAgICAgICAgICBtZXNzYWdlOiBcIlVuZXhwZWN0ZWQgc3lzdGVtIG1lc3NhZ2UgaW4gcHJvbXB0OiAke2NvbnRlbnR9XCIsXG4gICAgICAgICAgcHJvbXB0XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgY2FzZSBcInVzZXJcIjoge1xuICAgICAgICBjb25zdCB1c2VyTWVzc2FnZSA9IGNvbnRlbnQubWFwKChwYXJ0KSA9PiB7XG4gICAgICAgICAgc3dpdGNoIChwYXJ0LnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ0ZXh0XCI6IHtcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcnQudGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJpbWFnZVwiOiB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvcjQoe1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uYWxpdHk6IFwiaW1hZ2VzXCJcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KS5qb2luKFwiXCIpO1xuICAgICAgICB0ZXh0ICs9IGAke3VzZXJ9OlxuJHt1c2VyTWVzc2FnZX1cblxuYDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiYXNzaXN0YW50XCI6IHtcbiAgICAgICAgY29uc3QgYXNzaXN0YW50TWVzc2FnZSA9IGNvbnRlbnQubWFwKChwYXJ0KSA9PiB7XG4gICAgICAgICAgc3dpdGNoIChwYXJ0LnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ0ZXh0XCI6IHtcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcnQudGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJ0b29sLWNhbGxcIjoge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3I0KHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbmFsaXR5OiBcInRvb2wtY2FsbCBtZXNzYWdlc1wiXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSkuam9pbihcIlwiKTtcbiAgICAgICAgdGV4dCArPSBgJHthc3Npc3RhbnR9OlxuJHthc3Npc3RhbnRNZXNzYWdlfVxuXG5gO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJ0b29sXCI6IHtcbiAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yNCh7XG4gICAgICAgICAgZnVuY3Rpb25hbGl0eTogXCJ0b29sIG1lc3NhZ2VzXCJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIGNvbnN0IF9leGhhdXN0aXZlQ2hlY2sgPSByb2xlO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHJvbGU6ICR7X2V4aGF1c3RpdmVDaGVja31gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdGV4dCArPSBgJHthc3Npc3RhbnR9OlxuYDtcbiAgcmV0dXJuIHtcbiAgICBwcm9tcHQ6IHRleHQsXG4gICAgc3RvcFNlcXVlbmNlczogW2BcbiR7dXNlcn06YF1cbiAgfTtcbn1cblxuLy8gc3JjL21hcC1vcGVuYWktY29tcGxldGlvbi1sb2dwcm9icy50c1xuZnVuY3Rpb24gbWFwT3BlbkFJQ29tcGxldGlvbkxvZ1Byb2JzKGxvZ3Byb2JzKSB7XG4gIHJldHVybiBsb2dwcm9icyA9PSBudWxsID8gdm9pZCAwIDogbG9ncHJvYnMudG9rZW5zLm1hcCgodG9rZW4sIGluZGV4KSA9PiAoe1xuICAgIHRva2VuLFxuICAgIGxvZ3Byb2I6IGxvZ3Byb2JzLnRva2VuX2xvZ3Byb2JzW2luZGV4XSxcbiAgICB0b3BMb2dwcm9iczogbG9ncHJvYnMudG9wX2xvZ3Byb2JzID8gT2JqZWN0LmVudHJpZXMobG9ncHJvYnMudG9wX2xvZ3Byb2JzW2luZGV4XSkubWFwKFxuICAgICAgKFt0b2tlbjIsIGxvZ3Byb2JdKSA9PiAoe1xuICAgICAgICB0b2tlbjogdG9rZW4yLFxuICAgICAgICBsb2dwcm9iXG4gICAgICB9KVxuICAgICkgOiBbXVxuICB9KSk7XG59XG5cbi8vIHNyYy9vcGVuYWktY29tcGxldGlvbi1sYW5ndWFnZS1tb2RlbC50c1xudmFyIE9wZW5BSUNvbXBsZXRpb25MYW5ndWFnZU1vZGVsID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihtb2RlbElkLCBzZXR0aW5ncywgY29uZmlnKSB7XG4gICAgdGhpcy5zcGVjaWZpY2F0aW9uVmVyc2lvbiA9IFwidjFcIjtcbiAgICB0aGlzLmRlZmF1bHRPYmplY3RHZW5lcmF0aW9uTW9kZSA9IHZvaWQgMDtcbiAgICB0aGlzLm1vZGVsSWQgPSBtb2RlbElkO1xuICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgfVxuICBnZXQgcHJvdmlkZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLnByb3ZpZGVyO1xuICB9XG4gIGdldEFyZ3Moe1xuICAgIG1vZGUsXG4gICAgaW5wdXRGb3JtYXQsXG4gICAgcHJvbXB0LFxuICAgIG1heFRva2VucyxcbiAgICB0ZW1wZXJhdHVyZSxcbiAgICB0b3BQLFxuICAgIHRvcEssXG4gICAgZnJlcXVlbmN5UGVuYWx0eSxcbiAgICBwcmVzZW5jZVBlbmFsdHksXG4gICAgc3RvcFNlcXVlbmNlczogdXNlclN0b3BTZXF1ZW5jZXMsXG4gICAgcmVzcG9uc2VGb3JtYXQsXG4gICAgc2VlZFxuICB9KSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHR5cGUgPSBtb2RlLnR5cGU7XG4gICAgY29uc3Qgd2FybmluZ3MgPSBbXTtcbiAgICBpZiAodG9wSyAhPSBudWxsKSB7XG4gICAgICB3YXJuaW5ncy5wdXNoKHtcbiAgICAgICAgdHlwZTogXCJ1bnN1cHBvcnRlZC1zZXR0aW5nXCIsXG4gICAgICAgIHNldHRpbmc6IFwidG9wS1wiXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHJlc3BvbnNlRm9ybWF0ICE9IG51bGwgJiYgcmVzcG9uc2VGb3JtYXQudHlwZSAhPT0gXCJ0ZXh0XCIpIHtcbiAgICAgIHdhcm5pbmdzLnB1c2goe1xuICAgICAgICB0eXBlOiBcInVuc3VwcG9ydGVkLXNldHRpbmdcIixcbiAgICAgICAgc2V0dGluZzogXCJyZXNwb25zZUZvcm1hdFwiLFxuICAgICAgICBkZXRhaWxzOiBcIkpTT04gcmVzcG9uc2UgZm9ybWF0IGlzIG5vdCBzdXBwb3J0ZWQuXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCB7IHByb21wdDogY29tcGxldGlvblByb21wdCwgc3RvcFNlcXVlbmNlcyB9ID0gY29udmVydFRvT3BlbkFJQ29tcGxldGlvblByb21wdCh7IHByb21wdCwgaW5wdXRGb3JtYXQgfSk7XG4gICAgY29uc3Qgc3RvcCA9IFsuLi5zdG9wU2VxdWVuY2VzICE9IG51bGwgPyBzdG9wU2VxdWVuY2VzIDogW10sIC4uLnVzZXJTdG9wU2VxdWVuY2VzICE9IG51bGwgPyB1c2VyU3RvcFNlcXVlbmNlcyA6IFtdXTtcbiAgICBjb25zdCBiYXNlQXJncyA9IHtcbiAgICAgIC8vIG1vZGVsIGlkOlxuICAgICAgbW9kZWw6IHRoaXMubW9kZWxJZCxcbiAgICAgIC8vIG1vZGVsIHNwZWNpZmljIHNldHRpbmdzOlxuICAgICAgZWNobzogdGhpcy5zZXR0aW5ncy5lY2hvLFxuICAgICAgbG9naXRfYmlhczogdGhpcy5zZXR0aW5ncy5sb2dpdEJpYXMsXG4gICAgICBsb2dwcm9iczogdHlwZW9mIHRoaXMuc2V0dGluZ3MubG9ncHJvYnMgPT09IFwibnVtYmVyXCIgPyB0aGlzLnNldHRpbmdzLmxvZ3Byb2JzIDogdHlwZW9mIHRoaXMuc2V0dGluZ3MubG9ncHJvYnMgPT09IFwiYm9vbGVhblwiID8gdGhpcy5zZXR0aW5ncy5sb2dwcm9icyA/IDAgOiB2b2lkIDAgOiB2b2lkIDAsXG4gICAgICBzdWZmaXg6IHRoaXMuc2V0dGluZ3Muc3VmZml4LFxuICAgICAgdXNlcjogdGhpcy5zZXR0aW5ncy51c2VyLFxuICAgICAgLy8gc3RhbmRhcmRpemVkIHNldHRpbmdzOlxuICAgICAgbWF4X3Rva2VuczogbWF4VG9rZW5zLFxuICAgICAgdGVtcGVyYXR1cmUsXG4gICAgICB0b3BfcDogdG9wUCxcbiAgICAgIGZyZXF1ZW5jeV9wZW5hbHR5OiBmcmVxdWVuY3lQZW5hbHR5LFxuICAgICAgcHJlc2VuY2VfcGVuYWx0eTogcHJlc2VuY2VQZW5hbHR5LFxuICAgICAgc2VlZCxcbiAgICAgIC8vIHByb21wdDpcbiAgICAgIHByb21wdDogY29tcGxldGlvblByb21wdCxcbiAgICAgIC8vIHN0b3Agc2VxdWVuY2VzOlxuICAgICAgc3RvcDogc3RvcC5sZW5ndGggPiAwID8gc3RvcCA6IHZvaWQgMFxuICAgIH07XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFwicmVndWxhclwiOiB7XG4gICAgICAgIGlmICgoX2EgPSBtb2RlLnRvb2xzKSA9PSBudWxsID8gdm9pZCAwIDogX2EubGVuZ3RoKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yNSh7XG4gICAgICAgICAgICBmdW5jdGlvbmFsaXR5OiBcInRvb2xzXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobW9kZS50b29sQ2hvaWNlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yNSh7XG4gICAgICAgICAgICBmdW5jdGlvbmFsaXR5OiBcInRvb2xDaG9pY2VcIlxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGFyZ3M6IGJhc2VBcmdzLCB3YXJuaW5ncyB9O1xuICAgICAgfVxuICAgICAgY2FzZSBcIm9iamVjdC1qc29uXCI6IHtcbiAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yNSh7XG4gICAgICAgICAgZnVuY3Rpb25hbGl0eTogXCJvYmplY3QtanNvbiBtb2RlXCJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjYXNlIFwib2JqZWN0LXRvb2xcIjoge1xuICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3I1KHtcbiAgICAgICAgICBmdW5jdGlvbmFsaXR5OiBcIm9iamVjdC10b29sIG1vZGVcIlxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgY29uc3QgX2V4aGF1c3RpdmVDaGVjayA9IHR5cGU7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgdHlwZTogJHtfZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBhc3luYyBkb0dlbmVyYXRlKG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGFyZ3MsIHdhcm5pbmdzIH0gPSB0aGlzLmdldEFyZ3Mob3B0aW9ucyk7XG4gICAgY29uc3Qge1xuICAgICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgdmFsdWU6IHJlc3BvbnNlLFxuICAgICAgcmF3VmFsdWU6IHJhd1Jlc3BvbnNlXG4gICAgfSA9IGF3YWl0IHBvc3RKc29uVG9BcGkyKHtcbiAgICAgIHVybDogdGhpcy5jb25maWcudXJsKHtcbiAgICAgICAgcGF0aDogXCIvY29tcGxldGlvbnNcIixcbiAgICAgICAgbW9kZWxJZDogdGhpcy5tb2RlbElkXG4gICAgICB9KSxcbiAgICAgIGhlYWRlcnM6IGNvbWJpbmVIZWFkZXJzMih0aGlzLmNvbmZpZy5oZWFkZXJzKCksIG9wdGlvbnMuaGVhZGVycyksXG4gICAgICBib2R5OiBhcmdzLFxuICAgICAgZmFpbGVkUmVzcG9uc2VIYW5kbGVyOiBvcGVuYWlGYWlsZWRSZXNwb25zZUhhbmRsZXIsXG4gICAgICBzdWNjZXNzZnVsUmVzcG9uc2VIYW5kbGVyOiBjcmVhdGVKc29uUmVzcG9uc2VIYW5kbGVyMihcbiAgICAgICAgb3BlbmFpQ29tcGxldGlvblJlc3BvbnNlU2NoZW1hXG4gICAgICApLFxuICAgICAgYWJvcnRTaWduYWw6IG9wdGlvbnMuYWJvcnRTaWduYWwsXG4gICAgICBmZXRjaDogdGhpcy5jb25maWcuZmV0Y2hcbiAgICB9KTtcbiAgICBjb25zdCB7IHByb21wdDogcmF3UHJvbXB0LCAuLi5yYXdTZXR0aW5ncyB9ID0gYXJncztcbiAgICBjb25zdCBjaG9pY2UgPSByZXNwb25zZS5jaG9pY2VzWzBdO1xuICAgIHJldHVybiB7XG4gICAgICB0ZXh0OiBjaG9pY2UudGV4dCxcbiAgICAgIHVzYWdlOiB7XG4gICAgICAgIHByb21wdFRva2VuczogcmVzcG9uc2UudXNhZ2UucHJvbXB0X3Rva2VucyxcbiAgICAgICAgY29tcGxldGlvblRva2VuczogcmVzcG9uc2UudXNhZ2UuY29tcGxldGlvbl90b2tlbnNcbiAgICAgIH0sXG4gICAgICBmaW5pc2hSZWFzb246IG1hcE9wZW5BSUZpbmlzaFJlYXNvbihjaG9pY2UuZmluaXNoX3JlYXNvbiksXG4gICAgICBsb2dwcm9iczogbWFwT3BlbkFJQ29tcGxldGlvbkxvZ1Byb2JzKGNob2ljZS5sb2dwcm9icyksXG4gICAgICByYXdDYWxsOiB7IHJhd1Byb21wdCwgcmF3U2V0dGluZ3MgfSxcbiAgICAgIHJhd1Jlc3BvbnNlOiB7IGhlYWRlcnM6IHJlc3BvbnNlSGVhZGVycywgYm9keTogcmF3UmVzcG9uc2UgfSxcbiAgICAgIHJlc3BvbnNlOiBnZXRSZXNwb25zZU1ldGFkYXRhKHJlc3BvbnNlKSxcbiAgICAgIHdhcm5pbmdzLFxuICAgICAgcmVxdWVzdDogeyBib2R5OiBKU09OLnN0cmluZ2lmeShhcmdzKSB9XG4gICAgfTtcbiAgfVxuICBhc3luYyBkb1N0cmVhbShvcHRpb25zKSB7XG4gICAgY29uc3QgeyBhcmdzLCB3YXJuaW5ncyB9ID0gdGhpcy5nZXRBcmdzKG9wdGlvbnMpO1xuICAgIGNvbnN0IGJvZHkgPSB7XG4gICAgICAuLi5hcmdzLFxuICAgICAgc3RyZWFtOiB0cnVlLFxuICAgICAgLy8gb25seSBpbmNsdWRlIHN0cmVhbV9vcHRpb25zIHdoZW4gaW4gc3RyaWN0IGNvbXBhdGliaWxpdHkgbW9kZTpcbiAgICAgIHN0cmVhbV9vcHRpb25zOiB0aGlzLmNvbmZpZy5jb21wYXRpYmlsaXR5ID09PSBcInN0cmljdFwiID8geyBpbmNsdWRlX3VzYWdlOiB0cnVlIH0gOiB2b2lkIDBcbiAgICB9O1xuICAgIGNvbnN0IHsgcmVzcG9uc2VIZWFkZXJzLCB2YWx1ZTogcmVzcG9uc2UgfSA9IGF3YWl0IHBvc3RKc29uVG9BcGkyKHtcbiAgICAgIHVybDogdGhpcy5jb25maWcudXJsKHtcbiAgICAgICAgcGF0aDogXCIvY29tcGxldGlvbnNcIixcbiAgICAgICAgbW9kZWxJZDogdGhpcy5tb2RlbElkXG4gICAgICB9KSxcbiAgICAgIGhlYWRlcnM6IGNvbWJpbmVIZWFkZXJzMih0aGlzLmNvbmZpZy5oZWFkZXJzKCksIG9wdGlvbnMuaGVhZGVycyksXG4gICAgICBib2R5LFxuICAgICAgZmFpbGVkUmVzcG9uc2VIYW5kbGVyOiBvcGVuYWlGYWlsZWRSZXNwb25zZUhhbmRsZXIsXG4gICAgICBzdWNjZXNzZnVsUmVzcG9uc2VIYW5kbGVyOiBjcmVhdGVFdmVudFNvdXJjZVJlc3BvbnNlSGFuZGxlcjIoXG4gICAgICAgIG9wZW5haUNvbXBsZXRpb25DaHVua1NjaGVtYVxuICAgICAgKSxcbiAgICAgIGFib3J0U2lnbmFsOiBvcHRpb25zLmFib3J0U2lnbmFsLFxuICAgICAgZmV0Y2g6IHRoaXMuY29uZmlnLmZldGNoXG4gICAgfSk7XG4gICAgY29uc3QgeyBwcm9tcHQ6IHJhd1Byb21wdCwgLi4ucmF3U2V0dGluZ3MgfSA9IGFyZ3M7XG4gICAgbGV0IGZpbmlzaFJlYXNvbiA9IFwidW5rbm93blwiO1xuICAgIGxldCB1c2FnZSA9IHtcbiAgICAgIHByb21wdFRva2VuczogTnVtYmVyLk5hTixcbiAgICAgIGNvbXBsZXRpb25Ub2tlbnM6IE51bWJlci5OYU5cbiAgICB9O1xuICAgIGxldCBsb2dwcm9icztcbiAgICBsZXQgaXNGaXJzdENodW5rID0gdHJ1ZTtcbiAgICByZXR1cm4ge1xuICAgICAgc3RyZWFtOiByZXNwb25zZS5waXBlVGhyb3VnaChcbiAgICAgICAgbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICAgICAgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgICAgICBpZiAoIWNodW5rLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgZmluaXNoUmVhc29uID0gXCJlcnJvclwiO1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoeyB0eXBlOiBcImVycm9yXCIsIGVycm9yOiBjaHVuay5lcnJvciB9KTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBjaHVuay52YWx1ZTtcbiAgICAgICAgICAgIGlmIChcImVycm9yXCIgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgZmluaXNoUmVhc29uID0gXCJlcnJvclwiO1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoeyB0eXBlOiBcImVycm9yXCIsIGVycm9yOiB2YWx1ZS5lcnJvciB9KTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzRmlyc3RDaHVuaykge1xuICAgICAgICAgICAgICBpc0ZpcnN0Q2h1bmsgPSBmYWxzZTtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInJlc3BvbnNlLW1ldGFkYXRhXCIsXG4gICAgICAgICAgICAgICAgLi4uZ2V0UmVzcG9uc2VNZXRhZGF0YSh2YWx1ZSlcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUudXNhZ2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgICB1c2FnZSA9IHtcbiAgICAgICAgICAgICAgICBwcm9tcHRUb2tlbnM6IHZhbHVlLnVzYWdlLnByb21wdF90b2tlbnMsXG4gICAgICAgICAgICAgICAgY29tcGxldGlvblRva2VuczogdmFsdWUudXNhZ2UuY29tcGxldGlvbl90b2tlbnNcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNob2ljZSA9IHZhbHVlLmNob2ljZXNbMF07XG4gICAgICAgICAgICBpZiAoKGNob2ljZSA9PSBudWxsID8gdm9pZCAwIDogY2hvaWNlLmZpbmlzaF9yZWFzb24pICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgZmluaXNoUmVhc29uID0gbWFwT3BlbkFJRmluaXNoUmVhc29uKGNob2ljZS5maW5pc2hfcmVhc29uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoY2hvaWNlID09IG51bGwgPyB2b2lkIDAgOiBjaG9pY2UudGV4dCkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dC1kZWx0YVwiLFxuICAgICAgICAgICAgICAgIHRleHREZWx0YTogY2hvaWNlLnRleHRcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtYXBwZWRMb2dwcm9icyA9IG1hcE9wZW5BSUNvbXBsZXRpb25Mb2dQcm9icyhcbiAgICAgICAgICAgICAgY2hvaWNlID09IG51bGwgPyB2b2lkIDAgOiBjaG9pY2UubG9ncHJvYnNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAobWFwcGVkTG9ncHJvYnMgPT0gbnVsbCA/IHZvaWQgMCA6IG1hcHBlZExvZ3Byb2JzLmxlbmd0aCkge1xuICAgICAgICAgICAgICBpZiAobG9ncHJvYnMgPT09IHZvaWQgMCkgbG9ncHJvYnMgPSBbXTtcbiAgICAgICAgICAgICAgbG9ncHJvYnMucHVzaCguLi5tYXBwZWRMb2dwcm9icyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBmbHVzaChjb250cm9sbGVyKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICB0eXBlOiBcImZpbmlzaFwiLFxuICAgICAgICAgICAgICBmaW5pc2hSZWFzb24sXG4gICAgICAgICAgICAgIGxvZ3Byb2JzLFxuICAgICAgICAgICAgICB1c2FnZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKSxcbiAgICAgIHJhd0NhbGw6IHsgcmF3UHJvbXB0LCByYXdTZXR0aW5ncyB9LFxuICAgICAgcmF3UmVzcG9uc2U6IHsgaGVhZGVyczogcmVzcG9uc2VIZWFkZXJzIH0sXG4gICAgICB3YXJuaW5ncyxcbiAgICAgIHJlcXVlc3Q6IHsgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSkgfVxuICAgIH07XG4gIH1cbn07XG52YXIgb3BlbmFpQ29tcGxldGlvblJlc3BvbnNlU2NoZW1hID0gejMub2JqZWN0KHtcbiAgaWQ6IHozLnN0cmluZygpLm51bGxpc2goKSxcbiAgY3JlYXRlZDogejMubnVtYmVyKCkubnVsbGlzaCgpLFxuICBtb2RlbDogejMuc3RyaW5nKCkubnVsbGlzaCgpLFxuICBjaG9pY2VzOiB6My5hcnJheShcbiAgICB6My5vYmplY3Qoe1xuICAgICAgdGV4dDogejMuc3RyaW5nKCksXG4gICAgICBmaW5pc2hfcmVhc29uOiB6My5zdHJpbmcoKSxcbiAgICAgIGxvZ3Byb2JzOiB6My5vYmplY3Qoe1xuICAgICAgICB0b2tlbnM6IHozLmFycmF5KHozLnN0cmluZygpKSxcbiAgICAgICAgdG9rZW5fbG9ncHJvYnM6IHozLmFycmF5KHozLm51bWJlcigpKSxcbiAgICAgICAgdG9wX2xvZ3Byb2JzOiB6My5hcnJheSh6My5yZWNvcmQoejMuc3RyaW5nKCksIHozLm51bWJlcigpKSkubnVsbGFibGUoKVxuICAgICAgfSkubnVsbGlzaCgpXG4gICAgfSlcbiAgKSxcbiAgdXNhZ2U6IHozLm9iamVjdCh7XG4gICAgcHJvbXB0X3Rva2VuczogejMubnVtYmVyKCksXG4gICAgY29tcGxldGlvbl90b2tlbnM6IHozLm51bWJlcigpXG4gIH0pXG59KTtcbnZhciBvcGVuYWlDb21wbGV0aW9uQ2h1bmtTY2hlbWEgPSB6My51bmlvbihbXG4gIHozLm9iamVjdCh7XG4gICAgaWQ6IHozLnN0cmluZygpLm51bGxpc2goKSxcbiAgICBjcmVhdGVkOiB6My5udW1iZXIoKS5udWxsaXNoKCksXG4gICAgbW9kZWw6IHozLnN0cmluZygpLm51bGxpc2goKSxcbiAgICBjaG9pY2VzOiB6My5hcnJheShcbiAgICAgIHozLm9iamVjdCh7XG4gICAgICAgIHRleHQ6IHozLnN0cmluZygpLFxuICAgICAgICBmaW5pc2hfcmVhc29uOiB6My5zdHJpbmcoKS5udWxsaXNoKCksXG4gICAgICAgIGluZGV4OiB6My5udW1iZXIoKSxcbiAgICAgICAgbG9ncHJvYnM6IHozLm9iamVjdCh7XG4gICAgICAgICAgdG9rZW5zOiB6My5hcnJheSh6My5zdHJpbmcoKSksXG4gICAgICAgICAgdG9rZW5fbG9ncHJvYnM6IHozLmFycmF5KHozLm51bWJlcigpKSxcbiAgICAgICAgICB0b3BfbG9ncHJvYnM6IHozLmFycmF5KHozLnJlY29yZCh6My5zdHJpbmcoKSwgejMubnVtYmVyKCkpKS5udWxsYWJsZSgpXG4gICAgICAgIH0pLm51bGxpc2goKVxuICAgICAgfSlcbiAgICApLFxuICAgIHVzYWdlOiB6My5vYmplY3Qoe1xuICAgICAgcHJvbXB0X3Rva2VuczogejMubnVtYmVyKCksXG4gICAgICBjb21wbGV0aW9uX3Rva2VuczogejMubnVtYmVyKClcbiAgICB9KS5udWxsaXNoKClcbiAgfSksXG4gIG9wZW5haUVycm9yRGF0YVNjaGVtYVxuXSk7XG5cbi8vIHNyYy9vcGVuYWktZW1iZWRkaW5nLW1vZGVsLnRzXG5pbXBvcnQge1xuICBUb29NYW55RW1iZWRkaW5nVmFsdWVzRm9yQ2FsbEVycm9yXG59IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5pbXBvcnQge1xuICBjb21iaW5lSGVhZGVycyBhcyBjb21iaW5lSGVhZGVyczMsXG4gIGNyZWF0ZUpzb25SZXNwb25zZUhhbmRsZXIgYXMgY3JlYXRlSnNvblJlc3BvbnNlSGFuZGxlcjMsXG4gIHBvc3RKc29uVG9BcGkgYXMgcG9zdEpzb25Ub0FwaTNcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbmltcG9ydCB7IHogYXMgejQgfSBmcm9tIFwiem9kXCI7XG52YXIgT3BlbkFJRW1iZWRkaW5nTW9kZWwgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG1vZGVsSWQsIHNldHRpbmdzLCBjb25maWcpIHtcbiAgICB0aGlzLnNwZWNpZmljYXRpb25WZXJzaW9uID0gXCJ2MVwiO1xuICAgIHRoaXMubW9kZWxJZCA9IG1vZGVsSWQ7XG4gICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICB9XG4gIGdldCBwcm92aWRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5jb25maWcucHJvdmlkZXI7XG4gIH1cbiAgZ2V0IG1heEVtYmVkZGluZ3NQZXJDYWxsKCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKF9hID0gdGhpcy5zZXR0aW5ncy5tYXhFbWJlZGRpbmdzUGVyQ2FsbCkgIT0gbnVsbCA/IF9hIDogMjA0ODtcbiAgfVxuICBnZXQgc3VwcG9ydHNQYXJhbGxlbENhbGxzKCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKF9hID0gdGhpcy5zZXR0aW5ncy5zdXBwb3J0c1BhcmFsbGVsQ2FsbHMpICE9IG51bGwgPyBfYSA6IHRydWU7XG4gIH1cbiAgYXN5bmMgZG9FbWJlZCh7XG4gICAgdmFsdWVzLFxuICAgIGhlYWRlcnMsXG4gICAgYWJvcnRTaWduYWxcbiAgfSkge1xuICAgIGlmICh2YWx1ZXMubGVuZ3RoID4gdGhpcy5tYXhFbWJlZGRpbmdzUGVyQ2FsbCkge1xuICAgICAgdGhyb3cgbmV3IFRvb01hbnlFbWJlZGRpbmdWYWx1ZXNGb3JDYWxsRXJyb3Ioe1xuICAgICAgICBwcm92aWRlcjogdGhpcy5wcm92aWRlcixcbiAgICAgICAgbW9kZWxJZDogdGhpcy5tb2RlbElkLFxuICAgICAgICBtYXhFbWJlZGRpbmdzUGVyQ2FsbDogdGhpcy5tYXhFbWJlZGRpbmdzUGVyQ2FsbCxcbiAgICAgICAgdmFsdWVzXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgeyByZXNwb25zZUhlYWRlcnMsIHZhbHVlOiByZXNwb25zZSB9ID0gYXdhaXQgcG9zdEpzb25Ub0FwaTMoe1xuICAgICAgdXJsOiB0aGlzLmNvbmZpZy51cmwoe1xuICAgICAgICBwYXRoOiBcIi9lbWJlZGRpbmdzXCIsXG4gICAgICAgIG1vZGVsSWQ6IHRoaXMubW9kZWxJZFxuICAgICAgfSksXG4gICAgICBoZWFkZXJzOiBjb21iaW5lSGVhZGVyczModGhpcy5jb25maWcuaGVhZGVycygpLCBoZWFkZXJzKSxcbiAgICAgIGJvZHk6IHtcbiAgICAgICAgbW9kZWw6IHRoaXMubW9kZWxJZCxcbiAgICAgICAgaW5wdXQ6IHZhbHVlcyxcbiAgICAgICAgZW5jb2RpbmdfZm9ybWF0OiBcImZsb2F0XCIsXG4gICAgICAgIGRpbWVuc2lvbnM6IHRoaXMuc2V0dGluZ3MuZGltZW5zaW9ucyxcbiAgICAgICAgdXNlcjogdGhpcy5zZXR0aW5ncy51c2VyXG4gICAgICB9LFxuICAgICAgZmFpbGVkUmVzcG9uc2VIYW5kbGVyOiBvcGVuYWlGYWlsZWRSZXNwb25zZUhhbmRsZXIsXG4gICAgICBzdWNjZXNzZnVsUmVzcG9uc2VIYW5kbGVyOiBjcmVhdGVKc29uUmVzcG9uc2VIYW5kbGVyMyhcbiAgICAgICAgb3BlbmFpVGV4dEVtYmVkZGluZ1Jlc3BvbnNlU2NoZW1hXG4gICAgICApLFxuICAgICAgYWJvcnRTaWduYWwsXG4gICAgICBmZXRjaDogdGhpcy5jb25maWcuZmV0Y2hcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgZW1iZWRkaW5nczogcmVzcG9uc2UuZGF0YS5tYXAoKGl0ZW0pID0+IGl0ZW0uZW1iZWRkaW5nKSxcbiAgICAgIHVzYWdlOiByZXNwb25zZS51c2FnZSA/IHsgdG9rZW5zOiByZXNwb25zZS51c2FnZS5wcm9tcHRfdG9rZW5zIH0gOiB2b2lkIDAsXG4gICAgICByYXdSZXNwb25zZTogeyBoZWFkZXJzOiByZXNwb25zZUhlYWRlcnMgfVxuICAgIH07XG4gIH1cbn07XG52YXIgb3BlbmFpVGV4dEVtYmVkZGluZ1Jlc3BvbnNlU2NoZW1hID0gejQub2JqZWN0KHtcbiAgZGF0YTogejQuYXJyYXkoejQub2JqZWN0KHsgZW1iZWRkaW5nOiB6NC5hcnJheSh6NC5udW1iZXIoKSkgfSkpLFxuICB1c2FnZTogejQub2JqZWN0KHsgcHJvbXB0X3Rva2VuczogejQubnVtYmVyKCkgfSkubnVsbGlzaCgpXG59KTtcblxuLy8gc3JjL29wZW5haS1pbWFnZS1tb2RlbC50c1xuaW1wb3J0IHtcbiAgY29tYmluZUhlYWRlcnMgYXMgY29tYmluZUhlYWRlcnM0LFxuICBjcmVhdGVKc29uUmVzcG9uc2VIYW5kbGVyIGFzIGNyZWF0ZUpzb25SZXNwb25zZUhhbmRsZXI0LFxuICBwb3N0SnNvblRvQXBpIGFzIHBvc3RKc29uVG9BcGk0XG59IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5pbXBvcnQgeyB6IGFzIHo1IH0gZnJvbSBcInpvZFwiO1xuXG4vLyBzcmMvb3BlbmFpLWltYWdlLXNldHRpbmdzLnRzXG52YXIgbW9kZWxNYXhJbWFnZXNQZXJDYWxsID0ge1xuICBcImRhbGwtZS0zXCI6IDEsXG4gIFwiZGFsbC1lLTJcIjogMTAsXG4gIFwiZ3B0LWltYWdlLTFcIjogMTBcbn07XG52YXIgaGFzRGVmYXVsdFJlc3BvbnNlRm9ybWF0ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1wiZ3B0LWltYWdlLTFcIl0pO1xuXG4vLyBzcmMvb3BlbmFpLWltYWdlLW1vZGVsLnRzXG52YXIgT3BlbkFJSW1hZ2VNb2RlbCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IobW9kZWxJZCwgc2V0dGluZ3MsIGNvbmZpZykge1xuICAgIHRoaXMubW9kZWxJZCA9IG1vZGVsSWQ7XG4gICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIHRoaXMuc3BlY2lmaWNhdGlvblZlcnNpb24gPSBcInYxXCI7XG4gIH1cbiAgZ2V0IG1heEltYWdlc1BlckNhbGwoKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5zZXR0aW5ncy5tYXhJbWFnZXNQZXJDYWxsKSAhPSBudWxsID8gX2EgOiBtb2RlbE1heEltYWdlc1BlckNhbGxbdGhpcy5tb2RlbElkXSkgIT0gbnVsbCA/IF9iIDogMTtcbiAgfVxuICBnZXQgcHJvdmlkZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLnByb3ZpZGVyO1xuICB9XG4gIGFzeW5jIGRvR2VuZXJhdGUoe1xuICAgIHByb21wdCxcbiAgICBuLFxuICAgIHNpemUsXG4gICAgYXNwZWN0UmF0aW8sXG4gICAgc2VlZCxcbiAgICBwcm92aWRlck9wdGlvbnMsXG4gICAgaGVhZGVycyxcbiAgICBhYm9ydFNpZ25hbFxuICB9KSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgIGNvbnN0IHdhcm5pbmdzID0gW107XG4gICAgaWYgKGFzcGVjdFJhdGlvICE9IG51bGwpIHtcbiAgICAgIHdhcm5pbmdzLnB1c2goe1xuICAgICAgICB0eXBlOiBcInVuc3VwcG9ydGVkLXNldHRpbmdcIixcbiAgICAgICAgc2V0dGluZzogXCJhc3BlY3RSYXRpb1wiLFxuICAgICAgICBkZXRhaWxzOiBcIlRoaXMgbW9kZWwgZG9lcyBub3Qgc3VwcG9ydCBhc3BlY3QgcmF0aW8uIFVzZSBgc2l6ZWAgaW5zdGVhZC5cIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChzZWVkICE9IG51bGwpIHtcbiAgICAgIHdhcm5pbmdzLnB1c2goeyB0eXBlOiBcInVuc3VwcG9ydGVkLXNldHRpbmdcIiwgc2V0dGluZzogXCJzZWVkXCIgfSk7XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnREYXRlID0gKF9jID0gKF9iID0gKF9hID0gdGhpcy5jb25maWcuX2ludGVybmFsKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY3VycmVudERhdGUpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKSkgIT0gbnVsbCA/IF9jIDogLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gICAgY29uc3QgeyB2YWx1ZTogcmVzcG9uc2UsIHJlc3BvbnNlSGVhZGVycyB9ID0gYXdhaXQgcG9zdEpzb25Ub0FwaTQoe1xuICAgICAgdXJsOiB0aGlzLmNvbmZpZy51cmwoe1xuICAgICAgICBwYXRoOiBcIi9pbWFnZXMvZ2VuZXJhdGlvbnNcIixcbiAgICAgICAgbW9kZWxJZDogdGhpcy5tb2RlbElkXG4gICAgICB9KSxcbiAgICAgIGhlYWRlcnM6IGNvbWJpbmVIZWFkZXJzNCh0aGlzLmNvbmZpZy5oZWFkZXJzKCksIGhlYWRlcnMpLFxuICAgICAgYm9keToge1xuICAgICAgICBtb2RlbDogdGhpcy5tb2RlbElkLFxuICAgICAgICBwcm9tcHQsXG4gICAgICAgIG4sXG4gICAgICAgIHNpemUsXG4gICAgICAgIC4uLihfZCA9IHByb3ZpZGVyT3B0aW9ucy5vcGVuYWkpICE9IG51bGwgPyBfZCA6IHt9LFxuICAgICAgICAuLi4haGFzRGVmYXVsdFJlc3BvbnNlRm9ybWF0Lmhhcyh0aGlzLm1vZGVsSWQpID8geyByZXNwb25zZV9mb3JtYXQ6IFwiYjY0X2pzb25cIiB9IDoge31cbiAgICAgIH0sXG4gICAgICBmYWlsZWRSZXNwb25zZUhhbmRsZXI6IG9wZW5haUZhaWxlZFJlc3BvbnNlSGFuZGxlcixcbiAgICAgIHN1Y2Nlc3NmdWxSZXNwb25zZUhhbmRsZXI6IGNyZWF0ZUpzb25SZXNwb25zZUhhbmRsZXI0KFxuICAgICAgICBvcGVuYWlJbWFnZVJlc3BvbnNlU2NoZW1hXG4gICAgICApLFxuICAgICAgYWJvcnRTaWduYWwsXG4gICAgICBmZXRjaDogdGhpcy5jb25maWcuZmV0Y2hcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgaW1hZ2VzOiByZXNwb25zZS5kYXRhLm1hcCgoaXRlbSkgPT4gaXRlbS5iNjRfanNvbiksXG4gICAgICB3YXJuaW5ncyxcbiAgICAgIHJlc3BvbnNlOiB7XG4gICAgICAgIHRpbWVzdGFtcDogY3VycmVudERhdGUsXG4gICAgICAgIG1vZGVsSWQ6IHRoaXMubW9kZWxJZCxcbiAgICAgICAgaGVhZGVyczogcmVzcG9uc2VIZWFkZXJzXG4gICAgICB9XG4gICAgfTtcbiAgfVxufTtcbnZhciBvcGVuYWlJbWFnZVJlc3BvbnNlU2NoZW1hID0gejUub2JqZWN0KHtcbiAgZGF0YTogejUuYXJyYXkoejUub2JqZWN0KHsgYjY0X2pzb246IHo1LnN0cmluZygpIH0pKVxufSk7XG5cbi8vIHNyYy9vcGVuYWktdHJhbnNjcmlwdGlvbi1tb2RlbC50c1xuaW1wb3J0IHtcbiAgY29tYmluZUhlYWRlcnMgYXMgY29tYmluZUhlYWRlcnM1LFxuICBjb252ZXJ0QmFzZTY0VG9VaW50OEFycmF5LFxuICBjcmVhdGVKc29uUmVzcG9uc2VIYW5kbGVyIGFzIGNyZWF0ZUpzb25SZXNwb25zZUhhbmRsZXI1LFxuICBwYXJzZVByb3ZpZGVyT3B0aW9ucyxcbiAgcG9zdEZvcm1EYXRhVG9BcGlcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbmltcG9ydCB7IHogYXMgejYgfSBmcm9tIFwiem9kXCI7XG52YXIgb3BlbkFJUHJvdmlkZXJPcHRpb25zU2NoZW1hID0gejYub2JqZWN0KHtcbiAgaW5jbHVkZTogejYuYXJyYXkoejYuc3RyaW5nKCkpLm51bGxpc2goKSxcbiAgbGFuZ3VhZ2U6IHo2LnN0cmluZygpLm51bGxpc2goKSxcbiAgcHJvbXB0OiB6Ni5zdHJpbmcoKS5udWxsaXNoKCksXG4gIHRlbXBlcmF0dXJlOiB6Ni5udW1iZXIoKS5taW4oMCkubWF4KDEpLm51bGxpc2goKS5kZWZhdWx0KDApLFxuICB0aW1lc3RhbXBHcmFudWxhcml0aWVzOiB6Ni5hcnJheSh6Ni5lbnVtKFtcIndvcmRcIiwgXCJzZWdtZW50XCJdKSkubnVsbGlzaCgpLmRlZmF1bHQoW1wic2VnbWVudFwiXSlcbn0pO1xudmFyIGxhbmd1YWdlTWFwID0ge1xuICBhZnJpa2FhbnM6IFwiYWZcIixcbiAgYXJhYmljOiBcImFyXCIsXG4gIGFybWVuaWFuOiBcImh5XCIsXG4gIGF6ZXJiYWlqYW5pOiBcImF6XCIsXG4gIGJlbGFydXNpYW46IFwiYmVcIixcbiAgYm9zbmlhbjogXCJic1wiLFxuICBidWxnYXJpYW46IFwiYmdcIixcbiAgY2F0YWxhbjogXCJjYVwiLFxuICBjaGluZXNlOiBcInpoXCIsXG4gIGNyb2F0aWFuOiBcImhyXCIsXG4gIGN6ZWNoOiBcImNzXCIsXG4gIGRhbmlzaDogXCJkYVwiLFxuICBkdXRjaDogXCJubFwiLFxuICBlbmdsaXNoOiBcImVuXCIsXG4gIGVzdG9uaWFuOiBcImV0XCIsXG4gIGZpbm5pc2g6IFwiZmlcIixcbiAgZnJlbmNoOiBcImZyXCIsXG4gIGdhbGljaWFuOiBcImdsXCIsXG4gIGdlcm1hbjogXCJkZVwiLFxuICBncmVlazogXCJlbFwiLFxuICBoZWJyZXc6IFwiaGVcIixcbiAgaGluZGk6IFwiaGlcIixcbiAgaHVuZ2FyaWFuOiBcImh1XCIsXG4gIGljZWxhbmRpYzogXCJpc1wiLFxuICBpbmRvbmVzaWFuOiBcImlkXCIsXG4gIGl0YWxpYW46IFwiaXRcIixcbiAgamFwYW5lc2U6IFwiamFcIixcbiAga2FubmFkYTogXCJrblwiLFxuICBrYXpha2g6IFwia2tcIixcbiAga29yZWFuOiBcImtvXCIsXG4gIGxhdHZpYW46IFwibHZcIixcbiAgbGl0aHVhbmlhbjogXCJsdFwiLFxuICBtYWNlZG9uaWFuOiBcIm1rXCIsXG4gIG1hbGF5OiBcIm1zXCIsXG4gIG1hcmF0aGk6IFwibXJcIixcbiAgbWFvcmk6IFwibWlcIixcbiAgbmVwYWxpOiBcIm5lXCIsXG4gIG5vcndlZ2lhbjogXCJub1wiLFxuICBwZXJzaWFuOiBcImZhXCIsXG4gIHBvbGlzaDogXCJwbFwiLFxuICBwb3J0dWd1ZXNlOiBcInB0XCIsXG4gIHJvbWFuaWFuOiBcInJvXCIsXG4gIHJ1c3NpYW46IFwicnVcIixcbiAgc2VyYmlhbjogXCJzclwiLFxuICBzbG92YWs6IFwic2tcIixcbiAgc2xvdmVuaWFuOiBcInNsXCIsXG4gIHNwYW5pc2g6IFwiZXNcIixcbiAgc3dhaGlsaTogXCJzd1wiLFxuICBzd2VkaXNoOiBcInN2XCIsXG4gIHRhZ2Fsb2c6IFwidGxcIixcbiAgdGFtaWw6IFwidGFcIixcbiAgdGhhaTogXCJ0aFwiLFxuICB0dXJraXNoOiBcInRyXCIsXG4gIHVrcmFpbmlhbjogXCJ1a1wiLFxuICB1cmR1OiBcInVyXCIsXG4gIHZpZXRuYW1lc2U6IFwidmlcIixcbiAgd2Vsc2g6IFwiY3lcIlxufTtcbnZhciBPcGVuQUlUcmFuc2NyaXB0aW9uTW9kZWwgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG1vZGVsSWQsIGNvbmZpZykge1xuICAgIHRoaXMubW9kZWxJZCA9IG1vZGVsSWQ7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy5zcGVjaWZpY2F0aW9uVmVyc2lvbiA9IFwidjFcIjtcbiAgfVxuICBnZXQgcHJvdmlkZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLnByb3ZpZGVyO1xuICB9XG4gIGdldEFyZ3Moe1xuICAgIGF1ZGlvLFxuICAgIG1lZGlhVHlwZSxcbiAgICBwcm92aWRlck9wdGlvbnNcbiAgfSkge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2U7XG4gICAgY29uc3Qgd2FybmluZ3MgPSBbXTtcbiAgICBjb25zdCBvcGVuQUlPcHRpb25zID0gcGFyc2VQcm92aWRlck9wdGlvbnMoe1xuICAgICAgcHJvdmlkZXI6IFwib3BlbmFpXCIsXG4gICAgICBwcm92aWRlck9wdGlvbnMsXG4gICAgICBzY2hlbWE6IG9wZW5BSVByb3ZpZGVyT3B0aW9uc1NjaGVtYVxuICAgIH0pO1xuICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgY29uc3QgYmxvYiA9IGF1ZGlvIGluc3RhbmNlb2YgVWludDhBcnJheSA/IG5ldyBCbG9iKFthdWRpb10pIDogbmV3IEJsb2IoW2NvbnZlcnRCYXNlNjRUb1VpbnQ4QXJyYXkoYXVkaW8pXSk7XG4gICAgZm9ybURhdGEuYXBwZW5kKFwibW9kZWxcIiwgdGhpcy5tb2RlbElkKTtcbiAgICBmb3JtRGF0YS5hcHBlbmQoXCJmaWxlXCIsIG5ldyBGaWxlKFtibG9iXSwgXCJhdWRpb1wiLCB7IHR5cGU6IG1lZGlhVHlwZSB9KSk7XG4gICAgaWYgKG9wZW5BSU9wdGlvbnMpIHtcbiAgICAgIGNvbnN0IHRyYW5zY3JpcHRpb25Nb2RlbE9wdGlvbnMgPSB7XG4gICAgICAgIGluY2x1ZGU6IChfYSA9IG9wZW5BSU9wdGlvbnMuaW5jbHVkZSkgIT0gbnVsbCA/IF9hIDogdm9pZCAwLFxuICAgICAgICBsYW5ndWFnZTogKF9iID0gb3BlbkFJT3B0aW9ucy5sYW5ndWFnZSkgIT0gbnVsbCA/IF9iIDogdm9pZCAwLFxuICAgICAgICBwcm9tcHQ6IChfYyA9IG9wZW5BSU9wdGlvbnMucHJvbXB0KSAhPSBudWxsID8gX2MgOiB2b2lkIDAsXG4gICAgICAgIHRlbXBlcmF0dXJlOiAoX2QgPSBvcGVuQUlPcHRpb25zLnRlbXBlcmF0dXJlKSAhPSBudWxsID8gX2QgOiB2b2lkIDAsXG4gICAgICAgIHRpbWVzdGFtcF9ncmFudWxhcml0aWVzOiAoX2UgPSBvcGVuQUlPcHRpb25zLnRpbWVzdGFtcEdyYW51bGFyaXRpZXMpICE9IG51bGwgPyBfZSA6IHZvaWQgMFxuICAgICAgfTtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHRyYW5zY3JpcHRpb25Nb2RlbE9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0cmFuc2NyaXB0aW9uTW9kZWxPcHRpb25zW2tleV07XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgZm9ybURhdGEuYXBwZW5kKGtleSwgU3RyaW5nKHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGZvcm1EYXRhLFxuICAgICAgd2FybmluZ3NcbiAgICB9O1xuICB9XG4gIGFzeW5jIGRvR2VuZXJhdGUob3B0aW9ucykge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgIGNvbnN0IGN1cnJlbnREYXRlID0gKF9jID0gKF9iID0gKF9hID0gdGhpcy5jb25maWcuX2ludGVybmFsKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY3VycmVudERhdGUpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKSkgIT0gbnVsbCA/IF9jIDogLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gICAgY29uc3QgeyBmb3JtRGF0YSwgd2FybmluZ3MgfSA9IHRoaXMuZ2V0QXJncyhvcHRpb25zKTtcbiAgICBjb25zdCB7XG4gICAgICB2YWx1ZTogcmVzcG9uc2UsXG4gICAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgICByYXdWYWx1ZTogcmF3UmVzcG9uc2VcbiAgICB9ID0gYXdhaXQgcG9zdEZvcm1EYXRhVG9BcGkoe1xuICAgICAgdXJsOiB0aGlzLmNvbmZpZy51cmwoe1xuICAgICAgICBwYXRoOiBcIi9hdWRpby90cmFuc2NyaXB0aW9uc1wiLFxuICAgICAgICBtb2RlbElkOiB0aGlzLm1vZGVsSWRcbiAgICAgIH0pLFxuICAgICAgaGVhZGVyczogY29tYmluZUhlYWRlcnM1KHRoaXMuY29uZmlnLmhlYWRlcnMoKSwgb3B0aW9ucy5oZWFkZXJzKSxcbiAgICAgIGZvcm1EYXRhLFxuICAgICAgZmFpbGVkUmVzcG9uc2VIYW5kbGVyOiBvcGVuYWlGYWlsZWRSZXNwb25zZUhhbmRsZXIsXG4gICAgICBzdWNjZXNzZnVsUmVzcG9uc2VIYW5kbGVyOiBjcmVhdGVKc29uUmVzcG9uc2VIYW5kbGVyNShcbiAgICAgICAgb3BlbmFpVHJhbnNjcmlwdGlvblJlc3BvbnNlU2NoZW1hXG4gICAgICApLFxuICAgICAgYWJvcnRTaWduYWw6IG9wdGlvbnMuYWJvcnRTaWduYWwsXG4gICAgICBmZXRjaDogdGhpcy5jb25maWcuZmV0Y2hcbiAgICB9KTtcbiAgICBjb25zdCBsYW5ndWFnZSA9IHJlc3BvbnNlLmxhbmd1YWdlICE9IG51bGwgJiYgcmVzcG9uc2UubGFuZ3VhZ2UgaW4gbGFuZ3VhZ2VNYXAgPyBsYW5ndWFnZU1hcFtyZXNwb25zZS5sYW5ndWFnZV0gOiB2b2lkIDA7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRleHQ6IHJlc3BvbnNlLnRleHQsXG4gICAgICBzZWdtZW50czogKF9lID0gKF9kID0gcmVzcG9uc2Uud29yZHMpID09IG51bGwgPyB2b2lkIDAgOiBfZC5tYXAoKHdvcmQpID0+ICh7XG4gICAgICAgIHRleHQ6IHdvcmQud29yZCxcbiAgICAgICAgc3RhcnRTZWNvbmQ6IHdvcmQuc3RhcnQsXG4gICAgICAgIGVuZFNlY29uZDogd29yZC5lbmRcbiAgICAgIH0pKSkgIT0gbnVsbCA/IF9lIDogW10sXG4gICAgICBsYW5ndWFnZSxcbiAgICAgIGR1cmF0aW9uSW5TZWNvbmRzOiAoX2YgPSByZXNwb25zZS5kdXJhdGlvbikgIT0gbnVsbCA/IF9mIDogdm9pZCAwLFxuICAgICAgd2FybmluZ3MsXG4gICAgICByZXNwb25zZToge1xuICAgICAgICB0aW1lc3RhbXA6IGN1cnJlbnREYXRlLFxuICAgICAgICBtb2RlbElkOiB0aGlzLm1vZGVsSWQsXG4gICAgICAgIGhlYWRlcnM6IHJlc3BvbnNlSGVhZGVycyxcbiAgICAgICAgYm9keTogcmF3UmVzcG9uc2VcbiAgICAgIH1cbiAgICB9O1xuICB9XG59O1xudmFyIG9wZW5haVRyYW5zY3JpcHRpb25SZXNwb25zZVNjaGVtYSA9IHo2Lm9iamVjdCh7XG4gIHRleHQ6IHo2LnN0cmluZygpLFxuICBsYW5ndWFnZTogejYuc3RyaW5nKCkubnVsbGlzaCgpLFxuICBkdXJhdGlvbjogejYubnVtYmVyKCkubnVsbGlzaCgpLFxuICB3b3JkczogejYuYXJyYXkoXG4gICAgejYub2JqZWN0KHtcbiAgICAgIHdvcmQ6IHo2LnN0cmluZygpLFxuICAgICAgc3RhcnQ6IHo2Lm51bWJlcigpLFxuICAgICAgZW5kOiB6Ni5udW1iZXIoKVxuICAgIH0pXG4gICkubnVsbGlzaCgpXG59KTtcblxuLy8gc3JjL3Jlc3BvbnNlcy9vcGVuYWktcmVzcG9uc2VzLWxhbmd1YWdlLW1vZGVsLnRzXG5pbXBvcnQge1xuICBjb21iaW5lSGVhZGVycyBhcyBjb21iaW5lSGVhZGVyczYsXG4gIGNyZWF0ZUV2ZW50U291cmNlUmVzcG9uc2VIYW5kbGVyIGFzIGNyZWF0ZUV2ZW50U291cmNlUmVzcG9uc2VIYW5kbGVyMyxcbiAgY3JlYXRlSnNvblJlc3BvbnNlSGFuZGxlciBhcyBjcmVhdGVKc29uUmVzcG9uc2VIYW5kbGVyNixcbiAgZ2VuZXJhdGVJZCBhcyBnZW5lcmF0ZUlkMixcbiAgcGFyc2VQcm92aWRlck9wdGlvbnMgYXMgcGFyc2VQcm92aWRlck9wdGlvbnMyLFxuICBwb3N0SnNvblRvQXBpIGFzIHBvc3RKc29uVG9BcGk1XG59IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5pbXBvcnQgeyB6IGFzIHo3IH0gZnJvbSBcInpvZFwiO1xuXG4vLyBzcmMvcmVzcG9uc2VzL2NvbnZlcnQtdG8tb3BlbmFpLXJlc3BvbnNlcy1tZXNzYWdlcy50c1xuaW1wb3J0IHtcbiAgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3IgYXMgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3I2XG59IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5pbXBvcnQgeyBjb252ZXJ0VWludDhBcnJheVRvQmFzZTY0IGFzIGNvbnZlcnRVaW50OEFycmF5VG9CYXNlNjQyIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbmZ1bmN0aW9uIGNvbnZlcnRUb09wZW5BSVJlc3BvbnNlc01lc3NhZ2VzKHtcbiAgcHJvbXB0LFxuICBzeXN0ZW1NZXNzYWdlTW9kZVxufSkge1xuICBjb25zdCBtZXNzYWdlcyA9IFtdO1xuICBjb25zdCB3YXJuaW5ncyA9IFtdO1xuICBmb3IgKGNvbnN0IHsgcm9sZSwgY29udGVudCB9IG9mIHByb21wdCkge1xuICAgIHN3aXRjaCAocm9sZSkge1xuICAgICAgY2FzZSBcInN5c3RlbVwiOiB7XG4gICAgICAgIHN3aXRjaCAoc3lzdGVtTWVzc2FnZU1vZGUpIHtcbiAgICAgICAgICBjYXNlIFwic3lzdGVtXCI6IHtcbiAgICAgICAgICAgIG1lc3NhZ2VzLnB1c2goeyByb2xlOiBcInN5c3RlbVwiLCBjb250ZW50IH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJkZXZlbG9wZXJcIjoge1xuICAgICAgICAgICAgbWVzc2FnZXMucHVzaCh7IHJvbGU6IFwiZGV2ZWxvcGVyXCIsIGNvbnRlbnQgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcInJlbW92ZVwiOiB7XG4gICAgICAgICAgICB3YXJuaW5ncy5wdXNoKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJvdGhlclwiLFxuICAgICAgICAgICAgICBtZXNzYWdlOiBcInN5c3RlbSBtZXNzYWdlcyBhcmUgcmVtb3ZlZCBmb3IgdGhpcyBtb2RlbFwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICBjb25zdCBfZXhoYXVzdGl2ZUNoZWNrID0gc3lzdGVtTWVzc2FnZU1vZGU7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIGBVbnN1cHBvcnRlZCBzeXN0ZW0gbWVzc2FnZSBtb2RlOiAke19leGhhdXN0aXZlQ2hlY2t9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwidXNlclwiOiB7XG4gICAgICAgIG1lc3NhZ2VzLnB1c2goe1xuICAgICAgICAgIHJvbGU6IFwidXNlclwiLFxuICAgICAgICAgIGNvbnRlbnQ6IGNvbnRlbnQubWFwKChwYXJ0LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICAgICAgc3dpdGNoIChwYXJ0LnR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSBcInRleHRcIjoge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwiaW5wdXRfdGV4dFwiLCB0ZXh0OiBwYXJ0LnRleHQgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIFwiaW1hZ2VcIjoge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcImlucHV0X2ltYWdlXCIsXG4gICAgICAgICAgICAgICAgICBpbWFnZV91cmw6IHBhcnQuaW1hZ2UgaW5zdGFuY2VvZiBVUkwgPyBwYXJ0LmltYWdlLnRvU3RyaW5nKCkgOiBgZGF0YTokeyhfYSA9IHBhcnQubWltZVR5cGUpICE9IG51bGwgPyBfYSA6IFwiaW1hZ2UvanBlZ1wifTtiYXNlNjQsJHtjb252ZXJ0VWludDhBcnJheVRvQmFzZTY0MihwYXJ0LmltYWdlKX1gLFxuICAgICAgICAgICAgICAgICAgLy8gT3BlbkFJIHNwZWNpZmljIGV4dGVuc2lvbjogaW1hZ2UgZGV0YWlsXG4gICAgICAgICAgICAgICAgICBkZXRhaWw6IChfYyA9IChfYiA9IHBhcnQucHJvdmlkZXJNZXRhZGF0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLm9wZW5haSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLmltYWdlRGV0YWlsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIFwiZmlsZVwiOiB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnQuZGF0YSBpbnN0YW5jZW9mIFVSTCkge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yNih7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uYWxpdHk6IFwiRmlsZSBVUkxzIGluIHVzZXIgbWVzc2FnZXNcIlxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN3aXRjaCAocGFydC5taW1lVHlwZSkge1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImFwcGxpY2F0aW9uL3BkZlwiOiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJpbnB1dF9maWxlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgZmlsZW5hbWU6IChfZCA9IHBhcnQuZmlsZW5hbWUpICE9IG51bGwgPyBfZCA6IGBwYXJ0LSR7aW5kZXh9LnBkZmAsXG4gICAgICAgICAgICAgICAgICAgICAgZmlsZV9kYXRhOiBgZGF0YTphcHBsaWNhdGlvbi9wZGY7YmFzZTY0LCR7cGFydC5kYXRhfWBcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yNih7XG4gICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25hbGl0eTogXCJPbmx5IFBERiBmaWxlcyBhcmUgc3VwcG9ydGVkIGluIHVzZXIgbWVzc2FnZXNcIlxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiYXNzaXN0YW50XCI6IHtcbiAgICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIGNvbnRlbnQpIHtcbiAgICAgICAgICBzd2l0Y2ggKHBhcnQudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcInRleHRcIjoge1xuICAgICAgICAgICAgICBtZXNzYWdlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IFt7IHR5cGU6IFwib3V0cHV0X3RleHRcIiwgdGV4dDogcGFydC50ZXh0IH1dXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJ0b29sLWNhbGxcIjoge1xuICAgICAgICAgICAgICBtZXNzYWdlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImZ1bmN0aW9uX2NhbGxcIixcbiAgICAgICAgICAgICAgICBjYWxsX2lkOiBwYXJ0LnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgbmFtZTogcGFydC50b29sTmFtZSxcbiAgICAgICAgICAgICAgICBhcmd1bWVudHM6IEpTT04uc3RyaW5naWZ5KHBhcnQuYXJncylcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJ0b29sXCI6IHtcbiAgICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIGNvbnRlbnQpIHtcbiAgICAgICAgICBtZXNzYWdlcy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb25fY2FsbF9vdXRwdXRcIixcbiAgICAgICAgICAgIGNhbGxfaWQ6IHBhcnQudG9vbENhbGxJZCxcbiAgICAgICAgICAgIG91dHB1dDogSlNPTi5zdHJpbmdpZnkocGFydC5yZXN1bHQpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIGNvbnN0IF9leGhhdXN0aXZlQ2hlY2sgPSByb2xlO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHJvbGU6ICR7X2V4aGF1c3RpdmVDaGVja31gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHsgbWVzc2FnZXMsIHdhcm5pbmdzIH07XG59XG5cbi8vIHNyYy9yZXNwb25zZXMvbWFwLW9wZW5haS1yZXNwb25zZXMtZmluaXNoLXJlYXNvbi50c1xuZnVuY3Rpb24gbWFwT3BlbkFJUmVzcG9uc2VGaW5pc2hSZWFzb24oe1xuICBmaW5pc2hSZWFzb24sXG4gIGhhc1Rvb2xDYWxsc1xufSkge1xuICBzd2l0Y2ggKGZpbmlzaFJlYXNvbikge1xuICAgIGNhc2Ugdm9pZCAwOlxuICAgIGNhc2UgbnVsbDpcbiAgICAgIHJldHVybiBoYXNUb29sQ2FsbHMgPyBcInRvb2wtY2FsbHNcIiA6IFwic3RvcFwiO1xuICAgIGNhc2UgXCJtYXhfb3V0cHV0X3Rva2Vuc1wiOlxuICAgICAgcmV0dXJuIFwibGVuZ3RoXCI7XG4gICAgY2FzZSBcImNvbnRlbnRfZmlsdGVyXCI6XG4gICAgICByZXR1cm4gXCJjb250ZW50LWZpbHRlclwiO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gaGFzVG9vbENhbGxzID8gXCJ0b29sLWNhbGxzXCIgOiBcInVua25vd25cIjtcbiAgfVxufVxuXG4vLyBzcmMvcmVzcG9uc2VzL29wZW5haS1yZXNwb25zZXMtcHJlcGFyZS10b29scy50c1xuaW1wb3J0IHtcbiAgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3IgYXMgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3I3XG59IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5mdW5jdGlvbiBwcmVwYXJlUmVzcG9uc2VzVG9vbHMoe1xuICBtb2RlLFxuICBzdHJpY3Rcbn0pIHtcbiAgdmFyIF9hO1xuICBjb25zdCB0b29scyA9ICgoX2EgPSBtb2RlLnRvb2xzKSA9PSBudWxsID8gdm9pZCAwIDogX2EubGVuZ3RoKSA/IG1vZGUudG9vbHMgOiB2b2lkIDA7XG4gIGNvbnN0IHRvb2xXYXJuaW5ncyA9IFtdO1xuICBpZiAodG9vbHMgPT0gbnVsbCkge1xuICAgIHJldHVybiB7IHRvb2xzOiB2b2lkIDAsIHRvb2xfY2hvaWNlOiB2b2lkIDAsIHRvb2xXYXJuaW5ncyB9O1xuICB9XG4gIGNvbnN0IHRvb2xDaG9pY2UgPSBtb2RlLnRvb2xDaG9pY2U7XG4gIGNvbnN0IG9wZW5haVRvb2xzMiA9IFtdO1xuICBmb3IgKGNvbnN0IHRvb2wgb2YgdG9vbHMpIHtcbiAgICBzd2l0Y2ggKHRvb2wudHlwZSkge1xuICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgIG9wZW5haVRvb2xzMi5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgbmFtZTogdG9vbC5uYW1lLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiB0b29sLmRlc2NyaXB0aW9uLFxuICAgICAgICAgIHBhcmFtZXRlcnM6IHRvb2wucGFyYW1ldGVycyxcbiAgICAgICAgICBzdHJpY3Q6IHN0cmljdCA/IHRydWUgOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInByb3ZpZGVyLWRlZmluZWRcIjpcbiAgICAgICAgc3dpdGNoICh0b29sLmlkKSB7XG4gICAgICAgICAgY2FzZSBcIm9wZW5haS53ZWJfc2VhcmNoX3ByZXZpZXdcIjpcbiAgICAgICAgICAgIG9wZW5haVRvb2xzMi5wdXNoKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJ3ZWJfc2VhcmNoX3ByZXZpZXdcIixcbiAgICAgICAgICAgICAgc2VhcmNoX2NvbnRleHRfc2l6ZTogdG9vbC5hcmdzLnNlYXJjaENvbnRleHRTaXplLFxuICAgICAgICAgICAgICB1c2VyX2xvY2F0aW9uOiB0b29sLmFyZ3MudXNlckxvY2F0aW9uXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0b29sV2FybmluZ3MucHVzaCh7IHR5cGU6IFwidW5zdXBwb3J0ZWQtdG9vbFwiLCB0b29sIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0b29sV2FybmluZ3MucHVzaCh7IHR5cGU6IFwidW5zdXBwb3J0ZWQtdG9vbFwiLCB0b29sIH0pO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgaWYgKHRvb2xDaG9pY2UgPT0gbnVsbCkge1xuICAgIHJldHVybiB7IHRvb2xzOiBvcGVuYWlUb29sczIsIHRvb2xfY2hvaWNlOiB2b2lkIDAsIHRvb2xXYXJuaW5ncyB9O1xuICB9XG4gIGNvbnN0IHR5cGUgPSB0b29sQ2hvaWNlLnR5cGU7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgXCJhdXRvXCI6XG4gICAgY2FzZSBcIm5vbmVcIjpcbiAgICBjYXNlIFwicmVxdWlyZWRcIjpcbiAgICAgIHJldHVybiB7IHRvb2xzOiBvcGVuYWlUb29sczIsIHRvb2xfY2hvaWNlOiB0eXBlLCB0b29sV2FybmluZ3MgfTtcbiAgICBjYXNlIFwidG9vbFwiOiB7XG4gICAgICBpZiAodG9vbENob2ljZS50b29sTmFtZSA9PT0gXCJ3ZWJfc2VhcmNoX3ByZXZpZXdcIikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRvb2xzOiBvcGVuYWlUb29sczIsXG4gICAgICAgICAgdG9vbF9jaG9pY2U6IHtcbiAgICAgICAgICAgIHR5cGU6IFwid2ViX3NlYXJjaF9wcmV2aWV3XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRvb2xXYXJuaW5nc1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG9vbHM6IG9wZW5haVRvb2xzMixcbiAgICAgICAgdG9vbF9jaG9pY2U6IHtcbiAgICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgbmFtZTogdG9vbENob2ljZS50b29sTmFtZVxuICAgICAgICB9LFxuICAgICAgICB0b29sV2FybmluZ3NcbiAgICAgIH07XG4gICAgfVxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIGNvbnN0IF9leGhhdXN0aXZlQ2hlY2sgPSB0eXBlO1xuICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yNyh7XG4gICAgICAgIGZ1bmN0aW9uYWxpdHk6IGBVbnN1cHBvcnRlZCB0b29sIGNob2ljZSB0eXBlOiAke19leGhhdXN0aXZlQ2hlY2t9YFxuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5cbi8vIHNyYy9yZXNwb25zZXMvb3BlbmFpLXJlc3BvbnNlcy1sYW5ndWFnZS1tb2RlbC50c1xudmFyIE9wZW5BSVJlc3BvbnNlc0xhbmd1YWdlTW9kZWwgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG1vZGVsSWQsIGNvbmZpZykge1xuICAgIHRoaXMuc3BlY2lmaWNhdGlvblZlcnNpb24gPSBcInYxXCI7XG4gICAgdGhpcy5kZWZhdWx0T2JqZWN0R2VuZXJhdGlvbk1vZGUgPSBcImpzb25cIjtcbiAgICB0aGlzLnN1cHBvcnRzU3RydWN0dXJlZE91dHB1dHMgPSB0cnVlO1xuICAgIHRoaXMubW9kZWxJZCA9IG1vZGVsSWQ7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gIH1cbiAgZ2V0IHByb3ZpZGVyKCkge1xuICAgIHJldHVybiB0aGlzLmNvbmZpZy5wcm92aWRlcjtcbiAgfVxuICBnZXRBcmdzKHtcbiAgICBtb2RlLFxuICAgIG1heFRva2VucyxcbiAgICB0ZW1wZXJhdHVyZSxcbiAgICBzdG9wU2VxdWVuY2VzLFxuICAgIHRvcFAsXG4gICAgdG9wSyxcbiAgICBwcmVzZW5jZVBlbmFsdHksXG4gICAgZnJlcXVlbmN5UGVuYWx0eSxcbiAgICBzZWVkLFxuICAgIHByb21wdCxcbiAgICBwcm92aWRlck1ldGFkYXRhLFxuICAgIHJlc3BvbnNlRm9ybWF0XG4gIH0pIHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICBjb25zdCB3YXJuaW5ncyA9IFtdO1xuICAgIGNvbnN0IG1vZGVsQ29uZmlnID0gZ2V0UmVzcG9uc2VzTW9kZWxDb25maWcodGhpcy5tb2RlbElkKTtcbiAgICBjb25zdCB0eXBlID0gbW9kZS50eXBlO1xuICAgIGlmICh0b3BLICE9IG51bGwpIHtcbiAgICAgIHdhcm5pbmdzLnB1c2goe1xuICAgICAgICB0eXBlOiBcInVuc3VwcG9ydGVkLXNldHRpbmdcIixcbiAgICAgICAgc2V0dGluZzogXCJ0b3BLXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoc2VlZCAhPSBudWxsKSB7XG4gICAgICB3YXJuaW5ncy5wdXNoKHtcbiAgICAgICAgdHlwZTogXCJ1bnN1cHBvcnRlZC1zZXR0aW5nXCIsXG4gICAgICAgIHNldHRpbmc6IFwic2VlZFwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHByZXNlbmNlUGVuYWx0eSAhPSBudWxsKSB7XG4gICAgICB3YXJuaW5ncy5wdXNoKHtcbiAgICAgICAgdHlwZTogXCJ1bnN1cHBvcnRlZC1zZXR0aW5nXCIsXG4gICAgICAgIHNldHRpbmc6IFwicHJlc2VuY2VQZW5hbHR5XCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoZnJlcXVlbmN5UGVuYWx0eSAhPSBudWxsKSB7XG4gICAgICB3YXJuaW5ncy5wdXNoKHtcbiAgICAgICAgdHlwZTogXCJ1bnN1cHBvcnRlZC1zZXR0aW5nXCIsXG4gICAgICAgIHNldHRpbmc6IFwiZnJlcXVlbmN5UGVuYWx0eVwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHN0b3BTZXF1ZW5jZXMgIT0gbnVsbCkge1xuICAgICAgd2FybmluZ3MucHVzaCh7XG4gICAgICAgIHR5cGU6IFwidW5zdXBwb3J0ZWQtc2V0dGluZ1wiLFxuICAgICAgICBzZXR0aW5nOiBcInN0b3BTZXF1ZW5jZXNcIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHsgbWVzc2FnZXMsIHdhcm5pbmdzOiBtZXNzYWdlV2FybmluZ3MgfSA9IGNvbnZlcnRUb09wZW5BSVJlc3BvbnNlc01lc3NhZ2VzKHtcbiAgICAgIHByb21wdCxcbiAgICAgIHN5c3RlbU1lc3NhZ2VNb2RlOiBtb2RlbENvbmZpZy5zeXN0ZW1NZXNzYWdlTW9kZVxuICAgIH0pO1xuICAgIHdhcm5pbmdzLnB1c2goLi4ubWVzc2FnZVdhcm5pbmdzKTtcbiAgICBjb25zdCBvcGVuYWlPcHRpb25zID0gcGFyc2VQcm92aWRlck9wdGlvbnMyKHtcbiAgICAgIHByb3ZpZGVyOiBcIm9wZW5haVwiLFxuICAgICAgcHJvdmlkZXJPcHRpb25zOiBwcm92aWRlck1ldGFkYXRhLFxuICAgICAgc2NoZW1hOiBvcGVuYWlSZXNwb25zZXNQcm92aWRlck9wdGlvbnNTY2hlbWFcbiAgICB9KTtcbiAgICBjb25zdCBpc1N0cmljdCA9IChfYSA9IG9wZW5haU9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wZW5haU9wdGlvbnMuc3RyaWN0U2NoZW1hcykgIT0gbnVsbCA/IF9hIDogdHJ1ZTtcbiAgICBjb25zdCBiYXNlQXJncyA9IHtcbiAgICAgIG1vZGVsOiB0aGlzLm1vZGVsSWQsXG4gICAgICBpbnB1dDogbWVzc2FnZXMsXG4gICAgICB0ZW1wZXJhdHVyZSxcbiAgICAgIHRvcF9wOiB0b3BQLFxuICAgICAgbWF4X291dHB1dF90b2tlbnM6IG1heFRva2VucyxcbiAgICAgIC4uLihyZXNwb25zZUZvcm1hdCA9PSBudWxsID8gdm9pZCAwIDogcmVzcG9uc2VGb3JtYXQudHlwZSkgPT09IFwianNvblwiICYmIHtcbiAgICAgICAgdGV4dDoge1xuICAgICAgICAgIGZvcm1hdDogcmVzcG9uc2VGb3JtYXQuc2NoZW1hICE9IG51bGwgPyB7XG4gICAgICAgICAgICB0eXBlOiBcImpzb25fc2NoZW1hXCIsXG4gICAgICAgICAgICBzdHJpY3Q6IGlzU3RyaWN0LFxuICAgICAgICAgICAgbmFtZTogKF9iID0gcmVzcG9uc2VGb3JtYXQubmFtZSkgIT0gbnVsbCA/IF9iIDogXCJyZXNwb25zZVwiLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IHJlc3BvbnNlRm9ybWF0LmRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgc2NoZW1hOiByZXNwb25zZUZvcm1hdC5zY2hlbWFcbiAgICAgICAgICB9IDogeyB0eXBlOiBcImpzb25fb2JqZWN0XCIgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gcHJvdmlkZXIgb3B0aW9uczpcbiAgICAgIG1ldGFkYXRhOiBvcGVuYWlPcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcGVuYWlPcHRpb25zLm1ldGFkYXRhLFxuICAgICAgcGFyYWxsZWxfdG9vbF9jYWxsczogb3BlbmFpT3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3BlbmFpT3B0aW9ucy5wYXJhbGxlbFRvb2xDYWxscyxcbiAgICAgIHByZXZpb3VzX3Jlc3BvbnNlX2lkOiBvcGVuYWlPcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcGVuYWlPcHRpb25zLnByZXZpb3VzUmVzcG9uc2VJZCxcbiAgICAgIHN0b3JlOiBvcGVuYWlPcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcGVuYWlPcHRpb25zLnN0b3JlLFxuICAgICAgdXNlcjogb3BlbmFpT3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3BlbmFpT3B0aW9ucy51c2VyLFxuICAgICAgaW5zdHJ1Y3Rpb25zOiBvcGVuYWlPcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcGVuYWlPcHRpb25zLmluc3RydWN0aW9ucyxcbiAgICAgIC8vIG1vZGVsLXNwZWNpZmljIHNldHRpbmdzOlxuICAgICAgLi4ubW9kZWxDb25maWcuaXNSZWFzb25pbmdNb2RlbCAmJiAoKG9wZW5haU9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wZW5haU9wdGlvbnMucmVhc29uaW5nRWZmb3J0KSAhPSBudWxsIHx8IChvcGVuYWlPcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcGVuYWlPcHRpb25zLnJlYXNvbmluZ1N1bW1hcnkpICE9IG51bGwpICYmIHtcbiAgICAgICAgcmVhc29uaW5nOiB7XG4gICAgICAgICAgLi4uKG9wZW5haU9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wZW5haU9wdGlvbnMucmVhc29uaW5nRWZmb3J0KSAhPSBudWxsICYmIHtcbiAgICAgICAgICAgIGVmZm9ydDogb3BlbmFpT3B0aW9ucy5yZWFzb25pbmdFZmZvcnRcbiAgICAgICAgICB9LFxuICAgICAgICAgIC4uLihvcGVuYWlPcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcGVuYWlPcHRpb25zLnJlYXNvbmluZ1N1bW1hcnkpICE9IG51bGwgJiYge1xuICAgICAgICAgICAgc3VtbWFyeTogb3BlbmFpT3B0aW9ucy5yZWFzb25pbmdTdW1tYXJ5XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLi4ubW9kZWxDb25maWcucmVxdWlyZWRBdXRvVHJ1bmNhdGlvbiAmJiB7XG4gICAgICAgIHRydW5jYXRpb246IFwiYXV0b1wiXG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAobW9kZWxDb25maWcuaXNSZWFzb25pbmdNb2RlbCkge1xuICAgICAgaWYgKGJhc2VBcmdzLnRlbXBlcmF0dXJlICE9IG51bGwpIHtcbiAgICAgICAgYmFzZUFyZ3MudGVtcGVyYXR1cmUgPSB2b2lkIDA7XG4gICAgICAgIHdhcm5pbmdzLnB1c2goe1xuICAgICAgICAgIHR5cGU6IFwidW5zdXBwb3J0ZWQtc2V0dGluZ1wiLFxuICAgICAgICAgIHNldHRpbmc6IFwidGVtcGVyYXR1cmVcIixcbiAgICAgICAgICBkZXRhaWxzOiBcInRlbXBlcmF0dXJlIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIHJlYXNvbmluZyBtb2RlbHNcIlxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChiYXNlQXJncy50b3BfcCAhPSBudWxsKSB7XG4gICAgICAgIGJhc2VBcmdzLnRvcF9wID0gdm9pZCAwO1xuICAgICAgICB3YXJuaW5ncy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBcInVuc3VwcG9ydGVkLXNldHRpbmdcIixcbiAgICAgICAgICBzZXR0aW5nOiBcInRvcFBcIixcbiAgICAgICAgICBkZXRhaWxzOiBcInRvcFAgaXMgbm90IHN1cHBvcnRlZCBmb3IgcmVhc29uaW5nIG1vZGVsc1wiXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgXCJyZWd1bGFyXCI6IHtcbiAgICAgICAgY29uc3QgeyB0b29scywgdG9vbF9jaG9pY2UsIHRvb2xXYXJuaW5ncyB9ID0gcHJlcGFyZVJlc3BvbnNlc1Rvb2xzKHtcbiAgICAgICAgICBtb2RlLFxuICAgICAgICAgIHN0cmljdDogaXNTdHJpY3RcbiAgICAgICAgICAvLyBUT0RPIHN1cHBvcnQgcHJvdmlkZXIgb3B0aW9ucyBvbiB0b29sc1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBhcmdzOiB7XG4gICAgICAgICAgICAuLi5iYXNlQXJncyxcbiAgICAgICAgICAgIHRvb2xzLFxuICAgICAgICAgICAgdG9vbF9jaG9pY2VcbiAgICAgICAgICB9LFxuICAgICAgICAgIHdhcm5pbmdzOiBbLi4ud2FybmluZ3MsIC4uLnRvb2xXYXJuaW5nc11cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJvYmplY3QtanNvblwiOiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYXJnczoge1xuICAgICAgICAgICAgLi4uYmFzZUFyZ3MsXG4gICAgICAgICAgICB0ZXh0OiB7XG4gICAgICAgICAgICAgIGZvcm1hdDogbW9kZS5zY2hlbWEgIT0gbnVsbCA/IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImpzb25fc2NoZW1hXCIsXG4gICAgICAgICAgICAgICAgc3RyaWN0OiBpc1N0cmljdCxcbiAgICAgICAgICAgICAgICBuYW1lOiAoX2MgPSBtb2RlLm5hbWUpICE9IG51bGwgPyBfYyA6IFwicmVzcG9uc2VcIixcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogbW9kZS5kZXNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICBzY2hlbWE6IG1vZGUuc2NoZW1hXG4gICAgICAgICAgICAgIH0gOiB7IHR5cGU6IFwianNvbl9vYmplY3RcIiB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICB3YXJuaW5nc1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY2FzZSBcIm9iamVjdC10b29sXCI6IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBhcmdzOiB7XG4gICAgICAgICAgICAuLi5iYXNlQXJncyxcbiAgICAgICAgICAgIHRvb2xfY2hvaWNlOiB7IHR5cGU6IFwiZnVuY3Rpb25cIiwgbmFtZTogbW9kZS50b29sLm5hbWUgfSxcbiAgICAgICAgICAgIHRvb2xzOiBbXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgICAgICAgbmFtZTogbW9kZS50b29sLm5hbWUsXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IG1vZGUudG9vbC5kZXNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiBtb2RlLnRvb2wucGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBzdHJpY3Q6IGlzU3RyaWN0XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHdhcm5pbmdzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIGNvbnN0IF9leGhhdXN0aXZlQ2hlY2sgPSB0eXBlO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHR5cGU6ICR7X2V4aGF1c3RpdmVDaGVja31gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgYXN5bmMgZG9HZW5lcmF0ZShvcHRpb25zKSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nO1xuICAgIGNvbnN0IHsgYXJnczogYm9keSwgd2FybmluZ3MgfSA9IHRoaXMuZ2V0QXJncyhvcHRpb25zKTtcbiAgICBjb25zdCB7XG4gICAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgICB2YWx1ZTogcmVzcG9uc2UsXG4gICAgICByYXdWYWx1ZTogcmF3UmVzcG9uc2VcbiAgICB9ID0gYXdhaXQgcG9zdEpzb25Ub0FwaTUoe1xuICAgICAgdXJsOiB0aGlzLmNvbmZpZy51cmwoe1xuICAgICAgICBwYXRoOiBcIi9yZXNwb25zZXNcIixcbiAgICAgICAgbW9kZWxJZDogdGhpcy5tb2RlbElkXG4gICAgICB9KSxcbiAgICAgIGhlYWRlcnM6IGNvbWJpbmVIZWFkZXJzNih0aGlzLmNvbmZpZy5oZWFkZXJzKCksIG9wdGlvbnMuaGVhZGVycyksXG4gICAgICBib2R5LFxuICAgICAgZmFpbGVkUmVzcG9uc2VIYW5kbGVyOiBvcGVuYWlGYWlsZWRSZXNwb25zZUhhbmRsZXIsXG4gICAgICBzdWNjZXNzZnVsUmVzcG9uc2VIYW5kbGVyOiBjcmVhdGVKc29uUmVzcG9uc2VIYW5kbGVyNihcbiAgICAgICAgejcub2JqZWN0KHtcbiAgICAgICAgICBpZDogejcuc3RyaW5nKCksXG4gICAgICAgICAgY3JlYXRlZF9hdDogejcubnVtYmVyKCksXG4gICAgICAgICAgbW9kZWw6IHo3LnN0cmluZygpLFxuICAgICAgICAgIG91dHB1dDogejcuYXJyYXkoXG4gICAgICAgICAgICB6Ny5kaXNjcmltaW5hdGVkVW5pb24oXCJ0eXBlXCIsIFtcbiAgICAgICAgICAgICAgejcub2JqZWN0KHtcbiAgICAgICAgICAgICAgICB0eXBlOiB6Ny5saXRlcmFsKFwibWVzc2FnZVwiKSxcbiAgICAgICAgICAgICAgICByb2xlOiB6Ny5saXRlcmFsKFwiYXNzaXN0YW50XCIpLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHo3LmFycmF5KFxuICAgICAgICAgICAgICAgICAgejcub2JqZWN0KHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogejcubGl0ZXJhbChcIm91dHB1dF90ZXh0XCIpLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiB6Ny5zdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgYW5ub3RhdGlvbnM6IHo3LmFycmF5KFxuICAgICAgICAgICAgICAgICAgICAgIHo3Lm9iamVjdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiB6Ny5saXRlcmFsKFwidXJsX2NpdGF0aW9uXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRfaW5kZXg6IHo3Lm51bWJlcigpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kX2luZGV4OiB6Ny5udW1iZXIoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybDogejcuc3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogejcuc3RyaW5nKClcbiAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIHo3Lm9iamVjdCh7XG4gICAgICAgICAgICAgICAgdHlwZTogejcubGl0ZXJhbChcImZ1bmN0aW9uX2NhbGxcIiksXG4gICAgICAgICAgICAgICAgY2FsbF9pZDogejcuc3RyaW5nKCksXG4gICAgICAgICAgICAgICAgbmFtZTogejcuc3RyaW5nKCksXG4gICAgICAgICAgICAgICAgYXJndW1lbnRzOiB6Ny5zdHJpbmcoKVxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgejcub2JqZWN0KHtcbiAgICAgICAgICAgICAgICB0eXBlOiB6Ny5saXRlcmFsKFwid2ViX3NlYXJjaF9jYWxsXCIpXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICB6Ny5vYmplY3Qoe1xuICAgICAgICAgICAgICAgIHR5cGU6IHo3LmxpdGVyYWwoXCJjb21wdXRlcl9jYWxsXCIpXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICB6Ny5vYmplY3Qoe1xuICAgICAgICAgICAgICAgIHR5cGU6IHo3LmxpdGVyYWwoXCJyZWFzb25pbmdcIiksXG4gICAgICAgICAgICAgICAgc3VtbWFyeTogejcuYXJyYXkoXG4gICAgICAgICAgICAgICAgICB6Ny5vYmplY3Qoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiB6Ny5saXRlcmFsKFwic3VtbWFyeV90ZXh0XCIpLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiB6Ny5zdHJpbmcoKVxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBdKVxuICAgICAgICAgICksXG4gICAgICAgICAgaW5jb21wbGV0ZV9kZXRhaWxzOiB6Ny5vYmplY3QoeyByZWFzb246IHo3LnN0cmluZygpIH0pLm51bGxhYmxlKCksXG4gICAgICAgICAgdXNhZ2U6IHVzYWdlU2NoZW1hXG4gICAgICAgIH0pXG4gICAgICApLFxuICAgICAgYWJvcnRTaWduYWw6IG9wdGlvbnMuYWJvcnRTaWduYWwsXG4gICAgICBmZXRjaDogdGhpcy5jb25maWcuZmV0Y2hcbiAgICB9KTtcbiAgICBjb25zdCBvdXRwdXRUZXh0RWxlbWVudHMgPSByZXNwb25zZS5vdXRwdXQuZmlsdGVyKChvdXRwdXQpID0+IG91dHB1dC50eXBlID09PSBcIm1lc3NhZ2VcIikuZmxhdE1hcCgob3V0cHV0KSA9PiBvdXRwdXQuY29udGVudCkuZmlsdGVyKChjb250ZW50KSA9PiBjb250ZW50LnR5cGUgPT09IFwib3V0cHV0X3RleHRcIik7XG4gICAgY29uc3QgdG9vbENhbGxzID0gcmVzcG9uc2Uub3V0cHV0LmZpbHRlcigob3V0cHV0KSA9PiBvdXRwdXQudHlwZSA9PT0gXCJmdW5jdGlvbl9jYWxsXCIpLm1hcCgob3V0cHV0KSA9PiAoe1xuICAgICAgdG9vbENhbGxUeXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICB0b29sQ2FsbElkOiBvdXRwdXQuY2FsbF9pZCxcbiAgICAgIHRvb2xOYW1lOiBvdXRwdXQubmFtZSxcbiAgICAgIGFyZ3M6IG91dHB1dC5hcmd1bWVudHNcbiAgICB9KSk7XG4gICAgY29uc3QgcmVhc29uaW5nU3VtbWFyeSA9IChfYiA9IChfYSA9IHJlc3BvbnNlLm91dHB1dC5maW5kKChpdGVtKSA9PiBpdGVtLnR5cGUgPT09IFwicmVhc29uaW5nXCIpKSA9PSBudWxsID8gdm9pZCAwIDogX2Euc3VtbWFyeSkgIT0gbnVsbCA/IF9iIDogbnVsbDtcbiAgICByZXR1cm4ge1xuICAgICAgdGV4dDogb3V0cHV0VGV4dEVsZW1lbnRzLm1hcCgoY29udGVudCkgPT4gY29udGVudC50ZXh0KS5qb2luKFwiXFxuXCIpLFxuICAgICAgc291cmNlczogb3V0cHV0VGV4dEVsZW1lbnRzLmZsYXRNYXAoXG4gICAgICAgIChjb250ZW50KSA9PiBjb250ZW50LmFubm90YXRpb25zLm1hcCgoYW5ub3RhdGlvbikgPT4ge1xuICAgICAgICAgIHZhciBfYTIsIF9iMiwgX2MyO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzb3VyY2VUeXBlOiBcInVybFwiLFxuICAgICAgICAgICAgaWQ6IChfYzIgPSAoX2IyID0gKF9hMiA9IHRoaXMuY29uZmlnKS5nZW5lcmF0ZUlkKSA9PSBudWxsID8gdm9pZCAwIDogX2IyLmNhbGwoX2EyKSkgIT0gbnVsbCA/IF9jMiA6IGdlbmVyYXRlSWQyKCksXG4gICAgICAgICAgICB1cmw6IGFubm90YXRpb24udXJsLFxuICAgICAgICAgICAgdGl0bGU6IGFubm90YXRpb24udGl0bGVcbiAgICAgICAgICB9O1xuICAgICAgICB9KVxuICAgICAgKSxcbiAgICAgIGZpbmlzaFJlYXNvbjogbWFwT3BlbkFJUmVzcG9uc2VGaW5pc2hSZWFzb24oe1xuICAgICAgICBmaW5pc2hSZWFzb246IChfYyA9IHJlc3BvbnNlLmluY29tcGxldGVfZGV0YWlscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLnJlYXNvbixcbiAgICAgICAgaGFzVG9vbENhbGxzOiB0b29sQ2FsbHMubGVuZ3RoID4gMFxuICAgICAgfSksXG4gICAgICB0b29sQ2FsbHM6IHRvb2xDYWxscy5sZW5ndGggPiAwID8gdG9vbENhbGxzIDogdm9pZCAwLFxuICAgICAgcmVhc29uaW5nOiByZWFzb25pbmdTdW1tYXJ5ID8gcmVhc29uaW5nU3VtbWFyeS5tYXAoKHN1bW1hcnkpID0+ICh7XG4gICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICB0ZXh0OiBzdW1tYXJ5LnRleHRcbiAgICAgIH0pKSA6IHZvaWQgMCxcbiAgICAgIHVzYWdlOiB7XG4gICAgICAgIHByb21wdFRva2VuczogcmVzcG9uc2UudXNhZ2UuaW5wdXRfdG9rZW5zLFxuICAgICAgICBjb21wbGV0aW9uVG9rZW5zOiByZXNwb25zZS51c2FnZS5vdXRwdXRfdG9rZW5zXG4gICAgICB9LFxuICAgICAgcmF3Q2FsbDoge1xuICAgICAgICByYXdQcm9tcHQ6IHZvaWQgMCxcbiAgICAgICAgcmF3U2V0dGluZ3M6IHt9XG4gICAgICB9LFxuICAgICAgcmF3UmVzcG9uc2U6IHtcbiAgICAgICAgaGVhZGVyczogcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgICBib2R5OiByYXdSZXNwb25zZVxuICAgICAgfSxcbiAgICAgIHJlcXVlc3Q6IHtcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSlcbiAgICAgIH0sXG4gICAgICByZXNwb25zZToge1xuICAgICAgICBpZDogcmVzcG9uc2UuaWQsXG4gICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUocmVzcG9uc2UuY3JlYXRlZF9hdCAqIDFlMyksXG4gICAgICAgIG1vZGVsSWQ6IHJlc3BvbnNlLm1vZGVsXG4gICAgICB9LFxuICAgICAgcHJvdmlkZXJNZXRhZGF0YToge1xuICAgICAgICBvcGVuYWk6IHtcbiAgICAgICAgICByZXNwb25zZUlkOiByZXNwb25zZS5pZCxcbiAgICAgICAgICBjYWNoZWRQcm9tcHRUb2tlbnM6IChfZSA9IChfZCA9IHJlc3BvbnNlLnVzYWdlLmlucHV0X3Rva2Vuc19kZXRhaWxzKSA9PSBudWxsID8gdm9pZCAwIDogX2QuY2FjaGVkX3Rva2VucykgIT0gbnVsbCA/IF9lIDogbnVsbCxcbiAgICAgICAgICByZWFzb25pbmdUb2tlbnM6IChfZyA9IChfZiA9IHJlc3BvbnNlLnVzYWdlLm91dHB1dF90b2tlbnNfZGV0YWlscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9mLnJlYXNvbmluZ190b2tlbnMpICE9IG51bGwgPyBfZyA6IG51bGxcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHdhcm5pbmdzXG4gICAgfTtcbiAgfVxuICBhc3luYyBkb1N0cmVhbShvcHRpb25zKSB7XG4gICAgY29uc3QgeyBhcmdzOiBib2R5LCB3YXJuaW5ncyB9ID0gdGhpcy5nZXRBcmdzKG9wdGlvbnMpO1xuICAgIGNvbnN0IHsgcmVzcG9uc2VIZWFkZXJzLCB2YWx1ZTogcmVzcG9uc2UgfSA9IGF3YWl0IHBvc3RKc29uVG9BcGk1KHtcbiAgICAgIHVybDogdGhpcy5jb25maWcudXJsKHtcbiAgICAgICAgcGF0aDogXCIvcmVzcG9uc2VzXCIsXG4gICAgICAgIG1vZGVsSWQ6IHRoaXMubW9kZWxJZFxuICAgICAgfSksXG4gICAgICBoZWFkZXJzOiBjb21iaW5lSGVhZGVyczYodGhpcy5jb25maWcuaGVhZGVycygpLCBvcHRpb25zLmhlYWRlcnMpLFxuICAgICAgYm9keToge1xuICAgICAgICAuLi5ib2R5LFxuICAgICAgICBzdHJlYW06IHRydWVcbiAgICAgIH0sXG4gICAgICBmYWlsZWRSZXNwb25zZUhhbmRsZXI6IG9wZW5haUZhaWxlZFJlc3BvbnNlSGFuZGxlcixcbiAgICAgIHN1Y2Nlc3NmdWxSZXNwb25zZUhhbmRsZXI6IGNyZWF0ZUV2ZW50U291cmNlUmVzcG9uc2VIYW5kbGVyMyhcbiAgICAgICAgb3BlbmFpUmVzcG9uc2VzQ2h1bmtTY2hlbWFcbiAgICAgICksXG4gICAgICBhYm9ydFNpZ25hbDogb3B0aW9ucy5hYm9ydFNpZ25hbCxcbiAgICAgIGZldGNoOiB0aGlzLmNvbmZpZy5mZXRjaFxuICAgIH0pO1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGxldCBmaW5pc2hSZWFzb24gPSBcInVua25vd25cIjtcbiAgICBsZXQgcHJvbXB0VG9rZW5zID0gTmFOO1xuICAgIGxldCBjb21wbGV0aW9uVG9rZW5zID0gTmFOO1xuICAgIGxldCBjYWNoZWRQcm9tcHRUb2tlbnMgPSBudWxsO1xuICAgIGxldCByZWFzb25pbmdUb2tlbnMgPSBudWxsO1xuICAgIGxldCByZXNwb25zZUlkID0gbnVsbDtcbiAgICBjb25zdCBvbmdvaW5nVG9vbENhbGxzID0ge307XG4gICAgbGV0IGhhc1Rvb2xDYWxscyA9IGZhbHNlO1xuICAgIHJldHVybiB7XG4gICAgICBzdHJlYW06IHJlc3BvbnNlLnBpcGVUaHJvdWdoKFxuICAgICAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgICAgICB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2g7XG4gICAgICAgICAgICBpZiAoIWNodW5rLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgZmluaXNoUmVhc29uID0gXCJlcnJvclwiO1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoeyB0eXBlOiBcImVycm9yXCIsIGVycm9yOiBjaHVuay5lcnJvciB9KTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBjaHVuay52YWx1ZTtcbiAgICAgICAgICAgIGlmIChpc1Jlc3BvbnNlT3V0cHV0SXRlbUFkZGVkQ2h1bmsodmFsdWUpKSB7XG4gICAgICAgICAgICAgIGlmICh2YWx1ZS5pdGVtLnR5cGUgPT09IFwiZnVuY3Rpb25fY2FsbFwiKSB7XG4gICAgICAgICAgICAgICAgb25nb2luZ1Rvb2xDYWxsc1t2YWx1ZS5vdXRwdXRfaW5kZXhdID0ge1xuICAgICAgICAgICAgICAgICAgdG9vbE5hbWU6IHZhbHVlLml0ZW0ubmFtZSxcbiAgICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHZhbHVlLml0ZW0uY2FsbF9pZFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1jYWxsLWRlbHRhXCIsXG4gICAgICAgICAgICAgICAgICB0b29sQ2FsbFR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHZhbHVlLml0ZW0uY2FsbF9pZCxcbiAgICAgICAgICAgICAgICAgIHRvb2xOYW1lOiB2YWx1ZS5pdGVtLm5hbWUsXG4gICAgICAgICAgICAgICAgICBhcmdzVGV4dERlbHRhOiB2YWx1ZS5pdGVtLmFyZ3VtZW50c1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzUmVzcG9uc2VGdW5jdGlvbkNhbGxBcmd1bWVudHNEZWx0YUNodW5rKHZhbHVlKSkge1xuICAgICAgICAgICAgICBjb25zdCB0b29sQ2FsbCA9IG9uZ29pbmdUb29sQ2FsbHNbdmFsdWUub3V0cHV0X2luZGV4XTtcbiAgICAgICAgICAgICAgaWYgKHRvb2xDYWxsICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLWNhbGwtZGVsdGFcIixcbiAgICAgICAgICAgICAgICAgIHRvb2xDYWxsVHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgICAgdG9vbENhbGxJZDogdG9vbENhbGwudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICAgIHRvb2xOYW1lOiB0b29sQ2FsbC50b29sTmFtZSxcbiAgICAgICAgICAgICAgICAgIGFyZ3NUZXh0RGVsdGE6IHZhbHVlLmRlbHRhXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNSZXNwb25zZUNyZWF0ZWRDaHVuayh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgcmVzcG9uc2VJZCA9IHZhbHVlLnJlc3BvbnNlLmlkO1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwicmVzcG9uc2UtbWV0YWRhdGFcIixcbiAgICAgICAgICAgICAgICBpZDogdmFsdWUucmVzcG9uc2UuaWQsXG4gICAgICAgICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSh2YWx1ZS5yZXNwb25zZS5jcmVhdGVkX2F0ICogMWUzKSxcbiAgICAgICAgICAgICAgICBtb2RlbElkOiB2YWx1ZS5yZXNwb25zZS5tb2RlbFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNUZXh0RGVsdGFDaHVuayh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInRleHQtZGVsdGFcIixcbiAgICAgICAgICAgICAgICB0ZXh0RGVsdGE6IHZhbHVlLmRlbHRhXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc1Jlc3BvbnNlUmVhc29uaW5nU3VtbWFyeVRleHREZWx0YUNodW5rKHZhbHVlKSkge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwicmVhc29uaW5nXCIsXG4gICAgICAgICAgICAgICAgdGV4dERlbHRhOiB2YWx1ZS5kZWx0YVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNSZXNwb25zZU91dHB1dEl0ZW1Eb25lQ2h1bmsodmFsdWUpICYmIHZhbHVlLml0ZW0udHlwZSA9PT0gXCJmdW5jdGlvbl9jYWxsXCIpIHtcbiAgICAgICAgICAgICAgb25nb2luZ1Rvb2xDYWxsc1t2YWx1ZS5vdXRwdXRfaW5kZXhdID0gdm9pZCAwO1xuICAgICAgICAgICAgICBoYXNUb29sQ2FsbHMgPSB0cnVlO1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1jYWxsXCIsXG4gICAgICAgICAgICAgICAgdG9vbENhbGxUeXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgICAgICAgdG9vbENhbGxJZDogdmFsdWUuaXRlbS5jYWxsX2lkLFxuICAgICAgICAgICAgICAgIHRvb2xOYW1lOiB2YWx1ZS5pdGVtLm5hbWUsXG4gICAgICAgICAgICAgICAgYXJnczogdmFsdWUuaXRlbS5hcmd1bWVudHNcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzUmVzcG9uc2VGaW5pc2hlZENodW5rKHZhbHVlKSkge1xuICAgICAgICAgICAgICBmaW5pc2hSZWFzb24gPSBtYXBPcGVuQUlSZXNwb25zZUZpbmlzaFJlYXNvbih7XG4gICAgICAgICAgICAgICAgZmluaXNoUmVhc29uOiAoX2EgPSB2YWx1ZS5yZXNwb25zZS5pbmNvbXBsZXRlX2RldGFpbHMpID09IG51bGwgPyB2b2lkIDAgOiBfYS5yZWFzb24sXG4gICAgICAgICAgICAgICAgaGFzVG9vbENhbGxzXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBwcm9tcHRUb2tlbnMgPSB2YWx1ZS5yZXNwb25zZS51c2FnZS5pbnB1dF90b2tlbnM7XG4gICAgICAgICAgICAgIGNvbXBsZXRpb25Ub2tlbnMgPSB2YWx1ZS5yZXNwb25zZS51c2FnZS5vdXRwdXRfdG9rZW5zO1xuICAgICAgICAgICAgICBjYWNoZWRQcm9tcHRUb2tlbnMgPSAoX2MgPSAoX2IgPSB2YWx1ZS5yZXNwb25zZS51c2FnZS5pbnB1dF90b2tlbnNfZGV0YWlscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhY2hlZF90b2tlbnMpICE9IG51bGwgPyBfYyA6IGNhY2hlZFByb21wdFRva2VucztcbiAgICAgICAgICAgICAgcmVhc29uaW5nVG9rZW5zID0gKF9lID0gKF9kID0gdmFsdWUucmVzcG9uc2UudXNhZ2Uub3V0cHV0X3Rva2Vuc19kZXRhaWxzKSA9PSBudWxsID8gdm9pZCAwIDogX2QucmVhc29uaW5nX3Rva2VucykgIT0gbnVsbCA/IF9lIDogcmVhc29uaW5nVG9rZW5zO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc1Jlc3BvbnNlQW5ub3RhdGlvbkFkZGVkQ2h1bmsodmFsdWUpKSB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJzb3VyY2VcIixcbiAgICAgICAgICAgICAgICBzb3VyY2U6IHtcbiAgICAgICAgICAgICAgICAgIHNvdXJjZVR5cGU6IFwidXJsXCIsXG4gICAgICAgICAgICAgICAgICBpZDogKF9oID0gKF9nID0gKF9mID0gc2VsZi5jb25maWcpLmdlbmVyYXRlSWQpID09IG51bGwgPyB2b2lkIDAgOiBfZy5jYWxsKF9mKSkgIT0gbnVsbCA/IF9oIDogZ2VuZXJhdGVJZDIoKSxcbiAgICAgICAgICAgICAgICAgIHVybDogdmFsdWUuYW5ub3RhdGlvbi51cmwsXG4gICAgICAgICAgICAgICAgICB0aXRsZTogdmFsdWUuYW5ub3RhdGlvbi50aXRsZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBmbHVzaChjb250cm9sbGVyKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICB0eXBlOiBcImZpbmlzaFwiLFxuICAgICAgICAgICAgICBmaW5pc2hSZWFzb24sXG4gICAgICAgICAgICAgIHVzYWdlOiB7IHByb21wdFRva2VucywgY29tcGxldGlvblRva2VucyB9LFxuICAgICAgICAgICAgICAuLi4oY2FjaGVkUHJvbXB0VG9rZW5zICE9IG51bGwgfHwgcmVhc29uaW5nVG9rZW5zICE9IG51bGwpICYmIHtcbiAgICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiB7XG4gICAgICAgICAgICAgICAgICBvcGVuYWk6IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VJZCxcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVkUHJvbXB0VG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICByZWFzb25pbmdUb2tlbnNcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICksXG4gICAgICByYXdDYWxsOiB7XG4gICAgICAgIHJhd1Byb21wdDogdm9pZCAwLFxuICAgICAgICByYXdTZXR0aW5nczoge31cbiAgICAgIH0sXG4gICAgICByYXdSZXNwb25zZTogeyBoZWFkZXJzOiByZXNwb25zZUhlYWRlcnMgfSxcbiAgICAgIHJlcXVlc3Q6IHsgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSkgfSxcbiAgICAgIHdhcm5pbmdzXG4gICAgfTtcbiAgfVxufTtcbnZhciB1c2FnZVNjaGVtYSA9IHo3Lm9iamVjdCh7XG4gIGlucHV0X3Rva2VuczogejcubnVtYmVyKCksXG4gIGlucHV0X3Rva2Vuc19kZXRhaWxzOiB6Ny5vYmplY3QoeyBjYWNoZWRfdG9rZW5zOiB6Ny5udW1iZXIoKS5udWxsaXNoKCkgfSkubnVsbGlzaCgpLFxuICBvdXRwdXRfdG9rZW5zOiB6Ny5udW1iZXIoKSxcbiAgb3V0cHV0X3Rva2Vuc19kZXRhaWxzOiB6Ny5vYmplY3QoeyByZWFzb25pbmdfdG9rZW5zOiB6Ny5udW1iZXIoKS5udWxsaXNoKCkgfSkubnVsbGlzaCgpXG59KTtcbnZhciB0ZXh0RGVsdGFDaHVua1NjaGVtYSA9IHo3Lm9iamVjdCh7XG4gIHR5cGU6IHo3LmxpdGVyYWwoXCJyZXNwb25zZS5vdXRwdXRfdGV4dC5kZWx0YVwiKSxcbiAgZGVsdGE6IHo3LnN0cmluZygpXG59KTtcbnZhciByZXNwb25zZUZpbmlzaGVkQ2h1bmtTY2hlbWEgPSB6Ny5vYmplY3Qoe1xuICB0eXBlOiB6Ny5lbnVtKFtcInJlc3BvbnNlLmNvbXBsZXRlZFwiLCBcInJlc3BvbnNlLmluY29tcGxldGVcIl0pLFxuICByZXNwb25zZTogejcub2JqZWN0KHtcbiAgICBpbmNvbXBsZXRlX2RldGFpbHM6IHo3Lm9iamVjdCh7IHJlYXNvbjogejcuc3RyaW5nKCkgfSkubnVsbGlzaCgpLFxuICAgIHVzYWdlOiB1c2FnZVNjaGVtYVxuICB9KVxufSk7XG52YXIgcmVzcG9uc2VDcmVhdGVkQ2h1bmtTY2hlbWEgPSB6Ny5vYmplY3Qoe1xuICB0eXBlOiB6Ny5saXRlcmFsKFwicmVzcG9uc2UuY3JlYXRlZFwiKSxcbiAgcmVzcG9uc2U6IHo3Lm9iamVjdCh7XG4gICAgaWQ6IHo3LnN0cmluZygpLFxuICAgIGNyZWF0ZWRfYXQ6IHo3Lm51bWJlcigpLFxuICAgIG1vZGVsOiB6Ny5zdHJpbmcoKVxuICB9KVxufSk7XG52YXIgcmVzcG9uc2VPdXRwdXRJdGVtRG9uZVNjaGVtYSA9IHo3Lm9iamVjdCh7XG4gIHR5cGU6IHo3LmxpdGVyYWwoXCJyZXNwb25zZS5vdXRwdXRfaXRlbS5kb25lXCIpLFxuICBvdXRwdXRfaW5kZXg6IHo3Lm51bWJlcigpLFxuICBpdGVtOiB6Ny5kaXNjcmltaW5hdGVkVW5pb24oXCJ0eXBlXCIsIFtcbiAgICB6Ny5vYmplY3Qoe1xuICAgICAgdHlwZTogejcubGl0ZXJhbChcIm1lc3NhZ2VcIilcbiAgICB9KSxcbiAgICB6Ny5vYmplY3Qoe1xuICAgICAgdHlwZTogejcubGl0ZXJhbChcImZ1bmN0aW9uX2NhbGxcIiksXG4gICAgICBpZDogejcuc3RyaW5nKCksXG4gICAgICBjYWxsX2lkOiB6Ny5zdHJpbmcoKSxcbiAgICAgIG5hbWU6IHo3LnN0cmluZygpLFxuICAgICAgYXJndW1lbnRzOiB6Ny5zdHJpbmcoKSxcbiAgICAgIHN0YXR1czogejcubGl0ZXJhbChcImNvbXBsZXRlZFwiKVxuICAgIH0pXG4gIF0pXG59KTtcbnZhciByZXNwb25zZUZ1bmN0aW9uQ2FsbEFyZ3VtZW50c0RlbHRhU2NoZW1hID0gejcub2JqZWN0KHtcbiAgdHlwZTogejcubGl0ZXJhbChcInJlc3BvbnNlLmZ1bmN0aW9uX2NhbGxfYXJndW1lbnRzLmRlbHRhXCIpLFxuICBpdGVtX2lkOiB6Ny5zdHJpbmcoKSxcbiAgb3V0cHV0X2luZGV4OiB6Ny5udW1iZXIoKSxcbiAgZGVsdGE6IHo3LnN0cmluZygpXG59KTtcbnZhciByZXNwb25zZU91dHB1dEl0ZW1BZGRlZFNjaGVtYSA9IHo3Lm9iamVjdCh7XG4gIHR5cGU6IHo3LmxpdGVyYWwoXCJyZXNwb25zZS5vdXRwdXRfaXRlbS5hZGRlZFwiKSxcbiAgb3V0cHV0X2luZGV4OiB6Ny5udW1iZXIoKSxcbiAgaXRlbTogejcuZGlzY3JpbWluYXRlZFVuaW9uKFwidHlwZVwiLCBbXG4gICAgejcub2JqZWN0KHtcbiAgICAgIHR5cGU6IHo3LmxpdGVyYWwoXCJtZXNzYWdlXCIpXG4gICAgfSksXG4gICAgejcub2JqZWN0KHtcbiAgICAgIHR5cGU6IHo3LmxpdGVyYWwoXCJmdW5jdGlvbl9jYWxsXCIpLFxuICAgICAgaWQ6IHo3LnN0cmluZygpLFxuICAgICAgY2FsbF9pZDogejcuc3RyaW5nKCksXG4gICAgICBuYW1lOiB6Ny5zdHJpbmcoKSxcbiAgICAgIGFyZ3VtZW50czogejcuc3RyaW5nKClcbiAgICB9KVxuICBdKVxufSk7XG52YXIgcmVzcG9uc2VBbm5vdGF0aW9uQWRkZWRTY2hlbWEgPSB6Ny5vYmplY3Qoe1xuICB0eXBlOiB6Ny5saXRlcmFsKFwicmVzcG9uc2Uub3V0cHV0X3RleHQuYW5ub3RhdGlvbi5hZGRlZFwiKSxcbiAgYW5ub3RhdGlvbjogejcub2JqZWN0KHtcbiAgICB0eXBlOiB6Ny5saXRlcmFsKFwidXJsX2NpdGF0aW9uXCIpLFxuICAgIHVybDogejcuc3RyaW5nKCksXG4gICAgdGl0bGU6IHo3LnN0cmluZygpXG4gIH0pXG59KTtcbnZhciByZXNwb25zZVJlYXNvbmluZ1N1bW1hcnlUZXh0RGVsdGFTY2hlbWEgPSB6Ny5vYmplY3Qoe1xuICB0eXBlOiB6Ny5saXRlcmFsKFwicmVzcG9uc2UucmVhc29uaW5nX3N1bW1hcnlfdGV4dC5kZWx0YVwiKSxcbiAgaXRlbV9pZDogejcuc3RyaW5nKCksXG4gIG91dHB1dF9pbmRleDogejcubnVtYmVyKCksXG4gIHN1bW1hcnlfaW5kZXg6IHo3Lm51bWJlcigpLFxuICBkZWx0YTogejcuc3RyaW5nKClcbn0pO1xudmFyIG9wZW5haVJlc3BvbnNlc0NodW5rU2NoZW1hID0gejcudW5pb24oW1xuICB0ZXh0RGVsdGFDaHVua1NjaGVtYSxcbiAgcmVzcG9uc2VGaW5pc2hlZENodW5rU2NoZW1hLFxuICByZXNwb25zZUNyZWF0ZWRDaHVua1NjaGVtYSxcbiAgcmVzcG9uc2VPdXRwdXRJdGVtRG9uZVNjaGVtYSxcbiAgcmVzcG9uc2VGdW5jdGlvbkNhbGxBcmd1bWVudHNEZWx0YVNjaGVtYSxcbiAgcmVzcG9uc2VPdXRwdXRJdGVtQWRkZWRTY2hlbWEsXG4gIHJlc3BvbnNlQW5ub3RhdGlvbkFkZGVkU2NoZW1hLFxuICByZXNwb25zZVJlYXNvbmluZ1N1bW1hcnlUZXh0RGVsdGFTY2hlbWEsXG4gIHo3Lm9iamVjdCh7IHR5cGU6IHo3LnN0cmluZygpIH0pLnBhc3N0aHJvdWdoKClcbiAgLy8gZmFsbGJhY2sgZm9yIHVua25vd24gY2h1bmtzXG5dKTtcbmZ1bmN0aW9uIGlzVGV4dERlbHRhQ2h1bmsoY2h1bmspIHtcbiAgcmV0dXJuIGNodW5rLnR5cGUgPT09IFwicmVzcG9uc2Uub3V0cHV0X3RleHQuZGVsdGFcIjtcbn1cbmZ1bmN0aW9uIGlzUmVzcG9uc2VPdXRwdXRJdGVtRG9uZUNodW5rKGNodW5rKSB7XG4gIHJldHVybiBjaHVuay50eXBlID09PSBcInJlc3BvbnNlLm91dHB1dF9pdGVtLmRvbmVcIjtcbn1cbmZ1bmN0aW9uIGlzUmVzcG9uc2VGaW5pc2hlZENodW5rKGNodW5rKSB7XG4gIHJldHVybiBjaHVuay50eXBlID09PSBcInJlc3BvbnNlLmNvbXBsZXRlZFwiIHx8IGNodW5rLnR5cGUgPT09IFwicmVzcG9uc2UuaW5jb21wbGV0ZVwiO1xufVxuZnVuY3Rpb24gaXNSZXNwb25zZUNyZWF0ZWRDaHVuayhjaHVuaykge1xuICByZXR1cm4gY2h1bmsudHlwZSA9PT0gXCJyZXNwb25zZS5jcmVhdGVkXCI7XG59XG5mdW5jdGlvbiBpc1Jlc3BvbnNlRnVuY3Rpb25DYWxsQXJndW1lbnRzRGVsdGFDaHVuayhjaHVuaykge1xuICByZXR1cm4gY2h1bmsudHlwZSA9PT0gXCJyZXNwb25zZS5mdW5jdGlvbl9jYWxsX2FyZ3VtZW50cy5kZWx0YVwiO1xufVxuZnVuY3Rpb24gaXNSZXNwb25zZU91dHB1dEl0ZW1BZGRlZENodW5rKGNodW5rKSB7XG4gIHJldHVybiBjaHVuay50eXBlID09PSBcInJlc3BvbnNlLm91dHB1dF9pdGVtLmFkZGVkXCI7XG59XG5mdW5jdGlvbiBpc1Jlc3BvbnNlQW5ub3RhdGlvbkFkZGVkQ2h1bmsoY2h1bmspIHtcbiAgcmV0dXJuIGNodW5rLnR5cGUgPT09IFwicmVzcG9uc2Uub3V0cHV0X3RleHQuYW5ub3RhdGlvbi5hZGRlZFwiO1xufVxuZnVuY3Rpb24gaXNSZXNwb25zZVJlYXNvbmluZ1N1bW1hcnlUZXh0RGVsdGFDaHVuayhjaHVuaykge1xuICByZXR1cm4gY2h1bmsudHlwZSA9PT0gXCJyZXNwb25zZS5yZWFzb25pbmdfc3VtbWFyeV90ZXh0LmRlbHRhXCI7XG59XG5mdW5jdGlvbiBnZXRSZXNwb25zZXNNb2RlbENvbmZpZyhtb2RlbElkKSB7XG4gIGlmIChtb2RlbElkLnN0YXJ0c1dpdGgoXCJvXCIpKSB7XG4gICAgaWYgKG1vZGVsSWQuc3RhcnRzV2l0aChcIm8xLW1pbmlcIikgfHwgbW9kZWxJZC5zdGFydHNXaXRoKFwibzEtcHJldmlld1wiKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXNSZWFzb25pbmdNb2RlbDogdHJ1ZSxcbiAgICAgICAgc3lzdGVtTWVzc2FnZU1vZGU6IFwicmVtb3ZlXCIsXG4gICAgICAgIHJlcXVpcmVkQXV0b1RydW5jYXRpb246IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgaXNSZWFzb25pbmdNb2RlbDogdHJ1ZSxcbiAgICAgIHN5c3RlbU1lc3NhZ2VNb2RlOiBcImRldmVsb3BlclwiLFxuICAgICAgcmVxdWlyZWRBdXRvVHJ1bmNhdGlvbjogZmFsc2VcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgaXNSZWFzb25pbmdNb2RlbDogZmFsc2UsXG4gICAgc3lzdGVtTWVzc2FnZU1vZGU6IFwic3lzdGVtXCIsXG4gICAgcmVxdWlyZWRBdXRvVHJ1bmNhdGlvbjogZmFsc2VcbiAgfTtcbn1cbnZhciBvcGVuYWlSZXNwb25zZXNQcm92aWRlck9wdGlvbnNTY2hlbWEgPSB6Ny5vYmplY3Qoe1xuICBtZXRhZGF0YTogejcuYW55KCkubnVsbGlzaCgpLFxuICBwYXJhbGxlbFRvb2xDYWxsczogejcuYm9vbGVhbigpLm51bGxpc2goKSxcbiAgcHJldmlvdXNSZXNwb25zZUlkOiB6Ny5zdHJpbmcoKS5udWxsaXNoKCksXG4gIHN0b3JlOiB6Ny5ib29sZWFuKCkubnVsbGlzaCgpLFxuICB1c2VyOiB6Ny5zdHJpbmcoKS5udWxsaXNoKCksXG4gIHJlYXNvbmluZ0VmZm9ydDogejcuc3RyaW5nKCkubnVsbGlzaCgpLFxuICBzdHJpY3RTY2hlbWFzOiB6Ny5ib29sZWFuKCkubnVsbGlzaCgpLFxuICBpbnN0cnVjdGlvbnM6IHo3LnN0cmluZygpLm51bGxpc2goKSxcbiAgcmVhc29uaW5nU3VtbWFyeTogejcuc3RyaW5nKCkubnVsbGlzaCgpXG59KTtcblxuLy8gc3JjL29wZW5haS10b29scy50c1xuaW1wb3J0IHsgeiBhcyB6OCB9IGZyb20gXCJ6b2RcIjtcbnZhciBXZWJTZWFyY2hQcmV2aWV3UGFyYW1ldGVycyA9IHo4Lm9iamVjdCh7fSk7XG5mdW5jdGlvbiB3ZWJTZWFyY2hQcmV2aWV3VG9vbCh7XG4gIHNlYXJjaENvbnRleHRTaXplLFxuICB1c2VyTG9jYXRpb25cbn0gPSB7fSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwicHJvdmlkZXItZGVmaW5lZFwiLFxuICAgIGlkOiBcIm9wZW5haS53ZWJfc2VhcmNoX3ByZXZpZXdcIixcbiAgICBhcmdzOiB7XG4gICAgICBzZWFyY2hDb250ZXh0U2l6ZSxcbiAgICAgIHVzZXJMb2NhdGlvblxuICAgIH0sXG4gICAgcGFyYW1ldGVyczogV2ViU2VhcmNoUHJldmlld1BhcmFtZXRlcnNcbiAgfTtcbn1cbnZhciBvcGVuYWlUb29scyA9IHtcbiAgd2ViU2VhcmNoUHJldmlldzogd2ViU2VhcmNoUHJldmlld1Rvb2xcbn07XG5cbi8vIHNyYy9vcGVuYWktc3BlZWNoLW1vZGVsLnRzXG5pbXBvcnQge1xuICBjb21iaW5lSGVhZGVycyBhcyBjb21iaW5lSGVhZGVyczcsXG4gIGNyZWF0ZUJpbmFyeVJlc3BvbnNlSGFuZGxlcixcbiAgcGFyc2VQcm92aWRlck9wdGlvbnMgYXMgcGFyc2VQcm92aWRlck9wdGlvbnMzLFxuICBwb3N0SnNvblRvQXBpIGFzIHBvc3RKc29uVG9BcGk2XG59IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5pbXBvcnQgeyB6IGFzIHo5IH0gZnJvbSBcInpvZFwiO1xudmFyIE9wZW5BSVByb3ZpZGVyT3B0aW9uc1NjaGVtYSA9IHo5Lm9iamVjdCh7XG4gIGluc3RydWN0aW9uczogejkuc3RyaW5nKCkubnVsbGlzaCgpLFxuICBzcGVlZDogejkubnVtYmVyKCkubWluKDAuMjUpLm1heCg0KS5kZWZhdWx0KDEpLm51bGxpc2goKVxufSk7XG52YXIgT3BlbkFJU3BlZWNoTW9kZWwgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG1vZGVsSWQsIGNvbmZpZykge1xuICAgIHRoaXMubW9kZWxJZCA9IG1vZGVsSWQ7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy5zcGVjaWZpY2F0aW9uVmVyc2lvbiA9IFwidjFcIjtcbiAgfVxuICBnZXQgcHJvdmlkZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLnByb3ZpZGVyO1xuICB9XG4gIGdldEFyZ3Moe1xuICAgIHRleHQsXG4gICAgdm9pY2UgPSBcImFsbG95XCIsXG4gICAgb3V0cHV0Rm9ybWF0ID0gXCJtcDNcIixcbiAgICBzcGVlZCxcbiAgICBpbnN0cnVjdGlvbnMsXG4gICAgcHJvdmlkZXJPcHRpb25zXG4gIH0pIHtcbiAgICBjb25zdCB3YXJuaW5ncyA9IFtdO1xuICAgIGNvbnN0IG9wZW5BSU9wdGlvbnMgPSBwYXJzZVByb3ZpZGVyT3B0aW9uczMoe1xuICAgICAgcHJvdmlkZXI6IFwib3BlbmFpXCIsXG4gICAgICBwcm92aWRlck9wdGlvbnMsXG4gICAgICBzY2hlbWE6IE9wZW5BSVByb3ZpZGVyT3B0aW9uc1NjaGVtYVxuICAgIH0pO1xuICAgIGNvbnN0IHJlcXVlc3RCb2R5ID0ge1xuICAgICAgbW9kZWw6IHRoaXMubW9kZWxJZCxcbiAgICAgIGlucHV0OiB0ZXh0LFxuICAgICAgdm9pY2UsXG4gICAgICByZXNwb25zZV9mb3JtYXQ6IFwibXAzXCIsXG4gICAgICBzcGVlZCxcbiAgICAgIGluc3RydWN0aW9uc1xuICAgIH07XG4gICAgaWYgKG91dHB1dEZvcm1hdCkge1xuICAgICAgaWYgKFtcIm1wM1wiLCBcIm9wdXNcIiwgXCJhYWNcIiwgXCJmbGFjXCIsIFwid2F2XCIsIFwicGNtXCJdLmluY2x1ZGVzKG91dHB1dEZvcm1hdCkpIHtcbiAgICAgICAgcmVxdWVzdEJvZHkucmVzcG9uc2VfZm9ybWF0ID0gb3V0cHV0Rm9ybWF0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2FybmluZ3MucHVzaCh7XG4gICAgICAgICAgdHlwZTogXCJ1bnN1cHBvcnRlZC1zZXR0aW5nXCIsXG4gICAgICAgICAgc2V0dGluZzogXCJvdXRwdXRGb3JtYXRcIixcbiAgICAgICAgICBkZXRhaWxzOiBgVW5zdXBwb3J0ZWQgb3V0cHV0IGZvcm1hdDogJHtvdXRwdXRGb3JtYXR9LiBVc2luZyBtcDMgaW5zdGVhZC5gXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob3BlbkFJT3B0aW9ucykge1xuICAgICAgY29uc3Qgc3BlZWNoTW9kZWxPcHRpb25zID0ge307XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBzcGVlY2hNb2RlbE9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBzcGVlY2hNb2RlbE9wdGlvbnNba2V5XTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgICAgICByZXF1ZXN0Qm9keVtrZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlcXVlc3RCb2R5LFxuICAgICAgd2FybmluZ3NcbiAgICB9O1xuICB9XG4gIGFzeW5jIGRvR2VuZXJhdGUob3B0aW9ucykge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIGNvbnN0IGN1cnJlbnREYXRlID0gKF9jID0gKF9iID0gKF9hID0gdGhpcy5jb25maWcuX2ludGVybmFsKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY3VycmVudERhdGUpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKSkgIT0gbnVsbCA/IF9jIDogLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gICAgY29uc3QgeyByZXF1ZXN0Qm9keSwgd2FybmluZ3MgfSA9IHRoaXMuZ2V0QXJncyhvcHRpb25zKTtcbiAgICBjb25zdCB7XG4gICAgICB2YWx1ZTogYXVkaW8sXG4gICAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgICByYXdWYWx1ZTogcmF3UmVzcG9uc2VcbiAgICB9ID0gYXdhaXQgcG9zdEpzb25Ub0FwaTYoe1xuICAgICAgdXJsOiB0aGlzLmNvbmZpZy51cmwoe1xuICAgICAgICBwYXRoOiBcIi9hdWRpby9zcGVlY2hcIixcbiAgICAgICAgbW9kZWxJZDogdGhpcy5tb2RlbElkXG4gICAgICB9KSxcbiAgICAgIGhlYWRlcnM6IGNvbWJpbmVIZWFkZXJzNyh0aGlzLmNvbmZpZy5oZWFkZXJzKCksIG9wdGlvbnMuaGVhZGVycyksXG4gICAgICBib2R5OiByZXF1ZXN0Qm9keSxcbiAgICAgIGZhaWxlZFJlc3BvbnNlSGFuZGxlcjogb3BlbmFpRmFpbGVkUmVzcG9uc2VIYW5kbGVyLFxuICAgICAgc3VjY2Vzc2Z1bFJlc3BvbnNlSGFuZGxlcjogY3JlYXRlQmluYXJ5UmVzcG9uc2VIYW5kbGVyKCksXG4gICAgICBhYm9ydFNpZ25hbDogb3B0aW9ucy5hYm9ydFNpZ25hbCxcbiAgICAgIGZldGNoOiB0aGlzLmNvbmZpZy5mZXRjaFxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBhdWRpbyxcbiAgICAgIHdhcm5pbmdzLFxuICAgICAgcmVxdWVzdDoge1xuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShyZXF1ZXN0Qm9keSlcbiAgICAgIH0sXG4gICAgICByZXNwb25zZToge1xuICAgICAgICB0aW1lc3RhbXA6IGN1cnJlbnREYXRlLFxuICAgICAgICBtb2RlbElkOiB0aGlzLm1vZGVsSWQsXG4gICAgICAgIGhlYWRlcnM6IHJlc3BvbnNlSGVhZGVycyxcbiAgICAgICAgYm9keTogcmF3UmVzcG9uc2VcbiAgICAgIH1cbiAgICB9O1xuICB9XG59O1xuXG4vLyBzcmMvb3BlbmFpLXByb3ZpZGVyLnRzXG5mdW5jdGlvbiBjcmVhdGVPcGVuQUkob3B0aW9ucyA9IHt9KSB7XG4gIHZhciBfYSwgX2IsIF9jO1xuICBjb25zdCBiYXNlVVJMID0gKF9hID0gd2l0aG91dFRyYWlsaW5nU2xhc2gob3B0aW9ucy5iYXNlVVJMKSkgIT0gbnVsbCA/IF9hIDogXCJodHRwczovL2FwaS5vcGVuYWkuY29tL3YxXCI7XG4gIGNvbnN0IGNvbXBhdGliaWxpdHkgPSAoX2IgPSBvcHRpb25zLmNvbXBhdGliaWxpdHkpICE9IG51bGwgPyBfYiA6IFwiY29tcGF0aWJsZVwiO1xuICBjb25zdCBwcm92aWRlck5hbWUgPSAoX2MgPSBvcHRpb25zLm5hbWUpICE9IG51bGwgPyBfYyA6IFwib3BlbmFpXCI7XG4gIGNvbnN0IGdldEhlYWRlcnMgPSAoKSA9PiAoe1xuICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHtsb2FkQXBpS2V5KHtcbiAgICAgIGFwaUtleTogb3B0aW9ucy5hcGlLZXksXG4gICAgICBlbnZpcm9ubWVudFZhcmlhYmxlTmFtZTogXCJPUEVOQUlfQVBJX0tFWVwiLFxuICAgICAgZGVzY3JpcHRpb246IFwiT3BlbkFJXCJcbiAgICB9KX1gLFxuICAgIFwiT3BlbkFJLU9yZ2FuaXphdGlvblwiOiBvcHRpb25zLm9yZ2FuaXphdGlvbixcbiAgICBcIk9wZW5BSS1Qcm9qZWN0XCI6IG9wdGlvbnMucHJvamVjdCxcbiAgICAuLi5vcHRpb25zLmhlYWRlcnNcbiAgfSk7XG4gIGNvbnN0IGNyZWF0ZUNoYXRNb2RlbCA9IChtb2RlbElkLCBzZXR0aW5ncyA9IHt9KSA9PiBuZXcgT3BlbkFJQ2hhdExhbmd1YWdlTW9kZWwobW9kZWxJZCwgc2V0dGluZ3MsIHtcbiAgICBwcm92aWRlcjogYCR7cHJvdmlkZXJOYW1lfS5jaGF0YCxcbiAgICB1cmw6ICh7IHBhdGggfSkgPT4gYCR7YmFzZVVSTH0ke3BhdGh9YCxcbiAgICBoZWFkZXJzOiBnZXRIZWFkZXJzLFxuICAgIGNvbXBhdGliaWxpdHksXG4gICAgZmV0Y2g6IG9wdGlvbnMuZmV0Y2hcbiAgfSk7XG4gIGNvbnN0IGNyZWF0ZUNvbXBsZXRpb25Nb2RlbCA9IChtb2RlbElkLCBzZXR0aW5ncyA9IHt9KSA9PiBuZXcgT3BlbkFJQ29tcGxldGlvbkxhbmd1YWdlTW9kZWwobW9kZWxJZCwgc2V0dGluZ3MsIHtcbiAgICBwcm92aWRlcjogYCR7cHJvdmlkZXJOYW1lfS5jb21wbGV0aW9uYCxcbiAgICB1cmw6ICh7IHBhdGggfSkgPT4gYCR7YmFzZVVSTH0ke3BhdGh9YCxcbiAgICBoZWFkZXJzOiBnZXRIZWFkZXJzLFxuICAgIGNvbXBhdGliaWxpdHksXG4gICAgZmV0Y2g6IG9wdGlvbnMuZmV0Y2hcbiAgfSk7XG4gIGNvbnN0IGNyZWF0ZUVtYmVkZGluZ01vZGVsID0gKG1vZGVsSWQsIHNldHRpbmdzID0ge30pID0+IG5ldyBPcGVuQUlFbWJlZGRpbmdNb2RlbChtb2RlbElkLCBzZXR0aW5ncywge1xuICAgIHByb3ZpZGVyOiBgJHtwcm92aWRlck5hbWV9LmVtYmVkZGluZ2AsXG4gICAgdXJsOiAoeyBwYXRoIH0pID0+IGAke2Jhc2VVUkx9JHtwYXRofWAsXG4gICAgaGVhZGVyczogZ2V0SGVhZGVycyxcbiAgICBmZXRjaDogb3B0aW9ucy5mZXRjaFxuICB9KTtcbiAgY29uc3QgY3JlYXRlSW1hZ2VNb2RlbCA9IChtb2RlbElkLCBzZXR0aW5ncyA9IHt9KSA9PiBuZXcgT3BlbkFJSW1hZ2VNb2RlbChtb2RlbElkLCBzZXR0aW5ncywge1xuICAgIHByb3ZpZGVyOiBgJHtwcm92aWRlck5hbWV9LmltYWdlYCxcbiAgICB1cmw6ICh7IHBhdGggfSkgPT4gYCR7YmFzZVVSTH0ke3BhdGh9YCxcbiAgICBoZWFkZXJzOiBnZXRIZWFkZXJzLFxuICAgIGZldGNoOiBvcHRpb25zLmZldGNoXG4gIH0pO1xuICBjb25zdCBjcmVhdGVUcmFuc2NyaXB0aW9uTW9kZWwgPSAobW9kZWxJZCkgPT4gbmV3IE9wZW5BSVRyYW5zY3JpcHRpb25Nb2RlbChtb2RlbElkLCB7XG4gICAgcHJvdmlkZXI6IGAke3Byb3ZpZGVyTmFtZX0udHJhbnNjcmlwdGlvbmAsXG4gICAgdXJsOiAoeyBwYXRoIH0pID0+IGAke2Jhc2VVUkx9JHtwYXRofWAsXG4gICAgaGVhZGVyczogZ2V0SGVhZGVycyxcbiAgICBmZXRjaDogb3B0aW9ucy5mZXRjaFxuICB9KTtcbiAgY29uc3QgY3JlYXRlU3BlZWNoTW9kZWwgPSAobW9kZWxJZCkgPT4gbmV3IE9wZW5BSVNwZWVjaE1vZGVsKG1vZGVsSWQsIHtcbiAgICBwcm92aWRlcjogYCR7cHJvdmlkZXJOYW1lfS5zcGVlY2hgLFxuICAgIHVybDogKHsgcGF0aCB9KSA9PiBgJHtiYXNlVVJMfSR7cGF0aH1gLFxuICAgIGhlYWRlcnM6IGdldEhlYWRlcnMsXG4gICAgZmV0Y2g6IG9wdGlvbnMuZmV0Y2hcbiAgfSk7XG4gIGNvbnN0IGNyZWF0ZUxhbmd1YWdlTW9kZWwgPSAobW9kZWxJZCwgc2V0dGluZ3MpID0+IHtcbiAgICBpZiAobmV3LnRhcmdldCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIlRoZSBPcGVuQUkgbW9kZWwgZnVuY3Rpb24gY2Fubm90IGJlIGNhbGxlZCB3aXRoIHRoZSBuZXcga2V5d29yZC5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKG1vZGVsSWQgPT09IFwiZ3B0LTMuNS10dXJiby1pbnN0cnVjdFwiKSB7XG4gICAgICByZXR1cm4gY3JlYXRlQ29tcGxldGlvbk1vZGVsKFxuICAgICAgICBtb2RlbElkLFxuICAgICAgICBzZXR0aW5nc1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYXRNb2RlbChtb2RlbElkLCBzZXR0aW5ncyk7XG4gIH07XG4gIGNvbnN0IGNyZWF0ZVJlc3BvbnNlc01vZGVsID0gKG1vZGVsSWQpID0+IHtcbiAgICByZXR1cm4gbmV3IE9wZW5BSVJlc3BvbnNlc0xhbmd1YWdlTW9kZWwobW9kZWxJZCwge1xuICAgICAgcHJvdmlkZXI6IGAke3Byb3ZpZGVyTmFtZX0ucmVzcG9uc2VzYCxcbiAgICAgIHVybDogKHsgcGF0aCB9KSA9PiBgJHtiYXNlVVJMfSR7cGF0aH1gLFxuICAgICAgaGVhZGVyczogZ2V0SGVhZGVycyxcbiAgICAgIGZldGNoOiBvcHRpb25zLmZldGNoXG4gICAgfSk7XG4gIH07XG4gIGNvbnN0IHByb3ZpZGVyID0gZnVuY3Rpb24obW9kZWxJZCwgc2V0dGluZ3MpIHtcbiAgICByZXR1cm4gY3JlYXRlTGFuZ3VhZ2VNb2RlbChtb2RlbElkLCBzZXR0aW5ncyk7XG4gIH07XG4gIHByb3ZpZGVyLmxhbmd1YWdlTW9kZWwgPSBjcmVhdGVMYW5ndWFnZU1vZGVsO1xuICBwcm92aWRlci5jaGF0ID0gY3JlYXRlQ2hhdE1vZGVsO1xuICBwcm92aWRlci5jb21wbGV0aW9uID0gY3JlYXRlQ29tcGxldGlvbk1vZGVsO1xuICBwcm92aWRlci5yZXNwb25zZXMgPSBjcmVhdGVSZXNwb25zZXNNb2RlbDtcbiAgcHJvdmlkZXIuZW1iZWRkaW5nID0gY3JlYXRlRW1iZWRkaW5nTW9kZWw7XG4gIHByb3ZpZGVyLnRleHRFbWJlZGRpbmcgPSBjcmVhdGVFbWJlZGRpbmdNb2RlbDtcbiAgcHJvdmlkZXIudGV4dEVtYmVkZGluZ01vZGVsID0gY3JlYXRlRW1iZWRkaW5nTW9kZWw7XG4gIHByb3ZpZGVyLmltYWdlID0gY3JlYXRlSW1hZ2VNb2RlbDtcbiAgcHJvdmlkZXIuaW1hZ2VNb2RlbCA9IGNyZWF0ZUltYWdlTW9kZWw7XG4gIHByb3ZpZGVyLnRyYW5zY3JpcHRpb24gPSBjcmVhdGVUcmFuc2NyaXB0aW9uTW9kZWw7XG4gIHByb3ZpZGVyLnRyYW5zY3JpcHRpb25Nb2RlbCA9IGNyZWF0ZVRyYW5zY3JpcHRpb25Nb2RlbDtcbiAgcHJvdmlkZXIuc3BlZWNoID0gY3JlYXRlU3BlZWNoTW9kZWw7XG4gIHByb3ZpZGVyLnNwZWVjaE1vZGVsID0gY3JlYXRlU3BlZWNoTW9kZWw7XG4gIHByb3ZpZGVyLnRvb2xzID0gb3BlbmFpVG9vbHM7XG4gIHJldHVybiBwcm92aWRlcjtcbn1cbnZhciBvcGVuYWkgPSBjcmVhdGVPcGVuQUkoe1xuICBjb21wYXRpYmlsaXR5OiBcInN0cmljdFwiXG4gIC8vIHN0cmljdCBmb3IgT3BlbkFJIEFQSVxufSk7XG5leHBvcnQge1xuICBjcmVhdGVPcGVuQUksXG4gIG9wZW5haVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@ai-sdk/openai/dist/index.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@ai-sdk/provider-utils/dist/index.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@ai-sdk/provider-utils/dist/index.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   asValidator: () => (/* binding */ asValidator),\n/* harmony export */   combineHeaders: () => (/* binding */ combineHeaders),\n/* harmony export */   convertAsyncIteratorToReadableStream: () => (/* binding */ convertAsyncIteratorToReadableStream),\n/* harmony export */   convertBase64ToUint8Array: () => (/* binding */ convertBase64ToUint8Array),\n/* harmony export */   convertUint8ArrayToBase64: () => (/* binding */ convertUint8ArrayToBase64),\n/* harmony export */   createBinaryResponseHandler: () => (/* binding */ createBinaryResponseHandler),\n/* harmony export */   createEventSourceParserStream: () => (/* binding */ createEventSourceParserStream),\n/* harmony export */   createEventSourceResponseHandler: () => (/* binding */ createEventSourceResponseHandler),\n/* harmony export */   createIdGenerator: () => (/* binding */ createIdGenerator),\n/* harmony export */   createJsonErrorResponseHandler: () => (/* binding */ createJsonErrorResponseHandler),\n/* harmony export */   createJsonResponseHandler: () => (/* binding */ createJsonResponseHandler),\n/* harmony export */   createJsonStreamResponseHandler: () => (/* binding */ createJsonStreamResponseHandler),\n/* harmony export */   createStatusCodeErrorResponseHandler: () => (/* binding */ createStatusCodeErrorResponseHandler),\n/* harmony export */   delay: () => (/* binding */ delay),\n/* harmony export */   extractResponseHeaders: () => (/* binding */ extractResponseHeaders),\n/* harmony export */   generateId: () => (/* binding */ generateId),\n/* harmony export */   getErrorMessage: () => (/* binding */ getErrorMessage),\n/* harmony export */   getFromApi: () => (/* binding */ getFromApi),\n/* harmony export */   isAbortError: () => (/* binding */ isAbortError),\n/* harmony export */   isParsableJson: () => (/* binding */ isParsableJson),\n/* harmony export */   isValidator: () => (/* binding */ isValidator),\n/* harmony export */   loadApiKey: () => (/* binding */ loadApiKey),\n/* harmony export */   loadOptionalSetting: () => (/* binding */ loadOptionalSetting),\n/* harmony export */   loadSetting: () => (/* binding */ loadSetting),\n/* harmony export */   parseJSON: () => (/* binding */ parseJSON),\n/* harmony export */   parseProviderOptions: () => (/* binding */ parseProviderOptions),\n/* harmony export */   postFormDataToApi: () => (/* binding */ postFormDataToApi),\n/* harmony export */   postJsonToApi: () => (/* binding */ postJsonToApi),\n/* harmony export */   postToApi: () => (/* binding */ postToApi),\n/* harmony export */   removeUndefinedEntries: () => (/* binding */ removeUndefinedEntries),\n/* harmony export */   resolve: () => (/* binding */ resolve),\n/* harmony export */   safeParseJSON: () => (/* binding */ safeParseJSON),\n/* harmony export */   safeValidateTypes: () => (/* binding */ safeValidateTypes),\n/* harmony export */   validateTypes: () => (/* binding */ validateTypes),\n/* harmony export */   validator: () => (/* binding */ validator),\n/* harmony export */   validatorSymbol: () => (/* binding */ validatorSymbol),\n/* harmony export */   withoutTrailingSlash: () => (/* binding */ withoutTrailingSlash),\n/* harmony export */   zodValidator: () => (/* binding */ zodValidator)\n/* harmony export */ });\n/* harmony import */ var _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ai-sdk/provider */ \"(rsc)/./node_modules/@ai-sdk/provider/dist/index.mjs\");\n/* harmony import */ var nanoid_non_secure__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! nanoid/non-secure */ \"(rsc)/./node_modules/nanoid/non-secure/index.js\");\n/* harmony import */ var secure_json_parse__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! secure-json-parse */ \"(rsc)/./node_modules/secure-json-parse/index.js\");\n// src/combine-headers.ts\nfunction combineHeaders(...headers) {\n  return headers.reduce(\n    (combinedHeaders, currentHeaders) => ({\n      ...combinedHeaders,\n      ...currentHeaders != null ? currentHeaders : {}\n    }),\n    {}\n  );\n}\n\n// src/convert-async-iterator-to-readable-stream.ts\nfunction convertAsyncIteratorToReadableStream(iterator) {\n  return new ReadableStream({\n    /**\n     * Called when the consumer wants to pull more data from the stream.\n     *\n     * @param {ReadableStreamDefaultController<T>} controller - The controller to enqueue data into the stream.\n     * @returns {Promise<void>}\n     */\n    async pull(controller) {\n      try {\n        const { value, done } = await iterator.next();\n        if (done) {\n          controller.close();\n        } else {\n          controller.enqueue(value);\n        }\n      } catch (error) {\n        controller.error(error);\n      }\n    },\n    /**\n     * Called when the consumer cancels the stream.\n     */\n    cancel() {\n    }\n  });\n}\n\n// src/delay.ts\nasync function delay(delayInMs) {\n  return delayInMs == null ? Promise.resolve() : new Promise((resolve2) => setTimeout(resolve2, delayInMs));\n}\n\n// src/event-source-parser-stream.ts\nfunction createEventSourceParserStream() {\n  let buffer = \"\";\n  let event = void 0;\n  let data = [];\n  let lastEventId = void 0;\n  let retry = void 0;\n  function parseLine(line, controller) {\n    if (line === \"\") {\n      dispatchEvent(controller);\n      return;\n    }\n    if (line.startsWith(\":\")) {\n      return;\n    }\n    const colonIndex = line.indexOf(\":\");\n    if (colonIndex === -1) {\n      handleField(line, \"\");\n      return;\n    }\n    const field = line.slice(0, colonIndex);\n    const valueStart = colonIndex + 1;\n    const value = valueStart < line.length && line[valueStart] === \" \" ? line.slice(valueStart + 1) : line.slice(valueStart);\n    handleField(field, value);\n  }\n  function dispatchEvent(controller) {\n    if (data.length > 0) {\n      controller.enqueue({\n        event,\n        data: data.join(\"\\n\"),\n        id: lastEventId,\n        retry\n      });\n      data = [];\n      event = void 0;\n      retry = void 0;\n    }\n  }\n  function handleField(field, value) {\n    switch (field) {\n      case \"event\":\n        event = value;\n        break;\n      case \"data\":\n        data.push(value);\n        break;\n      case \"id\":\n        lastEventId = value;\n        break;\n      case \"retry\":\n        const parsedRetry = parseInt(value, 10);\n        if (!isNaN(parsedRetry)) {\n          retry = parsedRetry;\n        }\n        break;\n    }\n  }\n  return new TransformStream({\n    transform(chunk, controller) {\n      const { lines, incompleteLine } = splitLines(buffer, chunk);\n      buffer = incompleteLine;\n      for (let i = 0; i < lines.length; i++) {\n        parseLine(lines[i], controller);\n      }\n    },\n    flush(controller) {\n      parseLine(buffer, controller);\n      dispatchEvent(controller);\n    }\n  });\n}\nfunction splitLines(buffer, chunk) {\n  const lines = [];\n  let currentLine = buffer;\n  for (let i = 0; i < chunk.length; ) {\n    const char = chunk[i++];\n    if (char === \"\\n\") {\n      lines.push(currentLine);\n      currentLine = \"\";\n    } else if (char === \"\\r\") {\n      lines.push(currentLine);\n      currentLine = \"\";\n      if (chunk[i + 1] === \"\\n\") {\n        i++;\n      }\n    } else {\n      currentLine += char;\n    }\n  }\n  return { lines, incompleteLine: currentLine };\n}\n\n// src/extract-response-headers.ts\nfunction extractResponseHeaders(response) {\n  const headers = {};\n  response.headers.forEach((value, key) => {\n    headers[key] = value;\n  });\n  return headers;\n}\n\n// src/generate-id.ts\n\n\nvar createIdGenerator = ({\n  prefix,\n  size: defaultSize = 16,\n  alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\",\n  separator = \"-\"\n} = {}) => {\n  const generator = (0,nanoid_non_secure__WEBPACK_IMPORTED_MODULE_0__.customAlphabet)(alphabet, defaultSize);\n  if (prefix == null) {\n    return generator;\n  }\n  if (alphabet.includes(separator)) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidArgumentError({\n      argument: \"separator\",\n      message: `The separator \"${separator}\" must not be part of the alphabet \"${alphabet}\".`\n    });\n  }\n  return (size) => `${prefix}${separator}${generator(size)}`;\n};\nvar generateId = createIdGenerator();\n\n// src/get-error-message.ts\nfunction getErrorMessage(error) {\n  if (error == null) {\n    return \"unknown error\";\n  }\n  if (typeof error === \"string\") {\n    return error;\n  }\n  if (error instanceof Error) {\n    return error.message;\n  }\n  return JSON.stringify(error);\n}\n\n// src/get-from-api.ts\n\n\n// src/remove-undefined-entries.ts\nfunction removeUndefinedEntries(record) {\n  return Object.fromEntries(\n    Object.entries(record).filter(([_key, value]) => value != null)\n  );\n}\n\n// src/is-abort-error.ts\nfunction isAbortError(error) {\n  return error instanceof Error && (error.name === \"AbortError\" || error.name === \"TimeoutError\");\n}\n\n// src/get-from-api.ts\nvar getOriginalFetch = () => globalThis.fetch;\nvar getFromApi = async ({\n  url,\n  headers = {},\n  successfulResponseHandler,\n  failedResponseHandler,\n  abortSignal,\n  fetch = getOriginalFetch()\n}) => {\n  try {\n    const response = await fetch(url, {\n      method: \"GET\",\n      headers: removeUndefinedEntries(headers),\n      signal: abortSignal\n    });\n    const responseHeaders = extractResponseHeaders(response);\n    if (!response.ok) {\n      let errorInformation;\n      try {\n        errorInformation = await failedResponseHandler({\n          response,\n          url,\n          requestBodyValues: {}\n        });\n      } catch (error) {\n        if (isAbortError(error) || _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError.isInstance(error)) {\n          throw error;\n        }\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError({\n          message: \"Failed to process error response\",\n          cause: error,\n          statusCode: response.status,\n          url,\n          responseHeaders,\n          requestBodyValues: {}\n        });\n      }\n      throw errorInformation.value;\n    }\n    try {\n      return await successfulResponseHandler({\n        response,\n        url,\n        requestBodyValues: {}\n      });\n    } catch (error) {\n      if (error instanceof Error) {\n        if (isAbortError(error) || _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError.isInstance(error)) {\n          throw error;\n        }\n      }\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError({\n        message: \"Failed to process successful response\",\n        cause: error,\n        statusCode: response.status,\n        url,\n        responseHeaders,\n        requestBodyValues: {}\n      });\n    }\n  } catch (error) {\n    if (isAbortError(error)) {\n      throw error;\n    }\n    if (error instanceof TypeError && error.message === \"fetch failed\") {\n      const cause = error.cause;\n      if (cause != null) {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError({\n          message: `Cannot connect to API: ${cause.message}`,\n          cause,\n          url,\n          isRetryable: true,\n          requestBodyValues: {}\n        });\n      }\n    }\n    throw error;\n  }\n};\n\n// src/load-api-key.ts\n\nfunction loadApiKey({\n  apiKey,\n  environmentVariableName,\n  apiKeyParameterName = \"apiKey\",\n  description\n}) {\n  if (typeof apiKey === \"string\") {\n    return apiKey;\n  }\n  if (apiKey != null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.LoadAPIKeyError({\n      message: `${description} API key must be a string.`\n    });\n  }\n  if (typeof process === \"undefined\") {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.LoadAPIKeyError({\n      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter. Environment variables is not supported in this environment.`\n    });\n  }\n  apiKey = process.env[environmentVariableName];\n  if (apiKey == null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.LoadAPIKeyError({\n      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter or the ${environmentVariableName} environment variable.`\n    });\n  }\n  if (typeof apiKey !== \"string\") {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.LoadAPIKeyError({\n      message: `${description} API key must be a string. The value of the ${environmentVariableName} environment variable is not a string.`\n    });\n  }\n  return apiKey;\n}\n\n// src/load-optional-setting.ts\nfunction loadOptionalSetting({\n  settingValue,\n  environmentVariableName\n}) {\n  if (typeof settingValue === \"string\") {\n    return settingValue;\n  }\n  if (settingValue != null || typeof process === \"undefined\") {\n    return void 0;\n  }\n  settingValue = process.env[environmentVariableName];\n  if (settingValue == null || typeof settingValue !== \"string\") {\n    return void 0;\n  }\n  return settingValue;\n}\n\n// src/load-setting.ts\n\nfunction loadSetting({\n  settingValue,\n  environmentVariableName,\n  settingName,\n  description\n}) {\n  if (typeof settingValue === \"string\") {\n    return settingValue;\n  }\n  if (settingValue != null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.LoadSettingError({\n      message: `${description} setting must be a string.`\n    });\n  }\n  if (typeof process === \"undefined\") {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.LoadSettingError({\n      message: `${description} setting is missing. Pass it using the '${settingName}' parameter. Environment variables is not supported in this environment.`\n    });\n  }\n  settingValue = process.env[environmentVariableName];\n  if (settingValue == null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.LoadSettingError({\n      message: `${description} setting is missing. Pass it using the '${settingName}' parameter or the ${environmentVariableName} environment variable.`\n    });\n  }\n  if (typeof settingValue !== \"string\") {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.LoadSettingError({\n      message: `${description} setting must be a string. The value of the ${environmentVariableName} environment variable is not a string.`\n    });\n  }\n  return settingValue;\n}\n\n// src/parse-json.ts\n\n\n\n// src/validate-types.ts\n\n\n// src/validator.ts\nvar validatorSymbol = Symbol.for(\"vercel.ai.validator\");\nfunction validator(validate) {\n  return { [validatorSymbol]: true, validate };\n}\nfunction isValidator(value) {\n  return typeof value === \"object\" && value !== null && validatorSymbol in value && value[validatorSymbol] === true && \"validate\" in value;\n}\nfunction asValidator(value) {\n  return isValidator(value) ? value : zodValidator(value);\n}\nfunction zodValidator(zodSchema) {\n  return validator((value) => {\n    const result = zodSchema.safeParse(value);\n    return result.success ? { success: true, value: result.data } : { success: false, error: result.error };\n  });\n}\n\n// src/validate-types.ts\nfunction validateTypes({\n  value,\n  schema: inputSchema\n}) {\n  const result = safeValidateTypes({ value, schema: inputSchema });\n  if (!result.success) {\n    throw _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.TypeValidationError.wrap({ value, cause: result.error });\n  }\n  return result.value;\n}\nfunction safeValidateTypes({\n  value,\n  schema\n}) {\n  const validator2 = asValidator(schema);\n  try {\n    if (validator2.validate == null) {\n      return { success: true, value };\n    }\n    const result = validator2.validate(value);\n    if (result.success) {\n      return result;\n    }\n    return {\n      success: false,\n      error: _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.TypeValidationError.wrap({ value, cause: result.error })\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.TypeValidationError.wrap({ value, cause: error })\n    };\n  }\n}\n\n// src/parse-json.ts\nfunction parseJSON({\n  text,\n  schema\n}) {\n  try {\n    const value = secure_json_parse__WEBPACK_IMPORTED_MODULE_2__.parse(text);\n    if (schema == null) {\n      return value;\n    }\n    return validateTypes({ value, schema });\n  } catch (error) {\n    if (_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.JSONParseError.isInstance(error) || _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.TypeValidationError.isInstance(error)) {\n      throw error;\n    }\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.JSONParseError({ text, cause: error });\n  }\n}\nfunction safeParseJSON({\n  text,\n  schema\n}) {\n  try {\n    const value = secure_json_parse__WEBPACK_IMPORTED_MODULE_2__.parse(text);\n    if (schema == null) {\n      return { success: true, value, rawValue: value };\n    }\n    const validationResult = safeValidateTypes({ value, schema });\n    return validationResult.success ? { ...validationResult, rawValue: value } : validationResult;\n  } catch (error) {\n    return {\n      success: false,\n      error: _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.JSONParseError.isInstance(error) ? error : new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.JSONParseError({ text, cause: error })\n    };\n  }\n}\nfunction isParsableJson(input) {\n  try {\n    secure_json_parse__WEBPACK_IMPORTED_MODULE_2__.parse(input);\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\n// src/parse-provider-options.ts\n\nfunction parseProviderOptions({\n  provider,\n  providerOptions,\n  schema\n}) {\n  if ((providerOptions == null ? void 0 : providerOptions[provider]) == null) {\n    return void 0;\n  }\n  const parsedProviderOptions = safeValidateTypes({\n    value: providerOptions[provider],\n    schema\n  });\n  if (!parsedProviderOptions.success) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidArgumentError({\n      argument: \"providerOptions\",\n      message: `invalid ${provider} provider options`,\n      cause: parsedProviderOptions.error\n    });\n  }\n  return parsedProviderOptions.value;\n}\n\n// src/post-to-api.ts\n\nvar getOriginalFetch2 = () => globalThis.fetch;\nvar postJsonToApi = async ({\n  url,\n  headers,\n  body,\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch\n}) => postToApi({\n  url,\n  headers: {\n    \"Content-Type\": \"application/json\",\n    ...headers\n  },\n  body: {\n    content: JSON.stringify(body),\n    values: body\n  },\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch\n});\nvar postFormDataToApi = async ({\n  url,\n  headers,\n  formData,\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch\n}) => postToApi({\n  url,\n  headers,\n  body: {\n    content: formData,\n    values: Object.fromEntries(formData.entries())\n  },\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch\n});\nvar postToApi = async ({\n  url,\n  headers = {},\n  body,\n  successfulResponseHandler,\n  failedResponseHandler,\n  abortSignal,\n  fetch = getOriginalFetch2()\n}) => {\n  try {\n    const response = await fetch(url, {\n      method: \"POST\",\n      headers: removeUndefinedEntries(headers),\n      body: body.content,\n      signal: abortSignal\n    });\n    const responseHeaders = extractResponseHeaders(response);\n    if (!response.ok) {\n      let errorInformation;\n      try {\n        errorInformation = await failedResponseHandler({\n          response,\n          url,\n          requestBodyValues: body.values\n        });\n      } catch (error) {\n        if (isAbortError(error) || _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError.isInstance(error)) {\n          throw error;\n        }\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError({\n          message: \"Failed to process error response\",\n          cause: error,\n          statusCode: response.status,\n          url,\n          responseHeaders,\n          requestBodyValues: body.values\n        });\n      }\n      throw errorInformation.value;\n    }\n    try {\n      return await successfulResponseHandler({\n        response,\n        url,\n        requestBodyValues: body.values\n      });\n    } catch (error) {\n      if (error instanceof Error) {\n        if (isAbortError(error) || _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError.isInstance(error)) {\n          throw error;\n        }\n      }\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError({\n        message: \"Failed to process successful response\",\n        cause: error,\n        statusCode: response.status,\n        url,\n        responseHeaders,\n        requestBodyValues: body.values\n      });\n    }\n  } catch (error) {\n    if (isAbortError(error)) {\n      throw error;\n    }\n    if (error instanceof TypeError && error.message === \"fetch failed\") {\n      const cause = error.cause;\n      if (cause != null) {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError({\n          message: `Cannot connect to API: ${cause.message}`,\n          cause,\n          url,\n          requestBodyValues: body.values,\n          isRetryable: true\n          // retry when network error\n        });\n      }\n    }\n    throw error;\n  }\n};\n\n// src/resolve.ts\nasync function resolve(value) {\n  if (typeof value === \"function\") {\n    value = value();\n  }\n  return Promise.resolve(value);\n}\n\n// src/response-handler.ts\n\nvar createJsonErrorResponseHandler = ({\n  errorSchema,\n  errorToMessage,\n  isRetryable\n}) => async ({ response, url, requestBodyValues }) => {\n  const responseBody = await response.text();\n  const responseHeaders = extractResponseHeaders(response);\n  if (responseBody.trim() === \"\") {\n    return {\n      responseHeaders,\n      value: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError({\n        message: response.statusText,\n        url,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n        isRetryable: isRetryable == null ? void 0 : isRetryable(response)\n      })\n    };\n  }\n  try {\n    const parsedError = parseJSON({\n      text: responseBody,\n      schema: errorSchema\n    });\n    return {\n      responseHeaders,\n      value: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError({\n        message: errorToMessage(parsedError),\n        url,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n        data: parsedError,\n        isRetryable: isRetryable == null ? void 0 : isRetryable(response, parsedError)\n      })\n    };\n  } catch (parseError) {\n    return {\n      responseHeaders,\n      value: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError({\n        message: response.statusText,\n        url,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n        isRetryable: isRetryable == null ? void 0 : isRetryable(response)\n      })\n    };\n  }\n};\nvar createEventSourceResponseHandler = (chunkSchema) => async ({ response }) => {\n  const responseHeaders = extractResponseHeaders(response);\n  if (response.body == null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.EmptyResponseBodyError({});\n  }\n  return {\n    responseHeaders,\n    value: response.body.pipeThrough(new TextDecoderStream()).pipeThrough(createEventSourceParserStream()).pipeThrough(\n      new TransformStream({\n        transform({ data }, controller) {\n          if (data === \"[DONE]\") {\n            return;\n          }\n          controller.enqueue(\n            safeParseJSON({\n              text: data,\n              schema: chunkSchema\n            })\n          );\n        }\n      })\n    )\n  };\n};\nvar createJsonStreamResponseHandler = (chunkSchema) => async ({ response }) => {\n  const responseHeaders = extractResponseHeaders(response);\n  if (response.body == null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.EmptyResponseBodyError({});\n  }\n  let buffer = \"\";\n  return {\n    responseHeaders,\n    value: response.body.pipeThrough(new TextDecoderStream()).pipeThrough(\n      new TransformStream({\n        transform(chunkText, controller) {\n          if (chunkText.endsWith(\"\\n\")) {\n            controller.enqueue(\n              safeParseJSON({\n                text: buffer + chunkText,\n                schema: chunkSchema\n              })\n            );\n            buffer = \"\";\n          } else {\n            buffer += chunkText;\n          }\n        }\n      })\n    )\n  };\n};\nvar createJsonResponseHandler = (responseSchema) => async ({ response, url, requestBodyValues }) => {\n  const responseBody = await response.text();\n  const parsedResult = safeParseJSON({\n    text: responseBody,\n    schema: responseSchema\n  });\n  const responseHeaders = extractResponseHeaders(response);\n  if (!parsedResult.success) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError({\n      message: \"Invalid JSON response\",\n      cause: parsedResult.error,\n      statusCode: response.status,\n      responseHeaders,\n      responseBody,\n      url,\n      requestBodyValues\n    });\n  }\n  return {\n    responseHeaders,\n    value: parsedResult.value,\n    rawValue: parsedResult.rawValue\n  };\n};\nvar createBinaryResponseHandler = () => async ({ response, url, requestBodyValues }) => {\n  const responseHeaders = extractResponseHeaders(response);\n  if (!response.body) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError({\n      message: \"Response body is empty\",\n      url,\n      requestBodyValues,\n      statusCode: response.status,\n      responseHeaders,\n      responseBody: void 0\n    });\n  }\n  try {\n    const buffer = await response.arrayBuffer();\n    return {\n      responseHeaders,\n      value: new Uint8Array(buffer)\n    };\n  } catch (error) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError({\n      message: \"Failed to read response as array buffer\",\n      url,\n      requestBodyValues,\n      statusCode: response.status,\n      responseHeaders,\n      responseBody: void 0,\n      cause: error\n    });\n  }\n};\nvar createStatusCodeErrorResponseHandler = () => async ({ response, url, requestBodyValues }) => {\n  const responseHeaders = extractResponseHeaders(response);\n  const responseBody = await response.text();\n  return {\n    responseHeaders,\n    value: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError({\n      message: response.statusText,\n      url,\n      requestBodyValues,\n      statusCode: response.status,\n      responseHeaders,\n      responseBody\n    })\n  };\n};\n\n// src/uint8-utils.ts\nvar { btoa, atob } = globalThis;\nfunction convertBase64ToUint8Array(base64String) {\n  const base64Url = base64String.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  const latin1string = atob(base64Url);\n  return Uint8Array.from(latin1string, (byte) => byte.codePointAt(0));\n}\nfunction convertUint8ArrayToBase64(array) {\n  let latin1string = \"\";\n  for (let i = 0; i < array.length; i++) {\n    latin1string += String.fromCodePoint(array[i]);\n  }\n  return btoa(latin1string);\n}\n\n// src/without-trailing-slash.ts\nfunction withoutTrailingSlash(url) {\n  return url == null ? void 0 : url.replace(/\\/$/, \"\");\n}\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGFpLXNkay9wcm92aWRlci11dGlscy9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx3QkFBd0I7QUFDdEM7QUFDQSxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQSxpREFBaUQsa0NBQWtDO0FBQ25GO0FBQ0E7QUFDQSxjQUFjLDBEQUFhO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixjQUFjLDBEQUFhO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSwwREFBMEQsa0NBQWtDO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwwREFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLE1BQU0sYUFBYTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUF3Q0U7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cnZpdmFsLWZ1bi8uL25vZGVfbW9kdWxlcy9AYWktc2RrL3Byb3ZpZGVyLXV0aWxzL2Rpc3QvaW5kZXgubWpzPzIwN2UiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2NvbWJpbmUtaGVhZGVycy50c1xuZnVuY3Rpb24gY29tYmluZUhlYWRlcnMoLi4uaGVhZGVycykge1xuICByZXR1cm4gaGVhZGVycy5yZWR1Y2UoXG4gICAgKGNvbWJpbmVkSGVhZGVycywgY3VycmVudEhlYWRlcnMpID0+ICh7XG4gICAgICAuLi5jb21iaW5lZEhlYWRlcnMsXG4gICAgICAuLi5jdXJyZW50SGVhZGVycyAhPSBudWxsID8gY3VycmVudEhlYWRlcnMgOiB7fVxuICAgIH0pLFxuICAgIHt9XG4gICk7XG59XG5cbi8vIHNyYy9jb252ZXJ0LWFzeW5jLWl0ZXJhdG9yLXRvLXJlYWRhYmxlLXN0cmVhbS50c1xuZnVuY3Rpb24gY29udmVydEFzeW5jSXRlcmF0b3JUb1JlYWRhYmxlU3RyZWFtKGl0ZXJhdG9yKSB7XG4gIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIHRoZSBjb25zdW1lciB3YW50cyB0byBwdWxsIG1vcmUgZGF0YSBmcm9tIHRoZSBzdHJlYW0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8VD59IGNvbnRyb2xsZXIgLSBUaGUgY29udHJvbGxlciB0byBlbnF1ZXVlIGRhdGEgaW50byB0aGUgc3RyZWFtLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgICAqL1xuICAgIGFzeW5jIHB1bGwoY29udHJvbGxlcikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gYXdhaXQgaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb250cm9sbGVyLmVycm9yKGVycm9yKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIHRoZSBjb25zdW1lciBjYW5jZWxzIHRoZSBzdHJlYW0uXG4gICAgICovXG4gICAgY2FuY2VsKCkge1xuICAgIH1cbiAgfSk7XG59XG5cbi8vIHNyYy9kZWxheS50c1xuYXN5bmMgZnVuY3Rpb24gZGVsYXkoZGVsYXlJbk1zKSB7XG4gIHJldHVybiBkZWxheUluTXMgPT0gbnVsbCA/IFByb21pc2UucmVzb2x2ZSgpIDogbmV3IFByb21pc2UoKHJlc29sdmUyKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUyLCBkZWxheUluTXMpKTtcbn1cblxuLy8gc3JjL2V2ZW50LXNvdXJjZS1wYXJzZXItc3RyZWFtLnRzXG5mdW5jdGlvbiBjcmVhdGVFdmVudFNvdXJjZVBhcnNlclN0cmVhbSgpIHtcbiAgbGV0IGJ1ZmZlciA9IFwiXCI7XG4gIGxldCBldmVudCA9IHZvaWQgMDtcbiAgbGV0IGRhdGEgPSBbXTtcbiAgbGV0IGxhc3RFdmVudElkID0gdm9pZCAwO1xuICBsZXQgcmV0cnkgPSB2b2lkIDA7XG4gIGZ1bmN0aW9uIHBhcnNlTGluZShsaW5lLCBjb250cm9sbGVyKSB7XG4gICAgaWYgKGxpbmUgPT09IFwiXCIpIHtcbiAgICAgIGRpc3BhdGNoRXZlbnQoY29udHJvbGxlcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChsaW5lLnN0YXJ0c1dpdGgoXCI6XCIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNvbG9uSW5kZXggPSBsaW5lLmluZGV4T2YoXCI6XCIpO1xuICAgIGlmIChjb2xvbkluZGV4ID09PSAtMSkge1xuICAgICAgaGFuZGxlRmllbGQobGluZSwgXCJcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGZpZWxkID0gbGluZS5zbGljZSgwLCBjb2xvbkluZGV4KTtcbiAgICBjb25zdCB2YWx1ZVN0YXJ0ID0gY29sb25JbmRleCArIDE7XG4gICAgY29uc3QgdmFsdWUgPSB2YWx1ZVN0YXJ0IDwgbGluZS5sZW5ndGggJiYgbGluZVt2YWx1ZVN0YXJ0XSA9PT0gXCIgXCIgPyBsaW5lLnNsaWNlKHZhbHVlU3RhcnQgKyAxKSA6IGxpbmUuc2xpY2UodmFsdWVTdGFydCk7XG4gICAgaGFuZGxlRmllbGQoZmllbGQsIHZhbHVlKTtcbiAgfVxuICBmdW5jdGlvbiBkaXNwYXRjaEV2ZW50KGNvbnRyb2xsZXIpIHtcbiAgICBpZiAoZGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICBldmVudCxcbiAgICAgICAgZGF0YTogZGF0YS5qb2luKFwiXFxuXCIpLFxuICAgICAgICBpZDogbGFzdEV2ZW50SWQsXG4gICAgICAgIHJldHJ5XG4gICAgICB9KTtcbiAgICAgIGRhdGEgPSBbXTtcbiAgICAgIGV2ZW50ID0gdm9pZCAwO1xuICAgICAgcmV0cnkgPSB2b2lkIDA7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGhhbmRsZUZpZWxkKGZpZWxkLCB2YWx1ZSkge1xuICAgIHN3aXRjaCAoZmllbGQpIHtcbiAgICAgIGNhc2UgXCJldmVudFwiOlxuICAgICAgICBldmVudCA9IHZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJkYXRhXCI6XG4gICAgICAgIGRhdGEucHVzaCh2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImlkXCI6XG4gICAgICAgIGxhc3RFdmVudElkID0gdmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInJldHJ5XCI6XG4gICAgICAgIGNvbnN0IHBhcnNlZFJldHJ5ID0gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgICAgICAgaWYgKCFpc05hTihwYXJzZWRSZXRyeSkpIHtcbiAgICAgICAgICByZXRyeSA9IHBhcnNlZFJldHJ5O1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICBjb25zdCB7IGxpbmVzLCBpbmNvbXBsZXRlTGluZSB9ID0gc3BsaXRMaW5lcyhidWZmZXIsIGNodW5rKTtcbiAgICAgIGJ1ZmZlciA9IGluY29tcGxldGVMaW5lO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwYXJzZUxpbmUobGluZXNbaV0sIGNvbnRyb2xsZXIpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZmx1c2goY29udHJvbGxlcikge1xuICAgICAgcGFyc2VMaW5lKGJ1ZmZlciwgY29udHJvbGxlcik7XG4gICAgICBkaXNwYXRjaEV2ZW50KGNvbnRyb2xsZXIpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBzcGxpdExpbmVzKGJ1ZmZlciwgY2h1bmspIHtcbiAgY29uc3QgbGluZXMgPSBbXTtcbiAgbGV0IGN1cnJlbnRMaW5lID0gYnVmZmVyO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNodW5rLmxlbmd0aDsgKSB7XG4gICAgY29uc3QgY2hhciA9IGNodW5rW2krK107XG4gICAgaWYgKGNoYXIgPT09IFwiXFxuXCIpIHtcbiAgICAgIGxpbmVzLnB1c2goY3VycmVudExpbmUpO1xuICAgICAgY3VycmVudExpbmUgPSBcIlwiO1xuICAgIH0gZWxzZSBpZiAoY2hhciA9PT0gXCJcXHJcIikge1xuICAgICAgbGluZXMucHVzaChjdXJyZW50TGluZSk7XG4gICAgICBjdXJyZW50TGluZSA9IFwiXCI7XG4gICAgICBpZiAoY2h1bmtbaSArIDFdID09PSBcIlxcblwiKSB7XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudExpbmUgKz0gY2hhcjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHsgbGluZXMsIGluY29tcGxldGVMaW5lOiBjdXJyZW50TGluZSB9O1xufVxuXG4vLyBzcmMvZXh0cmFjdC1yZXNwb25zZS1oZWFkZXJzLnRzXG5mdW5jdGlvbiBleHRyYWN0UmVzcG9uc2VIZWFkZXJzKHJlc3BvbnNlKSB7XG4gIGNvbnN0IGhlYWRlcnMgPSB7fTtcbiAgcmVzcG9uc2UuaGVhZGVycy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgaGVhZGVyc1trZXldID0gdmFsdWU7XG4gIH0pO1xuICByZXR1cm4gaGVhZGVycztcbn1cblxuLy8gc3JjL2dlbmVyYXRlLWlkLnRzXG5pbXBvcnQgeyBJbnZhbGlkQXJndW1lbnRFcnJvciB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5pbXBvcnQgeyBjdXN0b21BbHBoYWJldCB9IGZyb20gXCJuYW5vaWQvbm9uLXNlY3VyZVwiO1xudmFyIGNyZWF0ZUlkR2VuZXJhdG9yID0gKHtcbiAgcHJlZml4LFxuICBzaXplOiBkZWZhdWx0U2l6ZSA9IDE2LFxuICBhbHBoYWJldCA9IFwiMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpcIixcbiAgc2VwYXJhdG9yID0gXCItXCJcbn0gPSB7fSkgPT4ge1xuICBjb25zdCBnZW5lcmF0b3IgPSBjdXN0b21BbHBoYWJldChhbHBoYWJldCwgZGVmYXVsdFNpemUpO1xuICBpZiAocHJlZml4ID09IG51bGwpIHtcbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICB9XG4gIGlmIChhbHBoYWJldC5pbmNsdWRlcyhzZXBhcmF0b3IpKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgIGFyZ3VtZW50OiBcInNlcGFyYXRvclwiLFxuICAgICAgbWVzc2FnZTogYFRoZSBzZXBhcmF0b3IgXCIke3NlcGFyYXRvcn1cIiBtdXN0IG5vdCBiZSBwYXJ0IG9mIHRoZSBhbHBoYWJldCBcIiR7YWxwaGFiZXR9XCIuYFxuICAgIH0pO1xuICB9XG4gIHJldHVybiAoc2l6ZSkgPT4gYCR7cHJlZml4fSR7c2VwYXJhdG9yfSR7Z2VuZXJhdG9yKHNpemUpfWA7XG59O1xudmFyIGdlbmVyYXRlSWQgPSBjcmVhdGVJZEdlbmVyYXRvcigpO1xuXG4vLyBzcmMvZ2V0LWVycm9yLW1lc3NhZ2UudHNcbmZ1bmN0aW9uIGdldEVycm9yTWVzc2FnZShlcnJvcikge1xuICBpZiAoZXJyb3IgPT0gbnVsbCkge1xuICAgIHJldHVybiBcInVua25vd24gZXJyb3JcIjtcbiAgfVxuICBpZiAodHlwZW9mIGVycm9yID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGVycm9yO1xuICB9XG4gIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yLm1lc3NhZ2U7XG4gIH1cbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGVycm9yKTtcbn1cblxuLy8gc3JjL2dldC1mcm9tLWFwaS50c1xuaW1wb3J0IHsgQVBJQ2FsbEVycm9yIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcblxuLy8gc3JjL3JlbW92ZS11bmRlZmluZWQtZW50cmllcy50c1xuZnVuY3Rpb24gcmVtb3ZlVW5kZWZpbmVkRW50cmllcyhyZWNvcmQpIHtcbiAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICBPYmplY3QuZW50cmllcyhyZWNvcmQpLmZpbHRlcigoW19rZXksIHZhbHVlXSkgPT4gdmFsdWUgIT0gbnVsbClcbiAgKTtcbn1cblxuLy8gc3JjL2lzLWFib3J0LWVycm9yLnRzXG5mdW5jdGlvbiBpc0Fib3J0RXJyb3IoZXJyb3IpIHtcbiAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgKGVycm9yLm5hbWUgPT09IFwiQWJvcnRFcnJvclwiIHx8IGVycm9yLm5hbWUgPT09IFwiVGltZW91dEVycm9yXCIpO1xufVxuXG4vLyBzcmMvZ2V0LWZyb20tYXBpLnRzXG52YXIgZ2V0T3JpZ2luYWxGZXRjaCA9ICgpID0+IGdsb2JhbFRoaXMuZmV0Y2g7XG52YXIgZ2V0RnJvbUFwaSA9IGFzeW5jICh7XG4gIHVybCxcbiAgaGVhZGVycyA9IHt9LFxuICBzdWNjZXNzZnVsUmVzcG9uc2VIYW5kbGVyLFxuICBmYWlsZWRSZXNwb25zZUhhbmRsZXIsXG4gIGFib3J0U2lnbmFsLFxuICBmZXRjaCA9IGdldE9yaWdpbmFsRmV0Y2goKVxufSkgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICBoZWFkZXJzOiByZW1vdmVVbmRlZmluZWRFbnRyaWVzKGhlYWRlcnMpLFxuICAgICAgc2lnbmFsOiBhYm9ydFNpZ25hbFxuICAgIH0pO1xuICAgIGNvbnN0IHJlc3BvbnNlSGVhZGVycyA9IGV4dHJhY3RSZXNwb25zZUhlYWRlcnMocmVzcG9uc2UpO1xuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIGxldCBlcnJvckluZm9ybWF0aW9uO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZXJyb3JJbmZvcm1hdGlvbiA9IGF3YWl0IGZhaWxlZFJlc3BvbnNlSGFuZGxlcih7XG4gICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgdXJsLFxuICAgICAgICAgIHJlcXVlc3RCb2R5VmFsdWVzOiB7fVxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChpc0Fib3J0RXJyb3IoZXJyb3IpIHx8IEFQSUNhbGxFcnJvci5pc0luc3RhbmNlKGVycm9yKSkge1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBBUElDYWxsRXJyb3Ioe1xuICAgICAgICAgIG1lc3NhZ2U6IFwiRmFpbGVkIHRvIHByb2Nlc3MgZXJyb3IgcmVzcG9uc2VcIixcbiAgICAgICAgICBjYXVzZTogZXJyb3IsXG4gICAgICAgICAgc3RhdHVzQ29kZTogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgIHVybCxcbiAgICAgICAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgICAgICAgcmVxdWVzdEJvZHlWYWx1ZXM6IHt9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdGhyb3cgZXJyb3JJbmZvcm1hdGlvbi52YWx1ZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCBzdWNjZXNzZnVsUmVzcG9uc2VIYW5kbGVyKHtcbiAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgIHVybCxcbiAgICAgICAgcmVxdWVzdEJvZHlWYWx1ZXM6IHt9XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgaWYgKGlzQWJvcnRFcnJvcihlcnJvcikgfHwgQVBJQ2FsbEVycm9yLmlzSW5zdGFuY2UoZXJyb3IpKSB7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBBUElDYWxsRXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOiBcIkZhaWxlZCB0byBwcm9jZXNzIHN1Y2Nlc3NmdWwgcmVzcG9uc2VcIixcbiAgICAgICAgY2F1c2U6IGVycm9yLFxuICAgICAgICBzdGF0dXNDb2RlOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgIHVybCxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgICByZXF1ZXN0Qm9keVZhbHVlczoge31cbiAgICAgIH0pO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoaXNBYm9ydEVycm9yKGVycm9yKSkge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFR5cGVFcnJvciAmJiBlcnJvci5tZXNzYWdlID09PSBcImZldGNoIGZhaWxlZFwiKSB7XG4gICAgICBjb25zdCBjYXVzZSA9IGVycm9yLmNhdXNlO1xuICAgICAgaWYgKGNhdXNlICE9IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEFQSUNhbGxFcnJvcih7XG4gICAgICAgICAgbWVzc2FnZTogYENhbm5vdCBjb25uZWN0IHRvIEFQSTogJHtjYXVzZS5tZXNzYWdlfWAsXG4gICAgICAgICAgY2F1c2UsXG4gICAgICAgICAgdXJsLFxuICAgICAgICAgIGlzUmV0cnlhYmxlOiB0cnVlLFxuICAgICAgICAgIHJlcXVlc3RCb2R5VmFsdWVzOiB7fVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG5cbi8vIHNyYy9sb2FkLWFwaS1rZXkudHNcbmltcG9ydCB7IExvYWRBUElLZXlFcnJvciB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5mdW5jdGlvbiBsb2FkQXBpS2V5KHtcbiAgYXBpS2V5LFxuICBlbnZpcm9ubWVudFZhcmlhYmxlTmFtZSxcbiAgYXBpS2V5UGFyYW1ldGVyTmFtZSA9IFwiYXBpS2V5XCIsXG4gIGRlc2NyaXB0aW9uXG59KSB7XG4gIGlmICh0eXBlb2YgYXBpS2V5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGFwaUtleTtcbiAgfVxuICBpZiAoYXBpS2V5ICE9IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgTG9hZEFQSUtleUVycm9yKHtcbiAgICAgIG1lc3NhZ2U6IGAke2Rlc2NyaXB0aW9ufSBBUEkga2V5IG11c3QgYmUgYSBzdHJpbmcuYFxuICAgIH0pO1xuICB9XG4gIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHRocm93IG5ldyBMb2FkQVBJS2V5RXJyb3Ioe1xuICAgICAgbWVzc2FnZTogYCR7ZGVzY3JpcHRpb259IEFQSSBrZXkgaXMgbWlzc2luZy4gUGFzcyBpdCB1c2luZyB0aGUgJyR7YXBpS2V5UGFyYW1ldGVyTmFtZX0nIHBhcmFtZXRlci4gRW52aXJvbm1lbnQgdmFyaWFibGVzIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBlbnZpcm9ubWVudC5gXG4gICAgfSk7XG4gIH1cbiAgYXBpS2V5ID0gcHJvY2Vzcy5lbnZbZW52aXJvbm1lbnRWYXJpYWJsZU5hbWVdO1xuICBpZiAoYXBpS2V5ID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgTG9hZEFQSUtleUVycm9yKHtcbiAgICAgIG1lc3NhZ2U6IGAke2Rlc2NyaXB0aW9ufSBBUEkga2V5IGlzIG1pc3NpbmcuIFBhc3MgaXQgdXNpbmcgdGhlICcke2FwaUtleVBhcmFtZXRlck5hbWV9JyBwYXJhbWV0ZXIgb3IgdGhlICR7ZW52aXJvbm1lbnRWYXJpYWJsZU5hbWV9IGVudmlyb25tZW50IHZhcmlhYmxlLmBcbiAgICB9KTtcbiAgfVxuICBpZiAodHlwZW9mIGFwaUtleSAhPT0gXCJzdHJpbmdcIikge1xuICAgIHRocm93IG5ldyBMb2FkQVBJS2V5RXJyb3Ioe1xuICAgICAgbWVzc2FnZTogYCR7ZGVzY3JpcHRpb259IEFQSSBrZXkgbXVzdCBiZSBhIHN0cmluZy4gVGhlIHZhbHVlIG9mIHRoZSAke2Vudmlyb25tZW50VmFyaWFibGVOYW1lfSBlbnZpcm9ubWVudCB2YXJpYWJsZSBpcyBub3QgYSBzdHJpbmcuYFxuICAgIH0pO1xuICB9XG4gIHJldHVybiBhcGlLZXk7XG59XG5cbi8vIHNyYy9sb2FkLW9wdGlvbmFsLXNldHRpbmcudHNcbmZ1bmN0aW9uIGxvYWRPcHRpb25hbFNldHRpbmcoe1xuICBzZXR0aW5nVmFsdWUsXG4gIGVudmlyb25tZW50VmFyaWFibGVOYW1lXG59KSB7XG4gIGlmICh0eXBlb2Ygc2V0dGluZ1ZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIHNldHRpbmdWYWx1ZTtcbiAgfVxuICBpZiAoc2V0dGluZ1ZhbHVlICE9IG51bGwgfHwgdHlwZW9mIHByb2Nlc3MgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIHNldHRpbmdWYWx1ZSA9IHByb2Nlc3MuZW52W2Vudmlyb25tZW50VmFyaWFibGVOYW1lXTtcbiAgaWYgKHNldHRpbmdWYWx1ZSA9PSBudWxsIHx8IHR5cGVvZiBzZXR0aW5nVmFsdWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIHJldHVybiBzZXR0aW5nVmFsdWU7XG59XG5cbi8vIHNyYy9sb2FkLXNldHRpbmcudHNcbmltcG9ydCB7IExvYWRTZXR0aW5nRXJyb3IgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuZnVuY3Rpb24gbG9hZFNldHRpbmcoe1xuICBzZXR0aW5nVmFsdWUsXG4gIGVudmlyb25tZW50VmFyaWFibGVOYW1lLFxuICBzZXR0aW5nTmFtZSxcbiAgZGVzY3JpcHRpb25cbn0pIHtcbiAgaWYgKHR5cGVvZiBzZXR0aW5nVmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gc2V0dGluZ1ZhbHVlO1xuICB9XG4gIGlmIChzZXR0aW5nVmFsdWUgIT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBMb2FkU2V0dGluZ0Vycm9yKHtcbiAgICAgIG1lc3NhZ2U6IGAke2Rlc2NyaXB0aW9ufSBzZXR0aW5nIG11c3QgYmUgYSBzdHJpbmcuYFxuICAgIH0pO1xuICB9XG4gIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHRocm93IG5ldyBMb2FkU2V0dGluZ0Vycm9yKHtcbiAgICAgIG1lc3NhZ2U6IGAke2Rlc2NyaXB0aW9ufSBzZXR0aW5nIGlzIG1pc3NpbmcuIFBhc3MgaXQgdXNpbmcgdGhlICcke3NldHRpbmdOYW1lfScgcGFyYW1ldGVyLiBFbnZpcm9ubWVudCB2YXJpYWJsZXMgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGVudmlyb25tZW50LmBcbiAgICB9KTtcbiAgfVxuICBzZXR0aW5nVmFsdWUgPSBwcm9jZXNzLmVudltlbnZpcm9ubWVudFZhcmlhYmxlTmFtZV07XG4gIGlmIChzZXR0aW5nVmFsdWUgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBMb2FkU2V0dGluZ0Vycm9yKHtcbiAgICAgIG1lc3NhZ2U6IGAke2Rlc2NyaXB0aW9ufSBzZXR0aW5nIGlzIG1pc3NpbmcuIFBhc3MgaXQgdXNpbmcgdGhlICcke3NldHRpbmdOYW1lfScgcGFyYW1ldGVyIG9yIHRoZSAke2Vudmlyb25tZW50VmFyaWFibGVOYW1lfSBlbnZpcm9ubWVudCB2YXJpYWJsZS5gXG4gICAgfSk7XG4gIH1cbiAgaWYgKHR5cGVvZiBzZXR0aW5nVmFsdWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICB0aHJvdyBuZXcgTG9hZFNldHRpbmdFcnJvcih7XG4gICAgICBtZXNzYWdlOiBgJHtkZXNjcmlwdGlvbn0gc2V0dGluZyBtdXN0IGJlIGEgc3RyaW5nLiBUaGUgdmFsdWUgb2YgdGhlICR7ZW52aXJvbm1lbnRWYXJpYWJsZU5hbWV9IGVudmlyb25tZW50IHZhcmlhYmxlIGlzIG5vdCBhIHN0cmluZy5gXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHNldHRpbmdWYWx1ZTtcbn1cblxuLy8gc3JjL3BhcnNlLWpzb24udHNcbmltcG9ydCB7XG4gIEpTT05QYXJzZUVycm9yLFxuICBUeXBlVmFsaWRhdGlvbkVycm9yIGFzIFR5cGVWYWxpZGF0aW9uRXJyb3IyXG59IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5pbXBvcnQgU2VjdXJlSlNPTiBmcm9tIFwic2VjdXJlLWpzb24tcGFyc2VcIjtcblxuLy8gc3JjL3ZhbGlkYXRlLXR5cGVzLnRzXG5pbXBvcnQgeyBUeXBlVmFsaWRhdGlvbkVycm9yIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcblxuLy8gc3JjL3ZhbGlkYXRvci50c1xudmFyIHZhbGlkYXRvclN5bWJvbCA9IFN5bWJvbC5mb3IoXCJ2ZXJjZWwuYWkudmFsaWRhdG9yXCIpO1xuZnVuY3Rpb24gdmFsaWRhdG9yKHZhbGlkYXRlKSB7XG4gIHJldHVybiB7IFt2YWxpZGF0b3JTeW1ib2xdOiB0cnVlLCB2YWxpZGF0ZSB9O1xufVxuZnVuY3Rpb24gaXNWYWxpZGF0b3IodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWxpZGF0b3JTeW1ib2wgaW4gdmFsdWUgJiYgdmFsdWVbdmFsaWRhdG9yU3ltYm9sXSA9PT0gdHJ1ZSAmJiBcInZhbGlkYXRlXCIgaW4gdmFsdWU7XG59XG5mdW5jdGlvbiBhc1ZhbGlkYXRvcih2YWx1ZSkge1xuICByZXR1cm4gaXNWYWxpZGF0b3IodmFsdWUpID8gdmFsdWUgOiB6b2RWYWxpZGF0b3IodmFsdWUpO1xufVxuZnVuY3Rpb24gem9kVmFsaWRhdG9yKHpvZFNjaGVtYSkge1xuICByZXR1cm4gdmFsaWRhdG9yKCh2YWx1ZSkgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IHpvZFNjaGVtYS5zYWZlUGFyc2UodmFsdWUpO1xuICAgIHJldHVybiByZXN1bHQuc3VjY2VzcyA/IHsgc3VjY2VzczogdHJ1ZSwgdmFsdWU6IHJlc3VsdC5kYXRhIH0gOiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogcmVzdWx0LmVycm9yIH07XG4gIH0pO1xufVxuXG4vLyBzcmMvdmFsaWRhdGUtdHlwZXMudHNcbmZ1bmN0aW9uIHZhbGlkYXRlVHlwZXMoe1xuICB2YWx1ZSxcbiAgc2NoZW1hOiBpbnB1dFNjaGVtYVxufSkge1xuICBjb25zdCByZXN1bHQgPSBzYWZlVmFsaWRhdGVUeXBlcyh7IHZhbHVlLCBzY2hlbWE6IGlucHV0U2NoZW1hIH0pO1xuICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgdGhyb3cgVHlwZVZhbGlkYXRpb25FcnJvci53cmFwKHsgdmFsdWUsIGNhdXNlOiByZXN1bHQuZXJyb3IgfSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdC52YWx1ZTtcbn1cbmZ1bmN0aW9uIHNhZmVWYWxpZGF0ZVR5cGVzKHtcbiAgdmFsdWUsXG4gIHNjaGVtYVxufSkge1xuICBjb25zdCB2YWxpZGF0b3IyID0gYXNWYWxpZGF0b3Ioc2NoZW1hKTtcbiAgdHJ5IHtcbiAgICBpZiAodmFsaWRhdG9yMi52YWxpZGF0ZSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCB2YWx1ZSB9O1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSB2YWxpZGF0b3IyLnZhbGlkYXRlKHZhbHVlKTtcbiAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgIGVycm9yOiBUeXBlVmFsaWRhdGlvbkVycm9yLndyYXAoeyB2YWx1ZSwgY2F1c2U6IHJlc3VsdC5lcnJvciB9KVxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgZXJyb3I6IFR5cGVWYWxpZGF0aW9uRXJyb3Iud3JhcCh7IHZhbHVlLCBjYXVzZTogZXJyb3IgfSlcbiAgICB9O1xuICB9XG59XG5cbi8vIHNyYy9wYXJzZS1qc29uLnRzXG5mdW5jdGlvbiBwYXJzZUpTT04oe1xuICB0ZXh0LFxuICBzY2hlbWFcbn0pIHtcbiAgdHJ5IHtcbiAgICBjb25zdCB2YWx1ZSA9IFNlY3VyZUpTT04ucGFyc2UodGV4dCk7XG4gICAgaWYgKHNjaGVtYSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB2YWxpZGF0ZVR5cGVzKHsgdmFsdWUsIHNjaGVtYSB9KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoSlNPTlBhcnNlRXJyb3IuaXNJbnN0YW5jZShlcnJvcikgfHwgVHlwZVZhbGlkYXRpb25FcnJvcjIuaXNJbnN0YW5jZShlcnJvcikpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgSlNPTlBhcnNlRXJyb3IoeyB0ZXh0LCBjYXVzZTogZXJyb3IgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHNhZmVQYXJzZUpTT04oe1xuICB0ZXh0LFxuICBzY2hlbWFcbn0pIHtcbiAgdHJ5IHtcbiAgICBjb25zdCB2YWx1ZSA9IFNlY3VyZUpTT04ucGFyc2UodGV4dCk7XG4gICAgaWYgKHNjaGVtYSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCB2YWx1ZSwgcmF3VmFsdWU6IHZhbHVlIH07XG4gICAgfVxuICAgIGNvbnN0IHZhbGlkYXRpb25SZXN1bHQgPSBzYWZlVmFsaWRhdGVUeXBlcyh7IHZhbHVlLCBzY2hlbWEgfSk7XG4gICAgcmV0dXJuIHZhbGlkYXRpb25SZXN1bHQuc3VjY2VzcyA/IHsgLi4udmFsaWRhdGlvblJlc3VsdCwgcmF3VmFsdWU6IHZhbHVlIH0gOiB2YWxpZGF0aW9uUmVzdWx0O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB7XG4gICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgIGVycm9yOiBKU09OUGFyc2VFcnJvci5pc0luc3RhbmNlKGVycm9yKSA/IGVycm9yIDogbmV3IEpTT05QYXJzZUVycm9yKHsgdGV4dCwgY2F1c2U6IGVycm9yIH0pXG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gaXNQYXJzYWJsZUpzb24oaW5wdXQpIHtcbiAgdHJ5IHtcbiAgICBTZWN1cmVKU09OLnBhcnNlKGlucHV0KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vLyBzcmMvcGFyc2UtcHJvdmlkZXItb3B0aW9ucy50c1xuaW1wb3J0IHsgSW52YWxpZEFyZ3VtZW50RXJyb3IgYXMgSW52YWxpZEFyZ3VtZW50RXJyb3IyIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbmZ1bmN0aW9uIHBhcnNlUHJvdmlkZXJPcHRpb25zKHtcbiAgcHJvdmlkZXIsXG4gIHByb3ZpZGVyT3B0aW9ucyxcbiAgc2NoZW1hXG59KSB7XG4gIGlmICgocHJvdmlkZXJPcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBwcm92aWRlck9wdGlvbnNbcHJvdmlkZXJdKSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBjb25zdCBwYXJzZWRQcm92aWRlck9wdGlvbnMgPSBzYWZlVmFsaWRhdGVUeXBlcyh7XG4gICAgdmFsdWU6IHByb3ZpZGVyT3B0aW9uc1twcm92aWRlcl0sXG4gICAgc2NoZW1hXG4gIH0pO1xuICBpZiAoIXBhcnNlZFByb3ZpZGVyT3B0aW9ucy5zdWNjZXNzKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yMih7XG4gICAgICBhcmd1bWVudDogXCJwcm92aWRlck9wdGlvbnNcIixcbiAgICAgIG1lc3NhZ2U6IGBpbnZhbGlkICR7cHJvdmlkZXJ9IHByb3ZpZGVyIG9wdGlvbnNgLFxuICAgICAgY2F1c2U6IHBhcnNlZFByb3ZpZGVyT3B0aW9ucy5lcnJvclxuICAgIH0pO1xuICB9XG4gIHJldHVybiBwYXJzZWRQcm92aWRlck9wdGlvbnMudmFsdWU7XG59XG5cbi8vIHNyYy9wb3N0LXRvLWFwaS50c1xuaW1wb3J0IHsgQVBJQ2FsbEVycm9yIGFzIEFQSUNhbGxFcnJvcjIgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIGdldE9yaWdpbmFsRmV0Y2gyID0gKCkgPT4gZ2xvYmFsVGhpcy5mZXRjaDtcbnZhciBwb3N0SnNvblRvQXBpID0gYXN5bmMgKHtcbiAgdXJsLFxuICBoZWFkZXJzLFxuICBib2R5LFxuICBmYWlsZWRSZXNwb25zZUhhbmRsZXIsXG4gIHN1Y2Nlc3NmdWxSZXNwb25zZUhhbmRsZXIsXG4gIGFib3J0U2lnbmFsLFxuICBmZXRjaFxufSkgPT4gcG9zdFRvQXBpKHtcbiAgdXJsLFxuICBoZWFkZXJzOiB7XG4gICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgLi4uaGVhZGVyc1xuICB9LFxuICBib2R5OiB7XG4gICAgY29udGVudDogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgdmFsdWVzOiBib2R5XG4gIH0sXG4gIGZhaWxlZFJlc3BvbnNlSGFuZGxlcixcbiAgc3VjY2Vzc2Z1bFJlc3BvbnNlSGFuZGxlcixcbiAgYWJvcnRTaWduYWwsXG4gIGZldGNoXG59KTtcbnZhciBwb3N0Rm9ybURhdGFUb0FwaSA9IGFzeW5jICh7XG4gIHVybCxcbiAgaGVhZGVycyxcbiAgZm9ybURhdGEsXG4gIGZhaWxlZFJlc3BvbnNlSGFuZGxlcixcbiAgc3VjY2Vzc2Z1bFJlc3BvbnNlSGFuZGxlcixcbiAgYWJvcnRTaWduYWwsXG4gIGZldGNoXG59KSA9PiBwb3N0VG9BcGkoe1xuICB1cmwsXG4gIGhlYWRlcnMsXG4gIGJvZHk6IHtcbiAgICBjb250ZW50OiBmb3JtRGF0YSxcbiAgICB2YWx1ZXM6IE9iamVjdC5mcm9tRW50cmllcyhmb3JtRGF0YS5lbnRyaWVzKCkpXG4gIH0sXG4gIGZhaWxlZFJlc3BvbnNlSGFuZGxlcixcbiAgc3VjY2Vzc2Z1bFJlc3BvbnNlSGFuZGxlcixcbiAgYWJvcnRTaWduYWwsXG4gIGZldGNoXG59KTtcbnZhciBwb3N0VG9BcGkgPSBhc3luYyAoe1xuICB1cmwsXG4gIGhlYWRlcnMgPSB7fSxcbiAgYm9keSxcbiAgc3VjY2Vzc2Z1bFJlc3BvbnNlSGFuZGxlcixcbiAgZmFpbGVkUmVzcG9uc2VIYW5kbGVyLFxuICBhYm9ydFNpZ25hbCxcbiAgZmV0Y2ggPSBnZXRPcmlnaW5hbEZldGNoMigpXG59KSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBoZWFkZXJzOiByZW1vdmVVbmRlZmluZWRFbnRyaWVzKGhlYWRlcnMpLFxuICAgICAgYm9keTogYm9keS5jb250ZW50LFxuICAgICAgc2lnbmFsOiBhYm9ydFNpZ25hbFxuICAgIH0pO1xuICAgIGNvbnN0IHJlc3BvbnNlSGVhZGVycyA9IGV4dHJhY3RSZXNwb25zZUhlYWRlcnMocmVzcG9uc2UpO1xuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIGxldCBlcnJvckluZm9ybWF0aW9uO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZXJyb3JJbmZvcm1hdGlvbiA9IGF3YWl0IGZhaWxlZFJlc3BvbnNlSGFuZGxlcih7XG4gICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgdXJsLFxuICAgICAgICAgIHJlcXVlc3RCb2R5VmFsdWVzOiBib2R5LnZhbHVlc1xuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChpc0Fib3J0RXJyb3IoZXJyb3IpIHx8IEFQSUNhbGxFcnJvcjIuaXNJbnN0YW5jZShlcnJvcikpIHtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgQVBJQ2FsbEVycm9yMih7XG4gICAgICAgICAgbWVzc2FnZTogXCJGYWlsZWQgdG8gcHJvY2VzcyBlcnJvciByZXNwb25zZVwiLFxuICAgICAgICAgIGNhdXNlOiBlcnJvcixcbiAgICAgICAgICBzdGF0dXNDb2RlOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgICAgdXJsLFxuICAgICAgICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICAgICAgICByZXF1ZXN0Qm9keVZhbHVlczogYm9keS52YWx1ZXNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvckluZm9ybWF0aW9uLnZhbHVlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IHN1Y2Nlc3NmdWxSZXNwb25zZUhhbmRsZXIoe1xuICAgICAgICByZXNwb25zZSxcbiAgICAgICAgdXJsLFxuICAgICAgICByZXF1ZXN0Qm9keVZhbHVlczogYm9keS52YWx1ZXNcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICBpZiAoaXNBYm9ydEVycm9yKGVycm9yKSB8fCBBUElDYWxsRXJyb3IyLmlzSW5zdGFuY2UoZXJyb3IpKSB7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBBUElDYWxsRXJyb3IyKHtcbiAgICAgICAgbWVzc2FnZTogXCJGYWlsZWQgdG8gcHJvY2VzcyBzdWNjZXNzZnVsIHJlc3BvbnNlXCIsXG4gICAgICAgIGNhdXNlOiBlcnJvcixcbiAgICAgICAgc3RhdHVzQ29kZTogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICB1cmwsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICAgICAgcmVxdWVzdEJvZHlWYWx1ZXM6IGJvZHkudmFsdWVzXG4gICAgICB9KTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKGlzQWJvcnRFcnJvcihlcnJvcikpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBUeXBlRXJyb3IgJiYgZXJyb3IubWVzc2FnZSA9PT0gXCJmZXRjaCBmYWlsZWRcIikge1xuICAgICAgY29uc3QgY2F1c2UgPSBlcnJvci5jYXVzZTtcbiAgICAgIGlmIChjYXVzZSAhPSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBBUElDYWxsRXJyb3IyKHtcbiAgICAgICAgICBtZXNzYWdlOiBgQ2Fubm90IGNvbm5lY3QgdG8gQVBJOiAke2NhdXNlLm1lc3NhZ2V9YCxcbiAgICAgICAgICBjYXVzZSxcbiAgICAgICAgICB1cmwsXG4gICAgICAgICAgcmVxdWVzdEJvZHlWYWx1ZXM6IGJvZHkudmFsdWVzLFxuICAgICAgICAgIGlzUmV0cnlhYmxlOiB0cnVlXG4gICAgICAgICAgLy8gcmV0cnkgd2hlbiBuZXR3b3JrIGVycm9yXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcblxuLy8gc3JjL3Jlc29sdmUudHNcbmFzeW5jIGZ1bmN0aW9uIHJlc29sdmUodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdmFsdWUgPSB2YWx1ZSgpO1xuICB9XG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUpO1xufVxuXG4vLyBzcmMvcmVzcG9uc2UtaGFuZGxlci50c1xuaW1wb3J0IHsgQVBJQ2FsbEVycm9yIGFzIEFQSUNhbGxFcnJvcjMsIEVtcHR5UmVzcG9uc2VCb2R5RXJyb3IgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIGNyZWF0ZUpzb25FcnJvclJlc3BvbnNlSGFuZGxlciA9ICh7XG4gIGVycm9yU2NoZW1hLFxuICBlcnJvclRvTWVzc2FnZSxcbiAgaXNSZXRyeWFibGVcbn0pID0+IGFzeW5jICh7IHJlc3BvbnNlLCB1cmwsIHJlcXVlc3RCb2R5VmFsdWVzIH0pID0+IHtcbiAgY29uc3QgcmVzcG9uc2VCb2R5ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICBjb25zdCByZXNwb25zZUhlYWRlcnMgPSBleHRyYWN0UmVzcG9uc2VIZWFkZXJzKHJlc3BvbnNlKTtcbiAgaWYgKHJlc3BvbnNlQm9keS50cmltKCkgPT09IFwiXCIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgdmFsdWU6IG5ldyBBUElDYWxsRXJyb3IzKHtcbiAgICAgICAgbWVzc2FnZTogcmVzcG9uc2Uuc3RhdHVzVGV4dCxcbiAgICAgICAgdXJsLFxuICAgICAgICByZXF1ZXN0Qm9keVZhbHVlcyxcbiAgICAgICAgc3RhdHVzQ29kZTogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgICAgIHJlc3BvbnNlQm9keSxcbiAgICAgICAgaXNSZXRyeWFibGU6IGlzUmV0cnlhYmxlID09IG51bGwgPyB2b2lkIDAgOiBpc1JldHJ5YWJsZShyZXNwb25zZSlcbiAgICAgIH0pXG4gICAgfTtcbiAgfVxuICB0cnkge1xuICAgIGNvbnN0IHBhcnNlZEVycm9yID0gcGFyc2VKU09OKHtcbiAgICAgIHRleHQ6IHJlc3BvbnNlQm9keSxcbiAgICAgIHNjaGVtYTogZXJyb3JTY2hlbWFcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgdmFsdWU6IG5ldyBBUElDYWxsRXJyb3IzKHtcbiAgICAgICAgbWVzc2FnZTogZXJyb3JUb01lc3NhZ2UocGFyc2VkRXJyb3IpLFxuICAgICAgICB1cmwsXG4gICAgICAgIHJlcXVlc3RCb2R5VmFsdWVzLFxuICAgICAgICBzdGF0dXNDb2RlOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICAgICAgcmVzcG9uc2VCb2R5LFxuICAgICAgICBkYXRhOiBwYXJzZWRFcnJvcixcbiAgICAgICAgaXNSZXRyeWFibGU6IGlzUmV0cnlhYmxlID09IG51bGwgPyB2b2lkIDAgOiBpc1JldHJ5YWJsZShyZXNwb25zZSwgcGFyc2VkRXJyb3IpXG4gICAgICB9KVxuICAgIH07XG4gIH0gY2F0Y2ggKHBhcnNlRXJyb3IpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgdmFsdWU6IG5ldyBBUElDYWxsRXJyb3IzKHtcbiAgICAgICAgbWVzc2FnZTogcmVzcG9uc2Uuc3RhdHVzVGV4dCxcbiAgICAgICAgdXJsLFxuICAgICAgICByZXF1ZXN0Qm9keVZhbHVlcyxcbiAgICAgICAgc3RhdHVzQ29kZTogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgICAgIHJlc3BvbnNlQm9keSxcbiAgICAgICAgaXNSZXRyeWFibGU6IGlzUmV0cnlhYmxlID09IG51bGwgPyB2b2lkIDAgOiBpc1JldHJ5YWJsZShyZXNwb25zZSlcbiAgICAgIH0pXG4gICAgfTtcbiAgfVxufTtcbnZhciBjcmVhdGVFdmVudFNvdXJjZVJlc3BvbnNlSGFuZGxlciA9IChjaHVua1NjaGVtYSkgPT4gYXN5bmMgKHsgcmVzcG9uc2UgfSkgPT4ge1xuICBjb25zdCByZXNwb25zZUhlYWRlcnMgPSBleHRyYWN0UmVzcG9uc2VIZWFkZXJzKHJlc3BvbnNlKTtcbiAgaWYgKHJlc3BvbnNlLmJvZHkgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFbXB0eVJlc3BvbnNlQm9keUVycm9yKHt9KTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICB2YWx1ZTogcmVzcG9uc2UuYm9keS5waXBlVGhyb3VnaChuZXcgVGV4dERlY29kZXJTdHJlYW0oKSkucGlwZVRocm91Z2goY3JlYXRlRXZlbnRTb3VyY2VQYXJzZXJTdHJlYW0oKSkucGlwZVRocm91Z2goXG4gICAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgICAgdHJhbnNmb3JtKHsgZGF0YSB9LCBjb250cm9sbGVyKSB7XG4gICAgICAgICAgaWYgKGRhdGEgPT09IFwiW0RPTkVdXCIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgICAgc2FmZVBhcnNlSlNPTih7XG4gICAgICAgICAgICAgIHRleHQ6IGRhdGEsXG4gICAgICAgICAgICAgIHNjaGVtYTogY2h1bmtTY2hlbWFcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApXG4gIH07XG59O1xudmFyIGNyZWF0ZUpzb25TdHJlYW1SZXNwb25zZUhhbmRsZXIgPSAoY2h1bmtTY2hlbWEpID0+IGFzeW5jICh7IHJlc3BvbnNlIH0pID0+IHtcbiAgY29uc3QgcmVzcG9uc2VIZWFkZXJzID0gZXh0cmFjdFJlc3BvbnNlSGVhZGVycyhyZXNwb25zZSk7XG4gIGlmIChyZXNwb25zZS5ib2R5ID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRW1wdHlSZXNwb25zZUJvZHlFcnJvcih7fSk7XG4gIH1cbiAgbGV0IGJ1ZmZlciA9IFwiXCI7XG4gIHJldHVybiB7XG4gICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgIHZhbHVlOiByZXNwb25zZS5ib2R5LnBpcGVUaHJvdWdoKG5ldyBUZXh0RGVjb2RlclN0cmVhbSgpKS5waXBlVGhyb3VnaChcbiAgICAgIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgICB0cmFuc2Zvcm0oY2h1bmtUZXh0LCBjb250cm9sbGVyKSB7XG4gICAgICAgICAgaWYgKGNodW5rVGV4dC5lbmRzV2l0aChcIlxcblwiKSkge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgICAgICBzYWZlUGFyc2VKU09OKHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBidWZmZXIgKyBjaHVua1RleHQsXG4gICAgICAgICAgICAgICAgc2NoZW1hOiBjaHVua1NjaGVtYVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJ1ZmZlciA9IFwiXCI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJ1ZmZlciArPSBjaHVua1RleHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIClcbiAgfTtcbn07XG52YXIgY3JlYXRlSnNvblJlc3BvbnNlSGFuZGxlciA9IChyZXNwb25zZVNjaGVtYSkgPT4gYXN5bmMgKHsgcmVzcG9uc2UsIHVybCwgcmVxdWVzdEJvZHlWYWx1ZXMgfSkgPT4ge1xuICBjb25zdCByZXNwb25zZUJvZHkgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gIGNvbnN0IHBhcnNlZFJlc3VsdCA9IHNhZmVQYXJzZUpTT04oe1xuICAgIHRleHQ6IHJlc3BvbnNlQm9keSxcbiAgICBzY2hlbWE6IHJlc3BvbnNlU2NoZW1hXG4gIH0pO1xuICBjb25zdCByZXNwb25zZUhlYWRlcnMgPSBleHRyYWN0UmVzcG9uc2VIZWFkZXJzKHJlc3BvbnNlKTtcbiAgaWYgKCFwYXJzZWRSZXN1bHQuc3VjY2Vzcykge1xuICAgIHRocm93IG5ldyBBUElDYWxsRXJyb3IzKHtcbiAgICAgIG1lc3NhZ2U6IFwiSW52YWxpZCBKU09OIHJlc3BvbnNlXCIsXG4gICAgICBjYXVzZTogcGFyc2VkUmVzdWx0LmVycm9yLFxuICAgICAgc3RhdHVzQ29kZTogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgcmVzcG9uc2VCb2R5LFxuICAgICAgdXJsLFxuICAgICAgcmVxdWVzdEJvZHlWYWx1ZXNcbiAgICB9KTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICB2YWx1ZTogcGFyc2VkUmVzdWx0LnZhbHVlLFxuICAgIHJhd1ZhbHVlOiBwYXJzZWRSZXN1bHQucmF3VmFsdWVcbiAgfTtcbn07XG52YXIgY3JlYXRlQmluYXJ5UmVzcG9uc2VIYW5kbGVyID0gKCkgPT4gYXN5bmMgKHsgcmVzcG9uc2UsIHVybCwgcmVxdWVzdEJvZHlWYWx1ZXMgfSkgPT4ge1xuICBjb25zdCByZXNwb25zZUhlYWRlcnMgPSBleHRyYWN0UmVzcG9uc2VIZWFkZXJzKHJlc3BvbnNlKTtcbiAgaWYgKCFyZXNwb25zZS5ib2R5KSB7XG4gICAgdGhyb3cgbmV3IEFQSUNhbGxFcnJvcjMoe1xuICAgICAgbWVzc2FnZTogXCJSZXNwb25zZSBib2R5IGlzIGVtcHR5XCIsXG4gICAgICB1cmwsXG4gICAgICByZXF1ZXN0Qm9keVZhbHVlcyxcbiAgICAgIHN0YXR1c0NvZGU6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICAgIHJlc3BvbnNlQm9keTogdm9pZCAwXG4gICAgfSk7XG4gIH1cbiAgdHJ5IHtcbiAgICBjb25zdCBidWZmZXIgPSBhd2FpdCByZXNwb25zZS5hcnJheUJ1ZmZlcigpO1xuICAgIHJldHVybiB7XG4gICAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgICB2YWx1ZTogbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKVxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhyb3cgbmV3IEFQSUNhbGxFcnJvcjMoe1xuICAgICAgbWVzc2FnZTogXCJGYWlsZWQgdG8gcmVhZCByZXNwb25zZSBhcyBhcnJheSBidWZmZXJcIixcbiAgICAgIHVybCxcbiAgICAgIHJlcXVlc3RCb2R5VmFsdWVzLFxuICAgICAgc3RhdHVzQ29kZTogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgcmVzcG9uc2VCb2R5OiB2b2lkIDAsXG4gICAgICBjYXVzZTogZXJyb3JcbiAgICB9KTtcbiAgfVxufTtcbnZhciBjcmVhdGVTdGF0dXNDb2RlRXJyb3JSZXNwb25zZUhhbmRsZXIgPSAoKSA9PiBhc3luYyAoeyByZXNwb25zZSwgdXJsLCByZXF1ZXN0Qm9keVZhbHVlcyB9KSA9PiB7XG4gIGNvbnN0IHJlc3BvbnNlSGVhZGVycyA9IGV4dHJhY3RSZXNwb25zZUhlYWRlcnMocmVzcG9uc2UpO1xuICBjb25zdCByZXNwb25zZUJvZHkgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gIHJldHVybiB7XG4gICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgIHZhbHVlOiBuZXcgQVBJQ2FsbEVycm9yMyh7XG4gICAgICBtZXNzYWdlOiByZXNwb25zZS5zdGF0dXNUZXh0LFxuICAgICAgdXJsLFxuICAgICAgcmVxdWVzdEJvZHlWYWx1ZXMsXG4gICAgICBzdGF0dXNDb2RlOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgICByZXNwb25zZUJvZHlcbiAgICB9KVxuICB9O1xufTtcblxuLy8gc3JjL3VpbnQ4LXV0aWxzLnRzXG52YXIgeyBidG9hLCBhdG9iIH0gPSBnbG9iYWxUaGlzO1xuZnVuY3Rpb24gY29udmVydEJhc2U2NFRvVWludDhBcnJheShiYXNlNjRTdHJpbmcpIHtcbiAgY29uc3QgYmFzZTY0VXJsID0gYmFzZTY0U3RyaW5nLnJlcGxhY2UoLy0vZywgXCIrXCIpLnJlcGxhY2UoL18vZywgXCIvXCIpO1xuICBjb25zdCBsYXRpbjFzdHJpbmcgPSBhdG9iKGJhc2U2NFVybCk7XG4gIHJldHVybiBVaW50OEFycmF5LmZyb20obGF0aW4xc3RyaW5nLCAoYnl0ZSkgPT4gYnl0ZS5jb2RlUG9pbnRBdCgwKSk7XG59XG5mdW5jdGlvbiBjb252ZXJ0VWludDhBcnJheVRvQmFzZTY0KGFycmF5KSB7XG4gIGxldCBsYXRpbjFzdHJpbmcgPSBcIlwiO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgbGF0aW4xc3RyaW5nICs9IFN0cmluZy5mcm9tQ29kZVBvaW50KGFycmF5W2ldKTtcbiAgfVxuICByZXR1cm4gYnRvYShsYXRpbjFzdHJpbmcpO1xufVxuXG4vLyBzcmMvd2l0aG91dC10cmFpbGluZy1zbGFzaC50c1xuZnVuY3Rpb24gd2l0aG91dFRyYWlsaW5nU2xhc2godXJsKSB7XG4gIHJldHVybiB1cmwgPT0gbnVsbCA/IHZvaWQgMCA6IHVybC5yZXBsYWNlKC9cXC8kLywgXCJcIik7XG59XG5leHBvcnQge1xuICBhc1ZhbGlkYXRvcixcbiAgY29tYmluZUhlYWRlcnMsXG4gIGNvbnZlcnRBc3luY0l0ZXJhdG9yVG9SZWFkYWJsZVN0cmVhbSxcbiAgY29udmVydEJhc2U2NFRvVWludDhBcnJheSxcbiAgY29udmVydFVpbnQ4QXJyYXlUb0Jhc2U2NCxcbiAgY3JlYXRlQmluYXJ5UmVzcG9uc2VIYW5kbGVyLFxuICBjcmVhdGVFdmVudFNvdXJjZVBhcnNlclN0cmVhbSxcbiAgY3JlYXRlRXZlbnRTb3VyY2VSZXNwb25zZUhhbmRsZXIsXG4gIGNyZWF0ZUlkR2VuZXJhdG9yLFxuICBjcmVhdGVKc29uRXJyb3JSZXNwb25zZUhhbmRsZXIsXG4gIGNyZWF0ZUpzb25SZXNwb25zZUhhbmRsZXIsXG4gIGNyZWF0ZUpzb25TdHJlYW1SZXNwb25zZUhhbmRsZXIsXG4gIGNyZWF0ZVN0YXR1c0NvZGVFcnJvclJlc3BvbnNlSGFuZGxlcixcbiAgZGVsYXksXG4gIGV4dHJhY3RSZXNwb25zZUhlYWRlcnMsXG4gIGdlbmVyYXRlSWQsXG4gIGdldEVycm9yTWVzc2FnZSxcbiAgZ2V0RnJvbUFwaSxcbiAgaXNBYm9ydEVycm9yLFxuICBpc1BhcnNhYmxlSnNvbixcbiAgaXNWYWxpZGF0b3IsXG4gIGxvYWRBcGlLZXksXG4gIGxvYWRPcHRpb25hbFNldHRpbmcsXG4gIGxvYWRTZXR0aW5nLFxuICBwYXJzZUpTT04sXG4gIHBhcnNlUHJvdmlkZXJPcHRpb25zLFxuICBwb3N0Rm9ybURhdGFUb0FwaSxcbiAgcG9zdEpzb25Ub0FwaSxcbiAgcG9zdFRvQXBpLFxuICByZW1vdmVVbmRlZmluZWRFbnRyaWVzLFxuICByZXNvbHZlLFxuICBzYWZlUGFyc2VKU09OLFxuICBzYWZlVmFsaWRhdGVUeXBlcyxcbiAgdmFsaWRhdGVUeXBlcyxcbiAgdmFsaWRhdG9yLFxuICB2YWxpZGF0b3JTeW1ib2wsXG4gIHdpdGhvdXRUcmFpbGluZ1NsYXNoLFxuICB6b2RWYWxpZGF0b3Jcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@ai-sdk/provider-utils/dist/index.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@ai-sdk/provider/dist/index.mjs":
/*!******************************************************!*\
  !*** ./node_modules/@ai-sdk/provider/dist/index.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AISDKError: () => (/* binding */ AISDKError),\n/* harmony export */   APICallError: () => (/* binding */ APICallError),\n/* harmony export */   EmptyResponseBodyError: () => (/* binding */ EmptyResponseBodyError),\n/* harmony export */   InvalidArgumentError: () => (/* binding */ InvalidArgumentError),\n/* harmony export */   InvalidPromptError: () => (/* binding */ InvalidPromptError),\n/* harmony export */   InvalidResponseDataError: () => (/* binding */ InvalidResponseDataError),\n/* harmony export */   JSONParseError: () => (/* binding */ JSONParseError),\n/* harmony export */   LoadAPIKeyError: () => (/* binding */ LoadAPIKeyError),\n/* harmony export */   LoadSettingError: () => (/* binding */ LoadSettingError),\n/* harmony export */   NoContentGeneratedError: () => (/* binding */ NoContentGeneratedError),\n/* harmony export */   NoSuchModelError: () => (/* binding */ NoSuchModelError),\n/* harmony export */   TooManyEmbeddingValuesForCallError: () => (/* binding */ TooManyEmbeddingValuesForCallError),\n/* harmony export */   TypeValidationError: () => (/* binding */ TypeValidationError),\n/* harmony export */   UnsupportedFunctionalityError: () => (/* binding */ UnsupportedFunctionalityError),\n/* harmony export */   getErrorMessage: () => (/* binding */ getErrorMessage),\n/* harmony export */   isJSONArray: () => (/* binding */ isJSONArray),\n/* harmony export */   isJSONObject: () => (/* binding */ isJSONObject),\n/* harmony export */   isJSONValue: () => (/* binding */ isJSONValue)\n/* harmony export */ });\n// src/errors/ai-sdk-error.ts\nvar marker = \"vercel.ai.error\";\nvar symbol = Symbol.for(marker);\nvar _a;\nvar _AISDKError = class _AISDKError extends Error {\n  /**\n   * Creates an AI SDK Error.\n   *\n   * @param {Object} params - The parameters for creating the error.\n   * @param {string} params.name - The name of the error.\n   * @param {string} params.message - The error message.\n   * @param {unknown} [params.cause] - The underlying cause of the error.\n   */\n  constructor({\n    name: name14,\n    message,\n    cause\n  }) {\n    super(message);\n    this[_a] = true;\n    this.name = name14;\n    this.cause = cause;\n  }\n  /**\n   * Checks if the given error is an AI SDK Error.\n   * @param {unknown} error - The error to check.\n   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.\n   */\n  static isInstance(error) {\n    return _AISDKError.hasMarker(error, marker);\n  }\n  static hasMarker(error, marker15) {\n    const markerSymbol = Symbol.for(marker15);\n    return error != null && typeof error === \"object\" && markerSymbol in error && typeof error[markerSymbol] === \"boolean\" && error[markerSymbol] === true;\n  }\n};\n_a = symbol;\nvar AISDKError = _AISDKError;\n\n// src/errors/api-call-error.ts\nvar name = \"AI_APICallError\";\nvar marker2 = `vercel.ai.error.${name}`;\nvar symbol2 = Symbol.for(marker2);\nvar _a2;\nvar APICallError = class extends AISDKError {\n  constructor({\n    message,\n    url,\n    requestBodyValues,\n    statusCode,\n    responseHeaders,\n    responseBody,\n    cause,\n    isRetryable = statusCode != null && (statusCode === 408 || // request timeout\n    statusCode === 409 || // conflict\n    statusCode === 429 || // too many requests\n    statusCode >= 500),\n    // server error\n    data\n  }) {\n    super({ name, message, cause });\n    this[_a2] = true;\n    this.url = url;\n    this.requestBodyValues = requestBodyValues;\n    this.statusCode = statusCode;\n    this.responseHeaders = responseHeaders;\n    this.responseBody = responseBody;\n    this.isRetryable = isRetryable;\n    this.data = data;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker2);\n  }\n};\n_a2 = symbol2;\n\n// src/errors/empty-response-body-error.ts\nvar name2 = \"AI_EmptyResponseBodyError\";\nvar marker3 = `vercel.ai.error.${name2}`;\nvar symbol3 = Symbol.for(marker3);\nvar _a3;\nvar EmptyResponseBodyError = class extends AISDKError {\n  // used in isInstance\n  constructor({ message = \"Empty response body\" } = {}) {\n    super({ name: name2, message });\n    this[_a3] = true;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker3);\n  }\n};\n_a3 = symbol3;\n\n// src/errors/get-error-message.ts\nfunction getErrorMessage(error) {\n  if (error == null) {\n    return \"unknown error\";\n  }\n  if (typeof error === \"string\") {\n    return error;\n  }\n  if (error instanceof Error) {\n    return error.message;\n  }\n  return JSON.stringify(error);\n}\n\n// src/errors/invalid-argument-error.ts\nvar name3 = \"AI_InvalidArgumentError\";\nvar marker4 = `vercel.ai.error.${name3}`;\nvar symbol4 = Symbol.for(marker4);\nvar _a4;\nvar InvalidArgumentError = class extends AISDKError {\n  constructor({\n    message,\n    cause,\n    argument\n  }) {\n    super({ name: name3, message, cause });\n    this[_a4] = true;\n    this.argument = argument;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker4);\n  }\n};\n_a4 = symbol4;\n\n// src/errors/invalid-prompt-error.ts\nvar name4 = \"AI_InvalidPromptError\";\nvar marker5 = `vercel.ai.error.${name4}`;\nvar symbol5 = Symbol.for(marker5);\nvar _a5;\nvar InvalidPromptError = class extends AISDKError {\n  constructor({\n    prompt,\n    message,\n    cause\n  }) {\n    super({ name: name4, message: `Invalid prompt: ${message}`, cause });\n    this[_a5] = true;\n    this.prompt = prompt;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker5);\n  }\n};\n_a5 = symbol5;\n\n// src/errors/invalid-response-data-error.ts\nvar name5 = \"AI_InvalidResponseDataError\";\nvar marker6 = `vercel.ai.error.${name5}`;\nvar symbol6 = Symbol.for(marker6);\nvar _a6;\nvar InvalidResponseDataError = class extends AISDKError {\n  constructor({\n    data,\n    message = `Invalid response data: ${JSON.stringify(data)}.`\n  }) {\n    super({ name: name5, message });\n    this[_a6] = true;\n    this.data = data;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker6);\n  }\n};\n_a6 = symbol6;\n\n// src/errors/json-parse-error.ts\nvar name6 = \"AI_JSONParseError\";\nvar marker7 = `vercel.ai.error.${name6}`;\nvar symbol7 = Symbol.for(marker7);\nvar _a7;\nvar JSONParseError = class extends AISDKError {\n  constructor({ text, cause }) {\n    super({\n      name: name6,\n      message: `JSON parsing failed: Text: ${text}.\nError message: ${getErrorMessage(cause)}`,\n      cause\n    });\n    this[_a7] = true;\n    this.text = text;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker7);\n  }\n};\n_a7 = symbol7;\n\n// src/errors/load-api-key-error.ts\nvar name7 = \"AI_LoadAPIKeyError\";\nvar marker8 = `vercel.ai.error.${name7}`;\nvar symbol8 = Symbol.for(marker8);\nvar _a8;\nvar LoadAPIKeyError = class extends AISDKError {\n  // used in isInstance\n  constructor({ message }) {\n    super({ name: name7, message });\n    this[_a8] = true;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker8);\n  }\n};\n_a8 = symbol8;\n\n// src/errors/load-setting-error.ts\nvar name8 = \"AI_LoadSettingError\";\nvar marker9 = `vercel.ai.error.${name8}`;\nvar symbol9 = Symbol.for(marker9);\nvar _a9;\nvar LoadSettingError = class extends AISDKError {\n  // used in isInstance\n  constructor({ message }) {\n    super({ name: name8, message });\n    this[_a9] = true;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker9);\n  }\n};\n_a9 = symbol9;\n\n// src/errors/no-content-generated-error.ts\nvar name9 = \"AI_NoContentGeneratedError\";\nvar marker10 = `vercel.ai.error.${name9}`;\nvar symbol10 = Symbol.for(marker10);\nvar _a10;\nvar NoContentGeneratedError = class extends AISDKError {\n  // used in isInstance\n  constructor({\n    message = \"No content generated.\"\n  } = {}) {\n    super({ name: name9, message });\n    this[_a10] = true;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker10);\n  }\n};\n_a10 = symbol10;\n\n// src/errors/no-such-model-error.ts\nvar name10 = \"AI_NoSuchModelError\";\nvar marker11 = `vercel.ai.error.${name10}`;\nvar symbol11 = Symbol.for(marker11);\nvar _a11;\nvar NoSuchModelError = class extends AISDKError {\n  constructor({\n    errorName = name10,\n    modelId,\n    modelType,\n    message = `No such ${modelType}: ${modelId}`\n  }) {\n    super({ name: errorName, message });\n    this[_a11] = true;\n    this.modelId = modelId;\n    this.modelType = modelType;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker11);\n  }\n};\n_a11 = symbol11;\n\n// src/errors/too-many-embedding-values-for-call-error.ts\nvar name11 = \"AI_TooManyEmbeddingValuesForCallError\";\nvar marker12 = `vercel.ai.error.${name11}`;\nvar symbol12 = Symbol.for(marker12);\nvar _a12;\nvar TooManyEmbeddingValuesForCallError = class extends AISDKError {\n  constructor(options) {\n    super({\n      name: name11,\n      message: `Too many values for a single embedding call. The ${options.provider} model \"${options.modelId}\" can only embed up to ${options.maxEmbeddingsPerCall} values per call, but ${options.values.length} values were provided.`\n    });\n    this[_a12] = true;\n    this.provider = options.provider;\n    this.modelId = options.modelId;\n    this.maxEmbeddingsPerCall = options.maxEmbeddingsPerCall;\n    this.values = options.values;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker12);\n  }\n};\n_a12 = symbol12;\n\n// src/errors/type-validation-error.ts\nvar name12 = \"AI_TypeValidationError\";\nvar marker13 = `vercel.ai.error.${name12}`;\nvar symbol13 = Symbol.for(marker13);\nvar _a13;\nvar _TypeValidationError = class _TypeValidationError extends AISDKError {\n  constructor({ value, cause }) {\n    super({\n      name: name12,\n      message: `Type validation failed: Value: ${JSON.stringify(value)}.\nError message: ${getErrorMessage(cause)}`,\n      cause\n    });\n    this[_a13] = true;\n    this.value = value;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker13);\n  }\n  /**\n   * Wraps an error into a TypeValidationError.\n   * If the cause is already a TypeValidationError with the same value, it returns the cause.\n   * Otherwise, it creates a new TypeValidationError.\n   *\n   * @param {Object} params - The parameters for wrapping the error.\n   * @param {unknown} params.value - The value that failed validation.\n   * @param {unknown} params.cause - The original error or cause of the validation failure.\n   * @returns {TypeValidationError} A TypeValidationError instance.\n   */\n  static wrap({\n    value,\n    cause\n  }) {\n    return _TypeValidationError.isInstance(cause) && cause.value === value ? cause : new _TypeValidationError({ value, cause });\n  }\n};\n_a13 = symbol13;\nvar TypeValidationError = _TypeValidationError;\n\n// src/errors/unsupported-functionality-error.ts\nvar name13 = \"AI_UnsupportedFunctionalityError\";\nvar marker14 = `vercel.ai.error.${name13}`;\nvar symbol14 = Symbol.for(marker14);\nvar _a14;\nvar UnsupportedFunctionalityError = class extends AISDKError {\n  constructor({\n    functionality,\n    message = `'${functionality}' functionality not supported.`\n  }) {\n    super({ name: name13, message });\n    this[_a14] = true;\n    this.functionality = functionality;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker14);\n  }\n};\n_a14 = symbol14;\n\n// src/json-value/is-json.ts\nfunction isJSONValue(value) {\n  if (value === null || typeof value === \"string\" || typeof value === \"number\" || typeof value === \"boolean\") {\n    return true;\n  }\n  if (Array.isArray(value)) {\n    return value.every(isJSONValue);\n  }\n  if (typeof value === \"object\") {\n    return Object.entries(value).every(\n      ([key, val]) => typeof key === \"string\" && isJSONValue(val)\n    );\n  }\n  return false;\n}\nfunction isJSONArray(value) {\n  return Array.isArray(value) && value.every(isJSONValue);\n}\nfunction isJSONObject(value) {\n  return value != null && typeof value === \"object\" && Object.entries(value).every(\n    ([key, val]) => typeof key === \"string\" && isJSONValue(val)\n  );\n}\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGFpLXNkay9wcm92aWRlci9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlDQUFpQyxLQUFLO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsWUFBWSxzQkFBc0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUNBQWlDLE1BQU07QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0NBQWtDLElBQUk7QUFDdEQsWUFBWSxzQkFBc0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlDQUFpQyxNQUFNO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFlBQVksNkJBQTZCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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dWxlcy9AYWktc2RrL3Byb3ZpZGVyL2Rpc3QvaW5kZXgubWpzPzNhYjQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2Vycm9ycy9haS1zZGstZXJyb3IudHNcbnZhciBtYXJrZXIgPSBcInZlcmNlbC5haS5lcnJvclwiO1xudmFyIHN5bWJvbCA9IFN5bWJvbC5mb3IobWFya2VyKTtcbnZhciBfYTtcbnZhciBfQUlTREtFcnJvciA9IGNsYXNzIF9BSVNES0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAvKipcbiAgICogQ3JlYXRlcyBhbiBBSSBTREsgRXJyb3IuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgY3JlYXRpbmcgdGhlIGVycm9yLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLm5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZXJyb3IuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMubWVzc2FnZSAtIFRoZSBlcnJvciBtZXNzYWdlLlxuICAgKiBAcGFyYW0ge3Vua25vd259IFtwYXJhbXMuY2F1c2VdIC0gVGhlIHVuZGVybHlpbmcgY2F1c2Ugb2YgdGhlIGVycm9yLlxuICAgKi9cbiAgY29uc3RydWN0b3Ioe1xuICAgIG5hbWU6IG5hbWUxNCxcbiAgICBtZXNzYWdlLFxuICAgIGNhdXNlXG4gIH0pIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzW19hXSA9IHRydWU7XG4gICAgdGhpcy5uYW1lID0gbmFtZTE0O1xuICAgIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBlcnJvciBpcyBhbiBBSSBTREsgRXJyb3IuXG4gICAqIEBwYXJhbSB7dW5rbm93bn0gZXJyb3IgLSBUaGUgZXJyb3IgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBlcnJvciBpcyBhbiBBSSBTREsgRXJyb3IsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIF9BSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyKTtcbiAgfVxuICBzdGF0aWMgaGFzTWFya2VyKGVycm9yLCBtYXJrZXIxNSkge1xuICAgIGNvbnN0IG1hcmtlclN5bWJvbCA9IFN5bWJvbC5mb3IobWFya2VyMTUpO1xuICAgIHJldHVybiBlcnJvciAhPSBudWxsICYmIHR5cGVvZiBlcnJvciA9PT0gXCJvYmplY3RcIiAmJiBtYXJrZXJTeW1ib2wgaW4gZXJyb3IgJiYgdHlwZW9mIGVycm9yW21hcmtlclN5bWJvbF0gPT09IFwiYm9vbGVhblwiICYmIGVycm9yW21hcmtlclN5bWJvbF0gPT09IHRydWU7XG4gIH1cbn07XG5fYSA9IHN5bWJvbDtcbnZhciBBSVNES0Vycm9yID0gX0FJU0RLRXJyb3I7XG5cbi8vIHNyYy9lcnJvcnMvYXBpLWNhbGwtZXJyb3IudHNcbnZhciBuYW1lID0gXCJBSV9BUElDYWxsRXJyb3JcIjtcbnZhciBtYXJrZXIyID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWV9YDtcbnZhciBzeW1ib2wyID0gU3ltYm9sLmZvcihtYXJrZXIyKTtcbnZhciBfYTI7XG52YXIgQVBJQ2FsbEVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIG1lc3NhZ2UsXG4gICAgdXJsLFxuICAgIHJlcXVlc3RCb2R5VmFsdWVzLFxuICAgIHN0YXR1c0NvZGUsXG4gICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgIHJlc3BvbnNlQm9keSxcbiAgICBjYXVzZSxcbiAgICBpc1JldHJ5YWJsZSA9IHN0YXR1c0NvZGUgIT0gbnVsbCAmJiAoc3RhdHVzQ29kZSA9PT0gNDA4IHx8IC8vIHJlcXVlc3QgdGltZW91dFxuICAgIHN0YXR1c0NvZGUgPT09IDQwOSB8fCAvLyBjb25mbGljdFxuICAgIHN0YXR1c0NvZGUgPT09IDQyOSB8fCAvLyB0b28gbWFueSByZXF1ZXN0c1xuICAgIHN0YXR1c0NvZGUgPj0gNTAwKSxcbiAgICAvLyBzZXJ2ZXIgZXJyb3JcbiAgICBkYXRhXG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWUsIG1lc3NhZ2UsIGNhdXNlIH0pO1xuICAgIHRoaXNbX2EyXSA9IHRydWU7XG4gICAgdGhpcy51cmwgPSB1cmw7XG4gICAgdGhpcy5yZXF1ZXN0Qm9keVZhbHVlcyA9IHJlcXVlc3RCb2R5VmFsdWVzO1xuICAgIHRoaXMuc3RhdHVzQ29kZSA9IHN0YXR1c0NvZGU7XG4gICAgdGhpcy5yZXNwb25zZUhlYWRlcnMgPSByZXNwb25zZUhlYWRlcnM7XG4gICAgdGhpcy5yZXNwb25zZUJvZHkgPSByZXNwb25zZUJvZHk7XG4gICAgdGhpcy5pc1JldHJ5YWJsZSA9IGlzUmV0cnlhYmxlO1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvci5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjIpO1xuICB9XG59O1xuX2EyID0gc3ltYm9sMjtcblxuLy8gc3JjL2Vycm9ycy9lbXB0eS1yZXNwb25zZS1ib2R5LWVycm9yLnRzXG52YXIgbmFtZTIgPSBcIkFJX0VtcHR5UmVzcG9uc2VCb2R5RXJyb3JcIjtcbnZhciBtYXJrZXIzID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWUyfWA7XG52YXIgc3ltYm9sMyA9IFN5bWJvbC5mb3IobWFya2VyMyk7XG52YXIgX2EzO1xudmFyIEVtcHR5UmVzcG9uc2VCb2R5RXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3Ige1xuICAvLyB1c2VkIGluIGlzSW5zdGFuY2VcbiAgY29uc3RydWN0b3IoeyBtZXNzYWdlID0gXCJFbXB0eSByZXNwb25zZSBib2R5XCIgfSA9IHt9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lMiwgbWVzc2FnZSB9KTtcbiAgICB0aGlzW19hM10gPSB0cnVlO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIzKTtcbiAgfVxufTtcbl9hMyA9IHN5bWJvbDM7XG5cbi8vIHNyYy9lcnJvcnMvZ2V0LWVycm9yLW1lc3NhZ2UudHNcbmZ1bmN0aW9uIGdldEVycm9yTWVzc2FnZShlcnJvcikge1xuICBpZiAoZXJyb3IgPT0gbnVsbCkge1xuICAgIHJldHVybiBcInVua25vd24gZXJyb3JcIjtcbiAgfVxuICBpZiAodHlwZW9mIGVycm9yID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGVycm9yO1xuICB9XG4gIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yLm1lc3NhZ2U7XG4gIH1cbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGVycm9yKTtcbn1cblxuLy8gc3JjL2Vycm9ycy9pbnZhbGlkLWFyZ3VtZW50LWVycm9yLnRzXG52YXIgbmFtZTMgPSBcIkFJX0ludmFsaWRBcmd1bWVudEVycm9yXCI7XG52YXIgbWFya2VyNCA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lM31gO1xudmFyIHN5bWJvbDQgPSBTeW1ib2wuZm9yKG1hcmtlcjQpO1xudmFyIF9hNDtcbnZhciBJbnZhbGlkQXJndW1lbnRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBtZXNzYWdlLFxuICAgIGNhdXNlLFxuICAgIGFyZ3VtZW50XG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWUzLCBtZXNzYWdlLCBjYXVzZSB9KTtcbiAgICB0aGlzW19hNF0gPSB0cnVlO1xuICAgIHRoaXMuYXJndW1lbnQgPSBhcmd1bWVudDtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyNCk7XG4gIH1cbn07XG5fYTQgPSBzeW1ib2w0O1xuXG4vLyBzcmMvZXJyb3JzL2ludmFsaWQtcHJvbXB0LWVycm9yLnRzXG52YXIgbmFtZTQgPSBcIkFJX0ludmFsaWRQcm9tcHRFcnJvclwiO1xudmFyIG1hcmtlcjUgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTR9YDtcbnZhciBzeW1ib2w1ID0gU3ltYm9sLmZvcihtYXJrZXI1KTtcbnZhciBfYTU7XG52YXIgSW52YWxpZFByb21wdEVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHByb21wdCxcbiAgICBtZXNzYWdlLFxuICAgIGNhdXNlXG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWU0LCBtZXNzYWdlOiBgSW52YWxpZCBwcm9tcHQ6ICR7bWVzc2FnZX1gLCBjYXVzZSB9KTtcbiAgICB0aGlzW19hNV0gPSB0cnVlO1xuICAgIHRoaXMucHJvbXB0ID0gcHJvbXB0O1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXI1KTtcbiAgfVxufTtcbl9hNSA9IHN5bWJvbDU7XG5cbi8vIHNyYy9lcnJvcnMvaW52YWxpZC1yZXNwb25zZS1kYXRhLWVycm9yLnRzXG52YXIgbmFtZTUgPSBcIkFJX0ludmFsaWRSZXNwb25zZURhdGFFcnJvclwiO1xudmFyIG1hcmtlcjYgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTV9YDtcbnZhciBzeW1ib2w2ID0gU3ltYm9sLmZvcihtYXJrZXI2KTtcbnZhciBfYTY7XG52YXIgSW52YWxpZFJlc3BvbnNlRGF0YUVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGRhdGEsXG4gICAgbWVzc2FnZSA9IGBJbnZhbGlkIHJlc3BvbnNlIGRhdGE6ICR7SlNPTi5zdHJpbmdpZnkoZGF0YSl9LmBcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTUsIG1lc3NhZ2UgfSk7XG4gICAgdGhpc1tfYTZdID0gdHJ1ZTtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXI2KTtcbiAgfVxufTtcbl9hNiA9IHN5bWJvbDY7XG5cbi8vIHNyYy9lcnJvcnMvanNvbi1wYXJzZS1lcnJvci50c1xudmFyIG5hbWU2ID0gXCJBSV9KU09OUGFyc2VFcnJvclwiO1xudmFyIG1hcmtlcjcgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTZ9YDtcbnZhciBzeW1ib2w3ID0gU3ltYm9sLmZvcihtYXJrZXI3KTtcbnZhciBfYTc7XG52YXIgSlNPTlBhcnNlRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcih7IHRleHQsIGNhdXNlIH0pIHtcbiAgICBzdXBlcih7XG4gICAgICBuYW1lOiBuYW1lNixcbiAgICAgIG1lc3NhZ2U6IGBKU09OIHBhcnNpbmcgZmFpbGVkOiBUZXh0OiAke3RleHR9LlxuRXJyb3IgbWVzc2FnZTogJHtnZXRFcnJvck1lc3NhZ2UoY2F1c2UpfWAsXG4gICAgICBjYXVzZVxuICAgIH0pO1xuICAgIHRoaXNbX2E3XSA9IHRydWU7XG4gICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyNyk7XG4gIH1cbn07XG5fYTcgPSBzeW1ib2w3O1xuXG4vLyBzcmMvZXJyb3JzL2xvYWQtYXBpLWtleS1lcnJvci50c1xudmFyIG5hbWU3ID0gXCJBSV9Mb2FkQVBJS2V5RXJyb3JcIjtcbnZhciBtYXJrZXI4ID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWU3fWA7XG52YXIgc3ltYm9sOCA9IFN5bWJvbC5mb3IobWFya2VyOCk7XG52YXIgX2E4O1xudmFyIExvYWRBUElLZXlFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvciB7XG4gIC8vIHVzZWQgaW4gaXNJbnN0YW5jZVxuICBjb25zdHJ1Y3Rvcih7IG1lc3NhZ2UgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTcsIG1lc3NhZ2UgfSk7XG4gICAgdGhpc1tfYThdID0gdHJ1ZTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyOCk7XG4gIH1cbn07XG5fYTggPSBzeW1ib2w4O1xuXG4vLyBzcmMvZXJyb3JzL2xvYWQtc2V0dGluZy1lcnJvci50c1xudmFyIG5hbWU4ID0gXCJBSV9Mb2FkU2V0dGluZ0Vycm9yXCI7XG52YXIgbWFya2VyOSA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lOH1gO1xudmFyIHN5bWJvbDkgPSBTeW1ib2wuZm9yKG1hcmtlcjkpO1xudmFyIF9hOTtcbnZhciBMb2FkU2V0dGluZ0Vycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yIHtcbiAgLy8gdXNlZCBpbiBpc0luc3RhbmNlXG4gIGNvbnN0cnVjdG9yKHsgbWVzc2FnZSB9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lOCwgbWVzc2FnZSB9KTtcbiAgICB0aGlzW19hOV0gPSB0cnVlO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXI5KTtcbiAgfVxufTtcbl9hOSA9IHN5bWJvbDk7XG5cbi8vIHNyYy9lcnJvcnMvbm8tY29udGVudC1nZW5lcmF0ZWQtZXJyb3IudHNcbnZhciBuYW1lOSA9IFwiQUlfTm9Db250ZW50R2VuZXJhdGVkRXJyb3JcIjtcbnZhciBtYXJrZXIxMCA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lOX1gO1xudmFyIHN5bWJvbDEwID0gU3ltYm9sLmZvcihtYXJrZXIxMCk7XG52YXIgX2ExMDtcbnZhciBOb0NvbnRlbnRHZW5lcmF0ZWRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvciB7XG4gIC8vIHVzZWQgaW4gaXNJbnN0YW5jZVxuICBjb25zdHJ1Y3Rvcih7XG4gICAgbWVzc2FnZSA9IFwiTm8gY29udGVudCBnZW5lcmF0ZWQuXCJcbiAgfSA9IHt9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lOSwgbWVzc2FnZSB9KTtcbiAgICB0aGlzW19hMTBdID0gdHJ1ZTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyMTApO1xuICB9XG59O1xuX2ExMCA9IHN5bWJvbDEwO1xuXG4vLyBzcmMvZXJyb3JzL25vLXN1Y2gtbW9kZWwtZXJyb3IudHNcbnZhciBuYW1lMTAgPSBcIkFJX05vU3VjaE1vZGVsRXJyb3JcIjtcbnZhciBtYXJrZXIxMSA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lMTB9YDtcbnZhciBzeW1ib2wxMSA9IFN5bWJvbC5mb3IobWFya2VyMTEpO1xudmFyIF9hMTE7XG52YXIgTm9TdWNoTW9kZWxFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBlcnJvck5hbWUgPSBuYW1lMTAsXG4gICAgbW9kZWxJZCxcbiAgICBtb2RlbFR5cGUsXG4gICAgbWVzc2FnZSA9IGBObyBzdWNoICR7bW9kZWxUeXBlfTogJHttb2RlbElkfWBcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogZXJyb3JOYW1lLCBtZXNzYWdlIH0pO1xuICAgIHRoaXNbX2ExMV0gPSB0cnVlO1xuICAgIHRoaXMubW9kZWxJZCA9IG1vZGVsSWQ7XG4gICAgdGhpcy5tb2RlbFR5cGUgPSBtb2RlbFR5cGU7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvci5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjExKTtcbiAgfVxufTtcbl9hMTEgPSBzeW1ib2wxMTtcblxuLy8gc3JjL2Vycm9ycy90b28tbWFueS1lbWJlZGRpbmctdmFsdWVzLWZvci1jYWxsLWVycm9yLnRzXG52YXIgbmFtZTExID0gXCJBSV9Ub29NYW55RW1iZWRkaW5nVmFsdWVzRm9yQ2FsbEVycm9yXCI7XG52YXIgbWFya2VyMTIgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTExfWA7XG52YXIgc3ltYm9sMTIgPSBTeW1ib2wuZm9yKG1hcmtlcjEyKTtcbnZhciBfYTEyO1xudmFyIFRvb01hbnlFbWJlZGRpbmdWYWx1ZXNGb3JDYWxsRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIoe1xuICAgICAgbmFtZTogbmFtZTExLFxuICAgICAgbWVzc2FnZTogYFRvbyBtYW55IHZhbHVlcyBmb3IgYSBzaW5nbGUgZW1iZWRkaW5nIGNhbGwuIFRoZSAke29wdGlvbnMucHJvdmlkZXJ9IG1vZGVsIFwiJHtvcHRpb25zLm1vZGVsSWR9XCIgY2FuIG9ubHkgZW1iZWQgdXAgdG8gJHtvcHRpb25zLm1heEVtYmVkZGluZ3NQZXJDYWxsfSB2YWx1ZXMgcGVyIGNhbGwsIGJ1dCAke29wdGlvbnMudmFsdWVzLmxlbmd0aH0gdmFsdWVzIHdlcmUgcHJvdmlkZWQuYFxuICAgIH0pO1xuICAgIHRoaXNbX2ExMl0gPSB0cnVlO1xuICAgIHRoaXMucHJvdmlkZXIgPSBvcHRpb25zLnByb3ZpZGVyO1xuICAgIHRoaXMubW9kZWxJZCA9IG9wdGlvbnMubW9kZWxJZDtcbiAgICB0aGlzLm1heEVtYmVkZGluZ3NQZXJDYWxsID0gb3B0aW9ucy5tYXhFbWJlZGRpbmdzUGVyQ2FsbDtcbiAgICB0aGlzLnZhbHVlcyA9IG9wdGlvbnMudmFsdWVzO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIxMik7XG4gIH1cbn07XG5fYTEyID0gc3ltYm9sMTI7XG5cbi8vIHNyYy9lcnJvcnMvdHlwZS12YWxpZGF0aW9uLWVycm9yLnRzXG52YXIgbmFtZTEyID0gXCJBSV9UeXBlVmFsaWRhdGlvbkVycm9yXCI7XG52YXIgbWFya2VyMTMgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTEyfWA7XG52YXIgc3ltYm9sMTMgPSBTeW1ib2wuZm9yKG1hcmtlcjEzKTtcbnZhciBfYTEzO1xudmFyIF9UeXBlVmFsaWRhdGlvbkVycm9yID0gY2xhc3MgX1R5cGVWYWxpZGF0aW9uRXJyb3IgZXh0ZW5kcyBBSVNES0Vycm9yIHtcbiAgY29uc3RydWN0b3IoeyB2YWx1ZSwgY2F1c2UgfSkge1xuICAgIHN1cGVyKHtcbiAgICAgIG5hbWU6IG5hbWUxMixcbiAgICAgIG1lc3NhZ2U6IGBUeXBlIHZhbGlkYXRpb24gZmFpbGVkOiBWYWx1ZTogJHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9LlxuRXJyb3IgbWVzc2FnZTogJHtnZXRFcnJvck1lc3NhZ2UoY2F1c2UpfWAsXG4gICAgICBjYXVzZVxuICAgIH0pO1xuICAgIHRoaXNbX2ExM10gPSB0cnVlO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyMTMpO1xuICB9XG4gIC8qKlxuICAgKiBXcmFwcyBhbiBlcnJvciBpbnRvIGEgVHlwZVZhbGlkYXRpb25FcnJvci5cbiAgICogSWYgdGhlIGNhdXNlIGlzIGFscmVhZHkgYSBUeXBlVmFsaWRhdGlvbkVycm9yIHdpdGggdGhlIHNhbWUgdmFsdWUsIGl0IHJldHVybnMgdGhlIGNhdXNlLlxuICAgKiBPdGhlcndpc2UsIGl0IGNyZWF0ZXMgYSBuZXcgVHlwZVZhbGlkYXRpb25FcnJvci5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB3cmFwcGluZyB0aGUgZXJyb3IuXG4gICAqIEBwYXJhbSB7dW5rbm93bn0gcGFyYW1zLnZhbHVlIC0gVGhlIHZhbHVlIHRoYXQgZmFpbGVkIHZhbGlkYXRpb24uXG4gICAqIEBwYXJhbSB7dW5rbm93bn0gcGFyYW1zLmNhdXNlIC0gVGhlIG9yaWdpbmFsIGVycm9yIG9yIGNhdXNlIG9mIHRoZSB2YWxpZGF0aW9uIGZhaWx1cmUuXG4gICAqIEByZXR1cm5zIHtUeXBlVmFsaWRhdGlvbkVycm9yfSBBIFR5cGVWYWxpZGF0aW9uRXJyb3IgaW5zdGFuY2UuXG4gICAqL1xuICBzdGF0aWMgd3JhcCh7XG4gICAgdmFsdWUsXG4gICAgY2F1c2VcbiAgfSkge1xuICAgIHJldHVybiBfVHlwZVZhbGlkYXRpb25FcnJvci5pc0luc3RhbmNlKGNhdXNlKSAmJiBjYXVzZS52YWx1ZSA9PT0gdmFsdWUgPyBjYXVzZSA6IG5ldyBfVHlwZVZhbGlkYXRpb25FcnJvcih7IHZhbHVlLCBjYXVzZSB9KTtcbiAgfVxufTtcbl9hMTMgPSBzeW1ib2wxMztcbnZhciBUeXBlVmFsaWRhdGlvbkVycm9yID0gX1R5cGVWYWxpZGF0aW9uRXJyb3I7XG5cbi8vIHNyYy9lcnJvcnMvdW5zdXBwb3J0ZWQtZnVuY3Rpb25hbGl0eS1lcnJvci50c1xudmFyIG5hbWUxMyA9IFwiQUlfVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3JcIjtcbnZhciBtYXJrZXIxNCA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lMTN9YDtcbnZhciBzeW1ib2wxNCA9IFN5bWJvbC5mb3IobWFya2VyMTQpO1xudmFyIF9hMTQ7XG52YXIgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgZnVuY3Rpb25hbGl0eSxcbiAgICBtZXNzYWdlID0gYCcke2Z1bmN0aW9uYWxpdHl9JyBmdW5jdGlvbmFsaXR5IG5vdCBzdXBwb3J0ZWQuYFxuICB9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lMTMsIG1lc3NhZ2UgfSk7XG4gICAgdGhpc1tfYTE0XSA9IHRydWU7XG4gICAgdGhpcy5mdW5jdGlvbmFsaXR5ID0gZnVuY3Rpb25hbGl0eTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyMTQpO1xuICB9XG59O1xuX2ExNCA9IHN5bWJvbDE0O1xuXG4vLyBzcmMvanNvbi12YWx1ZS9pcy1qc29uLnRzXG5mdW5jdGlvbiBpc0pTT05WYWx1ZSh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlLmV2ZXJ5KGlzSlNPTlZhbHVlKTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHZhbHVlKS5ldmVyeShcbiAgICAgIChba2V5LCB2YWxdKSA9PiB0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiICYmIGlzSlNPTlZhbHVlKHZhbClcbiAgICApO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzSlNPTkFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5ldmVyeShpc0pTT05WYWx1ZSk7XG59XG5mdW5jdGlvbiBpc0pTT05PYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIE9iamVjdC5lbnRyaWVzKHZhbHVlKS5ldmVyeShcbiAgICAoW2tleSwgdmFsXSkgPT4gdHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIiAmJiBpc0pTT05WYWx1ZSh2YWwpXG4gICk7XG59XG5leHBvcnQge1xuICBBSVNES0Vycm9yLFxuICBBUElDYWxsRXJyb3IsXG4gIEVtcHR5UmVzcG9uc2VCb2R5RXJyb3IsXG4gIEludmFsaWRBcmd1bWVudEVycm9yLFxuICBJbnZhbGlkUHJvbXB0RXJyb3IsXG4gIEludmFsaWRSZXNwb25zZURhdGFFcnJvcixcbiAgSlNPTlBhcnNlRXJyb3IsXG4gIExvYWRBUElLZXlFcnJvcixcbiAgTG9hZFNldHRpbmdFcnJvcixcbiAgTm9Db250ZW50R2VuZXJhdGVkRXJyb3IsXG4gIE5vU3VjaE1vZGVsRXJyb3IsXG4gIFRvb01hbnlFbWJlZGRpbmdWYWx1ZXNGb3JDYWxsRXJyb3IsXG4gIFR5cGVWYWxpZGF0aW9uRXJyb3IsXG4gIFVuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yLFxuICBnZXRFcnJvck1lc3NhZ2UsXG4gIGlzSlNPTkFycmF5LFxuICBpc0pTT05PYmplY3QsXG4gIGlzSlNPTlZhbHVlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@ai-sdk/provider/dist/index.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@ai-sdk/ui-utils/dist/index.mjs":
/*!******************************************************!*\
  !*** ./node_modules/@ai-sdk/ui-utils/dist/index.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   asSchema: () => (/* binding */ asSchema),\n/* harmony export */   callChatApi: () => (/* binding */ callChatApi),\n/* harmony export */   callCompletionApi: () => (/* binding */ callCompletionApi),\n/* harmony export */   extractMaxToolInvocationStep: () => (/* binding */ extractMaxToolInvocationStep),\n/* harmony export */   fillMessageParts: () => (/* binding */ fillMessageParts),\n/* harmony export */   formatAssistantStreamPart: () => (/* binding */ formatAssistantStreamPart),\n/* harmony export */   formatDataStreamPart: () => (/* binding */ formatDataStreamPart),\n/* harmony export */   generateId: () => (/* reexport safe */ _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.generateId),\n/* harmony export */   getMessageParts: () => (/* binding */ getMessageParts),\n/* harmony export */   getTextFromDataUrl: () => (/* binding */ getTextFromDataUrl),\n/* harmony export */   isAssistantMessageWithCompletedToolCalls: () => (/* binding */ isAssistantMessageWithCompletedToolCalls),\n/* harmony export */   isDeepEqualData: () => (/* binding */ isDeepEqualData),\n/* harmony export */   jsonSchema: () => (/* binding */ jsonSchema),\n/* harmony export */   parseAssistantStreamPart: () => (/* binding */ parseAssistantStreamPart),\n/* harmony export */   parseDataStreamPart: () => (/* binding */ parseDataStreamPart),\n/* harmony export */   parsePartialJson: () => (/* binding */ parsePartialJson),\n/* harmony export */   prepareAttachmentsForRequest: () => (/* binding */ prepareAttachmentsForRequest),\n/* harmony export */   processAssistantStream: () => (/* binding */ processAssistantStream),\n/* harmony export */   processDataStream: () => (/* binding */ processDataStream),\n/* harmony export */   processTextStream: () => (/* binding */ processTextStream),\n/* harmony export */   shouldResubmitMessages: () => (/* binding */ shouldResubmitMessages),\n/* harmony export */   updateToolCallResult: () => (/* binding */ updateToolCallResult),\n/* harmony export */   zodSchema: () => (/* binding */ zodSchema)\n/* harmony export */ });\n/* harmony import */ var _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ai-sdk/provider-utils */ \"(rsc)/./node_modules/@ai-sdk/provider-utils/dist/index.mjs\");\n/* harmony import */ var zod_to_json_schema__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zod-to-json-schema */ \"(rsc)/./node_modules/zod-to-json-schema/dist/esm/index.js\");\n// src/index.ts\n\n\n// src/assistant-stream-parts.ts\nvar textStreamPart = {\n  code: \"0\",\n  name: \"text\",\n  parse: (value) => {\n    if (typeof value !== \"string\") {\n      throw new Error('\"text\" parts expect a string value.');\n    }\n    return { type: \"text\", value };\n  }\n};\nvar errorStreamPart = {\n  code: \"3\",\n  name: \"error\",\n  parse: (value) => {\n    if (typeof value !== \"string\") {\n      throw new Error('\"error\" parts expect a string value.');\n    }\n    return { type: \"error\", value };\n  }\n};\nvar assistantMessageStreamPart = {\n  code: \"4\",\n  name: \"assistant_message\",\n  parse: (value) => {\n    if (value == null || typeof value !== \"object\" || !(\"id\" in value) || !(\"role\" in value) || !(\"content\" in value) || typeof value.id !== \"string\" || typeof value.role !== \"string\" || value.role !== \"assistant\" || !Array.isArray(value.content) || !value.content.every(\n      (item) => item != null && typeof item === \"object\" && \"type\" in item && item.type === \"text\" && \"text\" in item && item.text != null && typeof item.text === \"object\" && \"value\" in item.text && typeof item.text.value === \"string\"\n    )) {\n      throw new Error(\n        '\"assistant_message\" parts expect an object with an \"id\", \"role\", and \"content\" property.'\n      );\n    }\n    return {\n      type: \"assistant_message\",\n      value\n    };\n  }\n};\nvar assistantControlDataStreamPart = {\n  code: \"5\",\n  name: \"assistant_control_data\",\n  parse: (value) => {\n    if (value == null || typeof value !== \"object\" || !(\"threadId\" in value) || !(\"messageId\" in value) || typeof value.threadId !== \"string\" || typeof value.messageId !== \"string\") {\n      throw new Error(\n        '\"assistant_control_data\" parts expect an object with a \"threadId\" and \"messageId\" property.'\n      );\n    }\n    return {\n      type: \"assistant_control_data\",\n      value: {\n        threadId: value.threadId,\n        messageId: value.messageId\n      }\n    };\n  }\n};\nvar dataMessageStreamPart = {\n  code: \"6\",\n  name: \"data_message\",\n  parse: (value) => {\n    if (value == null || typeof value !== \"object\" || !(\"role\" in value) || !(\"data\" in value) || typeof value.role !== \"string\" || value.role !== \"data\") {\n      throw new Error(\n        '\"data_message\" parts expect an object with a \"role\" and \"data\" property.'\n      );\n    }\n    return {\n      type: \"data_message\",\n      value\n    };\n  }\n};\nvar assistantStreamParts = [\n  textStreamPart,\n  errorStreamPart,\n  assistantMessageStreamPart,\n  assistantControlDataStreamPart,\n  dataMessageStreamPart\n];\nvar assistantStreamPartsByCode = {\n  [textStreamPart.code]: textStreamPart,\n  [errorStreamPart.code]: errorStreamPart,\n  [assistantMessageStreamPart.code]: assistantMessageStreamPart,\n  [assistantControlDataStreamPart.code]: assistantControlDataStreamPart,\n  [dataMessageStreamPart.code]: dataMessageStreamPart\n};\nvar StreamStringPrefixes = {\n  [textStreamPart.name]: textStreamPart.code,\n  [errorStreamPart.name]: errorStreamPart.code,\n  [assistantMessageStreamPart.name]: assistantMessageStreamPart.code,\n  [assistantControlDataStreamPart.name]: assistantControlDataStreamPart.code,\n  [dataMessageStreamPart.name]: dataMessageStreamPart.code\n};\nvar validCodes = assistantStreamParts.map((part) => part.code);\nvar parseAssistantStreamPart = (line) => {\n  const firstSeparatorIndex = line.indexOf(\":\");\n  if (firstSeparatorIndex === -1) {\n    throw new Error(\"Failed to parse stream string. No separator found.\");\n  }\n  const prefix = line.slice(0, firstSeparatorIndex);\n  if (!validCodes.includes(prefix)) {\n    throw new Error(`Failed to parse stream string. Invalid code ${prefix}.`);\n  }\n  const code = prefix;\n  const textValue = line.slice(firstSeparatorIndex + 1);\n  const jsonValue = JSON.parse(textValue);\n  return assistantStreamPartsByCode[code].parse(jsonValue);\n};\nfunction formatAssistantStreamPart(type, value) {\n  const streamPart = assistantStreamParts.find((part) => part.name === type);\n  if (!streamPart) {\n    throw new Error(`Invalid stream part type: ${type}`);\n  }\n  return `${streamPart.code}:${JSON.stringify(value)}\n`;\n}\n\n// src/process-chat-response.ts\n\n\n// src/duplicated/usage.ts\nfunction calculateLanguageModelUsage({\n  promptTokens,\n  completionTokens\n}) {\n  return {\n    promptTokens,\n    completionTokens,\n    totalTokens: promptTokens + completionTokens\n  };\n}\n\n// src/parse-partial-json.ts\n\n\n// src/fix-json.ts\nfunction fixJson(input) {\n  const stack = [\"ROOT\"];\n  let lastValidIndex = -1;\n  let literalStart = null;\n  function processValueStart(char, i, swapState) {\n    {\n      switch (char) {\n        case '\"': {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_STRING\");\n          break;\n        }\n        case \"f\":\n        case \"t\":\n        case \"n\": {\n          lastValidIndex = i;\n          literalStart = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_LITERAL\");\n          break;\n        }\n        case \"-\": {\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_NUMBER\");\n          break;\n        }\n        case \"0\":\n        case \"1\":\n        case \"2\":\n        case \"3\":\n        case \"4\":\n        case \"5\":\n        case \"6\":\n        case \"7\":\n        case \"8\":\n        case \"9\": {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_NUMBER\");\n          break;\n        }\n        case \"{\": {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_OBJECT_START\");\n          break;\n        }\n        case \"[\": {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_ARRAY_START\");\n          break;\n        }\n      }\n    }\n  }\n  function processAfterObjectValue(char, i) {\n    switch (char) {\n      case \",\": {\n        stack.pop();\n        stack.push(\"INSIDE_OBJECT_AFTER_COMMA\");\n        break;\n      }\n      case \"}\": {\n        lastValidIndex = i;\n        stack.pop();\n        break;\n      }\n    }\n  }\n  function processAfterArrayValue(char, i) {\n    switch (char) {\n      case \",\": {\n        stack.pop();\n        stack.push(\"INSIDE_ARRAY_AFTER_COMMA\");\n        break;\n      }\n      case \"]\": {\n        lastValidIndex = i;\n        stack.pop();\n        break;\n      }\n    }\n  }\n  for (let i = 0; i < input.length; i++) {\n    const char = input[i];\n    const currentState = stack[stack.length - 1];\n    switch (currentState) {\n      case \"ROOT\":\n        processValueStart(char, i, \"FINISH\");\n        break;\n      case \"INSIDE_OBJECT_START\": {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            stack.push(\"INSIDE_OBJECT_KEY\");\n            break;\n          }\n          case \"}\": {\n            lastValidIndex = i;\n            stack.pop();\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_OBJECT_AFTER_COMMA\": {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            stack.push(\"INSIDE_OBJECT_KEY\");\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_OBJECT_KEY\": {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            stack.push(\"INSIDE_OBJECT_AFTER_KEY\");\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_OBJECT_AFTER_KEY\": {\n        switch (char) {\n          case \":\": {\n            stack.pop();\n            stack.push(\"INSIDE_OBJECT_BEFORE_VALUE\");\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_OBJECT_BEFORE_VALUE\": {\n        processValueStart(char, i, \"INSIDE_OBJECT_AFTER_VALUE\");\n        break;\n      }\n      case \"INSIDE_OBJECT_AFTER_VALUE\": {\n        processAfterObjectValue(char, i);\n        break;\n      }\n      case \"INSIDE_STRING\": {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            lastValidIndex = i;\n            break;\n          }\n          case \"\\\\\": {\n            stack.push(\"INSIDE_STRING_ESCAPE\");\n            break;\n          }\n          default: {\n            lastValidIndex = i;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_ARRAY_START\": {\n        switch (char) {\n          case \"]\": {\n            lastValidIndex = i;\n            stack.pop();\n            break;\n          }\n          default: {\n            lastValidIndex = i;\n            processValueStart(char, i, \"INSIDE_ARRAY_AFTER_VALUE\");\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_ARRAY_AFTER_VALUE\": {\n        switch (char) {\n          case \",\": {\n            stack.pop();\n            stack.push(\"INSIDE_ARRAY_AFTER_COMMA\");\n            break;\n          }\n          case \"]\": {\n            lastValidIndex = i;\n            stack.pop();\n            break;\n          }\n          default: {\n            lastValidIndex = i;\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_ARRAY_AFTER_COMMA\": {\n        processValueStart(char, i, \"INSIDE_ARRAY_AFTER_VALUE\");\n        break;\n      }\n      case \"INSIDE_STRING_ESCAPE\": {\n        stack.pop();\n        lastValidIndex = i;\n        break;\n      }\n      case \"INSIDE_NUMBER\": {\n        switch (char) {\n          case \"0\":\n          case \"1\":\n          case \"2\":\n          case \"3\":\n          case \"4\":\n          case \"5\":\n          case \"6\":\n          case \"7\":\n          case \"8\":\n          case \"9\": {\n            lastValidIndex = i;\n            break;\n          }\n          case \"e\":\n          case \"E\":\n          case \"-\":\n          case \".\": {\n            break;\n          }\n          case \",\": {\n            stack.pop();\n            if (stack[stack.length - 1] === \"INSIDE_ARRAY_AFTER_VALUE\") {\n              processAfterArrayValue(char, i);\n            }\n            if (stack[stack.length - 1] === \"INSIDE_OBJECT_AFTER_VALUE\") {\n              processAfterObjectValue(char, i);\n            }\n            break;\n          }\n          case \"}\": {\n            stack.pop();\n            if (stack[stack.length - 1] === \"INSIDE_OBJECT_AFTER_VALUE\") {\n              processAfterObjectValue(char, i);\n            }\n            break;\n          }\n          case \"]\": {\n            stack.pop();\n            if (stack[stack.length - 1] === \"INSIDE_ARRAY_AFTER_VALUE\") {\n              processAfterArrayValue(char, i);\n            }\n            break;\n          }\n          default: {\n            stack.pop();\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_LITERAL\": {\n        const partialLiteral = input.substring(literalStart, i + 1);\n        if (!\"false\".startsWith(partialLiteral) && !\"true\".startsWith(partialLiteral) && !\"null\".startsWith(partialLiteral)) {\n          stack.pop();\n          if (stack[stack.length - 1] === \"INSIDE_OBJECT_AFTER_VALUE\") {\n            processAfterObjectValue(char, i);\n          } else if (stack[stack.length - 1] === \"INSIDE_ARRAY_AFTER_VALUE\") {\n            processAfterArrayValue(char, i);\n          }\n        } else {\n          lastValidIndex = i;\n        }\n        break;\n      }\n    }\n  }\n  let result = input.slice(0, lastValidIndex + 1);\n  for (let i = stack.length - 1; i >= 0; i--) {\n    const state = stack[i];\n    switch (state) {\n      case \"INSIDE_STRING\": {\n        result += '\"';\n        break;\n      }\n      case \"INSIDE_OBJECT_KEY\":\n      case \"INSIDE_OBJECT_AFTER_KEY\":\n      case \"INSIDE_OBJECT_AFTER_COMMA\":\n      case \"INSIDE_OBJECT_START\":\n      case \"INSIDE_OBJECT_BEFORE_VALUE\":\n      case \"INSIDE_OBJECT_AFTER_VALUE\": {\n        result += \"}\";\n        break;\n      }\n      case \"INSIDE_ARRAY_START\":\n      case \"INSIDE_ARRAY_AFTER_COMMA\":\n      case \"INSIDE_ARRAY_AFTER_VALUE\": {\n        result += \"]\";\n        break;\n      }\n      case \"INSIDE_LITERAL\": {\n        const partialLiteral = input.substring(literalStart, input.length);\n        if (\"true\".startsWith(partialLiteral)) {\n          result += \"true\".slice(partialLiteral.length);\n        } else if (\"false\".startsWith(partialLiteral)) {\n          result += \"false\".slice(partialLiteral.length);\n        } else if (\"null\".startsWith(partialLiteral)) {\n          result += \"null\".slice(partialLiteral.length);\n        }\n      }\n    }\n  }\n  return result;\n}\n\n// src/parse-partial-json.ts\nfunction parsePartialJson(jsonText) {\n  if (jsonText === void 0) {\n    return { value: void 0, state: \"undefined-input\" };\n  }\n  let result = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.safeParseJSON)({ text: jsonText });\n  if (result.success) {\n    return { value: result.value, state: \"successful-parse\" };\n  }\n  result = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.safeParseJSON)({ text: fixJson(jsonText) });\n  if (result.success) {\n    return { value: result.value, state: \"repaired-parse\" };\n  }\n  return { value: void 0, state: \"failed-parse\" };\n}\n\n// src/data-stream-parts.ts\nvar textStreamPart2 = {\n  code: \"0\",\n  name: \"text\",\n  parse: (value) => {\n    if (typeof value !== \"string\") {\n      throw new Error('\"text\" parts expect a string value.');\n    }\n    return { type: \"text\", value };\n  }\n};\nvar dataStreamPart = {\n  code: \"2\",\n  name: \"data\",\n  parse: (value) => {\n    if (!Array.isArray(value)) {\n      throw new Error('\"data\" parts expect an array value.');\n    }\n    return { type: \"data\", value };\n  }\n};\nvar errorStreamPart2 = {\n  code: \"3\",\n  name: \"error\",\n  parse: (value) => {\n    if (typeof value !== \"string\") {\n      throw new Error('\"error\" parts expect a string value.');\n    }\n    return { type: \"error\", value };\n  }\n};\nvar messageAnnotationsStreamPart = {\n  code: \"8\",\n  name: \"message_annotations\",\n  parse: (value) => {\n    if (!Array.isArray(value)) {\n      throw new Error('\"message_annotations\" parts expect an array value.');\n    }\n    return { type: \"message_annotations\", value };\n  }\n};\nvar toolCallStreamPart = {\n  code: \"9\",\n  name: \"tool_call\",\n  parse: (value) => {\n    if (value == null || typeof value !== \"object\" || !(\"toolCallId\" in value) || typeof value.toolCallId !== \"string\" || !(\"toolName\" in value) || typeof value.toolName !== \"string\" || !(\"args\" in value) || typeof value.args !== \"object\") {\n      throw new Error(\n        '\"tool_call\" parts expect an object with a \"toolCallId\", \"toolName\", and \"args\" property.'\n      );\n    }\n    return {\n      type: \"tool_call\",\n      value\n    };\n  }\n};\nvar toolResultStreamPart = {\n  code: \"a\",\n  name: \"tool_result\",\n  parse: (value) => {\n    if (value == null || typeof value !== \"object\" || !(\"toolCallId\" in value) || typeof value.toolCallId !== \"string\" || !(\"result\" in value)) {\n      throw new Error(\n        '\"tool_result\" parts expect an object with a \"toolCallId\" and a \"result\" property.'\n      );\n    }\n    return {\n      type: \"tool_result\",\n      value\n    };\n  }\n};\nvar toolCallStreamingStartStreamPart = {\n  code: \"b\",\n  name: \"tool_call_streaming_start\",\n  parse: (value) => {\n    if (value == null || typeof value !== \"object\" || !(\"toolCallId\" in value) || typeof value.toolCallId !== \"string\" || !(\"toolName\" in value) || typeof value.toolName !== \"string\") {\n      throw new Error(\n        '\"tool_call_streaming_start\" parts expect an object with a \"toolCallId\" and \"toolName\" property.'\n      );\n    }\n    return {\n      type: \"tool_call_streaming_start\",\n      value\n    };\n  }\n};\nvar toolCallDeltaStreamPart = {\n  code: \"c\",\n  name: \"tool_call_delta\",\n  parse: (value) => {\n    if (value == null || typeof value !== \"object\" || !(\"toolCallId\" in value) || typeof value.toolCallId !== \"string\" || !(\"argsTextDelta\" in value) || typeof value.argsTextDelta !== \"string\") {\n      throw new Error(\n        '\"tool_call_delta\" parts expect an object with a \"toolCallId\" and \"argsTextDelta\" property.'\n      );\n    }\n    return {\n      type: \"tool_call_delta\",\n      value\n    };\n  }\n};\nvar finishMessageStreamPart = {\n  code: \"d\",\n  name: \"finish_message\",\n  parse: (value) => {\n    if (value == null || typeof value !== \"object\" || !(\"finishReason\" in value) || typeof value.finishReason !== \"string\") {\n      throw new Error(\n        '\"finish_message\" parts expect an object with a \"finishReason\" property.'\n      );\n    }\n    const result = {\n      finishReason: value.finishReason\n    };\n    if (\"usage\" in value && value.usage != null && typeof value.usage === \"object\" && \"promptTokens\" in value.usage && \"completionTokens\" in value.usage) {\n      result.usage = {\n        promptTokens: typeof value.usage.promptTokens === \"number\" ? value.usage.promptTokens : Number.NaN,\n        completionTokens: typeof value.usage.completionTokens === \"number\" ? value.usage.completionTokens : Number.NaN\n      };\n    }\n    return {\n      type: \"finish_message\",\n      value: result\n    };\n  }\n};\nvar finishStepStreamPart = {\n  code: \"e\",\n  name: \"finish_step\",\n  parse: (value) => {\n    if (value == null || typeof value !== \"object\" || !(\"finishReason\" in value) || typeof value.finishReason !== \"string\") {\n      throw new Error(\n        '\"finish_step\" parts expect an object with a \"finishReason\" property.'\n      );\n    }\n    const result = {\n      finishReason: value.finishReason,\n      isContinued: false\n    };\n    if (\"usage\" in value && value.usage != null && typeof value.usage === \"object\" && \"promptTokens\" in value.usage && \"completionTokens\" in value.usage) {\n      result.usage = {\n        promptTokens: typeof value.usage.promptTokens === \"number\" ? value.usage.promptTokens : Number.NaN,\n        completionTokens: typeof value.usage.completionTokens === \"number\" ? value.usage.completionTokens : Number.NaN\n      };\n    }\n    if (\"isContinued\" in value && typeof value.isContinued === \"boolean\") {\n      result.isContinued = value.isContinued;\n    }\n    return {\n      type: \"finish_step\",\n      value: result\n    };\n  }\n};\nvar startStepStreamPart = {\n  code: \"f\",\n  name: \"start_step\",\n  parse: (value) => {\n    if (value == null || typeof value !== \"object\" || !(\"messageId\" in value) || typeof value.messageId !== \"string\") {\n      throw new Error(\n        '\"start_step\" parts expect an object with an \"id\" property.'\n      );\n    }\n    return {\n      type: \"start_step\",\n      value: {\n        messageId: value.messageId\n      }\n    };\n  }\n};\nvar reasoningStreamPart = {\n  code: \"g\",\n  name: \"reasoning\",\n  parse: (value) => {\n    if (typeof value !== \"string\") {\n      throw new Error('\"reasoning\" parts expect a string value.');\n    }\n    return { type: \"reasoning\", value };\n  }\n};\nvar sourcePart = {\n  code: \"h\",\n  name: \"source\",\n  parse: (value) => {\n    if (value == null || typeof value !== \"object\") {\n      throw new Error('\"source\" parts expect a Source object.');\n    }\n    return {\n      type: \"source\",\n      value\n    };\n  }\n};\nvar redactedReasoningStreamPart = {\n  code: \"i\",\n  name: \"redacted_reasoning\",\n  parse: (value) => {\n    if (value == null || typeof value !== \"object\" || !(\"data\" in value) || typeof value.data !== \"string\") {\n      throw new Error(\n        '\"redacted_reasoning\" parts expect an object with a \"data\" property.'\n      );\n    }\n    return { type: \"redacted_reasoning\", value: { data: value.data } };\n  }\n};\nvar reasoningSignatureStreamPart = {\n  code: \"j\",\n  name: \"reasoning_signature\",\n  parse: (value) => {\n    if (value == null || typeof value !== \"object\" || !(\"signature\" in value) || typeof value.signature !== \"string\") {\n      throw new Error(\n        '\"reasoning_signature\" parts expect an object with a \"signature\" property.'\n      );\n    }\n    return {\n      type: \"reasoning_signature\",\n      value: { signature: value.signature }\n    };\n  }\n};\nvar fileStreamPart = {\n  code: \"k\",\n  name: \"file\",\n  parse: (value) => {\n    if (value == null || typeof value !== \"object\" || !(\"data\" in value) || typeof value.data !== \"string\" || !(\"mimeType\" in value) || typeof value.mimeType !== \"string\") {\n      throw new Error(\n        '\"file\" parts expect an object with a \"data\" and \"mimeType\" property.'\n      );\n    }\n    return { type: \"file\", value };\n  }\n};\nvar dataStreamParts = [\n  textStreamPart2,\n  dataStreamPart,\n  errorStreamPart2,\n  messageAnnotationsStreamPart,\n  toolCallStreamPart,\n  toolResultStreamPart,\n  toolCallStreamingStartStreamPart,\n  toolCallDeltaStreamPart,\n  finishMessageStreamPart,\n  finishStepStreamPart,\n  startStepStreamPart,\n  reasoningStreamPart,\n  sourcePart,\n  redactedReasoningStreamPart,\n  reasoningSignatureStreamPart,\n  fileStreamPart\n];\nvar dataStreamPartsByCode = Object.fromEntries(\n  dataStreamParts.map((part) => [part.code, part])\n);\nvar DataStreamStringPrefixes = Object.fromEntries(\n  dataStreamParts.map((part) => [part.name, part.code])\n);\nvar validCodes2 = dataStreamParts.map((part) => part.code);\nvar parseDataStreamPart = (line) => {\n  const firstSeparatorIndex = line.indexOf(\":\");\n  if (firstSeparatorIndex === -1) {\n    throw new Error(\"Failed to parse stream string. No separator found.\");\n  }\n  const prefix = line.slice(0, firstSeparatorIndex);\n  if (!validCodes2.includes(prefix)) {\n    throw new Error(`Failed to parse stream string. Invalid code ${prefix}.`);\n  }\n  const code = prefix;\n  const textValue = line.slice(firstSeparatorIndex + 1);\n  const jsonValue = JSON.parse(textValue);\n  return dataStreamPartsByCode[code].parse(jsonValue);\n};\nfunction formatDataStreamPart(type, value) {\n  const streamPart = dataStreamParts.find((part) => part.name === type);\n  if (!streamPart) {\n    throw new Error(`Invalid stream part type: ${type}`);\n  }\n  return `${streamPart.code}:${JSON.stringify(value)}\n`;\n}\n\n// src/process-data-stream.ts\nvar NEWLINE = \"\\n\".charCodeAt(0);\nfunction concatChunks(chunks, totalLength) {\n  const concatenatedChunks = new Uint8Array(totalLength);\n  let offset = 0;\n  for (const chunk of chunks) {\n    concatenatedChunks.set(chunk, offset);\n    offset += chunk.length;\n  }\n  chunks.length = 0;\n  return concatenatedChunks;\n}\nasync function processDataStream({\n  stream,\n  onTextPart,\n  onReasoningPart,\n  onReasoningSignaturePart,\n  onRedactedReasoningPart,\n  onSourcePart,\n  onFilePart,\n  onDataPart,\n  onErrorPart,\n  onToolCallStreamingStartPart,\n  onToolCallDeltaPart,\n  onToolCallPart,\n  onToolResultPart,\n  onMessageAnnotationsPart,\n  onFinishMessagePart,\n  onFinishStepPart,\n  onStartStepPart\n}) {\n  const reader = stream.getReader();\n  const decoder = new TextDecoder();\n  const chunks = [];\n  let totalLength = 0;\n  while (true) {\n    const { value } = await reader.read();\n    if (value) {\n      chunks.push(value);\n      totalLength += value.length;\n      if (value[value.length - 1] !== NEWLINE) {\n        continue;\n      }\n    }\n    if (chunks.length === 0) {\n      break;\n    }\n    const concatenatedChunks = concatChunks(chunks, totalLength);\n    totalLength = 0;\n    const streamParts = decoder.decode(concatenatedChunks, { stream: true }).split(\"\\n\").filter((line) => line !== \"\").map(parseDataStreamPart);\n    for (const { type, value: value2 } of streamParts) {\n      switch (type) {\n        case \"text\":\n          await (onTextPart == null ? void 0 : onTextPart(value2));\n          break;\n        case \"reasoning\":\n          await (onReasoningPart == null ? void 0 : onReasoningPart(value2));\n          break;\n        case \"reasoning_signature\":\n          await (onReasoningSignaturePart == null ? void 0 : onReasoningSignaturePart(value2));\n          break;\n        case \"redacted_reasoning\":\n          await (onRedactedReasoningPart == null ? void 0 : onRedactedReasoningPart(value2));\n          break;\n        case \"file\":\n          await (onFilePart == null ? void 0 : onFilePart(value2));\n          break;\n        case \"source\":\n          await (onSourcePart == null ? void 0 : onSourcePart(value2));\n          break;\n        case \"data\":\n          await (onDataPart == null ? void 0 : onDataPart(value2));\n          break;\n        case \"error\":\n          await (onErrorPart == null ? void 0 : onErrorPart(value2));\n          break;\n        case \"message_annotations\":\n          await (onMessageAnnotationsPart == null ? void 0 : onMessageAnnotationsPart(value2));\n          break;\n        case \"tool_call_streaming_start\":\n          await (onToolCallStreamingStartPart == null ? void 0 : onToolCallStreamingStartPart(value2));\n          break;\n        case \"tool_call_delta\":\n          await (onToolCallDeltaPart == null ? void 0 : onToolCallDeltaPart(value2));\n          break;\n        case \"tool_call\":\n          await (onToolCallPart == null ? void 0 : onToolCallPart(value2));\n          break;\n        case \"tool_result\":\n          await (onToolResultPart == null ? void 0 : onToolResultPart(value2));\n          break;\n        case \"finish_message\":\n          await (onFinishMessagePart == null ? void 0 : onFinishMessagePart(value2));\n          break;\n        case \"finish_step\":\n          await (onFinishStepPart == null ? void 0 : onFinishStepPart(value2));\n          break;\n        case \"start_step\":\n          await (onStartStepPart == null ? void 0 : onStartStepPart(value2));\n          break;\n        default: {\n          const exhaustiveCheck = type;\n          throw new Error(`Unknown stream part type: ${exhaustiveCheck}`);\n        }\n      }\n    }\n  }\n}\n\n// src/process-chat-response.ts\nasync function processChatResponse({\n  stream,\n  update,\n  onToolCall,\n  onFinish,\n  generateId: generateId2 = _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.generateId,\n  getCurrentDate = () => /* @__PURE__ */ new Date(),\n  lastMessage\n}) {\n  var _a, _b;\n  const replaceLastMessage = (lastMessage == null ? void 0 : lastMessage.role) === \"assistant\";\n  let step = replaceLastMessage ? 1 + // find max step in existing tool invocations:\n  ((_b = (_a = lastMessage.toolInvocations) == null ? void 0 : _a.reduce((max, toolInvocation) => {\n    var _a2;\n    return Math.max(max, (_a2 = toolInvocation.step) != null ? _a2 : 0);\n  }, 0)) != null ? _b : 0) : 0;\n  const message = replaceLastMessage ? structuredClone(lastMessage) : {\n    id: generateId2(),\n    createdAt: getCurrentDate(),\n    role: \"assistant\",\n    content: \"\",\n    parts: []\n  };\n  let currentTextPart = void 0;\n  let currentReasoningPart = void 0;\n  let currentReasoningTextDetail = void 0;\n  function updateToolInvocationPart(toolCallId, invocation) {\n    const part = message.parts.find(\n      (part2) => part2.type === \"tool-invocation\" && part2.toolInvocation.toolCallId === toolCallId\n    );\n    if (part != null) {\n      part.toolInvocation = invocation;\n    } else {\n      message.parts.push({\n        type: \"tool-invocation\",\n        toolInvocation: invocation\n      });\n    }\n  }\n  const data = [];\n  let messageAnnotations = replaceLastMessage ? lastMessage == null ? void 0 : lastMessage.annotations : void 0;\n  const partialToolCalls = {};\n  let usage = {\n    completionTokens: NaN,\n    promptTokens: NaN,\n    totalTokens: NaN\n  };\n  let finishReason = \"unknown\";\n  function execUpdate() {\n    const copiedData = [...data];\n    if (messageAnnotations == null ? void 0 : messageAnnotations.length) {\n      message.annotations = messageAnnotations;\n    }\n    const copiedMessage = {\n      // deep copy the message to ensure that deep changes (msg attachments) are updated\n      // with SolidJS. SolidJS uses referential integration of sub-objects to detect changes.\n      ...structuredClone(message),\n      // add a revision id to ensure that the message is updated with SWR. SWR uses a\n      // hashing approach by default to detect changes, but it only works for shallow\n      // changes. This is why we need to add a revision id to ensure that the message\n      // is updated with SWR (without it, the changes get stuck in SWR and are not\n      // forwarded to rendering):\n      revisionId: generateId2()\n    };\n    update({\n      message: copiedMessage,\n      data: copiedData,\n      replaceLastMessage\n    });\n  }\n  await processDataStream({\n    stream,\n    onTextPart(value) {\n      if (currentTextPart == null) {\n        currentTextPart = {\n          type: \"text\",\n          text: value\n        };\n        message.parts.push(currentTextPart);\n      } else {\n        currentTextPart.text += value;\n      }\n      message.content += value;\n      execUpdate();\n    },\n    onReasoningPart(value) {\n      var _a2;\n      if (currentReasoningTextDetail == null) {\n        currentReasoningTextDetail = { type: \"text\", text: value };\n        if (currentReasoningPart != null) {\n          currentReasoningPart.details.push(currentReasoningTextDetail);\n        }\n      } else {\n        currentReasoningTextDetail.text += value;\n      }\n      if (currentReasoningPart == null) {\n        currentReasoningPart = {\n          type: \"reasoning\",\n          reasoning: value,\n          details: [currentReasoningTextDetail]\n        };\n        message.parts.push(currentReasoningPart);\n      } else {\n        currentReasoningPart.reasoning += value;\n      }\n      message.reasoning = ((_a2 = message.reasoning) != null ? _a2 : \"\") + value;\n      execUpdate();\n    },\n    onReasoningSignaturePart(value) {\n      if (currentReasoningTextDetail != null) {\n        currentReasoningTextDetail.signature = value.signature;\n      }\n    },\n    onRedactedReasoningPart(value) {\n      if (currentReasoningPart == null) {\n        currentReasoningPart = {\n          type: \"reasoning\",\n          reasoning: \"\",\n          details: []\n        };\n        message.parts.push(currentReasoningPart);\n      }\n      currentReasoningPart.details.push({\n        type: \"redacted\",\n        data: value.data\n      });\n      currentReasoningTextDetail = void 0;\n      execUpdate();\n    },\n    onFilePart(value) {\n      message.parts.push({\n        type: \"file\",\n        mimeType: value.mimeType,\n        data: value.data\n      });\n      execUpdate();\n    },\n    onSourcePart(value) {\n      message.parts.push({\n        type: \"source\",\n        source: value\n      });\n      execUpdate();\n    },\n    onToolCallStreamingStartPart(value) {\n      if (message.toolInvocations == null) {\n        message.toolInvocations = [];\n      }\n      partialToolCalls[value.toolCallId] = {\n        text: \"\",\n        step,\n        toolName: value.toolName,\n        index: message.toolInvocations.length\n      };\n      const invocation = {\n        state: \"partial-call\",\n        step,\n        toolCallId: value.toolCallId,\n        toolName: value.toolName,\n        args: void 0\n      };\n      message.toolInvocations.push(invocation);\n      updateToolInvocationPart(value.toolCallId, invocation);\n      execUpdate();\n    },\n    onToolCallDeltaPart(value) {\n      const partialToolCall = partialToolCalls[value.toolCallId];\n      partialToolCall.text += value.argsTextDelta;\n      const { value: partialArgs } = parsePartialJson(partialToolCall.text);\n      const invocation = {\n        state: \"partial-call\",\n        step: partialToolCall.step,\n        toolCallId: value.toolCallId,\n        toolName: partialToolCall.toolName,\n        args: partialArgs\n      };\n      message.toolInvocations[partialToolCall.index] = invocation;\n      updateToolInvocationPart(value.toolCallId, invocation);\n      execUpdate();\n    },\n    async onToolCallPart(value) {\n      const invocation = {\n        state: \"call\",\n        step,\n        ...value\n      };\n      if (partialToolCalls[value.toolCallId] != null) {\n        message.toolInvocations[partialToolCalls[value.toolCallId].index] = invocation;\n      } else {\n        if (message.toolInvocations == null) {\n          message.toolInvocations = [];\n        }\n        message.toolInvocations.push(invocation);\n      }\n      updateToolInvocationPart(value.toolCallId, invocation);\n      execUpdate();\n      if (onToolCall) {\n        const result = await onToolCall({ toolCall: value });\n        if (result != null) {\n          const invocation2 = {\n            state: \"result\",\n            step,\n            ...value,\n            result\n          };\n          message.toolInvocations[message.toolInvocations.length - 1] = invocation2;\n          updateToolInvocationPart(value.toolCallId, invocation2);\n          execUpdate();\n        }\n      }\n    },\n    onToolResultPart(value) {\n      const toolInvocations = message.toolInvocations;\n      if (toolInvocations == null) {\n        throw new Error(\"tool_result must be preceded by a tool_call\");\n      }\n      const toolInvocationIndex = toolInvocations.findIndex(\n        (invocation2) => invocation2.toolCallId === value.toolCallId\n      );\n      if (toolInvocationIndex === -1) {\n        throw new Error(\n          \"tool_result must be preceded by a tool_call with the same toolCallId\"\n        );\n      }\n      const invocation = {\n        ...toolInvocations[toolInvocationIndex],\n        state: \"result\",\n        ...value\n      };\n      toolInvocations[toolInvocationIndex] = invocation;\n      updateToolInvocationPart(value.toolCallId, invocation);\n      execUpdate();\n    },\n    onDataPart(value) {\n      data.push(...value);\n      execUpdate();\n    },\n    onMessageAnnotationsPart(value) {\n      if (messageAnnotations == null) {\n        messageAnnotations = [...value];\n      } else {\n        messageAnnotations.push(...value);\n      }\n      execUpdate();\n    },\n    onFinishStepPart(value) {\n      step += 1;\n      currentTextPart = value.isContinued ? currentTextPart : void 0;\n      currentReasoningPart = void 0;\n      currentReasoningTextDetail = void 0;\n    },\n    onStartStepPart(value) {\n      if (!replaceLastMessage) {\n        message.id = value.messageId;\n      }\n      message.parts.push({ type: \"step-start\" });\n      execUpdate();\n    },\n    onFinishMessagePart(value) {\n      finishReason = value.finishReason;\n      if (value.usage != null) {\n        usage = calculateLanguageModelUsage(value.usage);\n      }\n    },\n    onErrorPart(error) {\n      throw new Error(error);\n    }\n  });\n  onFinish == null ? void 0 : onFinish({ message, finishReason, usage });\n}\n\n// src/process-chat-text-response.ts\n\n\n// src/process-text-stream.ts\nasync function processTextStream({\n  stream,\n  onTextPart\n}) {\n  const reader = stream.pipeThrough(new TextDecoderStream()).getReader();\n  while (true) {\n    const { done, value } = await reader.read();\n    if (done) {\n      break;\n    }\n    await onTextPart(value);\n  }\n}\n\n// src/process-chat-text-response.ts\nasync function processChatTextResponse({\n  stream,\n  update,\n  onFinish,\n  getCurrentDate = () => /* @__PURE__ */ new Date(),\n  generateId: generateId2 = _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.generateId\n}) {\n  const textPart = { type: \"text\", text: \"\" };\n  const resultMessage = {\n    id: generateId2(),\n    createdAt: getCurrentDate(),\n    role: \"assistant\",\n    content: \"\",\n    parts: [textPart]\n  };\n  await processTextStream({\n    stream,\n    onTextPart: (chunk) => {\n      resultMessage.content += chunk;\n      textPart.text += chunk;\n      update({\n        message: { ...resultMessage },\n        data: [],\n        replaceLastMessage: false\n      });\n    }\n  });\n  onFinish == null ? void 0 : onFinish(resultMessage, {\n    usage: { completionTokens: NaN, promptTokens: NaN, totalTokens: NaN },\n    finishReason: \"unknown\"\n  });\n}\n\n// src/call-chat-api.ts\nvar getOriginalFetch = () => fetch;\nasync function callChatApi({\n  api,\n  body,\n  streamProtocol = \"data\",\n  credentials,\n  headers,\n  abortController,\n  restoreMessagesOnFailure,\n  onResponse,\n  onUpdate,\n  onFinish,\n  onToolCall,\n  generateId: generateId2,\n  fetch: fetch2 = getOriginalFetch(),\n  lastMessage\n}) {\n  var _a, _b;\n  const response = await fetch2(api, {\n    method: \"POST\",\n    body: JSON.stringify(body),\n    headers: {\n      \"Content-Type\": \"application/json\",\n      ...headers\n    },\n    signal: (_a = abortController == null ? void 0 : abortController()) == null ? void 0 : _a.signal,\n    credentials\n  }).catch((err) => {\n    restoreMessagesOnFailure();\n    throw err;\n  });\n  if (onResponse) {\n    try {\n      await onResponse(response);\n    } catch (err) {\n      throw err;\n    }\n  }\n  if (!response.ok) {\n    restoreMessagesOnFailure();\n    throw new Error(\n      (_b = await response.text()) != null ? _b : \"Failed to fetch the chat response.\"\n    );\n  }\n  if (!response.body) {\n    throw new Error(\"The response body is empty.\");\n  }\n  switch (streamProtocol) {\n    case \"text\": {\n      await processChatTextResponse({\n        stream: response.body,\n        update: onUpdate,\n        onFinish,\n        generateId: generateId2\n      });\n      return;\n    }\n    case \"data\": {\n      await processChatResponse({\n        stream: response.body,\n        update: onUpdate,\n        lastMessage,\n        onToolCall,\n        onFinish({ message, finishReason, usage }) {\n          if (onFinish && message != null) {\n            onFinish(message, { usage, finishReason });\n          }\n        },\n        generateId: generateId2\n      });\n      return;\n    }\n    default: {\n      const exhaustiveCheck = streamProtocol;\n      throw new Error(`Unknown stream protocol: ${exhaustiveCheck}`);\n    }\n  }\n}\n\n// src/call-completion-api.ts\nvar getOriginalFetch2 = () => fetch;\nasync function callCompletionApi({\n  api,\n  prompt,\n  credentials,\n  headers,\n  body,\n  streamProtocol = \"data\",\n  setCompletion,\n  setLoading,\n  setError,\n  setAbortController,\n  onResponse,\n  onFinish,\n  onError,\n  onData,\n  fetch: fetch2 = getOriginalFetch2()\n}) {\n  var _a;\n  try {\n    setLoading(true);\n    setError(void 0);\n    const abortController = new AbortController();\n    setAbortController(abortController);\n    setCompletion(\"\");\n    const response = await fetch2(api, {\n      method: \"POST\",\n      body: JSON.stringify({\n        prompt,\n        ...body\n      }),\n      credentials,\n      headers: {\n        \"Content-Type\": \"application/json\",\n        ...headers\n      },\n      signal: abortController.signal\n    }).catch((err) => {\n      throw err;\n    });\n    if (onResponse) {\n      try {\n        await onResponse(response);\n      } catch (err) {\n        throw err;\n      }\n    }\n    if (!response.ok) {\n      throw new Error(\n        (_a = await response.text()) != null ? _a : \"Failed to fetch the chat response.\"\n      );\n    }\n    if (!response.body) {\n      throw new Error(\"The response body is empty.\");\n    }\n    let result = \"\";\n    switch (streamProtocol) {\n      case \"text\": {\n        await processTextStream({\n          stream: response.body,\n          onTextPart: (chunk) => {\n            result += chunk;\n            setCompletion(result);\n          }\n        });\n        break;\n      }\n      case \"data\": {\n        await processDataStream({\n          stream: response.body,\n          onTextPart(value) {\n            result += value;\n            setCompletion(result);\n          },\n          onDataPart(value) {\n            onData == null ? void 0 : onData(value);\n          },\n          onErrorPart(value) {\n            throw new Error(value);\n          }\n        });\n        break;\n      }\n      default: {\n        const exhaustiveCheck = streamProtocol;\n        throw new Error(`Unknown stream protocol: ${exhaustiveCheck}`);\n      }\n    }\n    if (onFinish) {\n      onFinish(prompt, result);\n    }\n    setAbortController(null);\n    return result;\n  } catch (err) {\n    if (err.name === \"AbortError\") {\n      setAbortController(null);\n      return null;\n    }\n    if (err instanceof Error) {\n      if (onError) {\n        onError(err);\n      }\n    }\n    setError(err);\n  } finally {\n    setLoading(false);\n  }\n}\n\n// src/data-url.ts\nfunction getTextFromDataUrl(dataUrl) {\n  const [header, base64Content] = dataUrl.split(\",\");\n  const mimeType = header.split(\";\")[0].split(\":\")[1];\n  if (mimeType == null || base64Content == null) {\n    throw new Error(\"Invalid data URL format\");\n  }\n  try {\n    return window.atob(base64Content);\n  } catch (error) {\n    throw new Error(`Error decoding data URL`);\n  }\n}\n\n// src/extract-max-tool-invocation-step.ts\nfunction extractMaxToolInvocationStep(toolInvocations) {\n  return toolInvocations == null ? void 0 : toolInvocations.reduce((max, toolInvocation) => {\n    var _a;\n    return Math.max(max, (_a = toolInvocation.step) != null ? _a : 0);\n  }, 0);\n}\n\n// src/get-message-parts.ts\nfunction getMessageParts(message) {\n  var _a;\n  return (_a = message.parts) != null ? _a : [\n    ...message.toolInvocations ? message.toolInvocations.map((toolInvocation) => ({\n      type: \"tool-invocation\",\n      toolInvocation\n    })) : [],\n    ...message.reasoning ? [\n      {\n        type: \"reasoning\",\n        reasoning: message.reasoning,\n        details: [{ type: \"text\", text: message.reasoning }]\n      }\n    ] : [],\n    ...message.content ? [{ type: \"text\", text: message.content }] : []\n  ];\n}\n\n// src/fill-message-parts.ts\nfunction fillMessageParts(messages) {\n  return messages.map((message) => ({\n    ...message,\n    parts: getMessageParts(message)\n  }));\n}\n\n// src/is-deep-equal-data.ts\nfunction isDeepEqualData(obj1, obj2) {\n  if (obj1 === obj2)\n    return true;\n  if (obj1 == null || obj2 == null)\n    return false;\n  if (typeof obj1 !== \"object\" && typeof obj2 !== \"object\")\n    return obj1 === obj2;\n  if (obj1.constructor !== obj2.constructor)\n    return false;\n  if (obj1 instanceof Date && obj2 instanceof Date) {\n    return obj1.getTime() === obj2.getTime();\n  }\n  if (Array.isArray(obj1)) {\n    if (obj1.length !== obj2.length)\n      return false;\n    for (let i = 0; i < obj1.length; i++) {\n      if (!isDeepEqualData(obj1[i], obj2[i]))\n        return false;\n    }\n    return true;\n  }\n  const keys1 = Object.keys(obj1);\n  const keys2 = Object.keys(obj2);\n  if (keys1.length !== keys2.length)\n    return false;\n  for (const key of keys1) {\n    if (!keys2.includes(key))\n      return false;\n    if (!isDeepEqualData(obj1[key], obj2[key]))\n      return false;\n  }\n  return true;\n}\n\n// src/prepare-attachments-for-request.ts\nasync function prepareAttachmentsForRequest(attachmentsFromOptions) {\n  if (!attachmentsFromOptions) {\n    return [];\n  }\n  if (attachmentsFromOptions instanceof FileList) {\n    return Promise.all(\n      Array.from(attachmentsFromOptions).map(async (attachment) => {\n        const { name, type } = attachment;\n        const dataUrl = await new Promise((resolve, reject) => {\n          const reader = new FileReader();\n          reader.onload = (readerEvent) => {\n            var _a;\n            resolve((_a = readerEvent.target) == null ? void 0 : _a.result);\n          };\n          reader.onerror = (error) => reject(error);\n          reader.readAsDataURL(attachment);\n        });\n        return {\n          name,\n          contentType: type,\n          url: dataUrl\n        };\n      })\n    );\n  }\n  if (Array.isArray(attachmentsFromOptions)) {\n    return attachmentsFromOptions;\n  }\n  throw new Error(\"Invalid attachments type\");\n}\n\n// src/process-assistant-stream.ts\nvar NEWLINE2 = \"\\n\".charCodeAt(0);\nfunction concatChunks2(chunks, totalLength) {\n  const concatenatedChunks = new Uint8Array(totalLength);\n  let offset = 0;\n  for (const chunk of chunks) {\n    concatenatedChunks.set(chunk, offset);\n    offset += chunk.length;\n  }\n  chunks.length = 0;\n  return concatenatedChunks;\n}\nasync function processAssistantStream({\n  stream,\n  onTextPart,\n  onErrorPart,\n  onAssistantMessagePart,\n  onAssistantControlDataPart,\n  onDataMessagePart\n}) {\n  const reader = stream.getReader();\n  const decoder = new TextDecoder();\n  const chunks = [];\n  let totalLength = 0;\n  while (true) {\n    const { value } = await reader.read();\n    if (value) {\n      chunks.push(value);\n      totalLength += value.length;\n      if (value[value.length - 1] !== NEWLINE2) {\n        continue;\n      }\n    }\n    if (chunks.length === 0) {\n      break;\n    }\n    const concatenatedChunks = concatChunks2(chunks, totalLength);\n    totalLength = 0;\n    const streamParts = decoder.decode(concatenatedChunks, { stream: true }).split(\"\\n\").filter((line) => line !== \"\").map(parseAssistantStreamPart);\n    for (const { type, value: value2 } of streamParts) {\n      switch (type) {\n        case \"text\":\n          await (onTextPart == null ? void 0 : onTextPart(value2));\n          break;\n        case \"error\":\n          await (onErrorPart == null ? void 0 : onErrorPart(value2));\n          break;\n        case \"assistant_message\":\n          await (onAssistantMessagePart == null ? void 0 : onAssistantMessagePart(value2));\n          break;\n        case \"assistant_control_data\":\n          await (onAssistantControlDataPart == null ? void 0 : onAssistantControlDataPart(value2));\n          break;\n        case \"data_message\":\n          await (onDataMessagePart == null ? void 0 : onDataMessagePart(value2));\n          break;\n        default: {\n          const exhaustiveCheck = type;\n          throw new Error(`Unknown stream part type: ${exhaustiveCheck}`);\n        }\n      }\n    }\n  }\n}\n\n// src/schema.ts\n\n\n// src/zod-schema.ts\n\nfunction zodSchema(zodSchema2, options) {\n  var _a;\n  const useReferences = (_a = options == null ? void 0 : options.useReferences) != null ? _a : false;\n  return jsonSchema(\n    (0,zod_to_json_schema__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(zodSchema2, {\n      $refStrategy: useReferences ? \"root\" : \"none\",\n      target: \"jsonSchema7\"\n      // note: openai mode breaks various gemini conversions\n    }),\n    {\n      validate: (value) => {\n        const result = zodSchema2.safeParse(value);\n        return result.success ? { success: true, value: result.data } : { success: false, error: result.error };\n      }\n    }\n  );\n}\n\n// src/schema.ts\nvar schemaSymbol = Symbol.for(\"vercel.ai.schema\");\nfunction jsonSchema(jsonSchema2, {\n  validate\n} = {}) {\n  return {\n    [schemaSymbol]: true,\n    _type: void 0,\n    // should never be used directly\n    [_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.validatorSymbol]: true,\n    jsonSchema: jsonSchema2,\n    validate\n  };\n}\nfunction isSchema(value) {\n  return typeof value === \"object\" && value !== null && schemaSymbol in value && value[schemaSymbol] === true && \"jsonSchema\" in value && \"validate\" in value;\n}\nfunction asSchema(schema) {\n  return isSchema(schema) ? schema : zodSchema(schema);\n}\n\n// src/should-resubmit-messages.ts\nfunction shouldResubmitMessages({\n  originalMaxToolInvocationStep,\n  originalMessageCount,\n  maxSteps,\n  messages\n}) {\n  var _a;\n  const lastMessage = messages[messages.length - 1];\n  return (\n    // check if the feature is enabled:\n    maxSteps > 1 && // ensure there is a last message:\n    lastMessage != null && // ensure we actually have new steps (to prevent infinite loops in case of errors):\n    (messages.length > originalMessageCount || extractMaxToolInvocationStep(lastMessage.toolInvocations) !== originalMaxToolInvocationStep) && // check that next step is possible:\n    isAssistantMessageWithCompletedToolCalls(lastMessage) && // limit the number of automatic steps:\n    ((_a = extractMaxToolInvocationStep(lastMessage.toolInvocations)) != null ? _a : 0) < maxSteps\n  );\n}\nfunction isAssistantMessageWithCompletedToolCalls(message) {\n  if (message.role !== \"assistant\") {\n    return false;\n  }\n  const lastStepStartIndex = message.parts.reduce((lastIndex, part, index) => {\n    return part.type === \"step-start\" ? index : lastIndex;\n  }, -1);\n  const lastStepToolInvocations = message.parts.slice(lastStepStartIndex + 1).filter((part) => part.type === \"tool-invocation\");\n  return lastStepToolInvocations.length > 0 && lastStepToolInvocations.every((part) => \"result\" in part.toolInvocation);\n}\n\n// src/update-tool-call-result.ts\nfunction updateToolCallResult({\n  messages,\n  toolCallId,\n  toolResult: result\n}) {\n  var _a;\n  const lastMessage = messages[messages.length - 1];\n  const invocationPart = lastMessage.parts.find(\n    (part) => part.type === \"tool-invocation\" && part.toolInvocation.toolCallId === toolCallId\n  );\n  if (invocationPart == null) {\n    return;\n  }\n  const toolResult = {\n    ...invocationPart.toolInvocation,\n    state: \"result\",\n    result\n  };\n  invocationPart.toolInvocation = toolResult;\n  lastMessage.toolInvocations = (_a = lastMessage.toolInvocations) == null ? void 0 : _a.map(\n    (toolInvocation) => toolInvocation.toolCallId === toolCallId ? toolResult : toolInvocation\n  );\n}\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGFpLXNkay91aS11dGlscy9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDb0Q7O0FBRXBEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxPQUFPO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxLQUFLO0FBQ3REO0FBQ0EsWUFBWSxnQkFBZ0IsR0FBRztBQUMvQjtBQUNBOztBQUVBO0FBQzBFOztBQUUxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDdUQ7O0FBRXZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsUUFBUTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGVBQWUscUVBQWEsR0FBRyxnQkFBZ0I7QUFDL0M7QUFDQSxhQUFhO0FBQ2I7QUFDQSxXQUFXLHFFQUFhLEdBQUcseUJBQXlCO0FBQ3BEO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEscUNBQXFDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxPQUFPO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxLQUFLO0FBQ3REO0FBQ0EsWUFBWSxnQkFBZ0IsR0FBRztBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxjQUFjO0FBQzNFLGlCQUFpQixzQkFBc0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELGdCQUFnQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw4REFBa0I7QUFDOUM7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxjQUFjLHFCQUFxQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsaUJBQWlCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixvQkFBb0I7QUFDL0M7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gseUNBQXlDLDhCQUE4QjtBQUN2RTs7QUFFQTtBQUMyRTs7QUFFM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDhEQUFtQjtBQUMvQyxDQUFDO0FBQ0QscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0EsYUFBYSw0REFBNEQ7QUFDekU7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsOEJBQThCO0FBQ2pEO0FBQ0EsZ0NBQWdDLHFCQUFxQjtBQUNyRDtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxnQkFBZ0I7QUFDbEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxnQkFBZ0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHVDQUF1QztBQUMzRDtBQUNBO0FBQ0EsNEJBQTRCLHFDQUFxQztBQUNqRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxjQUFjO0FBQzNFLGlCQUFpQixzQkFBc0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELGdCQUFnQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ3lEOztBQUV6RDtBQUNpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksOERBQWU7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxvQ0FBb0MsSUFBSTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsSUFBSTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxtRUFBZTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF5QkU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cnZpdmFsLWZ1bi8uL25vZGVfbW9kdWxlcy9AYWktc2RrL3VpLXV0aWxzL2Rpc3QvaW5kZXgubWpzP2Y2ZDgiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2luZGV4LnRzXG5pbXBvcnQgeyBnZW5lcmF0ZUlkIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcblxuLy8gc3JjL2Fzc2lzdGFudC1zdHJlYW0tcGFydHMudHNcbnZhciB0ZXh0U3RyZWFtUGFydCA9IHtcbiAgY29kZTogXCIwXCIsXG4gIG5hbWU6IFwidGV4dFwiLFxuICBwYXJzZTogKHZhbHVlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcInRleHRcIiBwYXJ0cyBleHBlY3QgYSBzdHJpbmcgdmFsdWUuJyk7XG4gICAgfVxuICAgIHJldHVybiB7IHR5cGU6IFwidGV4dFwiLCB2YWx1ZSB9O1xuICB9XG59O1xudmFyIGVycm9yU3RyZWFtUGFydCA9IHtcbiAgY29kZTogXCIzXCIsXG4gIG5hbWU6IFwiZXJyb3JcIixcbiAgcGFyc2U6ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJlcnJvclwiIHBhcnRzIGV4cGVjdCBhIHN0cmluZyB2YWx1ZS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiLCB2YWx1ZSB9O1xuICB9XG59O1xudmFyIGFzc2lzdGFudE1lc3NhZ2VTdHJlYW1QYXJ0ID0ge1xuICBjb2RlOiBcIjRcIixcbiAgbmFtZTogXCJhc3Npc3RhbnRfbWVzc2FnZVwiLFxuICBwYXJzZTogKHZhbHVlKSA9PiB7XG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8ICEoXCJpZFwiIGluIHZhbHVlKSB8fCAhKFwicm9sZVwiIGluIHZhbHVlKSB8fCAhKFwiY29udGVudFwiIGluIHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUuaWQgIT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHZhbHVlLnJvbGUgIT09IFwic3RyaW5nXCIgfHwgdmFsdWUucm9sZSAhPT0gXCJhc3Npc3RhbnRcIiB8fCAhQXJyYXkuaXNBcnJheSh2YWx1ZS5jb250ZW50KSB8fCAhdmFsdWUuY29udGVudC5ldmVyeShcbiAgICAgIChpdGVtKSA9PiBpdGVtICE9IG51bGwgJiYgdHlwZW9mIGl0ZW0gPT09IFwib2JqZWN0XCIgJiYgXCJ0eXBlXCIgaW4gaXRlbSAmJiBpdGVtLnR5cGUgPT09IFwidGV4dFwiICYmIFwidGV4dFwiIGluIGl0ZW0gJiYgaXRlbS50ZXh0ICE9IG51bGwgJiYgdHlwZW9mIGl0ZW0udGV4dCA9PT0gXCJvYmplY3RcIiAmJiBcInZhbHVlXCIgaW4gaXRlbS50ZXh0ICYmIHR5cGVvZiBpdGVtLnRleHQudmFsdWUgPT09IFwic3RyaW5nXCJcbiAgICApKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdcImFzc2lzdGFudF9tZXNzYWdlXCIgcGFydHMgZXhwZWN0IGFuIG9iamVjdCB3aXRoIGFuIFwiaWRcIiwgXCJyb2xlXCIsIGFuZCBcImNvbnRlbnRcIiBwcm9wZXJ0eS4nXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJhc3Npc3RhbnRfbWVzc2FnZVwiLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9XG59O1xudmFyIGFzc2lzdGFudENvbnRyb2xEYXRhU3RyZWFtUGFydCA9IHtcbiAgY29kZTogXCI1XCIsXG4gIG5hbWU6IFwiYXNzaXN0YW50X2NvbnRyb2xfZGF0YVwiLFxuICBwYXJzZTogKHZhbHVlKSA9PiB7XG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8ICEoXCJ0aHJlYWRJZFwiIGluIHZhbHVlKSB8fCAhKFwibWVzc2FnZUlkXCIgaW4gdmFsdWUpIHx8IHR5cGVvZiB2YWx1ZS50aHJlYWRJZCAhPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdmFsdWUubWVzc2FnZUlkICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdcImFzc2lzdGFudF9jb250cm9sX2RhdGFcIiBwYXJ0cyBleHBlY3QgYW4gb2JqZWN0IHdpdGggYSBcInRocmVhZElkXCIgYW5kIFwibWVzc2FnZUlkXCIgcHJvcGVydHkuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiYXNzaXN0YW50X2NvbnRyb2xfZGF0YVwiLFxuICAgICAgdmFsdWU6IHtcbiAgICAgICAgdGhyZWFkSWQ6IHZhbHVlLnRocmVhZElkLFxuICAgICAgICBtZXNzYWdlSWQ6IHZhbHVlLm1lc3NhZ2VJZFxuICAgICAgfVxuICAgIH07XG4gIH1cbn07XG52YXIgZGF0YU1lc3NhZ2VTdHJlYW1QYXJ0ID0ge1xuICBjb2RlOiBcIjZcIixcbiAgbmFtZTogXCJkYXRhX21lc3NhZ2VcIixcbiAgcGFyc2U6ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCAhKFwicm9sZVwiIGluIHZhbHVlKSB8fCAhKFwiZGF0YVwiIGluIHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUucm9sZSAhPT0gXCJzdHJpbmdcIiB8fCB2YWx1ZS5yb2xlICE9PSBcImRhdGFcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnXCJkYXRhX21lc3NhZ2VcIiBwYXJ0cyBleHBlY3QgYW4gb2JqZWN0IHdpdGggYSBcInJvbGVcIiBhbmQgXCJkYXRhXCIgcHJvcGVydHkuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZGF0YV9tZXNzYWdlXCIsXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH1cbn07XG52YXIgYXNzaXN0YW50U3RyZWFtUGFydHMgPSBbXG4gIHRleHRTdHJlYW1QYXJ0LFxuICBlcnJvclN0cmVhbVBhcnQsXG4gIGFzc2lzdGFudE1lc3NhZ2VTdHJlYW1QYXJ0LFxuICBhc3Npc3RhbnRDb250cm9sRGF0YVN0cmVhbVBhcnQsXG4gIGRhdGFNZXNzYWdlU3RyZWFtUGFydFxuXTtcbnZhciBhc3Npc3RhbnRTdHJlYW1QYXJ0c0J5Q29kZSA9IHtcbiAgW3RleHRTdHJlYW1QYXJ0LmNvZGVdOiB0ZXh0U3RyZWFtUGFydCxcbiAgW2Vycm9yU3RyZWFtUGFydC5jb2RlXTogZXJyb3JTdHJlYW1QYXJ0LFxuICBbYXNzaXN0YW50TWVzc2FnZVN0cmVhbVBhcnQuY29kZV06IGFzc2lzdGFudE1lc3NhZ2VTdHJlYW1QYXJ0LFxuICBbYXNzaXN0YW50Q29udHJvbERhdGFTdHJlYW1QYXJ0LmNvZGVdOiBhc3Npc3RhbnRDb250cm9sRGF0YVN0cmVhbVBhcnQsXG4gIFtkYXRhTWVzc2FnZVN0cmVhbVBhcnQuY29kZV06IGRhdGFNZXNzYWdlU3RyZWFtUGFydFxufTtcbnZhciBTdHJlYW1TdHJpbmdQcmVmaXhlcyA9IHtcbiAgW3RleHRTdHJlYW1QYXJ0Lm5hbWVdOiB0ZXh0U3RyZWFtUGFydC5jb2RlLFxuICBbZXJyb3JTdHJlYW1QYXJ0Lm5hbWVdOiBlcnJvclN0cmVhbVBhcnQuY29kZSxcbiAgW2Fzc2lzdGFudE1lc3NhZ2VTdHJlYW1QYXJ0Lm5hbWVdOiBhc3Npc3RhbnRNZXNzYWdlU3RyZWFtUGFydC5jb2RlLFxuICBbYXNzaXN0YW50Q29udHJvbERhdGFTdHJlYW1QYXJ0Lm5hbWVdOiBhc3Npc3RhbnRDb250cm9sRGF0YVN0cmVhbVBhcnQuY29kZSxcbiAgW2RhdGFNZXNzYWdlU3RyZWFtUGFydC5uYW1lXTogZGF0YU1lc3NhZ2VTdHJlYW1QYXJ0LmNvZGVcbn07XG52YXIgdmFsaWRDb2RlcyA9IGFzc2lzdGFudFN0cmVhbVBhcnRzLm1hcCgocGFydCkgPT4gcGFydC5jb2RlKTtcbnZhciBwYXJzZUFzc2lzdGFudFN0cmVhbVBhcnQgPSAobGluZSkgPT4ge1xuICBjb25zdCBmaXJzdFNlcGFyYXRvckluZGV4ID0gbGluZS5pbmRleE9mKFwiOlwiKTtcbiAgaWYgKGZpcnN0U2VwYXJhdG9ySW5kZXggPT09IC0xKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIHBhcnNlIHN0cmVhbSBzdHJpbmcuIE5vIHNlcGFyYXRvciBmb3VuZC5cIik7XG4gIH1cbiAgY29uc3QgcHJlZml4ID0gbGluZS5zbGljZSgwLCBmaXJzdFNlcGFyYXRvckluZGV4KTtcbiAgaWYgKCF2YWxpZENvZGVzLmluY2x1ZGVzKHByZWZpeCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBwYXJzZSBzdHJlYW0gc3RyaW5nLiBJbnZhbGlkIGNvZGUgJHtwcmVmaXh9LmApO1xuICB9XG4gIGNvbnN0IGNvZGUgPSBwcmVmaXg7XG4gIGNvbnN0IHRleHRWYWx1ZSA9IGxpbmUuc2xpY2UoZmlyc3RTZXBhcmF0b3JJbmRleCArIDEpO1xuICBjb25zdCBqc29uVmFsdWUgPSBKU09OLnBhcnNlKHRleHRWYWx1ZSk7XG4gIHJldHVybiBhc3Npc3RhbnRTdHJlYW1QYXJ0c0J5Q29kZVtjb2RlXS5wYXJzZShqc29uVmFsdWUpO1xufTtcbmZ1bmN0aW9uIGZvcm1hdEFzc2lzdGFudFN0cmVhbVBhcnQodHlwZSwgdmFsdWUpIHtcbiAgY29uc3Qgc3RyZWFtUGFydCA9IGFzc2lzdGFudFN0cmVhbVBhcnRzLmZpbmQoKHBhcnQpID0+IHBhcnQubmFtZSA9PT0gdHlwZSk7XG4gIGlmICghc3RyZWFtUGFydCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzdHJlYW0gcGFydCB0eXBlOiAke3R5cGV9YCk7XG4gIH1cbiAgcmV0dXJuIGAke3N0cmVhbVBhcnQuY29kZX06JHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9XG5gO1xufVxuXG4vLyBzcmMvcHJvY2Vzcy1jaGF0LXJlc3BvbnNlLnRzXG5pbXBvcnQgeyBnZW5lcmF0ZUlkIGFzIGdlbmVyYXRlSWRGdW5jdGlvbiB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5cbi8vIHNyYy9kdXBsaWNhdGVkL3VzYWdlLnRzXG5mdW5jdGlvbiBjYWxjdWxhdGVMYW5ndWFnZU1vZGVsVXNhZ2Uoe1xuICBwcm9tcHRUb2tlbnMsXG4gIGNvbXBsZXRpb25Ub2tlbnNcbn0pIHtcbiAgcmV0dXJuIHtcbiAgICBwcm9tcHRUb2tlbnMsXG4gICAgY29tcGxldGlvblRva2VucyxcbiAgICB0b3RhbFRva2VuczogcHJvbXB0VG9rZW5zICsgY29tcGxldGlvblRva2Vuc1xuICB9O1xufVxuXG4vLyBzcmMvcGFyc2UtcGFydGlhbC1qc29uLnRzXG5pbXBvcnQgeyBzYWZlUGFyc2VKU09OIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcblxuLy8gc3JjL2ZpeC1qc29uLnRzXG5mdW5jdGlvbiBmaXhKc29uKGlucHV0KSB7XG4gIGNvbnN0IHN0YWNrID0gW1wiUk9PVFwiXTtcbiAgbGV0IGxhc3RWYWxpZEluZGV4ID0gLTE7XG4gIGxldCBsaXRlcmFsU3RhcnQgPSBudWxsO1xuICBmdW5jdGlvbiBwcm9jZXNzVmFsdWVTdGFydChjaGFyLCBpLCBzd2FwU3RhdGUpIHtcbiAgICB7XG4gICAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgICAgY2FzZSAnXCInOiB7XG4gICAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgIHN0YWNrLnB1c2goc3dhcFN0YXRlKTtcbiAgICAgICAgICBzdGFjay5wdXNoKFwiSU5TSURFX1NUUklOR1wiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiZlwiOlxuICAgICAgICBjYXNlIFwidFwiOlxuICAgICAgICBjYXNlIFwiblwiOiB7XG4gICAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICAgIGxpdGVyYWxTdGFydCA9IGk7XG4gICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgc3RhY2sucHVzaChzd2FwU3RhdGUpO1xuICAgICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfTElURVJBTFwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiLVwiOiB7XG4gICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgc3RhY2sucHVzaChzd2FwU3RhdGUpO1xuICAgICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfTlVNQkVSXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCIwXCI6XG4gICAgICAgIGNhc2UgXCIxXCI6XG4gICAgICAgIGNhc2UgXCIyXCI6XG4gICAgICAgIGNhc2UgXCIzXCI6XG4gICAgICAgIGNhc2UgXCI0XCI6XG4gICAgICAgIGNhc2UgXCI1XCI6XG4gICAgICAgIGNhc2UgXCI2XCI6XG4gICAgICAgIGNhc2UgXCI3XCI6XG4gICAgICAgIGNhc2UgXCI4XCI6XG4gICAgICAgIGNhc2UgXCI5XCI6IHtcbiAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgc3RhY2sucHVzaChzd2FwU3RhdGUpO1xuICAgICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfTlVNQkVSXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJ7XCI6IHtcbiAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgc3RhY2sucHVzaChzd2FwU3RhdGUpO1xuICAgICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfT0JKRUNUX1NUQVJUXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJbXCI6IHtcbiAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgc3RhY2sucHVzaChzd2FwU3RhdGUpO1xuICAgICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfQVJSQVlfU1RBUlRcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcHJvY2Vzc0FmdGVyT2JqZWN0VmFsdWUoY2hhciwgaSkge1xuICAgIHN3aXRjaCAoY2hhcikge1xuICAgICAgY2FzZSBcIixcIjoge1xuICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgc3RhY2sucHVzaChcIklOU0lERV9PQkpFQ1RfQUZURVJfQ09NTUFcIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIn1cIjoge1xuICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcHJvY2Vzc0FmdGVyQXJyYXlWYWx1ZShjaGFyLCBpKSB7XG4gICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICBjYXNlIFwiLFwiOiB7XG4gICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICBzdGFjay5wdXNoKFwiSU5TSURFX0FSUkFZX0FGVEVSX0NPTU1BXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJdXCI6IHtcbiAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjaGFyID0gaW5wdXRbaV07XG4gICAgY29uc3QgY3VycmVudFN0YXRlID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgc3dpdGNoIChjdXJyZW50U3RhdGUpIHtcbiAgICAgIGNhc2UgXCJST09UXCI6XG4gICAgICAgIHByb2Nlc3NWYWx1ZVN0YXJ0KGNoYXIsIGksIFwiRklOSVNIXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJJTlNJREVfT0JKRUNUX1NUQVJUXCI6IHtcbiAgICAgICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICAgICAgY2FzZSAnXCInOiB7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfT0JKRUNUX0tFWVwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwifVwiOiB7XG4gICAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfT0JKRUNUX0FGVEVSX0NPTU1BXCI6IHtcbiAgICAgICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICAgICAgY2FzZSAnXCInOiB7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfT0JKRUNUX0tFWVwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfT0JKRUNUX0tFWVwiOiB7XG4gICAgICAgIHN3aXRjaCAoY2hhcikge1xuICAgICAgICAgIGNhc2UgJ1wiJzoge1xuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBzdGFjay5wdXNoKFwiSU5TSURFX09CSkVDVF9BRlRFUl9LRVlcIik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiSU5TSURFX09CSkVDVF9BRlRFUl9LRVlcIjoge1xuICAgICAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgICAgICBjYXNlIFwiOlwiOiB7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfT0JKRUNUX0JFRk9SRV9WQUxVRVwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfT0JKRUNUX0JFRk9SRV9WQUxVRVwiOiB7XG4gICAgICAgIHByb2Nlc3NWYWx1ZVN0YXJ0KGNoYXIsIGksIFwiSU5TSURFX09CSkVDVF9BRlRFUl9WQUxVRVwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiSU5TSURFX09CSkVDVF9BRlRFUl9WQUxVRVwiOiB7XG4gICAgICAgIHByb2Nlc3NBZnRlck9iamVjdFZhbHVlKGNoYXIsIGkpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfU1RSSU5HXCI6IHtcbiAgICAgICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICAgICAgY2FzZSAnXCInOiB7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGxhc3RWYWxpZEluZGV4ID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwiXFxcXFwiOiB7XG4gICAgICAgICAgICBzdGFjay5wdXNoKFwiSU5TSURFX1NUUklOR19FU0NBUEVcIik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfQVJSQVlfU1RBUlRcIjoge1xuICAgICAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgICAgICBjYXNlIFwiXVwiOiB7XG4gICAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgICAgICBwcm9jZXNzVmFsdWVTdGFydChjaGFyLCBpLCBcIklOU0lERV9BUlJBWV9BRlRFUl9WQUxVRVwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfQVJSQVlfQUZURVJfVkFMVUVcIjoge1xuICAgICAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgICAgICBjYXNlIFwiLFwiOiB7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfQVJSQVlfQUZURVJfQ09NTUFcIik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcIl1cIjoge1xuICAgICAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIklOU0lERV9BUlJBWV9BRlRFUl9DT01NQVwiOiB7XG4gICAgICAgIHByb2Nlc3NWYWx1ZVN0YXJ0KGNoYXIsIGksIFwiSU5TSURFX0FSUkFZX0FGVEVSX1ZBTFVFXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfU1RSSU5HX0VTQ0FQRVwiOiB7XG4gICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIklOU0lERV9OVU1CRVJcIjoge1xuICAgICAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgICAgICBjYXNlIFwiMFwiOlxuICAgICAgICAgIGNhc2UgXCIxXCI6XG4gICAgICAgICAgY2FzZSBcIjJcIjpcbiAgICAgICAgICBjYXNlIFwiM1wiOlxuICAgICAgICAgIGNhc2UgXCI0XCI6XG4gICAgICAgICAgY2FzZSBcIjVcIjpcbiAgICAgICAgICBjYXNlIFwiNlwiOlxuICAgICAgICAgIGNhc2UgXCI3XCI6XG4gICAgICAgICAgY2FzZSBcIjhcIjpcbiAgICAgICAgICBjYXNlIFwiOVwiOiB7XG4gICAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcImVcIjpcbiAgICAgICAgICBjYXNlIFwiRVwiOlxuICAgICAgICAgIGNhc2UgXCItXCI6XG4gICAgICAgICAgY2FzZSBcIi5cIjoge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCIsXCI6IHtcbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgaWYgKHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdID09PSBcIklOU0lERV9BUlJBWV9BRlRFUl9WQUxVRVwiKSB7XG4gICAgICAgICAgICAgIHByb2Nlc3NBZnRlckFycmF5VmFsdWUoY2hhciwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0gPT09IFwiSU5TSURFX09CSkVDVF9BRlRFUl9WQUxVRVwiKSB7XG4gICAgICAgICAgICAgIHByb2Nlc3NBZnRlck9iamVjdFZhbHVlKGNoYXIsIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJ9XCI6IHtcbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgaWYgKHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdID09PSBcIklOU0lERV9PQkpFQ1RfQUZURVJfVkFMVUVcIikge1xuICAgICAgICAgICAgICBwcm9jZXNzQWZ0ZXJPYmplY3RWYWx1ZShjaGFyLCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwiXVwiOiB7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGlmIChzdGFja1tzdGFjay5sZW5ndGggLSAxXSA9PT0gXCJJTlNJREVfQVJSQVlfQUZURVJfVkFMVUVcIikge1xuICAgICAgICAgICAgICBwcm9jZXNzQWZ0ZXJBcnJheVZhbHVlKGNoYXIsIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIklOU0lERV9MSVRFUkFMXCI6IHtcbiAgICAgICAgY29uc3QgcGFydGlhbExpdGVyYWwgPSBpbnB1dC5zdWJzdHJpbmcobGl0ZXJhbFN0YXJ0LCBpICsgMSk7XG4gICAgICAgIGlmICghXCJmYWxzZVwiLnN0YXJ0c1dpdGgocGFydGlhbExpdGVyYWwpICYmICFcInRydWVcIi5zdGFydHNXaXRoKHBhcnRpYWxMaXRlcmFsKSAmJiAhXCJudWxsXCIuc3RhcnRzV2l0aChwYXJ0aWFsTGl0ZXJhbCkpIHtcbiAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICBpZiAoc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0gPT09IFwiSU5TSURFX09CSkVDVF9BRlRFUl9WQUxVRVwiKSB7XG4gICAgICAgICAgICBwcm9jZXNzQWZ0ZXJPYmplY3RWYWx1ZShjaGFyLCBpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdID09PSBcIklOU0lERV9BUlJBWV9BRlRFUl9WQUxVRVwiKSB7XG4gICAgICAgICAgICBwcm9jZXNzQWZ0ZXJBcnJheVZhbHVlKGNoYXIsIGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGxldCByZXN1bHQgPSBpbnB1dC5zbGljZSgwLCBsYXN0VmFsaWRJbmRleCArIDEpO1xuICBmb3IgKGxldCBpID0gc3RhY2subGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBjb25zdCBzdGF0ZSA9IHN0YWNrW2ldO1xuICAgIHN3aXRjaCAoc3RhdGUpIHtcbiAgICAgIGNhc2UgXCJJTlNJREVfU1RSSU5HXCI6IHtcbiAgICAgICAgcmVzdWx0ICs9ICdcIic7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIklOU0lERV9PQkpFQ1RfS0VZXCI6XG4gICAgICBjYXNlIFwiSU5TSURFX09CSkVDVF9BRlRFUl9LRVlcIjpcbiAgICAgIGNhc2UgXCJJTlNJREVfT0JKRUNUX0FGVEVSX0NPTU1BXCI6XG4gICAgICBjYXNlIFwiSU5TSURFX09CSkVDVF9TVEFSVFwiOlxuICAgICAgY2FzZSBcIklOU0lERV9PQkpFQ1RfQkVGT1JFX1ZBTFVFXCI6XG4gICAgICBjYXNlIFwiSU5TSURFX09CSkVDVF9BRlRFUl9WQUxVRVwiOiB7XG4gICAgICAgIHJlc3VsdCArPSBcIn1cIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiSU5TSURFX0FSUkFZX1NUQVJUXCI6XG4gICAgICBjYXNlIFwiSU5TSURFX0FSUkFZX0FGVEVSX0NPTU1BXCI6XG4gICAgICBjYXNlIFwiSU5TSURFX0FSUkFZX0FGVEVSX1ZBTFVFXCI6IHtcbiAgICAgICAgcmVzdWx0ICs9IFwiXVwiO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfTElURVJBTFwiOiB7XG4gICAgICAgIGNvbnN0IHBhcnRpYWxMaXRlcmFsID0gaW5wdXQuc3Vic3RyaW5nKGxpdGVyYWxTdGFydCwgaW5wdXQubGVuZ3RoKTtcbiAgICAgICAgaWYgKFwidHJ1ZVwiLnN0YXJ0c1dpdGgocGFydGlhbExpdGVyYWwpKSB7XG4gICAgICAgICAgcmVzdWx0ICs9IFwidHJ1ZVwiLnNsaWNlKHBhcnRpYWxMaXRlcmFsLmxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSBpZiAoXCJmYWxzZVwiLnN0YXJ0c1dpdGgocGFydGlhbExpdGVyYWwpKSB7XG4gICAgICAgICAgcmVzdWx0ICs9IFwiZmFsc2VcIi5zbGljZShwYXJ0aWFsTGl0ZXJhbC5sZW5ndGgpO1xuICAgICAgICB9IGVsc2UgaWYgKFwibnVsbFwiLnN0YXJ0c1dpdGgocGFydGlhbExpdGVyYWwpKSB7XG4gICAgICAgICAgcmVzdWx0ICs9IFwibnVsbFwiLnNsaWNlKHBhcnRpYWxMaXRlcmFsLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gc3JjL3BhcnNlLXBhcnRpYWwtanNvbi50c1xuZnVuY3Rpb24gcGFyc2VQYXJ0aWFsSnNvbihqc29uVGV4dCkge1xuICBpZiAoanNvblRleHQgPT09IHZvaWQgMCkge1xuICAgIHJldHVybiB7IHZhbHVlOiB2b2lkIDAsIHN0YXRlOiBcInVuZGVmaW5lZC1pbnB1dFwiIH07XG4gIH1cbiAgbGV0IHJlc3VsdCA9IHNhZmVQYXJzZUpTT04oeyB0ZXh0OiBqc29uVGV4dCB9KTtcbiAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHJlc3VsdC52YWx1ZSwgc3RhdGU6IFwic3VjY2Vzc2Z1bC1wYXJzZVwiIH07XG4gIH1cbiAgcmVzdWx0ID0gc2FmZVBhcnNlSlNPTih7IHRleHQ6IGZpeEpzb24oanNvblRleHQpIH0pO1xuICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICByZXR1cm4geyB2YWx1ZTogcmVzdWx0LnZhbHVlLCBzdGF0ZTogXCJyZXBhaXJlZC1wYXJzZVwiIH07XG4gIH1cbiAgcmV0dXJuIHsgdmFsdWU6IHZvaWQgMCwgc3RhdGU6IFwiZmFpbGVkLXBhcnNlXCIgfTtcbn1cblxuLy8gc3JjL2RhdGEtc3RyZWFtLXBhcnRzLnRzXG52YXIgdGV4dFN0cmVhbVBhcnQyID0ge1xuICBjb2RlOiBcIjBcIixcbiAgbmFtZTogXCJ0ZXh0XCIsXG4gIHBhcnNlOiAodmFsdWUpID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1widGV4dFwiIHBhcnRzIGV4cGVjdCBhIHN0cmluZyB2YWx1ZS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdHlwZTogXCJ0ZXh0XCIsIHZhbHVlIH07XG4gIH1cbn07XG52YXIgZGF0YVN0cmVhbVBhcnQgPSB7XG4gIGNvZGU6IFwiMlwiLFxuICBuYW1lOiBcImRhdGFcIixcbiAgcGFyc2U6ICh2YWx1ZSkgPT4ge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJkYXRhXCIgcGFydHMgZXhwZWN0IGFuIGFycmF5IHZhbHVlLicpO1xuICAgIH1cbiAgICByZXR1cm4geyB0eXBlOiBcImRhdGFcIiwgdmFsdWUgfTtcbiAgfVxufTtcbnZhciBlcnJvclN0cmVhbVBhcnQyID0ge1xuICBjb2RlOiBcIjNcIixcbiAgbmFtZTogXCJlcnJvclwiLFxuICBwYXJzZTogKHZhbHVlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcImVycm9yXCIgcGFydHMgZXhwZWN0IGEgc3RyaW5nIHZhbHVlLicpO1xuICAgIH1cbiAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIHZhbHVlIH07XG4gIH1cbn07XG52YXIgbWVzc2FnZUFubm90YXRpb25zU3RyZWFtUGFydCA9IHtcbiAgY29kZTogXCI4XCIsXG4gIG5hbWU6IFwibWVzc2FnZV9hbm5vdGF0aW9uc1wiLFxuICBwYXJzZTogKHZhbHVlKSA9PiB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIm1lc3NhZ2VfYW5ub3RhdGlvbnNcIiBwYXJ0cyBleHBlY3QgYW4gYXJyYXkgdmFsdWUuJyk7XG4gICAgfVxuICAgIHJldHVybiB7IHR5cGU6IFwibWVzc2FnZV9hbm5vdGF0aW9uc1wiLCB2YWx1ZSB9O1xuICB9XG59O1xudmFyIHRvb2xDYWxsU3RyZWFtUGFydCA9IHtcbiAgY29kZTogXCI5XCIsXG4gIG5hbWU6IFwidG9vbF9jYWxsXCIsXG4gIHBhcnNlOiAodmFsdWUpID0+IHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgIShcInRvb2xDYWxsSWRcIiBpbiB2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlLnRvb2xDYWxsSWQgIT09IFwic3RyaW5nXCIgfHwgIShcInRvb2xOYW1lXCIgaW4gdmFsdWUpIHx8IHR5cGVvZiB2YWx1ZS50b29sTmFtZSAhPT0gXCJzdHJpbmdcIiB8fCAhKFwiYXJnc1wiIGluIHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUuYXJncyAhPT0gXCJvYmplY3RcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnXCJ0b29sX2NhbGxcIiBwYXJ0cyBleHBlY3QgYW4gb2JqZWN0IHdpdGggYSBcInRvb2xDYWxsSWRcIiwgXCJ0b29sTmFtZVwiLCBhbmQgXCJhcmdzXCIgcHJvcGVydHkuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwidG9vbF9jYWxsXCIsXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH1cbn07XG52YXIgdG9vbFJlc3VsdFN0cmVhbVBhcnQgPSB7XG4gIGNvZGU6IFwiYVwiLFxuICBuYW1lOiBcInRvb2xfcmVzdWx0XCIsXG4gIHBhcnNlOiAodmFsdWUpID0+IHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgIShcInRvb2xDYWxsSWRcIiBpbiB2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlLnRvb2xDYWxsSWQgIT09IFwic3RyaW5nXCIgfHwgIShcInJlc3VsdFwiIGluIHZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnXCJ0b29sX3Jlc3VsdFwiIHBhcnRzIGV4cGVjdCBhbiBvYmplY3Qgd2l0aCBhIFwidG9vbENhbGxJZFwiIGFuZCBhIFwicmVzdWx0XCIgcHJvcGVydHkuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwidG9vbF9yZXN1bHRcIixcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgfVxufTtcbnZhciB0b29sQ2FsbFN0cmVhbWluZ1N0YXJ0U3RyZWFtUGFydCA9IHtcbiAgY29kZTogXCJiXCIsXG4gIG5hbWU6IFwidG9vbF9jYWxsX3N0cmVhbWluZ19zdGFydFwiLFxuICBwYXJzZTogKHZhbHVlKSA9PiB7XG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8ICEoXCJ0b29sQ2FsbElkXCIgaW4gdmFsdWUpIHx8IHR5cGVvZiB2YWx1ZS50b29sQ2FsbElkICE9PSBcInN0cmluZ1wiIHx8ICEoXCJ0b29sTmFtZVwiIGluIHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUudG9vbE5hbWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1widG9vbF9jYWxsX3N0cmVhbWluZ19zdGFydFwiIHBhcnRzIGV4cGVjdCBhbiBvYmplY3Qgd2l0aCBhIFwidG9vbENhbGxJZFwiIGFuZCBcInRvb2xOYW1lXCIgcHJvcGVydHkuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwidG9vbF9jYWxsX3N0cmVhbWluZ19zdGFydFwiLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9XG59O1xudmFyIHRvb2xDYWxsRGVsdGFTdHJlYW1QYXJ0ID0ge1xuICBjb2RlOiBcImNcIixcbiAgbmFtZTogXCJ0b29sX2NhbGxfZGVsdGFcIixcbiAgcGFyc2U6ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCAhKFwidG9vbENhbGxJZFwiIGluIHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUudG9vbENhbGxJZCAhPT0gXCJzdHJpbmdcIiB8fCAhKFwiYXJnc1RleHREZWx0YVwiIGluIHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUuYXJnc1RleHREZWx0YSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnXCJ0b29sX2NhbGxfZGVsdGFcIiBwYXJ0cyBleHBlY3QgYW4gb2JqZWN0IHdpdGggYSBcInRvb2xDYWxsSWRcIiBhbmQgXCJhcmdzVGV4dERlbHRhXCIgcHJvcGVydHkuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwidG9vbF9jYWxsX2RlbHRhXCIsXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH1cbn07XG52YXIgZmluaXNoTWVzc2FnZVN0cmVhbVBhcnQgPSB7XG4gIGNvZGU6IFwiZFwiLFxuICBuYW1lOiBcImZpbmlzaF9tZXNzYWdlXCIsXG4gIHBhcnNlOiAodmFsdWUpID0+IHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgIShcImZpbmlzaFJlYXNvblwiIGluIHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUuZmluaXNoUmVhc29uICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdcImZpbmlzaF9tZXNzYWdlXCIgcGFydHMgZXhwZWN0IGFuIG9iamVjdCB3aXRoIGEgXCJmaW5pc2hSZWFzb25cIiBwcm9wZXJ0eS4nXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICBmaW5pc2hSZWFzb246IHZhbHVlLmZpbmlzaFJlYXNvblxuICAgIH07XG4gICAgaWYgKFwidXNhZ2VcIiBpbiB2YWx1ZSAmJiB2YWx1ZS51c2FnZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZS51c2FnZSA9PT0gXCJvYmplY3RcIiAmJiBcInByb21wdFRva2Vuc1wiIGluIHZhbHVlLnVzYWdlICYmIFwiY29tcGxldGlvblRva2Vuc1wiIGluIHZhbHVlLnVzYWdlKSB7XG4gICAgICByZXN1bHQudXNhZ2UgPSB7XG4gICAgICAgIHByb21wdFRva2VuczogdHlwZW9mIHZhbHVlLnVzYWdlLnByb21wdFRva2VucyA9PT0gXCJudW1iZXJcIiA/IHZhbHVlLnVzYWdlLnByb21wdFRva2VucyA6IE51bWJlci5OYU4sXG4gICAgICAgIGNvbXBsZXRpb25Ub2tlbnM6IHR5cGVvZiB2YWx1ZS51c2FnZS5jb21wbGV0aW9uVG9rZW5zID09PSBcIm51bWJlclwiID8gdmFsdWUudXNhZ2UuY29tcGxldGlvblRva2VucyA6IE51bWJlci5OYU5cbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImZpbmlzaF9tZXNzYWdlXCIsXG4gICAgICB2YWx1ZTogcmVzdWx0XG4gICAgfTtcbiAgfVxufTtcbnZhciBmaW5pc2hTdGVwU3RyZWFtUGFydCA9IHtcbiAgY29kZTogXCJlXCIsXG4gIG5hbWU6IFwiZmluaXNoX3N0ZXBcIixcbiAgcGFyc2U6ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCAhKFwiZmluaXNoUmVhc29uXCIgaW4gdmFsdWUpIHx8IHR5cGVvZiB2YWx1ZS5maW5pc2hSZWFzb24gIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1wiZmluaXNoX3N0ZXBcIiBwYXJ0cyBleHBlY3QgYW4gb2JqZWN0IHdpdGggYSBcImZpbmlzaFJlYXNvblwiIHByb3BlcnR5LidcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgIGZpbmlzaFJlYXNvbjogdmFsdWUuZmluaXNoUmVhc29uLFxuICAgICAgaXNDb250aW51ZWQ6IGZhbHNlXG4gICAgfTtcbiAgICBpZiAoXCJ1c2FnZVwiIGluIHZhbHVlICYmIHZhbHVlLnVzYWdlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlLnVzYWdlID09PSBcIm9iamVjdFwiICYmIFwicHJvbXB0VG9rZW5zXCIgaW4gdmFsdWUudXNhZ2UgJiYgXCJjb21wbGV0aW9uVG9rZW5zXCIgaW4gdmFsdWUudXNhZ2UpIHtcbiAgICAgIHJlc3VsdC51c2FnZSA9IHtcbiAgICAgICAgcHJvbXB0VG9rZW5zOiB0eXBlb2YgdmFsdWUudXNhZ2UucHJvbXB0VG9rZW5zID09PSBcIm51bWJlclwiID8gdmFsdWUudXNhZ2UucHJvbXB0VG9rZW5zIDogTnVtYmVyLk5hTixcbiAgICAgICAgY29tcGxldGlvblRva2VuczogdHlwZW9mIHZhbHVlLnVzYWdlLmNvbXBsZXRpb25Ub2tlbnMgPT09IFwibnVtYmVyXCIgPyB2YWx1ZS51c2FnZS5jb21wbGV0aW9uVG9rZW5zIDogTnVtYmVyLk5hTlxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKFwiaXNDb250aW51ZWRcIiBpbiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUuaXNDb250aW51ZWQgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICByZXN1bHQuaXNDb250aW51ZWQgPSB2YWx1ZS5pc0NvbnRpbnVlZDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZmluaXNoX3N0ZXBcIixcbiAgICAgIHZhbHVlOiByZXN1bHRcbiAgICB9O1xuICB9XG59O1xudmFyIHN0YXJ0U3RlcFN0cmVhbVBhcnQgPSB7XG4gIGNvZGU6IFwiZlwiLFxuICBuYW1lOiBcInN0YXJ0X3N0ZXBcIixcbiAgcGFyc2U6ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCAhKFwibWVzc2FnZUlkXCIgaW4gdmFsdWUpIHx8IHR5cGVvZiB2YWx1ZS5tZXNzYWdlSWQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1wic3RhcnRfc3RlcFwiIHBhcnRzIGV4cGVjdCBhbiBvYmplY3Qgd2l0aCBhbiBcImlkXCIgcHJvcGVydHkuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwic3RhcnRfc3RlcFwiLFxuICAgICAgdmFsdWU6IHtcbiAgICAgICAgbWVzc2FnZUlkOiB2YWx1ZS5tZXNzYWdlSWRcbiAgICAgIH1cbiAgICB9O1xuICB9XG59O1xudmFyIHJlYXNvbmluZ1N0cmVhbVBhcnQgPSB7XG4gIGNvZGU6IFwiZ1wiLFxuICBuYW1lOiBcInJlYXNvbmluZ1wiLFxuICBwYXJzZTogKHZhbHVlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcInJlYXNvbmluZ1wiIHBhcnRzIGV4cGVjdCBhIHN0cmluZyB2YWx1ZS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdHlwZTogXCJyZWFzb25pbmdcIiwgdmFsdWUgfTtcbiAgfVxufTtcbnZhciBzb3VyY2VQYXJ0ID0ge1xuICBjb2RlOiBcImhcIixcbiAgbmFtZTogXCJzb3VyY2VcIixcbiAgcGFyc2U6ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcInNvdXJjZVwiIHBhcnRzIGV4cGVjdCBhIFNvdXJjZSBvYmplY3QuJyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInNvdXJjZVwiLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9XG59O1xudmFyIHJlZGFjdGVkUmVhc29uaW5nU3RyZWFtUGFydCA9IHtcbiAgY29kZTogXCJpXCIsXG4gIG5hbWU6IFwicmVkYWN0ZWRfcmVhc29uaW5nXCIsXG4gIHBhcnNlOiAodmFsdWUpID0+IHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgIShcImRhdGFcIiBpbiB2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlLmRhdGEgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1wicmVkYWN0ZWRfcmVhc29uaW5nXCIgcGFydHMgZXhwZWN0IGFuIG9iamVjdCB3aXRoIGEgXCJkYXRhXCIgcHJvcGVydHkuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdHlwZTogXCJyZWRhY3RlZF9yZWFzb25pbmdcIiwgdmFsdWU6IHsgZGF0YTogdmFsdWUuZGF0YSB9IH07XG4gIH1cbn07XG52YXIgcmVhc29uaW5nU2lnbmF0dXJlU3RyZWFtUGFydCA9IHtcbiAgY29kZTogXCJqXCIsXG4gIG5hbWU6IFwicmVhc29uaW5nX3NpZ25hdHVyZVwiLFxuICBwYXJzZTogKHZhbHVlKSA9PiB7XG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8ICEoXCJzaWduYXR1cmVcIiBpbiB2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlLnNpZ25hdHVyZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnXCJyZWFzb25pbmdfc2lnbmF0dXJlXCIgcGFydHMgZXhwZWN0IGFuIG9iamVjdCB3aXRoIGEgXCJzaWduYXR1cmVcIiBwcm9wZXJ0eS4nXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJyZWFzb25pbmdfc2lnbmF0dXJlXCIsXG4gICAgICB2YWx1ZTogeyBzaWduYXR1cmU6IHZhbHVlLnNpZ25hdHVyZSB9XG4gICAgfTtcbiAgfVxufTtcbnZhciBmaWxlU3RyZWFtUGFydCA9IHtcbiAgY29kZTogXCJrXCIsXG4gIG5hbWU6IFwiZmlsZVwiLFxuICBwYXJzZTogKHZhbHVlKSA9PiB7XG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8ICEoXCJkYXRhXCIgaW4gdmFsdWUpIHx8IHR5cGVvZiB2YWx1ZS5kYXRhICE9PSBcInN0cmluZ1wiIHx8ICEoXCJtaW1lVHlwZVwiIGluIHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUubWltZVR5cGUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1wiZmlsZVwiIHBhcnRzIGV4cGVjdCBhbiBvYmplY3Qgd2l0aCBhIFwiZGF0YVwiIGFuZCBcIm1pbWVUeXBlXCIgcHJvcGVydHkuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdHlwZTogXCJmaWxlXCIsIHZhbHVlIH07XG4gIH1cbn07XG52YXIgZGF0YVN0cmVhbVBhcnRzID0gW1xuICB0ZXh0U3RyZWFtUGFydDIsXG4gIGRhdGFTdHJlYW1QYXJ0LFxuICBlcnJvclN0cmVhbVBhcnQyLFxuICBtZXNzYWdlQW5ub3RhdGlvbnNTdHJlYW1QYXJ0LFxuICB0b29sQ2FsbFN0cmVhbVBhcnQsXG4gIHRvb2xSZXN1bHRTdHJlYW1QYXJ0LFxuICB0b29sQ2FsbFN0cmVhbWluZ1N0YXJ0U3RyZWFtUGFydCxcbiAgdG9vbENhbGxEZWx0YVN0cmVhbVBhcnQsXG4gIGZpbmlzaE1lc3NhZ2VTdHJlYW1QYXJ0LFxuICBmaW5pc2hTdGVwU3RyZWFtUGFydCxcbiAgc3RhcnRTdGVwU3RyZWFtUGFydCxcbiAgcmVhc29uaW5nU3RyZWFtUGFydCxcbiAgc291cmNlUGFydCxcbiAgcmVkYWN0ZWRSZWFzb25pbmdTdHJlYW1QYXJ0LFxuICByZWFzb25pbmdTaWduYXR1cmVTdHJlYW1QYXJ0LFxuICBmaWxlU3RyZWFtUGFydFxuXTtcbnZhciBkYXRhU3RyZWFtUGFydHNCeUNvZGUgPSBPYmplY3QuZnJvbUVudHJpZXMoXG4gIGRhdGFTdHJlYW1QYXJ0cy5tYXAoKHBhcnQpID0+IFtwYXJ0LmNvZGUsIHBhcnRdKVxuKTtcbnZhciBEYXRhU3RyZWFtU3RyaW5nUHJlZml4ZXMgPSBPYmplY3QuZnJvbUVudHJpZXMoXG4gIGRhdGFTdHJlYW1QYXJ0cy5tYXAoKHBhcnQpID0+IFtwYXJ0Lm5hbWUsIHBhcnQuY29kZV0pXG4pO1xudmFyIHZhbGlkQ29kZXMyID0gZGF0YVN0cmVhbVBhcnRzLm1hcCgocGFydCkgPT4gcGFydC5jb2RlKTtcbnZhciBwYXJzZURhdGFTdHJlYW1QYXJ0ID0gKGxpbmUpID0+IHtcbiAgY29uc3QgZmlyc3RTZXBhcmF0b3JJbmRleCA9IGxpbmUuaW5kZXhPZihcIjpcIik7XG4gIGlmIChmaXJzdFNlcGFyYXRvckluZGV4ID09PSAtMSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBwYXJzZSBzdHJlYW0gc3RyaW5nLiBObyBzZXBhcmF0b3IgZm91bmQuXCIpO1xuICB9XG4gIGNvbnN0IHByZWZpeCA9IGxpbmUuc2xpY2UoMCwgZmlyc3RTZXBhcmF0b3JJbmRleCk7XG4gIGlmICghdmFsaWRDb2RlczIuaW5jbHVkZXMocHJlZml4KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHBhcnNlIHN0cmVhbSBzdHJpbmcuIEludmFsaWQgY29kZSAke3ByZWZpeH0uYCk7XG4gIH1cbiAgY29uc3QgY29kZSA9IHByZWZpeDtcbiAgY29uc3QgdGV4dFZhbHVlID0gbGluZS5zbGljZShmaXJzdFNlcGFyYXRvckluZGV4ICsgMSk7XG4gIGNvbnN0IGpzb25WYWx1ZSA9IEpTT04ucGFyc2UodGV4dFZhbHVlKTtcbiAgcmV0dXJuIGRhdGFTdHJlYW1QYXJ0c0J5Q29kZVtjb2RlXS5wYXJzZShqc29uVmFsdWUpO1xufTtcbmZ1bmN0aW9uIGZvcm1hdERhdGFTdHJlYW1QYXJ0KHR5cGUsIHZhbHVlKSB7XG4gIGNvbnN0IHN0cmVhbVBhcnQgPSBkYXRhU3RyZWFtUGFydHMuZmluZCgocGFydCkgPT4gcGFydC5uYW1lID09PSB0eXBlKTtcbiAgaWYgKCFzdHJlYW1QYXJ0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHN0cmVhbSBwYXJ0IHR5cGU6ICR7dHlwZX1gKTtcbiAgfVxuICByZXR1cm4gYCR7c3RyZWFtUGFydC5jb2RlfToke0pTT04uc3RyaW5naWZ5KHZhbHVlKX1cbmA7XG59XG5cbi8vIHNyYy9wcm9jZXNzLWRhdGEtc3RyZWFtLnRzXG52YXIgTkVXTElORSA9IFwiXFxuXCIuY2hhckNvZGVBdCgwKTtcbmZ1bmN0aW9uIGNvbmNhdENodW5rcyhjaHVua3MsIHRvdGFsTGVuZ3RoKSB7XG4gIGNvbnN0IGNvbmNhdGVuYXRlZENodW5rcyA9IG5ldyBVaW50OEFycmF5KHRvdGFsTGVuZ3RoKTtcbiAgbGV0IG9mZnNldCA9IDA7XG4gIGZvciAoY29uc3QgY2h1bmsgb2YgY2h1bmtzKSB7XG4gICAgY29uY2F0ZW5hdGVkQ2h1bmtzLnNldChjaHVuaywgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gY2h1bmsubGVuZ3RoO1xuICB9XG4gIGNodW5rcy5sZW5ndGggPSAwO1xuICByZXR1cm4gY29uY2F0ZW5hdGVkQ2h1bmtzO1xufVxuYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc0RhdGFTdHJlYW0oe1xuICBzdHJlYW0sXG4gIG9uVGV4dFBhcnQsXG4gIG9uUmVhc29uaW5nUGFydCxcbiAgb25SZWFzb25pbmdTaWduYXR1cmVQYXJ0LFxuICBvblJlZGFjdGVkUmVhc29uaW5nUGFydCxcbiAgb25Tb3VyY2VQYXJ0LFxuICBvbkZpbGVQYXJ0LFxuICBvbkRhdGFQYXJ0LFxuICBvbkVycm9yUGFydCxcbiAgb25Ub29sQ2FsbFN0cmVhbWluZ1N0YXJ0UGFydCxcbiAgb25Ub29sQ2FsbERlbHRhUGFydCxcbiAgb25Ub29sQ2FsbFBhcnQsXG4gIG9uVG9vbFJlc3VsdFBhcnQsXG4gIG9uTWVzc2FnZUFubm90YXRpb25zUGFydCxcbiAgb25GaW5pc2hNZXNzYWdlUGFydCxcbiAgb25GaW5pc2hTdGVwUGFydCxcbiAgb25TdGFydFN0ZXBQYXJ0XG59KSB7XG4gIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5nZXRSZWFkZXIoKTtcbiAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuICBjb25zdCBjaHVua3MgPSBbXTtcbiAgbGV0IHRvdGFsTGVuZ3RoID0gMDtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBjb25zdCB7IHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgY2h1bmtzLnB1c2godmFsdWUpO1xuICAgICAgdG90YWxMZW5ndGggKz0gdmFsdWUubGVuZ3RoO1xuICAgICAgaWYgKHZhbHVlW3ZhbHVlLmxlbmd0aCAtIDFdICE9PSBORVdMSU5FKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY2h1bmtzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNvbnN0IGNvbmNhdGVuYXRlZENodW5rcyA9IGNvbmNhdENodW5rcyhjaHVua3MsIHRvdGFsTGVuZ3RoKTtcbiAgICB0b3RhbExlbmd0aCA9IDA7XG4gICAgY29uc3Qgc3RyZWFtUGFydHMgPSBkZWNvZGVyLmRlY29kZShjb25jYXRlbmF0ZWRDaHVua3MsIHsgc3RyZWFtOiB0cnVlIH0pLnNwbGl0KFwiXFxuXCIpLmZpbHRlcigobGluZSkgPT4gbGluZSAhPT0gXCJcIikubWFwKHBhcnNlRGF0YVN0cmVhbVBhcnQpO1xuICAgIGZvciAoY29uc3QgeyB0eXBlLCB2YWx1ZTogdmFsdWUyIH0gb2Ygc3RyZWFtUGFydHMpIHtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFwidGV4dFwiOlxuICAgICAgICAgIGF3YWl0IChvblRleHRQYXJ0ID09IG51bGwgPyB2b2lkIDAgOiBvblRleHRQYXJ0KHZhbHVlMikpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwicmVhc29uaW5nXCI6XG4gICAgICAgICAgYXdhaXQgKG9uUmVhc29uaW5nUGFydCA9PSBudWxsID8gdm9pZCAwIDogb25SZWFzb25pbmdQYXJ0KHZhbHVlMikpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwicmVhc29uaW5nX3NpZ25hdHVyZVwiOlxuICAgICAgICAgIGF3YWl0IChvblJlYXNvbmluZ1NpZ25hdHVyZVBhcnQgPT0gbnVsbCA/IHZvaWQgMCA6IG9uUmVhc29uaW5nU2lnbmF0dXJlUGFydCh2YWx1ZTIpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInJlZGFjdGVkX3JlYXNvbmluZ1wiOlxuICAgICAgICAgIGF3YWl0IChvblJlZGFjdGVkUmVhc29uaW5nUGFydCA9PSBudWxsID8gdm9pZCAwIDogb25SZWRhY3RlZFJlYXNvbmluZ1BhcnQodmFsdWUyKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJmaWxlXCI6XG4gICAgICAgICAgYXdhaXQgKG9uRmlsZVBhcnQgPT0gbnVsbCA/IHZvaWQgMCA6IG9uRmlsZVBhcnQodmFsdWUyKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJzb3VyY2VcIjpcbiAgICAgICAgICBhd2FpdCAob25Tb3VyY2VQYXJ0ID09IG51bGwgPyB2b2lkIDAgOiBvblNvdXJjZVBhcnQodmFsdWUyKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJkYXRhXCI6XG4gICAgICAgICAgYXdhaXQgKG9uRGF0YVBhcnQgPT0gbnVsbCA/IHZvaWQgMCA6IG9uRGF0YVBhcnQodmFsdWUyKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJlcnJvclwiOlxuICAgICAgICAgIGF3YWl0IChvbkVycm9yUGFydCA9PSBudWxsID8gdm9pZCAwIDogb25FcnJvclBhcnQodmFsdWUyKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJtZXNzYWdlX2Fubm90YXRpb25zXCI6XG4gICAgICAgICAgYXdhaXQgKG9uTWVzc2FnZUFubm90YXRpb25zUGFydCA9PSBudWxsID8gdm9pZCAwIDogb25NZXNzYWdlQW5ub3RhdGlvbnNQYXJ0KHZhbHVlMikpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwidG9vbF9jYWxsX3N0cmVhbWluZ19zdGFydFwiOlxuICAgICAgICAgIGF3YWl0IChvblRvb2xDYWxsU3RyZWFtaW5nU3RhcnRQYXJ0ID09IG51bGwgPyB2b2lkIDAgOiBvblRvb2xDYWxsU3RyZWFtaW5nU3RhcnRQYXJ0KHZhbHVlMikpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwidG9vbF9jYWxsX2RlbHRhXCI6XG4gICAgICAgICAgYXdhaXQgKG9uVG9vbENhbGxEZWx0YVBhcnQgPT0gbnVsbCA/IHZvaWQgMCA6IG9uVG9vbENhbGxEZWx0YVBhcnQodmFsdWUyKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ0b29sX2NhbGxcIjpcbiAgICAgICAgICBhd2FpdCAob25Ub29sQ2FsbFBhcnQgPT0gbnVsbCA/IHZvaWQgMCA6IG9uVG9vbENhbGxQYXJ0KHZhbHVlMikpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwidG9vbF9yZXN1bHRcIjpcbiAgICAgICAgICBhd2FpdCAob25Ub29sUmVzdWx0UGFydCA9PSBudWxsID8gdm9pZCAwIDogb25Ub29sUmVzdWx0UGFydCh2YWx1ZTIpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImZpbmlzaF9tZXNzYWdlXCI6XG4gICAgICAgICAgYXdhaXQgKG9uRmluaXNoTWVzc2FnZVBhcnQgPT0gbnVsbCA/IHZvaWQgMCA6IG9uRmluaXNoTWVzc2FnZVBhcnQodmFsdWUyKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJmaW5pc2hfc3RlcFwiOlxuICAgICAgICAgIGF3YWl0IChvbkZpbmlzaFN0ZXBQYXJ0ID09IG51bGwgPyB2b2lkIDAgOiBvbkZpbmlzaFN0ZXBQYXJ0KHZhbHVlMikpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwic3RhcnRfc3RlcFwiOlxuICAgICAgICAgIGF3YWl0IChvblN0YXJ0U3RlcFBhcnQgPT0gbnVsbCA/IHZvaWQgMCA6IG9uU3RhcnRTdGVwUGFydCh2YWx1ZTIpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgIGNvbnN0IGV4aGF1c3RpdmVDaGVjayA9IHR5cGU7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHN0cmVhbSBwYXJ0IHR5cGU6ICR7ZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIHNyYy9wcm9jZXNzLWNoYXQtcmVzcG9uc2UudHNcbmFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NDaGF0UmVzcG9uc2Uoe1xuICBzdHJlYW0sXG4gIHVwZGF0ZSxcbiAgb25Ub29sQ2FsbCxcbiAgb25GaW5pc2gsXG4gIGdlbmVyYXRlSWQ6IGdlbmVyYXRlSWQyID0gZ2VuZXJhdGVJZEZ1bmN0aW9uLFxuICBnZXRDdXJyZW50RGF0ZSA9ICgpID0+IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpLFxuICBsYXN0TWVzc2FnZVxufSkge1xuICB2YXIgX2EsIF9iO1xuICBjb25zdCByZXBsYWNlTGFzdE1lc3NhZ2UgPSAobGFzdE1lc3NhZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IGxhc3RNZXNzYWdlLnJvbGUpID09PSBcImFzc2lzdGFudFwiO1xuICBsZXQgc3RlcCA9IHJlcGxhY2VMYXN0TWVzc2FnZSA/IDEgKyAvLyBmaW5kIG1heCBzdGVwIGluIGV4aXN0aW5nIHRvb2wgaW52b2NhdGlvbnM6XG4gICgoX2IgPSAoX2EgPSBsYXN0TWVzc2FnZS50b29sSW52b2NhdGlvbnMpID09IG51bGwgPyB2b2lkIDAgOiBfYS5yZWR1Y2UoKG1heCwgdG9vbEludm9jYXRpb24pID0+IHtcbiAgICB2YXIgX2EyO1xuICAgIHJldHVybiBNYXRoLm1heChtYXgsIChfYTIgPSB0b29sSW52b2NhdGlvbi5zdGVwKSAhPSBudWxsID8gX2EyIDogMCk7XG4gIH0sIDApKSAhPSBudWxsID8gX2IgOiAwKSA6IDA7XG4gIGNvbnN0IG1lc3NhZ2UgPSByZXBsYWNlTGFzdE1lc3NhZ2UgPyBzdHJ1Y3R1cmVkQ2xvbmUobGFzdE1lc3NhZ2UpIDoge1xuICAgIGlkOiBnZW5lcmF0ZUlkMigpLFxuICAgIGNyZWF0ZWRBdDogZ2V0Q3VycmVudERhdGUoKSxcbiAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgIGNvbnRlbnQ6IFwiXCIsXG4gICAgcGFydHM6IFtdXG4gIH07XG4gIGxldCBjdXJyZW50VGV4dFBhcnQgPSB2b2lkIDA7XG4gIGxldCBjdXJyZW50UmVhc29uaW5nUGFydCA9IHZvaWQgMDtcbiAgbGV0IGN1cnJlbnRSZWFzb25pbmdUZXh0RGV0YWlsID0gdm9pZCAwO1xuICBmdW5jdGlvbiB1cGRhdGVUb29sSW52b2NhdGlvblBhcnQodG9vbENhbGxJZCwgaW52b2NhdGlvbikge1xuICAgIGNvbnN0IHBhcnQgPSBtZXNzYWdlLnBhcnRzLmZpbmQoXG4gICAgICAocGFydDIpID0+IHBhcnQyLnR5cGUgPT09IFwidG9vbC1pbnZvY2F0aW9uXCIgJiYgcGFydDIudG9vbEludm9jYXRpb24udG9vbENhbGxJZCA9PT0gdG9vbENhbGxJZFxuICAgICk7XG4gICAgaWYgKHBhcnQgIT0gbnVsbCkge1xuICAgICAgcGFydC50b29sSW52b2NhdGlvbiA9IGludm9jYXRpb247XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lc3NhZ2UucGFydHMucHVzaCh7XG4gICAgICAgIHR5cGU6IFwidG9vbC1pbnZvY2F0aW9uXCIsXG4gICAgICAgIHRvb2xJbnZvY2F0aW9uOiBpbnZvY2F0aW9uXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgY29uc3QgZGF0YSA9IFtdO1xuICBsZXQgbWVzc2FnZUFubm90YXRpb25zID0gcmVwbGFjZUxhc3RNZXNzYWdlID8gbGFzdE1lc3NhZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IGxhc3RNZXNzYWdlLmFubm90YXRpb25zIDogdm9pZCAwO1xuICBjb25zdCBwYXJ0aWFsVG9vbENhbGxzID0ge307XG4gIGxldCB1c2FnZSA9IHtcbiAgICBjb21wbGV0aW9uVG9rZW5zOiBOYU4sXG4gICAgcHJvbXB0VG9rZW5zOiBOYU4sXG4gICAgdG90YWxUb2tlbnM6IE5hTlxuICB9O1xuICBsZXQgZmluaXNoUmVhc29uID0gXCJ1bmtub3duXCI7XG4gIGZ1bmN0aW9uIGV4ZWNVcGRhdGUoKSB7XG4gICAgY29uc3QgY29waWVkRGF0YSA9IFsuLi5kYXRhXTtcbiAgICBpZiAobWVzc2FnZUFubm90YXRpb25zID09IG51bGwgPyB2b2lkIDAgOiBtZXNzYWdlQW5ub3RhdGlvbnMubGVuZ3RoKSB7XG4gICAgICBtZXNzYWdlLmFubm90YXRpb25zID0gbWVzc2FnZUFubm90YXRpb25zO1xuICAgIH1cbiAgICBjb25zdCBjb3BpZWRNZXNzYWdlID0ge1xuICAgICAgLy8gZGVlcCBjb3B5IHRoZSBtZXNzYWdlIHRvIGVuc3VyZSB0aGF0IGRlZXAgY2hhbmdlcyAobXNnIGF0dGFjaG1lbnRzKSBhcmUgdXBkYXRlZFxuICAgICAgLy8gd2l0aCBTb2xpZEpTLiBTb2xpZEpTIHVzZXMgcmVmZXJlbnRpYWwgaW50ZWdyYXRpb24gb2Ygc3ViLW9iamVjdHMgdG8gZGV0ZWN0IGNoYW5nZXMuXG4gICAgICAuLi5zdHJ1Y3R1cmVkQ2xvbmUobWVzc2FnZSksXG4gICAgICAvLyBhZGQgYSByZXZpc2lvbiBpZCB0byBlbnN1cmUgdGhhdCB0aGUgbWVzc2FnZSBpcyB1cGRhdGVkIHdpdGggU1dSLiBTV1IgdXNlcyBhXG4gICAgICAvLyBoYXNoaW5nIGFwcHJvYWNoIGJ5IGRlZmF1bHQgdG8gZGV0ZWN0IGNoYW5nZXMsIGJ1dCBpdCBvbmx5IHdvcmtzIGZvciBzaGFsbG93XG4gICAgICAvLyBjaGFuZ2VzLiBUaGlzIGlzIHdoeSB3ZSBuZWVkIHRvIGFkZCBhIHJldmlzaW9uIGlkIHRvIGVuc3VyZSB0aGF0IHRoZSBtZXNzYWdlXG4gICAgICAvLyBpcyB1cGRhdGVkIHdpdGggU1dSICh3aXRob3V0IGl0LCB0aGUgY2hhbmdlcyBnZXQgc3R1Y2sgaW4gU1dSIGFuZCBhcmUgbm90XG4gICAgICAvLyBmb3J3YXJkZWQgdG8gcmVuZGVyaW5nKTpcbiAgICAgIHJldmlzaW9uSWQ6IGdlbmVyYXRlSWQyKClcbiAgICB9O1xuICAgIHVwZGF0ZSh7XG4gICAgICBtZXNzYWdlOiBjb3BpZWRNZXNzYWdlLFxuICAgICAgZGF0YTogY29waWVkRGF0YSxcbiAgICAgIHJlcGxhY2VMYXN0TWVzc2FnZVxuICAgIH0pO1xuICB9XG4gIGF3YWl0IHByb2Nlc3NEYXRhU3RyZWFtKHtcbiAgICBzdHJlYW0sXG4gICAgb25UZXh0UGFydCh2YWx1ZSkge1xuICAgICAgaWYgKGN1cnJlbnRUZXh0UGFydCA9PSBudWxsKSB7XG4gICAgICAgIGN1cnJlbnRUZXh0UGFydCA9IHtcbiAgICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgICB0ZXh0OiB2YWx1ZVxuICAgICAgICB9O1xuICAgICAgICBtZXNzYWdlLnBhcnRzLnB1c2goY3VycmVudFRleHRQYXJ0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnJlbnRUZXh0UGFydC50ZXh0ICs9IHZhbHVlO1xuICAgICAgfVxuICAgICAgbWVzc2FnZS5jb250ZW50ICs9IHZhbHVlO1xuICAgICAgZXhlY1VwZGF0ZSgpO1xuICAgIH0sXG4gICAgb25SZWFzb25pbmdQYXJ0KHZhbHVlKSB7XG4gICAgICB2YXIgX2EyO1xuICAgICAgaWYgKGN1cnJlbnRSZWFzb25pbmdUZXh0RGV0YWlsID09IG51bGwpIHtcbiAgICAgICAgY3VycmVudFJlYXNvbmluZ1RleHREZXRhaWwgPSB7IHR5cGU6IFwidGV4dFwiLCB0ZXh0OiB2YWx1ZSB9O1xuICAgICAgICBpZiAoY3VycmVudFJlYXNvbmluZ1BhcnQgIT0gbnVsbCkge1xuICAgICAgICAgIGN1cnJlbnRSZWFzb25pbmdQYXJ0LmRldGFpbHMucHVzaChjdXJyZW50UmVhc29uaW5nVGV4dERldGFpbCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnJlbnRSZWFzb25pbmdUZXh0RGV0YWlsLnRleHQgKz0gdmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudFJlYXNvbmluZ1BhcnQgPT0gbnVsbCkge1xuICAgICAgICBjdXJyZW50UmVhc29uaW5nUGFydCA9IHtcbiAgICAgICAgICB0eXBlOiBcInJlYXNvbmluZ1wiLFxuICAgICAgICAgIHJlYXNvbmluZzogdmFsdWUsXG4gICAgICAgICAgZGV0YWlsczogW2N1cnJlbnRSZWFzb25pbmdUZXh0RGV0YWlsXVxuICAgICAgICB9O1xuICAgICAgICBtZXNzYWdlLnBhcnRzLnB1c2goY3VycmVudFJlYXNvbmluZ1BhcnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3VycmVudFJlYXNvbmluZ1BhcnQucmVhc29uaW5nICs9IHZhbHVlO1xuICAgICAgfVxuICAgICAgbWVzc2FnZS5yZWFzb25pbmcgPSAoKF9hMiA9IG1lc3NhZ2UucmVhc29uaW5nKSAhPSBudWxsID8gX2EyIDogXCJcIikgKyB2YWx1ZTtcbiAgICAgIGV4ZWNVcGRhdGUoKTtcbiAgICB9LFxuICAgIG9uUmVhc29uaW5nU2lnbmF0dXJlUGFydCh2YWx1ZSkge1xuICAgICAgaWYgKGN1cnJlbnRSZWFzb25pbmdUZXh0RGV0YWlsICE9IG51bGwpIHtcbiAgICAgICAgY3VycmVudFJlYXNvbmluZ1RleHREZXRhaWwuc2lnbmF0dXJlID0gdmFsdWUuc2lnbmF0dXJlO1xuICAgICAgfVxuICAgIH0sXG4gICAgb25SZWRhY3RlZFJlYXNvbmluZ1BhcnQodmFsdWUpIHtcbiAgICAgIGlmIChjdXJyZW50UmVhc29uaW5nUGFydCA9PSBudWxsKSB7XG4gICAgICAgIGN1cnJlbnRSZWFzb25pbmdQYXJ0ID0ge1xuICAgICAgICAgIHR5cGU6IFwicmVhc29uaW5nXCIsXG4gICAgICAgICAgcmVhc29uaW5nOiBcIlwiLFxuICAgICAgICAgIGRldGFpbHM6IFtdXG4gICAgICAgIH07XG4gICAgICAgIG1lc3NhZ2UucGFydHMucHVzaChjdXJyZW50UmVhc29uaW5nUGFydCk7XG4gICAgICB9XG4gICAgICBjdXJyZW50UmVhc29uaW5nUGFydC5kZXRhaWxzLnB1c2goe1xuICAgICAgICB0eXBlOiBcInJlZGFjdGVkXCIsXG4gICAgICAgIGRhdGE6IHZhbHVlLmRhdGFcbiAgICAgIH0pO1xuICAgICAgY3VycmVudFJlYXNvbmluZ1RleHREZXRhaWwgPSB2b2lkIDA7XG4gICAgICBleGVjVXBkYXRlKCk7XG4gICAgfSxcbiAgICBvbkZpbGVQYXJ0KHZhbHVlKSB7XG4gICAgICBtZXNzYWdlLnBhcnRzLnB1c2goe1xuICAgICAgICB0eXBlOiBcImZpbGVcIixcbiAgICAgICAgbWltZVR5cGU6IHZhbHVlLm1pbWVUeXBlLFxuICAgICAgICBkYXRhOiB2YWx1ZS5kYXRhXG4gICAgICB9KTtcbiAgICAgIGV4ZWNVcGRhdGUoKTtcbiAgICB9LFxuICAgIG9uU291cmNlUGFydCh2YWx1ZSkge1xuICAgICAgbWVzc2FnZS5wYXJ0cy5wdXNoKHtcbiAgICAgICAgdHlwZTogXCJzb3VyY2VcIixcbiAgICAgICAgc291cmNlOiB2YWx1ZVxuICAgICAgfSk7XG4gICAgICBleGVjVXBkYXRlKCk7XG4gICAgfSxcbiAgICBvblRvb2xDYWxsU3RyZWFtaW5nU3RhcnRQYXJ0KHZhbHVlKSB7XG4gICAgICBpZiAobWVzc2FnZS50b29sSW52b2NhdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICBtZXNzYWdlLnRvb2xJbnZvY2F0aW9ucyA9IFtdO1xuICAgICAgfVxuICAgICAgcGFydGlhbFRvb2xDYWxsc1t2YWx1ZS50b29sQ2FsbElkXSA9IHtcbiAgICAgICAgdGV4dDogXCJcIixcbiAgICAgICAgc3RlcCxcbiAgICAgICAgdG9vbE5hbWU6IHZhbHVlLnRvb2xOYW1lLFxuICAgICAgICBpbmRleDogbWVzc2FnZS50b29sSW52b2NhdGlvbnMubGVuZ3RoXG4gICAgICB9O1xuICAgICAgY29uc3QgaW52b2NhdGlvbiA9IHtcbiAgICAgICAgc3RhdGU6IFwicGFydGlhbC1jYWxsXCIsXG4gICAgICAgIHN0ZXAsXG4gICAgICAgIHRvb2xDYWxsSWQ6IHZhbHVlLnRvb2xDYWxsSWQsXG4gICAgICAgIHRvb2xOYW1lOiB2YWx1ZS50b29sTmFtZSxcbiAgICAgICAgYXJnczogdm9pZCAwXG4gICAgICB9O1xuICAgICAgbWVzc2FnZS50b29sSW52b2NhdGlvbnMucHVzaChpbnZvY2F0aW9uKTtcbiAgICAgIHVwZGF0ZVRvb2xJbnZvY2F0aW9uUGFydCh2YWx1ZS50b29sQ2FsbElkLCBpbnZvY2F0aW9uKTtcbiAgICAgIGV4ZWNVcGRhdGUoKTtcbiAgICB9LFxuICAgIG9uVG9vbENhbGxEZWx0YVBhcnQodmFsdWUpIHtcbiAgICAgIGNvbnN0IHBhcnRpYWxUb29sQ2FsbCA9IHBhcnRpYWxUb29sQ2FsbHNbdmFsdWUudG9vbENhbGxJZF07XG4gICAgICBwYXJ0aWFsVG9vbENhbGwudGV4dCArPSB2YWx1ZS5hcmdzVGV4dERlbHRhO1xuICAgICAgY29uc3QgeyB2YWx1ZTogcGFydGlhbEFyZ3MgfSA9IHBhcnNlUGFydGlhbEpzb24ocGFydGlhbFRvb2xDYWxsLnRleHQpO1xuICAgICAgY29uc3QgaW52b2NhdGlvbiA9IHtcbiAgICAgICAgc3RhdGU6IFwicGFydGlhbC1jYWxsXCIsXG4gICAgICAgIHN0ZXA6IHBhcnRpYWxUb29sQ2FsbC5zdGVwLFxuICAgICAgICB0b29sQ2FsbElkOiB2YWx1ZS50b29sQ2FsbElkLFxuICAgICAgICB0b29sTmFtZTogcGFydGlhbFRvb2xDYWxsLnRvb2xOYW1lLFxuICAgICAgICBhcmdzOiBwYXJ0aWFsQXJnc1xuICAgICAgfTtcbiAgICAgIG1lc3NhZ2UudG9vbEludm9jYXRpb25zW3BhcnRpYWxUb29sQ2FsbC5pbmRleF0gPSBpbnZvY2F0aW9uO1xuICAgICAgdXBkYXRlVG9vbEludm9jYXRpb25QYXJ0KHZhbHVlLnRvb2xDYWxsSWQsIGludm9jYXRpb24pO1xuICAgICAgZXhlY1VwZGF0ZSgpO1xuICAgIH0sXG4gICAgYXN5bmMgb25Ub29sQ2FsbFBhcnQodmFsdWUpIHtcbiAgICAgIGNvbnN0IGludm9jYXRpb24gPSB7XG4gICAgICAgIHN0YXRlOiBcImNhbGxcIixcbiAgICAgICAgc3RlcCxcbiAgICAgICAgLi4udmFsdWVcbiAgICAgIH07XG4gICAgICBpZiAocGFydGlhbFRvb2xDYWxsc1t2YWx1ZS50b29sQ2FsbElkXSAhPSBudWxsKSB7XG4gICAgICAgIG1lc3NhZ2UudG9vbEludm9jYXRpb25zW3BhcnRpYWxUb29sQ2FsbHNbdmFsdWUudG9vbENhbGxJZF0uaW5kZXhdID0gaW52b2NhdGlvbjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChtZXNzYWdlLnRvb2xJbnZvY2F0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgICAgbWVzc2FnZS50b29sSW52b2NhdGlvbnMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBtZXNzYWdlLnRvb2xJbnZvY2F0aW9ucy5wdXNoKGludm9jYXRpb24pO1xuICAgICAgfVxuICAgICAgdXBkYXRlVG9vbEludm9jYXRpb25QYXJ0KHZhbHVlLnRvb2xDYWxsSWQsIGludm9jYXRpb24pO1xuICAgICAgZXhlY1VwZGF0ZSgpO1xuICAgICAgaWYgKG9uVG9vbENhbGwpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgb25Ub29sQ2FsbCh7IHRvb2xDYWxsOiB2YWx1ZSB9KTtcbiAgICAgICAgaWYgKHJlc3VsdCAhPSBudWxsKSB7XG4gICAgICAgICAgY29uc3QgaW52b2NhdGlvbjIgPSB7XG4gICAgICAgICAgICBzdGF0ZTogXCJyZXN1bHRcIixcbiAgICAgICAgICAgIHN0ZXAsXG4gICAgICAgICAgICAuLi52YWx1ZSxcbiAgICAgICAgICAgIHJlc3VsdFxuICAgICAgICAgIH07XG4gICAgICAgICAgbWVzc2FnZS50b29sSW52b2NhdGlvbnNbbWVzc2FnZS50b29sSW52b2NhdGlvbnMubGVuZ3RoIC0gMV0gPSBpbnZvY2F0aW9uMjtcbiAgICAgICAgICB1cGRhdGVUb29sSW52b2NhdGlvblBhcnQodmFsdWUudG9vbENhbGxJZCwgaW52b2NhdGlvbjIpO1xuICAgICAgICAgIGV4ZWNVcGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgb25Ub29sUmVzdWx0UGFydCh2YWx1ZSkge1xuICAgICAgY29uc3QgdG9vbEludm9jYXRpb25zID0gbWVzc2FnZS50b29sSW52b2NhdGlvbnM7XG4gICAgICBpZiAodG9vbEludm9jYXRpb25zID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidG9vbF9yZXN1bHQgbXVzdCBiZSBwcmVjZWRlZCBieSBhIHRvb2xfY2FsbFwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRvb2xJbnZvY2F0aW9uSW5kZXggPSB0b29sSW52b2NhdGlvbnMuZmluZEluZGV4KFxuICAgICAgICAoaW52b2NhdGlvbjIpID0+IGludm9jYXRpb24yLnRvb2xDYWxsSWQgPT09IHZhbHVlLnRvb2xDYWxsSWRcbiAgICAgICk7XG4gICAgICBpZiAodG9vbEludm9jYXRpb25JbmRleCA9PT0gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwidG9vbF9yZXN1bHQgbXVzdCBiZSBwcmVjZWRlZCBieSBhIHRvb2xfY2FsbCB3aXRoIHRoZSBzYW1lIHRvb2xDYWxsSWRcIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29uc3QgaW52b2NhdGlvbiA9IHtcbiAgICAgICAgLi4udG9vbEludm9jYXRpb25zW3Rvb2xJbnZvY2F0aW9uSW5kZXhdLFxuICAgICAgICBzdGF0ZTogXCJyZXN1bHRcIixcbiAgICAgICAgLi4udmFsdWVcbiAgICAgIH07XG4gICAgICB0b29sSW52b2NhdGlvbnNbdG9vbEludm9jYXRpb25JbmRleF0gPSBpbnZvY2F0aW9uO1xuICAgICAgdXBkYXRlVG9vbEludm9jYXRpb25QYXJ0KHZhbHVlLnRvb2xDYWxsSWQsIGludm9jYXRpb24pO1xuICAgICAgZXhlY1VwZGF0ZSgpO1xuICAgIH0sXG4gICAgb25EYXRhUGFydCh2YWx1ZSkge1xuICAgICAgZGF0YS5wdXNoKC4uLnZhbHVlKTtcbiAgICAgIGV4ZWNVcGRhdGUoKTtcbiAgICB9LFxuICAgIG9uTWVzc2FnZUFubm90YXRpb25zUGFydCh2YWx1ZSkge1xuICAgICAgaWYgKG1lc3NhZ2VBbm5vdGF0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgIG1lc3NhZ2VBbm5vdGF0aW9ucyA9IFsuLi52YWx1ZV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtZXNzYWdlQW5ub3RhdGlvbnMucHVzaCguLi52YWx1ZSk7XG4gICAgICB9XG4gICAgICBleGVjVXBkYXRlKCk7XG4gICAgfSxcbiAgICBvbkZpbmlzaFN0ZXBQYXJ0KHZhbHVlKSB7XG4gICAgICBzdGVwICs9IDE7XG4gICAgICBjdXJyZW50VGV4dFBhcnQgPSB2YWx1ZS5pc0NvbnRpbnVlZCA/IGN1cnJlbnRUZXh0UGFydCA6IHZvaWQgMDtcbiAgICAgIGN1cnJlbnRSZWFzb25pbmdQYXJ0ID0gdm9pZCAwO1xuICAgICAgY3VycmVudFJlYXNvbmluZ1RleHREZXRhaWwgPSB2b2lkIDA7XG4gICAgfSxcbiAgICBvblN0YXJ0U3RlcFBhcnQodmFsdWUpIHtcbiAgICAgIGlmICghcmVwbGFjZUxhc3RNZXNzYWdlKSB7XG4gICAgICAgIG1lc3NhZ2UuaWQgPSB2YWx1ZS5tZXNzYWdlSWQ7XG4gICAgICB9XG4gICAgICBtZXNzYWdlLnBhcnRzLnB1c2goeyB0eXBlOiBcInN0ZXAtc3RhcnRcIiB9KTtcbiAgICAgIGV4ZWNVcGRhdGUoKTtcbiAgICB9LFxuICAgIG9uRmluaXNoTWVzc2FnZVBhcnQodmFsdWUpIHtcbiAgICAgIGZpbmlzaFJlYXNvbiA9IHZhbHVlLmZpbmlzaFJlYXNvbjtcbiAgICAgIGlmICh2YWx1ZS51c2FnZSAhPSBudWxsKSB7XG4gICAgICAgIHVzYWdlID0gY2FsY3VsYXRlTGFuZ3VhZ2VNb2RlbFVzYWdlKHZhbHVlLnVzYWdlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG9uRXJyb3JQYXJ0KGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgfSk7XG4gIG9uRmluaXNoID09IG51bGwgPyB2b2lkIDAgOiBvbkZpbmlzaCh7IG1lc3NhZ2UsIGZpbmlzaFJlYXNvbiwgdXNhZ2UgfSk7XG59XG5cbi8vIHNyYy9wcm9jZXNzLWNoYXQtdGV4dC1yZXNwb25zZS50c1xuaW1wb3J0IHsgZ2VuZXJhdGVJZCBhcyBnZW5lcmF0ZUlkRnVuY3Rpb24yIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcblxuLy8gc3JjL3Byb2Nlc3MtdGV4dC1zdHJlYW0udHNcbmFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NUZXh0U3RyZWFtKHtcbiAgc3RyZWFtLFxuICBvblRleHRQYXJ0XG59KSB7XG4gIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5waXBlVGhyb3VnaChuZXcgVGV4dERlY29kZXJTdHJlYW0oKSkuZ2V0UmVhZGVyKCk7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICBpZiAoZG9uZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGF3YWl0IG9uVGV4dFBhcnQodmFsdWUpO1xuICB9XG59XG5cbi8vIHNyYy9wcm9jZXNzLWNoYXQtdGV4dC1yZXNwb25zZS50c1xuYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc0NoYXRUZXh0UmVzcG9uc2Uoe1xuICBzdHJlYW0sXG4gIHVwZGF0ZSxcbiAgb25GaW5pc2gsXG4gIGdldEN1cnJlbnREYXRlID0gKCkgPT4gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCksXG4gIGdlbmVyYXRlSWQ6IGdlbmVyYXRlSWQyID0gZ2VuZXJhdGVJZEZ1bmN0aW9uMlxufSkge1xuICBjb25zdCB0ZXh0UGFydCA9IHsgdHlwZTogXCJ0ZXh0XCIsIHRleHQ6IFwiXCIgfTtcbiAgY29uc3QgcmVzdWx0TWVzc2FnZSA9IHtcbiAgICBpZDogZ2VuZXJhdGVJZDIoKSxcbiAgICBjcmVhdGVkQXQ6IGdldEN1cnJlbnREYXRlKCksXG4gICAgcm9sZTogXCJhc3Npc3RhbnRcIixcbiAgICBjb250ZW50OiBcIlwiLFxuICAgIHBhcnRzOiBbdGV4dFBhcnRdXG4gIH07XG4gIGF3YWl0IHByb2Nlc3NUZXh0U3RyZWFtKHtcbiAgICBzdHJlYW0sXG4gICAgb25UZXh0UGFydDogKGNodW5rKSA9PiB7XG4gICAgICByZXN1bHRNZXNzYWdlLmNvbnRlbnQgKz0gY2h1bms7XG4gICAgICB0ZXh0UGFydC50ZXh0ICs9IGNodW5rO1xuICAgICAgdXBkYXRlKHtcbiAgICAgICAgbWVzc2FnZTogeyAuLi5yZXN1bHRNZXNzYWdlIH0sXG4gICAgICAgIGRhdGE6IFtdLFxuICAgICAgICByZXBsYWNlTGFzdE1lc3NhZ2U6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICBvbkZpbmlzaCA9PSBudWxsID8gdm9pZCAwIDogb25GaW5pc2gocmVzdWx0TWVzc2FnZSwge1xuICAgIHVzYWdlOiB7IGNvbXBsZXRpb25Ub2tlbnM6IE5hTiwgcHJvbXB0VG9rZW5zOiBOYU4sIHRvdGFsVG9rZW5zOiBOYU4gfSxcbiAgICBmaW5pc2hSZWFzb246IFwidW5rbm93blwiXG4gIH0pO1xufVxuXG4vLyBzcmMvY2FsbC1jaGF0LWFwaS50c1xudmFyIGdldE9yaWdpbmFsRmV0Y2ggPSAoKSA9PiBmZXRjaDtcbmFzeW5jIGZ1bmN0aW9uIGNhbGxDaGF0QXBpKHtcbiAgYXBpLFxuICBib2R5LFxuICBzdHJlYW1Qcm90b2NvbCA9IFwiZGF0YVwiLFxuICBjcmVkZW50aWFscyxcbiAgaGVhZGVycyxcbiAgYWJvcnRDb250cm9sbGVyLFxuICByZXN0b3JlTWVzc2FnZXNPbkZhaWx1cmUsXG4gIG9uUmVzcG9uc2UsXG4gIG9uVXBkYXRlLFxuICBvbkZpbmlzaCxcbiAgb25Ub29sQ2FsbCxcbiAgZ2VuZXJhdGVJZDogZ2VuZXJhdGVJZDIsXG4gIGZldGNoOiBmZXRjaDIgPSBnZXRPcmlnaW5hbEZldGNoKCksXG4gIGxhc3RNZXNzYWdlXG59KSB7XG4gIHZhciBfYSwgX2I7XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2gyKGFwaSwge1xuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgaGVhZGVyczoge1xuICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAuLi5oZWFkZXJzXG4gICAgfSxcbiAgICBzaWduYWw6IChfYSA9IGFib3J0Q29udHJvbGxlciA9PSBudWxsID8gdm9pZCAwIDogYWJvcnRDb250cm9sbGVyKCkpID09IG51bGwgPyB2b2lkIDAgOiBfYS5zaWduYWwsXG4gICAgY3JlZGVudGlhbHNcbiAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgIHJlc3RvcmVNZXNzYWdlc09uRmFpbHVyZSgpO1xuICAgIHRocm93IGVycjtcbiAgfSk7XG4gIGlmIChvblJlc3BvbnNlKSB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IG9uUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgfVxuICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgcmVzdG9yZU1lc3NhZ2VzT25GYWlsdXJlKCk7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgKF9iID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpKSAhPSBudWxsID8gX2IgOiBcIkZhaWxlZCB0byBmZXRjaCB0aGUgY2hhdCByZXNwb25zZS5cIlxuICAgICk7XG4gIH1cbiAgaWYgKCFyZXNwb25zZS5ib2R5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHJlc3BvbnNlIGJvZHkgaXMgZW1wdHkuXCIpO1xuICB9XG4gIHN3aXRjaCAoc3RyZWFtUHJvdG9jb2wpIHtcbiAgICBjYXNlIFwidGV4dFwiOiB7XG4gICAgICBhd2FpdCBwcm9jZXNzQ2hhdFRleHRSZXNwb25zZSh7XG4gICAgICAgIHN0cmVhbTogcmVzcG9uc2UuYm9keSxcbiAgICAgICAgdXBkYXRlOiBvblVwZGF0ZSxcbiAgICAgICAgb25GaW5pc2gsXG4gICAgICAgIGdlbmVyYXRlSWQ6IGdlbmVyYXRlSWQyXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FzZSBcImRhdGFcIjoge1xuICAgICAgYXdhaXQgcHJvY2Vzc0NoYXRSZXNwb25zZSh7XG4gICAgICAgIHN0cmVhbTogcmVzcG9uc2UuYm9keSxcbiAgICAgICAgdXBkYXRlOiBvblVwZGF0ZSxcbiAgICAgICAgbGFzdE1lc3NhZ2UsXG4gICAgICAgIG9uVG9vbENhbGwsXG4gICAgICAgIG9uRmluaXNoKHsgbWVzc2FnZSwgZmluaXNoUmVhc29uLCB1c2FnZSB9KSB7XG4gICAgICAgICAgaWYgKG9uRmluaXNoICYmIG1lc3NhZ2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgb25GaW5pc2gobWVzc2FnZSwgeyB1c2FnZSwgZmluaXNoUmVhc29uIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZ2VuZXJhdGVJZDogZ2VuZXJhdGVJZDJcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICBjb25zdCBleGhhdXN0aXZlQ2hlY2sgPSBzdHJlYW1Qcm90b2NvbDtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBzdHJlYW0gcHJvdG9jb2w6ICR7ZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgIH1cbiAgfVxufVxuXG4vLyBzcmMvY2FsbC1jb21wbGV0aW9uLWFwaS50c1xudmFyIGdldE9yaWdpbmFsRmV0Y2gyID0gKCkgPT4gZmV0Y2g7XG5hc3luYyBmdW5jdGlvbiBjYWxsQ29tcGxldGlvbkFwaSh7XG4gIGFwaSxcbiAgcHJvbXB0LFxuICBjcmVkZW50aWFscyxcbiAgaGVhZGVycyxcbiAgYm9keSxcbiAgc3RyZWFtUHJvdG9jb2wgPSBcImRhdGFcIixcbiAgc2V0Q29tcGxldGlvbixcbiAgc2V0TG9hZGluZyxcbiAgc2V0RXJyb3IsXG4gIHNldEFib3J0Q29udHJvbGxlcixcbiAgb25SZXNwb25zZSxcbiAgb25GaW5pc2gsXG4gIG9uRXJyb3IsXG4gIG9uRGF0YSxcbiAgZmV0Y2g6IGZldGNoMiA9IGdldE9yaWdpbmFsRmV0Y2gyKClcbn0pIHtcbiAgdmFyIF9hO1xuICB0cnkge1xuICAgIHNldExvYWRpbmcodHJ1ZSk7XG4gICAgc2V0RXJyb3Iodm9pZCAwKTtcbiAgICBjb25zdCBhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgc2V0QWJvcnRDb250cm9sbGVyKGFib3J0Q29udHJvbGxlcik7XG4gICAgc2V0Q29tcGxldGlvbihcIlwiKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoMihhcGksIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIHByb21wdCxcbiAgICAgICAgLi4uYm9keVxuICAgICAgfSksXG4gICAgICBjcmVkZW50aWFscyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgIC4uLmhlYWRlcnNcbiAgICAgIH0sXG4gICAgICBzaWduYWw6IGFib3J0Q29udHJvbGxlci5zaWduYWxcbiAgICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfSk7XG4gICAgaWYgKG9uUmVzcG9uc2UpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IG9uUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAoX2EgPSBhd2FpdCByZXNwb25zZS50ZXh0KCkpICE9IG51bGwgPyBfYSA6IFwiRmFpbGVkIHRvIGZldGNoIHRoZSBjaGF0IHJlc3BvbnNlLlwiXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoIXJlc3BvbnNlLmJvZHkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSByZXNwb25zZSBib2R5IGlzIGVtcHR5LlwiKTtcbiAgICB9XG4gICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgc3dpdGNoIChzdHJlYW1Qcm90b2NvbCkge1xuICAgICAgY2FzZSBcInRleHRcIjoge1xuICAgICAgICBhd2FpdCBwcm9jZXNzVGV4dFN0cmVhbSh7XG4gICAgICAgICAgc3RyZWFtOiByZXNwb25zZS5ib2R5LFxuICAgICAgICAgIG9uVGV4dFBhcnQ6IChjaHVuaykgPT4ge1xuICAgICAgICAgICAgcmVzdWx0ICs9IGNodW5rO1xuICAgICAgICAgICAgc2V0Q29tcGxldGlvbihyZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcImRhdGFcIjoge1xuICAgICAgICBhd2FpdCBwcm9jZXNzRGF0YVN0cmVhbSh7XG4gICAgICAgICAgc3RyZWFtOiByZXNwb25zZS5ib2R5LFxuICAgICAgICAgIG9uVGV4dFBhcnQodmFsdWUpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSB2YWx1ZTtcbiAgICAgICAgICAgIHNldENvbXBsZXRpb24ocmVzdWx0KTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9uRGF0YVBhcnQodmFsdWUpIHtcbiAgICAgICAgICAgIG9uRGF0YSA9PSBudWxsID8gdm9pZCAwIDogb25EYXRhKHZhbHVlKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9uRXJyb3JQYXJ0KHZhbHVlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICBjb25zdCBleGhhdXN0aXZlQ2hlY2sgPSBzdHJlYW1Qcm90b2NvbDtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHN0cmVhbSBwcm90b2NvbDogJHtleGhhdXN0aXZlQ2hlY2t9YCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvbkZpbmlzaCkge1xuICAgICAgb25GaW5pc2gocHJvbXB0LCByZXN1bHQpO1xuICAgIH1cbiAgICBzZXRBYm9ydENvbnRyb2xsZXIobnVsbCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKGVyci5uYW1lID09PSBcIkFib3J0RXJyb3JcIikge1xuICAgICAgc2V0QWJvcnRDb250cm9sbGVyKG51bGwpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgaWYgKG9uRXJyb3IpIHtcbiAgICAgICAgb25FcnJvcihlcnIpO1xuICAgICAgfVxuICAgIH1cbiAgICBzZXRFcnJvcihlcnIpO1xuICB9IGZpbmFsbHkge1xuICAgIHNldExvYWRpbmcoZmFsc2UpO1xuICB9XG59XG5cbi8vIHNyYy9kYXRhLXVybC50c1xuZnVuY3Rpb24gZ2V0VGV4dEZyb21EYXRhVXJsKGRhdGFVcmwpIHtcbiAgY29uc3QgW2hlYWRlciwgYmFzZTY0Q29udGVudF0gPSBkYXRhVXJsLnNwbGl0KFwiLFwiKTtcbiAgY29uc3QgbWltZVR5cGUgPSBoZWFkZXIuc3BsaXQoXCI7XCIpWzBdLnNwbGl0KFwiOlwiKVsxXTtcbiAgaWYgKG1pbWVUeXBlID09IG51bGwgfHwgYmFzZTY0Q29udGVudCA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBkYXRhIFVSTCBmb3JtYXRcIik7XG4gIH1cbiAgdHJ5IHtcbiAgICByZXR1cm4gd2luZG93LmF0b2IoYmFzZTY0Q29udGVudCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBkZWNvZGluZyBkYXRhIFVSTGApO1xuICB9XG59XG5cbi8vIHNyYy9leHRyYWN0LW1heC10b29sLWludm9jYXRpb24tc3RlcC50c1xuZnVuY3Rpb24gZXh0cmFjdE1heFRvb2xJbnZvY2F0aW9uU3RlcCh0b29sSW52b2NhdGlvbnMpIHtcbiAgcmV0dXJuIHRvb2xJbnZvY2F0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogdG9vbEludm9jYXRpb25zLnJlZHVjZSgobWF4LCB0b29sSW52b2NhdGlvbikgPT4ge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gTWF0aC5tYXgobWF4LCAoX2EgPSB0b29sSW52b2NhdGlvbi5zdGVwKSAhPSBudWxsID8gX2EgOiAwKTtcbiAgfSwgMCk7XG59XG5cbi8vIHNyYy9nZXQtbWVzc2FnZS1wYXJ0cy50c1xuZnVuY3Rpb24gZ2V0TWVzc2FnZVBhcnRzKG1lc3NhZ2UpIHtcbiAgdmFyIF9hO1xuICByZXR1cm4gKF9hID0gbWVzc2FnZS5wYXJ0cykgIT0gbnVsbCA/IF9hIDogW1xuICAgIC4uLm1lc3NhZ2UudG9vbEludm9jYXRpb25zID8gbWVzc2FnZS50b29sSW52b2NhdGlvbnMubWFwKCh0b29sSW52b2NhdGlvbikgPT4gKHtcbiAgICAgIHR5cGU6IFwidG9vbC1pbnZvY2F0aW9uXCIsXG4gICAgICB0b29sSW52b2NhdGlvblxuICAgIH0pKSA6IFtdLFxuICAgIC4uLm1lc3NhZ2UucmVhc29uaW5nID8gW1xuICAgICAge1xuICAgICAgICB0eXBlOiBcInJlYXNvbmluZ1wiLFxuICAgICAgICByZWFzb25pbmc6IG1lc3NhZ2UucmVhc29uaW5nLFxuICAgICAgICBkZXRhaWxzOiBbeyB0eXBlOiBcInRleHRcIiwgdGV4dDogbWVzc2FnZS5yZWFzb25pbmcgfV1cbiAgICAgIH1cbiAgICBdIDogW10sXG4gICAgLi4ubWVzc2FnZS5jb250ZW50ID8gW3sgdHlwZTogXCJ0ZXh0XCIsIHRleHQ6IG1lc3NhZ2UuY29udGVudCB9XSA6IFtdXG4gIF07XG59XG5cbi8vIHNyYy9maWxsLW1lc3NhZ2UtcGFydHMudHNcbmZ1bmN0aW9uIGZpbGxNZXNzYWdlUGFydHMobWVzc2FnZXMpIHtcbiAgcmV0dXJuIG1lc3NhZ2VzLm1hcCgobWVzc2FnZSkgPT4gKHtcbiAgICAuLi5tZXNzYWdlLFxuICAgIHBhcnRzOiBnZXRNZXNzYWdlUGFydHMobWVzc2FnZSlcbiAgfSkpO1xufVxuXG4vLyBzcmMvaXMtZGVlcC1lcXVhbC1kYXRhLnRzXG5mdW5jdGlvbiBpc0RlZXBFcXVhbERhdGEob2JqMSwgb2JqMikge1xuICBpZiAob2JqMSA9PT0gb2JqMilcbiAgICByZXR1cm4gdHJ1ZTtcbiAgaWYgKG9iajEgPT0gbnVsbCB8fCBvYmoyID09IG51bGwpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIG9iajEgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iajIgIT09IFwib2JqZWN0XCIpXG4gICAgcmV0dXJuIG9iajEgPT09IG9iajI7XG4gIGlmIChvYmoxLmNvbnN0cnVjdG9yICE9PSBvYmoyLmNvbnN0cnVjdG9yKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKG9iajEgaW5zdGFuY2VvZiBEYXRlICYmIG9iajIgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgcmV0dXJuIG9iajEuZ2V0VGltZSgpID09PSBvYmoyLmdldFRpbWUoKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShvYmoxKSkge1xuICAgIGlmIChvYmoxLmxlbmd0aCAhPT0gb2JqMi5sZW5ndGgpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvYmoxLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIWlzRGVlcEVxdWFsRGF0YShvYmoxW2ldLCBvYmoyW2ldKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBrZXlzMSA9IE9iamVjdC5rZXlzKG9iajEpO1xuICBjb25zdCBrZXlzMiA9IE9iamVjdC5rZXlzKG9iajIpO1xuICBpZiAoa2V5czEubGVuZ3RoICE9PSBrZXlzMi5sZW5ndGgpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzMSkge1xuICAgIGlmICgha2V5czIuaW5jbHVkZXMoa2V5KSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoIWlzRGVlcEVxdWFsRGF0YShvYmoxW2tleV0sIG9iajJba2V5XSkpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIHNyYy9wcmVwYXJlLWF0dGFjaG1lbnRzLWZvci1yZXF1ZXN0LnRzXG5hc3luYyBmdW5jdGlvbiBwcmVwYXJlQXR0YWNobWVudHNGb3JSZXF1ZXN0KGF0dGFjaG1lbnRzRnJvbU9wdGlvbnMpIHtcbiAgaWYgKCFhdHRhY2htZW50c0Zyb21PcHRpb25zKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGlmIChhdHRhY2htZW50c0Zyb21PcHRpb25zIGluc3RhbmNlb2YgRmlsZUxpc3QpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoXG4gICAgICBBcnJheS5mcm9tKGF0dGFjaG1lbnRzRnJvbU9wdGlvbnMpLm1hcChhc3luYyAoYXR0YWNobWVudCkgPT4ge1xuICAgICAgICBjb25zdCB7IG5hbWUsIHR5cGUgfSA9IGF0dGFjaG1lbnQ7XG4gICAgICAgIGNvbnN0IGRhdGFVcmwgPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgY29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgICAgICByZWFkZXIub25sb2FkID0gKHJlYWRlckV2ZW50KSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICByZXNvbHZlKChfYSA9IHJlYWRlckV2ZW50LnRhcmdldCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnJlc3VsdCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICByZWFkZXIub25lcnJvciA9IChlcnJvcikgPT4gcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICByZWFkZXIucmVhZEFzRGF0YVVSTChhdHRhY2htZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBjb250ZW50VHlwZTogdHlwZSxcbiAgICAgICAgICB1cmw6IGRhdGFVcmxcbiAgICAgICAgfTtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShhdHRhY2htZW50c0Zyb21PcHRpb25zKSkge1xuICAgIHJldHVybiBhdHRhY2htZW50c0Zyb21PcHRpb25zO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYXR0YWNobWVudHMgdHlwZVwiKTtcbn1cblxuLy8gc3JjL3Byb2Nlc3MtYXNzaXN0YW50LXN0cmVhbS50c1xudmFyIE5FV0xJTkUyID0gXCJcXG5cIi5jaGFyQ29kZUF0KDApO1xuZnVuY3Rpb24gY29uY2F0Q2h1bmtzMihjaHVua3MsIHRvdGFsTGVuZ3RoKSB7XG4gIGNvbnN0IGNvbmNhdGVuYXRlZENodW5rcyA9IG5ldyBVaW50OEFycmF5KHRvdGFsTGVuZ3RoKTtcbiAgbGV0IG9mZnNldCA9IDA7XG4gIGZvciAoY29uc3QgY2h1bmsgb2YgY2h1bmtzKSB7XG4gICAgY29uY2F0ZW5hdGVkQ2h1bmtzLnNldChjaHVuaywgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gY2h1bmsubGVuZ3RoO1xuICB9XG4gIGNodW5rcy5sZW5ndGggPSAwO1xuICByZXR1cm4gY29uY2F0ZW5hdGVkQ2h1bmtzO1xufVxuYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc0Fzc2lzdGFudFN0cmVhbSh7XG4gIHN0cmVhbSxcbiAgb25UZXh0UGFydCxcbiAgb25FcnJvclBhcnQsXG4gIG9uQXNzaXN0YW50TWVzc2FnZVBhcnQsXG4gIG9uQXNzaXN0YW50Q29udHJvbERhdGFQYXJ0LFxuICBvbkRhdGFNZXNzYWdlUGFydFxufSkge1xuICBjb25zdCByZWFkZXIgPSBzdHJlYW0uZ2V0UmVhZGVyKCk7XG4gIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgY29uc3QgY2h1bmtzID0gW107XG4gIGxldCB0b3RhbExlbmd0aCA9IDA7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3QgeyB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGNodW5rcy5wdXNoKHZhbHVlKTtcbiAgICAgIHRvdGFsTGVuZ3RoICs9IHZhbHVlLmxlbmd0aDtcbiAgICAgIGlmICh2YWx1ZVt2YWx1ZS5sZW5ndGggLSAxXSAhPT0gTkVXTElORTIpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjaHVua3MubGVuZ3RoID09PSAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY29uc3QgY29uY2F0ZW5hdGVkQ2h1bmtzID0gY29uY2F0Q2h1bmtzMihjaHVua3MsIHRvdGFsTGVuZ3RoKTtcbiAgICB0b3RhbExlbmd0aCA9IDA7XG4gICAgY29uc3Qgc3RyZWFtUGFydHMgPSBkZWNvZGVyLmRlY29kZShjb25jYXRlbmF0ZWRDaHVua3MsIHsgc3RyZWFtOiB0cnVlIH0pLnNwbGl0KFwiXFxuXCIpLmZpbHRlcigobGluZSkgPT4gbGluZSAhPT0gXCJcIikubWFwKHBhcnNlQXNzaXN0YW50U3RyZWFtUGFydCk7XG4gICAgZm9yIChjb25zdCB7IHR5cGUsIHZhbHVlOiB2YWx1ZTIgfSBvZiBzdHJlYW1QYXJ0cykge1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJ0ZXh0XCI6XG4gICAgICAgICAgYXdhaXQgKG9uVGV4dFBhcnQgPT0gbnVsbCA/IHZvaWQgMCA6IG9uVGV4dFBhcnQodmFsdWUyKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJlcnJvclwiOlxuICAgICAgICAgIGF3YWl0IChvbkVycm9yUGFydCA9PSBudWxsID8gdm9pZCAwIDogb25FcnJvclBhcnQodmFsdWUyKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJhc3Npc3RhbnRfbWVzc2FnZVwiOlxuICAgICAgICAgIGF3YWl0IChvbkFzc2lzdGFudE1lc3NhZ2VQYXJ0ID09IG51bGwgPyB2b2lkIDAgOiBvbkFzc2lzdGFudE1lc3NhZ2VQYXJ0KHZhbHVlMikpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiYXNzaXN0YW50X2NvbnRyb2xfZGF0YVwiOlxuICAgICAgICAgIGF3YWl0IChvbkFzc2lzdGFudENvbnRyb2xEYXRhUGFydCA9PSBudWxsID8gdm9pZCAwIDogb25Bc3Npc3RhbnRDb250cm9sRGF0YVBhcnQodmFsdWUyKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJkYXRhX21lc3NhZ2VcIjpcbiAgICAgICAgICBhd2FpdCAob25EYXRhTWVzc2FnZVBhcnQgPT0gbnVsbCA/IHZvaWQgMCA6IG9uRGF0YU1lc3NhZ2VQYXJ0KHZhbHVlMikpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgY29uc3QgZXhoYXVzdGl2ZUNoZWNrID0gdHlwZTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gc3RyZWFtIHBhcnQgdHlwZTogJHtleGhhdXN0aXZlQ2hlY2t9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gc3JjL3NjaGVtYS50c1xuaW1wb3J0IHsgdmFsaWRhdG9yU3ltYm9sIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcblxuLy8gc3JjL3pvZC1zY2hlbWEudHNcbmltcG9ydCB6b2RUb0pzb25TY2hlbWEgZnJvbSBcInpvZC10by1qc29uLXNjaGVtYVwiO1xuZnVuY3Rpb24gem9kU2NoZW1hKHpvZFNjaGVtYTIsIG9wdGlvbnMpIHtcbiAgdmFyIF9hO1xuICBjb25zdCB1c2VSZWZlcmVuY2VzID0gKF9hID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy51c2VSZWZlcmVuY2VzKSAhPSBudWxsID8gX2EgOiBmYWxzZTtcbiAgcmV0dXJuIGpzb25TY2hlbWEoXG4gICAgem9kVG9Kc29uU2NoZW1hKHpvZFNjaGVtYTIsIHtcbiAgICAgICRyZWZTdHJhdGVneTogdXNlUmVmZXJlbmNlcyA/IFwicm9vdFwiIDogXCJub25lXCIsXG4gICAgICB0YXJnZXQ6IFwianNvblNjaGVtYTdcIlxuICAgICAgLy8gbm90ZTogb3BlbmFpIG1vZGUgYnJlYWtzIHZhcmlvdXMgZ2VtaW5pIGNvbnZlcnNpb25zXG4gICAgfSksXG4gICAge1xuICAgICAgdmFsaWRhdGU6ICh2YWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB6b2RTY2hlbWEyLnNhZmVQYXJzZSh2YWx1ZSk7XG4gICAgICAgIHJldHVybiByZXN1bHQuc3VjY2VzcyA/IHsgc3VjY2VzczogdHJ1ZSwgdmFsdWU6IHJlc3VsdC5kYXRhIH0gOiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogcmVzdWx0LmVycm9yIH07XG4gICAgICB9XG4gICAgfVxuICApO1xufVxuXG4vLyBzcmMvc2NoZW1hLnRzXG52YXIgc2NoZW1hU3ltYm9sID0gU3ltYm9sLmZvcihcInZlcmNlbC5haS5zY2hlbWFcIik7XG5mdW5jdGlvbiBqc29uU2NoZW1hKGpzb25TY2hlbWEyLCB7XG4gIHZhbGlkYXRlXG59ID0ge30pIHtcbiAgcmV0dXJuIHtcbiAgICBbc2NoZW1hU3ltYm9sXTogdHJ1ZSxcbiAgICBfdHlwZTogdm9pZCAwLFxuICAgIC8vIHNob3VsZCBuZXZlciBiZSB1c2VkIGRpcmVjdGx5XG4gICAgW3ZhbGlkYXRvclN5bWJvbF06IHRydWUsXG4gICAganNvblNjaGVtYToganNvblNjaGVtYTIsXG4gICAgdmFsaWRhdGVcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzU2NoZW1hKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGwgJiYgc2NoZW1hU3ltYm9sIGluIHZhbHVlICYmIHZhbHVlW3NjaGVtYVN5bWJvbF0gPT09IHRydWUgJiYgXCJqc29uU2NoZW1hXCIgaW4gdmFsdWUgJiYgXCJ2YWxpZGF0ZVwiIGluIHZhbHVlO1xufVxuZnVuY3Rpb24gYXNTY2hlbWEoc2NoZW1hKSB7XG4gIHJldHVybiBpc1NjaGVtYShzY2hlbWEpID8gc2NoZW1hIDogem9kU2NoZW1hKHNjaGVtYSk7XG59XG5cbi8vIHNyYy9zaG91bGQtcmVzdWJtaXQtbWVzc2FnZXMudHNcbmZ1bmN0aW9uIHNob3VsZFJlc3VibWl0TWVzc2FnZXMoe1xuICBvcmlnaW5hbE1heFRvb2xJbnZvY2F0aW9uU3RlcCxcbiAgb3JpZ2luYWxNZXNzYWdlQ291bnQsXG4gIG1heFN0ZXBzLFxuICBtZXNzYWdlc1xufSkge1xuICB2YXIgX2E7XG4gIGNvbnN0IGxhc3RNZXNzYWdlID0gbWVzc2FnZXNbbWVzc2FnZXMubGVuZ3RoIC0gMV07XG4gIHJldHVybiAoXG4gICAgLy8gY2hlY2sgaWYgdGhlIGZlYXR1cmUgaXMgZW5hYmxlZDpcbiAgICBtYXhTdGVwcyA+IDEgJiYgLy8gZW5zdXJlIHRoZXJlIGlzIGEgbGFzdCBtZXNzYWdlOlxuICAgIGxhc3RNZXNzYWdlICE9IG51bGwgJiYgLy8gZW5zdXJlIHdlIGFjdHVhbGx5IGhhdmUgbmV3IHN0ZXBzICh0byBwcmV2ZW50IGluZmluaXRlIGxvb3BzIGluIGNhc2Ugb2YgZXJyb3JzKTpcbiAgICAobWVzc2FnZXMubGVuZ3RoID4gb3JpZ2luYWxNZXNzYWdlQ291bnQgfHwgZXh0cmFjdE1heFRvb2xJbnZvY2F0aW9uU3RlcChsYXN0TWVzc2FnZS50b29sSW52b2NhdGlvbnMpICE9PSBvcmlnaW5hbE1heFRvb2xJbnZvY2F0aW9uU3RlcCkgJiYgLy8gY2hlY2sgdGhhdCBuZXh0IHN0ZXAgaXMgcG9zc2libGU6XG4gICAgaXNBc3Npc3RhbnRNZXNzYWdlV2l0aENvbXBsZXRlZFRvb2xDYWxscyhsYXN0TWVzc2FnZSkgJiYgLy8gbGltaXQgdGhlIG51bWJlciBvZiBhdXRvbWF0aWMgc3RlcHM6XG4gICAgKChfYSA9IGV4dHJhY3RNYXhUb29sSW52b2NhdGlvblN0ZXAobGFzdE1lc3NhZ2UudG9vbEludm9jYXRpb25zKSkgIT0gbnVsbCA/IF9hIDogMCkgPCBtYXhTdGVwc1xuICApO1xufVxuZnVuY3Rpb24gaXNBc3Npc3RhbnRNZXNzYWdlV2l0aENvbXBsZXRlZFRvb2xDYWxscyhtZXNzYWdlKSB7XG4gIGlmIChtZXNzYWdlLnJvbGUgIT09IFwiYXNzaXN0YW50XCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgbGFzdFN0ZXBTdGFydEluZGV4ID0gbWVzc2FnZS5wYXJ0cy5yZWR1Y2UoKGxhc3RJbmRleCwgcGFydCwgaW5kZXgpID0+IHtcbiAgICByZXR1cm4gcGFydC50eXBlID09PSBcInN0ZXAtc3RhcnRcIiA/IGluZGV4IDogbGFzdEluZGV4O1xuICB9LCAtMSk7XG4gIGNvbnN0IGxhc3RTdGVwVG9vbEludm9jYXRpb25zID0gbWVzc2FnZS5wYXJ0cy5zbGljZShsYXN0U3RlcFN0YXJ0SW5kZXggKyAxKS5maWx0ZXIoKHBhcnQpID0+IHBhcnQudHlwZSA9PT0gXCJ0b29sLWludm9jYXRpb25cIik7XG4gIHJldHVybiBsYXN0U3RlcFRvb2xJbnZvY2F0aW9ucy5sZW5ndGggPiAwICYmIGxhc3RTdGVwVG9vbEludm9jYXRpb25zLmV2ZXJ5KChwYXJ0KSA9PiBcInJlc3VsdFwiIGluIHBhcnQudG9vbEludm9jYXRpb24pO1xufVxuXG4vLyBzcmMvdXBkYXRlLXRvb2wtY2FsbC1yZXN1bHQudHNcbmZ1bmN0aW9uIHVwZGF0ZVRvb2xDYWxsUmVzdWx0KHtcbiAgbWVzc2FnZXMsXG4gIHRvb2xDYWxsSWQsXG4gIHRvb2xSZXN1bHQ6IHJlc3VsdFxufSkge1xuICB2YXIgX2E7XG4gIGNvbnN0IGxhc3RNZXNzYWdlID0gbWVzc2FnZXNbbWVzc2FnZXMubGVuZ3RoIC0gMV07XG4gIGNvbnN0IGludm9jYXRpb25QYXJ0ID0gbGFzdE1lc3NhZ2UucGFydHMuZmluZChcbiAgICAocGFydCkgPT4gcGFydC50eXBlID09PSBcInRvb2wtaW52b2NhdGlvblwiICYmIHBhcnQudG9vbEludm9jYXRpb24udG9vbENhbGxJZCA9PT0gdG9vbENhbGxJZFxuICApO1xuICBpZiAoaW52b2NhdGlvblBhcnQgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB0b29sUmVzdWx0ID0ge1xuICAgIC4uLmludm9jYXRpb25QYXJ0LnRvb2xJbnZvY2F0aW9uLFxuICAgIHN0YXRlOiBcInJlc3VsdFwiLFxuICAgIHJlc3VsdFxuICB9O1xuICBpbnZvY2F0aW9uUGFydC50b29sSW52b2NhdGlvbiA9IHRvb2xSZXN1bHQ7XG4gIGxhc3RNZXNzYWdlLnRvb2xJbnZvY2F0aW9ucyA9IChfYSA9IGxhc3RNZXNzYWdlLnRvb2xJbnZvY2F0aW9ucykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLm1hcChcbiAgICAodG9vbEludm9jYXRpb24pID0+IHRvb2xJbnZvY2F0aW9uLnRvb2xDYWxsSWQgPT09IHRvb2xDYWxsSWQgPyB0b29sUmVzdWx0IDogdG9vbEludm9jYXRpb25cbiAgKTtcbn1cbmV4cG9ydCB7XG4gIGFzU2NoZW1hLFxuICBjYWxsQ2hhdEFwaSxcbiAgY2FsbENvbXBsZXRpb25BcGksXG4gIGV4dHJhY3RNYXhUb29sSW52b2NhdGlvblN0ZXAsXG4gIGZpbGxNZXNzYWdlUGFydHMsXG4gIGZvcm1hdEFzc2lzdGFudFN0cmVhbVBhcnQsXG4gIGZvcm1hdERhdGFTdHJlYW1QYXJ0LFxuICBnZW5lcmF0ZUlkLFxuICBnZXRNZXNzYWdlUGFydHMsXG4gIGdldFRleHRGcm9tRGF0YVVybCxcbiAgaXNBc3Npc3RhbnRNZXNzYWdlV2l0aENvbXBsZXRlZFRvb2xDYWxscyxcbiAgaXNEZWVwRXF1YWxEYXRhLFxuICBqc29uU2NoZW1hLFxuICBwYXJzZUFzc2lzdGFudFN0cmVhbVBhcnQsXG4gIHBhcnNlRGF0YVN0cmVhbVBhcnQsXG4gIHBhcnNlUGFydGlhbEpzb24sXG4gIHByZXBhcmVBdHRhY2htZW50c0ZvclJlcXVlc3QsXG4gIHByb2Nlc3NBc3Npc3RhbnRTdHJlYW0sXG4gIHByb2Nlc3NEYXRhU3RyZWFtLFxuICBwcm9jZXNzVGV4dFN0cmVhbSxcbiAgc2hvdWxkUmVzdWJtaXRNZXNzYWdlcyxcbiAgdXBkYXRlVG9vbENhbGxSZXN1bHQsXG4gIHpvZFNjaGVtYVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@ai-sdk/ui-utils/dist/index.mjs\n");

/***/ })

};
;