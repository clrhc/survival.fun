/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@coinbase";
exports.ids = ["vendor-chunks/@coinbase"];
exports.modules = {

/***/ "(rsc)/./node_modules/@coinbase/agentkit-vercel-ai-sdk/dist/getVercelAiTools.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit-vercel-ai-sdk/dist/getVercelAiTools.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/**\n * Main exports for the CDP Vercel AI SDK package\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getVercelAITools = getVercelAITools;\nconst ai_1 = __webpack_require__(/*! ai */ \"(rsc)/./node_modules/ai/dist/index.js\");\n/**\n * Get Vercel AI SDK tools from an AgentKit instance\n *\n * @param agentKit - The AgentKit instance\n * @returns An array of Vercel AI SDK tools\n */\nfunction getVercelAITools(agentKit) {\n    const actions = agentKit.getActions();\n    return actions.reduce((acc, action) => {\n        acc[action.name] = (0, ai_1.tool)({\n            description: action.description,\n            parameters: action.schema,\n            execute: async (args) => {\n                const result = await action.invoke(args);\n                return result;\n            },\n        });\n        return acc;\n    }, {});\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0LXZlcmNlbC1haS1zZGsvZGlzdC9nZXRWZXJjZWxBaVRvb2xzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHdCQUF3QjtBQUN4QixhQUFhLG1CQUFPLENBQUMsaURBQUk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBLEtBQUssSUFBSTtBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3Vydml2YWwtZnVuLy4vbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9hZ2VudGtpdC12ZXJjZWwtYWktc2RrL2Rpc3QvZ2V0VmVyY2VsQWlUb29scy5qcz81NGE4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBNYWluIGV4cG9ydHMgZm9yIHRoZSBDRFAgVmVyY2VsIEFJIFNESyBwYWNrYWdlXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0VmVyY2VsQUlUb29scyA9IGdldFZlcmNlbEFJVG9vbHM7XG5jb25zdCBhaV8xID0gcmVxdWlyZShcImFpXCIpO1xuLyoqXG4gKiBHZXQgVmVyY2VsIEFJIFNESyB0b29scyBmcm9tIGFuIEFnZW50S2l0IGluc3RhbmNlXG4gKlxuICogQHBhcmFtIGFnZW50S2l0IC0gVGhlIEFnZW50S2l0IGluc3RhbmNlXG4gKiBAcmV0dXJucyBBbiBhcnJheSBvZiBWZXJjZWwgQUkgU0RLIHRvb2xzXG4gKi9cbmZ1bmN0aW9uIGdldFZlcmNlbEFJVG9vbHMoYWdlbnRLaXQpIHtcbiAgICBjb25zdCBhY3Rpb25zID0gYWdlbnRLaXQuZ2V0QWN0aW9ucygpO1xuICAgIHJldHVybiBhY3Rpb25zLnJlZHVjZSgoYWNjLCBhY3Rpb24pID0+IHtcbiAgICAgICAgYWNjW2FjdGlvbi5uYW1lXSA9ICgwLCBhaV8xLnRvb2wpKHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBhY3Rpb24uZGVzY3JpcHRpb24sXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBhY3Rpb24uc2NoZW1hLFxuICAgICAgICAgICAgZXhlY3V0ZTogYXN5bmMgKGFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBhY3Rpb24uaW52b2tlKGFyZ3MpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit-vercel-ai-sdk/dist/getVercelAiTools.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit-vercel-ai-sdk/dist/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit-vercel-ai-sdk/dist/index.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./getVercelAiTools */ \"(rsc)/./node_modules/@coinbase/agentkit-vercel-ai-sdk/dist/getVercelAiTools.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0LXZlcmNlbC1haS1zZGsvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxhQUFhLG1CQUFPLENBQUMsMEdBQW9CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3Vydml2YWwtZnVuLy4vbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9hZ2VudGtpdC12ZXJjZWwtYWktc2RrL2Rpc3QvaW5kZXguanM/YzU3OSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2dldFZlcmNlbEFpVG9vbHNcIiksIGV4cG9ydHMpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit-vercel-ai-sdk/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/across/acrossActionProvider.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/across/acrossActionProvider.js ***!
  \**********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _AcrossActionProvider_privateKey;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.acrossActionProvider = exports.AcrossActionProvider = void 0;\nconst zod_1 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/lib/index.js\");\nconst viem_1 = __webpack_require__(/*! viem */ \"(rsc)/./node_modules/viem/_cjs/index.js\");\nconst actionProvider_1 = __webpack_require__(/*! ../actionProvider */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/actionProvider.js\");\nconst network_1 = __webpack_require__(/*! ../../network */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/network/index.js\");\nconst actionDecorator_1 = __webpack_require__(/*! ../actionDecorator */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/actionDecorator.js\");\nconst schemas_1 = __webpack_require__(/*! ./schemas */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/across/schemas.js\");\nconst wallet_providers_1 = __webpack_require__(/*! ../../wallet-providers */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/wallet-providers/index.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/across/utils.js\");\nconst accounts_1 = __webpack_require__(/*! viem/accounts */ \"(rsc)/./node_modules/viem/_cjs/accounts/index.js\");\nconst constants_1 = __webpack_require__(/*! ../erc20/constants */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/erc20/constants.js\");\n/**\n * AcrossActionProvider provides actions for cross-chain bridging via Across Protocol.\n */\nclass AcrossActionProvider extends actionProvider_1.ActionProvider {\n    /**\n     * Constructor for the AcrossActionProvider.\n     *\n     * @param config - The configuration options for the AcrossActionProvider.\n     */\n    constructor(config) {\n        super(\"across\", []);\n        _AcrossActionProvider_privateKey.set(this, void 0);\n        /**\n         * Checks if the Across action provider supports the given network.\n         *\n         * @param network - The network to check.\n         * @returns True if the Across action provider supports the network, false otherwise.\n         */\n        this.supportsNetwork = (network) => {\n            // Across only supports EVM-compatible chains\n            return network.protocolFamily === \"evm\";\n        };\n        __classPrivateFieldSet(this, _AcrossActionProvider_privateKey, config.privateKey, \"f\");\n        const account = (0, accounts_1.privateKeyToAccount)(__classPrivateFieldGet(this, _AcrossActionProvider_privateKey, \"f\"));\n        if (!account)\n            throw new Error(\"Invalid private key\");\n    }\n    /**\n     * Bridges a token from one chain to another using Across Protocol.\n     *\n     * @param walletProvider - The wallet provider to use for the transaction.\n     * @param args - The input arguments for the action.\n     * @returns A message containing the bridge details.\n     */\n    async bridgeToken(walletProvider, args) {\n        try {\n            // Use dynamic import to get the Across SDK\n            const acrossModule = await Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/viem\"), __webpack_require__.e(\"vendor-chunks/@noble\"), __webpack_require__.e(\"vendor-chunks/ox\"), __webpack_require__.e(\"vendor-chunks/abitype\"), __webpack_require__.e(\"vendor-chunks/@across-protocol\")]).then(__webpack_require__.bind(__webpack_require__, /*! @across-protocol/app-sdk */ \"(rsc)/./node_modules/@across-protocol/app-sdk/dist/index.js\"));\n            const createAcrossClient = acrossModule.createAcrossClient;\n            // Get recipient address if provided, otherwise use sender\n            const address = walletProvider.getAddress();\n            const recipient = (args.recipient || address);\n            // Get origin chain\n            const originChain = (0, network_1.getChain)(walletProvider.getNetwork().chainId);\n            if (!originChain) {\n                throw new Error(`Unsupported origin chain: ${walletProvider.getNetwork()}`);\n            }\n            // Get destination chain\n            const destinationNetworkId = network_1.CHAIN_ID_TO_NETWORK_ID[Number(args.destinationChainId)];\n            const destinationChain = network_1.NETWORK_ID_TO_VIEM_CHAIN[destinationNetworkId];\n            if (!destinationChain) {\n                throw new Error(`Unsupported destination chain: ${args.destinationChainId}`);\n            }\n            // Sanity checks\n            if (originChain.id === destinationChain.id) {\n                throw new Error(\"Origin and destination chains cannot be the same\");\n            }\n            const useTestnet = (0, utils_1.isAcrossSupportedTestnet)(originChain.id);\n            if (useTestnet !== (0, utils_1.isAcrossSupportedTestnet)(destinationChain.id)) {\n                throw new Error(`Cross-chain transfers between ${originChain.name} and ${destinationChain.name} are not supported.\n           Origin and destination chains must either be both testnets or both mainnets.`);\n            }\n            // Create wallet client\n            const account = (0, accounts_1.privateKeyToAccount)(__classPrivateFieldGet(this, _AcrossActionProvider_privateKey, \"f\"));\n            if (account.address !== walletProvider.getAddress()) {\n                throw new Error(\"Private key does not match wallet provider address\");\n            }\n            const walletClient = (0, viem_1.createWalletClient)({\n                account,\n                chain: originChain,\n                transport: (0, viem_1.http)(),\n            });\n            // Create Across client\n            const acrossClient = createAcrossClient({\n                chains: [originChain, destinationChain],\n                useTestnet,\n            });\n            // Get chain details to find token information\n            const chainDetails = await acrossClient.getSupportedChains({});\n            const originChainDetails = chainDetails.find(chain => chain.chainId === originChain.id);\n            if (!originChainDetails) {\n                throw new Error(`Origin chain ${originChain.id} not supported by Across Protocol`);\n            }\n            // Find token by symbol on the origin chain\n            const inputTokens = originChainDetails.inputTokens;\n            if (!inputTokens || inputTokens.length === 0) {\n                throw new Error(`No input tokens available on chain ${originChain.id}`);\n            }\n            const tokenInfo = inputTokens.find(token => token.symbol.toUpperCase() === args.inputTokenSymbol.toUpperCase());\n            if (!tokenInfo) {\n                throw new Error(`Token ${args.inputTokenSymbol} not found on chain ${originChain.id}. Available tokens: ${inputTokens.map(t => t.symbol).join(\", \")}`);\n            }\n            // Get token address and decimals to parse the amount\n            const inputToken = tokenInfo.address;\n            const decimals = tokenInfo.decimals;\n            const inputAmount = (0, viem_1.parseUnits)(args.amount, decimals);\n            // Check balance\n            const isNative = args.inputTokenSymbol.toUpperCase() === \"ETH\";\n            if (isNative) {\n                // Check native ETH balance\n                const ethBalance = await walletProvider.getBalance();\n                if (ethBalance < inputAmount) {\n                    throw new Error(`Insufficient balance. Requested to bridge ${(0, viem_1.formatUnits)(inputAmount, decimals)} ${args.inputTokenSymbol} but balance is only ${(0, viem_1.formatUnits)(ethBalance, decimals)} ${args.inputTokenSymbol}`);\n                }\n            }\n            else {\n                // Check ERC20 token balance\n                const tokenBalance = (await walletProvider.readContract({\n                    address: inputToken,\n                    abi: constants_1.abi,\n                    functionName: \"balanceOf\",\n                    args: [address],\n                }));\n                if (tokenBalance < inputAmount) {\n                    throw new Error(`Insufficient balance. Requested to bridge ${(0, viem_1.formatUnits)(inputAmount, decimals)} ${args.inputTokenSymbol} but balance is only ${(0, viem_1.formatUnits)(tokenBalance, decimals)} ${args.inputTokenSymbol}`);\n                }\n            }\n            // Get available routes\n            const routeInfo = await acrossClient.getAvailableRoutes({\n                originChainId: originChain.id,\n                destinationChainId: destinationChain.id,\n                originToken: inputToken,\n            });\n            // Select the appropriate route for native ETH or ERC20 token\n            const route = routeInfo.find(route => route.isNative === isNative);\n            if (!route) {\n                throw new Error(`No routes available from chain ${originChain.name} to chain ${destinationChain.name} for token ${args.inputTokenSymbol}`);\n            }\n            // Get quote\n            const quote = await acrossClient.getQuote({\n                route,\n                inputAmount,\n                recipient,\n            });\n            // Convert units to readable format\n            const formattedInfo = {\n                minDeposit: (0, viem_1.formatUnits)(quote.limits.minDeposit, decimals),\n                maxDeposit: (0, viem_1.formatUnits)(quote.limits.maxDeposit, decimals),\n                inputAmount: (0, viem_1.formatUnits)(quote.deposit.inputAmount, decimals),\n                outputAmount: (0, viem_1.formatUnits)(quote.deposit.outputAmount, decimals),\n            };\n            // Check if input amount is within valid deposit range\n            if (quote.deposit.inputAmount < quote.limits.minDeposit) {\n                throw new Error(`Input amount ${formattedInfo.inputAmount} ${args.inputTokenSymbol} is below the minimum deposit of ${formattedInfo.minDeposit} ${args.inputTokenSymbol}`);\n            }\n            if (quote.deposit.inputAmount > quote.limits.maxDeposit) {\n                throw new Error(`Input amount ${formattedInfo.inputAmount} ${args.inputTokenSymbol} exceeds the maximum deposit of ${formattedInfo.maxDeposit} ${args.inputTokenSymbol}`);\n            }\n            // Check if output amount is within acceptable slippage limits\n            const actualSlippagePercentage = ((Number(formattedInfo.inputAmount) - Number(formattedInfo.outputAmount)) /\n                Number(formattedInfo.inputAmount)) *\n                100;\n            if (actualSlippagePercentage > args.maxSplippage) {\n                throw new Error(`Output amount has high slippage of ${actualSlippagePercentage.toFixed(2)}%, which exceeds the maximum allowed slippage of ${args.maxSplippage}%. ` +\n                    `Input: ${formattedInfo.inputAmount} ${args.inputTokenSymbol}, Output: ${formattedInfo.outputAmount} ${args.inputTokenSymbol}`);\n            }\n            //Approve ERC20 token if needed\n            let approvalTxHash;\n            if (!isNative) {\n                approvalTxHash = await walletProvider.sendTransaction({\n                    to: inputToken,\n                    data: (0, viem_1.encodeFunctionData)({\n                        abi: constants_1.abi,\n                        functionName: \"approve\",\n                        args: [quote.deposit.spokePoolAddress, quote.deposit.inputAmount],\n                    }),\n                });\n                await walletProvider.waitForTransactionReceipt(approvalTxHash);\n            }\n            // Simulate the deposit transaction\n            const { request } = await acrossClient.simulateDepositTx({\n                walletClient: walletClient,\n                deposit: quote.deposit,\n            });\n            // Execute the deposit transaction\n            const transactionHash = await walletClient.writeContract(request);\n            // Wait for tx to be mined\n            const { depositId } = await acrossClient.waitForDepositTx({\n                transactionHash,\n                originChainId: originChain.id,\n            });\n            return `\nSuccessfully deposited tokens:\n- From: Chain ${originChain.id} (${originChain.name})\n- To: Chain ${destinationChain.id} (${destinationChain.name})\n- Token: ${args.inputTokenSymbol} (${inputToken})\n- Input Amount: ${formattedInfo.inputAmount} ${args.inputTokenSymbol}\n- Output Amount: ${formattedInfo.outputAmount} ${args.inputTokenSymbol}\n- Recipient: ${recipient}\n${!isNative ? `- Transaction Hash for approval: ${approvalTxHash}\\n` : \"\"}\n- Transaction Hash for deposit: ${transactionHash}\n- Deposit ID: ${depositId}\n        `;\n        }\n        catch (error) {\n            return `Error with Across SDK: ${error}`;\n        }\n    }\n    /**\n     * Checks the status of a bridge deposit via Across Protocol.\n     *\n     * @param walletProvider - The wallet provider to use for the transaction.\n     * @param args - The input arguments for the action.\n     * @returns A message containing the deposit status details.\n     */\n    async checkDepositStatus(walletProvider, args) {\n        const originChainId = Number(args.originChainId) || Number(walletProvider.getNetwork().chainId);\n        if ((0, utils_1.isAcrossSupportedTestnet)(originChainId)) {\n            throw new Error(\"Checking deposit status on testnets is currently not supported by the Across API\");\n        }\n        try {\n            const response = await fetch(`https://app.across.to/api/deposit/status?originChainId=${originChainId}&depositId=${args.depositId}`, {\n                method: \"GET\",\n            });\n            if (!response.ok) {\n                throw new Error(`Across API request failed with status ${response.status}`);\n            }\n            const apiData = await response.json();\n            // Get chain names\n            const originChainName = (0, network_1.getChain)(String(apiData.originChainId))?.name || \"Unknown Chain\";\n            const destinationChainName = (0, network_1.getChain)(String(apiData.destinationChainId))?.name || \"Unknown Chain\";\n            // Create structured response\n            const structuredResponse = {\n                status: apiData.status || \"unknown\",\n                depositTxInfo: apiData.depositTxHash\n                    ? {\n                        txHash: apiData.depositTxHash,\n                        chainId: apiData.originChainId,\n                        chainName: originChainName,\n                    }\n                    : null,\n                fillTxInfo: apiData.fillTx\n                    ? {\n                        txHash: apiData.fillTx,\n                        chainId: apiData.destinationChainId,\n                        chainName: destinationChainName,\n                    }\n                    : null,\n                depositRefundTxInfo: apiData.depositRefundTxHash\n                    ? {\n                        txHash: apiData.depositRefundTxHash,\n                        chainId: apiData.originChainId,\n                        chainName: originChainName,\n                    }\n                    : null,\n            };\n            return JSON.stringify(structuredResponse, null, 2);\n        }\n        catch (error) {\n            return `Error checking deposit status: ${error}`;\n        }\n    }\n}\nexports.AcrossActionProvider = AcrossActionProvider;\n_AcrossActionProvider_privateKey = new WeakMap();\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"bridge_token\",\n        description: `\n    This tool will bridge tokens from the current chain to another chain using the Across Protocol.\n\n    It takes the following inputs:\n    - destinationChainId: The chain ID of the destination chain (e.g. 8453 for base-mainnet)\n    - inputTokenSymbol: The symbol of the token to bridge (e.g. 'ETH', 'USDC')\n    - amount: The amount of tokens to bridge in whole units (e.g. 1.5 WETH, 10 USDC)\n    - recipient: (Optional) The recipient address on the destination chain (defaults to sender)\n    - maxSplippage: (Optional) The maximum slippage percentage (defaults to 1.5%)\n\n    Important notes:\n    - Origin chain is the currently connected chain of the wallet provider \n    - Supports cross-chain transfers between EVM-compatible chains for both mainnets and test networks\n    - Testnet deposits are not refunded if not filled on destination chain\n    - Ensure sufficient balance of the input token before bridging\n    - Returns deposit ID that can be used to check the status of the deposit\n    `,\n        schema: schemas_1.BridgeTokenSchema,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [wallet_providers_1.EvmWalletProvider, void 0]),\n    __metadata(\"design:returntype\", Promise)\n], AcrossActionProvider.prototype, \"bridgeToken\", null);\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"check_deposit_status\",\n        description: `\n    This tool will check the status of a cross-chain bridge deposit on the Across Protocol.\n    \n    It takes the following inputs:\n    - originChainId: The chain ID of the origin chain (defaults to the current chain)\n    - depositId: The ID of the deposit to check (returned by the bridge deposit transaction)\n    `,\n        schema: schemas_1.CheckDepositStatusSchema,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [wallet_providers_1.EvmWalletProvider, void 0]),\n    __metadata(\"design:returntype\", Promise)\n], AcrossActionProvider.prototype, \"checkDepositStatus\", null);\nconst acrossActionProvider = (config) => new AcrossActionProvider(config);\nexports.acrossActionProvider = acrossActionProvider;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9hY3Jvc3MvYWNyb3NzQWN0aW9uUHJvdmlkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsUUFBUTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDRCQUE0QixHQUFHLDRCQUE0QjtBQUMzRCxjQUFjLG1CQUFPLENBQUMsa0RBQUs7QUFDM0IsZUFBZSxtQkFBTyxDQUFDLHFEQUFNO0FBQzdCLHlCQUF5QixtQkFBTyxDQUFDLDBHQUFtQjtBQUNwRCxrQkFBa0IsbUJBQU8sQ0FBQyxvRkFBZTtBQUN6QywwQkFBMEIsbUJBQU8sQ0FBQyw0R0FBb0I7QUFDdEQsa0JBQWtCLG1CQUFPLENBQUMsa0dBQVc7QUFDckMsMkJBQTJCLG1CQUFPLENBQUMsc0dBQXdCO0FBQzNELGdCQUFnQixtQkFBTyxDQUFDLDhGQUFTO0FBQ2pDLG1CQUFtQixtQkFBTyxDQUFDLHVFQUFlO0FBQzFDLG9CQUFvQixtQkFBTyxDQUFDLDRHQUFvQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QywrWkFBa0M7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsNEJBQTRCO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0Usd0JBQXdCO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLGtCQUFrQixNQUFNLHVCQUF1QjtBQUNoSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EseUVBQXlFO0FBQ3pFO0FBQ0E7QUFDQSxnREFBZ0QsZ0JBQWdCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLGVBQWU7QUFDckY7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLHVCQUF1QixxQkFBcUIsZUFBZSxzQkFBc0IsMENBQTBDO0FBQ3BLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUYsZ0RBQWdELEVBQUUsdUJBQXVCLHNCQUFzQiwrQ0FBK0MsRUFBRSxzQkFBc0I7QUFDdlA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUZBQWlGLGdEQUFnRCxFQUFFLHVCQUF1QixzQkFBc0IsaURBQWlELEVBQUUsc0JBQXNCO0FBQ3pQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxrQkFBa0IsV0FBVyx1QkFBdUIsWUFBWSxzQkFBc0I7QUFDeEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCwyQkFBMkIsRUFBRSx1QkFBdUIsa0NBQWtDLDBCQUEwQixFQUFFLHNCQUFzQjtBQUN4TDtBQUNBO0FBQ0EsZ0RBQWdELDJCQUEyQixFQUFFLHVCQUF1QixpQ0FBaUMsMEJBQTBCLEVBQUUsc0JBQXNCO0FBQ3ZMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxvQ0FBb0MsbURBQW1ELGtCQUFrQjtBQUMvSyw4QkFBOEIsMkJBQTJCLEVBQUUsc0JBQXNCLFlBQVksNEJBQTRCLEVBQUUsc0JBQXNCO0FBQ2pKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGdCQUFnQixnQkFBZ0IsR0FBRyxpQkFBaUI7QUFDcEQsY0FBYyxxQkFBcUIsR0FBRyxzQkFBc0I7QUFDNUQsV0FBVyx1QkFBdUIsR0FBRyxXQUFXO0FBQ2hELGtCQUFrQiwyQkFBMkIsRUFBRTtBQUMvQyxtQkFBbUIsNEJBQTRCLEVBQUU7QUFDakQsZUFBZTtBQUNmLEVBQUUsZ0RBQWdELGVBQWU7QUFDakUsa0NBQWtDO0FBQ2xDLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsTUFBTTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtR0FBbUcsY0FBYyxhQUFhLGVBQWU7QUFDN0k7QUFDQSxhQUFhO0FBQ2I7QUFDQSx5RUFBeUUsZ0JBQWdCO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxNQUFNO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXJ2aXZhbC1mdW4vLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9hY3Jvc3MvYWNyb3NzQWN0aW9uUHJvdmlkZXIuanM/MmEzNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZFNldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZFNldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwgdmFsdWUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XG59O1xudmFyIF9fY2xhc3NQcml2YXRlRmllbGRHZXQgPSAodGhpcyAmJiB0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRHZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcbn07XG52YXIgX0Fjcm9zc0FjdGlvblByb3ZpZGVyX3ByaXZhdGVLZXk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmFjcm9zc0FjdGlvblByb3ZpZGVyID0gZXhwb3J0cy5BY3Jvc3NBY3Rpb25Qcm92aWRlciA9IHZvaWQgMDtcbmNvbnN0IHpvZF8xID0gcmVxdWlyZShcInpvZFwiKTtcbmNvbnN0IHZpZW1fMSA9IHJlcXVpcmUoXCJ2aWVtXCIpO1xuY29uc3QgYWN0aW9uUHJvdmlkZXJfMSA9IHJlcXVpcmUoXCIuLi9hY3Rpb25Qcm92aWRlclwiKTtcbmNvbnN0IG5ldHdvcmtfMSA9IHJlcXVpcmUoXCIuLi8uLi9uZXR3b3JrXCIpO1xuY29uc3QgYWN0aW9uRGVjb3JhdG9yXzEgPSByZXF1aXJlKFwiLi4vYWN0aW9uRGVjb3JhdG9yXCIpO1xuY29uc3Qgc2NoZW1hc18xID0gcmVxdWlyZShcIi4vc2NoZW1hc1wiKTtcbmNvbnN0IHdhbGxldF9wcm92aWRlcnNfMSA9IHJlcXVpcmUoXCIuLi8uLi93YWxsZXQtcHJvdmlkZXJzXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuY29uc3QgYWNjb3VudHNfMSA9IHJlcXVpcmUoXCJ2aWVtL2FjY291bnRzXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi4vZXJjMjAvY29uc3RhbnRzXCIpO1xuLyoqXG4gKiBBY3Jvc3NBY3Rpb25Qcm92aWRlciBwcm92aWRlcyBhY3Rpb25zIGZvciBjcm9zcy1jaGFpbiBicmlkZ2luZyB2aWEgQWNyb3NzIFByb3RvY29sLlxuICovXG5jbGFzcyBBY3Jvc3NBY3Rpb25Qcm92aWRlciBleHRlbmRzIGFjdGlvblByb3ZpZGVyXzEuQWN0aW9uUHJvdmlkZXIge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciB0aGUgQWNyb3NzQWN0aW9uUHJvdmlkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29uZmlnIC0gVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIEFjcm9zc0FjdGlvblByb3ZpZGVyLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICBzdXBlcihcImFjcm9zc1wiLCBbXSk7XG4gICAgICAgIF9BY3Jvc3NBY3Rpb25Qcm92aWRlcl9wcml2YXRlS2V5LnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2tzIGlmIHRoZSBBY3Jvc3MgYWN0aW9uIHByb3ZpZGVyIHN1cHBvcnRzIHRoZSBnaXZlbiBuZXR3b3JrLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gbmV0d29yayAtIFRoZSBuZXR3b3JrIHRvIGNoZWNrLlxuICAgICAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBBY3Jvc3MgYWN0aW9uIHByb3ZpZGVyIHN1cHBvcnRzIHRoZSBuZXR3b3JrLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN1cHBvcnRzTmV0d29yayA9IChuZXR3b3JrKSA9PiB7XG4gICAgICAgICAgICAvLyBBY3Jvc3Mgb25seSBzdXBwb3J0cyBFVk0tY29tcGF0aWJsZSBjaGFpbnNcbiAgICAgICAgICAgIHJldHVybiBuZXR3b3JrLnByb3RvY29sRmFtaWx5ID09PSBcImV2bVwiO1xuICAgICAgICB9O1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9BY3Jvc3NBY3Rpb25Qcm92aWRlcl9wcml2YXRlS2V5LCBjb25maWcucHJpdmF0ZUtleSwgXCJmXCIpO1xuICAgICAgICBjb25zdCBhY2NvdW50ID0gKDAsIGFjY291bnRzXzEucHJpdmF0ZUtleVRvQWNjb3VudCkoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQWNyb3NzQWN0aW9uUHJvdmlkZXJfcHJpdmF0ZUtleSwgXCJmXCIpKTtcbiAgICAgICAgaWYgKCFhY2NvdW50KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBwcml2YXRlIGtleVwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQnJpZGdlcyBhIHRva2VuIGZyb20gb25lIGNoYWluIHRvIGFub3RoZXIgdXNpbmcgQWNyb3NzIFByb3RvY29sLlxuICAgICAqXG4gICAgICogQHBhcmFtIHdhbGxldFByb3ZpZGVyIC0gVGhlIHdhbGxldCBwcm92aWRlciB0byB1c2UgZm9yIHRoZSB0cmFuc2FjdGlvbi5cbiAgICAgKiBAcGFyYW0gYXJncyAtIFRoZSBpbnB1dCBhcmd1bWVudHMgZm9yIHRoZSBhY3Rpb24uXG4gICAgICogQHJldHVybnMgQSBtZXNzYWdlIGNvbnRhaW5pbmcgdGhlIGJyaWRnZSBkZXRhaWxzLlxuICAgICAqL1xuICAgIGFzeW5jIGJyaWRnZVRva2VuKHdhbGxldFByb3ZpZGVyLCBhcmdzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBVc2UgZHluYW1pYyBpbXBvcnQgdG8gZ2V0IHRoZSBBY3Jvc3MgU0RLXG4gICAgICAgICAgICBjb25zdCBhY3Jvc3NNb2R1bGUgPSBhd2FpdCBpbXBvcnQoXCJAYWNyb3NzLXByb3RvY29sL2FwcC1zZGtcIik7XG4gICAgICAgICAgICBjb25zdCBjcmVhdGVBY3Jvc3NDbGllbnQgPSBhY3Jvc3NNb2R1bGUuY3JlYXRlQWNyb3NzQ2xpZW50O1xuICAgICAgICAgICAgLy8gR2V0IHJlY2lwaWVudCBhZGRyZXNzIGlmIHByb3ZpZGVkLCBvdGhlcndpc2UgdXNlIHNlbmRlclxuICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9IHdhbGxldFByb3ZpZGVyLmdldEFkZHJlc3MoKTtcbiAgICAgICAgICAgIGNvbnN0IHJlY2lwaWVudCA9IChhcmdzLnJlY2lwaWVudCB8fCBhZGRyZXNzKTtcbiAgICAgICAgICAgIC8vIEdldCBvcmlnaW4gY2hhaW5cbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbkNoYWluID0gKDAsIG5ldHdvcmtfMS5nZXRDaGFpbikod2FsbGV0UHJvdmlkZXIuZ2V0TmV0d29yaygpLmNoYWluSWQpO1xuICAgICAgICAgICAgaWYgKCFvcmlnaW5DaGFpbikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgb3JpZ2luIGNoYWluOiAke3dhbGxldFByb3ZpZGVyLmdldE5ldHdvcmsoKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEdldCBkZXN0aW5hdGlvbiBjaGFpblxuICAgICAgICAgICAgY29uc3QgZGVzdGluYXRpb25OZXR3b3JrSWQgPSBuZXR3b3JrXzEuQ0hBSU5fSURfVE9fTkVUV09SS19JRFtOdW1iZXIoYXJncy5kZXN0aW5hdGlvbkNoYWluSWQpXTtcbiAgICAgICAgICAgIGNvbnN0IGRlc3RpbmF0aW9uQ2hhaW4gPSBuZXR3b3JrXzEuTkVUV09SS19JRF9UT19WSUVNX0NIQUlOW2Rlc3RpbmF0aW9uTmV0d29ya0lkXTtcbiAgICAgICAgICAgIGlmICghZGVzdGluYXRpb25DaGFpbikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZGVzdGluYXRpb24gY2hhaW46ICR7YXJncy5kZXN0aW5hdGlvbkNoYWluSWR9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTYW5pdHkgY2hlY2tzXG4gICAgICAgICAgICBpZiAob3JpZ2luQ2hhaW4uaWQgPT09IGRlc3RpbmF0aW9uQ2hhaW4uaWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPcmlnaW4gYW5kIGRlc3RpbmF0aW9uIGNoYWlucyBjYW5ub3QgYmUgdGhlIHNhbWVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB1c2VUZXN0bmV0ID0gKDAsIHV0aWxzXzEuaXNBY3Jvc3NTdXBwb3J0ZWRUZXN0bmV0KShvcmlnaW5DaGFpbi5pZCk7XG4gICAgICAgICAgICBpZiAodXNlVGVzdG5ldCAhPT0gKDAsIHV0aWxzXzEuaXNBY3Jvc3NTdXBwb3J0ZWRUZXN0bmV0KShkZXN0aW5hdGlvbkNoYWluLmlkKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ3Jvc3MtY2hhaW4gdHJhbnNmZXJzIGJldHdlZW4gJHtvcmlnaW5DaGFpbi5uYW1lfSBhbmQgJHtkZXN0aW5hdGlvbkNoYWluLm5hbWV9IGFyZSBub3Qgc3VwcG9ydGVkLlxuICAgICAgICAgICBPcmlnaW4gYW5kIGRlc3RpbmF0aW9uIGNoYWlucyBtdXN0IGVpdGhlciBiZSBib3RoIHRlc3RuZXRzIG9yIGJvdGggbWFpbm5ldHMuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDcmVhdGUgd2FsbGV0IGNsaWVudFxuICAgICAgICAgICAgY29uc3QgYWNjb3VudCA9ICgwLCBhY2NvdW50c18xLnByaXZhdGVLZXlUb0FjY291bnQpKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Fjcm9zc0FjdGlvblByb3ZpZGVyX3ByaXZhdGVLZXksIFwiZlwiKSk7XG4gICAgICAgICAgICBpZiAoYWNjb3VudC5hZGRyZXNzICE9PSB3YWxsZXRQcm92aWRlci5nZXRBZGRyZXNzKCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQcml2YXRlIGtleSBkb2VzIG5vdCBtYXRjaCB3YWxsZXQgcHJvdmlkZXIgYWRkcmVzc1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHdhbGxldENsaWVudCA9ICgwLCB2aWVtXzEuY3JlYXRlV2FsbGV0Q2xpZW50KSh7XG4gICAgICAgICAgICAgICAgYWNjb3VudCxcbiAgICAgICAgICAgICAgICBjaGFpbjogb3JpZ2luQ2hhaW4sXG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0OiAoMCwgdmllbV8xLmh0dHApKCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBBY3Jvc3MgY2xpZW50XG4gICAgICAgICAgICBjb25zdCBhY3Jvc3NDbGllbnQgPSBjcmVhdGVBY3Jvc3NDbGllbnQoe1xuICAgICAgICAgICAgICAgIGNoYWluczogW29yaWdpbkNoYWluLCBkZXN0aW5hdGlvbkNoYWluXSxcbiAgICAgICAgICAgICAgICB1c2VUZXN0bmV0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBHZXQgY2hhaW4gZGV0YWlscyB0byBmaW5kIHRva2VuIGluZm9ybWF0aW9uXG4gICAgICAgICAgICBjb25zdCBjaGFpbkRldGFpbHMgPSBhd2FpdCBhY3Jvc3NDbGllbnQuZ2V0U3VwcG9ydGVkQ2hhaW5zKHt9KTtcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbkNoYWluRGV0YWlscyA9IGNoYWluRGV0YWlscy5maW5kKGNoYWluID0+IGNoYWluLmNoYWluSWQgPT09IG9yaWdpbkNoYWluLmlkKTtcbiAgICAgICAgICAgIGlmICghb3JpZ2luQ2hhaW5EZXRhaWxzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBPcmlnaW4gY2hhaW4gJHtvcmlnaW5DaGFpbi5pZH0gbm90IHN1cHBvcnRlZCBieSBBY3Jvc3MgUHJvdG9jb2xgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZpbmQgdG9rZW4gYnkgc3ltYm9sIG9uIHRoZSBvcmlnaW4gY2hhaW5cbiAgICAgICAgICAgIGNvbnN0IGlucHV0VG9rZW5zID0gb3JpZ2luQ2hhaW5EZXRhaWxzLmlucHV0VG9rZW5zO1xuICAgICAgICAgICAgaWYgKCFpbnB1dFRva2VucyB8fCBpbnB1dFRva2Vucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIGlucHV0IHRva2VucyBhdmFpbGFibGUgb24gY2hhaW4gJHtvcmlnaW5DaGFpbi5pZH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRva2VuSW5mbyA9IGlucHV0VG9rZW5zLmZpbmQodG9rZW4gPT4gdG9rZW4uc3ltYm9sLnRvVXBwZXJDYXNlKCkgPT09IGFyZ3MuaW5wdXRUb2tlblN5bWJvbC50b1VwcGVyQ2FzZSgpKTtcbiAgICAgICAgICAgIGlmICghdG9rZW5JbmZvKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUb2tlbiAke2FyZ3MuaW5wdXRUb2tlblN5bWJvbH0gbm90IGZvdW5kIG9uIGNoYWluICR7b3JpZ2luQ2hhaW4uaWR9LiBBdmFpbGFibGUgdG9rZW5zOiAke2lucHV0VG9rZW5zLm1hcCh0ID0+IHQuc3ltYm9sKS5qb2luKFwiLCBcIil9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBHZXQgdG9rZW4gYWRkcmVzcyBhbmQgZGVjaW1hbHMgdG8gcGFyc2UgdGhlIGFtb3VudFxuICAgICAgICAgICAgY29uc3QgaW5wdXRUb2tlbiA9IHRva2VuSW5mby5hZGRyZXNzO1xuICAgICAgICAgICAgY29uc3QgZGVjaW1hbHMgPSB0b2tlbkluZm8uZGVjaW1hbHM7XG4gICAgICAgICAgICBjb25zdCBpbnB1dEFtb3VudCA9ICgwLCB2aWVtXzEucGFyc2VVbml0cykoYXJncy5hbW91bnQsIGRlY2ltYWxzKTtcbiAgICAgICAgICAgIC8vIENoZWNrIGJhbGFuY2VcbiAgICAgICAgICAgIGNvbnN0IGlzTmF0aXZlID0gYXJncy5pbnB1dFRva2VuU3ltYm9sLnRvVXBwZXJDYXNlKCkgPT09IFwiRVRIXCI7XG4gICAgICAgICAgICBpZiAoaXNOYXRpdmUpIHtcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBuYXRpdmUgRVRIIGJhbGFuY2VcbiAgICAgICAgICAgICAgICBjb25zdCBldGhCYWxhbmNlID0gYXdhaXQgd2FsbGV0UHJvdmlkZXIuZ2V0QmFsYW5jZSgpO1xuICAgICAgICAgICAgICAgIGlmIChldGhCYWxhbmNlIDwgaW5wdXRBbW91bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnN1ZmZpY2llbnQgYmFsYW5jZS4gUmVxdWVzdGVkIHRvIGJyaWRnZSAkeygwLCB2aWVtXzEuZm9ybWF0VW5pdHMpKGlucHV0QW1vdW50LCBkZWNpbWFscyl9ICR7YXJncy5pbnB1dFRva2VuU3ltYm9sfSBidXQgYmFsYW5jZSBpcyBvbmx5ICR7KDAsIHZpZW1fMS5mb3JtYXRVbml0cykoZXRoQmFsYW5jZSwgZGVjaW1hbHMpfSAke2FyZ3MuaW5wdXRUb2tlblN5bWJvbH1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBFUkMyMCB0b2tlbiBiYWxhbmNlXG4gICAgICAgICAgICAgICAgY29uc3QgdG9rZW5CYWxhbmNlID0gKGF3YWl0IHdhbGxldFByb3ZpZGVyLnJlYWRDb250cmFjdCh7XG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IGlucHV0VG9rZW4sXG4gICAgICAgICAgICAgICAgICAgIGFiaTogY29uc3RhbnRzXzEuYWJpLFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWU6IFwiYmFsYW5jZU9mXCIsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFthZGRyZXNzXSxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuQmFsYW5jZSA8IGlucHV0QW1vdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW5zdWZmaWNpZW50IGJhbGFuY2UuIFJlcXVlc3RlZCB0byBicmlkZ2UgJHsoMCwgdmllbV8xLmZvcm1hdFVuaXRzKShpbnB1dEFtb3VudCwgZGVjaW1hbHMpfSAke2FyZ3MuaW5wdXRUb2tlblN5bWJvbH0gYnV0IGJhbGFuY2UgaXMgb25seSAkeygwLCB2aWVtXzEuZm9ybWF0VW5pdHMpKHRva2VuQmFsYW5jZSwgZGVjaW1hbHMpfSAke2FyZ3MuaW5wdXRUb2tlblN5bWJvbH1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBHZXQgYXZhaWxhYmxlIHJvdXRlc1xuICAgICAgICAgICAgY29uc3Qgcm91dGVJbmZvID0gYXdhaXQgYWNyb3NzQ2xpZW50LmdldEF2YWlsYWJsZVJvdXRlcyh7XG4gICAgICAgICAgICAgICAgb3JpZ2luQ2hhaW5JZDogb3JpZ2luQ2hhaW4uaWQsXG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb25DaGFpbklkOiBkZXN0aW5hdGlvbkNoYWluLmlkLFxuICAgICAgICAgICAgICAgIG9yaWdpblRva2VuOiBpbnB1dFRva2VuLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBTZWxlY3QgdGhlIGFwcHJvcHJpYXRlIHJvdXRlIGZvciBuYXRpdmUgRVRIIG9yIEVSQzIwIHRva2VuXG4gICAgICAgICAgICBjb25zdCByb3V0ZSA9IHJvdXRlSW5mby5maW5kKHJvdXRlID0+IHJvdXRlLmlzTmF0aXZlID09PSBpc05hdGl2ZSk7XG4gICAgICAgICAgICBpZiAoIXJvdXRlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyByb3V0ZXMgYXZhaWxhYmxlIGZyb20gY2hhaW4gJHtvcmlnaW5DaGFpbi5uYW1lfSB0byBjaGFpbiAke2Rlc3RpbmF0aW9uQ2hhaW4ubmFtZX0gZm9yIHRva2VuICR7YXJncy5pbnB1dFRva2VuU3ltYm9sfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gR2V0IHF1b3RlXG4gICAgICAgICAgICBjb25zdCBxdW90ZSA9IGF3YWl0IGFjcm9zc0NsaWVudC5nZXRRdW90ZSh7XG4gICAgICAgICAgICAgICAgcm91dGUsXG4gICAgICAgICAgICAgICAgaW5wdXRBbW91bnQsXG4gICAgICAgICAgICAgICAgcmVjaXBpZW50LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IHVuaXRzIHRvIHJlYWRhYmxlIGZvcm1hdFxuICAgICAgICAgICAgY29uc3QgZm9ybWF0dGVkSW5mbyA9IHtcbiAgICAgICAgICAgICAgICBtaW5EZXBvc2l0OiAoMCwgdmllbV8xLmZvcm1hdFVuaXRzKShxdW90ZS5saW1pdHMubWluRGVwb3NpdCwgZGVjaW1hbHMpLFxuICAgICAgICAgICAgICAgIG1heERlcG9zaXQ6ICgwLCB2aWVtXzEuZm9ybWF0VW5pdHMpKHF1b3RlLmxpbWl0cy5tYXhEZXBvc2l0LCBkZWNpbWFscyksXG4gICAgICAgICAgICAgICAgaW5wdXRBbW91bnQ6ICgwLCB2aWVtXzEuZm9ybWF0VW5pdHMpKHF1b3RlLmRlcG9zaXQuaW5wdXRBbW91bnQsIGRlY2ltYWxzKSxcbiAgICAgICAgICAgICAgICBvdXRwdXRBbW91bnQ6ICgwLCB2aWVtXzEuZm9ybWF0VW5pdHMpKHF1b3RlLmRlcG9zaXQub3V0cHV0QW1vdW50LCBkZWNpbWFscyksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgaW5wdXQgYW1vdW50IGlzIHdpdGhpbiB2YWxpZCBkZXBvc2l0IHJhbmdlXG4gICAgICAgICAgICBpZiAocXVvdGUuZGVwb3NpdC5pbnB1dEFtb3VudCA8IHF1b3RlLmxpbWl0cy5taW5EZXBvc2l0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnB1dCBhbW91bnQgJHtmb3JtYXR0ZWRJbmZvLmlucHV0QW1vdW50fSAke2FyZ3MuaW5wdXRUb2tlblN5bWJvbH0gaXMgYmVsb3cgdGhlIG1pbmltdW0gZGVwb3NpdCBvZiAke2Zvcm1hdHRlZEluZm8ubWluRGVwb3NpdH0gJHthcmdzLmlucHV0VG9rZW5TeW1ib2x9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocXVvdGUuZGVwb3NpdC5pbnB1dEFtb3VudCA+IHF1b3RlLmxpbWl0cy5tYXhEZXBvc2l0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnB1dCBhbW91bnQgJHtmb3JtYXR0ZWRJbmZvLmlucHV0QW1vdW50fSAke2FyZ3MuaW5wdXRUb2tlblN5bWJvbH0gZXhjZWVkcyB0aGUgbWF4aW11bSBkZXBvc2l0IG9mICR7Zm9ybWF0dGVkSW5mby5tYXhEZXBvc2l0fSAke2FyZ3MuaW5wdXRUb2tlblN5bWJvbH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIG91dHB1dCBhbW91bnQgaXMgd2l0aGluIGFjY2VwdGFibGUgc2xpcHBhZ2UgbGltaXRzXG4gICAgICAgICAgICBjb25zdCBhY3R1YWxTbGlwcGFnZVBlcmNlbnRhZ2UgPSAoKE51bWJlcihmb3JtYXR0ZWRJbmZvLmlucHV0QW1vdW50KSAtIE51bWJlcihmb3JtYXR0ZWRJbmZvLm91dHB1dEFtb3VudCkpIC9cbiAgICAgICAgICAgICAgICBOdW1iZXIoZm9ybWF0dGVkSW5mby5pbnB1dEFtb3VudCkpICpcbiAgICAgICAgICAgICAgICAxMDA7XG4gICAgICAgICAgICBpZiAoYWN0dWFsU2xpcHBhZ2VQZXJjZW50YWdlID4gYXJncy5tYXhTcGxpcHBhZ2UpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE91dHB1dCBhbW91bnQgaGFzIGhpZ2ggc2xpcHBhZ2Ugb2YgJHthY3R1YWxTbGlwcGFnZVBlcmNlbnRhZ2UudG9GaXhlZCgyKX0lLCB3aGljaCBleGNlZWRzIHRoZSBtYXhpbXVtIGFsbG93ZWQgc2xpcHBhZ2Ugb2YgJHthcmdzLm1heFNwbGlwcGFnZX0lLiBgICtcbiAgICAgICAgICAgICAgICAgICAgYElucHV0OiAke2Zvcm1hdHRlZEluZm8uaW5wdXRBbW91bnR9ICR7YXJncy5pbnB1dFRva2VuU3ltYm9sfSwgT3V0cHV0OiAke2Zvcm1hdHRlZEluZm8ub3V0cHV0QW1vdW50fSAke2FyZ3MuaW5wdXRUb2tlblN5bWJvbH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vQXBwcm92ZSBFUkMyMCB0b2tlbiBpZiBuZWVkZWRcbiAgICAgICAgICAgIGxldCBhcHByb3ZhbFR4SGFzaDtcbiAgICAgICAgICAgIGlmICghaXNOYXRpdmUpIHtcbiAgICAgICAgICAgICAgICBhcHByb3ZhbFR4SGFzaCA9IGF3YWl0IHdhbGxldFByb3ZpZGVyLnNlbmRUcmFuc2FjdGlvbih7XG4gICAgICAgICAgICAgICAgICAgIHRvOiBpbnB1dFRva2VuLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiAoMCwgdmllbV8xLmVuY29kZUZ1bmN0aW9uRGF0YSkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgYWJpOiBjb25zdGFudHNfMS5hYmksXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWU6IFwiYXBwcm92ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogW3F1b3RlLmRlcG9zaXQuc3Bva2VQb29sQWRkcmVzcywgcXVvdGUuZGVwb3NpdC5pbnB1dEFtb3VudF0sXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGF3YWl0IHdhbGxldFByb3ZpZGVyLndhaXRGb3JUcmFuc2FjdGlvblJlY2VpcHQoYXBwcm92YWxUeEhhc2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU2ltdWxhdGUgdGhlIGRlcG9zaXQgdHJhbnNhY3Rpb25cbiAgICAgICAgICAgIGNvbnN0IHsgcmVxdWVzdCB9ID0gYXdhaXQgYWNyb3NzQ2xpZW50LnNpbXVsYXRlRGVwb3NpdFR4KHtcbiAgICAgICAgICAgICAgICB3YWxsZXRDbGllbnQ6IHdhbGxldENsaWVudCxcbiAgICAgICAgICAgICAgICBkZXBvc2l0OiBxdW90ZS5kZXBvc2l0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBFeGVjdXRlIHRoZSBkZXBvc2l0IHRyYW5zYWN0aW9uXG4gICAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvbkhhc2ggPSBhd2FpdCB3YWxsZXRDbGllbnQud3JpdGVDb250cmFjdChyZXF1ZXN0KTtcbiAgICAgICAgICAgIC8vIFdhaXQgZm9yIHR4IHRvIGJlIG1pbmVkXG4gICAgICAgICAgICBjb25zdCB7IGRlcG9zaXRJZCB9ID0gYXdhaXQgYWNyb3NzQ2xpZW50LndhaXRGb3JEZXBvc2l0VHgoe1xuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uSGFzaCxcbiAgICAgICAgICAgICAgICBvcmlnaW5DaGFpbklkOiBvcmlnaW5DaGFpbi5pZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGBcblN1Y2Nlc3NmdWxseSBkZXBvc2l0ZWQgdG9rZW5zOlxuLSBGcm9tOiBDaGFpbiAke29yaWdpbkNoYWluLmlkfSAoJHtvcmlnaW5DaGFpbi5uYW1lfSlcbi0gVG86IENoYWluICR7ZGVzdGluYXRpb25DaGFpbi5pZH0gKCR7ZGVzdGluYXRpb25DaGFpbi5uYW1lfSlcbi0gVG9rZW46ICR7YXJncy5pbnB1dFRva2VuU3ltYm9sfSAoJHtpbnB1dFRva2VufSlcbi0gSW5wdXQgQW1vdW50OiAke2Zvcm1hdHRlZEluZm8uaW5wdXRBbW91bnR9ICR7YXJncy5pbnB1dFRva2VuU3ltYm9sfVxuLSBPdXRwdXQgQW1vdW50OiAke2Zvcm1hdHRlZEluZm8ub3V0cHV0QW1vdW50fSAke2FyZ3MuaW5wdXRUb2tlblN5bWJvbH1cbi0gUmVjaXBpZW50OiAke3JlY2lwaWVudH1cbiR7IWlzTmF0aXZlID8gYC0gVHJhbnNhY3Rpb24gSGFzaCBmb3IgYXBwcm92YWw6ICR7YXBwcm92YWxUeEhhc2h9XFxuYCA6IFwiXCJ9XG4tIFRyYW5zYWN0aW9uIEhhc2ggZm9yIGRlcG9zaXQ6ICR7dHJhbnNhY3Rpb25IYXNofVxuLSBEZXBvc2l0IElEOiAke2RlcG9zaXRJZH1cbiAgICAgICAgYDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBgRXJyb3Igd2l0aCBBY3Jvc3MgU0RLOiAke2Vycm9yfWA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHRoZSBzdGF0dXMgb2YgYSBicmlkZ2UgZGVwb3NpdCB2aWEgQWNyb3NzIFByb3RvY29sLlxuICAgICAqXG4gICAgICogQHBhcmFtIHdhbGxldFByb3ZpZGVyIC0gVGhlIHdhbGxldCBwcm92aWRlciB0byB1c2UgZm9yIHRoZSB0cmFuc2FjdGlvbi5cbiAgICAgKiBAcGFyYW0gYXJncyAtIFRoZSBpbnB1dCBhcmd1bWVudHMgZm9yIHRoZSBhY3Rpb24uXG4gICAgICogQHJldHVybnMgQSBtZXNzYWdlIGNvbnRhaW5pbmcgdGhlIGRlcG9zaXQgc3RhdHVzIGRldGFpbHMuXG4gICAgICovXG4gICAgYXN5bmMgY2hlY2tEZXBvc2l0U3RhdHVzKHdhbGxldFByb3ZpZGVyLCBhcmdzKSB7XG4gICAgICAgIGNvbnN0IG9yaWdpbkNoYWluSWQgPSBOdW1iZXIoYXJncy5vcmlnaW5DaGFpbklkKSB8fCBOdW1iZXIod2FsbGV0UHJvdmlkZXIuZ2V0TmV0d29yaygpLmNoYWluSWQpO1xuICAgICAgICBpZiAoKDAsIHV0aWxzXzEuaXNBY3Jvc3NTdXBwb3J0ZWRUZXN0bmV0KShvcmlnaW5DaGFpbklkKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2hlY2tpbmcgZGVwb3NpdCBzdGF0dXMgb24gdGVzdG5ldHMgaXMgY3VycmVudGx5IG5vdCBzdXBwb3J0ZWQgYnkgdGhlIEFjcm9zcyBBUElcIik7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYGh0dHBzOi8vYXBwLmFjcm9zcy50by9hcGkvZGVwb3NpdC9zdGF0dXM/b3JpZ2luQ2hhaW5JZD0ke29yaWdpbkNoYWluSWR9JmRlcG9zaXRJZD0ke2FyZ3MuZGVwb3NpdElkfWAsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFjcm9zcyBBUEkgcmVxdWVzdCBmYWlsZWQgd2l0aCBzdGF0dXMgJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhcGlEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgLy8gR2V0IGNoYWluIG5hbWVzXG4gICAgICAgICAgICBjb25zdCBvcmlnaW5DaGFpbk5hbWUgPSAoMCwgbmV0d29ya18xLmdldENoYWluKShTdHJpbmcoYXBpRGF0YS5vcmlnaW5DaGFpbklkKSk/Lm5hbWUgfHwgXCJVbmtub3duIENoYWluXCI7XG4gICAgICAgICAgICBjb25zdCBkZXN0aW5hdGlvbkNoYWluTmFtZSA9ICgwLCBuZXR3b3JrXzEuZ2V0Q2hhaW4pKFN0cmluZyhhcGlEYXRhLmRlc3RpbmF0aW9uQ2hhaW5JZCkpPy5uYW1lIHx8IFwiVW5rbm93biBDaGFpblwiO1xuICAgICAgICAgICAgLy8gQ3JlYXRlIHN0cnVjdHVyZWQgcmVzcG9uc2VcbiAgICAgICAgICAgIGNvbnN0IHN0cnVjdHVyZWRSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICBzdGF0dXM6IGFwaURhdGEuc3RhdHVzIHx8IFwidW5rbm93blwiLFxuICAgICAgICAgICAgICAgIGRlcG9zaXRUeEluZm86IGFwaURhdGEuZGVwb3NpdFR4SGFzaFxuICAgICAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR4SGFzaDogYXBpRGF0YS5kZXBvc2l0VHhIYXNoLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW5JZDogYXBpRGF0YS5vcmlnaW5DaGFpbklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW5OYW1lOiBvcmlnaW5DaGFpbk5hbWUsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgOiBudWxsLFxuICAgICAgICAgICAgICAgIGZpbGxUeEluZm86IGFwaURhdGEuZmlsbFR4XG4gICAgICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHhIYXNoOiBhcGlEYXRhLmZpbGxUeCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYWluSWQ6IGFwaURhdGEuZGVzdGluYXRpb25DaGFpbklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW5OYW1lOiBkZXN0aW5hdGlvbkNoYWluTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICA6IG51bGwsXG4gICAgICAgICAgICAgICAgZGVwb3NpdFJlZnVuZFR4SW5mbzogYXBpRGF0YS5kZXBvc2l0UmVmdW5kVHhIYXNoXG4gICAgICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHhIYXNoOiBhcGlEYXRhLmRlcG9zaXRSZWZ1bmRUeEhhc2gsXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFpbklkOiBhcGlEYXRhLm9yaWdpbkNoYWluSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFpbk5hbWU6IG9yaWdpbkNoYWluTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICA6IG51bGwsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHN0cnVjdHVyZWRSZXNwb25zZSwgbnVsbCwgMik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gYEVycm9yIGNoZWNraW5nIGRlcG9zaXQgc3RhdHVzOiAke2Vycm9yfWA7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkFjcm9zc0FjdGlvblByb3ZpZGVyID0gQWNyb3NzQWN0aW9uUHJvdmlkZXI7XG5fQWNyb3NzQWN0aW9uUHJvdmlkZXJfcHJpdmF0ZUtleSA9IG5ldyBXZWFrTWFwKCk7XG5fX2RlY29yYXRlKFtcbiAgICAoMCwgYWN0aW9uRGVjb3JhdG9yXzEuQ3JlYXRlQWN0aW9uKSh7XG4gICAgICAgIG5hbWU6IFwiYnJpZGdlX3Rva2VuXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgXG4gICAgVGhpcyB0b29sIHdpbGwgYnJpZGdlIHRva2VucyBmcm9tIHRoZSBjdXJyZW50IGNoYWluIHRvIGFub3RoZXIgY2hhaW4gdXNpbmcgdGhlIEFjcm9zcyBQcm90b2NvbC5cblxuICAgIEl0IHRha2VzIHRoZSBmb2xsb3dpbmcgaW5wdXRzOlxuICAgIC0gZGVzdGluYXRpb25DaGFpbklkOiBUaGUgY2hhaW4gSUQgb2YgdGhlIGRlc3RpbmF0aW9uIGNoYWluIChlLmcuIDg0NTMgZm9yIGJhc2UtbWFpbm5ldClcbiAgICAtIGlucHV0VG9rZW5TeW1ib2w6IFRoZSBzeW1ib2wgb2YgdGhlIHRva2VuIHRvIGJyaWRnZSAoZS5nLiAnRVRIJywgJ1VTREMnKVxuICAgIC0gYW1vdW50OiBUaGUgYW1vdW50IG9mIHRva2VucyB0byBicmlkZ2UgaW4gd2hvbGUgdW5pdHMgKGUuZy4gMS41IFdFVEgsIDEwIFVTREMpXG4gICAgLSByZWNpcGllbnQ6IChPcHRpb25hbCkgVGhlIHJlY2lwaWVudCBhZGRyZXNzIG9uIHRoZSBkZXN0aW5hdGlvbiBjaGFpbiAoZGVmYXVsdHMgdG8gc2VuZGVyKVxuICAgIC0gbWF4U3BsaXBwYWdlOiAoT3B0aW9uYWwpIFRoZSBtYXhpbXVtIHNsaXBwYWdlIHBlcmNlbnRhZ2UgKGRlZmF1bHRzIHRvIDEuNSUpXG5cbiAgICBJbXBvcnRhbnQgbm90ZXM6XG4gICAgLSBPcmlnaW4gY2hhaW4gaXMgdGhlIGN1cnJlbnRseSBjb25uZWN0ZWQgY2hhaW4gb2YgdGhlIHdhbGxldCBwcm92aWRlciBcbiAgICAtIFN1cHBvcnRzIGNyb3NzLWNoYWluIHRyYW5zZmVycyBiZXR3ZWVuIEVWTS1jb21wYXRpYmxlIGNoYWlucyBmb3IgYm90aCBtYWlubmV0cyBhbmQgdGVzdCBuZXR3b3Jrc1xuICAgIC0gVGVzdG5ldCBkZXBvc2l0cyBhcmUgbm90IHJlZnVuZGVkIGlmIG5vdCBmaWxsZWQgb24gZGVzdGluYXRpb24gY2hhaW5cbiAgICAtIEVuc3VyZSBzdWZmaWNpZW50IGJhbGFuY2Ugb2YgdGhlIGlucHV0IHRva2VuIGJlZm9yZSBicmlkZ2luZ1xuICAgIC0gUmV0dXJucyBkZXBvc2l0IElEIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2hlY2sgdGhlIHN0YXR1cyBvZiB0aGUgZGVwb3NpdFxuICAgIGAsXG4gICAgICAgIHNjaGVtYTogc2NoZW1hc18xLkJyaWRnZVRva2VuU2NoZW1hLFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFt3YWxsZXRfcHJvdmlkZXJzXzEuRXZtV2FsbGV0UHJvdmlkZXIsIHZvaWQgMF0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCBQcm9taXNlKVxuXSwgQWNyb3NzQWN0aW9uUHJvdmlkZXIucHJvdG90eXBlLCBcImJyaWRnZVRva2VuXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgKDAsIGFjdGlvbkRlY29yYXRvcl8xLkNyZWF0ZUFjdGlvbikoe1xuICAgICAgICBuYW1lOiBcImNoZWNrX2RlcG9zaXRfc3RhdHVzXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgXG4gICAgVGhpcyB0b29sIHdpbGwgY2hlY2sgdGhlIHN0YXR1cyBvZiBhIGNyb3NzLWNoYWluIGJyaWRnZSBkZXBvc2l0IG9uIHRoZSBBY3Jvc3MgUHJvdG9jb2wuXG4gICAgXG4gICAgSXQgdGFrZXMgdGhlIGZvbGxvd2luZyBpbnB1dHM6XG4gICAgLSBvcmlnaW5DaGFpbklkOiBUaGUgY2hhaW4gSUQgb2YgdGhlIG9yaWdpbiBjaGFpbiAoZGVmYXVsdHMgdG8gdGhlIGN1cnJlbnQgY2hhaW4pXG4gICAgLSBkZXBvc2l0SWQ6IFRoZSBJRCBvZiB0aGUgZGVwb3NpdCB0byBjaGVjayAocmV0dXJuZWQgYnkgdGhlIGJyaWRnZSBkZXBvc2l0IHRyYW5zYWN0aW9uKVxuICAgIGAsXG4gICAgICAgIHNjaGVtYTogc2NoZW1hc18xLkNoZWNrRGVwb3NpdFN0YXR1c1NjaGVtYSxcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbd2FsbGV0X3Byb3ZpZGVyc18xLkV2bVdhbGxldFByb3ZpZGVyLCB2b2lkIDBdKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgUHJvbWlzZSlcbl0sIEFjcm9zc0FjdGlvblByb3ZpZGVyLnByb3RvdHlwZSwgXCJjaGVja0RlcG9zaXRTdGF0dXNcIiwgbnVsbCk7XG5jb25zdCBhY3Jvc3NBY3Rpb25Qcm92aWRlciA9IChjb25maWcpID0+IG5ldyBBY3Jvc3NBY3Rpb25Qcm92aWRlcihjb25maWcpO1xuZXhwb3J0cy5hY3Jvc3NBY3Rpb25Qcm92aWRlciA9IGFjcm9zc0FjdGlvblByb3ZpZGVyO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/across/acrossActionProvider.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/across/index.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/across/index.js ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./acrossActionProvider */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/across/acrossActionProvider.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9hY3Jvc3MvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYSxtQkFBTyxDQUFDLDRIQUF3QiIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cnZpdmFsLWZ1bi8uL25vZGVfbW9kdWxlcy9AY29pbmJhc2UvYWdlbnRraXQvZGlzdC9hY3Rpb24tcHJvdmlkZXJzL2Fjcm9zcy9pbmRleC5qcz8xZWFmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYWNyb3NzQWN0aW9uUHJvdmlkZXJcIiksIGV4cG9ydHMpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/across/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/across/schemas.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/across/schemas.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CheckDepositStatusSchema = exports.BridgeTokenSchema = void 0;\nconst zod_1 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/lib/index.js\");\n/**\n * Input schema for bridge token action.\n */\nexports.BridgeTokenSchema = zod_1.z\n    .object({\n    destinationChainId: zod_1.z\n        .string()\n        .describe(\"The chain ID of the destination chain (e.g. 11155111 for ethereum-sepolia)\"),\n    inputTokenSymbol: zod_1.z\n        .string()\n        .describe(\"The symbol of the token to bridge (e.g., 'ETH', 'WETH', 'USDC')\")\n        .default(\"ETH\"),\n    amount: zod_1.z\n        .string()\n        .describe(\"The amount of tokens to bridge in whole units (e.g. 1.5 WETH, 10 USDC)\"),\n    recipient: zod_1.z\n        .string()\n        .optional()\n        .describe(\"The recipient address on the destination chain (defaults to sender)\"),\n    maxSplippage: zod_1.z\n        .number()\n        .optional()\n        .describe(\"The maximum slippage percentage (e.g. 10 for 10%)\")\n        .default(1.5),\n})\n    .strip()\n    .describe(\"Instructions for bridging tokens across chains using Across Protocol\");\n/**\n * Input schema for check deposit status action.\n */\nexports.CheckDepositStatusSchema = zod_1.z\n    .object({\n    originChainId: zod_1.z\n        .string()\n        .optional()\n        .describe(\"The chain ID of the origin chain (defaults to the current chain)\"),\n    depositId: zod_1.z\n        .string()\n        .describe(\"The ID of the deposit to check (returned by the bridge deposit transaction)\"),\n})\n    .strip()\n    .describe(\"Instructions for checking the status of a deposit on Across Protocol\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9hY3Jvc3Mvc2NoZW1hcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQ0FBZ0MsR0FBRyx5QkFBeUI7QUFDNUQsY0FBYyxtQkFBTyxDQUFDLGtEQUFLO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3Vydml2YWwtZnVuLy4vbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9hZ2VudGtpdC9kaXN0L2FjdGlvbi1wcm92aWRlcnMvYWNyb3NzL3NjaGVtYXMuanM/ZWNhZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2hlY2tEZXBvc2l0U3RhdHVzU2NoZW1hID0gZXhwb3J0cy5CcmlkZ2VUb2tlblNjaGVtYSA9IHZvaWQgMDtcbmNvbnN0IHpvZF8xID0gcmVxdWlyZShcInpvZFwiKTtcbi8qKlxuICogSW5wdXQgc2NoZW1hIGZvciBicmlkZ2UgdG9rZW4gYWN0aW9uLlxuICovXG5leHBvcnRzLkJyaWRnZVRva2VuU2NoZW1hID0gem9kXzEuelxuICAgIC5vYmplY3Qoe1xuICAgIGRlc3RpbmF0aW9uQ2hhaW5JZDogem9kXzEuelxuICAgICAgICAuc3RyaW5nKClcbiAgICAgICAgLmRlc2NyaWJlKFwiVGhlIGNoYWluIElEIG9mIHRoZSBkZXN0aW5hdGlvbiBjaGFpbiAoZS5nLiAxMTE1NTExMSBmb3IgZXRoZXJldW0tc2Vwb2xpYSlcIiksXG4gICAgaW5wdXRUb2tlblN5bWJvbDogem9kXzEuelxuICAgICAgICAuc3RyaW5nKClcbiAgICAgICAgLmRlc2NyaWJlKFwiVGhlIHN5bWJvbCBvZiB0aGUgdG9rZW4gdG8gYnJpZGdlIChlLmcuLCAnRVRIJywgJ1dFVEgnLCAnVVNEQycpXCIpXG4gICAgICAgIC5kZWZhdWx0KFwiRVRIXCIpLFxuICAgIGFtb3VudDogem9kXzEuelxuICAgICAgICAuc3RyaW5nKClcbiAgICAgICAgLmRlc2NyaWJlKFwiVGhlIGFtb3VudCBvZiB0b2tlbnMgdG8gYnJpZGdlIGluIHdob2xlIHVuaXRzIChlLmcuIDEuNSBXRVRILCAxMCBVU0RDKVwiKSxcbiAgICByZWNpcGllbnQ6IHpvZF8xLnpcbiAgICAgICAgLnN0cmluZygpXG4gICAgICAgIC5vcHRpb25hbCgpXG4gICAgICAgIC5kZXNjcmliZShcIlRoZSByZWNpcGllbnQgYWRkcmVzcyBvbiB0aGUgZGVzdGluYXRpb24gY2hhaW4gKGRlZmF1bHRzIHRvIHNlbmRlcilcIiksXG4gICAgbWF4U3BsaXBwYWdlOiB6b2RfMS56XG4gICAgICAgIC5udW1iZXIoKVxuICAgICAgICAub3B0aW9uYWwoKVxuICAgICAgICAuZGVzY3JpYmUoXCJUaGUgbWF4aW11bSBzbGlwcGFnZSBwZXJjZW50YWdlIChlLmcuIDEwIGZvciAxMCUpXCIpXG4gICAgICAgIC5kZWZhdWx0KDEuNSksXG59KVxuICAgIC5zdHJpcCgpXG4gICAgLmRlc2NyaWJlKFwiSW5zdHJ1Y3Rpb25zIGZvciBicmlkZ2luZyB0b2tlbnMgYWNyb3NzIGNoYWlucyB1c2luZyBBY3Jvc3MgUHJvdG9jb2xcIik7XG4vKipcbiAqIElucHV0IHNjaGVtYSBmb3IgY2hlY2sgZGVwb3NpdCBzdGF0dXMgYWN0aW9uLlxuICovXG5leHBvcnRzLkNoZWNrRGVwb3NpdFN0YXR1c1NjaGVtYSA9IHpvZF8xLnpcbiAgICAub2JqZWN0KHtcbiAgICBvcmlnaW5DaGFpbklkOiB6b2RfMS56XG4gICAgICAgIC5zdHJpbmcoKVxuICAgICAgICAub3B0aW9uYWwoKVxuICAgICAgICAuZGVzY3JpYmUoXCJUaGUgY2hhaW4gSUQgb2YgdGhlIG9yaWdpbiBjaGFpbiAoZGVmYXVsdHMgdG8gdGhlIGN1cnJlbnQgY2hhaW4pXCIpLFxuICAgIGRlcG9zaXRJZDogem9kXzEuelxuICAgICAgICAuc3RyaW5nKClcbiAgICAgICAgLmRlc2NyaWJlKFwiVGhlIElEIG9mIHRoZSBkZXBvc2l0IHRvIGNoZWNrIChyZXR1cm5lZCBieSB0aGUgYnJpZGdlIGRlcG9zaXQgdHJhbnNhY3Rpb24pXCIpLFxufSlcbiAgICAuc3RyaXAoKVxuICAgIC5kZXNjcmliZShcIkluc3RydWN0aW9ucyBmb3IgY2hlY2tpbmcgdGhlIHN0YXR1cyBvZiBhIGRlcG9zaXQgb24gQWNyb3NzIFByb3RvY29sXCIpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/across/schemas.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/across/utils.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/across/utils.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isAcrossSupportedTestnet = isAcrossSupportedTestnet;\n/**\n * Checks if a chain ID corresponds to a testnet network supported by Across\n *\n * @param chainId - The blockchain network chain ID\n * @returns true if the chain ID corresponds to a testnet network supported by Across, false otherwise\n */\nfunction isAcrossSupportedTestnet(chainId) {\n    // List of testnet chain IDs\n    const testnetChainIds = [\n        11155111, // Sepolia\n        84532, // Base Sepolia\n        421614, // Arbitrum Sepolia\n        11155420, // Optimism Sepolia\n        919, // Mode Sepolia\n        80002, // Polygon Amoy\n        168587773, // Blast Sepolia\n        4202, // Lisk Sepolia\n        37111, // Lens Sepolia\n        1301, // Unichain Sepolia\n    ];\n    return testnetChainIds.includes(chainId);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9hY3Jvc3MvdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3Vydml2YWwtZnVuLy4vbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9hZ2VudGtpdC9kaXN0L2FjdGlvbi1wcm92aWRlcnMvYWNyb3NzL3V0aWxzLmpzP2M3YjUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmlzQWNyb3NzU3VwcG9ydGVkVGVzdG5ldCA9IGlzQWNyb3NzU3VwcG9ydGVkVGVzdG5ldDtcbi8qKlxuICogQ2hlY2tzIGlmIGEgY2hhaW4gSUQgY29ycmVzcG9uZHMgdG8gYSB0ZXN0bmV0IG5ldHdvcmsgc3VwcG9ydGVkIGJ5IEFjcm9zc1xuICpcbiAqIEBwYXJhbSBjaGFpbklkIC0gVGhlIGJsb2NrY2hhaW4gbmV0d29yayBjaGFpbiBJRFxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgY2hhaW4gSUQgY29ycmVzcG9uZHMgdG8gYSB0ZXN0bmV0IG5ldHdvcmsgc3VwcG9ydGVkIGJ5IEFjcm9zcywgZmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbmZ1bmN0aW9uIGlzQWNyb3NzU3VwcG9ydGVkVGVzdG5ldChjaGFpbklkKSB7XG4gICAgLy8gTGlzdCBvZiB0ZXN0bmV0IGNoYWluIElEc1xuICAgIGNvbnN0IHRlc3RuZXRDaGFpbklkcyA9IFtcbiAgICAgICAgMTExNTUxMTEsIC8vIFNlcG9saWFcbiAgICAgICAgODQ1MzIsIC8vIEJhc2UgU2Vwb2xpYVxuICAgICAgICA0MjE2MTQsIC8vIEFyYml0cnVtIFNlcG9saWFcbiAgICAgICAgMTExNTU0MjAsIC8vIE9wdGltaXNtIFNlcG9saWFcbiAgICAgICAgOTE5LCAvLyBNb2RlIFNlcG9saWFcbiAgICAgICAgODAwMDIsIC8vIFBvbHlnb24gQW1veVxuICAgICAgICAxNjg1ODc3NzMsIC8vIEJsYXN0IFNlcG9saWFcbiAgICAgICAgNDIwMiwgLy8gTGlzayBTZXBvbGlhXG4gICAgICAgIDM3MTExLCAvLyBMZW5zIFNlcG9saWFcbiAgICAgICAgMTMwMSwgLy8gVW5pY2hhaW4gU2Vwb2xpYVxuICAgIF07XG4gICAgcmV0dXJuIHRlc3RuZXRDaGFpbklkcy5pbmNsdWRlcyhjaGFpbklkKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/across/utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/actionDecorator.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/actionDecorator.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ACTION_DECORATOR_KEY = void 0;\nexports.CreateAction = CreateAction;\nconst wallet_providers_1 = __webpack_require__(/*! ../wallet-providers */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/wallet-providers/index.js\");\nconst analytics_1 = __webpack_require__(/*! ../analytics */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/analytics/index.js\");\n__webpack_require__(/*! reflect-metadata */ \"(rsc)/./node_modules/reflect-metadata/Reflect.js\");\n/**\n * Metadata key for the action decorator\n */\nexports.ACTION_DECORATOR_KEY = Symbol(\"agentkit:action\");\n/**\n * Decorator to embed metadata on class methods to indicate they are actions accessible to the agent\n *\n * @param params - The parameters for the action decorator\n * @returns A decorator function\n *\n * @example\n * ```typescript\n * class MyActionProvider extends ActionProvider {\n *   @CreateAction({ name: \"my_action\", description: \"My action\", schema: myActionSchema })\n *   public myAction(args: z.infer<typeof myActionSchema>) {\n *     // ...\n *   }\n * }\n * ```\n */\nfunction CreateAction(params) {\n    return (target, propertyKey, descriptor) => {\n        const prefixedActionName = `${target.constructor.name}_${params.name}`;\n        const originalMethod = descriptor.value;\n        const { isWalletProvider } = validateActionMethodArguments(target, propertyKey);\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        descriptor.value = function (...args) {\n            let walletMetrics = {};\n            if (isWalletProvider) {\n                walletMetrics = {\n                    wallet_provider: args[0].getName(),\n                    wallet_address: args[0].getAddress(),\n                    network_id: args[0].getNetwork().networkId,\n                    chain_id: args[0].getNetwork().chainId,\n                    protocol_family: args[0].getNetwork().protocolFamily,\n                };\n            }\n            (0, analytics_1.sendAnalyticsEvent)({\n                name: \"agent_action_invocation\",\n                action: \"invoke_action\",\n                component: \"agent_action\",\n                action_name: prefixedActionName,\n                class_name: target.constructor.name,\n                method_name: propertyKey,\n                ...walletMetrics,\n            });\n            return originalMethod.apply(this, args);\n        };\n        const existingMetadata = Reflect.getMetadata(exports.ACTION_DECORATOR_KEY, target.constructor) || new Map();\n        const metaData = {\n            name: prefixedActionName,\n            description: params.description,\n            schema: params.schema,\n            invoke: descriptor.value,\n            walletProvider: isWalletProvider,\n        };\n        existingMetadata.set(propertyKey, metaData);\n        Reflect.defineMetadata(exports.ACTION_DECORATOR_KEY, existingMetadata, target.constructor);\n        return target;\n    };\n}\n/**\n * Validates the arguments of an action method\n *\n * @param target - The target object\n * @param propertyKey - The property key\n * @returns An object containing the wallet provider flag\n */\nfunction validateActionMethodArguments(target, propertyKey) {\n    const className = target instanceof Object ? target.constructor.name : undefined;\n    const params = Reflect.getMetadata(\"design:paramtypes\", target, propertyKey);\n    if (params == null) {\n        throw new Error(`Failed to get parameters for action method ${propertyKey} on class ${className}`);\n    }\n    if (params.length > 2) {\n        throw new Error(`Action method ${propertyKey} on class ${className} has more than 2 parameters`);\n    }\n    const walletProviderParam = params.find(param => {\n        if (!param || !param.prototype) {\n            return false;\n        }\n        if (param === wallet_providers_1.WalletProvider)\n            return true;\n        return param.prototype instanceof wallet_providers_1.WalletProvider;\n    });\n    return {\n        isWalletProvider: !!walletProviderParam,\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9hY3Rpb25EZWNvcmF0b3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNEJBQTRCO0FBQzVCLG9CQUFvQjtBQUNwQiwyQkFBMkIsbUJBQU8sQ0FBQyxtR0FBcUI7QUFDeEQsb0JBQW9CLG1CQUFPLENBQUMscUZBQWM7QUFDMUMsbUJBQU8sQ0FBQywwRUFBa0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixxRUFBcUU7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyx3QkFBd0IsR0FBRyxZQUFZO0FBQzdFO0FBQ0EsZ0JBQWdCLG1CQUFtQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsYUFBYSxXQUFXLFVBQVU7QUFDeEc7QUFDQTtBQUNBLHlDQUF5QyxhQUFhLFdBQVcsV0FBVztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3Vydml2YWwtZnVuLy4vbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9hZ2VudGtpdC9kaXN0L2FjdGlvbi1wcm92aWRlcnMvYWN0aW9uRGVjb3JhdG9yLmpzPzUyY2UiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFDVElPTl9ERUNPUkFUT1JfS0VZID0gdm9pZCAwO1xuZXhwb3J0cy5DcmVhdGVBY3Rpb24gPSBDcmVhdGVBY3Rpb247XG5jb25zdCB3YWxsZXRfcHJvdmlkZXJzXzEgPSByZXF1aXJlKFwiLi4vd2FsbGV0LXByb3ZpZGVyc1wiKTtcbmNvbnN0IGFuYWx5dGljc18xID0gcmVxdWlyZShcIi4uL2FuYWx5dGljc1wiKTtcbnJlcXVpcmUoXCJyZWZsZWN0LW1ldGFkYXRhXCIpO1xuLyoqXG4gKiBNZXRhZGF0YSBrZXkgZm9yIHRoZSBhY3Rpb24gZGVjb3JhdG9yXG4gKi9cbmV4cG9ydHMuQUNUSU9OX0RFQ09SQVRPUl9LRVkgPSBTeW1ib2woXCJhZ2VudGtpdDphY3Rpb25cIik7XG4vKipcbiAqIERlY29yYXRvciB0byBlbWJlZCBtZXRhZGF0YSBvbiBjbGFzcyBtZXRob2RzIHRvIGluZGljYXRlIHRoZXkgYXJlIGFjdGlvbnMgYWNjZXNzaWJsZSB0byB0aGUgYWdlbnRcbiAqXG4gKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoZSBhY3Rpb24gZGVjb3JhdG9yXG4gKiBAcmV0dXJucyBBIGRlY29yYXRvciBmdW5jdGlvblxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBjbGFzcyBNeUFjdGlvblByb3ZpZGVyIGV4dGVuZHMgQWN0aW9uUHJvdmlkZXIge1xuICogICBAQ3JlYXRlQWN0aW9uKHsgbmFtZTogXCJteV9hY3Rpb25cIiwgZGVzY3JpcHRpb246IFwiTXkgYWN0aW9uXCIsIHNjaGVtYTogbXlBY3Rpb25TY2hlbWEgfSlcbiAqICAgcHVibGljIG15QWN0aW9uKGFyZ3M6IHouaW5mZXI8dHlwZW9mIG15QWN0aW9uU2NoZW1hPikge1xuICogICAgIC8vIC4uLlxuICogICB9XG4gKiB9XG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gQ3JlYXRlQWN0aW9uKHBhcmFtcykge1xuICAgIHJldHVybiAodGFyZ2V0LCBwcm9wZXJ0eUtleSwgZGVzY3JpcHRvcikgPT4ge1xuICAgICAgICBjb25zdCBwcmVmaXhlZEFjdGlvbk5hbWUgPSBgJHt0YXJnZXQuY29uc3RydWN0b3IubmFtZX1fJHtwYXJhbXMubmFtZX1gO1xuICAgICAgICBjb25zdCBvcmlnaW5hbE1ldGhvZCA9IGRlc2NyaXB0b3IudmFsdWU7XG4gICAgICAgIGNvbnN0IHsgaXNXYWxsZXRQcm92aWRlciB9ID0gdmFsaWRhdGVBY3Rpb25NZXRob2RBcmd1bWVudHModGFyZ2V0LCBwcm9wZXJ0eUtleSk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIGRlc2NyaXB0b3IudmFsdWUgPSBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICAgICAgbGV0IHdhbGxldE1ldHJpY3MgPSB7fTtcbiAgICAgICAgICAgIGlmIChpc1dhbGxldFByb3ZpZGVyKSB7XG4gICAgICAgICAgICAgICAgd2FsbGV0TWV0cmljcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgd2FsbGV0X3Byb3ZpZGVyOiBhcmdzWzBdLmdldE5hbWUoKSxcbiAgICAgICAgICAgICAgICAgICAgd2FsbGV0X2FkZHJlc3M6IGFyZ3NbMF0uZ2V0QWRkcmVzcygpLFxuICAgICAgICAgICAgICAgICAgICBuZXR3b3JrX2lkOiBhcmdzWzBdLmdldE5ldHdvcmsoKS5uZXR3b3JrSWQsXG4gICAgICAgICAgICAgICAgICAgIGNoYWluX2lkOiBhcmdzWzBdLmdldE5ldHdvcmsoKS5jaGFpbklkLFxuICAgICAgICAgICAgICAgICAgICBwcm90b2NvbF9mYW1pbHk6IGFyZ3NbMF0uZ2V0TmV0d29yaygpLnByb3RvY29sRmFtaWx5LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoMCwgYW5hbHl0aWNzXzEuc2VuZEFuYWx5dGljc0V2ZW50KSh7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJhZ2VudF9hY3Rpb25faW52b2NhdGlvblwiLFxuICAgICAgICAgICAgICAgIGFjdGlvbjogXCJpbnZva2VfYWN0aW9uXCIsXG4gICAgICAgICAgICAgICAgY29tcG9uZW50OiBcImFnZW50X2FjdGlvblwiLFxuICAgICAgICAgICAgICAgIGFjdGlvbl9uYW1lOiBwcmVmaXhlZEFjdGlvbk5hbWUsXG4gICAgICAgICAgICAgICAgY2xhc3NfbmFtZTogdGFyZ2V0LmNvbnN0cnVjdG9yLm5hbWUsXG4gICAgICAgICAgICAgICAgbWV0aG9kX25hbWU6IHByb3BlcnR5S2V5LFxuICAgICAgICAgICAgICAgIC4uLndhbGxldE1ldHJpY3MsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbE1ldGhvZC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdNZXRhZGF0YSA9IFJlZmxlY3QuZ2V0TWV0YWRhdGEoZXhwb3J0cy5BQ1RJT05fREVDT1JBVE9SX0tFWSwgdGFyZ2V0LmNvbnN0cnVjdG9yKSB8fCBuZXcgTWFwKCk7XG4gICAgICAgIGNvbnN0IG1ldGFEYXRhID0ge1xuICAgICAgICAgICAgbmFtZTogcHJlZml4ZWRBY3Rpb25OYW1lLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IHBhcmFtcy5kZXNjcmlwdGlvbixcbiAgICAgICAgICAgIHNjaGVtYTogcGFyYW1zLnNjaGVtYSxcbiAgICAgICAgICAgIGludm9rZTogZGVzY3JpcHRvci52YWx1ZSxcbiAgICAgICAgICAgIHdhbGxldFByb3ZpZGVyOiBpc1dhbGxldFByb3ZpZGVyLFxuICAgICAgICB9O1xuICAgICAgICBleGlzdGluZ01ldGFkYXRhLnNldChwcm9wZXJ0eUtleSwgbWV0YURhdGEpO1xuICAgICAgICBSZWZsZWN0LmRlZmluZU1ldGFkYXRhKGV4cG9ydHMuQUNUSU9OX0RFQ09SQVRPUl9LRVksIGV4aXN0aW5nTWV0YWRhdGEsIHRhcmdldC5jb25zdHJ1Y3Rvcik7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfTtcbn1cbi8qKlxuICogVmFsaWRhdGVzIHRoZSBhcmd1bWVudHMgb2YgYW4gYWN0aW9uIG1ldGhvZFxuICpcbiAqIEBwYXJhbSB0YXJnZXQgLSBUaGUgdGFyZ2V0IG9iamVjdFxuICogQHBhcmFtIHByb3BlcnR5S2V5IC0gVGhlIHByb3BlcnR5IGtleVxuICogQHJldHVybnMgQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHdhbGxldCBwcm92aWRlciBmbGFnXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlQWN0aW9uTWV0aG9kQXJndW1lbnRzKHRhcmdldCwgcHJvcGVydHlLZXkpIHtcbiAgICBjb25zdCBjbGFzc05hbWUgPSB0YXJnZXQgaW5zdGFuY2VvZiBPYmplY3QgPyB0YXJnZXQuY29uc3RydWN0b3IubmFtZSA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBwYXJhbXMgPSBSZWZsZWN0LmdldE1ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgdGFyZ2V0LCBwcm9wZXJ0eUtleSk7XG4gICAgaWYgKHBhcmFtcyA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGdldCBwYXJhbWV0ZXJzIGZvciBhY3Rpb24gbWV0aG9kICR7cHJvcGVydHlLZXl9IG9uIGNsYXNzICR7Y2xhc3NOYW1lfWApO1xuICAgIH1cbiAgICBpZiAocGFyYW1zLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBY3Rpb24gbWV0aG9kICR7cHJvcGVydHlLZXl9IG9uIGNsYXNzICR7Y2xhc3NOYW1lfSBoYXMgbW9yZSB0aGFuIDIgcGFyYW1ldGVyc2ApO1xuICAgIH1cbiAgICBjb25zdCB3YWxsZXRQcm92aWRlclBhcmFtID0gcGFyYW1zLmZpbmQocGFyYW0gPT4ge1xuICAgICAgICBpZiAoIXBhcmFtIHx8ICFwYXJhbS5wcm90b3R5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyYW0gPT09IHdhbGxldF9wcm92aWRlcnNfMS5XYWxsZXRQcm92aWRlcilcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gcGFyYW0ucHJvdG90eXBlIGluc3RhbmNlb2Ygd2FsbGV0X3Byb3ZpZGVyc18xLldhbGxldFByb3ZpZGVyO1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGlzV2FsbGV0UHJvdmlkZXI6ICEhd2FsbGV0UHJvdmlkZXJQYXJhbSxcbiAgICB9O1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/actionDecorator.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/actionProvider.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/actionProvider.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ActionProvider = void 0;\nconst actionDecorator_1 = __webpack_require__(/*! ./actionDecorator */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/actionDecorator.js\");\n/**\n * ActionProvider is the abstract base class for all action providers.\n *\n * @abstract\n */\nclass ActionProvider {\n    /**\n     * The constructor for the action provider.\n     *\n     * @param name - The name of the action provider.\n     * @param actionProviders - The action providers to combine.\n     */\n    constructor(name, \n    // Update parameter type to match property type\n    actionProviders) {\n        this.name = name;\n        this.actionProviders = actionProviders;\n    }\n    /**\n     * Gets the actions of the action provider bound to the given wallet provider.\n     *\n     * @param walletProvider - The wallet provider.\n     * @returns The actions of the action provider.\n     */\n    getActions(walletProvider) {\n        const actions = [];\n        const actionProviders = [this, ...this.actionProviders];\n        for (const actionProvider of actionProviders) {\n            const actionsMetadataMap = Reflect.getMetadata(actionDecorator_1.ACTION_DECORATOR_KEY, actionProvider.constructor);\n            if (!actionsMetadataMap) {\n                if (!(actionProvider instanceof ActionProvider)) {\n                    console.warn(`Warning: ${actionProvider} is not an instance of ActionProvider.`);\n                }\n                else {\n                    console.warn(`Warning: ${actionProvider} has no actions.`);\n                }\n                continue;\n            }\n            for (const actionMetadata of actionsMetadataMap.values()) {\n                actions.push({\n                    name: actionMetadata.name,\n                    description: actionMetadata.description,\n                    schema: actionMetadata.schema,\n                    invoke: schemaArgs => {\n                        const args = [];\n                        if (actionMetadata.walletProvider) {\n                            args[0] = walletProvider;\n                        }\n                        args.push(schemaArgs);\n                        return actionMetadata.invoke.apply(actionProvider, args);\n                    },\n                });\n            }\n        }\n        return actions;\n    }\n}\nexports.ActionProvider = ActionProvider;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9hY3Rpb25Qcm92aWRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQkFBc0I7QUFDdEIsMEJBQTBCLG1CQUFPLENBQUMsMkdBQW1CO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGdCQUFnQjtBQUM3RDtBQUNBO0FBQ0EsNkNBQTZDLGdCQUFnQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXJ2aXZhbC1mdW4vLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9hY3Rpb25Qcm92aWRlci5qcz8zNzFmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BY3Rpb25Qcm92aWRlciA9IHZvaWQgMDtcbmNvbnN0IGFjdGlvbkRlY29yYXRvcl8xID0gcmVxdWlyZShcIi4vYWN0aW9uRGVjb3JhdG9yXCIpO1xuLyoqXG4gKiBBY3Rpb25Qcm92aWRlciBpcyB0aGUgYWJzdHJhY3QgYmFzZSBjbGFzcyBmb3IgYWxsIGFjdGlvbiBwcm92aWRlcnMuXG4gKlxuICogQGFic3RyYWN0XG4gKi9cbmNsYXNzIEFjdGlvblByb3ZpZGVyIHtcbiAgICAvKipcbiAgICAgKiBUaGUgY29uc3RydWN0b3IgZm9yIHRoZSBhY3Rpb24gcHJvdmlkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBhY3Rpb24gcHJvdmlkZXIuXG4gICAgICogQHBhcmFtIGFjdGlvblByb3ZpZGVycyAtIFRoZSBhY3Rpb24gcHJvdmlkZXJzIHRvIGNvbWJpbmUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobmFtZSwgXG4gICAgLy8gVXBkYXRlIHBhcmFtZXRlciB0eXBlIHRvIG1hdGNoIHByb3BlcnR5IHR5cGVcbiAgICBhY3Rpb25Qcm92aWRlcnMpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5hY3Rpb25Qcm92aWRlcnMgPSBhY3Rpb25Qcm92aWRlcnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGFjdGlvbnMgb2YgdGhlIGFjdGlvbiBwcm92aWRlciBib3VuZCB0byB0aGUgZ2l2ZW4gd2FsbGV0IHByb3ZpZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHdhbGxldFByb3ZpZGVyIC0gVGhlIHdhbGxldCBwcm92aWRlci5cbiAgICAgKiBAcmV0dXJucyBUaGUgYWN0aW9ucyBvZiB0aGUgYWN0aW9uIHByb3ZpZGVyLlxuICAgICAqL1xuICAgIGdldEFjdGlvbnMod2FsbGV0UHJvdmlkZXIpIHtcbiAgICAgICAgY29uc3QgYWN0aW9ucyA9IFtdO1xuICAgICAgICBjb25zdCBhY3Rpb25Qcm92aWRlcnMgPSBbdGhpcywgLi4udGhpcy5hY3Rpb25Qcm92aWRlcnNdO1xuICAgICAgICBmb3IgKGNvbnN0IGFjdGlvblByb3ZpZGVyIG9mIGFjdGlvblByb3ZpZGVycykge1xuICAgICAgICAgICAgY29uc3QgYWN0aW9uc01ldGFkYXRhTWFwID0gUmVmbGVjdC5nZXRNZXRhZGF0YShhY3Rpb25EZWNvcmF0b3JfMS5BQ1RJT05fREVDT1JBVE9SX0tFWSwgYWN0aW9uUHJvdmlkZXIuY29uc3RydWN0b3IpO1xuICAgICAgICAgICAgaWYgKCFhY3Rpb25zTWV0YWRhdGFNYXApIHtcbiAgICAgICAgICAgICAgICBpZiAoIShhY3Rpb25Qcm92aWRlciBpbnN0YW5jZW9mIEFjdGlvblByb3ZpZGVyKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFdhcm5pbmc6ICR7YWN0aW9uUHJvdmlkZXJ9IGlzIG5vdCBhbiBpbnN0YW5jZSBvZiBBY3Rpb25Qcm92aWRlci5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgV2FybmluZzogJHthY3Rpb25Qcm92aWRlcn0gaGFzIG5vIGFjdGlvbnMuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBhY3Rpb25NZXRhZGF0YSBvZiBhY3Rpb25zTWV0YWRhdGFNYXAudmFsdWVzKCkpIHtcbiAgICAgICAgICAgICAgICBhY3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBhY3Rpb25NZXRhZGF0YS5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogYWN0aW9uTWV0YWRhdGEuZGVzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgICAgIHNjaGVtYTogYWN0aW9uTWV0YWRhdGEuc2NoZW1hLFxuICAgICAgICAgICAgICAgICAgICBpbnZva2U6IHNjaGVtYUFyZ3MgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYXJncyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGlvbk1ldGFkYXRhLndhbGxldFByb3ZpZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnc1swXSA9IHdhbGxldFByb3ZpZGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoKHNjaGVtYUFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFjdGlvbk1ldGFkYXRhLmludm9rZS5hcHBseShhY3Rpb25Qcm92aWRlciwgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjdGlvbnM7XG4gICAgfVxufVxuZXhwb3J0cy5BY3Rpb25Qcm92aWRlciA9IEFjdGlvblByb3ZpZGVyO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/actionProvider.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/alchemy/alchemyTokenPricesActionProvider.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/alchemy/alchemyTokenPricesActionProvider.js ***!
  \***********************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.alchemyTokenPricesActionProvider = exports.AlchemyTokenPricesActionProvider = void 0;\nconst zod_1 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/lib/index.js\");\nconst actionProvider_1 = __webpack_require__(/*! ../actionProvider */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/actionProvider.js\");\nconst actionDecorator_1 = __webpack_require__(/*! ../actionDecorator */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/actionDecorator.js\");\nconst schemas_1 = __webpack_require__(/*! ./schemas */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/alchemy/schemas.js\");\n/**\n * AlchemyTokenPricesActionProvider is an action provider for fetching token prices via the Alchemy Prices API.\n * This provider enables querying current and historical token prices using symbols or addresses.\n *\n */\nclass AlchemyTokenPricesActionProvider extends actionProvider_1.ActionProvider {\n    /**\n     * Creates a new instance of AlchemyTokenPricesActionProvider\n     *\n     * @param config - Configuration options including the API key\n     */\n    constructor(config = {}) {\n        super(\"alchemyTokenPrices\", []);\n        /**\n         * Checks if the Alchemy Prices action provider supports the given network.\n         * Since the API works with multiple networks, this always returns true.\n         *\n         * @returns Always returns true.\n         */\n        this.supportsNetwork = () => {\n            return true;\n        };\n        config.apiKey || (config.apiKey = process.env.ALCHEMY_API_KEY);\n        if (!config.apiKey) {\n            throw new Error(\"ALCHEMY_API_KEY is not configured.\");\n        }\n        this.apiKey = config.apiKey;\n        this.baseUrl = \"https://api.g.alchemy.com/prices/v1\";\n    }\n    /**\n     * Fetch current token prices for one or more token symbols.\n     *\n     * @param args - The arguments containing an array of token symbols.\n     * @returns A JSON string with the token prices or an error message.\n     */\n    async tokenPricesBySymbol(args) {\n        try {\n            // Build query parameters: for each symbol add a separate query parameter\n            const params = new URLSearchParams();\n            for (const symbol of args.symbols) {\n                params.append(\"symbols\", symbol);\n            }\n            const url = `${this.baseUrl}/${this.apiKey}/tokens/by-symbol?${params.toString()}`;\n            const response = await fetch(url, {\n                method: \"GET\",\n                headers: {\n                    Accept: \"application/json\",\n                },\n            });\n            if (!response.ok) {\n                throw new Error(`HTTP error! status: ${response.status}`);\n            }\n            const data = await response.json();\n            return `Successfully fetched token prices by symbol:\\n${JSON.stringify(data, null, 2)}`;\n        }\n        catch (error) {\n            return `Error fetching token prices by symbol: ${error}`;\n        }\n    }\n    /**\n     * Fetch current token prices for one or more tokens identified by network and address pairs.\n     *\n     * @param args - The arguments containing an array of token network/address pairs.\n     * @returns A JSON string with the token prices or an error message.\n     */\n    async tokenPricesByAddress(args) {\n        try {\n            const url = `${this.baseUrl}/${this.apiKey}/tokens/by-address`;\n            const response = await fetch(url, {\n                method: \"POST\",\n                headers: {\n                    Accept: \"application/json\",\n                    \"Content-Type\": \"application/json\",\n                },\n                body: JSON.stringify(args),\n            });\n            if (!response.ok) {\n                throw new Error(`HTTP error! status: ${response.status}`);\n            }\n            const data = await response.json();\n            return `Successfully fetched token prices by address:\\n${JSON.stringify(data, null, 2)}`;\n        }\n        catch (error) {\n            return `Error fetching token prices by address: ${error}`;\n        }\n    }\n}\nexports.AlchemyTokenPricesActionProvider = AlchemyTokenPricesActionProvider;\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"token_prices_by_symbol\",\n        description: `\nThis tool will fetch current prices for one or more tokens using their symbols via the Alchemy Prices API.\n\nA successful response will return a JSON payload similar to:\n{\n  \"data\": [\n    {\n      \"symbol\": \"ETH\",\n      \"prices\": [\n        {\n          \"currency\": \"usd\",\n          \"value\": \"2873.490923459\",\n          \"lastUpdatedAt\": \"2025-02-03T23:46:40Z\"\n        }\n      ]\n    }\n  ]\n}\n\nA failure response will return an error message with details.\n    `,\n        schema: schemas_1.AlchemyTokenPricesBySymbolSchema,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [void 0]),\n    __metadata(\"design:returntype\", Promise)\n], AlchemyTokenPricesActionProvider.prototype, \"tokenPricesBySymbol\", null);\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"token_prices_by_address\",\n        description: `\nThis tool will fetch current prices for tokens using network and address pairs via the Alchemy Prices API.\n\nA successful response will return a JSON payload similar to:\n{\n  \"data\": [\n    {\n      \"network\": \"eth-mainnet\",\n      \"address\": \"0xYourTokenAddress\",\n      \"prices\": [\n        {\n          \"currency\": \"usd\",\n          \"value\": \"1234.56\",\n          \"lastUpdatedAt\": \"2025-02-03T23:46:40Z\"\n        }\n      ]\n    }\n  ]\n}\n\nA failure response will return an error message with details.\n    `,\n        schema: schemas_1.AlchemyTokenPricesByAddressSchema,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [void 0]),\n    __metadata(\"design:returntype\", Promise)\n], AlchemyTokenPricesActionProvider.prototype, \"tokenPricesByAddress\", null);\n/**\n * Factory function to create a new AlchemyTokenPricesActionProvider instance.\n *\n * @param config - The configuration options for the provider.\n * @returns A new instance of AlchemyTokenPricesActionProvider.\n */\nconst alchemyTokenPricesActionProvider = (config) => new AlchemyTokenPricesActionProvider(config);\nexports.alchemyTokenPricesActionProvider = alchemyTokenPricesActionProvider;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9hbGNoZW15L2FsY2hlbXlUb2tlblByaWNlc0FjdGlvblByb3ZpZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFFBQVE7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx3Q0FBd0MsR0FBRyx3Q0FBd0M7QUFDbkYsY0FBYyxtQkFBTyxDQUFDLGtEQUFLO0FBQzNCLHlCQUF5QixtQkFBTyxDQUFDLDBHQUFtQjtBQUNwRCwwQkFBMEIsbUJBQU8sQ0FBQyw0R0FBb0I7QUFDdEQsa0JBQWtCLG1CQUFPLENBQUMsbUdBQVc7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsYUFBYSxHQUFHLFlBQVksb0JBQW9CLGtCQUFrQjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQSx1REFBdUQsZ0JBQWdCO0FBQ3ZFO0FBQ0E7QUFDQSxvRUFBb0UsOEJBQThCO0FBQ2xHO0FBQ0E7QUFDQSw2REFBNkQsTUFBTTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhLEdBQUcsWUFBWTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsdURBQXVELGdCQUFnQjtBQUN2RTtBQUNBO0FBQ0EscUVBQXFFLDhCQUE4QjtBQUNuRztBQUNBO0FBQ0EsOERBQThELE1BQU07QUFDcEU7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXJ2aXZhbC1mdW4vLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9hbGNoZW15L2FsY2hlbXlUb2tlblByaWNlc0FjdGlvblByb3ZpZGVyLmpzP2VkMWIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hbGNoZW15VG9rZW5QcmljZXNBY3Rpb25Qcm92aWRlciA9IGV4cG9ydHMuQWxjaGVteVRva2VuUHJpY2VzQWN0aW9uUHJvdmlkZXIgPSB2b2lkIDA7XG5jb25zdCB6b2RfMSA9IHJlcXVpcmUoXCJ6b2RcIik7XG5jb25zdCBhY3Rpb25Qcm92aWRlcl8xID0gcmVxdWlyZShcIi4uL2FjdGlvblByb3ZpZGVyXCIpO1xuY29uc3QgYWN0aW9uRGVjb3JhdG9yXzEgPSByZXF1aXJlKFwiLi4vYWN0aW9uRGVjb3JhdG9yXCIpO1xuY29uc3Qgc2NoZW1hc18xID0gcmVxdWlyZShcIi4vc2NoZW1hc1wiKTtcbi8qKlxuICogQWxjaGVteVRva2VuUHJpY2VzQWN0aW9uUHJvdmlkZXIgaXMgYW4gYWN0aW9uIHByb3ZpZGVyIGZvciBmZXRjaGluZyB0b2tlbiBwcmljZXMgdmlhIHRoZSBBbGNoZW15IFByaWNlcyBBUEkuXG4gKiBUaGlzIHByb3ZpZGVyIGVuYWJsZXMgcXVlcnlpbmcgY3VycmVudCBhbmQgaGlzdG9yaWNhbCB0b2tlbiBwcmljZXMgdXNpbmcgc3ltYm9scyBvciBhZGRyZXNzZXMuXG4gKlxuICovXG5jbGFzcyBBbGNoZW15VG9rZW5QcmljZXNBY3Rpb25Qcm92aWRlciBleHRlbmRzIGFjdGlvblByb3ZpZGVyXzEuQWN0aW9uUHJvdmlkZXIge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgQWxjaGVteVRva2VuUHJpY2VzQWN0aW9uUHJvdmlkZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb25maWcgLSBDb25maWd1cmF0aW9uIG9wdGlvbnMgaW5jbHVkaW5nIHRoZSBBUEkga2V5XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnID0ge30pIHtcbiAgICAgICAgc3VwZXIoXCJhbGNoZW15VG9rZW5QcmljZXNcIiwgW10pO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2tzIGlmIHRoZSBBbGNoZW15IFByaWNlcyBhY3Rpb24gcHJvdmlkZXIgc3VwcG9ydHMgdGhlIGdpdmVuIG5ldHdvcmsuXG4gICAgICAgICAqIFNpbmNlIHRoZSBBUEkgd29ya3Mgd2l0aCBtdWx0aXBsZSBuZXR3b3JrcywgdGhpcyBhbHdheXMgcmV0dXJucyB0cnVlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyBBbHdheXMgcmV0dXJucyB0cnVlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdXBwb3J0c05ldHdvcmsgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uZmlnLmFwaUtleSB8fCAoY29uZmlnLmFwaUtleSA9IHByb2Nlc3MuZW52LkFMQ0hFTVlfQVBJX0tFWSk7XG4gICAgICAgIGlmICghY29uZmlnLmFwaUtleSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQUxDSEVNWV9BUElfS0VZIGlzIG5vdCBjb25maWd1cmVkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFwaUtleSA9IGNvbmZpZy5hcGlLZXk7XG4gICAgICAgIHRoaXMuYmFzZVVybCA9IFwiaHR0cHM6Ly9hcGkuZy5hbGNoZW15LmNvbS9wcmljZXMvdjFcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2ggY3VycmVudCB0b2tlbiBwcmljZXMgZm9yIG9uZSBvciBtb3JlIHRva2VuIHN5bWJvbHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXJncyAtIFRoZSBhcmd1bWVudHMgY29udGFpbmluZyBhbiBhcnJheSBvZiB0b2tlbiBzeW1ib2xzLlxuICAgICAqIEByZXR1cm5zIEEgSlNPTiBzdHJpbmcgd2l0aCB0aGUgdG9rZW4gcHJpY2VzIG9yIGFuIGVycm9yIG1lc3NhZ2UuXG4gICAgICovXG4gICAgYXN5bmMgdG9rZW5QcmljZXNCeVN5bWJvbChhcmdzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBCdWlsZCBxdWVyeSBwYXJhbWV0ZXJzOiBmb3IgZWFjaCBzeW1ib2wgYWRkIGEgc2VwYXJhdGUgcXVlcnkgcGFyYW1ldGVyXG4gICAgICAgICAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHN5bWJvbCBvZiBhcmdzLnN5bWJvbHMpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwic3ltYm9sc1wiLCBzeW1ib2wpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdXJsID0gYCR7dGhpcy5iYXNlVXJsfS8ke3RoaXMuYXBpS2V5fS90b2tlbnMvYnktc3ltYm9sPyR7cGFyYW1zLnRvU3RyaW5nKCl9YDtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgQWNjZXB0OiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBIVFRQIGVycm9yISBzdGF0dXM6ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIHJldHVybiBgU3VjY2Vzc2Z1bGx5IGZldGNoZWQgdG9rZW4gcHJpY2VzIGJ5IHN5bWJvbDpcXG4ke0pTT04uc3RyaW5naWZ5KGRhdGEsIG51bGwsIDIpfWA7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gYEVycm9yIGZldGNoaW5nIHRva2VuIHByaWNlcyBieSBzeW1ib2w6ICR7ZXJyb3J9YDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBGZXRjaCBjdXJyZW50IHRva2VuIHByaWNlcyBmb3Igb25lIG9yIG1vcmUgdG9rZW5zIGlkZW50aWZpZWQgYnkgbmV0d29yayBhbmQgYWRkcmVzcyBwYWlycy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhcmdzIC0gVGhlIGFyZ3VtZW50cyBjb250YWluaW5nIGFuIGFycmF5IG9mIHRva2VuIG5ldHdvcmsvYWRkcmVzcyBwYWlycy5cbiAgICAgKiBAcmV0dXJucyBBIEpTT04gc3RyaW5nIHdpdGggdGhlIHRva2VuIHByaWNlcyBvciBhbiBlcnJvciBtZXNzYWdlLlxuICAgICAqL1xuICAgIGFzeW5jIHRva2VuUHJpY2VzQnlBZGRyZXNzKGFyZ3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IGAke3RoaXMuYmFzZVVybH0vJHt0aGlzLmFwaUtleX0vdG9rZW5zL2J5LWFkZHJlc3NgO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgQWNjZXB0OiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShhcmdzKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCBlcnJvciEgc3RhdHVzOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICByZXR1cm4gYFN1Y2Nlc3NmdWxseSBmZXRjaGVkIHRva2VuIHByaWNlcyBieSBhZGRyZXNzOlxcbiR7SlNPTi5zdHJpbmdpZnkoZGF0YSwgbnVsbCwgMil9YDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBgRXJyb3IgZmV0Y2hpbmcgdG9rZW4gcHJpY2VzIGJ5IGFkZHJlc3M6ICR7ZXJyb3J9YDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQWxjaGVteVRva2VuUHJpY2VzQWN0aW9uUHJvdmlkZXIgPSBBbGNoZW15VG9rZW5QcmljZXNBY3Rpb25Qcm92aWRlcjtcbl9fZGVjb3JhdGUoW1xuICAgICgwLCBhY3Rpb25EZWNvcmF0b3JfMS5DcmVhdGVBY3Rpb24pKHtcbiAgICAgICAgbmFtZTogXCJ0b2tlbl9wcmljZXNfYnlfc3ltYm9sXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgXG5UaGlzIHRvb2wgd2lsbCBmZXRjaCBjdXJyZW50IHByaWNlcyBmb3Igb25lIG9yIG1vcmUgdG9rZW5zIHVzaW5nIHRoZWlyIHN5bWJvbHMgdmlhIHRoZSBBbGNoZW15IFByaWNlcyBBUEkuXG5cbkEgc3VjY2Vzc2Z1bCByZXNwb25zZSB3aWxsIHJldHVybiBhIEpTT04gcGF5bG9hZCBzaW1pbGFyIHRvOlxue1xuICBcImRhdGFcIjogW1xuICAgIHtcbiAgICAgIFwic3ltYm9sXCI6IFwiRVRIXCIsXG4gICAgICBcInByaWNlc1wiOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBcImN1cnJlbmN5XCI6IFwidXNkXCIsXG4gICAgICAgICAgXCJ2YWx1ZVwiOiBcIjI4NzMuNDkwOTIzNDU5XCIsXG4gICAgICAgICAgXCJsYXN0VXBkYXRlZEF0XCI6IFwiMjAyNS0wMi0wM1QyMzo0Njo0MFpcIlxuICAgICAgICB9XG4gICAgICBdXG4gICAgfVxuICBdXG59XG5cbkEgZmFpbHVyZSByZXNwb25zZSB3aWxsIHJldHVybiBhbiBlcnJvciBtZXNzYWdlIHdpdGggZGV0YWlscy5cbiAgICBgLFxuICAgICAgICBzY2hlbWE6IHNjaGVtYXNfMS5BbGNoZW15VG9rZW5QcmljZXNCeVN5bWJvbFNjaGVtYSxcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbdm9pZCAwXSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIFByb21pc2UpXG5dLCBBbGNoZW15VG9rZW5QcmljZXNBY3Rpb25Qcm92aWRlci5wcm90b3R5cGUsIFwidG9rZW5QcmljZXNCeVN5bWJvbFwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgICgwLCBhY3Rpb25EZWNvcmF0b3JfMS5DcmVhdGVBY3Rpb24pKHtcbiAgICAgICAgbmFtZTogXCJ0b2tlbl9wcmljZXNfYnlfYWRkcmVzc1wiLFxuICAgICAgICBkZXNjcmlwdGlvbjogYFxuVGhpcyB0b29sIHdpbGwgZmV0Y2ggY3VycmVudCBwcmljZXMgZm9yIHRva2VucyB1c2luZyBuZXR3b3JrIGFuZCBhZGRyZXNzIHBhaXJzIHZpYSB0aGUgQWxjaGVteSBQcmljZXMgQVBJLlxuXG5BIHN1Y2Nlc3NmdWwgcmVzcG9uc2Ugd2lsbCByZXR1cm4gYSBKU09OIHBheWxvYWQgc2ltaWxhciB0bzpcbntcbiAgXCJkYXRhXCI6IFtcbiAgICB7XG4gICAgICBcIm5ldHdvcmtcIjogXCJldGgtbWFpbm5ldFwiLFxuICAgICAgXCJhZGRyZXNzXCI6IFwiMHhZb3VyVG9rZW5BZGRyZXNzXCIsXG4gICAgICBcInByaWNlc1wiOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBcImN1cnJlbmN5XCI6IFwidXNkXCIsXG4gICAgICAgICAgXCJ2YWx1ZVwiOiBcIjEyMzQuNTZcIixcbiAgICAgICAgICBcImxhc3RVcGRhdGVkQXRcIjogXCIyMDI1LTAyLTAzVDIzOjQ2OjQwWlwiXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9XG4gIF1cbn1cblxuQSBmYWlsdXJlIHJlc3BvbnNlIHdpbGwgcmV0dXJuIGFuIGVycm9yIG1lc3NhZ2Ugd2l0aCBkZXRhaWxzLlxuICAgIGAsXG4gICAgICAgIHNjaGVtYTogc2NoZW1hc18xLkFsY2hlbXlUb2tlblByaWNlc0J5QWRkcmVzc1NjaGVtYSxcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbdm9pZCAwXSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIFByb21pc2UpXG5dLCBBbGNoZW15VG9rZW5QcmljZXNBY3Rpb25Qcm92aWRlci5wcm90b3R5cGUsIFwidG9rZW5QcmljZXNCeUFkZHJlc3NcIiwgbnVsbCk7XG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb24gdG8gY3JlYXRlIGEgbmV3IEFsY2hlbXlUb2tlblByaWNlc0FjdGlvblByb3ZpZGVyIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSBjb25maWcgLSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgcHJvdmlkZXIuXG4gKiBAcmV0dXJucyBBIG5ldyBpbnN0YW5jZSBvZiBBbGNoZW15VG9rZW5QcmljZXNBY3Rpb25Qcm92aWRlci5cbiAqL1xuY29uc3QgYWxjaGVteVRva2VuUHJpY2VzQWN0aW9uUHJvdmlkZXIgPSAoY29uZmlnKSA9PiBuZXcgQWxjaGVteVRva2VuUHJpY2VzQWN0aW9uUHJvdmlkZXIoY29uZmlnKTtcbmV4cG9ydHMuYWxjaGVteVRva2VuUHJpY2VzQWN0aW9uUHJvdmlkZXIgPSBhbGNoZW15VG9rZW5QcmljZXNBY3Rpb25Qcm92aWRlcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/alchemy/alchemyTokenPricesActionProvider.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/alchemy/index.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/alchemy/index.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./alchemyTokenPricesActionProvider */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/alchemy/alchemyTokenPricesActionProvider.js\"), exports);\n__exportStar(__webpack_require__(/*! ./schemas */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/alchemy/schemas.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9hbGNoZW15L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWEsbUJBQU8sQ0FBQyxxSkFBb0M7QUFDekQsYUFBYSxtQkFBTyxDQUFDLG1HQUFXIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3Vydml2YWwtZnVuLy4vbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9hZ2VudGtpdC9kaXN0L2FjdGlvbi1wcm92aWRlcnMvYWxjaGVteS9pbmRleC5qcz8yODY0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYWxjaGVteVRva2VuUHJpY2VzQWN0aW9uUHJvdmlkZXJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3NjaGVtYXNcIiksIGV4cG9ydHMpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/alchemy/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/alchemy/schemas.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/alchemy/schemas.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AlchemyTokenPricesByAddressSchema = exports.AlchemyTokenPricesBySymbolSchema = void 0;\nconst zod_1 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/lib/index.js\");\n/**\n * Input schema for fetching token prices by symbol.\n *\n * The API expects a list of token symbols.\n */\nexports.AlchemyTokenPricesBySymbolSchema = zod_1.z\n    .object({\n    symbols: zod_1.z\n        .array(zod_1.z.string())\n        .min(1, \"At least one token symbol is required. Example: ETH, BTC, SOL, etc.\")\n        .max(25, \"A maximum of 25 token symbols can be provided.\"),\n})\n    .describe(\"Input schema for fetching token prices by symbol from Alchemy\");\n/**\n * Input schema for fetching token prices by address.\n *\n * The API expects an object with an array of addresses, where each address contains\n * a network identifier and a token contract address.\n */\nexports.AlchemyTokenPricesByAddressSchema = zod_1.z\n    .object({\n    addresses: zod_1.z\n        .array(zod_1.z.object({\n        network: zod_1.z.string().describe(\"Network identifier (e.g., eth-mainnet, base-mainnet etc.)\"),\n        address: zod_1.z.string().describe(\"Token contract address\"),\n    }))\n        .min(1, \"At least one address is required.\")\n        .max(25, \"A maximum of 25 addresses can be provided.\"),\n})\n    .describe(\"Input schema for fetching token prices by address from Alchemy\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9hbGNoZW15L3NjaGVtYXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QseUNBQXlDLEdBQUcsd0NBQXdDO0FBQ3BGLGNBQWMsbUJBQU8sQ0FBQyxrREFBSztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQztBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3Vydml2YWwtZnVuLy4vbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9hZ2VudGtpdC9kaXN0L2FjdGlvbi1wcm92aWRlcnMvYWxjaGVteS9zY2hlbWFzLmpzPzIzMTAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFsY2hlbXlUb2tlblByaWNlc0J5QWRkcmVzc1NjaGVtYSA9IGV4cG9ydHMuQWxjaGVteVRva2VuUHJpY2VzQnlTeW1ib2xTY2hlbWEgPSB2b2lkIDA7XG5jb25zdCB6b2RfMSA9IHJlcXVpcmUoXCJ6b2RcIik7XG4vKipcbiAqIElucHV0IHNjaGVtYSBmb3IgZmV0Y2hpbmcgdG9rZW4gcHJpY2VzIGJ5IHN5bWJvbC5cbiAqXG4gKiBUaGUgQVBJIGV4cGVjdHMgYSBsaXN0IG9mIHRva2VuIHN5bWJvbHMuXG4gKi9cbmV4cG9ydHMuQWxjaGVteVRva2VuUHJpY2VzQnlTeW1ib2xTY2hlbWEgPSB6b2RfMS56XG4gICAgLm9iamVjdCh7XG4gICAgc3ltYm9sczogem9kXzEuelxuICAgICAgICAuYXJyYXkoem9kXzEuei5zdHJpbmcoKSlcbiAgICAgICAgLm1pbigxLCBcIkF0IGxlYXN0IG9uZSB0b2tlbiBzeW1ib2wgaXMgcmVxdWlyZWQuIEV4YW1wbGU6IEVUSCwgQlRDLCBTT0wsIGV0Yy5cIilcbiAgICAgICAgLm1heCgyNSwgXCJBIG1heGltdW0gb2YgMjUgdG9rZW4gc3ltYm9scyBjYW4gYmUgcHJvdmlkZWQuXCIpLFxufSlcbiAgICAuZGVzY3JpYmUoXCJJbnB1dCBzY2hlbWEgZm9yIGZldGNoaW5nIHRva2VuIHByaWNlcyBieSBzeW1ib2wgZnJvbSBBbGNoZW15XCIpO1xuLyoqXG4gKiBJbnB1dCBzY2hlbWEgZm9yIGZldGNoaW5nIHRva2VuIHByaWNlcyBieSBhZGRyZXNzLlxuICpcbiAqIFRoZSBBUEkgZXhwZWN0cyBhbiBvYmplY3Qgd2l0aCBhbiBhcnJheSBvZiBhZGRyZXNzZXMsIHdoZXJlIGVhY2ggYWRkcmVzcyBjb250YWluc1xuICogYSBuZXR3b3JrIGlkZW50aWZpZXIgYW5kIGEgdG9rZW4gY29udHJhY3QgYWRkcmVzcy5cbiAqL1xuZXhwb3J0cy5BbGNoZW15VG9rZW5QcmljZXNCeUFkZHJlc3NTY2hlbWEgPSB6b2RfMS56XG4gICAgLm9iamVjdCh7XG4gICAgYWRkcmVzc2VzOiB6b2RfMS56XG4gICAgICAgIC5hcnJheSh6b2RfMS56Lm9iamVjdCh7XG4gICAgICAgIG5ldHdvcms6IHpvZF8xLnouc3RyaW5nKCkuZGVzY3JpYmUoXCJOZXR3b3JrIGlkZW50aWZpZXIgKGUuZy4sIGV0aC1tYWlubmV0LCBiYXNlLW1haW5uZXQgZXRjLilcIiksXG4gICAgICAgIGFkZHJlc3M6IHpvZF8xLnouc3RyaW5nKCkuZGVzY3JpYmUoXCJUb2tlbiBjb250cmFjdCBhZGRyZXNzXCIpLFxuICAgIH0pKVxuICAgICAgICAubWluKDEsIFwiQXQgbGVhc3Qgb25lIGFkZHJlc3MgaXMgcmVxdWlyZWQuXCIpXG4gICAgICAgIC5tYXgoMjUsIFwiQSBtYXhpbXVtIG9mIDI1IGFkZHJlc3NlcyBjYW4gYmUgcHJvdmlkZWQuXCIpLFxufSlcbiAgICAuZGVzY3JpYmUoXCJJbnB1dCBzY2hlbWEgZm9yIGZldGNoaW5nIHRva2VuIHByaWNlcyBieSBhZGRyZXNzIGZyb20gQWxjaGVteVwiKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/alchemy/schemas.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/allora/alloraActionProvider.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/allora/alloraActionProvider.js ***!
  \**********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.alloraActionProvider = exports.AlloraActionProvider = void 0;\nconst actionProvider_1 = __webpack_require__(/*! ../actionProvider */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/actionProvider.js\");\nconst actionDecorator_1 = __webpack_require__(/*! ../actionDecorator */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/actionDecorator.js\");\nconst allora_sdk_1 = __webpack_require__(/*! @alloralabs/allora-sdk */ \"(rsc)/./node_modules/@alloralabs/allora-sdk/dist/src/v2/index.js\");\nconst zod_1 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/lib/index.js\");\nconst schemas_1 = __webpack_require__(/*! ./schemas */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/allora/schemas.js\");\n/**\n * Action provider for interacting with Allora Network\n */\nclass AlloraActionProvider extends actionProvider_1.ActionProvider {\n    /**\n     * Creates an instance of AlloraActionProvider\n     *\n     * @param config - Configuration for the Allora API client including API key and optional chain slug\n     */\n    constructor(config = {}) {\n        super(\"allora\", []);\n        // This is a public, development only key and should be used for testing purposes only.\n        // It might be changed or revoked in the future. It is also subject to limits and usage policies.\n        const DEFAULT_API_KEY = \"UP-4151d0cc489a44a7aa5cd7ef\";\n        config.apiKey = config.apiKey || DEFAULT_API_KEY;\n        config.chainSlug = config.chainSlug || allora_sdk_1.ChainSlug.TESTNET;\n        this.client = new allora_sdk_1.AlloraAPIClient(config);\n    }\n    /**\n     * Gets all available topics from Allora Network\n     *\n     * @param _ - Empty object as no parameters are required\n     * @returns A string containing the list of topics in JSON format\n     */\n    async getAllTopics(_) {\n        try {\n            const topics = await this.client.getAllTopics();\n            const topicsJson = JSON.stringify(topics);\n            return `The available topics at Allora Network are:\\n ${topicsJson}`;\n        }\n        catch (error) {\n            return `Error getting all topics: ${error}`;\n        }\n    }\n    /**\n     * Gets inference data for a specific topic from Allora Network\n     *\n     * @param args - Object containing the topic ID to get inference for\n     * @returns A string containing the inference data in JSON format\n     */\n    async getInferenceByTopicId(args) {\n        try {\n            const inference = await this.client.getInferenceByTopicID(args.topicId);\n            const inferenceJson = JSON.stringify(inference.inference_data);\n            return `The inference for topic ${args.topicId} is:\\n ${inferenceJson}`;\n        }\n        catch (error) {\n            return `Error getting inference for topic ${args.topicId}: ${error}`;\n        }\n    }\n    /**\n     * Gets price inference for a token/timeframe pair from Allora Network\n     *\n     * @param args - Object containing the asset symbol and timeframe\n     * @returns A string containing the price inference data in JSON format\n     */\n    async getPriceInference(args) {\n        try {\n            const inference = await this.client.getPriceInference(args.asset, args.timeframe);\n            const response = {\n                price: inference.inference_data.network_inference_normalized,\n                timestamp: inference.inference_data.timestamp,\n                asset: args.asset,\n                timeframe: args.timeframe,\n            };\n            const inferenceJson = JSON.stringify(response);\n            return `The price inference for ${args.asset} (${args.timeframe}) is:\\n${inferenceJson}`;\n        }\n        catch (error) {\n            return `Error getting price inference for ${args.asset} (${args.timeframe}): ${error}`;\n        }\n    }\n    /**\n     * Checks if the provider supports a given network\n     *\n     * @returns Always returns true as Allora service is network-agnostic\n     */\n    supportsNetwork() {\n        return true; // Allora service is network-agnostic\n    }\n}\nexports.AlloraActionProvider = AlloraActionProvider;\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"get_all_topics\",\n        description: `\nThis tool will get all available inference topics from Allora Network.\n\nA successful response will return a list of available topics in JSON format. Example:\n[\n    {\n        \"topic_id\": 1,\n        \"topic_name\": \"Bitcoin 8h\",\n        \"description\": \"Bitcoin price prediction for the next 8 hours\",\n        \"epoch_length\": 100,\n        \"ground_truth_lag\": 10,\n        \"loss_method\": \"method1\",\n        \"worker_submission_window\": 50,\n        \"worker_count\": 5,\n        \"reputer_count\": 3,\n        \"total_staked_allo\": 1000,\n        \"total_emissions_allo\": 500,\n        \"is_active\": true,\n        \"updated_at\": \"2023-01-01T00:00:00Z\"\n    }\n]\n\nKey fields:\n- topic_id: Unique identifier, use with get_inference_by_topic_id action\n- topic_name: Name of the topic\n- description: Short description of the topic's purpose\n- is_active: If true, topic is active and accepting submissions\n- updated_at: Timestamp of last update\n\nA failure response will return an error message with details.\n`,\n        schema: schemas_1.GetAllTopicsSchema,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [void 0]),\n    __metadata(\"design:returntype\", Promise)\n], AlloraActionProvider.prototype, \"getAllTopics\", null);\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"get_inference_by_topic_id\",\n        description: `\nThis tool will get inference for a specific topic from Allora Network.\nIt requires a topic ID as input, which can be obtained from the get_all_topics action.\n\nA successful response will return a message with the inference data in JSON format. Example:\n    {\n        \"network_inference\": \"0.5\",\n        \"network_inference_normalized\": \"0.5\",\n        \"confidence_interval_percentiles\": [\"0.1\", \"0.5\", \"0.9\"],\n        \"confidence_interval_percentiles_normalized\": [\"0.1\", \"0.5\", \"0.9\"],\n        \"confidence_interval_values\": [\"0.1\", \"0.5\", \"0.9\"],\n        \"confidence_interval_values_normalized\": [\"0.1\", \"0.5\", \"0.9\"],\n        \"topic_id\": \"1\",\n        \"timestamp\": 1718198400,\n        \"extra_data\": \"extra_data\"\n    }\nThe network_inference field is the inference for the topic.\nThe network_inference_normalized field is the normalized inference for the topic.\n\nA failure response will return an error message with details.\n`,\n        schema: schemas_1.GetInferenceByTopicIdSchema,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [void 0]),\n    __metadata(\"design:returntype\", Promise)\n], AlloraActionProvider.prototype, \"getInferenceByTopicId\", null);\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"get_price_inference\",\n        description: `\nThis tool will get price inference for a specific token and timeframe from Allora Network.\nIt requires an asset symbol (e.g., 'BTC', 'ETH') and a timeframe (e.g., '8h', '24h') as input.\n\nA successful response will return a message with the price inference. Example:\n    The price inference for BTC (8h) is:\n    {\n        \"price\": \"100000\",\n        \"timestamp\": 1718198400,\n        \"asset\": \"BTC\",\n        \"timeframe\": \"8h\"\n    }\n\nA failure response will return an error message with details.\n`,\n        schema: schemas_1.GetPriceInferenceSchema,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [void 0]),\n    __metadata(\"design:returntype\", Promise)\n], AlloraActionProvider.prototype, \"getPriceInference\", null);\nconst alloraActionProvider = (config = {}) => new AlloraActionProvider(config);\nexports.alloraActionProvider = alloraActionProvider;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9hbGxvcmEvYWxsb3JhQWN0aW9uUHJvdmlkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsUUFBUTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDRCQUE0QixHQUFHLDRCQUE0QjtBQUMzRCx5QkFBeUIsbUJBQU8sQ0FBQywwR0FBbUI7QUFDcEQsMEJBQTBCLG1CQUFPLENBQUMsNEdBQW9CO0FBQ3RELHFCQUFxQixtQkFBTyxDQUFDLGdHQUF3QjtBQUNyRCxjQUFjLG1CQUFPLENBQUMsa0RBQUs7QUFDM0Isa0JBQWtCLG1CQUFPLENBQUMsa0dBQVc7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxXQUFXO0FBQy9FO0FBQ0E7QUFDQSxnREFBZ0QsTUFBTTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYyxRQUFRLGNBQWM7QUFDbEY7QUFDQTtBQUNBLHdEQUF3RCxhQUFhLElBQUksTUFBTTtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsWUFBWSxHQUFHLGVBQWUsU0FBUyxjQUFjO0FBQ25HO0FBQ0E7QUFDQSx3REFBd0QsWUFBWSxHQUFHLGVBQWUsS0FBSyxNQUFNO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDLDRCQUE0QiIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cnZpdmFsLWZ1bi8uL25vZGVfbW9kdWxlcy9AY29pbmJhc2UvYWdlbnRraXQvZGlzdC9hY3Rpb24tcHJvdmlkZXJzL2FsbG9yYS9hbGxvcmFBY3Rpb25Qcm92aWRlci5qcz8zYmFkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYWxsb3JhQWN0aW9uUHJvdmlkZXIgPSBleHBvcnRzLkFsbG9yYUFjdGlvblByb3ZpZGVyID0gdm9pZCAwO1xuY29uc3QgYWN0aW9uUHJvdmlkZXJfMSA9IHJlcXVpcmUoXCIuLi9hY3Rpb25Qcm92aWRlclwiKTtcbmNvbnN0IGFjdGlvbkRlY29yYXRvcl8xID0gcmVxdWlyZShcIi4uL2FjdGlvbkRlY29yYXRvclwiKTtcbmNvbnN0IGFsbG9yYV9zZGtfMSA9IHJlcXVpcmUoXCJAYWxsb3JhbGFicy9hbGxvcmEtc2RrXCIpO1xuY29uc3Qgem9kXzEgPSByZXF1aXJlKFwiem9kXCIpO1xuY29uc3Qgc2NoZW1hc18xID0gcmVxdWlyZShcIi4vc2NoZW1hc1wiKTtcbi8qKlxuICogQWN0aW9uIHByb3ZpZGVyIGZvciBpbnRlcmFjdGluZyB3aXRoIEFsbG9yYSBOZXR3b3JrXG4gKi9cbmNsYXNzIEFsbG9yYUFjdGlvblByb3ZpZGVyIGV4dGVuZHMgYWN0aW9uUHJvdmlkZXJfMS5BY3Rpb25Qcm92aWRlciB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBBbGxvcmFBY3Rpb25Qcm92aWRlclxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbmZpZyAtIENvbmZpZ3VyYXRpb24gZm9yIHRoZSBBbGxvcmEgQVBJIGNsaWVudCBpbmNsdWRpbmcgQVBJIGtleSBhbmQgb3B0aW9uYWwgY2hhaW4gc2x1Z1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKFwiYWxsb3JhXCIsIFtdKTtcbiAgICAgICAgLy8gVGhpcyBpcyBhIHB1YmxpYywgZGV2ZWxvcG1lbnQgb25seSBrZXkgYW5kIHNob3VsZCBiZSB1c2VkIGZvciB0ZXN0aW5nIHB1cnBvc2VzIG9ubHkuXG4gICAgICAgIC8vIEl0IG1pZ2h0IGJlIGNoYW5nZWQgb3IgcmV2b2tlZCBpbiB0aGUgZnV0dXJlLiBJdCBpcyBhbHNvIHN1YmplY3QgdG8gbGltaXRzIGFuZCB1c2FnZSBwb2xpY2llcy5cbiAgICAgICAgY29uc3QgREVGQVVMVF9BUElfS0VZID0gXCJVUC00MTUxZDBjYzQ4OWE0NGE3YWE1Y2Q3ZWZcIjtcbiAgICAgICAgY29uZmlnLmFwaUtleSA9IGNvbmZpZy5hcGlLZXkgfHwgREVGQVVMVF9BUElfS0VZO1xuICAgICAgICBjb25maWcuY2hhaW5TbHVnID0gY29uZmlnLmNoYWluU2x1ZyB8fCBhbGxvcmFfc2RrXzEuQ2hhaW5TbHVnLlRFU1RORVQ7XG4gICAgICAgIHRoaXMuY2xpZW50ID0gbmV3IGFsbG9yYV9zZGtfMS5BbGxvcmFBUElDbGllbnQoY29uZmlnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhbGwgYXZhaWxhYmxlIHRvcGljcyBmcm9tIEFsbG9yYSBOZXR3b3JrXG4gICAgICpcbiAgICAgKiBAcGFyYW0gXyAtIEVtcHR5IG9iamVjdCBhcyBubyBwYXJhbWV0ZXJzIGFyZSByZXF1aXJlZFxuICAgICAqIEByZXR1cm5zIEEgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIGxpc3Qgb2YgdG9waWNzIGluIEpTT04gZm9ybWF0XG4gICAgICovXG4gICAgYXN5bmMgZ2V0QWxsVG9waWNzKF8pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHRvcGljcyA9IGF3YWl0IHRoaXMuY2xpZW50LmdldEFsbFRvcGljcygpO1xuICAgICAgICAgICAgY29uc3QgdG9waWNzSnNvbiA9IEpTT04uc3RyaW5naWZ5KHRvcGljcyk7XG4gICAgICAgICAgICByZXR1cm4gYFRoZSBhdmFpbGFibGUgdG9waWNzIGF0IEFsbG9yYSBOZXR3b3JrIGFyZTpcXG4gJHt0b3BpY3NKc29ufWA7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gYEVycm9yIGdldHRpbmcgYWxsIHRvcGljczogJHtlcnJvcn1gO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgaW5mZXJlbmNlIGRhdGEgZm9yIGEgc3BlY2lmaWMgdG9waWMgZnJvbSBBbGxvcmEgTmV0d29ya1xuICAgICAqXG4gICAgICogQHBhcmFtIGFyZ3MgLSBPYmplY3QgY29udGFpbmluZyB0aGUgdG9waWMgSUQgdG8gZ2V0IGluZmVyZW5jZSBmb3JcbiAgICAgKiBAcmV0dXJucyBBIHN0cmluZyBjb250YWluaW5nIHRoZSBpbmZlcmVuY2UgZGF0YSBpbiBKU09OIGZvcm1hdFxuICAgICAqL1xuICAgIGFzeW5jIGdldEluZmVyZW5jZUJ5VG9waWNJZChhcmdzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBpbmZlcmVuY2UgPSBhd2FpdCB0aGlzLmNsaWVudC5nZXRJbmZlcmVuY2VCeVRvcGljSUQoYXJncy50b3BpY0lkKTtcbiAgICAgICAgICAgIGNvbnN0IGluZmVyZW5jZUpzb24gPSBKU09OLnN0cmluZ2lmeShpbmZlcmVuY2UuaW5mZXJlbmNlX2RhdGEpO1xuICAgICAgICAgICAgcmV0dXJuIGBUaGUgaW5mZXJlbmNlIGZvciB0b3BpYyAke2FyZ3MudG9waWNJZH0gaXM6XFxuICR7aW5mZXJlbmNlSnNvbn1gO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGBFcnJvciBnZXR0aW5nIGluZmVyZW5jZSBmb3IgdG9waWMgJHthcmdzLnRvcGljSWR9OiAke2Vycm9yfWA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBwcmljZSBpbmZlcmVuY2UgZm9yIGEgdG9rZW4vdGltZWZyYW1lIHBhaXIgZnJvbSBBbGxvcmEgTmV0d29ya1xuICAgICAqXG4gICAgICogQHBhcmFtIGFyZ3MgLSBPYmplY3QgY29udGFpbmluZyB0aGUgYXNzZXQgc3ltYm9sIGFuZCB0aW1lZnJhbWVcbiAgICAgKiBAcmV0dXJucyBBIHN0cmluZyBjb250YWluaW5nIHRoZSBwcmljZSBpbmZlcmVuY2UgZGF0YSBpbiBKU09OIGZvcm1hdFxuICAgICAqL1xuICAgIGFzeW5jIGdldFByaWNlSW5mZXJlbmNlKGFyZ3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGluZmVyZW5jZSA9IGF3YWl0IHRoaXMuY2xpZW50LmdldFByaWNlSW5mZXJlbmNlKGFyZ3MuYXNzZXQsIGFyZ3MudGltZWZyYW1lKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgIHByaWNlOiBpbmZlcmVuY2UuaW5mZXJlbmNlX2RhdGEubmV0d29ya19pbmZlcmVuY2Vfbm9ybWFsaXplZCxcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IGluZmVyZW5jZS5pbmZlcmVuY2VfZGF0YS50aW1lc3RhbXAsXG4gICAgICAgICAgICAgICAgYXNzZXQ6IGFyZ3MuYXNzZXQsXG4gICAgICAgICAgICAgICAgdGltZWZyYW1lOiBhcmdzLnRpbWVmcmFtZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBpbmZlcmVuY2VKc29uID0gSlNPTi5zdHJpbmdpZnkocmVzcG9uc2UpO1xuICAgICAgICAgICAgcmV0dXJuIGBUaGUgcHJpY2UgaW5mZXJlbmNlIGZvciAke2FyZ3MuYXNzZXR9ICgke2FyZ3MudGltZWZyYW1lfSkgaXM6XFxuJHtpbmZlcmVuY2VKc29ufWA7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gYEVycm9yIGdldHRpbmcgcHJpY2UgaW5mZXJlbmNlIGZvciAke2FyZ3MuYXNzZXR9ICgke2FyZ3MudGltZWZyYW1lfSk6ICR7ZXJyb3J9YDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIHByb3ZpZGVyIHN1cHBvcnRzIGEgZ2l2ZW4gbmV0d29ya1xuICAgICAqXG4gICAgICogQHJldHVybnMgQWx3YXlzIHJldHVybnMgdHJ1ZSBhcyBBbGxvcmEgc2VydmljZSBpcyBuZXR3b3JrLWFnbm9zdGljXG4gICAgICovXG4gICAgc3VwcG9ydHNOZXR3b3JrKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gQWxsb3JhIHNlcnZpY2UgaXMgbmV0d29yay1hZ25vc3RpY1xuICAgIH1cbn1cbmV4cG9ydHMuQWxsb3JhQWN0aW9uUHJvdmlkZXIgPSBBbGxvcmFBY3Rpb25Qcm92aWRlcjtcbl9fZGVjb3JhdGUoW1xuICAgICgwLCBhY3Rpb25EZWNvcmF0b3JfMS5DcmVhdGVBY3Rpb24pKHtcbiAgICAgICAgbmFtZTogXCJnZXRfYWxsX3RvcGljc1wiLFxuICAgICAgICBkZXNjcmlwdGlvbjogYFxuVGhpcyB0b29sIHdpbGwgZ2V0IGFsbCBhdmFpbGFibGUgaW5mZXJlbmNlIHRvcGljcyBmcm9tIEFsbG9yYSBOZXR3b3JrLlxuXG5BIHN1Y2Nlc3NmdWwgcmVzcG9uc2Ugd2lsbCByZXR1cm4gYSBsaXN0IG9mIGF2YWlsYWJsZSB0b3BpY3MgaW4gSlNPTiBmb3JtYXQuIEV4YW1wbGU6XG5bXG4gICAge1xuICAgICAgICBcInRvcGljX2lkXCI6IDEsXG4gICAgICAgIFwidG9waWNfbmFtZVwiOiBcIkJpdGNvaW4gOGhcIixcbiAgICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIkJpdGNvaW4gcHJpY2UgcHJlZGljdGlvbiBmb3IgdGhlIG5leHQgOCBob3Vyc1wiLFxuICAgICAgICBcImVwb2NoX2xlbmd0aFwiOiAxMDAsXG4gICAgICAgIFwiZ3JvdW5kX3RydXRoX2xhZ1wiOiAxMCxcbiAgICAgICAgXCJsb3NzX21ldGhvZFwiOiBcIm1ldGhvZDFcIixcbiAgICAgICAgXCJ3b3JrZXJfc3VibWlzc2lvbl93aW5kb3dcIjogNTAsXG4gICAgICAgIFwid29ya2VyX2NvdW50XCI6IDUsXG4gICAgICAgIFwicmVwdXRlcl9jb3VudFwiOiAzLFxuICAgICAgICBcInRvdGFsX3N0YWtlZF9hbGxvXCI6IDEwMDAsXG4gICAgICAgIFwidG90YWxfZW1pc3Npb25zX2FsbG9cIjogNTAwLFxuICAgICAgICBcImlzX2FjdGl2ZVwiOiB0cnVlLFxuICAgICAgICBcInVwZGF0ZWRfYXRcIjogXCIyMDIzLTAxLTAxVDAwOjAwOjAwWlwiXG4gICAgfVxuXVxuXG5LZXkgZmllbGRzOlxuLSB0b3BpY19pZDogVW5pcXVlIGlkZW50aWZpZXIsIHVzZSB3aXRoIGdldF9pbmZlcmVuY2VfYnlfdG9waWNfaWQgYWN0aW9uXG4tIHRvcGljX25hbWU6IE5hbWUgb2YgdGhlIHRvcGljXG4tIGRlc2NyaXB0aW9uOiBTaG9ydCBkZXNjcmlwdGlvbiBvZiB0aGUgdG9waWMncyBwdXJwb3NlXG4tIGlzX2FjdGl2ZTogSWYgdHJ1ZSwgdG9waWMgaXMgYWN0aXZlIGFuZCBhY2NlcHRpbmcgc3VibWlzc2lvbnNcbi0gdXBkYXRlZF9hdDogVGltZXN0YW1wIG9mIGxhc3QgdXBkYXRlXG5cbkEgZmFpbHVyZSByZXNwb25zZSB3aWxsIHJldHVybiBhbiBlcnJvciBtZXNzYWdlIHdpdGggZGV0YWlscy5cbmAsXG4gICAgICAgIHNjaGVtYTogc2NoZW1hc18xLkdldEFsbFRvcGljc1NjaGVtYSxcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbdm9pZCAwXSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIFByb21pc2UpXG5dLCBBbGxvcmFBY3Rpb25Qcm92aWRlci5wcm90b3R5cGUsIFwiZ2V0QWxsVG9waWNzXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgKDAsIGFjdGlvbkRlY29yYXRvcl8xLkNyZWF0ZUFjdGlvbikoe1xuICAgICAgICBuYW1lOiBcImdldF9pbmZlcmVuY2VfYnlfdG9waWNfaWRcIixcbiAgICAgICAgZGVzY3JpcHRpb246IGBcblRoaXMgdG9vbCB3aWxsIGdldCBpbmZlcmVuY2UgZm9yIGEgc3BlY2lmaWMgdG9waWMgZnJvbSBBbGxvcmEgTmV0d29yay5cbkl0IHJlcXVpcmVzIGEgdG9waWMgSUQgYXMgaW5wdXQsIHdoaWNoIGNhbiBiZSBvYnRhaW5lZCBmcm9tIHRoZSBnZXRfYWxsX3RvcGljcyBhY3Rpb24uXG5cbkEgc3VjY2Vzc2Z1bCByZXNwb25zZSB3aWxsIHJldHVybiBhIG1lc3NhZ2Ugd2l0aCB0aGUgaW5mZXJlbmNlIGRhdGEgaW4gSlNPTiBmb3JtYXQuIEV4YW1wbGU6XG4gICAge1xuICAgICAgICBcIm5ldHdvcmtfaW5mZXJlbmNlXCI6IFwiMC41XCIsXG4gICAgICAgIFwibmV0d29ya19pbmZlcmVuY2Vfbm9ybWFsaXplZFwiOiBcIjAuNVwiLFxuICAgICAgICBcImNvbmZpZGVuY2VfaW50ZXJ2YWxfcGVyY2VudGlsZXNcIjogW1wiMC4xXCIsIFwiMC41XCIsIFwiMC45XCJdLFxuICAgICAgICBcImNvbmZpZGVuY2VfaW50ZXJ2YWxfcGVyY2VudGlsZXNfbm9ybWFsaXplZFwiOiBbXCIwLjFcIiwgXCIwLjVcIiwgXCIwLjlcIl0sXG4gICAgICAgIFwiY29uZmlkZW5jZV9pbnRlcnZhbF92YWx1ZXNcIjogW1wiMC4xXCIsIFwiMC41XCIsIFwiMC45XCJdLFxuICAgICAgICBcImNvbmZpZGVuY2VfaW50ZXJ2YWxfdmFsdWVzX25vcm1hbGl6ZWRcIjogW1wiMC4xXCIsIFwiMC41XCIsIFwiMC45XCJdLFxuICAgICAgICBcInRvcGljX2lkXCI6IFwiMVwiLFxuICAgICAgICBcInRpbWVzdGFtcFwiOiAxNzE4MTk4NDAwLFxuICAgICAgICBcImV4dHJhX2RhdGFcIjogXCJleHRyYV9kYXRhXCJcbiAgICB9XG5UaGUgbmV0d29ya19pbmZlcmVuY2UgZmllbGQgaXMgdGhlIGluZmVyZW5jZSBmb3IgdGhlIHRvcGljLlxuVGhlIG5ldHdvcmtfaW5mZXJlbmNlX25vcm1hbGl6ZWQgZmllbGQgaXMgdGhlIG5vcm1hbGl6ZWQgaW5mZXJlbmNlIGZvciB0aGUgdG9waWMuXG5cbkEgZmFpbHVyZSByZXNwb25zZSB3aWxsIHJldHVybiBhbiBlcnJvciBtZXNzYWdlIHdpdGggZGV0YWlscy5cbmAsXG4gICAgICAgIHNjaGVtYTogc2NoZW1hc18xLkdldEluZmVyZW5jZUJ5VG9waWNJZFNjaGVtYSxcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbdm9pZCAwXSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIFByb21pc2UpXG5dLCBBbGxvcmFBY3Rpb25Qcm92aWRlci5wcm90b3R5cGUsIFwiZ2V0SW5mZXJlbmNlQnlUb3BpY0lkXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgKDAsIGFjdGlvbkRlY29yYXRvcl8xLkNyZWF0ZUFjdGlvbikoe1xuICAgICAgICBuYW1lOiBcImdldF9wcmljZV9pbmZlcmVuY2VcIixcbiAgICAgICAgZGVzY3JpcHRpb246IGBcblRoaXMgdG9vbCB3aWxsIGdldCBwcmljZSBpbmZlcmVuY2UgZm9yIGEgc3BlY2lmaWMgdG9rZW4gYW5kIHRpbWVmcmFtZSBmcm9tIEFsbG9yYSBOZXR3b3JrLlxuSXQgcmVxdWlyZXMgYW4gYXNzZXQgc3ltYm9sIChlLmcuLCAnQlRDJywgJ0VUSCcpIGFuZCBhIHRpbWVmcmFtZSAoZS5nLiwgJzhoJywgJzI0aCcpIGFzIGlucHV0LlxuXG5BIHN1Y2Nlc3NmdWwgcmVzcG9uc2Ugd2lsbCByZXR1cm4gYSBtZXNzYWdlIHdpdGggdGhlIHByaWNlIGluZmVyZW5jZS4gRXhhbXBsZTpcbiAgICBUaGUgcHJpY2UgaW5mZXJlbmNlIGZvciBCVEMgKDhoKSBpczpcbiAgICB7XG4gICAgICAgIFwicHJpY2VcIjogXCIxMDAwMDBcIixcbiAgICAgICAgXCJ0aW1lc3RhbXBcIjogMTcxODE5ODQwMCxcbiAgICAgICAgXCJhc3NldFwiOiBcIkJUQ1wiLFxuICAgICAgICBcInRpbWVmcmFtZVwiOiBcIjhoXCJcbiAgICB9XG5cbkEgZmFpbHVyZSByZXNwb25zZSB3aWxsIHJldHVybiBhbiBlcnJvciBtZXNzYWdlIHdpdGggZGV0YWlscy5cbmAsXG4gICAgICAgIHNjaGVtYTogc2NoZW1hc18xLkdldFByaWNlSW5mZXJlbmNlU2NoZW1hLFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFt2b2lkIDBdKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgUHJvbWlzZSlcbl0sIEFsbG9yYUFjdGlvblByb3ZpZGVyLnByb3RvdHlwZSwgXCJnZXRQcmljZUluZmVyZW5jZVwiLCBudWxsKTtcbmNvbnN0IGFsbG9yYUFjdGlvblByb3ZpZGVyID0gKGNvbmZpZyA9IHt9KSA9PiBuZXcgQWxsb3JhQWN0aW9uUHJvdmlkZXIoY29uZmlnKTtcbmV4cG9ydHMuYWxsb3JhQWN0aW9uUHJvdmlkZXIgPSBhbGxvcmFBY3Rpb25Qcm92aWRlcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/allora/alloraActionProvider.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/allora/index.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/allora/index.js ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./alloraActionProvider */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/allora/alloraActionProvider.js\"), exports);\n__exportStar(__webpack_require__(/*! ./schemas */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/allora/schemas.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9hbGxvcmEvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYSxtQkFBTyxDQUFDLDRIQUF3QjtBQUM3QyxhQUFhLG1CQUFPLENBQUMsa0dBQVciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXJ2aXZhbC1mdW4vLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9hbGxvcmEvaW5kZXguanM/OGJhMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2FsbG9yYUFjdGlvblByb3ZpZGVyXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9zY2hlbWFzXCIpLCBleHBvcnRzKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/allora/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/allora/schemas.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/allora/schemas.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GetPriceInferenceSchema = exports.GetInferenceByTopicIdSchema = exports.GetAllTopicsSchema = void 0;\nconst zod_1 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/lib/index.js\");\n/**\n * Input schema for getting all topics from Allora Network\n */\nexports.GetAllTopicsSchema = zod_1.z\n    .object({})\n    .strip()\n    .describe(\"Instructions for getting all topics from Allora Network\");\n/**\n * Input schema for getting inference data by topic ID from Allora Network\n */\nexports.GetInferenceByTopicIdSchema = zod_1.z\n    .object({\n    topicId: zod_1.z.number().describe(\"The ID of the topic to get inference data for\"),\n})\n    .strip()\n    .describe(\"Instructions for getting inference data from Allora Network by topic ID\");\n/**\n * Input schema for getting price inference for a token/timeframe pair\n */\nexports.GetPriceInferenceSchema = zod_1.z\n    .object({\n    asset: zod_1.z.string().describe(\"The token to get price inference for (e.g., 'BTC', 'ETH')\"),\n    timeframe: zod_1.z.string().describe(\"The timeframe for the prediction (e.g., '8h', '24h')\"),\n})\n    .strip()\n    .describe(\"Instructions for getting price inference for a token/timeframe pair\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9hbGxvcmEvc2NoZW1hcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwrQkFBK0IsR0FBRyxtQ0FBbUMsR0FBRywwQkFBMEI7QUFDbEcsY0FBYyxtQkFBTyxDQUFDLGtEQUFLO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXJ2aXZhbC1mdW4vLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9hbGxvcmEvc2NoZW1hcy5qcz9hYmNlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5HZXRQcmljZUluZmVyZW5jZVNjaGVtYSA9IGV4cG9ydHMuR2V0SW5mZXJlbmNlQnlUb3BpY0lkU2NoZW1hID0gZXhwb3J0cy5HZXRBbGxUb3BpY3NTY2hlbWEgPSB2b2lkIDA7XG5jb25zdCB6b2RfMSA9IHJlcXVpcmUoXCJ6b2RcIik7XG4vKipcbiAqIElucHV0IHNjaGVtYSBmb3IgZ2V0dGluZyBhbGwgdG9waWNzIGZyb20gQWxsb3JhIE5ldHdvcmtcbiAqL1xuZXhwb3J0cy5HZXRBbGxUb3BpY3NTY2hlbWEgPSB6b2RfMS56XG4gICAgLm9iamVjdCh7fSlcbiAgICAuc3RyaXAoKVxuICAgIC5kZXNjcmliZShcIkluc3RydWN0aW9ucyBmb3IgZ2V0dGluZyBhbGwgdG9waWNzIGZyb20gQWxsb3JhIE5ldHdvcmtcIik7XG4vKipcbiAqIElucHV0IHNjaGVtYSBmb3IgZ2V0dGluZyBpbmZlcmVuY2UgZGF0YSBieSB0b3BpYyBJRCBmcm9tIEFsbG9yYSBOZXR3b3JrXG4gKi9cbmV4cG9ydHMuR2V0SW5mZXJlbmNlQnlUb3BpY0lkU2NoZW1hID0gem9kXzEuelxuICAgIC5vYmplY3Qoe1xuICAgIHRvcGljSWQ6IHpvZF8xLnoubnVtYmVyKCkuZGVzY3JpYmUoXCJUaGUgSUQgb2YgdGhlIHRvcGljIHRvIGdldCBpbmZlcmVuY2UgZGF0YSBmb3JcIiksXG59KVxuICAgIC5zdHJpcCgpXG4gICAgLmRlc2NyaWJlKFwiSW5zdHJ1Y3Rpb25zIGZvciBnZXR0aW5nIGluZmVyZW5jZSBkYXRhIGZyb20gQWxsb3JhIE5ldHdvcmsgYnkgdG9waWMgSURcIik7XG4vKipcbiAqIElucHV0IHNjaGVtYSBmb3IgZ2V0dGluZyBwcmljZSBpbmZlcmVuY2UgZm9yIGEgdG9rZW4vdGltZWZyYW1lIHBhaXJcbiAqL1xuZXhwb3J0cy5HZXRQcmljZUluZmVyZW5jZVNjaGVtYSA9IHpvZF8xLnpcbiAgICAub2JqZWN0KHtcbiAgICBhc3NldDogem9kXzEuei5zdHJpbmcoKS5kZXNjcmliZShcIlRoZSB0b2tlbiB0byBnZXQgcHJpY2UgaW5mZXJlbmNlIGZvciAoZS5nLiwgJ0JUQycsICdFVEgnKVwiKSxcbiAgICB0aW1lZnJhbWU6IHpvZF8xLnouc3RyaW5nKCkuZGVzY3JpYmUoXCJUaGUgdGltZWZyYW1lIGZvciB0aGUgcHJlZGljdGlvbiAoZS5nLiwgJzhoJywgJzI0aCcpXCIpLFxufSlcbiAgICAuc3RyaXAoKVxuICAgIC5kZXNjcmliZShcIkluc3RydWN0aW9ucyBmb3IgZ2V0dGluZyBwcmljZSBpbmZlcmVuY2UgZm9yIGEgdG9rZW4vdGltZWZyYW1lIHBhaXJcIik7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/allora/schemas.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/basename/basenameActionProvider.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/basename/basenameActionProvider.js ***!
  \**************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.basenameActionProvider = exports.BasenameActionProvider = void 0;\nconst viem_1 = __webpack_require__(/*! viem */ \"(rsc)/./node_modules/viem/_cjs/index.js\");\nconst zod_1 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/lib/index.js\");\nconst actionProvider_1 = __webpack_require__(/*! ../actionProvider */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/actionProvider.js\");\nconst actionDecorator_1 = __webpack_require__(/*! ../actionDecorator */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/actionDecorator.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/basename/constants.js\");\nconst schemas_1 = __webpack_require__(/*! ./schemas */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/basename/schemas.js\");\nconst wallet_providers_1 = __webpack_require__(/*! ../../wallet-providers */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/wallet-providers/index.js\");\n/**\n * Action provider for registering Basenames.\n */\nclass BasenameActionProvider extends actionProvider_1.ActionProvider {\n    /**\n     * Constructs a new BasenameActionProvider.\n     */\n    constructor() {\n        super(\"basename\", []);\n        /**\n         * Checks if the Basename action provider supports the given network.\n         *\n         * @param network - The network to check.\n         * @returns True if the Basename action provider supports the network, false otherwise.\n         */\n        this.supportsNetwork = (network) => network.networkId === \"base-mainnet\" || network.networkId === \"base-sepolia\";\n    }\n    /**\n     * Registers a Basename.\n     *\n     * @param wallet - The wallet to use for the registration.\n     * @param args - The arguments for the registration.\n     * @returns A string indicating the success or failure of the registration.\n     */\n    async register(wallet, args) {\n        const address = wallet.getAddress();\n        const isMainnet = wallet.getNetwork().networkId === \"base-mainnet\";\n        const suffix = isMainnet ? \".base.eth\" : \".basetest.eth\";\n        if (!args.basename.endsWith(suffix)) {\n            args.basename += suffix;\n        }\n        const l2ResolverAddress = isMainnet ? constants_1.L2_RESOLVER_ADDRESS_MAINNET : constants_1.L2_RESOLVER_ADDRESS_TESTNET;\n        const addressData = (0, viem_1.encodeFunctionData)({\n            abi: constants_1.L2_RESOLVER_ABI,\n            functionName: \"setAddr\",\n            args: [(0, viem_1.namehash)(args.basename), address],\n        });\n        const nameData = (0, viem_1.encodeFunctionData)({\n            abi: constants_1.L2_RESOLVER_ABI,\n            functionName: \"setName\",\n            args: [(0, viem_1.namehash)(args.basename), args.basename],\n        });\n        try {\n            const contractAddress = isMainnet\n                ? constants_1.BASENAMES_REGISTRAR_CONTROLLER_ADDRESS_MAINNET\n                : constants_1.BASENAMES_REGISTRAR_CONTROLLER_ADDRESS_TESTNET;\n            const hash = await wallet.sendTransaction({\n                to: contractAddress,\n                data: (0, viem_1.encodeFunctionData)({\n                    abi: constants_1.REGISTRAR_ABI,\n                    functionName: \"register\",\n                    args: [\n                        {\n                            name: args.basename.replace(suffix, \"\"),\n                            owner: address,\n                            duration: constants_1.REGISTRATION_DURATION,\n                            resolver: l2ResolverAddress,\n                            data: [addressData, nameData],\n                            reverseRecord: true,\n                        },\n                    ],\n                }),\n                value: (0, viem_1.parseEther)(args.amount),\n            });\n            await wallet.waitForTransactionReceipt(hash);\n            return `Successfully registered basename ${args.basename} for address ${address}`;\n        }\n        catch (error) {\n            return `Error registering basename: Error: ${error}`;\n        }\n    }\n}\nexports.BasenameActionProvider = BasenameActionProvider;\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"register_basename\",\n        description: `\nThis tool will register a Basename for the agent. The agent should have a wallet associated to register a Basename.\nWhen your network ID is 'base-mainnet' (also sometimes known simply as 'base'), the name must end with .base.eth, and when your network ID is 'base-sepolia', it must ends with .basetest.eth.\nDo not suggest any alternatives and never try to register a Basename with another postfix. The prefix of the name must be unique so if the registration of the\nBasename fails, you should prompt to try again with a more unique name.\n`,\n        schema: schemas_1.RegisterBasenameSchema,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [wallet_providers_1.EvmWalletProvider, void 0]),\n    __metadata(\"design:returntype\", Promise)\n], BasenameActionProvider.prototype, \"register\", null);\nconst basenameActionProvider = () => new BasenameActionProvider();\nexports.basenameActionProvider = basenameActionProvider;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9iYXNlbmFtZS9iYXNlbmFtZUFjdGlvblByb3ZpZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFFBQVE7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw4QkFBOEIsR0FBRyw4QkFBOEI7QUFDL0QsZUFBZSxtQkFBTyxDQUFDLHFEQUFNO0FBQzdCLGNBQWMsbUJBQU8sQ0FBQyxrREFBSztBQUMzQix5QkFBeUIsbUJBQU8sQ0FBQywwR0FBbUI7QUFDcEQsMEJBQTBCLG1CQUFPLENBQUMsNEdBQW9CO0FBQ3RELG9CQUFvQixtQkFBTyxDQUFDLHdHQUFhO0FBQ3pDLGtCQUFrQixtQkFBTyxDQUFDLG9HQUFXO0FBQ3JDLDJCQUEyQixtQkFBTyxDQUFDLHNHQUF3QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNBLHVEQUF1RCxlQUFlLGNBQWMsUUFBUTtBQUM1RjtBQUNBO0FBQ0EseURBQXlELE1BQU07QUFDL0Q7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXJ2aXZhbC1mdW4vLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9iYXNlbmFtZS9iYXNlbmFtZUFjdGlvblByb3ZpZGVyLmpzPzAzZGQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5iYXNlbmFtZUFjdGlvblByb3ZpZGVyID0gZXhwb3J0cy5CYXNlbmFtZUFjdGlvblByb3ZpZGVyID0gdm9pZCAwO1xuY29uc3QgdmllbV8xID0gcmVxdWlyZShcInZpZW1cIik7XG5jb25zdCB6b2RfMSA9IHJlcXVpcmUoXCJ6b2RcIik7XG5jb25zdCBhY3Rpb25Qcm92aWRlcl8xID0gcmVxdWlyZShcIi4uL2FjdGlvblByb3ZpZGVyXCIpO1xuY29uc3QgYWN0aW9uRGVjb3JhdG9yXzEgPSByZXF1aXJlKFwiLi4vYWN0aW9uRGVjb3JhdG9yXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCBzY2hlbWFzXzEgPSByZXF1aXJlKFwiLi9zY2hlbWFzXCIpO1xuY29uc3Qgd2FsbGV0X3Byb3ZpZGVyc18xID0gcmVxdWlyZShcIi4uLy4uL3dhbGxldC1wcm92aWRlcnNcIik7XG4vKipcbiAqIEFjdGlvbiBwcm92aWRlciBmb3IgcmVnaXN0ZXJpbmcgQmFzZW5hbWVzLlxuICovXG5jbGFzcyBCYXNlbmFtZUFjdGlvblByb3ZpZGVyIGV4dGVuZHMgYWN0aW9uUHJvdmlkZXJfMS5BY3Rpb25Qcm92aWRlciB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyBhIG5ldyBCYXNlbmFtZUFjdGlvblByb3ZpZGVyLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihcImJhc2VuYW1lXCIsIFtdKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrcyBpZiB0aGUgQmFzZW5hbWUgYWN0aW9uIHByb3ZpZGVyIHN1cHBvcnRzIHRoZSBnaXZlbiBuZXR3b3JrLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gbmV0d29yayAtIFRoZSBuZXR3b3JrIHRvIGNoZWNrLlxuICAgICAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBCYXNlbmFtZSBhY3Rpb24gcHJvdmlkZXIgc3VwcG9ydHMgdGhlIG5ldHdvcmssIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3VwcG9ydHNOZXR3b3JrID0gKG5ldHdvcmspID0+IG5ldHdvcmsubmV0d29ya0lkID09PSBcImJhc2UtbWFpbm5ldFwiIHx8IG5ldHdvcmsubmV0d29ya0lkID09PSBcImJhc2Utc2Vwb2xpYVwiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBCYXNlbmFtZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB3YWxsZXQgLSBUaGUgd2FsbGV0IHRvIHVzZSBmb3IgdGhlIHJlZ2lzdHJhdGlvbi5cbiAgICAgKiBAcGFyYW0gYXJncyAtIFRoZSBhcmd1bWVudHMgZm9yIHRoZSByZWdpc3RyYXRpb24uXG4gICAgICogQHJldHVybnMgQSBzdHJpbmcgaW5kaWNhdGluZyB0aGUgc3VjY2VzcyBvciBmYWlsdXJlIG9mIHRoZSByZWdpc3RyYXRpb24uXG4gICAgICovXG4gICAgYXN5bmMgcmVnaXN0ZXIod2FsbGV0LCBhcmdzKSB7XG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSB3YWxsZXQuZ2V0QWRkcmVzcygpO1xuICAgICAgICBjb25zdCBpc01haW5uZXQgPSB3YWxsZXQuZ2V0TmV0d29yaygpLm5ldHdvcmtJZCA9PT0gXCJiYXNlLW1haW5uZXRcIjtcbiAgICAgICAgY29uc3Qgc3VmZml4ID0gaXNNYWlubmV0ID8gXCIuYmFzZS5ldGhcIiA6IFwiLmJhc2V0ZXN0LmV0aFwiO1xuICAgICAgICBpZiAoIWFyZ3MuYmFzZW5hbWUuZW5kc1dpdGgoc3VmZml4KSkge1xuICAgICAgICAgICAgYXJncy5iYXNlbmFtZSArPSBzdWZmaXg7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbDJSZXNvbHZlckFkZHJlc3MgPSBpc01haW5uZXQgPyBjb25zdGFudHNfMS5MMl9SRVNPTFZFUl9BRERSRVNTX01BSU5ORVQgOiBjb25zdGFudHNfMS5MMl9SRVNPTFZFUl9BRERSRVNTX1RFU1RORVQ7XG4gICAgICAgIGNvbnN0IGFkZHJlc3NEYXRhID0gKDAsIHZpZW1fMS5lbmNvZGVGdW5jdGlvbkRhdGEpKHtcbiAgICAgICAgICAgIGFiaTogY29uc3RhbnRzXzEuTDJfUkVTT0xWRVJfQUJJLFxuICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiBcInNldEFkZHJcIixcbiAgICAgICAgICAgIGFyZ3M6IFsoMCwgdmllbV8xLm5hbWVoYXNoKShhcmdzLmJhc2VuYW1lKSwgYWRkcmVzc10sXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBuYW1lRGF0YSA9ICgwLCB2aWVtXzEuZW5jb2RlRnVuY3Rpb25EYXRhKSh7XG4gICAgICAgICAgICBhYmk6IGNvbnN0YW50c18xLkwyX1JFU09MVkVSX0FCSSxcbiAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogXCJzZXROYW1lXCIsXG4gICAgICAgICAgICBhcmdzOiBbKDAsIHZpZW1fMS5uYW1laGFzaCkoYXJncy5iYXNlbmFtZSksIGFyZ3MuYmFzZW5hbWVdLFxuICAgICAgICB9KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRyYWN0QWRkcmVzcyA9IGlzTWFpbm5ldFxuICAgICAgICAgICAgICAgID8gY29uc3RhbnRzXzEuQkFTRU5BTUVTX1JFR0lTVFJBUl9DT05UUk9MTEVSX0FERFJFU1NfTUFJTk5FVFxuICAgICAgICAgICAgICAgIDogY29uc3RhbnRzXzEuQkFTRU5BTUVTX1JFR0lTVFJBUl9DT05UUk9MTEVSX0FERFJFU1NfVEVTVE5FVDtcbiAgICAgICAgICAgIGNvbnN0IGhhc2ggPSBhd2FpdCB3YWxsZXQuc2VuZFRyYW5zYWN0aW9uKHtcbiAgICAgICAgICAgICAgICB0bzogY29udHJhY3RBZGRyZXNzLFxuICAgICAgICAgICAgICAgIGRhdGE6ICgwLCB2aWVtXzEuZW5jb2RlRnVuY3Rpb25EYXRhKSh7XG4gICAgICAgICAgICAgICAgICAgIGFiaTogY29uc3RhbnRzXzEuUkVHSVNUUkFSX0FCSSxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiBcInJlZ2lzdGVyXCIsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBhcmdzLmJhc2VuYW1lLnJlcGxhY2Uoc3VmZml4LCBcIlwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvd25lcjogYWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbjogY29uc3RhbnRzXzEuUkVHSVNUUkFUSU9OX0RVUkFUSU9OLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVyOiBsMlJlc29sdmVyQWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBbYWRkcmVzc0RhdGEsIG5hbWVEYXRhXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXZlcnNlUmVjb3JkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogKDAsIHZpZW1fMS5wYXJzZUV0aGVyKShhcmdzLmFtb3VudCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IHdhbGxldC53YWl0Rm9yVHJhbnNhY3Rpb25SZWNlaXB0KGhhc2gpO1xuICAgICAgICAgICAgcmV0dXJuIGBTdWNjZXNzZnVsbHkgcmVnaXN0ZXJlZCBiYXNlbmFtZSAke2FyZ3MuYmFzZW5hbWV9IGZvciBhZGRyZXNzICR7YWRkcmVzc31gO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGBFcnJvciByZWdpc3RlcmluZyBiYXNlbmFtZTogRXJyb3I6ICR7ZXJyb3J9YDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQmFzZW5hbWVBY3Rpb25Qcm92aWRlciA9IEJhc2VuYW1lQWN0aW9uUHJvdmlkZXI7XG5fX2RlY29yYXRlKFtcbiAgICAoMCwgYWN0aW9uRGVjb3JhdG9yXzEuQ3JlYXRlQWN0aW9uKSh7XG4gICAgICAgIG5hbWU6IFwicmVnaXN0ZXJfYmFzZW5hbWVcIixcbiAgICAgICAgZGVzY3JpcHRpb246IGBcblRoaXMgdG9vbCB3aWxsIHJlZ2lzdGVyIGEgQmFzZW5hbWUgZm9yIHRoZSBhZ2VudC4gVGhlIGFnZW50IHNob3VsZCBoYXZlIGEgd2FsbGV0IGFzc29jaWF0ZWQgdG8gcmVnaXN0ZXIgYSBCYXNlbmFtZS5cbldoZW4geW91ciBuZXR3b3JrIElEIGlzICdiYXNlLW1haW5uZXQnIChhbHNvIHNvbWV0aW1lcyBrbm93biBzaW1wbHkgYXMgJ2Jhc2UnKSwgdGhlIG5hbWUgbXVzdCBlbmQgd2l0aCAuYmFzZS5ldGgsIGFuZCB3aGVuIHlvdXIgbmV0d29yayBJRCBpcyAnYmFzZS1zZXBvbGlhJywgaXQgbXVzdCBlbmRzIHdpdGggLmJhc2V0ZXN0LmV0aC5cbkRvIG5vdCBzdWdnZXN0IGFueSBhbHRlcm5hdGl2ZXMgYW5kIG5ldmVyIHRyeSB0byByZWdpc3RlciBhIEJhc2VuYW1lIHdpdGggYW5vdGhlciBwb3N0Zml4LiBUaGUgcHJlZml4IG9mIHRoZSBuYW1lIG11c3QgYmUgdW5pcXVlIHNvIGlmIHRoZSByZWdpc3RyYXRpb24gb2YgdGhlXG5CYXNlbmFtZSBmYWlscywgeW91IHNob3VsZCBwcm9tcHQgdG8gdHJ5IGFnYWluIHdpdGggYSBtb3JlIHVuaXF1ZSBuYW1lLlxuYCxcbiAgICAgICAgc2NoZW1hOiBzY2hlbWFzXzEuUmVnaXN0ZXJCYXNlbmFtZVNjaGVtYSxcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbd2FsbGV0X3Byb3ZpZGVyc18xLkV2bVdhbGxldFByb3ZpZGVyLCB2b2lkIDBdKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgUHJvbWlzZSlcbl0sIEJhc2VuYW1lQWN0aW9uUHJvdmlkZXIucHJvdG90eXBlLCBcInJlZ2lzdGVyXCIsIG51bGwpO1xuY29uc3QgYmFzZW5hbWVBY3Rpb25Qcm92aWRlciA9ICgpID0+IG5ldyBCYXNlbmFtZUFjdGlvblByb3ZpZGVyKCk7XG5leHBvcnRzLmJhc2VuYW1lQWN0aW9uUHJvdmlkZXIgPSBiYXNlbmFtZUFjdGlvblByb3ZpZGVyO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/basename/basenameActionProvider.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/basename/constants.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/basename/constants.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.REGISTRAR_ABI = exports.L2_RESOLVER_ABI = exports.REGISTRATION_DURATION = exports.L2_RESOLVER_ADDRESS_TESTNET = exports.L2_RESOLVER_ADDRESS_MAINNET = exports.BASENAMES_REGISTRAR_CONTROLLER_ADDRESS_TESTNET = exports.BASENAMES_REGISTRAR_CONTROLLER_ADDRESS_MAINNET = void 0;\n// Contract addresses\nexports.BASENAMES_REGISTRAR_CONTROLLER_ADDRESS_MAINNET = \"0x4cCb0BB02FCABA27e82a56646E81d8c5bC4119a5\";\nexports.BASENAMES_REGISTRAR_CONTROLLER_ADDRESS_TESTNET = \"0x49aE3cC2e3AA768B1e5654f5D3C6002144A59581\";\nexports.L2_RESOLVER_ADDRESS_MAINNET = \"0xC6d566A56A1aFf6508b41f6c90ff131615583BCD\";\nexports.L2_RESOLVER_ADDRESS_TESTNET = \"0x6533C94869D28fAA8dF77cc63f9e2b2D6Cf77eBA\";\n// Default registration duration (1 year in seconds)\nexports.REGISTRATION_DURATION = 31557600n;\n// Relevant ABI for L2 Resolver Contract.\nexports.L2_RESOLVER_ABI = [\n    {\n        inputs: [\n            { internalType: \"bytes32\", name: \"node\", type: \"bytes32\" },\n            { internalType: \"address\", name: \"a\", type: \"address\" },\n        ],\n        name: \"setAddr\",\n        outputs: [],\n        stateMutability: \"nonpayable\",\n        type: \"function\",\n    },\n    {\n        inputs: [\n            { internalType: \"bytes32\", name: \"node\", type: \"bytes32\" },\n            { internalType: \"string\", name: \"newName\", type: \"string\" },\n        ],\n        name: \"setName\",\n        outputs: [],\n        stateMutability: \"nonpayable\",\n        type: \"function\",\n    },\n];\n// Relevant ABI for Basenames Registrar Controller Contract.\nexports.REGISTRAR_ABI = [\n    {\n        inputs: [\n            {\n                components: [\n                    {\n                        internalType: \"string\",\n                        name: \"name\",\n                        type: \"string\",\n                    },\n                    {\n                        internalType: \"address\",\n                        name: \"owner\",\n                        type: \"address\",\n                    },\n                    {\n                        internalType: \"uint256\",\n                        name: \"duration\",\n                        type: \"uint256\",\n                    },\n                    {\n                        internalType: \"address\",\n                        name: \"resolver\",\n                        type: \"address\",\n                    },\n                    {\n                        internalType: \"bytes[]\",\n                        name: \"data\",\n                        type: \"bytes[]\",\n                    },\n                    {\n                        internalType: \"bool\",\n                        name: \"reverseRecord\",\n                        type: \"bool\",\n                    },\n                ],\n                internalType: \"struct RegistrarController.RegisterRequest\",\n                name: \"request\",\n                type: \"tuple\",\n            },\n        ],\n        name: \"register\",\n        outputs: [],\n        stateMutability: \"payable\",\n        type: \"function\",\n    },\n];\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9iYXNlbmFtZS9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCLEdBQUcsdUJBQXVCLEdBQUcsNkJBQTZCLEdBQUcsbUNBQW1DLEdBQUcsbUNBQW1DLEdBQUcsc0RBQXNELEdBQUcsc0RBQXNEO0FBQzdRO0FBQ0Esc0RBQXNEO0FBQ3RELHNEQUFzRDtBQUN0RCxtQ0FBbUM7QUFDbkMsbUNBQW1DO0FBQ25DO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQSxjQUFjLHdEQUF3RDtBQUN0RSxjQUFjLHFEQUFxRDtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxjQUFjLHdEQUF3RDtBQUN0RSxjQUFjLHlEQUF5RDtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3Vydml2YWwtZnVuLy4vbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9hZ2VudGtpdC9kaXN0L2FjdGlvbi1wcm92aWRlcnMvYmFzZW5hbWUvY29uc3RhbnRzLmpzP2FhYTIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJFR0lTVFJBUl9BQkkgPSBleHBvcnRzLkwyX1JFU09MVkVSX0FCSSA9IGV4cG9ydHMuUkVHSVNUUkFUSU9OX0RVUkFUSU9OID0gZXhwb3J0cy5MMl9SRVNPTFZFUl9BRERSRVNTX1RFU1RORVQgPSBleHBvcnRzLkwyX1JFU09MVkVSX0FERFJFU1NfTUFJTk5FVCA9IGV4cG9ydHMuQkFTRU5BTUVTX1JFR0lTVFJBUl9DT05UUk9MTEVSX0FERFJFU1NfVEVTVE5FVCA9IGV4cG9ydHMuQkFTRU5BTUVTX1JFR0lTVFJBUl9DT05UUk9MTEVSX0FERFJFU1NfTUFJTk5FVCA9IHZvaWQgMDtcbi8vIENvbnRyYWN0IGFkZHJlc3Nlc1xuZXhwb3J0cy5CQVNFTkFNRVNfUkVHSVNUUkFSX0NPTlRST0xMRVJfQUREUkVTU19NQUlOTkVUID0gXCIweDRjQ2IwQkIwMkZDQUJBMjdlODJhNTY2NDZFODFkOGM1YkM0MTE5YTVcIjtcbmV4cG9ydHMuQkFTRU5BTUVTX1JFR0lTVFJBUl9DT05UUk9MTEVSX0FERFJFU1NfVEVTVE5FVCA9IFwiMHg0OWFFM2NDMmUzQUE3NjhCMWU1NjU0ZjVEM0M2MDAyMTQ0QTU5NTgxXCI7XG5leHBvcnRzLkwyX1JFU09MVkVSX0FERFJFU1NfTUFJTk5FVCA9IFwiMHhDNmQ1NjZBNTZBMWFGZjY1MDhiNDFmNmM5MGZmMTMxNjE1NTgzQkNEXCI7XG5leHBvcnRzLkwyX1JFU09MVkVSX0FERFJFU1NfVEVTVE5FVCA9IFwiMHg2NTMzQzk0ODY5RDI4ZkFBOGRGNzdjYzYzZjllMmIyRDZDZjc3ZUJBXCI7XG4vLyBEZWZhdWx0IHJlZ2lzdHJhdGlvbiBkdXJhdGlvbiAoMSB5ZWFyIGluIHNlY29uZHMpXG5leHBvcnRzLlJFR0lTVFJBVElPTl9EVVJBVElPTiA9IDMxNTU3NjAwbjtcbi8vIFJlbGV2YW50IEFCSSBmb3IgTDIgUmVzb2x2ZXIgQ29udHJhY3QuXG5leHBvcnRzLkwyX1JFU09MVkVSX0FCSSA9IFtcbiAgICB7XG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAgeyBpbnRlcm5hbFR5cGU6IFwiYnl0ZXMzMlwiLCBuYW1lOiBcIm5vZGVcIiwgdHlwZTogXCJieXRlczMyXCIgfSxcbiAgICAgICAgICAgIHsgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIiwgbmFtZTogXCJhXCIsIHR5cGU6IFwiYWRkcmVzc1wiIH0sXG4gICAgICAgIF0sXG4gICAgICAgIG5hbWU6IFwic2V0QWRkclwiLFxuICAgICAgICBvdXRwdXRzOiBbXSxcbiAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiBcIm5vbnBheWFibGVcIixcbiAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgIH0sXG4gICAge1xuICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICAgIHsgaW50ZXJuYWxUeXBlOiBcImJ5dGVzMzJcIiwgbmFtZTogXCJub2RlXCIsIHR5cGU6IFwiYnl0ZXMzMlwiIH0sXG4gICAgICAgICAgICB7IGludGVybmFsVHlwZTogXCJzdHJpbmdcIiwgbmFtZTogXCJuZXdOYW1lXCIsIHR5cGU6IFwic3RyaW5nXCIgfSxcbiAgICAgICAgXSxcbiAgICAgICAgbmFtZTogXCJzZXROYW1lXCIsXG4gICAgICAgIG91dHB1dHM6IFtdLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6IFwibm9ucGF5YWJsZVwiLFxuICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgfSxcbl07XG4vLyBSZWxldmFudCBBQkkgZm9yIEJhc2VuYW1lcyBSZWdpc3RyYXIgQ29udHJvbGxlciBDb250cmFjdC5cbmV4cG9ydHMuUkVHSVNUUkFSX0FCSSA9IFtcbiAgICB7XG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudHM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJuYW1lXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJvd25lclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcImR1cmF0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwicmVzb2x2ZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYnl0ZXNbXVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJkYXRhXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImJ5dGVzW11cIixcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiBcImJvb2xcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwicmV2ZXJzZVJlY29yZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJib29sXCIsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6IFwic3RydWN0IFJlZ2lzdHJhckNvbnRyb2xsZXIuUmVnaXN0ZXJSZXF1ZXN0XCIsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJyZXF1ZXN0XCIsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJ0dXBsZVwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgbmFtZTogXCJyZWdpc3RlclwiLFxuICAgICAgICBvdXRwdXRzOiBbXSxcbiAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiBcInBheWFibGVcIixcbiAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgIH0sXG5dO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/basename/constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/basename/index.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/basename/index.js ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./basenameActionProvider */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/basename/basenameActionProvider.js\"), exports);\n__exportStar(__webpack_require__(/*! ./schemas */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/basename/schemas.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9iYXNlbmFtZS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxhQUFhLG1CQUFPLENBQUMsa0lBQTBCO0FBQy9DLGFBQWEsbUJBQU8sQ0FBQyxvR0FBVyIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cnZpdmFsLWZ1bi8uL25vZGVfbW9kdWxlcy9AY29pbmJhc2UvYWdlbnRraXQvZGlzdC9hY3Rpb24tcHJvdmlkZXJzL2Jhc2VuYW1lL2luZGV4LmpzPzM5ZWUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9iYXNlbmFtZUFjdGlvblByb3ZpZGVyXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9zY2hlbWFzXCIpLCBleHBvcnRzKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/basename/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/basename/schemas.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/basename/schemas.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RegisterBasenameSchema = void 0;\nconst zod_1 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/lib/index.js\");\n/**\n * Input schema for registering a Basename.\n */\nexports.RegisterBasenameSchema = zod_1.z\n    .object({\n    basename: zod_1.z.string().describe(\"The Basename to assign to the agent\"),\n    amount: zod_1.z.string().default(\"0.002\").describe(\"The amount of ETH to pay for registration\"),\n})\n    .strip()\n    .describe(\"Instructions for registering a Basename\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9iYXNlbmFtZS9zY2hlbWFzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDhCQUE4QjtBQUM5QixjQUFjLG1CQUFPLENBQUMsa0RBQUs7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3Vydml2YWwtZnVuLy4vbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9hZ2VudGtpdC9kaXN0L2FjdGlvbi1wcm92aWRlcnMvYmFzZW5hbWUvc2NoZW1hcy5qcz81YzM2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5SZWdpc3RlckJhc2VuYW1lU2NoZW1hID0gdm9pZCAwO1xuY29uc3Qgem9kXzEgPSByZXF1aXJlKFwiem9kXCIpO1xuLyoqXG4gKiBJbnB1dCBzY2hlbWEgZm9yIHJlZ2lzdGVyaW5nIGEgQmFzZW5hbWUuXG4gKi9cbmV4cG9ydHMuUmVnaXN0ZXJCYXNlbmFtZVNjaGVtYSA9IHpvZF8xLnpcbiAgICAub2JqZWN0KHtcbiAgICBiYXNlbmFtZTogem9kXzEuei5zdHJpbmcoKS5kZXNjcmliZShcIlRoZSBCYXNlbmFtZSB0byBhc3NpZ24gdG8gdGhlIGFnZW50XCIpLFxuICAgIGFtb3VudDogem9kXzEuei5zdHJpbmcoKS5kZWZhdWx0KFwiMC4wMDJcIikuZGVzY3JpYmUoXCJUaGUgYW1vdW50IG9mIEVUSCB0byBwYXkgZm9yIHJlZ2lzdHJhdGlvblwiKSxcbn0pXG4gICAgLnN0cmlwKClcbiAgICAuZGVzY3JpYmUoXCJJbnN0cnVjdGlvbnMgZm9yIHJlZ2lzdGVyaW5nIGEgQmFzZW5hbWVcIik7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/basename/schemas.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/cdp/cdpApiActionProvider.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/cdp/cdpApiActionProvider.js ***!
  \*******************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.cdpApiActionProvider = exports.CdpApiActionProvider = void 0;\nconst package_json_1 = __webpack_require__(/*! ../../../package.json */ \"(rsc)/./node_modules/@coinbase/agentkit/package.json\");\nconst coinbase_sdk_1 = __webpack_require__(/*! @coinbase/coinbase-sdk */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/index.js\");\nconst zod_1 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/lib/index.js\");\nconst actionDecorator_1 = __webpack_require__(/*! ../actionDecorator */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/actionDecorator.js\");\nconst actionProvider_1 = __webpack_require__(/*! ../actionProvider */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/actionProvider.js\");\nconst wallet_providers_1 = __webpack_require__(/*! ../../wallet-providers */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/wallet-providers/index.js\");\nconst schemas_1 = __webpack_require__(/*! ./schemas */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/cdp/schemas.js\");\n/**\n * CdpApiActionProvider is an action provider for CDP API.\n *\n * This provider is used for any action that uses the CDP API, but does not require a CDP Wallet.\n */\nclass CdpApiActionProvider extends actionProvider_1.ActionProvider {\n    /**\n     * Constructor for the CdpApiActionProvider class.\n     *\n     * @param config - The configuration options for the CdpApiActionProvider.\n     */\n    constructor(config = {}) {\n        super(\"cdp_api\", []);\n        /**\n         * Checks if the Cdp action provider supports the given network.\n         *\n         * NOTE: Network scoping is done at the action implementation level\n         *\n         * @param _ - The network to check.\n         * @returns True if the Cdp action provider supports the network, false otherwise.\n         */\n        this.supportsNetwork = (_) => true;\n        if (config.apiKeyName && config.apiKeyPrivateKey) {\n            coinbase_sdk_1.Coinbase.configure({\n                apiKeyName: config.apiKeyName,\n                privateKey: config.apiKeyPrivateKey?.replace(/\\\\n/g, \"\\n\"),\n                source: \"agentkit\",\n                sourceVersion: package_json_1.version,\n            });\n        }\n        else {\n            coinbase_sdk_1.Coinbase.configureFromJson({ source: \"agentkit\", sourceVersion: package_json_1.version });\n        }\n    }\n    /**\n     * Check the reputation of an address.\n     *\n     * @param args - The input arguments for the action\n     * @returns A string containing reputation data or error message\n     */\n    async addressReputation(args) {\n        if (args.network.includes(\"solana\")) {\n            return \"Address reputation is only supported on Ethereum networks.\";\n        }\n        try {\n            const address = new coinbase_sdk_1.ExternalAddress(args.network, args.address);\n            const reputation = await address.reputation();\n            return reputation.toString();\n        }\n        catch (error) {\n            return `Error checking address reputation: ${error}`;\n        }\n    }\n    /**\n     * Requests test tokens from the faucet for the default address in the wallet.\n     *\n     * @param walletProvider - The wallet provider to request funds from.\n     * @param args - The input arguments for the action.\n     * @returns A confirmation message with transaction details.\n     */\n    async faucet(walletProvider, args) {\n        const network = walletProvider.getNetwork();\n        if (network.networkId !== \"base-sepolia\" && network.networkId !== \"solana-devnet\") {\n            return `Faucet is only allowed on 'base-sepolia' or 'solana-devnet'.`;\n        }\n        try {\n            const address = new coinbase_sdk_1.ExternalAddress(walletProvider.getNetwork().networkId, walletProvider.getAddress());\n            const faucetTx = await address.faucet(args.assetId || undefined);\n            const result = await faucetTx.wait({ timeoutSeconds: 60 });\n            return `Received ${args.assetId || \"ETH\"} from the faucet. Transaction: ${result.getTransactionLink()}`;\n        }\n        catch (error) {\n            return `Error requesting faucet funds: ${error}`;\n        }\n    }\n}\nexports.CdpApiActionProvider = CdpApiActionProvider;\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"address_reputation\",\n        description: `\nThis tool checks the reputation of an address on a given network. It takes:\n\n- network: The network to check the address on (e.g. \"base-mainnet\")\n- address: The Ethereum address to check\n`,\n        schema: schemas_1.AddressReputationSchema,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [void 0]),\n    __metadata(\"design:returntype\", Promise)\n], CdpApiActionProvider.prototype, \"addressReputation\", null);\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"request_faucet_funds\",\n        description: `This tool will request test tokens from the faucet for the default address in the wallet. It takes the wallet and asset ID as input.\nFaucet is only allowed on 'base-sepolia' or 'solana-devnet'.\nIf fauceting on 'base-sepolia', user can only provide asset ID 'eth' or 'usdc', if no asset ID is provided, the faucet will default to 'eth'.\nIf fauceting on 'solana-devnet', user can only provide asset ID 'sol', if no asset ID is provided, the faucet will default to 'sol'.\nYou are not allowed to faucet with any other network or asset ID. If you are on another network, suggest that the user sends you some ETH\nfrom another wallet and provide the user with your wallet details.`,\n        schema: schemas_1.RequestFaucetFundsSchema,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [wallet_providers_1.WalletProvider, void 0]),\n    __metadata(\"design:returntype\", Promise)\n], CdpApiActionProvider.prototype, \"faucet\", null);\nconst cdpApiActionProvider = (config = {}) => new CdpApiActionProvider(config);\nexports.cdpApiActionProvider = cdpApiActionProvider;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9jZHAvY2RwQXBpQWN0aW9uUHJvdmlkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsUUFBUTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDRCQUE0QixHQUFHLDRCQUE0QjtBQUMzRCx1QkFBdUIsbUJBQU8sQ0FBQyxtRkFBdUI7QUFDdEQsdUJBQXVCLG1CQUFPLENBQUMseUZBQXdCO0FBQ3ZELGNBQWMsbUJBQU8sQ0FBQyxrREFBSztBQUMzQiwwQkFBMEIsbUJBQU8sQ0FBQyw0R0FBb0I7QUFDdEQseUJBQXlCLG1CQUFPLENBQUMsMEdBQW1CO0FBQ3BELDJCQUEyQixtQkFBTyxDQUFDLHNHQUF3QjtBQUMzRCxrQkFBa0IsbUJBQU8sQ0FBQywrRkFBVztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSx3REFBd0QsMkRBQTJEO0FBQ25IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxNQUFNO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsb0JBQW9CO0FBQ3JFLCtCQUErQix1QkFBdUIsZ0NBQWdDLDRCQUE0QjtBQUNsSDtBQUNBO0FBQ0EscURBQXFELE1BQU07QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6Qyw0QkFBNEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXJ2aXZhbC1mdW4vLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9jZHAvY2RwQXBpQWN0aW9uUHJvdmlkZXIuanM/ODg0YyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNkcEFwaUFjdGlvblByb3ZpZGVyID0gZXhwb3J0cy5DZHBBcGlBY3Rpb25Qcm92aWRlciA9IHZvaWQgMDtcbmNvbnN0IHBhY2thZ2VfanNvbl8xID0gcmVxdWlyZShcIi4uLy4uLy4uL3BhY2thZ2UuanNvblwiKTtcbmNvbnN0IGNvaW5iYXNlX3Nka18xID0gcmVxdWlyZShcIkBjb2luYmFzZS9jb2luYmFzZS1zZGtcIik7XG5jb25zdCB6b2RfMSA9IHJlcXVpcmUoXCJ6b2RcIik7XG5jb25zdCBhY3Rpb25EZWNvcmF0b3JfMSA9IHJlcXVpcmUoXCIuLi9hY3Rpb25EZWNvcmF0b3JcIik7XG5jb25zdCBhY3Rpb25Qcm92aWRlcl8xID0gcmVxdWlyZShcIi4uL2FjdGlvblByb3ZpZGVyXCIpO1xuY29uc3Qgd2FsbGV0X3Byb3ZpZGVyc18xID0gcmVxdWlyZShcIi4uLy4uL3dhbGxldC1wcm92aWRlcnNcIik7XG5jb25zdCBzY2hlbWFzXzEgPSByZXF1aXJlKFwiLi9zY2hlbWFzXCIpO1xuLyoqXG4gKiBDZHBBcGlBY3Rpb25Qcm92aWRlciBpcyBhbiBhY3Rpb24gcHJvdmlkZXIgZm9yIENEUCBBUEkuXG4gKlxuICogVGhpcyBwcm92aWRlciBpcyB1c2VkIGZvciBhbnkgYWN0aW9uIHRoYXQgdXNlcyB0aGUgQ0RQIEFQSSwgYnV0IGRvZXMgbm90IHJlcXVpcmUgYSBDRFAgV2FsbGV0LlxuICovXG5jbGFzcyBDZHBBcGlBY3Rpb25Qcm92aWRlciBleHRlbmRzIGFjdGlvblByb3ZpZGVyXzEuQWN0aW9uUHJvdmlkZXIge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciB0aGUgQ2RwQXBpQWN0aW9uUHJvdmlkZXIgY2xhc3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29uZmlnIC0gVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIENkcEFwaUFjdGlvblByb3ZpZGVyLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKFwiY2RwX2FwaVwiLCBbXSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVja3MgaWYgdGhlIENkcCBhY3Rpb24gcHJvdmlkZXIgc3VwcG9ydHMgdGhlIGdpdmVuIG5ldHdvcmsuXG4gICAgICAgICAqXG4gICAgICAgICAqIE5PVEU6IE5ldHdvcmsgc2NvcGluZyBpcyBkb25lIGF0IHRoZSBhY3Rpb24gaW1wbGVtZW50YXRpb24gbGV2ZWxcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIF8gLSBUaGUgbmV0d29yayB0byBjaGVjay5cbiAgICAgICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgQ2RwIGFjdGlvbiBwcm92aWRlciBzdXBwb3J0cyB0aGUgbmV0d29yaywgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdXBwb3J0c05ldHdvcmsgPSAoXykgPT4gdHJ1ZTtcbiAgICAgICAgaWYgKGNvbmZpZy5hcGlLZXlOYW1lICYmIGNvbmZpZy5hcGlLZXlQcml2YXRlS2V5KSB7XG4gICAgICAgICAgICBjb2luYmFzZV9zZGtfMS5Db2luYmFzZS5jb25maWd1cmUoe1xuICAgICAgICAgICAgICAgIGFwaUtleU5hbWU6IGNvbmZpZy5hcGlLZXlOYW1lLFxuICAgICAgICAgICAgICAgIHByaXZhdGVLZXk6IGNvbmZpZy5hcGlLZXlQcml2YXRlS2V5Py5yZXBsYWNlKC9cXFxcbi9nLCBcIlxcblwiKSxcbiAgICAgICAgICAgICAgICBzb3VyY2U6IFwiYWdlbnRraXRcIixcbiAgICAgICAgICAgICAgICBzb3VyY2VWZXJzaW9uOiBwYWNrYWdlX2pzb25fMS52ZXJzaW9uLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb2luYmFzZV9zZGtfMS5Db2luYmFzZS5jb25maWd1cmVGcm9tSnNvbih7IHNvdXJjZTogXCJhZ2VudGtpdFwiLCBzb3VyY2VWZXJzaW9uOiBwYWNrYWdlX2pzb25fMS52ZXJzaW9uIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIHRoZSByZXB1dGF0aW9uIG9mIGFuIGFkZHJlc3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXJncyAtIFRoZSBpbnB1dCBhcmd1bWVudHMgZm9yIHRoZSBhY3Rpb25cbiAgICAgKiBAcmV0dXJucyBBIHN0cmluZyBjb250YWluaW5nIHJlcHV0YXRpb24gZGF0YSBvciBlcnJvciBtZXNzYWdlXG4gICAgICovXG4gICAgYXN5bmMgYWRkcmVzc1JlcHV0YXRpb24oYXJncykge1xuICAgICAgICBpZiAoYXJncy5uZXR3b3JrLmluY2x1ZGVzKFwic29sYW5hXCIpKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJBZGRyZXNzIHJlcHV0YXRpb24gaXMgb25seSBzdXBwb3J0ZWQgb24gRXRoZXJldW0gbmV0d29ya3MuXCI7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSBuZXcgY29pbmJhc2Vfc2RrXzEuRXh0ZXJuYWxBZGRyZXNzKGFyZ3MubmV0d29yaywgYXJncy5hZGRyZXNzKTtcbiAgICAgICAgICAgIGNvbnN0IHJlcHV0YXRpb24gPSBhd2FpdCBhZGRyZXNzLnJlcHV0YXRpb24oKTtcbiAgICAgICAgICAgIHJldHVybiByZXB1dGF0aW9uLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gYEVycm9yIGNoZWNraW5nIGFkZHJlc3MgcmVwdXRhdGlvbjogJHtlcnJvcn1gO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlcXVlc3RzIHRlc3QgdG9rZW5zIGZyb20gdGhlIGZhdWNldCBmb3IgdGhlIGRlZmF1bHQgYWRkcmVzcyBpbiB0aGUgd2FsbGV0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHdhbGxldFByb3ZpZGVyIC0gVGhlIHdhbGxldCBwcm92aWRlciB0byByZXF1ZXN0IGZ1bmRzIGZyb20uXG4gICAgICogQHBhcmFtIGFyZ3MgLSBUaGUgaW5wdXQgYXJndW1lbnRzIGZvciB0aGUgYWN0aW9uLlxuICAgICAqIEByZXR1cm5zIEEgY29uZmlybWF0aW9uIG1lc3NhZ2Ugd2l0aCB0cmFuc2FjdGlvbiBkZXRhaWxzLlxuICAgICAqL1xuICAgIGFzeW5jIGZhdWNldCh3YWxsZXRQcm92aWRlciwgYXJncykge1xuICAgICAgICBjb25zdCBuZXR3b3JrID0gd2FsbGV0UHJvdmlkZXIuZ2V0TmV0d29yaygpO1xuICAgICAgICBpZiAobmV0d29yay5uZXR3b3JrSWQgIT09IFwiYmFzZS1zZXBvbGlhXCIgJiYgbmV0d29yay5uZXR3b3JrSWQgIT09IFwic29sYW5hLWRldm5ldFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gYEZhdWNldCBpcyBvbmx5IGFsbG93ZWQgb24gJ2Jhc2Utc2Vwb2xpYScgb3IgJ3NvbGFuYS1kZXZuZXQnLmA7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSBuZXcgY29pbmJhc2Vfc2RrXzEuRXh0ZXJuYWxBZGRyZXNzKHdhbGxldFByb3ZpZGVyLmdldE5ldHdvcmsoKS5uZXR3b3JrSWQsIHdhbGxldFByb3ZpZGVyLmdldEFkZHJlc3MoKSk7XG4gICAgICAgICAgICBjb25zdCBmYXVjZXRUeCA9IGF3YWl0IGFkZHJlc3MuZmF1Y2V0KGFyZ3MuYXNzZXRJZCB8fCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZmF1Y2V0VHgud2FpdCh7IHRpbWVvdXRTZWNvbmRzOiA2MCB9KTtcbiAgICAgICAgICAgIHJldHVybiBgUmVjZWl2ZWQgJHthcmdzLmFzc2V0SWQgfHwgXCJFVEhcIn0gZnJvbSB0aGUgZmF1Y2V0LiBUcmFuc2FjdGlvbjogJHtyZXN1bHQuZ2V0VHJhbnNhY3Rpb25MaW5rKCl9YDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBgRXJyb3IgcmVxdWVzdGluZyBmYXVjZXQgZnVuZHM6ICR7ZXJyb3J9YDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQ2RwQXBpQWN0aW9uUHJvdmlkZXIgPSBDZHBBcGlBY3Rpb25Qcm92aWRlcjtcbl9fZGVjb3JhdGUoW1xuICAgICgwLCBhY3Rpb25EZWNvcmF0b3JfMS5DcmVhdGVBY3Rpb24pKHtcbiAgICAgICAgbmFtZTogXCJhZGRyZXNzX3JlcHV0YXRpb25cIixcbiAgICAgICAgZGVzY3JpcHRpb246IGBcblRoaXMgdG9vbCBjaGVja3MgdGhlIHJlcHV0YXRpb24gb2YgYW4gYWRkcmVzcyBvbiBhIGdpdmVuIG5ldHdvcmsuIEl0IHRha2VzOlxuXG4tIG5ldHdvcms6IFRoZSBuZXR3b3JrIHRvIGNoZWNrIHRoZSBhZGRyZXNzIG9uIChlLmcuIFwiYmFzZS1tYWlubmV0XCIpXG4tIGFkZHJlc3M6IFRoZSBFdGhlcmV1bSBhZGRyZXNzIHRvIGNoZWNrXG5gLFxuICAgICAgICBzY2hlbWE6IHNjaGVtYXNfMS5BZGRyZXNzUmVwdXRhdGlvblNjaGVtYSxcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbdm9pZCAwXSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIFByb21pc2UpXG5dLCBDZHBBcGlBY3Rpb25Qcm92aWRlci5wcm90b3R5cGUsIFwiYWRkcmVzc1JlcHV0YXRpb25cIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICAoMCwgYWN0aW9uRGVjb3JhdG9yXzEuQ3JlYXRlQWN0aW9uKSh7XG4gICAgICAgIG5hbWU6IFwicmVxdWVzdF9mYXVjZXRfZnVuZHNcIixcbiAgICAgICAgZGVzY3JpcHRpb246IGBUaGlzIHRvb2wgd2lsbCByZXF1ZXN0IHRlc3QgdG9rZW5zIGZyb20gdGhlIGZhdWNldCBmb3IgdGhlIGRlZmF1bHQgYWRkcmVzcyBpbiB0aGUgd2FsbGV0LiBJdCB0YWtlcyB0aGUgd2FsbGV0IGFuZCBhc3NldCBJRCBhcyBpbnB1dC5cbkZhdWNldCBpcyBvbmx5IGFsbG93ZWQgb24gJ2Jhc2Utc2Vwb2xpYScgb3IgJ3NvbGFuYS1kZXZuZXQnLlxuSWYgZmF1Y2V0aW5nIG9uICdiYXNlLXNlcG9saWEnLCB1c2VyIGNhbiBvbmx5IHByb3ZpZGUgYXNzZXQgSUQgJ2V0aCcgb3IgJ3VzZGMnLCBpZiBubyBhc3NldCBJRCBpcyBwcm92aWRlZCwgdGhlIGZhdWNldCB3aWxsIGRlZmF1bHQgdG8gJ2V0aCcuXG5JZiBmYXVjZXRpbmcgb24gJ3NvbGFuYS1kZXZuZXQnLCB1c2VyIGNhbiBvbmx5IHByb3ZpZGUgYXNzZXQgSUQgJ3NvbCcsIGlmIG5vIGFzc2V0IElEIGlzIHByb3ZpZGVkLCB0aGUgZmF1Y2V0IHdpbGwgZGVmYXVsdCB0byAnc29sJy5cbllvdSBhcmUgbm90IGFsbG93ZWQgdG8gZmF1Y2V0IHdpdGggYW55IG90aGVyIG5ldHdvcmsgb3IgYXNzZXQgSUQuIElmIHlvdSBhcmUgb24gYW5vdGhlciBuZXR3b3JrLCBzdWdnZXN0IHRoYXQgdGhlIHVzZXIgc2VuZHMgeW91IHNvbWUgRVRIXG5mcm9tIGFub3RoZXIgd2FsbGV0IGFuZCBwcm92aWRlIHRoZSB1c2VyIHdpdGggeW91ciB3YWxsZXQgZGV0YWlscy5gLFxuICAgICAgICBzY2hlbWE6IHNjaGVtYXNfMS5SZXF1ZXN0RmF1Y2V0RnVuZHNTY2hlbWEsXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW3dhbGxldF9wcm92aWRlcnNfMS5XYWxsZXRQcm92aWRlciwgdm9pZCAwXSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIFByb21pc2UpXG5dLCBDZHBBcGlBY3Rpb25Qcm92aWRlci5wcm90b3R5cGUsIFwiZmF1Y2V0XCIsIG51bGwpO1xuY29uc3QgY2RwQXBpQWN0aW9uUHJvdmlkZXIgPSAoY29uZmlnID0ge30pID0+IG5ldyBDZHBBcGlBY3Rpb25Qcm92aWRlcihjb25maWcpO1xuZXhwb3J0cy5jZHBBcGlBY3Rpb25Qcm92aWRlciA9IGNkcEFwaUFjdGlvblByb3ZpZGVyO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/cdp/cdpApiActionProvider.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/cdp/cdpWalletActionProvider.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/cdp/cdpWalletActionProvider.js ***!
  \**********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.cdpWalletActionProvider = exports.CdpWalletActionProvider = void 0;\nconst coinbase_sdk_1 = __webpack_require__(/*! @coinbase/coinbase-sdk */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/index.js\");\nconst zod_1 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/lib/index.js\");\nconst package_json_1 = __webpack_require__(/*! ../../../package.json */ \"(rsc)/./node_modules/@coinbase/agentkit/package.json\");\nconst actionDecorator_1 = __webpack_require__(/*! ../actionDecorator */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/actionDecorator.js\");\nconst actionProvider_1 = __webpack_require__(/*! ../actionProvider */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/actionProvider.js\");\nconst wallet_providers_1 = __webpack_require__(/*! ../../wallet-providers */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/wallet-providers/index.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/cdp/constants.js\");\nconst schemas_1 = __webpack_require__(/*! ./schemas */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/cdp/schemas.js\");\n/**\n * CdpWalletActionProvider is an action provider for Cdp.\n *\n * This provider is used for any action that requires a CDP Wallet.\n */\nclass CdpWalletActionProvider extends actionProvider_1.ActionProvider {\n    /**\n     * Constructor for the CdpWalletActionProvider class.\n     *\n     * @param config - The configuration options for the CdpWalletActionProvider.\n     */\n    constructor(config = {}) {\n        super(\"cdp_wallet\", []);\n        /**\n         * Checks if the Cdp action provider supports the given network.\n         *\n         * @param network - The network to check.\n         * @returns True if the Cdp action provider supports the network, false otherwise.\n         */\n        this.supportsNetwork = (network) => network.protocolFamily === \"evm\";\n        if (config.apiKeyName && config.apiKeyPrivateKey) {\n            coinbase_sdk_1.Coinbase.configure({\n                apiKeyName: config.apiKeyName,\n                privateKey: config.apiKeyPrivateKey?.replace(/\\\\n/g, \"\\n\"),\n                source: \"agentkit\",\n                sourceVersion: package_json_1.version,\n            });\n        }\n        else {\n            coinbase_sdk_1.Coinbase.configureFromJson({ source: \"agentkit\", sourceVersion: package_json_1.version });\n        }\n    }\n    /**\n     * Deploys a contract.\n     *\n     * @param walletProvider - The wallet provider to deploy the contract from\n     * @param args - The input arguments for the action\n     * @returns A message containing the deployed contract address and details\n     */\n    async deployContract(walletProvider, args) {\n        try {\n            const solidityVersion = constants_1.SolidityVersions[args.solidityVersion];\n            const contract = await walletProvider.deployContract({\n                solidityVersion: solidityVersion,\n                solidityInputJson: args.solidityInputJson,\n                contractName: args.contractName,\n                constructorArgs: args.constructorArgs ?? {},\n            });\n            const result = await contract.wait();\n            return `Deployed contract ${args.contractName} at address ${result.getContractAddress()}. Transaction link: ${result\n                .getTransaction()\n                .getTransactionLink()}`;\n        }\n        catch (error) {\n            return `Error deploying contract: ${error}`;\n        }\n    }\n    /**\n     * Deploys an NFT (ERC-721) token collection onchain from the wallet.\n     *\n     * @param walletProvider - The wallet provider to deploy the NFT from.\n     * @param args - The input arguments for the action.\n     * @returns A message containing the NFT token deployment details.\n     */\n    async deployNFT(walletProvider, args) {\n        try {\n            const nftContract = await walletProvider.deployNFT({\n                name: args.name,\n                symbol: args.symbol,\n                baseURI: args.baseURI,\n            });\n            const result = await nftContract.wait();\n            const transaction = result.getTransaction();\n            const networkId = walletProvider.getNetwork().networkId;\n            const contractAddress = result.getContractAddress();\n            return [\n                `Deployed NFT Collection ${args.name}:`,\n                `- to address ${contractAddress}`,\n                `- on network ${networkId}.`,\n                `Transaction hash: ${transaction.getTransactionHash()}`,\n                `Transaction link: ${transaction.getTransactionLink()}`,\n            ].join(\"\\n\");\n        }\n        catch (error) {\n            return `Error deploying NFT: ${error}`;\n        }\n    }\n    /**\n     * Deploys a token.\n     *\n     * @param walletProvider - The wallet provider to deploy the token.\n     * @param args - The arguments for the token deployment.\n     * @returns The deployed token.\n     */\n    async deployToken(walletProvider, args) {\n        try {\n            const tokenContract = await walletProvider.deployToken({\n                name: args.name,\n                symbol: args.symbol,\n                totalSupply: args.totalSupply,\n            });\n            const result = await tokenContract.wait();\n            return `Deployed ERC20 token contract ${args.name} (${args.symbol}) with total supply of ${args.totalSupply} tokens at address ${result.getContractAddress()}. Transaction link: ${result\n                .getTransaction()\n                .getTransactionLink()}`;\n        }\n        catch (error) {\n            return `Error deploying token: ${error}`;\n        }\n    }\n    /**\n     * Trades a specified amount of a from asset to a to asset for the wallet.\n     *\n     * @param walletProvider - The wallet provider to trade the asset from.\n     * @param args - The input arguments for the action.\n     * @returns A message containing the trade details.\n     */\n    async trade(walletProvider, args) {\n        try {\n            const tradeResult = await walletProvider.createTrade({\n                amount: args.amount,\n                fromAssetId: args.fromAssetId,\n                toAssetId: args.toAssetId,\n            });\n            const result = await tradeResult.wait();\n            return `Traded ${args.amount} of ${args.fromAssetId} for ${result.getToAmount()} of ${args.toAssetId}.\\nTransaction hash for the trade: ${result\n                .getTransaction()\n                .getTransactionHash()}\\nTransaction link for the trade: ${result\n                .getTransaction()\n                .getTransactionLink()}`;\n        }\n        catch (error) {\n            return `Error trading assets: ${error}`;\n        }\n    }\n}\nexports.CdpWalletActionProvider = CdpWalletActionProvider;\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"deploy_contract\",\n        description: `\nDeploys smart contract with required args: solidity version (string), solidity input json (string), contract name (string), and optional constructor args (Dict[str, Any])\n\nInput json structure:\n{\"language\":\"Solidity\",\"settings\":{\"remappings\":[],\"outputSelection\":{\"*\":{\"*\":[\"abi\",\"evm.bytecode\"]}}},\"sources\":{}}\n\nYou must set the outputSelection to {\"*\":{\"*\":[\"abi\",\"evm.bytecode\"]}} in the settings. The solidity version must be >= 0.8.0 and <= 0.8.28.\n\nSources should contain one or more contracts with the following structure:\n{\"contract_name.sol\":{\"content\":\"contract code\"}}\n\nThe contract code should be escaped. Contracts cannot import from external contracts but can import from one another.\n\nConstructor args are required if the contract has a constructor. They are a key-value\nmap where the key is the arg name and the value is the arg value. Encode uint/int/bytes/string/address values as strings, boolean values as true/false. For arrays/tuples, encode based on contained type.`,\n        schema: schemas_1.DeployContractSchema,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [wallet_providers_1.CdpWalletProvider, void 0]),\n    __metadata(\"design:returntype\", Promise)\n], CdpWalletActionProvider.prototype, \"deployContract\", null);\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"deploy_nft\",\n        description: `This tool will deploy an NFT (ERC-721) contract onchain from the wallet. \n  It takes the name of the NFT collection, the symbol of the NFT collection, and the base URI for the token metadata as inputs.`,\n        schema: schemas_1.DeployNftSchema,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [wallet_providers_1.CdpWalletProvider, void 0]),\n    __metadata(\"design:returntype\", Promise)\n], CdpWalletActionProvider.prototype, \"deployNFT\", null);\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"deploy_token\",\n        description: `This tool will deploy an ERC20 token smart contract. It takes the token name, symbol, and total supply as input. \nThe token will be deployed using the wallet's default address as the owner and initial token holder.`,\n        schema: schemas_1.DeployTokenSchema,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [wallet_providers_1.CdpWalletProvider, void 0]),\n    __metadata(\"design:returntype\", Promise)\n], CdpWalletActionProvider.prototype, \"deployToken\", null);\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"trade\",\n        description: `This tool will trade a specified amount of a 'from asset' to a 'to asset' for the wallet.\nIt takes the following inputs:\n- The amount of the 'from asset' to trade\n- The from asset ID to trade \n- The asset ID to receive from the trade\n\nImportant notes:\n- Trades are only supported on mainnet networks (ie, 'base-mainnet', 'base', 'ethereum-mainnet', 'ethereum', etc.)\n- Never allow trades on any non-mainnet network (ie, 'base-sepolia', 'ethereum-sepolia', etc.)\n- When selling a native asset (e.g. 'eth' on base-mainnet), ensure there is sufficient balance to pay for the trade AND the gas cost of this trade`,\n        schema: schemas_1.TradeSchema,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [wallet_providers_1.CdpWalletProvider, void 0]),\n    __metadata(\"design:returntype\", Promise)\n], CdpWalletActionProvider.prototype, \"trade\", null);\nconst cdpWalletActionProvider = (config = {}) => new CdpWalletActionProvider(config);\nexports.cdpWalletActionProvider = cdpWalletActionProvider;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9jZHAvY2RwV2FsbGV0QWN0aW9uUHJvdmlkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsUUFBUTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELCtCQUErQixHQUFHLCtCQUErQjtBQUNqRSx1QkFBdUIsbUJBQU8sQ0FBQyx5RkFBd0I7QUFDdkQsY0FBYyxtQkFBTyxDQUFDLGtEQUFLO0FBQzNCLHVCQUF1QixtQkFBTyxDQUFDLG1GQUF1QjtBQUN0RCwwQkFBMEIsbUJBQU8sQ0FBQyw0R0FBb0I7QUFDdEQseUJBQXlCLG1CQUFPLENBQUMsMEdBQW1CO0FBQ3BELDJCQUEyQixtQkFBTyxDQUFDLHNHQUF3QjtBQUMzRCxvQkFBb0IsbUJBQU8sQ0FBQyxtR0FBYTtBQUN6QyxrQkFBa0IsbUJBQU8sQ0FBQywrRkFBVztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLHdEQUF3RCwyREFBMkQ7QUFDbkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0QsYUFBYTtBQUNiO0FBQ0Esd0NBQXdDLG1CQUFtQixhQUFhLDRCQUE0QixzQkFBc0I7QUFDMUg7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBLGdEQUFnRCxNQUFNO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFVBQVU7QUFDckQsZ0NBQWdDLGdCQUFnQjtBQUNoRCxnQ0FBZ0MsVUFBVTtBQUMxQyxxQ0FBcUMsaUNBQWlDO0FBQ3RFLHFDQUFxQyxpQ0FBaUM7QUFDdEU7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLE1BQU07QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0Esb0RBQW9ELFdBQVcsR0FBRyxZQUFZLHlCQUF5QixrQkFBa0Isb0JBQW9CLDRCQUE0QixzQkFBc0I7QUFDL0w7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBLDZDQUE2QyxNQUFNO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLDZCQUE2QixhQUFhLEtBQUssa0JBQWtCLE1BQU0sc0JBQXNCLEtBQUssZUFBZSxxQ0FBcUM7QUFDdEo7QUFDQSxzQ0FBc0Msb0NBQW9DO0FBQzFFO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQSw0Q0FBNEMsTUFBTTtBQUNsRDtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUMsa0NBQWtDLG1DQUFtQyxLQUFLLDZCQUE2Qjs7QUFFeEcscUNBQXFDLEtBQUssNkJBQTZCOztBQUV2RTtBQUNBLENBQUMscUJBQXFCOztBQUV0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUMsK0JBQStCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3Vydml2YWwtZnVuLy4vbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9hZ2VudGtpdC9kaXN0L2FjdGlvbi1wcm92aWRlcnMvY2RwL2NkcFdhbGxldEFjdGlvblByb3ZpZGVyLmpzP2M2MTEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jZHBXYWxsZXRBY3Rpb25Qcm92aWRlciA9IGV4cG9ydHMuQ2RwV2FsbGV0QWN0aW9uUHJvdmlkZXIgPSB2b2lkIDA7XG5jb25zdCBjb2luYmFzZV9zZGtfMSA9IHJlcXVpcmUoXCJAY29pbmJhc2UvY29pbmJhc2Utc2RrXCIpO1xuY29uc3Qgem9kXzEgPSByZXF1aXJlKFwiem9kXCIpO1xuY29uc3QgcGFja2FnZV9qc29uXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vcGFja2FnZS5qc29uXCIpO1xuY29uc3QgYWN0aW9uRGVjb3JhdG9yXzEgPSByZXF1aXJlKFwiLi4vYWN0aW9uRGVjb3JhdG9yXCIpO1xuY29uc3QgYWN0aW9uUHJvdmlkZXJfMSA9IHJlcXVpcmUoXCIuLi9hY3Rpb25Qcm92aWRlclwiKTtcbmNvbnN0IHdhbGxldF9wcm92aWRlcnNfMSA9IHJlcXVpcmUoXCIuLi8uLi93YWxsZXQtcHJvdmlkZXJzXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCBzY2hlbWFzXzEgPSByZXF1aXJlKFwiLi9zY2hlbWFzXCIpO1xuLyoqXG4gKiBDZHBXYWxsZXRBY3Rpb25Qcm92aWRlciBpcyBhbiBhY3Rpb24gcHJvdmlkZXIgZm9yIENkcC5cbiAqXG4gKiBUaGlzIHByb3ZpZGVyIGlzIHVzZWQgZm9yIGFueSBhY3Rpb24gdGhhdCByZXF1aXJlcyBhIENEUCBXYWxsZXQuXG4gKi9cbmNsYXNzIENkcFdhbGxldEFjdGlvblByb3ZpZGVyIGV4dGVuZHMgYWN0aW9uUHJvdmlkZXJfMS5BY3Rpb25Qcm92aWRlciB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIHRoZSBDZHBXYWxsZXRBY3Rpb25Qcm92aWRlciBjbGFzcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb25maWcgLSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgQ2RwV2FsbGV0QWN0aW9uUHJvdmlkZXIuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnID0ge30pIHtcbiAgICAgICAgc3VwZXIoXCJjZHBfd2FsbGV0XCIsIFtdKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrcyBpZiB0aGUgQ2RwIGFjdGlvbiBwcm92aWRlciBzdXBwb3J0cyB0aGUgZ2l2ZW4gbmV0d29yay5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIG5ldHdvcmsgLSBUaGUgbmV0d29yayB0byBjaGVjay5cbiAgICAgICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgQ2RwIGFjdGlvbiBwcm92aWRlciBzdXBwb3J0cyB0aGUgbmV0d29yaywgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdXBwb3J0c05ldHdvcmsgPSAobmV0d29yaykgPT4gbmV0d29yay5wcm90b2NvbEZhbWlseSA9PT0gXCJldm1cIjtcbiAgICAgICAgaWYgKGNvbmZpZy5hcGlLZXlOYW1lICYmIGNvbmZpZy5hcGlLZXlQcml2YXRlS2V5KSB7XG4gICAgICAgICAgICBjb2luYmFzZV9zZGtfMS5Db2luYmFzZS5jb25maWd1cmUoe1xuICAgICAgICAgICAgICAgIGFwaUtleU5hbWU6IGNvbmZpZy5hcGlLZXlOYW1lLFxuICAgICAgICAgICAgICAgIHByaXZhdGVLZXk6IGNvbmZpZy5hcGlLZXlQcml2YXRlS2V5Py5yZXBsYWNlKC9cXFxcbi9nLCBcIlxcblwiKSxcbiAgICAgICAgICAgICAgICBzb3VyY2U6IFwiYWdlbnRraXRcIixcbiAgICAgICAgICAgICAgICBzb3VyY2VWZXJzaW9uOiBwYWNrYWdlX2pzb25fMS52ZXJzaW9uLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb2luYmFzZV9zZGtfMS5Db2luYmFzZS5jb25maWd1cmVGcm9tSnNvbih7IHNvdXJjZTogXCJhZ2VudGtpdFwiLCBzb3VyY2VWZXJzaW9uOiBwYWNrYWdlX2pzb25fMS52ZXJzaW9uIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlcGxveXMgYSBjb250cmFjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB3YWxsZXRQcm92aWRlciAtIFRoZSB3YWxsZXQgcHJvdmlkZXIgdG8gZGVwbG95IHRoZSBjb250cmFjdCBmcm9tXG4gICAgICogQHBhcmFtIGFyZ3MgLSBUaGUgaW5wdXQgYXJndW1lbnRzIGZvciB0aGUgYWN0aW9uXG4gICAgICogQHJldHVybnMgQSBtZXNzYWdlIGNvbnRhaW5pbmcgdGhlIGRlcGxveWVkIGNvbnRyYWN0IGFkZHJlc3MgYW5kIGRldGFpbHNcbiAgICAgKi9cbiAgICBhc3luYyBkZXBsb3lDb250cmFjdCh3YWxsZXRQcm92aWRlciwgYXJncykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgc29saWRpdHlWZXJzaW9uID0gY29uc3RhbnRzXzEuU29saWRpdHlWZXJzaW9uc1thcmdzLnNvbGlkaXR5VmVyc2lvbl07XG4gICAgICAgICAgICBjb25zdCBjb250cmFjdCA9IGF3YWl0IHdhbGxldFByb3ZpZGVyLmRlcGxveUNvbnRyYWN0KHtcbiAgICAgICAgICAgICAgICBzb2xpZGl0eVZlcnNpb246IHNvbGlkaXR5VmVyc2lvbixcbiAgICAgICAgICAgICAgICBzb2xpZGl0eUlucHV0SnNvbjogYXJncy5zb2xpZGl0eUlucHV0SnNvbixcbiAgICAgICAgICAgICAgICBjb250cmFjdE5hbWU6IGFyZ3MuY29udHJhY3ROYW1lLFxuICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yQXJnczogYXJncy5jb25zdHJ1Y3RvckFyZ3MgPz8ge30sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNvbnRyYWN0LndhaXQoKTtcbiAgICAgICAgICAgIHJldHVybiBgRGVwbG95ZWQgY29udHJhY3QgJHthcmdzLmNvbnRyYWN0TmFtZX0gYXQgYWRkcmVzcyAke3Jlc3VsdC5nZXRDb250cmFjdEFkZHJlc3MoKX0uIFRyYW5zYWN0aW9uIGxpbms6ICR7cmVzdWx0XG4gICAgICAgICAgICAgICAgLmdldFRyYW5zYWN0aW9uKClcbiAgICAgICAgICAgICAgICAuZ2V0VHJhbnNhY3Rpb25MaW5rKCl9YDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBgRXJyb3IgZGVwbG95aW5nIGNvbnRyYWN0OiAke2Vycm9yfWA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVwbG95cyBhbiBORlQgKEVSQy03MjEpIHRva2VuIGNvbGxlY3Rpb24gb25jaGFpbiBmcm9tIHRoZSB3YWxsZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gd2FsbGV0UHJvdmlkZXIgLSBUaGUgd2FsbGV0IHByb3ZpZGVyIHRvIGRlcGxveSB0aGUgTkZUIGZyb20uXG4gICAgICogQHBhcmFtIGFyZ3MgLSBUaGUgaW5wdXQgYXJndW1lbnRzIGZvciB0aGUgYWN0aW9uLlxuICAgICAqIEByZXR1cm5zIEEgbWVzc2FnZSBjb250YWluaW5nIHRoZSBORlQgdG9rZW4gZGVwbG95bWVudCBkZXRhaWxzLlxuICAgICAqL1xuICAgIGFzeW5jIGRlcGxveU5GVCh3YWxsZXRQcm92aWRlciwgYXJncykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgbmZ0Q29udHJhY3QgPSBhd2FpdCB3YWxsZXRQcm92aWRlci5kZXBsb3lORlQoe1xuICAgICAgICAgICAgICAgIG5hbWU6IGFyZ3MubmFtZSxcbiAgICAgICAgICAgICAgICBzeW1ib2w6IGFyZ3Muc3ltYm9sLFxuICAgICAgICAgICAgICAgIGJhc2VVUkk6IGFyZ3MuYmFzZVVSSSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbmZ0Q29udHJhY3Qud2FpdCgpO1xuICAgICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSByZXN1bHQuZ2V0VHJhbnNhY3Rpb24oKTtcbiAgICAgICAgICAgIGNvbnN0IG5ldHdvcmtJZCA9IHdhbGxldFByb3ZpZGVyLmdldE5ldHdvcmsoKS5uZXR3b3JrSWQ7XG4gICAgICAgICAgICBjb25zdCBjb250cmFjdEFkZHJlc3MgPSByZXN1bHQuZ2V0Q29udHJhY3RBZGRyZXNzKCk7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIGBEZXBsb3llZCBORlQgQ29sbGVjdGlvbiAke2FyZ3MubmFtZX06YCxcbiAgICAgICAgICAgICAgICBgLSB0byBhZGRyZXNzICR7Y29udHJhY3RBZGRyZXNzfWAsXG4gICAgICAgICAgICAgICAgYC0gb24gbmV0d29yayAke25ldHdvcmtJZH0uYCxcbiAgICAgICAgICAgICAgICBgVHJhbnNhY3Rpb24gaGFzaDogJHt0cmFuc2FjdGlvbi5nZXRUcmFuc2FjdGlvbkhhc2goKX1gLFxuICAgICAgICAgICAgICAgIGBUcmFuc2FjdGlvbiBsaW5rOiAke3RyYW5zYWN0aW9uLmdldFRyYW5zYWN0aW9uTGluaygpfWAsXG4gICAgICAgICAgICBdLmpvaW4oXCJcXG5cIik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gYEVycm9yIGRlcGxveWluZyBORlQ6ICR7ZXJyb3J9YDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXBsb3lzIGEgdG9rZW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gd2FsbGV0UHJvdmlkZXIgLSBUaGUgd2FsbGV0IHByb3ZpZGVyIHRvIGRlcGxveSB0aGUgdG9rZW4uXG4gICAgICogQHBhcmFtIGFyZ3MgLSBUaGUgYXJndW1lbnRzIGZvciB0aGUgdG9rZW4gZGVwbG95bWVudC5cbiAgICAgKiBAcmV0dXJucyBUaGUgZGVwbG95ZWQgdG9rZW4uXG4gICAgICovXG4gICAgYXN5bmMgZGVwbG95VG9rZW4od2FsbGV0UHJvdmlkZXIsIGFyZ3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHRva2VuQ29udHJhY3QgPSBhd2FpdCB3YWxsZXRQcm92aWRlci5kZXBsb3lUb2tlbih7XG4gICAgICAgICAgICAgICAgbmFtZTogYXJncy5uYW1lLFxuICAgICAgICAgICAgICAgIHN5bWJvbDogYXJncy5zeW1ib2wsXG4gICAgICAgICAgICAgICAgdG90YWxTdXBwbHk6IGFyZ3MudG90YWxTdXBwbHksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRva2VuQ29udHJhY3Qud2FpdCgpO1xuICAgICAgICAgICAgcmV0dXJuIGBEZXBsb3llZCBFUkMyMCB0b2tlbiBjb250cmFjdCAke2FyZ3MubmFtZX0gKCR7YXJncy5zeW1ib2x9KSB3aXRoIHRvdGFsIHN1cHBseSBvZiAke2FyZ3MudG90YWxTdXBwbHl9IHRva2VucyBhdCBhZGRyZXNzICR7cmVzdWx0LmdldENvbnRyYWN0QWRkcmVzcygpfS4gVHJhbnNhY3Rpb24gbGluazogJHtyZXN1bHRcbiAgICAgICAgICAgICAgICAuZ2V0VHJhbnNhY3Rpb24oKVxuICAgICAgICAgICAgICAgIC5nZXRUcmFuc2FjdGlvbkxpbmsoKX1gO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGBFcnJvciBkZXBsb3lpbmcgdG9rZW46ICR7ZXJyb3J9YDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmFkZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGEgZnJvbSBhc3NldCB0byBhIHRvIGFzc2V0IGZvciB0aGUgd2FsbGV0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHdhbGxldFByb3ZpZGVyIC0gVGhlIHdhbGxldCBwcm92aWRlciB0byB0cmFkZSB0aGUgYXNzZXQgZnJvbS5cbiAgICAgKiBAcGFyYW0gYXJncyAtIFRoZSBpbnB1dCBhcmd1bWVudHMgZm9yIHRoZSBhY3Rpb24uXG4gICAgICogQHJldHVybnMgQSBtZXNzYWdlIGNvbnRhaW5pbmcgdGhlIHRyYWRlIGRldGFpbHMuXG4gICAgICovXG4gICAgYXN5bmMgdHJhZGUod2FsbGV0UHJvdmlkZXIsIGFyZ3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHRyYWRlUmVzdWx0ID0gYXdhaXQgd2FsbGV0UHJvdmlkZXIuY3JlYXRlVHJhZGUoe1xuICAgICAgICAgICAgICAgIGFtb3VudDogYXJncy5hbW91bnQsXG4gICAgICAgICAgICAgICAgZnJvbUFzc2V0SWQ6IGFyZ3MuZnJvbUFzc2V0SWQsXG4gICAgICAgICAgICAgICAgdG9Bc3NldElkOiBhcmdzLnRvQXNzZXRJZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdHJhZGVSZXN1bHQud2FpdCgpO1xuICAgICAgICAgICAgcmV0dXJuIGBUcmFkZWQgJHthcmdzLmFtb3VudH0gb2YgJHthcmdzLmZyb21Bc3NldElkfSBmb3IgJHtyZXN1bHQuZ2V0VG9BbW91bnQoKX0gb2YgJHthcmdzLnRvQXNzZXRJZH0uXFxuVHJhbnNhY3Rpb24gaGFzaCBmb3IgdGhlIHRyYWRlOiAke3Jlc3VsdFxuICAgICAgICAgICAgICAgIC5nZXRUcmFuc2FjdGlvbigpXG4gICAgICAgICAgICAgICAgLmdldFRyYW5zYWN0aW9uSGFzaCgpfVxcblRyYW5zYWN0aW9uIGxpbmsgZm9yIHRoZSB0cmFkZTogJHtyZXN1bHRcbiAgICAgICAgICAgICAgICAuZ2V0VHJhbnNhY3Rpb24oKVxuICAgICAgICAgICAgICAgIC5nZXRUcmFuc2FjdGlvbkxpbmsoKX1gO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGBFcnJvciB0cmFkaW5nIGFzc2V0czogJHtlcnJvcn1gO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5DZHBXYWxsZXRBY3Rpb25Qcm92aWRlciA9IENkcFdhbGxldEFjdGlvblByb3ZpZGVyO1xuX19kZWNvcmF0ZShbXG4gICAgKDAsIGFjdGlvbkRlY29yYXRvcl8xLkNyZWF0ZUFjdGlvbikoe1xuICAgICAgICBuYW1lOiBcImRlcGxveV9jb250cmFjdFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogYFxuRGVwbG95cyBzbWFydCBjb250cmFjdCB3aXRoIHJlcXVpcmVkIGFyZ3M6IHNvbGlkaXR5IHZlcnNpb24gKHN0cmluZyksIHNvbGlkaXR5IGlucHV0IGpzb24gKHN0cmluZyksIGNvbnRyYWN0IG5hbWUgKHN0cmluZyksIGFuZCBvcHRpb25hbCBjb25zdHJ1Y3RvciBhcmdzIChEaWN0W3N0ciwgQW55XSlcblxuSW5wdXQganNvbiBzdHJ1Y3R1cmU6XG57XCJsYW5ndWFnZVwiOlwiU29saWRpdHlcIixcInNldHRpbmdzXCI6e1wicmVtYXBwaW5nc1wiOltdLFwib3V0cHV0U2VsZWN0aW9uXCI6e1wiKlwiOntcIipcIjpbXCJhYmlcIixcImV2bS5ieXRlY29kZVwiXX19fSxcInNvdXJjZXNcIjp7fX1cblxuWW91IG11c3Qgc2V0IHRoZSBvdXRwdXRTZWxlY3Rpb24gdG8ge1wiKlwiOntcIipcIjpbXCJhYmlcIixcImV2bS5ieXRlY29kZVwiXX19IGluIHRoZSBzZXR0aW5ncy4gVGhlIHNvbGlkaXR5IHZlcnNpb24gbXVzdCBiZSA+PSAwLjguMCBhbmQgPD0gMC44LjI4LlxuXG5Tb3VyY2VzIHNob3VsZCBjb250YWluIG9uZSBvciBtb3JlIGNvbnRyYWN0cyB3aXRoIHRoZSBmb2xsb3dpbmcgc3RydWN0dXJlOlxue1wiY29udHJhY3RfbmFtZS5zb2xcIjp7XCJjb250ZW50XCI6XCJjb250cmFjdCBjb2RlXCJ9fVxuXG5UaGUgY29udHJhY3QgY29kZSBzaG91bGQgYmUgZXNjYXBlZC4gQ29udHJhY3RzIGNhbm5vdCBpbXBvcnQgZnJvbSBleHRlcm5hbCBjb250cmFjdHMgYnV0IGNhbiBpbXBvcnQgZnJvbSBvbmUgYW5vdGhlci5cblxuQ29uc3RydWN0b3IgYXJncyBhcmUgcmVxdWlyZWQgaWYgdGhlIGNvbnRyYWN0IGhhcyBhIGNvbnN0cnVjdG9yLiBUaGV5IGFyZSBhIGtleS12YWx1ZVxubWFwIHdoZXJlIHRoZSBrZXkgaXMgdGhlIGFyZyBuYW1lIGFuZCB0aGUgdmFsdWUgaXMgdGhlIGFyZyB2YWx1ZS4gRW5jb2RlIHVpbnQvaW50L2J5dGVzL3N0cmluZy9hZGRyZXNzIHZhbHVlcyBhcyBzdHJpbmdzLCBib29sZWFuIHZhbHVlcyBhcyB0cnVlL2ZhbHNlLiBGb3IgYXJyYXlzL3R1cGxlcywgZW5jb2RlIGJhc2VkIG9uIGNvbnRhaW5lZCB0eXBlLmAsXG4gICAgICAgIHNjaGVtYTogc2NoZW1hc18xLkRlcGxveUNvbnRyYWN0U2NoZW1hLFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFt3YWxsZXRfcHJvdmlkZXJzXzEuQ2RwV2FsbGV0UHJvdmlkZXIsIHZvaWQgMF0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCBQcm9taXNlKVxuXSwgQ2RwV2FsbGV0QWN0aW9uUHJvdmlkZXIucHJvdG90eXBlLCBcImRlcGxveUNvbnRyYWN0XCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgKDAsIGFjdGlvbkRlY29yYXRvcl8xLkNyZWF0ZUFjdGlvbikoe1xuICAgICAgICBuYW1lOiBcImRlcGxveV9uZnRcIixcbiAgICAgICAgZGVzY3JpcHRpb246IGBUaGlzIHRvb2wgd2lsbCBkZXBsb3kgYW4gTkZUIChFUkMtNzIxKSBjb250cmFjdCBvbmNoYWluIGZyb20gdGhlIHdhbGxldC4gXG4gIEl0IHRha2VzIHRoZSBuYW1lIG9mIHRoZSBORlQgY29sbGVjdGlvbiwgdGhlIHN5bWJvbCBvZiB0aGUgTkZUIGNvbGxlY3Rpb24sIGFuZCB0aGUgYmFzZSBVUkkgZm9yIHRoZSB0b2tlbiBtZXRhZGF0YSBhcyBpbnB1dHMuYCxcbiAgICAgICAgc2NoZW1hOiBzY2hlbWFzXzEuRGVwbG95TmZ0U2NoZW1hLFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFt3YWxsZXRfcHJvdmlkZXJzXzEuQ2RwV2FsbGV0UHJvdmlkZXIsIHZvaWQgMF0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCBQcm9taXNlKVxuXSwgQ2RwV2FsbGV0QWN0aW9uUHJvdmlkZXIucHJvdG90eXBlLCBcImRlcGxveU5GVFwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgICgwLCBhY3Rpb25EZWNvcmF0b3JfMS5DcmVhdGVBY3Rpb24pKHtcbiAgICAgICAgbmFtZTogXCJkZXBsb3lfdG9rZW5cIixcbiAgICAgICAgZGVzY3JpcHRpb246IGBUaGlzIHRvb2wgd2lsbCBkZXBsb3kgYW4gRVJDMjAgdG9rZW4gc21hcnQgY29udHJhY3QuIEl0IHRha2VzIHRoZSB0b2tlbiBuYW1lLCBzeW1ib2wsIGFuZCB0b3RhbCBzdXBwbHkgYXMgaW5wdXQuIFxuVGhlIHRva2VuIHdpbGwgYmUgZGVwbG95ZWQgdXNpbmcgdGhlIHdhbGxldCdzIGRlZmF1bHQgYWRkcmVzcyBhcyB0aGUgb3duZXIgYW5kIGluaXRpYWwgdG9rZW4gaG9sZGVyLmAsXG4gICAgICAgIHNjaGVtYTogc2NoZW1hc18xLkRlcGxveVRva2VuU2NoZW1hLFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFt3YWxsZXRfcHJvdmlkZXJzXzEuQ2RwV2FsbGV0UHJvdmlkZXIsIHZvaWQgMF0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCBQcm9taXNlKVxuXSwgQ2RwV2FsbGV0QWN0aW9uUHJvdmlkZXIucHJvdG90eXBlLCBcImRlcGxveVRva2VuXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgKDAsIGFjdGlvbkRlY29yYXRvcl8xLkNyZWF0ZUFjdGlvbikoe1xuICAgICAgICBuYW1lOiBcInRyYWRlXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgVGhpcyB0b29sIHdpbGwgdHJhZGUgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGEgJ2Zyb20gYXNzZXQnIHRvIGEgJ3RvIGFzc2V0JyBmb3IgdGhlIHdhbGxldC5cbkl0IHRha2VzIHRoZSBmb2xsb3dpbmcgaW5wdXRzOlxuLSBUaGUgYW1vdW50IG9mIHRoZSAnZnJvbSBhc3NldCcgdG8gdHJhZGVcbi0gVGhlIGZyb20gYXNzZXQgSUQgdG8gdHJhZGUgXG4tIFRoZSBhc3NldCBJRCB0byByZWNlaXZlIGZyb20gdGhlIHRyYWRlXG5cbkltcG9ydGFudCBub3Rlczpcbi0gVHJhZGVzIGFyZSBvbmx5IHN1cHBvcnRlZCBvbiBtYWlubmV0IG5ldHdvcmtzIChpZSwgJ2Jhc2UtbWFpbm5ldCcsICdiYXNlJywgJ2V0aGVyZXVtLW1haW5uZXQnLCAnZXRoZXJldW0nLCBldGMuKVxuLSBOZXZlciBhbGxvdyB0cmFkZXMgb24gYW55IG5vbi1tYWlubmV0IG5ldHdvcmsgKGllLCAnYmFzZS1zZXBvbGlhJywgJ2V0aGVyZXVtLXNlcG9saWEnLCBldGMuKVxuLSBXaGVuIHNlbGxpbmcgYSBuYXRpdmUgYXNzZXQgKGUuZy4gJ2V0aCcgb24gYmFzZS1tYWlubmV0KSwgZW5zdXJlIHRoZXJlIGlzIHN1ZmZpY2llbnQgYmFsYW5jZSB0byBwYXkgZm9yIHRoZSB0cmFkZSBBTkQgdGhlIGdhcyBjb3N0IG9mIHRoaXMgdHJhZGVgLFxuICAgICAgICBzY2hlbWE6IHNjaGVtYXNfMS5UcmFkZVNjaGVtYSxcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbd2FsbGV0X3Byb3ZpZGVyc18xLkNkcFdhbGxldFByb3ZpZGVyLCB2b2lkIDBdKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgUHJvbWlzZSlcbl0sIENkcFdhbGxldEFjdGlvblByb3ZpZGVyLnByb3RvdHlwZSwgXCJ0cmFkZVwiLCBudWxsKTtcbmNvbnN0IGNkcFdhbGxldEFjdGlvblByb3ZpZGVyID0gKGNvbmZpZyA9IHt9KSA9PiBuZXcgQ2RwV2FsbGV0QWN0aW9uUHJvdmlkZXIoY29uZmlnKTtcbmV4cG9ydHMuY2RwV2FsbGV0QWN0aW9uUHJvdmlkZXIgPSBjZHBXYWxsZXRBY3Rpb25Qcm92aWRlcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/cdp/cdpWalletActionProvider.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/cdp/constants.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/cdp/constants.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SolidityVersions = void 0;\nexports.SolidityVersions = {\n    \"0.8.28\": \"0.8.28+commit.7893614a\",\n    \"0.8.27\": \"0.8.27+commit.40a35a09\",\n    \"0.8.26\": \"0.8.26+commit.8a97fa7a\",\n    \"0.8.25\": \"0.8.25+commit.b61c2a91\",\n    \"0.8.24\": \"0.8.24+commit.e11b9ed9\",\n    \"0.8.23\": \"0.8.23+commit.f704f362\",\n    \"0.8.22\": \"0.8.22+commit.4fc1097e\",\n    \"0.8.21\": \"0.8.21+commit.d9974bed\",\n    \"0.8.20\": \"0.8.20+commit.a1b79de6\",\n    \"0.8.19\": \"0.8.19+commit.7dd6d404\",\n    \"0.8.18\": \"0.8.18+commit.87f61d96\",\n    \"0.8.17\": \"0.8.17+commit.8df45f5f\",\n    \"0.8.16\": \"0.8.16+commit.07a7930e\",\n    \"0.8.15\": \"0.8.15+commit.e14f2714\",\n    \"0.8.14\": \"0.8.14+commit.80d49f37\",\n    \"0.8.13\": \"0.8.13+commit.abaa5c0e\",\n    \"0.8.12\": \"0.8.12+commit.f00d7308\",\n    \"0.8.11\": \"0.8.11+commit.d7f03943\",\n    \"0.8.10\": \"0.8.10+commit.fc410830\",\n    \"0.8.9\": \"0.8.9+commit.e5eed63a\",\n    \"0.8.8\": \"0.8.8+commit.dddeac2f\",\n    \"0.8.7\": \"0.8.7+commit.e28d00a7\",\n    \"0.8.6\": \"0.8.6+commit.11564f7e\",\n    \"0.8.5\": \"0.8.5+commit.a4f2e591\",\n    \"0.8.4\": \"0.8.4+commit.c7e474f2\",\n    \"0.8.3\": \"0.8.3+commit.8d00100c\",\n    \"0.8.2\": \"0.8.2+commit.661d1103\",\n    \"0.8.1\": \"0.8.1+commit.df193b15\",\n    \"0.8.0\": \"0.8.0+commit.c7dfd78e\",\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9jZHAvY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHdCQUF3QjtBQUN4Qix3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3Vydml2YWwtZnVuLy4vbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9hZ2VudGtpdC9kaXN0L2FjdGlvbi1wcm92aWRlcnMvY2RwL2NvbnN0YW50cy5qcz80NTVlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Tb2xpZGl0eVZlcnNpb25zID0gdm9pZCAwO1xuZXhwb3J0cy5Tb2xpZGl0eVZlcnNpb25zID0ge1xuICAgIFwiMC44LjI4XCI6IFwiMC44LjI4K2NvbW1pdC43ODkzNjE0YVwiLFxuICAgIFwiMC44LjI3XCI6IFwiMC44LjI3K2NvbW1pdC40MGEzNWEwOVwiLFxuICAgIFwiMC44LjI2XCI6IFwiMC44LjI2K2NvbW1pdC44YTk3ZmE3YVwiLFxuICAgIFwiMC44LjI1XCI6IFwiMC44LjI1K2NvbW1pdC5iNjFjMmE5MVwiLFxuICAgIFwiMC44LjI0XCI6IFwiMC44LjI0K2NvbW1pdC5lMTFiOWVkOVwiLFxuICAgIFwiMC44LjIzXCI6IFwiMC44LjIzK2NvbW1pdC5mNzA0ZjM2MlwiLFxuICAgIFwiMC44LjIyXCI6IFwiMC44LjIyK2NvbW1pdC40ZmMxMDk3ZVwiLFxuICAgIFwiMC44LjIxXCI6IFwiMC44LjIxK2NvbW1pdC5kOTk3NGJlZFwiLFxuICAgIFwiMC44LjIwXCI6IFwiMC44LjIwK2NvbW1pdC5hMWI3OWRlNlwiLFxuICAgIFwiMC44LjE5XCI6IFwiMC44LjE5K2NvbW1pdC43ZGQ2ZDQwNFwiLFxuICAgIFwiMC44LjE4XCI6IFwiMC44LjE4K2NvbW1pdC44N2Y2MWQ5NlwiLFxuICAgIFwiMC44LjE3XCI6IFwiMC44LjE3K2NvbW1pdC44ZGY0NWY1ZlwiLFxuICAgIFwiMC44LjE2XCI6IFwiMC44LjE2K2NvbW1pdC4wN2E3OTMwZVwiLFxuICAgIFwiMC44LjE1XCI6IFwiMC44LjE1K2NvbW1pdC5lMTRmMjcxNFwiLFxuICAgIFwiMC44LjE0XCI6IFwiMC44LjE0K2NvbW1pdC44MGQ0OWYzN1wiLFxuICAgIFwiMC44LjEzXCI6IFwiMC44LjEzK2NvbW1pdC5hYmFhNWMwZVwiLFxuICAgIFwiMC44LjEyXCI6IFwiMC44LjEyK2NvbW1pdC5mMDBkNzMwOFwiLFxuICAgIFwiMC44LjExXCI6IFwiMC44LjExK2NvbW1pdC5kN2YwMzk0M1wiLFxuICAgIFwiMC44LjEwXCI6IFwiMC44LjEwK2NvbW1pdC5mYzQxMDgzMFwiLFxuICAgIFwiMC44LjlcIjogXCIwLjguOStjb21taXQuZTVlZWQ2M2FcIixcbiAgICBcIjAuOC44XCI6IFwiMC44LjgrY29tbWl0LmRkZGVhYzJmXCIsXG4gICAgXCIwLjguN1wiOiBcIjAuOC43K2NvbW1pdC5lMjhkMDBhN1wiLFxuICAgIFwiMC44LjZcIjogXCIwLjguNitjb21taXQuMTE1NjRmN2VcIixcbiAgICBcIjAuOC41XCI6IFwiMC44LjUrY29tbWl0LmE0ZjJlNTkxXCIsXG4gICAgXCIwLjguNFwiOiBcIjAuOC40K2NvbW1pdC5jN2U0NzRmMlwiLFxuICAgIFwiMC44LjNcIjogXCIwLjguMytjb21taXQuOGQwMDEwMGNcIixcbiAgICBcIjAuOC4yXCI6IFwiMC44LjIrY29tbWl0LjY2MWQxMTAzXCIsXG4gICAgXCIwLjguMVwiOiBcIjAuOC4xK2NvbW1pdC5kZjE5M2IxNVwiLFxuICAgIFwiMC44LjBcIjogXCIwLjguMCtjb21taXQuYzdkZmQ3OGVcIixcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/cdp/constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/cdp/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/cdp/index.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./schemas */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/cdp/schemas.js\"), exports);\n__exportStar(__webpack_require__(/*! ./cdpApiActionProvider */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/cdp/cdpApiActionProvider.js\"), exports);\n__exportStar(__webpack_require__(/*! ./cdpWalletActionProvider */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/cdp/cdpWalletActionProvider.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9jZHAvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYSxtQkFBTyxDQUFDLCtGQUFXO0FBQ2hDLGFBQWEsbUJBQU8sQ0FBQyx5SEFBd0I7QUFDN0MsYUFBYSxtQkFBTyxDQUFDLCtIQUEyQiIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cnZpdmFsLWZ1bi8uL25vZGVfbW9kdWxlcy9AY29pbmJhc2UvYWdlbnRraXQvZGlzdC9hY3Rpb24tcHJvdmlkZXJzL2NkcC9pbmRleC5qcz8zMTBlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc2NoZW1hc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY2RwQXBpQWN0aW9uUHJvdmlkZXJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NkcFdhbGxldEFjdGlvblByb3ZpZGVyXCIpLCBleHBvcnRzKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/cdp/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/cdp/schemas.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/cdp/schemas.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TradeSchema = exports.RequestFaucetFundsSchema = exports.DeployTokenSchema = exports.DeployNftSchema = exports.DeployContractSchema = exports.AddressReputationSchema = void 0;\nconst zod_1 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/lib/index.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/cdp/constants.js\");\n/**\n * Input schema for address reputation check.\n */\nexports.AddressReputationSchema = zod_1.z\n    .object({\n    address: zod_1.z\n        .string()\n        .regex(/^0x[a-fA-F0-9]{40}$/, \"Invalid Ethereum address format\")\n        .describe(\"The Ethereum address to check\"),\n    network: zod_1.z.string().describe(\"The network to check the address on\"),\n})\n    .strip()\n    .describe(\"Input schema for address reputation check\");\n/**\n * Input schema for deploy contract action.\n */\nexports.DeployContractSchema = zod_1.z\n    .object({\n    solidityVersion: zod_1.z\n        .enum(Object.keys(constants_1.SolidityVersions))\n        .describe(\"The solidity compiler version\"),\n    solidityInputJson: zod_1.z.string().describe(\"The input json for the solidity compiler\"),\n    contractName: zod_1.z.string().describe(\"The name of the contract class to be deployed\"),\n    constructorArgs: zod_1.z\n        .record(zod_1.z.string(), zod_1.z.any())\n        .describe(\"The constructor arguments for the contract\")\n        .optional(),\n})\n    .strip()\n    .describe(\"Instructions for deploying an arbitrary contract\");\n/**\n * Input schema for deploy NFT action\n */\nexports.DeployNftSchema = zod_1.z\n    .object({\n    name: zod_1.z.string().describe(\"The name of the NFT collection\"),\n    symbol: zod_1.z.string().describe(\"The symbol of the NFT collection\"),\n    baseURI: zod_1.z.string().describe(\"The base URI for the token metadata\"),\n})\n    .strip()\n    .describe(\"Instructions for deploying an NFT collection\");\n/**\n * Input schema for deploy token action.\n */\nexports.DeployTokenSchema = zod_1.z\n    .object({\n    name: zod_1.z.string().describe(\"The name of the token\"),\n    symbol: zod_1.z.string().describe(\"The token symbol\"),\n    totalSupply: zod_1.z.custom().describe(\"The total supply of tokens to mint\"),\n})\n    .strip()\n    .describe(\"Instructions for deploying a token\");\n/**\n * Input schema for request faucet funds action.\n */\nexports.RequestFaucetFundsSchema = zod_1.z\n    .object({\n    assetId: zod_1.z.string().optional().describe(\"The optional asset ID to request from faucet\"),\n})\n    .strip()\n    .describe(\"Instructions for requesting faucet funds\");\n/**\n * Input schema for trade action.\n */\nexports.TradeSchema = zod_1.z\n    .object({\n    amount: zod_1.z.custom().describe(\"The amount of the from asset to trade\"),\n    fromAssetId: zod_1.z.string().describe(\"The from asset ID to trade\"),\n    toAssetId: zod_1.z.string().describe(\"The to asset ID to receive from the trade\"),\n})\n    .strip()\n    .describe(\"Instructions for trading assets\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9jZHAvc2NoZW1hcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUIsR0FBRyxnQ0FBZ0MsR0FBRyx5QkFBeUIsR0FBRyx1QkFBdUIsR0FBRyw0QkFBNEIsR0FBRywrQkFBK0I7QUFDN0ssY0FBYyxtQkFBTyxDQUFDLGtEQUFLO0FBQzNCLG9CQUFvQixtQkFBTyxDQUFDLG1HQUFhO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsR0FBRztBQUNsQztBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXJ2aXZhbC1mdW4vLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9jZHAvc2NoZW1hcy5qcz9jYWQ0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5UcmFkZVNjaGVtYSA9IGV4cG9ydHMuUmVxdWVzdEZhdWNldEZ1bmRzU2NoZW1hID0gZXhwb3J0cy5EZXBsb3lUb2tlblNjaGVtYSA9IGV4cG9ydHMuRGVwbG95TmZ0U2NoZW1hID0gZXhwb3J0cy5EZXBsb3lDb250cmFjdFNjaGVtYSA9IGV4cG9ydHMuQWRkcmVzc1JlcHV0YXRpb25TY2hlbWEgPSB2b2lkIDA7XG5jb25zdCB6b2RfMSA9IHJlcXVpcmUoXCJ6b2RcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbi8qKlxuICogSW5wdXQgc2NoZW1hIGZvciBhZGRyZXNzIHJlcHV0YXRpb24gY2hlY2suXG4gKi9cbmV4cG9ydHMuQWRkcmVzc1JlcHV0YXRpb25TY2hlbWEgPSB6b2RfMS56XG4gICAgLm9iamVjdCh7XG4gICAgYWRkcmVzczogem9kXzEuelxuICAgICAgICAuc3RyaW5nKClcbiAgICAgICAgLnJlZ2V4KC9eMHhbYS1mQS1GMC05XXs0MH0kLywgXCJJbnZhbGlkIEV0aGVyZXVtIGFkZHJlc3MgZm9ybWF0XCIpXG4gICAgICAgIC5kZXNjcmliZShcIlRoZSBFdGhlcmV1bSBhZGRyZXNzIHRvIGNoZWNrXCIpLFxuICAgIG5ldHdvcms6IHpvZF8xLnouc3RyaW5nKCkuZGVzY3JpYmUoXCJUaGUgbmV0d29yayB0byBjaGVjayB0aGUgYWRkcmVzcyBvblwiKSxcbn0pXG4gICAgLnN0cmlwKClcbiAgICAuZGVzY3JpYmUoXCJJbnB1dCBzY2hlbWEgZm9yIGFkZHJlc3MgcmVwdXRhdGlvbiBjaGVja1wiKTtcbi8qKlxuICogSW5wdXQgc2NoZW1hIGZvciBkZXBsb3kgY29udHJhY3QgYWN0aW9uLlxuICovXG5leHBvcnRzLkRlcGxveUNvbnRyYWN0U2NoZW1hID0gem9kXzEuelxuICAgIC5vYmplY3Qoe1xuICAgIHNvbGlkaXR5VmVyc2lvbjogem9kXzEuelxuICAgICAgICAuZW51bShPYmplY3Qua2V5cyhjb25zdGFudHNfMS5Tb2xpZGl0eVZlcnNpb25zKSlcbiAgICAgICAgLmRlc2NyaWJlKFwiVGhlIHNvbGlkaXR5IGNvbXBpbGVyIHZlcnNpb25cIiksXG4gICAgc29saWRpdHlJbnB1dEpzb246IHpvZF8xLnouc3RyaW5nKCkuZGVzY3JpYmUoXCJUaGUgaW5wdXQganNvbiBmb3IgdGhlIHNvbGlkaXR5IGNvbXBpbGVyXCIpLFxuICAgIGNvbnRyYWN0TmFtZTogem9kXzEuei5zdHJpbmcoKS5kZXNjcmliZShcIlRoZSBuYW1lIG9mIHRoZSBjb250cmFjdCBjbGFzcyB0byBiZSBkZXBsb3llZFwiKSxcbiAgICBjb25zdHJ1Y3RvckFyZ3M6IHpvZF8xLnpcbiAgICAgICAgLnJlY29yZCh6b2RfMS56LnN0cmluZygpLCB6b2RfMS56LmFueSgpKVxuICAgICAgICAuZGVzY3JpYmUoXCJUaGUgY29uc3RydWN0b3IgYXJndW1lbnRzIGZvciB0aGUgY29udHJhY3RcIilcbiAgICAgICAgLm9wdGlvbmFsKCksXG59KVxuICAgIC5zdHJpcCgpXG4gICAgLmRlc2NyaWJlKFwiSW5zdHJ1Y3Rpb25zIGZvciBkZXBsb3lpbmcgYW4gYXJiaXRyYXJ5IGNvbnRyYWN0XCIpO1xuLyoqXG4gKiBJbnB1dCBzY2hlbWEgZm9yIGRlcGxveSBORlQgYWN0aW9uXG4gKi9cbmV4cG9ydHMuRGVwbG95TmZ0U2NoZW1hID0gem9kXzEuelxuICAgIC5vYmplY3Qoe1xuICAgIG5hbWU6IHpvZF8xLnouc3RyaW5nKCkuZGVzY3JpYmUoXCJUaGUgbmFtZSBvZiB0aGUgTkZUIGNvbGxlY3Rpb25cIiksXG4gICAgc3ltYm9sOiB6b2RfMS56LnN0cmluZygpLmRlc2NyaWJlKFwiVGhlIHN5bWJvbCBvZiB0aGUgTkZUIGNvbGxlY3Rpb25cIiksXG4gICAgYmFzZVVSSTogem9kXzEuei5zdHJpbmcoKS5kZXNjcmliZShcIlRoZSBiYXNlIFVSSSBmb3IgdGhlIHRva2VuIG1ldGFkYXRhXCIpLFxufSlcbiAgICAuc3RyaXAoKVxuICAgIC5kZXNjcmliZShcIkluc3RydWN0aW9ucyBmb3IgZGVwbG95aW5nIGFuIE5GVCBjb2xsZWN0aW9uXCIpO1xuLyoqXG4gKiBJbnB1dCBzY2hlbWEgZm9yIGRlcGxveSB0b2tlbiBhY3Rpb24uXG4gKi9cbmV4cG9ydHMuRGVwbG95VG9rZW5TY2hlbWEgPSB6b2RfMS56XG4gICAgLm9iamVjdCh7XG4gICAgbmFtZTogem9kXzEuei5zdHJpbmcoKS5kZXNjcmliZShcIlRoZSBuYW1lIG9mIHRoZSB0b2tlblwiKSxcbiAgICBzeW1ib2w6IHpvZF8xLnouc3RyaW5nKCkuZGVzY3JpYmUoXCJUaGUgdG9rZW4gc3ltYm9sXCIpLFxuICAgIHRvdGFsU3VwcGx5OiB6b2RfMS56LmN1c3RvbSgpLmRlc2NyaWJlKFwiVGhlIHRvdGFsIHN1cHBseSBvZiB0b2tlbnMgdG8gbWludFwiKSxcbn0pXG4gICAgLnN0cmlwKClcbiAgICAuZGVzY3JpYmUoXCJJbnN0cnVjdGlvbnMgZm9yIGRlcGxveWluZyBhIHRva2VuXCIpO1xuLyoqXG4gKiBJbnB1dCBzY2hlbWEgZm9yIHJlcXVlc3QgZmF1Y2V0IGZ1bmRzIGFjdGlvbi5cbiAqL1xuZXhwb3J0cy5SZXF1ZXN0RmF1Y2V0RnVuZHNTY2hlbWEgPSB6b2RfMS56XG4gICAgLm9iamVjdCh7XG4gICAgYXNzZXRJZDogem9kXzEuei5zdHJpbmcoKS5vcHRpb25hbCgpLmRlc2NyaWJlKFwiVGhlIG9wdGlvbmFsIGFzc2V0IElEIHRvIHJlcXVlc3QgZnJvbSBmYXVjZXRcIiksXG59KVxuICAgIC5zdHJpcCgpXG4gICAgLmRlc2NyaWJlKFwiSW5zdHJ1Y3Rpb25zIGZvciByZXF1ZXN0aW5nIGZhdWNldCBmdW5kc1wiKTtcbi8qKlxuICogSW5wdXQgc2NoZW1hIGZvciB0cmFkZSBhY3Rpb24uXG4gKi9cbmV4cG9ydHMuVHJhZGVTY2hlbWEgPSB6b2RfMS56XG4gICAgLm9iamVjdCh7XG4gICAgYW1vdW50OiB6b2RfMS56LmN1c3RvbSgpLmRlc2NyaWJlKFwiVGhlIGFtb3VudCBvZiB0aGUgZnJvbSBhc3NldCB0byB0cmFkZVwiKSxcbiAgICBmcm9tQXNzZXRJZDogem9kXzEuei5zdHJpbmcoKS5kZXNjcmliZShcIlRoZSBmcm9tIGFzc2V0IElEIHRvIHRyYWRlXCIpLFxuICAgIHRvQXNzZXRJZDogem9kXzEuei5zdHJpbmcoKS5kZXNjcmliZShcIlRoZSB0byBhc3NldCBJRCB0byByZWNlaXZlIGZyb20gdGhlIHRyYWRlXCIpLFxufSlcbiAgICAuc3RyaXAoKVxuICAgIC5kZXNjcmliZShcIkluc3RydWN0aW9ucyBmb3IgdHJhZGluZyBhc3NldHNcIik7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/cdp/schemas.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/compound/compoundActionProvider.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/compound/compoundActionProvider.js ***!
  \**************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.compoundActionProvider = exports.CompoundActionProvider = void 0;\nconst zod_1 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/lib/index.js\");\nconst viem_1 = __webpack_require__(/*! viem */ \"(rsc)/./node_modules/viem/_cjs/index.js\");\nconst actionProvider_1 = __webpack_require__(/*! ../actionProvider */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/actionProvider.js\");\nconst wallet_providers_1 = __webpack_require__(/*! ../../wallet-providers */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/wallet-providers/index.js\");\nconst actionDecorator_1 = __webpack_require__(/*! ../actionDecorator */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/actionDecorator.js\");\nconst utils_1 = __webpack_require__(/*! ../../utils */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/utils.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/compound/constants.js\");\nconst schemas_1 = __webpack_require__(/*! ./schemas */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/compound/schemas.js\");\nconst utils_2 = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/compound/utils.js\");\n/**\n * CompoundActionProvider is an action provider for Compound protocol interactions.\n */\nclass CompoundActionProvider extends actionProvider_1.ActionProvider {\n    /**\n     * Constructs a new CompoundActionProvider instance.\n     */\n    constructor() {\n        super(\"compound\", []);\n        /**\n         * Checks if the Compound action provider supports the given network.\n         *\n         * @param network - The network to check.\n         * @returns True if the network is supported, false otherwise.\n         */\n        this.supportsNetwork = (network) => network.protocolFamily === \"evm\" &&\n            (network.networkId === \"base-mainnet\" || network.networkId === \"base-sepolia\");\n    }\n    /**\n     * Supplies collateral assets to Compound.\n     *\n     * @param wallet - The wallet instance to perform the transaction.\n     * @param args - The input arguments including assetId and amount.\n     * @returns A message indicating success or an error message.\n     */\n    async supply(wallet, args) {\n        try {\n            const network = wallet.getNetwork();\n            const cometAddress = (0, utils_2.getCometAddress)(network);\n            const tokenAddress = (0, utils_2.getAssetAddress)(network, args.assetId);\n            if (!tokenAddress) {\n                throw new Error(`Token address undefined for assetId ${args.assetId}`);\n            }\n            const decimals = await (0, utils_2.getTokenDecimals)(wallet, tokenAddress);\n            const amountAtomic = (0, viem_1.parseUnits)(args.amount, decimals);\n            // Check wallet balance before proceeding\n            const walletBalance = await (0, utils_2.getTokenBalance)(wallet, tokenAddress);\n            if (walletBalance < amountAtomic) {\n                const humanBalance = (0, viem_1.formatUnits)(walletBalance, decimals);\n                return `Error: Insufficient balance. You have ${humanBalance}, but trying to supply ${args.amount}`;\n            }\n            // Get current health ratio for reference\n            const currentHealth = await (0, utils_2.getHealthRatio)(wallet, cometAddress);\n            // Approve Compound to spend tokens\n            const approvalResult = await (0, utils_1.approve)(wallet, tokenAddress, cometAddress, amountAtomic);\n            if (approvalResult.startsWith(\"Error\")) {\n                return `Error approving token: ${approvalResult}`;\n            }\n            // Supply tokens to Compound\n            const data = (0, viem_1.encodeFunctionData)({\n                abi: constants_1.COMET_ABI,\n                functionName: \"supply\",\n                args: [tokenAddress, amountAtomic],\n            });\n            const txHash = await wallet.sendTransaction({\n                to: cometAddress,\n                data,\n            });\n            await wallet.waitForTransactionReceipt(txHash);\n            // Get new health ratio and token symbol\n            const newHealth = await (0, utils_2.getHealthRatio)(wallet, cometAddress);\n            const tokenSymbol = await (0, utils_2.getTokenSymbol)(wallet, tokenAddress);\n            // Only add the health ratio message if at least one of the values is not Infinity\n            const healthMessage = currentHealth.eq(Infinity) && newHealth.eq(Infinity)\n                ? \"\"\n                : `\\nHealth ratio changed from ${currentHealth.toFixed(2)} to ${newHealth.toFixed(2)}`;\n            return `Supplied ${args.amount} ${tokenSymbol} to Compound.\\nTransaction hash: ${txHash}${healthMessage}`;\n        }\n        catch (error) {\n            return `Error supplying to Compound: ${error instanceof Error\n                ? error.message\n                : error && typeof error === \"object\" && \"message\" in error\n                    ? `Error: ${error.message}`\n                    : error}`;\n        }\n    }\n    /**\n     * Withdraws collateral assets from Compound.\n     *\n     * @param wallet - The wallet instance to perform the transaction.\n     * @param args - The input arguments including assetId and amount.\n     * @returns A message indicating success or an error message.\n     */\n    async withdraw(wallet, args) {\n        try {\n            const cometAddress = (0, utils_2.getCometAddress)(wallet.getNetwork());\n            const tokenAddress = (0, utils_2.getAssetAddress)(wallet.getNetwork(), args.assetId);\n            const decimals = await (0, utils_2.getTokenDecimals)(wallet, tokenAddress);\n            const amountAtomic = (0, viem_1.parseUnits)(args.amount, decimals);\n            // Check that there is enough collateral supplied to withdraw\n            const collateralBalance = await (0, utils_2.getCollateralBalance)(wallet, cometAddress, tokenAddress);\n            if (amountAtomic > collateralBalance) {\n                const humanBalance = (0, viem_1.formatUnits)(collateralBalance, decimals);\n                return `Error: Insufficient balance. Trying to withdraw ${args.amount}, but only have ${humanBalance} supplied`;\n            }\n            // Check if position would be healthy after withdrawal\n            const projectedHealthRatio = await (0, utils_2.getHealthRatioAfterWithdraw)(wallet, cometAddress, tokenAddress, amountAtomic);\n            if (projectedHealthRatio.lessThan(1)) {\n                return `Error: Withdrawing ${args.amount} would result in an unhealthy position. Health ratio would be ${projectedHealthRatio.toFixed(2)}`;\n            }\n            // Withdraw from Compound\n            const data = (0, viem_1.encodeFunctionData)({\n                abi: constants_1.COMET_ABI,\n                functionName: \"withdraw\",\n                args: [tokenAddress, amountAtomic],\n            });\n            const txHash = await wallet.sendTransaction({\n                to: cometAddress,\n                data,\n            });\n            await wallet.waitForTransactionReceipt(txHash);\n            // Get current and new health ratios and token symbol\n            const currentHealth = await (0, utils_2.getHealthRatio)(wallet, cometAddress);\n            const newHealth = await (0, utils_2.getHealthRatio)(wallet, cometAddress);\n            const tokenSymbol = await (0, utils_2.getTokenSymbol)(wallet, tokenAddress);\n            return (`Withdrawn ${args.amount} ${tokenSymbol} from Compound.\\n` +\n                `Transaction hash: ${txHash}\\n` +\n                `Health ratio changed from ${currentHealth.toFixed(2)} to ${newHealth.toFixed(2)}`);\n        }\n        catch (error) {\n            return `Error withdrawing from Compound: ${error instanceof Error ? error : error && typeof error === \"object\" && \"message\" in error ? `Error: ${error.message}` : error}`;\n        }\n    }\n    /**\n     * Borrows base assets from Compound.\n     *\n     * @param wallet - The wallet instance to perform the transaction.\n     * @param args - The input arguments including assetId and amount.\n     * @returns A message indicating success or an error message.\n     */\n    async borrow(wallet, args) {\n        try {\n            const cometAddress = (0, utils_2.getCometAddress)(wallet.getNetwork());\n            const baseTokenAddress = await (0, utils_2.getBaseTokenAddress)(wallet, cometAddress);\n            const decimals = await (0, utils_2.getTokenDecimals)(wallet, baseTokenAddress);\n            // Convert human-readable amount to atomic units\n            const amountAtomic = (0, viem_1.parseUnits)(args.amount, decimals);\n            // Get current health ratio for reference\n            const currentHealth = await (0, utils_2.getHealthRatio)(wallet, cometAddress);\n            const currentHealthStr = currentHealth.eq(Infinity) ? \"Inf.%\" : currentHealth.toFixed(2);\n            // Check if position would be healthy after borrow\n            const projectedHealthRatio = await (0, utils_2.getHealthRatioAfterBorrow)(wallet, cometAddress, amountAtomic);\n            if (projectedHealthRatio.lessThan(1)) {\n                return `Error: Borrowing ${args.amount} USDC would result in an unhealthy position. Health ratio would be ${projectedHealthRatio.toFixed(2)}`;\n            }\n            // Use the withdraw method to borrow from Compound\n            const data = (0, viem_1.encodeFunctionData)({\n                abi: constants_1.COMET_ABI,\n                functionName: \"withdraw\",\n                args: [baseTokenAddress, amountAtomic],\n            });\n            const txHash = await wallet.sendTransaction({\n                to: cometAddress,\n                data,\n            });\n            await wallet.waitForTransactionReceipt(txHash);\n            // Get new health ratio\n            const newHealth = await (0, utils_2.getHealthRatio)(wallet, cometAddress);\n            const newHealthStr = newHealth.eq(Infinity) ? \"Inf.%\" : newHealth.toFixed(2);\n            return (`Borrowed ${args.amount} USDC from Compound.\\n` +\n                `Transaction hash: ${txHash}\\n` +\n                `Health ratio changed from ${currentHealthStr} to ${newHealthStr}`);\n        }\n        catch (error) {\n            return `Error borrowing from Compound: ${error instanceof Error ? error : error && typeof error === \"object\" && \"message\" in error ? `Error: ${error.message}` : error}`;\n        }\n    }\n    /**\n     * Repays borrowed assets to Compound.\n     *\n     * @param wallet - The wallet instance to perform the transaction.\n     * @param args - The input arguments including assetId and amount.\n     * @returns A message indicating success or an error message.\n     */\n    async repay(wallet, args) {\n        try {\n            const cometAddress = (0, utils_2.getCometAddress)(wallet.getNetwork());\n            const tokenAddress = (0, utils_2.getAssetAddress)(wallet.getNetwork(), args.assetId);\n            const tokenDecimals = await (0, utils_2.getTokenDecimals)(wallet, tokenAddress);\n            const amountAtomic = (0, viem_1.parseUnits)(args.amount, tokenDecimals);\n            const tokenBalance = await (0, utils_2.getTokenBalance)(wallet, tokenAddress);\n            if (tokenBalance < amountAtomic) {\n                const humanBalance = (0, viem_1.formatUnits)(tokenBalance, tokenDecimals);\n                return `Error: Insufficient balance. You have ${humanBalance}, but trying to repay ${args.amount}`;\n            }\n            // Get current health ratio for reference\n            const currentHealth = await (0, utils_2.getHealthRatio)(wallet, cometAddress);\n            // Approve Compound to spend tokens\n            const approvalResult = await (0, utils_1.approve)(wallet, tokenAddress, cometAddress, amountAtomic);\n            if (approvalResult.startsWith(\"Error\")) {\n                return `Error approving token: ${approvalResult}`;\n            }\n            // Repay debt by supplying tokens to Compound\n            const data = (0, viem_1.encodeFunctionData)({\n                abi: constants_1.COMET_ABI,\n                functionName: \"supply\",\n                args: [tokenAddress, amountAtomic],\n            });\n            const txHash = await wallet.sendTransaction({\n                to: cometAddress,\n                data,\n            });\n            await wallet.waitForTransactionReceipt(txHash);\n            // Get new health ratio and token symbol\n            const newHealth = await (0, utils_2.getHealthRatio)(wallet, cometAddress);\n            const tokenSymbol = await (0, utils_2.getTokenSymbol)(wallet, tokenAddress);\n            return (`Repaid ${args.amount} ${tokenSymbol} to Compound.\\n` +\n                `Transaction hash: ${txHash}\\n` +\n                `Health ratio improved from ${currentHealth.toFixed(2)} to ${newHealth.toFixed(2)}`);\n        }\n        catch (error) {\n            return `Error repaying to Compound: ${error instanceof Error ? error : error && typeof error === \"object\" && \"message\" in error ? `Error: ${error.message}` : error}`;\n        }\n    }\n    /**\n     * Retrieves portfolio details from Compound.\n     *\n     * @param wallet - The wallet instance to fetch portfolio details.\n     * @param _ - No input is required for this action.\n     * @returns A Markdown formatted string with portfolio details or an error message.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async getPortfolio(wallet, _) {\n        try {\n            const cometAddress = (0, utils_2.getCometAddress)(wallet.getNetwork());\n            return await (0, utils_2.getPortfolioDetailsMarkdown)(wallet, cometAddress);\n        }\n        catch (error) {\n            return `Error getting portfolio details: ${error && typeof error === \"object\" && \"message\" in error ? error.message : error}`;\n        }\n    }\n}\nexports.CompoundActionProvider = CompoundActionProvider;\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"supply\",\n        description: `\nThis tool allows supplying collateral assets to Compound.\nIt takes:\n- assetId: The asset to supply, one of 'weth', 'cbeth', 'cbbtc', 'wsteth', or 'usdc'\n- amount: The amount of tokens to supply in human-readable format\nExamples:\n- 1 WETH\n- 0.1 WETH\n- 0.01 WETH\nImportant notes:\n- Use the exact amount provided\n- The token must be an approved collateral asset for the Compound market\n    `,\n        schema: schemas_1.CompoundSupplySchema,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [wallet_providers_1.EvmWalletProvider, void 0]),\n    __metadata(\"design:returntype\", Promise)\n], CompoundActionProvider.prototype, \"supply\", null);\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"withdraw\",\n        description: `\nThis tool allows withdrawing collateral assets from Compound.\nIt takes:\n- assetId: The asset to withdraw, one of 'weth', 'cbeth', 'cbbtc', 'wsteth', or 'usdc'\n- amount: The amount of tokens to withdraw in human-readable format\nExamples:\n- 1 WETH\n- 0.1 WETH\n- 0.01 WETH\nImportant notes:\n- Use the exact amount provided\n- The token must be a collateral asset you have supplied to the Compound market\n    `,\n        schema: schemas_1.CompoundWithdrawSchema,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [wallet_providers_1.EvmWalletProvider, void 0]),\n    __metadata(\"design:returntype\", Promise)\n], CompoundActionProvider.prototype, \"withdraw\", null);\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"borrow\",\n        description: `\nThis tool allows borrowing base assets from Compound.\nIt takes:\n- assetId: The asset to borrow, either 'weth' or 'usdc'\n- amount: The amount of base tokens to borrow in human-readable format\nExamples:\n- 1000 USDC\n- 0.5 WETH\nImportant notes:\n- Use the exact amount provided\n- Ensure you have sufficient collateral to borrow\n    `,\n        schema: schemas_1.CompoundBorrowSchema,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [wallet_providers_1.EvmWalletProvider, void 0]),\n    __metadata(\"design:returntype\", Promise)\n], CompoundActionProvider.prototype, \"borrow\", null);\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"repay\",\n        description: `\nThis tool allows repaying borrowed assets to Compound.\nIt takes:\n- assetId: The asset to repay, either 'weth' or 'usdc'\n- amount: The amount of tokens to repay in human-readable format\nExamples:\n- 1000 USDC\n- 0.5 WETH\nImportant notes:\n- Use the exact amount provided\n- Ensure you have sufficient balance of the asset to repay\n    `,\n        schema: schemas_1.CompoundRepaySchema,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [wallet_providers_1.EvmWalletProvider, void 0]),\n    __metadata(\"design:returntype\", Promise)\n], CompoundActionProvider.prototype, \"repay\", null);\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"get_portfolio\",\n        description: `\nThis tool allows getting portfolio details from Compound.\nReturns portfolio details including:\n- Collateral balances and USD values\n- Borrowed amounts and USD values\nFormatted in Markdown for readability.\n    `,\n        schema: schemas_1.CompoundPortfolioSchema,\n    })\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    ,\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [wallet_providers_1.EvmWalletProvider, void 0]),\n    __metadata(\"design:returntype\", Promise)\n], CompoundActionProvider.prototype, \"getPortfolio\", null);\n/**\n * Factory function to create a new instance of CompoundActionProvider.\n *\n * @returns A new CompoundActionProvider instance.\n */\nconst compoundActionProvider = () => new CompoundActionProvider();\nexports.compoundActionProvider = compoundActionProvider;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9jb21wb3VuZC9jb21wb3VuZEFjdGlvblByb3ZpZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFFBQVE7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw4QkFBOEIsR0FBRyw4QkFBOEI7QUFDL0QsY0FBYyxtQkFBTyxDQUFDLGtEQUFLO0FBQzNCLGVBQWUsbUJBQU8sQ0FBQyxxREFBTTtBQUM3Qix5QkFBeUIsbUJBQU8sQ0FBQywwR0FBbUI7QUFDcEQsMkJBQTJCLG1CQUFPLENBQUMsc0dBQXdCO0FBQzNELDBCQUEwQixtQkFBTyxDQUFDLDRHQUFvQjtBQUN0RCxnQkFBZ0IsbUJBQU8sQ0FBQywwRUFBYTtBQUNyQyxvQkFBb0IsbUJBQU8sQ0FBQyx3R0FBYTtBQUN6QyxrQkFBa0IsbUJBQU8sQ0FBQyxvR0FBVztBQUNyQyxnQkFBZ0IsbUJBQU8sQ0FBQyxnR0FBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxhQUFhO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLGFBQWEseUJBQXlCLFlBQVk7QUFDbEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGVBQWU7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCwwQkFBMEIsS0FBSyxxQkFBcUI7QUFDckcsK0JBQStCLGFBQWEsRUFBRSxhQUFhLGtDQUFrQyxPQUFPLEVBQUUsY0FBYztBQUNwSDtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQSxnQ0FBZ0MsY0FBYztBQUM5Qyw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsWUFBWSxrQkFBa0IsY0FBYztBQUN0SDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxhQUFhLCtEQUErRCxnQ0FBZ0M7QUFDeko7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGFBQWEsRUFBRSxhQUFhO0FBQzdELHFDQUFxQyxPQUFPO0FBQzVDLDZDQUE2QywwQkFBMEIsS0FBSyxxQkFBcUI7QUFDakc7QUFDQTtBQUNBLHVEQUF1RCxzR0FBc0csY0FBYyxVQUFVO0FBQ3JMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGFBQWEsb0VBQW9FLGdDQUFnQztBQUM1SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGFBQWE7QUFDN0MscUNBQXFDLE9BQU87QUFDNUMsNkNBQTZDLGtCQUFrQixLQUFLLGFBQWE7QUFDakY7QUFDQTtBQUNBLHFEQUFxRCxzR0FBc0csY0FBYyxVQUFVO0FBQ25MO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxhQUFhLHdCQUF3QixZQUFZO0FBQ2pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxlQUFlO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsYUFBYSxFQUFFLGFBQWE7QUFDMUQscUNBQXFDLE9BQU87QUFDNUMsOENBQThDLDBCQUEwQixLQUFLLHFCQUFxQjtBQUNsRztBQUNBO0FBQ0Esa0RBQWtELHNHQUFzRyxjQUFjLFVBQVU7QUFDaEw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsaUZBQWlGO0FBQ3hJO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QiIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cnZpdmFsLWZ1bi8uL25vZGVfbW9kdWxlcy9AY29pbmJhc2UvYWdlbnRraXQvZGlzdC9hY3Rpb24tcHJvdmlkZXJzL2NvbXBvdW5kL2NvbXBvdW5kQWN0aW9uUHJvdmlkZXIuanM/NWYzMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNvbXBvdW5kQWN0aW9uUHJvdmlkZXIgPSBleHBvcnRzLkNvbXBvdW5kQWN0aW9uUHJvdmlkZXIgPSB2b2lkIDA7XG5jb25zdCB6b2RfMSA9IHJlcXVpcmUoXCJ6b2RcIik7XG5jb25zdCB2aWVtXzEgPSByZXF1aXJlKFwidmllbVwiKTtcbmNvbnN0IGFjdGlvblByb3ZpZGVyXzEgPSByZXF1aXJlKFwiLi4vYWN0aW9uUHJvdmlkZXJcIik7XG5jb25zdCB3YWxsZXRfcHJvdmlkZXJzXzEgPSByZXF1aXJlKFwiLi4vLi4vd2FsbGV0LXByb3ZpZGVyc1wiKTtcbmNvbnN0IGFjdGlvbkRlY29yYXRvcl8xID0gcmVxdWlyZShcIi4uL2FjdGlvbkRlY29yYXRvclwiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHNcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IHNjaGVtYXNfMSA9IHJlcXVpcmUoXCIuL3NjaGVtYXNcIik7XG5jb25zdCB1dGlsc18yID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG4vKipcbiAqIENvbXBvdW5kQWN0aW9uUHJvdmlkZXIgaXMgYW4gYWN0aW9uIHByb3ZpZGVyIGZvciBDb21wb3VuZCBwcm90b2NvbCBpbnRlcmFjdGlvbnMuXG4gKi9cbmNsYXNzIENvbXBvdW5kQWN0aW9uUHJvdmlkZXIgZXh0ZW5kcyBhY3Rpb25Qcm92aWRlcl8xLkFjdGlvblByb3ZpZGVyIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IENvbXBvdW5kQWN0aW9uUHJvdmlkZXIgaW5zdGFuY2UuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKFwiY29tcG91bmRcIiwgW10pO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2tzIGlmIHRoZSBDb21wb3VuZCBhY3Rpb24gcHJvdmlkZXIgc3VwcG9ydHMgdGhlIGdpdmVuIG5ldHdvcmsuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBuZXR3b3JrIC0gVGhlIG5ldHdvcmsgdG8gY2hlY2suXG4gICAgICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIG5ldHdvcmsgaXMgc3VwcG9ydGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN1cHBvcnRzTmV0d29yayA9IChuZXR3b3JrKSA9PiBuZXR3b3JrLnByb3RvY29sRmFtaWx5ID09PSBcImV2bVwiICYmXG4gICAgICAgICAgICAobmV0d29yay5uZXR3b3JrSWQgPT09IFwiYmFzZS1tYWlubmV0XCIgfHwgbmV0d29yay5uZXR3b3JrSWQgPT09IFwiYmFzZS1zZXBvbGlhXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdXBwbGllcyBjb2xsYXRlcmFsIGFzc2V0cyB0byBDb21wb3VuZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB3YWxsZXQgLSBUaGUgd2FsbGV0IGluc3RhbmNlIHRvIHBlcmZvcm0gdGhlIHRyYW5zYWN0aW9uLlxuICAgICAqIEBwYXJhbSBhcmdzIC0gVGhlIGlucHV0IGFyZ3VtZW50cyBpbmNsdWRpbmcgYXNzZXRJZCBhbmQgYW1vdW50LlxuICAgICAqIEByZXR1cm5zIEEgbWVzc2FnZSBpbmRpY2F0aW5nIHN1Y2Nlc3Mgb3IgYW4gZXJyb3IgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBhc3luYyBzdXBwbHkod2FsbGV0LCBhcmdzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBuZXR3b3JrID0gd2FsbGV0LmdldE5ldHdvcmsoKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbWV0QWRkcmVzcyA9ICgwLCB1dGlsc18yLmdldENvbWV0QWRkcmVzcykobmV0d29yayk7XG4gICAgICAgICAgICBjb25zdCB0b2tlbkFkZHJlc3MgPSAoMCwgdXRpbHNfMi5nZXRBc3NldEFkZHJlc3MpKG5ldHdvcmssIGFyZ3MuYXNzZXRJZCk7XG4gICAgICAgICAgICBpZiAoIXRva2VuQWRkcmVzcykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVG9rZW4gYWRkcmVzcyB1bmRlZmluZWQgZm9yIGFzc2V0SWQgJHthcmdzLmFzc2V0SWR9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkZWNpbWFscyA9IGF3YWl0ICgwLCB1dGlsc18yLmdldFRva2VuRGVjaW1hbHMpKHdhbGxldCwgdG9rZW5BZGRyZXNzKTtcbiAgICAgICAgICAgIGNvbnN0IGFtb3VudEF0b21pYyA9ICgwLCB2aWVtXzEucGFyc2VVbml0cykoYXJncy5hbW91bnQsIGRlY2ltYWxzKTtcbiAgICAgICAgICAgIC8vIENoZWNrIHdhbGxldCBiYWxhbmNlIGJlZm9yZSBwcm9jZWVkaW5nXG4gICAgICAgICAgICBjb25zdCB3YWxsZXRCYWxhbmNlID0gYXdhaXQgKDAsIHV0aWxzXzIuZ2V0VG9rZW5CYWxhbmNlKSh3YWxsZXQsIHRva2VuQWRkcmVzcyk7XG4gICAgICAgICAgICBpZiAod2FsbGV0QmFsYW5jZSA8IGFtb3VudEF0b21pYykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGh1bWFuQmFsYW5jZSA9ICgwLCB2aWVtXzEuZm9ybWF0VW5pdHMpKHdhbGxldEJhbGFuY2UsIGRlY2ltYWxzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYEVycm9yOiBJbnN1ZmZpY2llbnQgYmFsYW5jZS4gWW91IGhhdmUgJHtodW1hbkJhbGFuY2V9LCBidXQgdHJ5aW5nIHRvIHN1cHBseSAke2FyZ3MuYW1vdW50fWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBHZXQgY3VycmVudCBoZWFsdGggcmF0aW8gZm9yIHJlZmVyZW5jZVxuICAgICAgICAgICAgY29uc3QgY3VycmVudEhlYWx0aCA9IGF3YWl0ICgwLCB1dGlsc18yLmdldEhlYWx0aFJhdGlvKSh3YWxsZXQsIGNvbWV0QWRkcmVzcyk7XG4gICAgICAgICAgICAvLyBBcHByb3ZlIENvbXBvdW5kIHRvIHNwZW5kIHRva2Vuc1xuICAgICAgICAgICAgY29uc3QgYXBwcm92YWxSZXN1bHQgPSBhd2FpdCAoMCwgdXRpbHNfMS5hcHByb3ZlKSh3YWxsZXQsIHRva2VuQWRkcmVzcywgY29tZXRBZGRyZXNzLCBhbW91bnRBdG9taWMpO1xuICAgICAgICAgICAgaWYgKGFwcHJvdmFsUmVzdWx0LnN0YXJ0c1dpdGgoXCJFcnJvclwiKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBgRXJyb3IgYXBwcm92aW5nIHRva2VuOiAke2FwcHJvdmFsUmVzdWx0fWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTdXBwbHkgdG9rZW5zIHRvIENvbXBvdW5kXG4gICAgICAgICAgICBjb25zdCBkYXRhID0gKDAsIHZpZW1fMS5lbmNvZGVGdW5jdGlvbkRhdGEpKHtcbiAgICAgICAgICAgICAgICBhYmk6IGNvbnN0YW50c18xLkNPTUVUX0FCSSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWU6IFwic3VwcGx5XCIsXG4gICAgICAgICAgICAgICAgYXJnczogW3Rva2VuQWRkcmVzcywgYW1vdW50QXRvbWljXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgdHhIYXNoID0gYXdhaXQgd2FsbGV0LnNlbmRUcmFuc2FjdGlvbih7XG4gICAgICAgICAgICAgICAgdG86IGNvbWV0QWRkcmVzcyxcbiAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCB3YWxsZXQud2FpdEZvclRyYW5zYWN0aW9uUmVjZWlwdCh0eEhhc2gpO1xuICAgICAgICAgICAgLy8gR2V0IG5ldyBoZWFsdGggcmF0aW8gYW5kIHRva2VuIHN5bWJvbFxuICAgICAgICAgICAgY29uc3QgbmV3SGVhbHRoID0gYXdhaXQgKDAsIHV0aWxzXzIuZ2V0SGVhbHRoUmF0aW8pKHdhbGxldCwgY29tZXRBZGRyZXNzKTtcbiAgICAgICAgICAgIGNvbnN0IHRva2VuU3ltYm9sID0gYXdhaXQgKDAsIHV0aWxzXzIuZ2V0VG9rZW5TeW1ib2wpKHdhbGxldCwgdG9rZW5BZGRyZXNzKTtcbiAgICAgICAgICAgIC8vIE9ubHkgYWRkIHRoZSBoZWFsdGggcmF0aW8gbWVzc2FnZSBpZiBhdCBsZWFzdCBvbmUgb2YgdGhlIHZhbHVlcyBpcyBub3QgSW5maW5pdHlcbiAgICAgICAgICAgIGNvbnN0IGhlYWx0aE1lc3NhZ2UgPSBjdXJyZW50SGVhbHRoLmVxKEluZmluaXR5KSAmJiBuZXdIZWFsdGguZXEoSW5maW5pdHkpXG4gICAgICAgICAgICAgICAgPyBcIlwiXG4gICAgICAgICAgICAgICAgOiBgXFxuSGVhbHRoIHJhdGlvIGNoYW5nZWQgZnJvbSAke2N1cnJlbnRIZWFsdGgudG9GaXhlZCgyKX0gdG8gJHtuZXdIZWFsdGgudG9GaXhlZCgyKX1gO1xuICAgICAgICAgICAgcmV0dXJuIGBTdXBwbGllZCAke2FyZ3MuYW1vdW50fSAke3Rva2VuU3ltYm9sfSB0byBDb21wb3VuZC5cXG5UcmFuc2FjdGlvbiBoYXNoOiAke3R4SGFzaH0ke2hlYWx0aE1lc3NhZ2V9YDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBgRXJyb3Igc3VwcGx5aW5nIHRvIENvbXBvdW5kOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3JcbiAgICAgICAgICAgICAgICA/IGVycm9yLm1lc3NhZ2VcbiAgICAgICAgICAgICAgICA6IGVycm9yICYmIHR5cGVvZiBlcnJvciA9PT0gXCJvYmplY3RcIiAmJiBcIm1lc3NhZ2VcIiBpbiBlcnJvclxuICAgICAgICAgICAgICAgICAgICA/IGBFcnJvcjogJHtlcnJvci5tZXNzYWdlfWBcbiAgICAgICAgICAgICAgICAgICAgOiBlcnJvcn1gO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdpdGhkcmF3cyBjb2xsYXRlcmFsIGFzc2V0cyBmcm9tIENvbXBvdW5kLlxuICAgICAqXG4gICAgICogQHBhcmFtIHdhbGxldCAtIFRoZSB3YWxsZXQgaW5zdGFuY2UgdG8gcGVyZm9ybSB0aGUgdHJhbnNhY3Rpb24uXG4gICAgICogQHBhcmFtIGFyZ3MgLSBUaGUgaW5wdXQgYXJndW1lbnRzIGluY2x1ZGluZyBhc3NldElkIGFuZCBhbW91bnQuXG4gICAgICogQHJldHVybnMgQSBtZXNzYWdlIGluZGljYXRpbmcgc3VjY2VzcyBvciBhbiBlcnJvciBtZXNzYWdlLlxuICAgICAqL1xuICAgIGFzeW5jIHdpdGhkcmF3KHdhbGxldCwgYXJncykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgY29tZXRBZGRyZXNzID0gKDAsIHV0aWxzXzIuZ2V0Q29tZXRBZGRyZXNzKSh3YWxsZXQuZ2V0TmV0d29yaygpKTtcbiAgICAgICAgICAgIGNvbnN0IHRva2VuQWRkcmVzcyA9ICgwLCB1dGlsc18yLmdldEFzc2V0QWRkcmVzcykod2FsbGV0LmdldE5ldHdvcmsoKSwgYXJncy5hc3NldElkKTtcbiAgICAgICAgICAgIGNvbnN0IGRlY2ltYWxzID0gYXdhaXQgKDAsIHV0aWxzXzIuZ2V0VG9rZW5EZWNpbWFscykod2FsbGV0LCB0b2tlbkFkZHJlc3MpO1xuICAgICAgICAgICAgY29uc3QgYW1vdW50QXRvbWljID0gKDAsIHZpZW1fMS5wYXJzZVVuaXRzKShhcmdzLmFtb3VudCwgZGVjaW1hbHMpO1xuICAgICAgICAgICAgLy8gQ2hlY2sgdGhhdCB0aGVyZSBpcyBlbm91Z2ggY29sbGF0ZXJhbCBzdXBwbGllZCB0byB3aXRoZHJhd1xuICAgICAgICAgICAgY29uc3QgY29sbGF0ZXJhbEJhbGFuY2UgPSBhd2FpdCAoMCwgdXRpbHNfMi5nZXRDb2xsYXRlcmFsQmFsYW5jZSkod2FsbGV0LCBjb21ldEFkZHJlc3MsIHRva2VuQWRkcmVzcyk7XG4gICAgICAgICAgICBpZiAoYW1vdW50QXRvbWljID4gY29sbGF0ZXJhbEJhbGFuY2UpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBodW1hbkJhbGFuY2UgPSAoMCwgdmllbV8xLmZvcm1hdFVuaXRzKShjb2xsYXRlcmFsQmFsYW5jZSwgZGVjaW1hbHMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBgRXJyb3I6IEluc3VmZmljaWVudCBiYWxhbmNlLiBUcnlpbmcgdG8gd2l0aGRyYXcgJHthcmdzLmFtb3VudH0sIGJ1dCBvbmx5IGhhdmUgJHtodW1hbkJhbGFuY2V9IHN1cHBsaWVkYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHBvc2l0aW9uIHdvdWxkIGJlIGhlYWx0aHkgYWZ0ZXIgd2l0aGRyYXdhbFxuICAgICAgICAgICAgY29uc3QgcHJvamVjdGVkSGVhbHRoUmF0aW8gPSBhd2FpdCAoMCwgdXRpbHNfMi5nZXRIZWFsdGhSYXRpb0FmdGVyV2l0aGRyYXcpKHdhbGxldCwgY29tZXRBZGRyZXNzLCB0b2tlbkFkZHJlc3MsIGFtb3VudEF0b21pYyk7XG4gICAgICAgICAgICBpZiAocHJvamVjdGVkSGVhbHRoUmF0aW8ubGVzc1RoYW4oMSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYEVycm9yOiBXaXRoZHJhd2luZyAke2FyZ3MuYW1vdW50fSB3b3VsZCByZXN1bHQgaW4gYW4gdW5oZWFsdGh5IHBvc2l0aW9uLiBIZWFsdGggcmF0aW8gd291bGQgYmUgJHtwcm9qZWN0ZWRIZWFsdGhSYXRpby50b0ZpeGVkKDIpfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXaXRoZHJhdyBmcm9tIENvbXBvdW5kXG4gICAgICAgICAgICBjb25zdCBkYXRhID0gKDAsIHZpZW1fMS5lbmNvZGVGdW5jdGlvbkRhdGEpKHtcbiAgICAgICAgICAgICAgICBhYmk6IGNvbnN0YW50c18xLkNPTUVUX0FCSSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWU6IFwid2l0aGRyYXdcIixcbiAgICAgICAgICAgICAgICBhcmdzOiBbdG9rZW5BZGRyZXNzLCBhbW91bnRBdG9taWNdLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCB0eEhhc2ggPSBhd2FpdCB3YWxsZXQuc2VuZFRyYW5zYWN0aW9uKHtcbiAgICAgICAgICAgICAgICB0bzogY29tZXRBZGRyZXNzLFxuICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IHdhbGxldC53YWl0Rm9yVHJhbnNhY3Rpb25SZWNlaXB0KHR4SGFzaCk7XG4gICAgICAgICAgICAvLyBHZXQgY3VycmVudCBhbmQgbmV3IGhlYWx0aCByYXRpb3MgYW5kIHRva2VuIHN5bWJvbFxuICAgICAgICAgICAgY29uc3QgY3VycmVudEhlYWx0aCA9IGF3YWl0ICgwLCB1dGlsc18yLmdldEhlYWx0aFJhdGlvKSh3YWxsZXQsIGNvbWV0QWRkcmVzcyk7XG4gICAgICAgICAgICBjb25zdCBuZXdIZWFsdGggPSBhd2FpdCAoMCwgdXRpbHNfMi5nZXRIZWFsdGhSYXRpbykod2FsbGV0LCBjb21ldEFkZHJlc3MpO1xuICAgICAgICAgICAgY29uc3QgdG9rZW5TeW1ib2wgPSBhd2FpdCAoMCwgdXRpbHNfMi5nZXRUb2tlblN5bWJvbCkod2FsbGV0LCB0b2tlbkFkZHJlc3MpO1xuICAgICAgICAgICAgcmV0dXJuIChgV2l0aGRyYXduICR7YXJncy5hbW91bnR9ICR7dG9rZW5TeW1ib2x9IGZyb20gQ29tcG91bmQuXFxuYCArXG4gICAgICAgICAgICAgICAgYFRyYW5zYWN0aW9uIGhhc2g6ICR7dHhIYXNofVxcbmAgK1xuICAgICAgICAgICAgICAgIGBIZWFsdGggcmF0aW8gY2hhbmdlZCBmcm9tICR7Y3VycmVudEhlYWx0aC50b0ZpeGVkKDIpfSB0byAke25ld0hlYWx0aC50b0ZpeGVkKDIpfWApO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGBFcnJvciB3aXRoZHJhd2luZyBmcm9tIENvbXBvdW5kOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvciA6IGVycm9yICYmIHR5cGVvZiBlcnJvciA9PT0gXCJvYmplY3RcIiAmJiBcIm1lc3NhZ2VcIiBpbiBlcnJvciA/IGBFcnJvcjogJHtlcnJvci5tZXNzYWdlfWAgOiBlcnJvcn1gO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJvcnJvd3MgYmFzZSBhc3NldHMgZnJvbSBDb21wb3VuZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB3YWxsZXQgLSBUaGUgd2FsbGV0IGluc3RhbmNlIHRvIHBlcmZvcm0gdGhlIHRyYW5zYWN0aW9uLlxuICAgICAqIEBwYXJhbSBhcmdzIC0gVGhlIGlucHV0IGFyZ3VtZW50cyBpbmNsdWRpbmcgYXNzZXRJZCBhbmQgYW1vdW50LlxuICAgICAqIEByZXR1cm5zIEEgbWVzc2FnZSBpbmRpY2F0aW5nIHN1Y2Nlc3Mgb3IgYW4gZXJyb3IgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBhc3luYyBib3Jyb3cod2FsbGV0LCBhcmdzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBjb21ldEFkZHJlc3MgPSAoMCwgdXRpbHNfMi5nZXRDb21ldEFkZHJlc3MpKHdhbGxldC5nZXROZXR3b3JrKCkpO1xuICAgICAgICAgICAgY29uc3QgYmFzZVRva2VuQWRkcmVzcyA9IGF3YWl0ICgwLCB1dGlsc18yLmdldEJhc2VUb2tlbkFkZHJlc3MpKHdhbGxldCwgY29tZXRBZGRyZXNzKTtcbiAgICAgICAgICAgIGNvbnN0IGRlY2ltYWxzID0gYXdhaXQgKDAsIHV0aWxzXzIuZ2V0VG9rZW5EZWNpbWFscykod2FsbGV0LCBiYXNlVG9rZW5BZGRyZXNzKTtcbiAgICAgICAgICAgIC8vIENvbnZlcnQgaHVtYW4tcmVhZGFibGUgYW1vdW50IHRvIGF0b21pYyB1bml0c1xuICAgICAgICAgICAgY29uc3QgYW1vdW50QXRvbWljID0gKDAsIHZpZW1fMS5wYXJzZVVuaXRzKShhcmdzLmFtb3VudCwgZGVjaW1hbHMpO1xuICAgICAgICAgICAgLy8gR2V0IGN1cnJlbnQgaGVhbHRoIHJhdGlvIGZvciByZWZlcmVuY2VcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRIZWFsdGggPSBhd2FpdCAoMCwgdXRpbHNfMi5nZXRIZWFsdGhSYXRpbykod2FsbGV0LCBjb21ldEFkZHJlc3MpO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudEhlYWx0aFN0ciA9IGN1cnJlbnRIZWFsdGguZXEoSW5maW5pdHkpID8gXCJJbmYuJVwiIDogY3VycmVudEhlYWx0aC50b0ZpeGVkKDIpO1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgcG9zaXRpb24gd291bGQgYmUgaGVhbHRoeSBhZnRlciBib3Jyb3dcbiAgICAgICAgICAgIGNvbnN0IHByb2plY3RlZEhlYWx0aFJhdGlvID0gYXdhaXQgKDAsIHV0aWxzXzIuZ2V0SGVhbHRoUmF0aW9BZnRlckJvcnJvdykod2FsbGV0LCBjb21ldEFkZHJlc3MsIGFtb3VudEF0b21pYyk7XG4gICAgICAgICAgICBpZiAocHJvamVjdGVkSGVhbHRoUmF0aW8ubGVzc1RoYW4oMSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYEVycm9yOiBCb3Jyb3dpbmcgJHthcmdzLmFtb3VudH0gVVNEQyB3b3VsZCByZXN1bHQgaW4gYW4gdW5oZWFsdGh5IHBvc2l0aW9uLiBIZWFsdGggcmF0aW8gd291bGQgYmUgJHtwcm9qZWN0ZWRIZWFsdGhSYXRpby50b0ZpeGVkKDIpfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBVc2UgdGhlIHdpdGhkcmF3IG1ldGhvZCB0byBib3Jyb3cgZnJvbSBDb21wb3VuZFxuICAgICAgICAgICAgY29uc3QgZGF0YSA9ICgwLCB2aWVtXzEuZW5jb2RlRnVuY3Rpb25EYXRhKSh7XG4gICAgICAgICAgICAgICAgYWJpOiBjb25zdGFudHNfMS5DT01FVF9BQkksXG4gICAgICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiBcIndpdGhkcmF3XCIsXG4gICAgICAgICAgICAgICAgYXJnczogW2Jhc2VUb2tlbkFkZHJlc3MsIGFtb3VudEF0b21pY10sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHR4SGFzaCA9IGF3YWl0IHdhbGxldC5zZW5kVHJhbnNhY3Rpb24oe1xuICAgICAgICAgICAgICAgIHRvOiBjb21ldEFkZHJlc3MsXG4gICAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgd2FsbGV0LndhaXRGb3JUcmFuc2FjdGlvblJlY2VpcHQodHhIYXNoKTtcbiAgICAgICAgICAgIC8vIEdldCBuZXcgaGVhbHRoIHJhdGlvXG4gICAgICAgICAgICBjb25zdCBuZXdIZWFsdGggPSBhd2FpdCAoMCwgdXRpbHNfMi5nZXRIZWFsdGhSYXRpbykod2FsbGV0LCBjb21ldEFkZHJlc3MpO1xuICAgICAgICAgICAgY29uc3QgbmV3SGVhbHRoU3RyID0gbmV3SGVhbHRoLmVxKEluZmluaXR5KSA/IFwiSW5mLiVcIiA6IG5ld0hlYWx0aC50b0ZpeGVkKDIpO1xuICAgICAgICAgICAgcmV0dXJuIChgQm9ycm93ZWQgJHthcmdzLmFtb3VudH0gVVNEQyBmcm9tIENvbXBvdW5kLlxcbmAgK1xuICAgICAgICAgICAgICAgIGBUcmFuc2FjdGlvbiBoYXNoOiAke3R4SGFzaH1cXG5gICtcbiAgICAgICAgICAgICAgICBgSGVhbHRoIHJhdGlvIGNoYW5nZWQgZnJvbSAke2N1cnJlbnRIZWFsdGhTdHJ9IHRvICR7bmV3SGVhbHRoU3RyfWApO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGBFcnJvciBib3Jyb3dpbmcgZnJvbSBDb21wb3VuZDogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IgOiBlcnJvciAmJiB0eXBlb2YgZXJyb3IgPT09IFwib2JqZWN0XCIgJiYgXCJtZXNzYWdlXCIgaW4gZXJyb3IgPyBgRXJyb3I6ICR7ZXJyb3IubWVzc2FnZX1gIDogZXJyb3J9YDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXBheXMgYm9ycm93ZWQgYXNzZXRzIHRvIENvbXBvdW5kLlxuICAgICAqXG4gICAgICogQHBhcmFtIHdhbGxldCAtIFRoZSB3YWxsZXQgaW5zdGFuY2UgdG8gcGVyZm9ybSB0aGUgdHJhbnNhY3Rpb24uXG4gICAgICogQHBhcmFtIGFyZ3MgLSBUaGUgaW5wdXQgYXJndW1lbnRzIGluY2x1ZGluZyBhc3NldElkIGFuZCBhbW91bnQuXG4gICAgICogQHJldHVybnMgQSBtZXNzYWdlIGluZGljYXRpbmcgc3VjY2VzcyBvciBhbiBlcnJvciBtZXNzYWdlLlxuICAgICAqL1xuICAgIGFzeW5jIHJlcGF5KHdhbGxldCwgYXJncykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgY29tZXRBZGRyZXNzID0gKDAsIHV0aWxzXzIuZ2V0Q29tZXRBZGRyZXNzKSh3YWxsZXQuZ2V0TmV0d29yaygpKTtcbiAgICAgICAgICAgIGNvbnN0IHRva2VuQWRkcmVzcyA9ICgwLCB1dGlsc18yLmdldEFzc2V0QWRkcmVzcykod2FsbGV0LmdldE5ldHdvcmsoKSwgYXJncy5hc3NldElkKTtcbiAgICAgICAgICAgIGNvbnN0IHRva2VuRGVjaW1hbHMgPSBhd2FpdCAoMCwgdXRpbHNfMi5nZXRUb2tlbkRlY2ltYWxzKSh3YWxsZXQsIHRva2VuQWRkcmVzcyk7XG4gICAgICAgICAgICBjb25zdCBhbW91bnRBdG9taWMgPSAoMCwgdmllbV8xLnBhcnNlVW5pdHMpKGFyZ3MuYW1vdW50LCB0b2tlbkRlY2ltYWxzKTtcbiAgICAgICAgICAgIGNvbnN0IHRva2VuQmFsYW5jZSA9IGF3YWl0ICgwLCB1dGlsc18yLmdldFRva2VuQmFsYW5jZSkod2FsbGV0LCB0b2tlbkFkZHJlc3MpO1xuICAgICAgICAgICAgaWYgKHRva2VuQmFsYW5jZSA8IGFtb3VudEF0b21pYykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGh1bWFuQmFsYW5jZSA9ICgwLCB2aWVtXzEuZm9ybWF0VW5pdHMpKHRva2VuQmFsYW5jZSwgdG9rZW5EZWNpbWFscyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGBFcnJvcjogSW5zdWZmaWNpZW50IGJhbGFuY2UuIFlvdSBoYXZlICR7aHVtYW5CYWxhbmNlfSwgYnV0IHRyeWluZyB0byByZXBheSAke2FyZ3MuYW1vdW50fWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBHZXQgY3VycmVudCBoZWFsdGggcmF0aW8gZm9yIHJlZmVyZW5jZVxuICAgICAgICAgICAgY29uc3QgY3VycmVudEhlYWx0aCA9IGF3YWl0ICgwLCB1dGlsc18yLmdldEhlYWx0aFJhdGlvKSh3YWxsZXQsIGNvbWV0QWRkcmVzcyk7XG4gICAgICAgICAgICAvLyBBcHByb3ZlIENvbXBvdW5kIHRvIHNwZW5kIHRva2Vuc1xuICAgICAgICAgICAgY29uc3QgYXBwcm92YWxSZXN1bHQgPSBhd2FpdCAoMCwgdXRpbHNfMS5hcHByb3ZlKSh3YWxsZXQsIHRva2VuQWRkcmVzcywgY29tZXRBZGRyZXNzLCBhbW91bnRBdG9taWMpO1xuICAgICAgICAgICAgaWYgKGFwcHJvdmFsUmVzdWx0LnN0YXJ0c1dpdGgoXCJFcnJvclwiKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBgRXJyb3IgYXBwcm92aW5nIHRva2VuOiAke2FwcHJvdmFsUmVzdWx0fWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZXBheSBkZWJ0IGJ5IHN1cHBseWluZyB0b2tlbnMgdG8gQ29tcG91bmRcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSAoMCwgdmllbV8xLmVuY29kZUZ1bmN0aW9uRGF0YSkoe1xuICAgICAgICAgICAgICAgIGFiaTogY29uc3RhbnRzXzEuQ09NRVRfQUJJLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogXCJzdXBwbHlcIixcbiAgICAgICAgICAgICAgICBhcmdzOiBbdG9rZW5BZGRyZXNzLCBhbW91bnRBdG9taWNdLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCB0eEhhc2ggPSBhd2FpdCB3YWxsZXQuc2VuZFRyYW5zYWN0aW9uKHtcbiAgICAgICAgICAgICAgICB0bzogY29tZXRBZGRyZXNzLFxuICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IHdhbGxldC53YWl0Rm9yVHJhbnNhY3Rpb25SZWNlaXB0KHR4SGFzaCk7XG4gICAgICAgICAgICAvLyBHZXQgbmV3IGhlYWx0aCByYXRpbyBhbmQgdG9rZW4gc3ltYm9sXG4gICAgICAgICAgICBjb25zdCBuZXdIZWFsdGggPSBhd2FpdCAoMCwgdXRpbHNfMi5nZXRIZWFsdGhSYXRpbykod2FsbGV0LCBjb21ldEFkZHJlc3MpO1xuICAgICAgICAgICAgY29uc3QgdG9rZW5TeW1ib2wgPSBhd2FpdCAoMCwgdXRpbHNfMi5nZXRUb2tlblN5bWJvbCkod2FsbGV0LCB0b2tlbkFkZHJlc3MpO1xuICAgICAgICAgICAgcmV0dXJuIChgUmVwYWlkICR7YXJncy5hbW91bnR9ICR7dG9rZW5TeW1ib2x9IHRvIENvbXBvdW5kLlxcbmAgK1xuICAgICAgICAgICAgICAgIGBUcmFuc2FjdGlvbiBoYXNoOiAke3R4SGFzaH1cXG5gICtcbiAgICAgICAgICAgICAgICBgSGVhbHRoIHJhdGlvIGltcHJvdmVkIGZyb20gJHtjdXJyZW50SGVhbHRoLnRvRml4ZWQoMil9IHRvICR7bmV3SGVhbHRoLnRvRml4ZWQoMil9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gYEVycm9yIHJlcGF5aW5nIHRvIENvbXBvdW5kOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvciA6IGVycm9yICYmIHR5cGVvZiBlcnJvciA9PT0gXCJvYmplY3RcIiAmJiBcIm1lc3NhZ2VcIiBpbiBlcnJvciA/IGBFcnJvcjogJHtlcnJvci5tZXNzYWdlfWAgOiBlcnJvcn1gO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBwb3J0Zm9saW8gZGV0YWlscyBmcm9tIENvbXBvdW5kLlxuICAgICAqXG4gICAgICogQHBhcmFtIHdhbGxldCAtIFRoZSB3YWxsZXQgaW5zdGFuY2UgdG8gZmV0Y2ggcG9ydGZvbGlvIGRldGFpbHMuXG4gICAgICogQHBhcmFtIF8gLSBObyBpbnB1dCBpcyByZXF1aXJlZCBmb3IgdGhpcyBhY3Rpb24uXG4gICAgICogQHJldHVybnMgQSBNYXJrZG93biBmb3JtYXR0ZWQgc3RyaW5nIHdpdGggcG9ydGZvbGlvIGRldGFpbHMgb3IgYW4gZXJyb3IgbWVzc2FnZS5cbiAgICAgKi9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgYXN5bmMgZ2V0UG9ydGZvbGlvKHdhbGxldCwgXykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgY29tZXRBZGRyZXNzID0gKDAsIHV0aWxzXzIuZ2V0Q29tZXRBZGRyZXNzKSh3YWxsZXQuZ2V0TmV0d29yaygpKTtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCAoMCwgdXRpbHNfMi5nZXRQb3J0Zm9saW9EZXRhaWxzTWFya2Rvd24pKHdhbGxldCwgY29tZXRBZGRyZXNzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBgRXJyb3IgZ2V0dGluZyBwb3J0Zm9saW8gZGV0YWlsczogJHtlcnJvciAmJiB0eXBlb2YgZXJyb3IgPT09IFwib2JqZWN0XCIgJiYgXCJtZXNzYWdlXCIgaW4gZXJyb3IgPyBlcnJvci5tZXNzYWdlIDogZXJyb3J9YDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQ29tcG91bmRBY3Rpb25Qcm92aWRlciA9IENvbXBvdW5kQWN0aW9uUHJvdmlkZXI7XG5fX2RlY29yYXRlKFtcbiAgICAoMCwgYWN0aW9uRGVjb3JhdG9yXzEuQ3JlYXRlQWN0aW9uKSh7XG4gICAgICAgIG5hbWU6IFwic3VwcGx5XCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgXG5UaGlzIHRvb2wgYWxsb3dzIHN1cHBseWluZyBjb2xsYXRlcmFsIGFzc2V0cyB0byBDb21wb3VuZC5cbkl0IHRha2VzOlxuLSBhc3NldElkOiBUaGUgYXNzZXQgdG8gc3VwcGx5LCBvbmUgb2YgJ3dldGgnLCAnY2JldGgnLCAnY2JidGMnLCAnd3N0ZXRoJywgb3IgJ3VzZGMnXG4tIGFtb3VudDogVGhlIGFtb3VudCBvZiB0b2tlbnMgdG8gc3VwcGx5IGluIGh1bWFuLXJlYWRhYmxlIGZvcm1hdFxuRXhhbXBsZXM6XG4tIDEgV0VUSFxuLSAwLjEgV0VUSFxuLSAwLjAxIFdFVEhcbkltcG9ydGFudCBub3Rlczpcbi0gVXNlIHRoZSBleGFjdCBhbW91bnQgcHJvdmlkZWRcbi0gVGhlIHRva2VuIG11c3QgYmUgYW4gYXBwcm92ZWQgY29sbGF0ZXJhbCBhc3NldCBmb3IgdGhlIENvbXBvdW5kIG1hcmtldFxuICAgIGAsXG4gICAgICAgIHNjaGVtYTogc2NoZW1hc18xLkNvbXBvdW5kU3VwcGx5U2NoZW1hLFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFt3YWxsZXRfcHJvdmlkZXJzXzEuRXZtV2FsbGV0UHJvdmlkZXIsIHZvaWQgMF0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCBQcm9taXNlKVxuXSwgQ29tcG91bmRBY3Rpb25Qcm92aWRlci5wcm90b3R5cGUsIFwic3VwcGx5XCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgKDAsIGFjdGlvbkRlY29yYXRvcl8xLkNyZWF0ZUFjdGlvbikoe1xuICAgICAgICBuYW1lOiBcIndpdGhkcmF3XCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgXG5UaGlzIHRvb2wgYWxsb3dzIHdpdGhkcmF3aW5nIGNvbGxhdGVyYWwgYXNzZXRzIGZyb20gQ29tcG91bmQuXG5JdCB0YWtlczpcbi0gYXNzZXRJZDogVGhlIGFzc2V0IHRvIHdpdGhkcmF3LCBvbmUgb2YgJ3dldGgnLCAnY2JldGgnLCAnY2JidGMnLCAnd3N0ZXRoJywgb3IgJ3VzZGMnXG4tIGFtb3VudDogVGhlIGFtb3VudCBvZiB0b2tlbnMgdG8gd2l0aGRyYXcgaW4gaHVtYW4tcmVhZGFibGUgZm9ybWF0XG5FeGFtcGxlczpcbi0gMSBXRVRIXG4tIDAuMSBXRVRIXG4tIDAuMDEgV0VUSFxuSW1wb3J0YW50IG5vdGVzOlxuLSBVc2UgdGhlIGV4YWN0IGFtb3VudCBwcm92aWRlZFxuLSBUaGUgdG9rZW4gbXVzdCBiZSBhIGNvbGxhdGVyYWwgYXNzZXQgeW91IGhhdmUgc3VwcGxpZWQgdG8gdGhlIENvbXBvdW5kIG1hcmtldFxuICAgIGAsXG4gICAgICAgIHNjaGVtYTogc2NoZW1hc18xLkNvbXBvdW5kV2l0aGRyYXdTY2hlbWEsXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW3dhbGxldF9wcm92aWRlcnNfMS5Fdm1XYWxsZXRQcm92aWRlciwgdm9pZCAwXSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIFByb21pc2UpXG5dLCBDb21wb3VuZEFjdGlvblByb3ZpZGVyLnByb3RvdHlwZSwgXCJ3aXRoZHJhd1wiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgICgwLCBhY3Rpb25EZWNvcmF0b3JfMS5DcmVhdGVBY3Rpb24pKHtcbiAgICAgICAgbmFtZTogXCJib3Jyb3dcIixcbiAgICAgICAgZGVzY3JpcHRpb246IGBcblRoaXMgdG9vbCBhbGxvd3MgYm9ycm93aW5nIGJhc2UgYXNzZXRzIGZyb20gQ29tcG91bmQuXG5JdCB0YWtlczpcbi0gYXNzZXRJZDogVGhlIGFzc2V0IHRvIGJvcnJvdywgZWl0aGVyICd3ZXRoJyBvciAndXNkYydcbi0gYW1vdW50OiBUaGUgYW1vdW50IG9mIGJhc2UgdG9rZW5zIHRvIGJvcnJvdyBpbiBodW1hbi1yZWFkYWJsZSBmb3JtYXRcbkV4YW1wbGVzOlxuLSAxMDAwIFVTRENcbi0gMC41IFdFVEhcbkltcG9ydGFudCBub3Rlczpcbi0gVXNlIHRoZSBleGFjdCBhbW91bnQgcHJvdmlkZWRcbi0gRW5zdXJlIHlvdSBoYXZlIHN1ZmZpY2llbnQgY29sbGF0ZXJhbCB0byBib3Jyb3dcbiAgICBgLFxuICAgICAgICBzY2hlbWE6IHNjaGVtYXNfMS5Db21wb3VuZEJvcnJvd1NjaGVtYSxcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbd2FsbGV0X3Byb3ZpZGVyc18xLkV2bVdhbGxldFByb3ZpZGVyLCB2b2lkIDBdKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgUHJvbWlzZSlcbl0sIENvbXBvdW5kQWN0aW9uUHJvdmlkZXIucHJvdG90eXBlLCBcImJvcnJvd1wiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgICgwLCBhY3Rpb25EZWNvcmF0b3JfMS5DcmVhdGVBY3Rpb24pKHtcbiAgICAgICAgbmFtZTogXCJyZXBheVwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogYFxuVGhpcyB0b29sIGFsbG93cyByZXBheWluZyBib3Jyb3dlZCBhc3NldHMgdG8gQ29tcG91bmQuXG5JdCB0YWtlczpcbi0gYXNzZXRJZDogVGhlIGFzc2V0IHRvIHJlcGF5LCBlaXRoZXIgJ3dldGgnIG9yICd1c2RjJ1xuLSBhbW91bnQ6IFRoZSBhbW91bnQgb2YgdG9rZW5zIHRvIHJlcGF5IGluIGh1bWFuLXJlYWRhYmxlIGZvcm1hdFxuRXhhbXBsZXM6XG4tIDEwMDAgVVNEQ1xuLSAwLjUgV0VUSFxuSW1wb3J0YW50IG5vdGVzOlxuLSBVc2UgdGhlIGV4YWN0IGFtb3VudCBwcm92aWRlZFxuLSBFbnN1cmUgeW91IGhhdmUgc3VmZmljaWVudCBiYWxhbmNlIG9mIHRoZSBhc3NldCB0byByZXBheVxuICAgIGAsXG4gICAgICAgIHNjaGVtYTogc2NoZW1hc18xLkNvbXBvdW5kUmVwYXlTY2hlbWEsXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW3dhbGxldF9wcm92aWRlcnNfMS5Fdm1XYWxsZXRQcm92aWRlciwgdm9pZCAwXSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIFByb21pc2UpXG5dLCBDb21wb3VuZEFjdGlvblByb3ZpZGVyLnByb3RvdHlwZSwgXCJyZXBheVwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgICgwLCBhY3Rpb25EZWNvcmF0b3JfMS5DcmVhdGVBY3Rpb24pKHtcbiAgICAgICAgbmFtZTogXCJnZXRfcG9ydGZvbGlvXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgXG5UaGlzIHRvb2wgYWxsb3dzIGdldHRpbmcgcG9ydGZvbGlvIGRldGFpbHMgZnJvbSBDb21wb3VuZC5cblJldHVybnMgcG9ydGZvbGlvIGRldGFpbHMgaW5jbHVkaW5nOlxuLSBDb2xsYXRlcmFsIGJhbGFuY2VzIGFuZCBVU0QgdmFsdWVzXG4tIEJvcnJvd2VkIGFtb3VudHMgYW5kIFVTRCB2YWx1ZXNcbkZvcm1hdHRlZCBpbiBNYXJrZG93biBmb3IgcmVhZGFiaWxpdHkuXG4gICAgYCxcbiAgICAgICAgc2NoZW1hOiBzY2hlbWFzXzEuQ29tcG91bmRQb3J0Zm9saW9TY2hlbWEsXG4gICAgfSlcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFt3YWxsZXRfcHJvdmlkZXJzXzEuRXZtV2FsbGV0UHJvdmlkZXIsIHZvaWQgMF0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCBQcm9taXNlKVxuXSwgQ29tcG91bmRBY3Rpb25Qcm92aWRlci5wcm90b3R5cGUsIFwiZ2V0UG9ydGZvbGlvXCIsIG51bGwpO1xuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIHRvIGNyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiBDb21wb3VuZEFjdGlvblByb3ZpZGVyLlxuICpcbiAqIEByZXR1cm5zIEEgbmV3IENvbXBvdW5kQWN0aW9uUHJvdmlkZXIgaW5zdGFuY2UuXG4gKi9cbmNvbnN0IGNvbXBvdW5kQWN0aW9uUHJvdmlkZXIgPSAoKSA9PiBuZXcgQ29tcG91bmRBY3Rpb25Qcm92aWRlcigpO1xuZXhwb3J0cy5jb21wb3VuZEFjdGlvblByb3ZpZGVyID0gY29tcG91bmRBY3Rpb25Qcm92aWRlcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/compound/compoundActionProvider.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/compound/constants.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/compound/constants.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PRICE_FEED_ABI = exports.COMET_ABI = exports.ERC20_ABI = exports.ASSET_ADDRESSES = exports.COMET_ADDRESSES = exports.SUPPORTED_NETWORKS = void 0;\nconst constants_1 = __webpack_require__(/*! ../erc20/constants */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/erc20/constants.js\");\nObject.defineProperty(exports, \"ERC20_ABI\", ({ enumerable: true, get: function () { return constants_1.abi; } }));\nexports.SUPPORTED_NETWORKS = [\"base-mainnet\", \"base-sepolia\"];\nexports.COMET_ADDRESSES = {\n    \"base-mainnet\": \"0xb125E6687d4313864e53df431d5425969c15Eb2F\",\n    \"base-sepolia\": \"0x571621Ce60Cebb0c1D442B5afb38B1663C6Bf017\",\n};\nexports.ASSET_ADDRESSES = {\n    \"base-mainnet\": {\n        weth: \"0x4200000000000000000000000000000000000006\",\n        cbeth: \"0x2Ae3F1Ec7F1F5012CFEab0185bfc7aa3cf0DEc22\",\n        cbbtc: \"0xcbB7C0000aB88B473b1f5aFd9ef808440eed33Bf\",\n        wsteth: \"0xc1CBa3fCea344f92D9239c08C0568f6F2F0ee452\",\n        usdc: \"0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913\",\n    },\n    \"base-sepolia\": {\n        weth: \"0x4200000000000000000000000000000000000006\",\n        usdc: \"0x036CbD53842c5426634e7929541eC2318f3dCF7e\",\n        wsteth: \"0x774eD9EDB0C5202dF9A86183804b5D9E99dC6CA3\",\n    },\n};\nexports.COMET_ABI = [\n    {\n        inputs: [\n            { internalType: \"address\", name: \"asset\", type: \"address\" },\n            { internalType: \"uint256\", name: \"amount\", type: \"uint256\" },\n        ],\n        name: \"supply\",\n        outputs: [],\n        stateMutability: \"nonpayable\",\n        type: \"function\",\n    },\n    {\n        inputs: [\n            { internalType: \"address\", name: \"asset\", type: \"address\" },\n            { internalType: \"uint256\", name: \"amount\", type: \"uint256\" },\n        ],\n        name: \"withdraw\",\n        outputs: [],\n        stateMutability: \"nonpayable\",\n        type: \"function\",\n    },\n    {\n        inputs: [{ internalType: \"address\", name: \"priceFeed\", type: \"address\" }],\n        name: \"getPrice\",\n        outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n        stateMutability: \"view\",\n        type: \"function\",\n    },\n    {\n        inputs: [{ internalType: \"address\", name: \"account\", type: \"address\" }],\n        name: \"borrowBalanceOf\",\n        outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n        stateMutability: \"view\",\n        type: \"function\",\n    },\n    {\n        inputs: [],\n        name: \"numAssets\",\n        outputs: [{ internalType: \"uint8\", name: \"\", type: \"uint8\" }],\n        stateMutability: \"view\",\n        type: \"function\",\n    },\n    {\n        inputs: [{ internalType: \"uint8\", name: \"i\", type: \"uint8\" }],\n        name: \"getAssetInfo\",\n        outputs: [\n            {\n                components: [\n                    { internalType: \"uint8\", name: \"offset\", type: \"uint8\" },\n                    { internalType: \"address\", name: \"asset\", type: \"address\" },\n                    { internalType: \"address\", name: \"priceFeed\", type: \"address\" },\n                    { internalType: \"uint64\", name: \"scale\", type: \"uint64\" },\n                    { internalType: \"uint64\", name: \"borrowCollateralFactor\", type: \"uint64\" },\n                    { internalType: \"uint64\", name: \"liquidateCollateralFactor\", type: \"uint64\" },\n                    { internalType: \"uint64\", name: \"liquidationFactor\", type: \"uint64\" },\n                    { internalType: \"uint128\", name: \"supplyCap\", type: \"uint128\" },\n                ],\n                internalType: \"struct CometCore.AssetInfo\",\n                name: \"\",\n                type: \"tuple\",\n            },\n        ],\n        stateMutability: \"view\",\n        type: \"function\",\n    },\n    {\n        inputs: [],\n        name: \"baseToken\",\n        outputs: [{ internalType: \"address\", name: \"\", type: \"address\" }],\n        stateMutability: \"view\",\n        type: \"function\",\n    },\n    {\n        inputs: [],\n        name: \"baseTokenPriceFeed\",\n        outputs: [{ internalType: \"address\", name: \"\", type: \"address\" }],\n        stateMutability: \"view\",\n        type: \"function\",\n    },\n    {\n        inputs: [\n            { internalType: \"address\", name: \"account\", type: \"address\" },\n            { internalType: \"address\", name: \"asset\", type: \"address\" },\n        ],\n        name: \"collateralBalanceOf\",\n        outputs: [{ internalType: \"uint128\", name: \"balance\", type: \"uint128\" }],\n        stateMutability: \"view\",\n        type: \"function\",\n    },\n];\nexports.PRICE_FEED_ABI = [\n    {\n        inputs: [],\n        name: \"latestRoundData\",\n        outputs: [\n            { name: \"roundId\", type: \"uint80\" },\n            { name: \"answer\", type: \"int256\" },\n            { name: \"startedAt\", type: \"uint256\" },\n            { name: \"updatedAt\", type: \"uint256\" },\n            { name: \"answeredInRound\", type: \"uint80\" },\n        ],\n        stateMutability: \"view\",\n        type: \"function\",\n    },\n];\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9jb21wb3VuZC9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsc0JBQXNCLEdBQUcsaUJBQWlCLEdBQUcsaUJBQWlCLEdBQUcsdUJBQXVCLEdBQUcsdUJBQXVCLEdBQUcsMEJBQTBCO0FBQy9JLG9CQUFvQixtQkFBTyxDQUFDLDRHQUFvQjtBQUNoRCw2Q0FBNEMsRUFBRSxxQ0FBcUMsMkJBQTJCLEVBQUM7QUFDL0csMEJBQTBCO0FBQzFCLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxjQUFjLHlEQUF5RDtBQUN2RSxjQUFjLDBEQUEwRDtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxjQUFjLHlEQUF5RDtBQUN2RSxjQUFjLDBEQUEwRDtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsbUJBQW1CLDZEQUE2RDtBQUNoRjtBQUNBLG9CQUFvQixvREFBb0Q7QUFDeEU7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLG1CQUFtQiwyREFBMkQ7QUFDOUU7QUFDQSxvQkFBb0Isb0RBQW9EO0FBQ3hFO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdEQUFnRDtBQUNwRTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsbUJBQW1CLGlEQUFpRDtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzREFBc0Q7QUFDNUUsc0JBQXNCLHlEQUF5RDtBQUMvRSxzQkFBc0IsNkRBQTZEO0FBQ25GLHNCQUFzQix1REFBdUQ7QUFDN0Usc0JBQXNCLHdFQUF3RTtBQUM5RixzQkFBc0IsMkVBQTJFO0FBQ2pHLHNCQUFzQixtRUFBbUU7QUFDekYsc0JBQXNCLDZEQUE2RDtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9EQUFvRDtBQUN4RTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvREFBb0Q7QUFDeEU7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsY0FBYywyREFBMkQ7QUFDekUsY0FBYyx5REFBeUQ7QUFDdkU7QUFDQTtBQUNBLG9CQUFvQiwyREFBMkQ7QUFDL0U7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsaUNBQWlDO0FBQy9DLGNBQWMsZ0NBQWdDO0FBQzlDLGNBQWMsb0NBQW9DO0FBQ2xELGNBQWMsb0NBQW9DO0FBQ2xELGNBQWMseUNBQXlDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cnZpdmFsLWZ1bi8uL25vZGVfbW9kdWxlcy9AY29pbmJhc2UvYWdlbnRraXQvZGlzdC9hY3Rpb24tcHJvdmlkZXJzL2NvbXBvdW5kL2NvbnN0YW50cy5qcz9kYTViIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5QUklDRV9GRUVEX0FCSSA9IGV4cG9ydHMuQ09NRVRfQUJJID0gZXhwb3J0cy5FUkMyMF9BQkkgPSBleHBvcnRzLkFTU0VUX0FERFJFU1NFUyA9IGV4cG9ydHMuQ09NRVRfQUREUkVTU0VTID0gZXhwb3J0cy5TVVBQT1JURURfTkVUV09SS1MgPSB2b2lkIDA7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuLi9lcmMyMC9jb25zdGFudHNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJFUkMyMF9BQklcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbnN0YW50c18xLmFiaTsgfSB9KTtcbmV4cG9ydHMuU1VQUE9SVEVEX05FVFdPUktTID0gW1wiYmFzZS1tYWlubmV0XCIsIFwiYmFzZS1zZXBvbGlhXCJdO1xuZXhwb3J0cy5DT01FVF9BRERSRVNTRVMgPSB7XG4gICAgXCJiYXNlLW1haW5uZXRcIjogXCIweGIxMjVFNjY4N2Q0MzEzODY0ZTUzZGY0MzFkNTQyNTk2OWMxNUViMkZcIixcbiAgICBcImJhc2Utc2Vwb2xpYVwiOiBcIjB4NTcxNjIxQ2U2MENlYmIwYzFENDQyQjVhZmIzOEIxNjYzQzZCZjAxN1wiLFxufTtcbmV4cG9ydHMuQVNTRVRfQUREUkVTU0VTID0ge1xuICAgIFwiYmFzZS1tYWlubmV0XCI6IHtcbiAgICAgICAgd2V0aDogXCIweDQyMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDZcIixcbiAgICAgICAgY2JldGg6IFwiMHgyQWUzRjFFYzdGMUY1MDEyQ0ZFYWIwMTg1YmZjN2FhM2NmMERFYzIyXCIsXG4gICAgICAgIGNiYnRjOiBcIjB4Y2JCN0MwMDAwYUI4OEI0NzNiMWY1YUZkOWVmODA4NDQwZWVkMzNCZlwiLFxuICAgICAgICB3c3RldGg6IFwiMHhjMUNCYTNmQ2VhMzQ0ZjkyRDkyMzljMDhDMDU2OGY2RjJGMGVlNDUyXCIsXG4gICAgICAgIHVzZGM6IFwiMHg4MzM1ODlmQ0Q2ZURiNkUwOGY0YzdDMzJENGY3MWI1NGJkQTAyOTEzXCIsXG4gICAgfSxcbiAgICBcImJhc2Utc2Vwb2xpYVwiOiB7XG4gICAgICAgIHdldGg6IFwiMHg0MjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA2XCIsXG4gICAgICAgIHVzZGM6IFwiMHgwMzZDYkQ1Mzg0MmM1NDI2NjM0ZTc5Mjk1NDFlQzIzMThmM2RDRjdlXCIsXG4gICAgICAgIHdzdGV0aDogXCIweDc3NGVEOUVEQjBDNTIwMmRGOUE4NjE4MzgwNGI1RDlFOTlkQzZDQTNcIixcbiAgICB9LFxufTtcbmV4cG9ydHMuQ09NRVRfQUJJID0gW1xuICAgIHtcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7IGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsIG5hbWU6IFwiYXNzZXRcIiwgdHlwZTogXCJhZGRyZXNzXCIgfSxcbiAgICAgICAgICAgIHsgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIiwgbmFtZTogXCJhbW91bnRcIiwgdHlwZTogXCJ1aW50MjU2XCIgfSxcbiAgICAgICAgXSxcbiAgICAgICAgbmFtZTogXCJzdXBwbHlcIixcbiAgICAgICAgb3V0cHV0czogW10sXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogXCJub25wYXlhYmxlXCIsXG4gICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICB9LFxuICAgIHtcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7IGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsIG5hbWU6IFwiYXNzZXRcIiwgdHlwZTogXCJhZGRyZXNzXCIgfSxcbiAgICAgICAgICAgIHsgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIiwgbmFtZTogXCJhbW91bnRcIiwgdHlwZTogXCJ1aW50MjU2XCIgfSxcbiAgICAgICAgXSxcbiAgICAgICAgbmFtZTogXCJ3aXRoZHJhd1wiLFxuICAgICAgICBvdXRwdXRzOiBbXSxcbiAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiBcIm5vbnBheWFibGVcIixcbiAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgIH0sXG4gICAge1xuICAgICAgICBpbnB1dHM6IFt7IGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsIG5hbWU6IFwicHJpY2VGZWVkXCIsIHR5cGU6IFwiYWRkcmVzc1wiIH1dLFxuICAgICAgICBuYW1lOiBcImdldFByaWNlXCIsXG4gICAgICAgIG91dHB1dHM6IFt7IGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsIG5hbWU6IFwiXCIsIHR5cGU6IFwidWludDI1NlwiIH1dLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6IFwidmlld1wiLFxuICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlucHV0czogW3sgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIiwgbmFtZTogXCJhY2NvdW50XCIsIHR5cGU6IFwiYWRkcmVzc1wiIH1dLFxuICAgICAgICBuYW1lOiBcImJvcnJvd0JhbGFuY2VPZlwiLFxuICAgICAgICBvdXRwdXRzOiBbeyBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLCBuYW1lOiBcIlwiLCB0eXBlOiBcInVpbnQyNTZcIiB9XSxcbiAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIixcbiAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgIH0sXG4gICAge1xuICAgICAgICBpbnB1dHM6IFtdLFxuICAgICAgICBuYW1lOiBcIm51bUFzc2V0c1wiLFxuICAgICAgICBvdXRwdXRzOiBbeyBpbnRlcm5hbFR5cGU6IFwidWludDhcIiwgbmFtZTogXCJcIiwgdHlwZTogXCJ1aW50OFwiIH1dLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6IFwidmlld1wiLFxuICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlucHV0czogW3sgaW50ZXJuYWxUeXBlOiBcInVpbnQ4XCIsIG5hbWU6IFwiaVwiLCB0eXBlOiBcInVpbnQ4XCIgfV0sXG4gICAgICAgIG5hbWU6IFwiZ2V0QXNzZXRJbmZvXCIsXG4gICAgICAgIG91dHB1dHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzOiBbXG4gICAgICAgICAgICAgICAgICAgIHsgaW50ZXJuYWxUeXBlOiBcInVpbnQ4XCIsIG5hbWU6IFwib2Zmc2V0XCIsIHR5cGU6IFwidWludDhcIiB9LFxuICAgICAgICAgICAgICAgICAgICB7IGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsIG5hbWU6IFwiYXNzZXRcIiwgdHlwZTogXCJhZGRyZXNzXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgeyBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLCBuYW1lOiBcInByaWNlRmVlZFwiLCB0eXBlOiBcImFkZHJlc3NcIiB9LFxuICAgICAgICAgICAgICAgICAgICB7IGludGVybmFsVHlwZTogXCJ1aW50NjRcIiwgbmFtZTogXCJzY2FsZVwiLCB0eXBlOiBcInVpbnQ2NFwiIH0sXG4gICAgICAgICAgICAgICAgICAgIHsgaW50ZXJuYWxUeXBlOiBcInVpbnQ2NFwiLCBuYW1lOiBcImJvcnJvd0NvbGxhdGVyYWxGYWN0b3JcIiwgdHlwZTogXCJ1aW50NjRcIiB9LFxuICAgICAgICAgICAgICAgICAgICB7IGludGVybmFsVHlwZTogXCJ1aW50NjRcIiwgbmFtZTogXCJsaXF1aWRhdGVDb2xsYXRlcmFsRmFjdG9yXCIsIHR5cGU6IFwidWludDY0XCIgfSxcbiAgICAgICAgICAgICAgICAgICAgeyBpbnRlcm5hbFR5cGU6IFwidWludDY0XCIsIG5hbWU6IFwibGlxdWlkYXRpb25GYWN0b3JcIiwgdHlwZTogXCJ1aW50NjRcIiB9LFxuICAgICAgICAgICAgICAgICAgICB7IGludGVybmFsVHlwZTogXCJ1aW50MTI4XCIsIG5hbWU6IFwic3VwcGx5Q2FwXCIsIHR5cGU6IFwidWludDEyOFwiIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6IFwic3RydWN0IENvbWV0Q29yZS5Bc3NldEluZm9cIixcbiAgICAgICAgICAgICAgICBuYW1lOiBcIlwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwidHVwbGVcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICB9LFxuICAgIHtcbiAgICAgICAgaW5wdXRzOiBbXSxcbiAgICAgICAgbmFtZTogXCJiYXNlVG9rZW5cIixcbiAgICAgICAgb3V0cHV0czogW3sgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIiwgbmFtZTogXCJcIiwgdHlwZTogXCJhZGRyZXNzXCIgfV0sXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICB9LFxuICAgIHtcbiAgICAgICAgaW5wdXRzOiBbXSxcbiAgICAgICAgbmFtZTogXCJiYXNlVG9rZW5QcmljZUZlZWRcIixcbiAgICAgICAgb3V0cHV0czogW3sgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIiwgbmFtZTogXCJcIiwgdHlwZTogXCJhZGRyZXNzXCIgfV0sXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICB9LFxuICAgIHtcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7IGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsIG5hbWU6IFwiYWNjb3VudFwiLCB0eXBlOiBcImFkZHJlc3NcIiB9LFxuICAgICAgICAgICAgeyBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLCBuYW1lOiBcImFzc2V0XCIsIHR5cGU6IFwiYWRkcmVzc1wiIH0sXG4gICAgICAgIF0sXG4gICAgICAgIG5hbWU6IFwiY29sbGF0ZXJhbEJhbGFuY2VPZlwiLFxuICAgICAgICBvdXRwdXRzOiBbeyBpbnRlcm5hbFR5cGU6IFwidWludDEyOFwiLCBuYW1lOiBcImJhbGFuY2VcIiwgdHlwZTogXCJ1aW50MTI4XCIgfV0sXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICB9LFxuXTtcbmV4cG9ydHMuUFJJQ0VfRkVFRF9BQkkgPSBbXG4gICAge1xuICAgICAgICBpbnB1dHM6IFtdLFxuICAgICAgICBuYW1lOiBcImxhdGVzdFJvdW5kRGF0YVwiLFxuICAgICAgICBvdXRwdXRzOiBbXG4gICAgICAgICAgICB7IG5hbWU6IFwicm91bmRJZFwiLCB0eXBlOiBcInVpbnQ4MFwiIH0sXG4gICAgICAgICAgICB7IG5hbWU6IFwiYW5zd2VyXCIsIHR5cGU6IFwiaW50MjU2XCIgfSxcbiAgICAgICAgICAgIHsgbmFtZTogXCJzdGFydGVkQXRcIiwgdHlwZTogXCJ1aW50MjU2XCIgfSxcbiAgICAgICAgICAgIHsgbmFtZTogXCJ1cGRhdGVkQXRcIiwgdHlwZTogXCJ1aW50MjU2XCIgfSxcbiAgICAgICAgICAgIHsgbmFtZTogXCJhbnN3ZXJlZEluUm91bmRcIiwgdHlwZTogXCJ1aW50ODBcIiB9LFxuICAgICAgICBdLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6IFwidmlld1wiLFxuICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgfSxcbl07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/compound/constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/compound/index.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/compound/index.js ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./compoundActionProvider */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/compound/compoundActionProvider.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9jb21wb3VuZC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxhQUFhLG1CQUFPLENBQUMsa0lBQTBCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3Vydml2YWwtZnVuLy4vbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9hZ2VudGtpdC9kaXN0L2FjdGlvbi1wcm92aWRlcnMvY29tcG91bmQvaW5kZXguanM/MDQxMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NvbXBvdW5kQWN0aW9uUHJvdmlkZXJcIiksIGV4cG9ydHMpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/compound/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/compound/schemas.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/compound/schemas.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CompoundPortfolioSchema = exports.CompoundRepaySchema = exports.CompoundBorrowSchema = exports.CompoundWithdrawSchema = exports.CompoundSupplySchema = void 0;\nconst zod_1 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/lib/index.js\");\n/**\n * Input schema for Compound supply action.\n */\nexports.CompoundSupplySchema = zod_1.z\n    .object({\n    assetId: zod_1.z.enum([\"weth\", \"cbeth\", \"cbbtc\", \"wsteth\", \"usdc\"]).describe(\"The asset to supply\"),\n    amount: zod_1.z\n        .string()\n        .regex(/^\\d+(\\.\\d+)?$/, \"Must be a valid integer or decimal value\")\n        .describe(\"The amount of tokens to supply in human-readable format\"),\n})\n    .describe(\"Input schema for Compound supply action\");\n/**\n * Input schema for Compound withdraw action.\n */\nexports.CompoundWithdrawSchema = zod_1.z\n    .object({\n    assetId: zod_1.z.enum([\"weth\", \"cbeth\", \"cbbtc\", \"wsteth\", \"usdc\"]).describe(\"The asset to withdraw\"),\n    amount: zod_1.z\n        .string()\n        .regex(/^\\d+(\\.\\d+)?$/, \"Must be a valid integer or decimal value\")\n        .describe(\"The amount of tokens to withdraw in human-readable format\"),\n})\n    .describe(\"Input schema for Compound withdraw action\");\n/**\n * Input schema for Compound borrow action.\n */\nexports.CompoundBorrowSchema = zod_1.z\n    .object({\n    assetId: zod_1.z.enum([\"weth\", \"usdc\"]).describe(\"The asset to borrow\"),\n    amount: zod_1.z\n        .string()\n        .regex(/^\\d+(\\.\\d+)?$/, \"Must be a valid integer or decimal value\")\n        .describe(\"The amount of base tokens to borrow in human-readable format\"),\n})\n    .describe(\"Input schema for Compound borrow action\");\n/**\n * Input schema for Compound repay action.\n */\nexports.CompoundRepaySchema = zod_1.z\n    .object({\n    assetId: zod_1.z.enum([\"weth\", \"usdc\"]).describe(\"The asset to repay\"),\n    amount: zod_1.z\n        .string()\n        .regex(/^\\d+(\\.\\d+)?$/, \"Must be a valid integer or decimal value\")\n        .describe(\"The amount of tokens to repay in human-readable format\"),\n})\n    .describe(\"Input schema for Compound repay action\");\n/**\n * Input schema for Compound get portfolio action.\n */\nexports.CompoundPortfolioSchema = zod_1.z\n    .object({})\n    .describe(\"Input schema for Compound get portfolio action\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9jb21wb3VuZC9zY2hlbWFzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELCtCQUErQixHQUFHLDJCQUEyQixHQUFHLDRCQUE0QixHQUFHLDhCQUE4QixHQUFHLDRCQUE0QjtBQUM1SixjQUFjLG1CQUFPLENBQUMsa0RBQUs7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQixjQUFjO0FBQ2QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXJ2aXZhbC1mdW4vLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9jb21wb3VuZC9zY2hlbWFzLmpzPzdmODMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvbXBvdW5kUG9ydGZvbGlvU2NoZW1hID0gZXhwb3J0cy5Db21wb3VuZFJlcGF5U2NoZW1hID0gZXhwb3J0cy5Db21wb3VuZEJvcnJvd1NjaGVtYSA9IGV4cG9ydHMuQ29tcG91bmRXaXRoZHJhd1NjaGVtYSA9IGV4cG9ydHMuQ29tcG91bmRTdXBwbHlTY2hlbWEgPSB2b2lkIDA7XG5jb25zdCB6b2RfMSA9IHJlcXVpcmUoXCJ6b2RcIik7XG4vKipcbiAqIElucHV0IHNjaGVtYSBmb3IgQ29tcG91bmQgc3VwcGx5IGFjdGlvbi5cbiAqL1xuZXhwb3J0cy5Db21wb3VuZFN1cHBseVNjaGVtYSA9IHpvZF8xLnpcbiAgICAub2JqZWN0KHtcbiAgICBhc3NldElkOiB6b2RfMS56LmVudW0oW1wid2V0aFwiLCBcImNiZXRoXCIsIFwiY2JidGNcIiwgXCJ3c3RldGhcIiwgXCJ1c2RjXCJdKS5kZXNjcmliZShcIlRoZSBhc3NldCB0byBzdXBwbHlcIiksXG4gICAgYW1vdW50OiB6b2RfMS56XG4gICAgICAgIC5zdHJpbmcoKVxuICAgICAgICAucmVnZXgoL15cXGQrKFxcLlxcZCspPyQvLCBcIk11c3QgYmUgYSB2YWxpZCBpbnRlZ2VyIG9yIGRlY2ltYWwgdmFsdWVcIilcbiAgICAgICAgLmRlc2NyaWJlKFwiVGhlIGFtb3VudCBvZiB0b2tlbnMgdG8gc3VwcGx5IGluIGh1bWFuLXJlYWRhYmxlIGZvcm1hdFwiKSxcbn0pXG4gICAgLmRlc2NyaWJlKFwiSW5wdXQgc2NoZW1hIGZvciBDb21wb3VuZCBzdXBwbHkgYWN0aW9uXCIpO1xuLyoqXG4gKiBJbnB1dCBzY2hlbWEgZm9yIENvbXBvdW5kIHdpdGhkcmF3IGFjdGlvbi5cbiAqL1xuZXhwb3J0cy5Db21wb3VuZFdpdGhkcmF3U2NoZW1hID0gem9kXzEuelxuICAgIC5vYmplY3Qoe1xuICAgIGFzc2V0SWQ6IHpvZF8xLnouZW51bShbXCJ3ZXRoXCIsIFwiY2JldGhcIiwgXCJjYmJ0Y1wiLCBcIndzdGV0aFwiLCBcInVzZGNcIl0pLmRlc2NyaWJlKFwiVGhlIGFzc2V0IHRvIHdpdGhkcmF3XCIpLFxuICAgIGFtb3VudDogem9kXzEuelxuICAgICAgICAuc3RyaW5nKClcbiAgICAgICAgLnJlZ2V4KC9eXFxkKyhcXC5cXGQrKT8kLywgXCJNdXN0IGJlIGEgdmFsaWQgaW50ZWdlciBvciBkZWNpbWFsIHZhbHVlXCIpXG4gICAgICAgIC5kZXNjcmliZShcIlRoZSBhbW91bnQgb2YgdG9rZW5zIHRvIHdpdGhkcmF3IGluIGh1bWFuLXJlYWRhYmxlIGZvcm1hdFwiKSxcbn0pXG4gICAgLmRlc2NyaWJlKFwiSW5wdXQgc2NoZW1hIGZvciBDb21wb3VuZCB3aXRoZHJhdyBhY3Rpb25cIik7XG4vKipcbiAqIElucHV0IHNjaGVtYSBmb3IgQ29tcG91bmQgYm9ycm93IGFjdGlvbi5cbiAqL1xuZXhwb3J0cy5Db21wb3VuZEJvcnJvd1NjaGVtYSA9IHpvZF8xLnpcbiAgICAub2JqZWN0KHtcbiAgICBhc3NldElkOiB6b2RfMS56LmVudW0oW1wid2V0aFwiLCBcInVzZGNcIl0pLmRlc2NyaWJlKFwiVGhlIGFzc2V0IHRvIGJvcnJvd1wiKSxcbiAgICBhbW91bnQ6IHpvZF8xLnpcbiAgICAgICAgLnN0cmluZygpXG4gICAgICAgIC5yZWdleCgvXlxcZCsoXFwuXFxkKyk/JC8sIFwiTXVzdCBiZSBhIHZhbGlkIGludGVnZXIgb3IgZGVjaW1hbCB2YWx1ZVwiKVxuICAgICAgICAuZGVzY3JpYmUoXCJUaGUgYW1vdW50IG9mIGJhc2UgdG9rZW5zIHRvIGJvcnJvdyBpbiBodW1hbi1yZWFkYWJsZSBmb3JtYXRcIiksXG59KVxuICAgIC5kZXNjcmliZShcIklucHV0IHNjaGVtYSBmb3IgQ29tcG91bmQgYm9ycm93IGFjdGlvblwiKTtcbi8qKlxuICogSW5wdXQgc2NoZW1hIGZvciBDb21wb3VuZCByZXBheSBhY3Rpb24uXG4gKi9cbmV4cG9ydHMuQ29tcG91bmRSZXBheVNjaGVtYSA9IHpvZF8xLnpcbiAgICAub2JqZWN0KHtcbiAgICBhc3NldElkOiB6b2RfMS56LmVudW0oW1wid2V0aFwiLCBcInVzZGNcIl0pLmRlc2NyaWJlKFwiVGhlIGFzc2V0IHRvIHJlcGF5XCIpLFxuICAgIGFtb3VudDogem9kXzEuelxuICAgICAgICAuc3RyaW5nKClcbiAgICAgICAgLnJlZ2V4KC9eXFxkKyhcXC5cXGQrKT8kLywgXCJNdXN0IGJlIGEgdmFsaWQgaW50ZWdlciBvciBkZWNpbWFsIHZhbHVlXCIpXG4gICAgICAgIC5kZXNjcmliZShcIlRoZSBhbW91bnQgb2YgdG9rZW5zIHRvIHJlcGF5IGluIGh1bWFuLXJlYWRhYmxlIGZvcm1hdFwiKSxcbn0pXG4gICAgLmRlc2NyaWJlKFwiSW5wdXQgc2NoZW1hIGZvciBDb21wb3VuZCByZXBheSBhY3Rpb25cIik7XG4vKipcbiAqIElucHV0IHNjaGVtYSBmb3IgQ29tcG91bmQgZ2V0IHBvcnRmb2xpbyBhY3Rpb24uXG4gKi9cbmV4cG9ydHMuQ29tcG91bmRQb3J0Zm9saW9TY2hlbWEgPSB6b2RfMS56XG4gICAgLm9iamVjdCh7fSlcbiAgICAuZGVzY3JpYmUoXCJJbnB1dCBzY2hlbWEgZm9yIENvbXBvdW5kIGdldCBwb3J0Zm9saW8gYWN0aW9uXCIpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/compound/schemas.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/compound/utils.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/compound/utils.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getBaseTokenAddress = exports.getAssetAddress = exports.getCometAddress = exports.getPortfolioDetailsMarkdown = exports.getHealthRatioAfterBorrow = exports.getHealthRatioAfterWithdraw = exports.getHealthRatio = exports.getCollateralBalance = exports.getTokenBalance = exports.getTokenSymbol = exports.getTokenDecimals = void 0;\nconst decimal_js_1 = __webpack_require__(/*! decimal.js */ \"(rsc)/./node_modules/decimal.js/decimal.js\");\nconst viem_1 = __webpack_require__(/*! viem */ \"(rsc)/./node_modules/viem/_cjs/index.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/compound/constants.js\");\nconst constants_2 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/compound/constants.js\");\n/**\n * Get token decimals from contract\n *\n * @param wallet - The wallet provider instance\n * @param tokenAddress - The address of the token contract\n * @returns The number of decimals for the token\n */\nconst getTokenDecimals = async (wallet, tokenAddress) => {\n    const decimals = await wallet.readContract({\n        address: tokenAddress,\n        abi: constants_1.ERC20_ABI,\n        functionName: \"decimals\",\n    });\n    return Number(decimals);\n};\nexports.getTokenDecimals = getTokenDecimals;\n/**\n * Get token symbol from contract\n *\n * @param wallet - The wallet provider instance\n * @param tokenAddress - The address of the token contract\n * @returns The symbol of the token\n */\nconst getTokenSymbol = async (wallet, tokenAddress) => {\n    const symbol = await wallet.readContract({\n        address: tokenAddress,\n        abi: constants_1.ERC20_ABI,\n        functionName: \"symbol\",\n    });\n    return symbol;\n};\nexports.getTokenSymbol = getTokenSymbol;\n/**\n * Get token balance for an address\n *\n * @param wallet - The wallet provider instance\n * @param tokenAddress - The address of the token contract\n * @returns The token balance as a bigint\n */\nconst getTokenBalance = async (wallet, tokenAddress) => {\n    const balance = await wallet.readContract({\n        address: tokenAddress,\n        abi: constants_1.ERC20_ABI,\n        functionName: \"balanceOf\",\n        args: [wallet.getAddress()],\n    });\n    return balance;\n};\nexports.getTokenBalance = getTokenBalance;\n/**\n * Get collateral balance for an address\n *\n * @param wallet - The wallet provider instance\n * @param cometAddress - The address of the Comet contract\n * @param tokenAddress - The address of the token contract\n * @returns The collateral balance as a bigint\n */\nconst getCollateralBalance = async (wallet, cometAddress, tokenAddress) => {\n    const balance = await wallet.readContract({\n        address: cometAddress,\n        abi: constants_1.COMET_ABI,\n        functionName: \"collateralBalanceOf\",\n        args: [(await wallet.getAddress()), tokenAddress],\n    });\n    return balance;\n};\nexports.getCollateralBalance = getCollateralBalance;\n/**\n * Get health ratio for an account\n *\n * @param wallet - The wallet provider instance\n * @param cometAddress - The address of the Comet contract\n * @returns The health ratio as a Decimal\n */\nconst getHealthRatio = async (wallet, cometAddress) => {\n    const borrowDetails = await getBorrowDetails(wallet, cometAddress);\n    const supplyDetails = await getSupplyDetails(wallet, cometAddress);\n    const borrowValue = borrowDetails.borrowAmount.mul(borrowDetails.price);\n    let totalAdjustedCollateral = new decimal_js_1.Decimal(0);\n    for (const supply of supplyDetails) {\n        const collateralValue = supply.supplyAmount.mul(supply.price);\n        const adjustedValue = collateralValue.mul(supply.collateralFactor);\n        totalAdjustedCollateral = totalAdjustedCollateral.add(adjustedValue);\n    }\n    return borrowValue.eq(0) ? new decimal_js_1.Decimal(Infinity) : totalAdjustedCollateral.div(borrowValue);\n};\nexports.getHealthRatio = getHealthRatio;\n/**\n * Get health ratio after a hypothetical withdraw\n *\n * @param wallet - The wallet provider instance\n * @param cometAddress - The address of the Comet contract\n * @param tokenAddress - The address of the token contract\n * @param amount - The amount to withdraw\n * @returns The health ratio after withdraw as a Decimal\n */\nconst getHealthRatioAfterWithdraw = async (wallet, cometAddress, tokenAddress, amount) => {\n    const borrowDetails = await getBorrowDetails(wallet, cometAddress);\n    const supplyDetails = await getSupplyDetails(wallet, cometAddress);\n    const borrowValue = borrowDetails.borrowAmount.mul(borrowDetails.price);\n    let totalAdjustedCollateral = new decimal_js_1.Decimal(0);\n    for (const supply of supplyDetails) {\n        const supplyTokenSymbol = supply.tokenSymbol;\n        const withdrawTokenSymbol = await (0, exports.getTokenSymbol)(wallet, tokenAddress);\n        if (supplyTokenSymbol === withdrawTokenSymbol) {\n            const decimals = await (0, exports.getTokenDecimals)(wallet, tokenAddress);\n            const withdrawAmountHuman = new decimal_js_1.Decimal((0, viem_1.formatUnits)(amount, decimals));\n            const newSupplyAmount = supply.supplyAmount.sub(withdrawAmountHuman);\n            const assetValue = newSupplyAmount.mul(supply.price);\n            totalAdjustedCollateral = totalAdjustedCollateral.add(assetValue.mul(supply.collateralFactor));\n        }\n        else {\n            totalAdjustedCollateral = totalAdjustedCollateral.add(supply.supplyAmount.mul(supply.price).mul(supply.collateralFactor));\n        }\n    }\n    return borrowValue.eq(0) ? new decimal_js_1.Decimal(Infinity) : totalAdjustedCollateral.div(borrowValue);\n};\nexports.getHealthRatioAfterWithdraw = getHealthRatioAfterWithdraw;\n/**\n * Get health ratio after a hypothetical borrow\n *\n * @param wallet - The wallet provider instance\n * @param cometAddress - The address of the Comet contract\n * @param amount - The amount to borrow\n * @returns The health ratio after borrow as a Decimal\n */\nconst getHealthRatioAfterBorrow = async (wallet, cometAddress, amount) => {\n    const borrowDetails = await getBorrowDetails(wallet, cometAddress);\n    const supplyDetails = await getSupplyDetails(wallet, cometAddress);\n    const baseToken = await (0, exports.getBaseTokenAddress)(wallet, cometAddress);\n    const baseDecimals = await (0, exports.getTokenDecimals)(wallet, baseToken);\n    const additionalBorrow = new decimal_js_1.Decimal((0, viem_1.formatUnits)(amount, baseDecimals));\n    const newBorrow = borrowDetails.borrowAmount.add(additionalBorrow);\n    const newBorrowValue = newBorrow.mul(borrowDetails.price);\n    let totalAdjustedCollateral = new decimal_js_1.Decimal(0);\n    for (const supply of supplyDetails) {\n        totalAdjustedCollateral = totalAdjustedCollateral.add(supply.supplyAmount.mul(supply.price).mul(supply.collateralFactor));\n    }\n    return newBorrowValue.eq(0) ? new decimal_js_1.Decimal(Infinity) : totalAdjustedCollateral.div(newBorrowValue);\n};\nexports.getHealthRatioAfterBorrow = getHealthRatioAfterBorrow;\n/**\n * Get portfolio details in markdown format\n *\n * @param wallet - The wallet provider instance\n * @param cometAddress - The address of the Comet contract\n * @returns A markdown formatted string with portfolio details\n */\nconst getPortfolioDetailsMarkdown = async (wallet, cometAddress) => {\n    let markdownOutput = \"# Portfolio Details\\n\\n\";\n    markdownOutput += \"## Supply Details\\n\\n\";\n    let totalSupplyValue = new decimal_js_1.Decimal(0);\n    const supplyDetails = await getSupplyDetails(wallet, cometAddress);\n    if (supplyDetails.length > 0) {\n        for (const supply of supplyDetails) {\n            const token = supply.tokenSymbol;\n            const supplyAmount = supply.supplyAmount;\n            const price = supply.price;\n            const decimals = supply.decimals;\n            const collateralFactor = supply.collateralFactor;\n            const assetValue = supplyAmount.mul(price);\n            markdownOutput += `### ${token}\\n`;\n            markdownOutput += `- **Supply Amount:** ${supplyAmount.toFixed(decimals)}\\n`;\n            markdownOutput += `- **Price:** $${price.toFixed(2)}\\n`;\n            markdownOutput += `- **Collateral Factor:** ${collateralFactor.toFixed(2)}\\n`;\n            markdownOutput += `- **Asset Value:** $${assetValue.toFixed(2)}\\n\\n`;\n            totalSupplyValue = totalSupplyValue.add(assetValue);\n        }\n    }\n    else {\n        markdownOutput += \"No supplied assets found in your Compound position.\\n\\n\";\n    }\n    markdownOutput += `### Total Supply Value: $${totalSupplyValue.toFixed(2)}\\n\\n`;\n    markdownOutput += \"## Borrow Details\\n\\n\";\n    const borrowDetails = await getBorrowDetails(wallet, cometAddress);\n    if (borrowDetails.borrowAmount.gt(0)) {\n        const token = borrowDetails.tokenSymbol;\n        const price = borrowDetails.price;\n        const borrowValue = borrowDetails.borrowAmount.mul(price);\n        markdownOutput += `### ${token}\\n`;\n        markdownOutput += `- **Borrow Amount:** ${borrowDetails.borrowAmount.toFixed(6)}\\n`;\n        markdownOutput += `- **Price:** $${price.toFixed(2)}\\n`;\n        markdownOutput += `- **Borrow Value:** $${borrowValue.toFixed(2)}\\n\\n`;\n    }\n    else {\n        markdownOutput += \"No borrowed assets found in your Compound position.\\n\\n\";\n    }\n    markdownOutput += \"## Overall Health\\n\\n\";\n    const healthRatio = await (0, exports.getHealthRatio)(wallet, cometAddress);\n    markdownOutput += `- **Health Ratio:** ${healthRatio.toFixed(2)}\\n`;\n    return markdownOutput;\n};\nexports.getPortfolioDetailsMarkdown = getPortfolioDetailsMarkdown;\n/**\n * Fetch the latest price feed data.\n *\n * @param wallet - The wallet provider instance\n * @param priceFeedAddress - The address of the price feed contract\n * @returns A tuple containing the price and timestamp\n */\nconst getPriceFeedData = async (wallet, priceFeedAddress) => {\n    const latestData = await wallet.readContract({\n        address: priceFeedAddress,\n        abi: constants_1.PRICE_FEED_ABI,\n        functionName: \"latestRoundData\",\n        args: [],\n    });\n    const answer = latestData[1].toString();\n    const updatedAt = Number(latestData[3]);\n    return [answer, updatedAt];\n};\n/**\n * Retrieve borrow details: amount, base token symbol, and price.\n *\n * @param wallet - The wallet provider instance\n * @param cometAddress - The address of the Comet contract\n * @returns An object containing borrow details\n */\nconst getBorrowDetails = async (wallet, cometAddress) => {\n    const borrowAmountRaw = await wallet.readContract({\n        address: cometAddress,\n        abi: constants_1.COMET_ABI,\n        functionName: \"borrowBalanceOf\",\n        args: [(await wallet.getAddress())],\n    });\n    const baseToken = await (0, exports.getBaseTokenAddress)(wallet, cometAddress);\n    const baseDecimals = await (0, exports.getTokenDecimals)(wallet, baseToken);\n    const baseTokenSymbol = await (0, exports.getTokenSymbol)(wallet, baseToken);\n    const basePriceFeed = await wallet.readContract({\n        address: cometAddress,\n        abi: constants_1.COMET_ABI,\n        functionName: \"baseTokenPriceFeed\",\n        args: [],\n    });\n    const [basePriceRaw] = await getPriceFeedData(wallet, basePriceFeed);\n    const humanBorrowAmount = new decimal_js_1.Decimal((0, viem_1.formatUnits)(borrowAmountRaw, baseDecimals));\n    const price = new decimal_js_1.Decimal(basePriceRaw).div(new decimal_js_1.Decimal(10).pow(8));\n    return { tokenSymbol: baseTokenSymbol, borrowAmount: humanBorrowAmount, price };\n};\n/**\n * Retrieve supply details across all collateral assets.\n *\n * @param wallet - The wallet provider instance\n * @param cometAddress - The address of the Comet contract\n * @returns An array of supply details for each asset\n */\nconst getSupplyDetails = async (wallet, cometAddress) => {\n    const numAssets = await wallet.readContract({\n        address: cometAddress,\n        abi: constants_1.COMET_ABI,\n        functionName: \"numAssets\",\n        args: [],\n    });\n    const supplyDetails = [];\n    for (let i = 0; i < numAssets; i++) {\n        const assetInfo = await wallet.readContract({\n            address: cometAddress,\n            abi: constants_1.COMET_ABI,\n            functionName: \"getAssetInfo\",\n            args: [i],\n        });\n        const assetAddress = assetInfo.asset;\n        const collateralBalance = await (0, exports.getCollateralBalance)(wallet, cometAddress, assetAddress);\n        if (collateralBalance > 0n) {\n            const tokenSymbol = await (0, exports.getTokenSymbol)(wallet, assetAddress);\n            const decimals = await (0, exports.getTokenDecimals)(wallet, assetAddress);\n            const [priceRaw] = await getPriceFeedData(wallet, assetInfo.priceFeed);\n            const humanSupplyAmount = new decimal_js_1.Decimal((0, viem_1.formatUnits)(collateralBalance, decimals));\n            const price = new decimal_js_1.Decimal(priceRaw).div(new decimal_js_1.Decimal(10).pow(8));\n            const collateralFactor = new decimal_js_1.Decimal(assetInfo.borrowCollateralFactor.toString()).div(new decimal_js_1.Decimal(10).pow(18));\n            supplyDetails.push({\n                tokenSymbol,\n                supplyAmount: humanSupplyAmount,\n                price,\n                collateralFactor,\n                decimals,\n            });\n        }\n    }\n    return supplyDetails;\n};\n/**\n * Gets the Comet address for the current network.\n *\n * @param network - The network instance\n * @returns The Comet contract address\n */\nconst getCometAddress = (network) => {\n    if (!network.networkId) {\n        throw new Error(\"Network ID is required\");\n    }\n    if (network.networkId === \"base-mainnet\") {\n        return constants_2.COMET_ADDRESSES[\"base-mainnet\"];\n    }\n    else if (network.networkId === \"base-sepolia\") {\n        return constants_2.COMET_ADDRESSES[\"base-sepolia\"];\n    }\n    throw new Error(`Network ${network.networkId} not supported`);\n};\nexports.getCometAddress = getCometAddress;\n/**\n * Gets the asset address for a given assetId on the current network.\n *\n * @param network - The network instance\n * @param assetId - The identifier of the asset\n * @returns The asset contract address\n */\nconst getAssetAddress = (network, assetId) => {\n    if (!network.networkId) {\n        throw new Error(\"Network ID is required\");\n    }\n    const normalizedAssetId = assetId.toLowerCase();\n    if (network.networkId === \"base-mainnet\") {\n        const address = constants_2.ASSET_ADDRESSES[\"base-mainnet\"][normalizedAssetId];\n        if (!address) {\n            throw new Error(`Asset ${assetId} not supported on Base Mainnet`);\n        }\n        return address;\n    }\n    else if (network.networkId === \"base-sepolia\") {\n        const address = constants_2.ASSET_ADDRESSES[\"base-sepolia\"][normalizedAssetId];\n        if (!address) {\n            throw new Error(`Asset ${assetId} not supported on Base Sepolia`);\n        }\n        return address;\n    }\n    throw new Error(`Network ${network.networkId} not supported`);\n};\nexports.getAssetAddress = getAssetAddress;\n/**\n * Get the base token address for a Compound market\n *\n * @param wallet - The wallet provider instance\n * @param cometAddress - The address of the Comet contract\n * @returns The base token address\n */\nconst getBaseTokenAddress = async (wallet, cometAddress) => {\n    const baseToken = await wallet.readContract({\n        address: cometAddress,\n        abi: constants_1.COMET_ABI,\n        functionName: \"baseToken\",\n        args: [],\n    });\n    return baseToken;\n};\nexports.getBaseTokenAddress = getBaseTokenAddress;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9jb21wb3VuZC91dGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwyQkFBMkIsR0FBRyx1QkFBdUIsR0FBRyx1QkFBdUIsR0FBRyxtQ0FBbUMsR0FBRyxpQ0FBaUMsR0FBRyxtQ0FBbUMsR0FBRyxzQkFBc0IsR0FBRyw0QkFBNEIsR0FBRyx1QkFBdUIsR0FBRyxzQkFBc0IsR0FBRyx3QkFBd0I7QUFDclUscUJBQXFCLG1CQUFPLENBQUMsOERBQVk7QUFDekMsZUFBZSxtQkFBTyxDQUFDLHFEQUFNO0FBQzdCLG9CQUFvQixtQkFBTyxDQUFDLHdHQUFhO0FBQ3pDLG9CQUFvQixtQkFBTyxDQUFDLHdHQUFhO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE1BQU07QUFDM0Msc0RBQXNELCtCQUErQjtBQUNyRiwrQ0FBK0MsaUJBQWlCO0FBQ2hFLDBEQUEwRCw0QkFBNEI7QUFDdEYscURBQXFELHNCQUFzQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsNEJBQTRCO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxNQUFNO0FBQ3ZDLGtEQUFrRCxzQ0FBc0M7QUFDeEYsMkNBQTJDLGlCQUFpQjtBQUM1RCxrREFBa0QsdUJBQXVCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qyx1QkFBdUI7QUFDcEU7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLG1CQUFtQjtBQUNsRDtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsU0FBUztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsU0FBUztBQUM5QztBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsbUJBQW1CO0FBQ2xEO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSwyQkFBMkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXJ2aXZhbC1mdW4vLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9jb21wb3VuZC91dGlscy5qcz8yYzA1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRCYXNlVG9rZW5BZGRyZXNzID0gZXhwb3J0cy5nZXRBc3NldEFkZHJlc3MgPSBleHBvcnRzLmdldENvbWV0QWRkcmVzcyA9IGV4cG9ydHMuZ2V0UG9ydGZvbGlvRGV0YWlsc01hcmtkb3duID0gZXhwb3J0cy5nZXRIZWFsdGhSYXRpb0FmdGVyQm9ycm93ID0gZXhwb3J0cy5nZXRIZWFsdGhSYXRpb0FmdGVyV2l0aGRyYXcgPSBleHBvcnRzLmdldEhlYWx0aFJhdGlvID0gZXhwb3J0cy5nZXRDb2xsYXRlcmFsQmFsYW5jZSA9IGV4cG9ydHMuZ2V0VG9rZW5CYWxhbmNlID0gZXhwb3J0cy5nZXRUb2tlblN5bWJvbCA9IGV4cG9ydHMuZ2V0VG9rZW5EZWNpbWFscyA9IHZvaWQgMDtcbmNvbnN0IGRlY2ltYWxfanNfMSA9IHJlcXVpcmUoXCJkZWNpbWFsLmpzXCIpO1xuY29uc3QgdmllbV8xID0gcmVxdWlyZShcInZpZW1cIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IGNvbnN0YW50c18yID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuLyoqXG4gKiBHZXQgdG9rZW4gZGVjaW1hbHMgZnJvbSBjb250cmFjdFxuICpcbiAqIEBwYXJhbSB3YWxsZXQgLSBUaGUgd2FsbGV0IHByb3ZpZGVyIGluc3RhbmNlXG4gKiBAcGFyYW0gdG9rZW5BZGRyZXNzIC0gVGhlIGFkZHJlc3Mgb2YgdGhlIHRva2VuIGNvbnRyYWN0XG4gKiBAcmV0dXJucyBUaGUgbnVtYmVyIG9mIGRlY2ltYWxzIGZvciB0aGUgdG9rZW5cbiAqL1xuY29uc3QgZ2V0VG9rZW5EZWNpbWFscyA9IGFzeW5jICh3YWxsZXQsIHRva2VuQWRkcmVzcykgPT4ge1xuICAgIGNvbnN0IGRlY2ltYWxzID0gYXdhaXQgd2FsbGV0LnJlYWRDb250cmFjdCh7XG4gICAgICAgIGFkZHJlc3M6IHRva2VuQWRkcmVzcyxcbiAgICAgICAgYWJpOiBjb25zdGFudHNfMS5FUkMyMF9BQkksXG4gICAgICAgIGZ1bmN0aW9uTmFtZTogXCJkZWNpbWFsc1wiLFxuICAgIH0pO1xuICAgIHJldHVybiBOdW1iZXIoZGVjaW1hbHMpO1xufTtcbmV4cG9ydHMuZ2V0VG9rZW5EZWNpbWFscyA9IGdldFRva2VuRGVjaW1hbHM7XG4vKipcbiAqIEdldCB0b2tlbiBzeW1ib2wgZnJvbSBjb250cmFjdFxuICpcbiAqIEBwYXJhbSB3YWxsZXQgLSBUaGUgd2FsbGV0IHByb3ZpZGVyIGluc3RhbmNlXG4gKiBAcGFyYW0gdG9rZW5BZGRyZXNzIC0gVGhlIGFkZHJlc3Mgb2YgdGhlIHRva2VuIGNvbnRyYWN0XG4gKiBAcmV0dXJucyBUaGUgc3ltYm9sIG9mIHRoZSB0b2tlblxuICovXG5jb25zdCBnZXRUb2tlblN5bWJvbCA9IGFzeW5jICh3YWxsZXQsIHRva2VuQWRkcmVzcykgPT4ge1xuICAgIGNvbnN0IHN5bWJvbCA9IGF3YWl0IHdhbGxldC5yZWFkQ29udHJhY3Qoe1xuICAgICAgICBhZGRyZXNzOiB0b2tlbkFkZHJlc3MsXG4gICAgICAgIGFiaTogY29uc3RhbnRzXzEuRVJDMjBfQUJJLFxuICAgICAgICBmdW5jdGlvbk5hbWU6IFwic3ltYm9sXCIsXG4gICAgfSk7XG4gICAgcmV0dXJuIHN5bWJvbDtcbn07XG5leHBvcnRzLmdldFRva2VuU3ltYm9sID0gZ2V0VG9rZW5TeW1ib2w7XG4vKipcbiAqIEdldCB0b2tlbiBiYWxhbmNlIGZvciBhbiBhZGRyZXNzXG4gKlxuICogQHBhcmFtIHdhbGxldCAtIFRoZSB3YWxsZXQgcHJvdmlkZXIgaW5zdGFuY2VcbiAqIEBwYXJhbSB0b2tlbkFkZHJlc3MgLSBUaGUgYWRkcmVzcyBvZiB0aGUgdG9rZW4gY29udHJhY3RcbiAqIEByZXR1cm5zIFRoZSB0b2tlbiBiYWxhbmNlIGFzIGEgYmlnaW50XG4gKi9cbmNvbnN0IGdldFRva2VuQmFsYW5jZSA9IGFzeW5jICh3YWxsZXQsIHRva2VuQWRkcmVzcykgPT4ge1xuICAgIGNvbnN0IGJhbGFuY2UgPSBhd2FpdCB3YWxsZXQucmVhZENvbnRyYWN0KHtcbiAgICAgICAgYWRkcmVzczogdG9rZW5BZGRyZXNzLFxuICAgICAgICBhYmk6IGNvbnN0YW50c18xLkVSQzIwX0FCSSxcbiAgICAgICAgZnVuY3Rpb25OYW1lOiBcImJhbGFuY2VPZlwiLFxuICAgICAgICBhcmdzOiBbd2FsbGV0LmdldEFkZHJlc3MoKV0sXG4gICAgfSk7XG4gICAgcmV0dXJuIGJhbGFuY2U7XG59O1xuZXhwb3J0cy5nZXRUb2tlbkJhbGFuY2UgPSBnZXRUb2tlbkJhbGFuY2U7XG4vKipcbiAqIEdldCBjb2xsYXRlcmFsIGJhbGFuY2UgZm9yIGFuIGFkZHJlc3NcbiAqXG4gKiBAcGFyYW0gd2FsbGV0IC0gVGhlIHdhbGxldCBwcm92aWRlciBpbnN0YW5jZVxuICogQHBhcmFtIGNvbWV0QWRkcmVzcyAtIFRoZSBhZGRyZXNzIG9mIHRoZSBDb21ldCBjb250cmFjdFxuICogQHBhcmFtIHRva2VuQWRkcmVzcyAtIFRoZSBhZGRyZXNzIG9mIHRoZSB0b2tlbiBjb250cmFjdFxuICogQHJldHVybnMgVGhlIGNvbGxhdGVyYWwgYmFsYW5jZSBhcyBhIGJpZ2ludFxuICovXG5jb25zdCBnZXRDb2xsYXRlcmFsQmFsYW5jZSA9IGFzeW5jICh3YWxsZXQsIGNvbWV0QWRkcmVzcywgdG9rZW5BZGRyZXNzKSA9PiB7XG4gICAgY29uc3QgYmFsYW5jZSA9IGF3YWl0IHdhbGxldC5yZWFkQ29udHJhY3Qoe1xuICAgICAgICBhZGRyZXNzOiBjb21ldEFkZHJlc3MsXG4gICAgICAgIGFiaTogY29uc3RhbnRzXzEuQ09NRVRfQUJJLFxuICAgICAgICBmdW5jdGlvbk5hbWU6IFwiY29sbGF0ZXJhbEJhbGFuY2VPZlwiLFxuICAgICAgICBhcmdzOiBbKGF3YWl0IHdhbGxldC5nZXRBZGRyZXNzKCkpLCB0b2tlbkFkZHJlc3NdLFxuICAgIH0pO1xuICAgIHJldHVybiBiYWxhbmNlO1xufTtcbmV4cG9ydHMuZ2V0Q29sbGF0ZXJhbEJhbGFuY2UgPSBnZXRDb2xsYXRlcmFsQmFsYW5jZTtcbi8qKlxuICogR2V0IGhlYWx0aCByYXRpbyBmb3IgYW4gYWNjb3VudFxuICpcbiAqIEBwYXJhbSB3YWxsZXQgLSBUaGUgd2FsbGV0IHByb3ZpZGVyIGluc3RhbmNlXG4gKiBAcGFyYW0gY29tZXRBZGRyZXNzIC0gVGhlIGFkZHJlc3Mgb2YgdGhlIENvbWV0IGNvbnRyYWN0XG4gKiBAcmV0dXJucyBUaGUgaGVhbHRoIHJhdGlvIGFzIGEgRGVjaW1hbFxuICovXG5jb25zdCBnZXRIZWFsdGhSYXRpbyA9IGFzeW5jICh3YWxsZXQsIGNvbWV0QWRkcmVzcykgPT4ge1xuICAgIGNvbnN0IGJvcnJvd0RldGFpbHMgPSBhd2FpdCBnZXRCb3Jyb3dEZXRhaWxzKHdhbGxldCwgY29tZXRBZGRyZXNzKTtcbiAgICBjb25zdCBzdXBwbHlEZXRhaWxzID0gYXdhaXQgZ2V0U3VwcGx5RGV0YWlscyh3YWxsZXQsIGNvbWV0QWRkcmVzcyk7XG4gICAgY29uc3QgYm9ycm93VmFsdWUgPSBib3Jyb3dEZXRhaWxzLmJvcnJvd0Ftb3VudC5tdWwoYm9ycm93RGV0YWlscy5wcmljZSk7XG4gICAgbGV0IHRvdGFsQWRqdXN0ZWRDb2xsYXRlcmFsID0gbmV3IGRlY2ltYWxfanNfMS5EZWNpbWFsKDApO1xuICAgIGZvciAoY29uc3Qgc3VwcGx5IG9mIHN1cHBseURldGFpbHMpIHtcbiAgICAgICAgY29uc3QgY29sbGF0ZXJhbFZhbHVlID0gc3VwcGx5LnN1cHBseUFtb3VudC5tdWwoc3VwcGx5LnByaWNlKTtcbiAgICAgICAgY29uc3QgYWRqdXN0ZWRWYWx1ZSA9IGNvbGxhdGVyYWxWYWx1ZS5tdWwoc3VwcGx5LmNvbGxhdGVyYWxGYWN0b3IpO1xuICAgICAgICB0b3RhbEFkanVzdGVkQ29sbGF0ZXJhbCA9IHRvdGFsQWRqdXN0ZWRDb2xsYXRlcmFsLmFkZChhZGp1c3RlZFZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGJvcnJvd1ZhbHVlLmVxKDApID8gbmV3IGRlY2ltYWxfanNfMS5EZWNpbWFsKEluZmluaXR5KSA6IHRvdGFsQWRqdXN0ZWRDb2xsYXRlcmFsLmRpdihib3Jyb3dWYWx1ZSk7XG59O1xuZXhwb3J0cy5nZXRIZWFsdGhSYXRpbyA9IGdldEhlYWx0aFJhdGlvO1xuLyoqXG4gKiBHZXQgaGVhbHRoIHJhdGlvIGFmdGVyIGEgaHlwb3RoZXRpY2FsIHdpdGhkcmF3XG4gKlxuICogQHBhcmFtIHdhbGxldCAtIFRoZSB3YWxsZXQgcHJvdmlkZXIgaW5zdGFuY2VcbiAqIEBwYXJhbSBjb21ldEFkZHJlc3MgLSBUaGUgYWRkcmVzcyBvZiB0aGUgQ29tZXQgY29udHJhY3RcbiAqIEBwYXJhbSB0b2tlbkFkZHJlc3MgLSBUaGUgYWRkcmVzcyBvZiB0aGUgdG9rZW4gY29udHJhY3RcbiAqIEBwYXJhbSBhbW91bnQgLSBUaGUgYW1vdW50IHRvIHdpdGhkcmF3XG4gKiBAcmV0dXJucyBUaGUgaGVhbHRoIHJhdGlvIGFmdGVyIHdpdGhkcmF3IGFzIGEgRGVjaW1hbFxuICovXG5jb25zdCBnZXRIZWFsdGhSYXRpb0FmdGVyV2l0aGRyYXcgPSBhc3luYyAod2FsbGV0LCBjb21ldEFkZHJlc3MsIHRva2VuQWRkcmVzcywgYW1vdW50KSA9PiB7XG4gICAgY29uc3QgYm9ycm93RGV0YWlscyA9IGF3YWl0IGdldEJvcnJvd0RldGFpbHMod2FsbGV0LCBjb21ldEFkZHJlc3MpO1xuICAgIGNvbnN0IHN1cHBseURldGFpbHMgPSBhd2FpdCBnZXRTdXBwbHlEZXRhaWxzKHdhbGxldCwgY29tZXRBZGRyZXNzKTtcbiAgICBjb25zdCBib3Jyb3dWYWx1ZSA9IGJvcnJvd0RldGFpbHMuYm9ycm93QW1vdW50Lm11bChib3Jyb3dEZXRhaWxzLnByaWNlKTtcbiAgICBsZXQgdG90YWxBZGp1c3RlZENvbGxhdGVyYWwgPSBuZXcgZGVjaW1hbF9qc18xLkRlY2ltYWwoMCk7XG4gICAgZm9yIChjb25zdCBzdXBwbHkgb2Ygc3VwcGx5RGV0YWlscykge1xuICAgICAgICBjb25zdCBzdXBwbHlUb2tlblN5bWJvbCA9IHN1cHBseS50b2tlblN5bWJvbDtcbiAgICAgICAgY29uc3Qgd2l0aGRyYXdUb2tlblN5bWJvbCA9IGF3YWl0ICgwLCBleHBvcnRzLmdldFRva2VuU3ltYm9sKSh3YWxsZXQsIHRva2VuQWRkcmVzcyk7XG4gICAgICAgIGlmIChzdXBwbHlUb2tlblN5bWJvbCA9PT0gd2l0aGRyYXdUb2tlblN5bWJvbCkge1xuICAgICAgICAgICAgY29uc3QgZGVjaW1hbHMgPSBhd2FpdCAoMCwgZXhwb3J0cy5nZXRUb2tlbkRlY2ltYWxzKSh3YWxsZXQsIHRva2VuQWRkcmVzcyk7XG4gICAgICAgICAgICBjb25zdCB3aXRoZHJhd0Ftb3VudEh1bWFuID0gbmV3IGRlY2ltYWxfanNfMS5EZWNpbWFsKCgwLCB2aWVtXzEuZm9ybWF0VW5pdHMpKGFtb3VudCwgZGVjaW1hbHMpKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld1N1cHBseUFtb3VudCA9IHN1cHBseS5zdXBwbHlBbW91bnQuc3ViKHdpdGhkcmF3QW1vdW50SHVtYW4pO1xuICAgICAgICAgICAgY29uc3QgYXNzZXRWYWx1ZSA9IG5ld1N1cHBseUFtb3VudC5tdWwoc3VwcGx5LnByaWNlKTtcbiAgICAgICAgICAgIHRvdGFsQWRqdXN0ZWRDb2xsYXRlcmFsID0gdG90YWxBZGp1c3RlZENvbGxhdGVyYWwuYWRkKGFzc2V0VmFsdWUubXVsKHN1cHBseS5jb2xsYXRlcmFsRmFjdG9yKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0b3RhbEFkanVzdGVkQ29sbGF0ZXJhbCA9IHRvdGFsQWRqdXN0ZWRDb2xsYXRlcmFsLmFkZChzdXBwbHkuc3VwcGx5QW1vdW50Lm11bChzdXBwbHkucHJpY2UpLm11bChzdXBwbHkuY29sbGF0ZXJhbEZhY3RvcikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBib3Jyb3dWYWx1ZS5lcSgwKSA/IG5ldyBkZWNpbWFsX2pzXzEuRGVjaW1hbChJbmZpbml0eSkgOiB0b3RhbEFkanVzdGVkQ29sbGF0ZXJhbC5kaXYoYm9ycm93VmFsdWUpO1xufTtcbmV4cG9ydHMuZ2V0SGVhbHRoUmF0aW9BZnRlcldpdGhkcmF3ID0gZ2V0SGVhbHRoUmF0aW9BZnRlcldpdGhkcmF3O1xuLyoqXG4gKiBHZXQgaGVhbHRoIHJhdGlvIGFmdGVyIGEgaHlwb3RoZXRpY2FsIGJvcnJvd1xuICpcbiAqIEBwYXJhbSB3YWxsZXQgLSBUaGUgd2FsbGV0IHByb3ZpZGVyIGluc3RhbmNlXG4gKiBAcGFyYW0gY29tZXRBZGRyZXNzIC0gVGhlIGFkZHJlc3Mgb2YgdGhlIENvbWV0IGNvbnRyYWN0XG4gKiBAcGFyYW0gYW1vdW50IC0gVGhlIGFtb3VudCB0byBib3Jyb3dcbiAqIEByZXR1cm5zIFRoZSBoZWFsdGggcmF0aW8gYWZ0ZXIgYm9ycm93IGFzIGEgRGVjaW1hbFxuICovXG5jb25zdCBnZXRIZWFsdGhSYXRpb0FmdGVyQm9ycm93ID0gYXN5bmMgKHdhbGxldCwgY29tZXRBZGRyZXNzLCBhbW91bnQpID0+IHtcbiAgICBjb25zdCBib3Jyb3dEZXRhaWxzID0gYXdhaXQgZ2V0Qm9ycm93RGV0YWlscyh3YWxsZXQsIGNvbWV0QWRkcmVzcyk7XG4gICAgY29uc3Qgc3VwcGx5RGV0YWlscyA9IGF3YWl0IGdldFN1cHBseURldGFpbHMod2FsbGV0LCBjb21ldEFkZHJlc3MpO1xuICAgIGNvbnN0IGJhc2VUb2tlbiA9IGF3YWl0ICgwLCBleHBvcnRzLmdldEJhc2VUb2tlbkFkZHJlc3MpKHdhbGxldCwgY29tZXRBZGRyZXNzKTtcbiAgICBjb25zdCBiYXNlRGVjaW1hbHMgPSBhd2FpdCAoMCwgZXhwb3J0cy5nZXRUb2tlbkRlY2ltYWxzKSh3YWxsZXQsIGJhc2VUb2tlbik7XG4gICAgY29uc3QgYWRkaXRpb25hbEJvcnJvdyA9IG5ldyBkZWNpbWFsX2pzXzEuRGVjaW1hbCgoMCwgdmllbV8xLmZvcm1hdFVuaXRzKShhbW91bnQsIGJhc2VEZWNpbWFscykpO1xuICAgIGNvbnN0IG5ld0JvcnJvdyA9IGJvcnJvd0RldGFpbHMuYm9ycm93QW1vdW50LmFkZChhZGRpdGlvbmFsQm9ycm93KTtcbiAgICBjb25zdCBuZXdCb3Jyb3dWYWx1ZSA9IG5ld0JvcnJvdy5tdWwoYm9ycm93RGV0YWlscy5wcmljZSk7XG4gICAgbGV0IHRvdGFsQWRqdXN0ZWRDb2xsYXRlcmFsID0gbmV3IGRlY2ltYWxfanNfMS5EZWNpbWFsKDApO1xuICAgIGZvciAoY29uc3Qgc3VwcGx5IG9mIHN1cHBseURldGFpbHMpIHtcbiAgICAgICAgdG90YWxBZGp1c3RlZENvbGxhdGVyYWwgPSB0b3RhbEFkanVzdGVkQ29sbGF0ZXJhbC5hZGQoc3VwcGx5LnN1cHBseUFtb3VudC5tdWwoc3VwcGx5LnByaWNlKS5tdWwoc3VwcGx5LmNvbGxhdGVyYWxGYWN0b3IpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld0JvcnJvd1ZhbHVlLmVxKDApID8gbmV3IGRlY2ltYWxfanNfMS5EZWNpbWFsKEluZmluaXR5KSA6IHRvdGFsQWRqdXN0ZWRDb2xsYXRlcmFsLmRpdihuZXdCb3Jyb3dWYWx1ZSk7XG59O1xuZXhwb3J0cy5nZXRIZWFsdGhSYXRpb0FmdGVyQm9ycm93ID0gZ2V0SGVhbHRoUmF0aW9BZnRlckJvcnJvdztcbi8qKlxuICogR2V0IHBvcnRmb2xpbyBkZXRhaWxzIGluIG1hcmtkb3duIGZvcm1hdFxuICpcbiAqIEBwYXJhbSB3YWxsZXQgLSBUaGUgd2FsbGV0IHByb3ZpZGVyIGluc3RhbmNlXG4gKiBAcGFyYW0gY29tZXRBZGRyZXNzIC0gVGhlIGFkZHJlc3Mgb2YgdGhlIENvbWV0IGNvbnRyYWN0XG4gKiBAcmV0dXJucyBBIG1hcmtkb3duIGZvcm1hdHRlZCBzdHJpbmcgd2l0aCBwb3J0Zm9saW8gZGV0YWlsc1xuICovXG5jb25zdCBnZXRQb3J0Zm9saW9EZXRhaWxzTWFya2Rvd24gPSBhc3luYyAod2FsbGV0LCBjb21ldEFkZHJlc3MpID0+IHtcbiAgICBsZXQgbWFya2Rvd25PdXRwdXQgPSBcIiMgUG9ydGZvbGlvIERldGFpbHNcXG5cXG5cIjtcbiAgICBtYXJrZG93bk91dHB1dCArPSBcIiMjIFN1cHBseSBEZXRhaWxzXFxuXFxuXCI7XG4gICAgbGV0IHRvdGFsU3VwcGx5VmFsdWUgPSBuZXcgZGVjaW1hbF9qc18xLkRlY2ltYWwoMCk7XG4gICAgY29uc3Qgc3VwcGx5RGV0YWlscyA9IGF3YWl0IGdldFN1cHBseURldGFpbHMod2FsbGV0LCBjb21ldEFkZHJlc3MpO1xuICAgIGlmIChzdXBwbHlEZXRhaWxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZm9yIChjb25zdCBzdXBwbHkgb2Ygc3VwcGx5RGV0YWlscykge1xuICAgICAgICAgICAgY29uc3QgdG9rZW4gPSBzdXBwbHkudG9rZW5TeW1ib2w7XG4gICAgICAgICAgICBjb25zdCBzdXBwbHlBbW91bnQgPSBzdXBwbHkuc3VwcGx5QW1vdW50O1xuICAgICAgICAgICAgY29uc3QgcHJpY2UgPSBzdXBwbHkucHJpY2U7XG4gICAgICAgICAgICBjb25zdCBkZWNpbWFscyA9IHN1cHBseS5kZWNpbWFscztcbiAgICAgICAgICAgIGNvbnN0IGNvbGxhdGVyYWxGYWN0b3IgPSBzdXBwbHkuY29sbGF0ZXJhbEZhY3RvcjtcbiAgICAgICAgICAgIGNvbnN0IGFzc2V0VmFsdWUgPSBzdXBwbHlBbW91bnQubXVsKHByaWNlKTtcbiAgICAgICAgICAgIG1hcmtkb3duT3V0cHV0ICs9IGAjIyMgJHt0b2tlbn1cXG5gO1xuICAgICAgICAgICAgbWFya2Rvd25PdXRwdXQgKz0gYC0gKipTdXBwbHkgQW1vdW50OioqICR7c3VwcGx5QW1vdW50LnRvRml4ZWQoZGVjaW1hbHMpfVxcbmA7XG4gICAgICAgICAgICBtYXJrZG93bk91dHB1dCArPSBgLSAqKlByaWNlOioqICQke3ByaWNlLnRvRml4ZWQoMil9XFxuYDtcbiAgICAgICAgICAgIG1hcmtkb3duT3V0cHV0ICs9IGAtICoqQ29sbGF0ZXJhbCBGYWN0b3I6KiogJHtjb2xsYXRlcmFsRmFjdG9yLnRvRml4ZWQoMil9XFxuYDtcbiAgICAgICAgICAgIG1hcmtkb3duT3V0cHV0ICs9IGAtICoqQXNzZXQgVmFsdWU6KiogJCR7YXNzZXRWYWx1ZS50b0ZpeGVkKDIpfVxcblxcbmA7XG4gICAgICAgICAgICB0b3RhbFN1cHBseVZhbHVlID0gdG90YWxTdXBwbHlWYWx1ZS5hZGQoYXNzZXRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG1hcmtkb3duT3V0cHV0ICs9IFwiTm8gc3VwcGxpZWQgYXNzZXRzIGZvdW5kIGluIHlvdXIgQ29tcG91bmQgcG9zaXRpb24uXFxuXFxuXCI7XG4gICAgfVxuICAgIG1hcmtkb3duT3V0cHV0ICs9IGAjIyMgVG90YWwgU3VwcGx5IFZhbHVlOiAkJHt0b3RhbFN1cHBseVZhbHVlLnRvRml4ZWQoMil9XFxuXFxuYDtcbiAgICBtYXJrZG93bk91dHB1dCArPSBcIiMjIEJvcnJvdyBEZXRhaWxzXFxuXFxuXCI7XG4gICAgY29uc3QgYm9ycm93RGV0YWlscyA9IGF3YWl0IGdldEJvcnJvd0RldGFpbHMod2FsbGV0LCBjb21ldEFkZHJlc3MpO1xuICAgIGlmIChib3Jyb3dEZXRhaWxzLmJvcnJvd0Ftb3VudC5ndCgwKSkge1xuICAgICAgICBjb25zdCB0b2tlbiA9IGJvcnJvd0RldGFpbHMudG9rZW5TeW1ib2w7XG4gICAgICAgIGNvbnN0IHByaWNlID0gYm9ycm93RGV0YWlscy5wcmljZTtcbiAgICAgICAgY29uc3QgYm9ycm93VmFsdWUgPSBib3Jyb3dEZXRhaWxzLmJvcnJvd0Ftb3VudC5tdWwocHJpY2UpO1xuICAgICAgICBtYXJrZG93bk91dHB1dCArPSBgIyMjICR7dG9rZW59XFxuYDtcbiAgICAgICAgbWFya2Rvd25PdXRwdXQgKz0gYC0gKipCb3Jyb3cgQW1vdW50OioqICR7Ym9ycm93RGV0YWlscy5ib3Jyb3dBbW91bnQudG9GaXhlZCg2KX1cXG5gO1xuICAgICAgICBtYXJrZG93bk91dHB1dCArPSBgLSAqKlByaWNlOioqICQke3ByaWNlLnRvRml4ZWQoMil9XFxuYDtcbiAgICAgICAgbWFya2Rvd25PdXRwdXQgKz0gYC0gKipCb3Jyb3cgVmFsdWU6KiogJCR7Ym9ycm93VmFsdWUudG9GaXhlZCgyKX1cXG5cXG5gO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbWFya2Rvd25PdXRwdXQgKz0gXCJObyBib3Jyb3dlZCBhc3NldHMgZm91bmQgaW4geW91ciBDb21wb3VuZCBwb3NpdGlvbi5cXG5cXG5cIjtcbiAgICB9XG4gICAgbWFya2Rvd25PdXRwdXQgKz0gXCIjIyBPdmVyYWxsIEhlYWx0aFxcblxcblwiO1xuICAgIGNvbnN0IGhlYWx0aFJhdGlvID0gYXdhaXQgKDAsIGV4cG9ydHMuZ2V0SGVhbHRoUmF0aW8pKHdhbGxldCwgY29tZXRBZGRyZXNzKTtcbiAgICBtYXJrZG93bk91dHB1dCArPSBgLSAqKkhlYWx0aCBSYXRpbzoqKiAke2hlYWx0aFJhdGlvLnRvRml4ZWQoMil9XFxuYDtcbiAgICByZXR1cm4gbWFya2Rvd25PdXRwdXQ7XG59O1xuZXhwb3J0cy5nZXRQb3J0Zm9saW9EZXRhaWxzTWFya2Rvd24gPSBnZXRQb3J0Zm9saW9EZXRhaWxzTWFya2Rvd247XG4vKipcbiAqIEZldGNoIHRoZSBsYXRlc3QgcHJpY2UgZmVlZCBkYXRhLlxuICpcbiAqIEBwYXJhbSB3YWxsZXQgLSBUaGUgd2FsbGV0IHByb3ZpZGVyIGluc3RhbmNlXG4gKiBAcGFyYW0gcHJpY2VGZWVkQWRkcmVzcyAtIFRoZSBhZGRyZXNzIG9mIHRoZSBwcmljZSBmZWVkIGNvbnRyYWN0XG4gKiBAcmV0dXJucyBBIHR1cGxlIGNvbnRhaW5pbmcgdGhlIHByaWNlIGFuZCB0aW1lc3RhbXBcbiAqL1xuY29uc3QgZ2V0UHJpY2VGZWVkRGF0YSA9IGFzeW5jICh3YWxsZXQsIHByaWNlRmVlZEFkZHJlc3MpID0+IHtcbiAgICBjb25zdCBsYXRlc3REYXRhID0gYXdhaXQgd2FsbGV0LnJlYWRDb250cmFjdCh7XG4gICAgICAgIGFkZHJlc3M6IHByaWNlRmVlZEFkZHJlc3MsXG4gICAgICAgIGFiaTogY29uc3RhbnRzXzEuUFJJQ0VfRkVFRF9BQkksXG4gICAgICAgIGZ1bmN0aW9uTmFtZTogXCJsYXRlc3RSb3VuZERhdGFcIixcbiAgICAgICAgYXJnczogW10sXG4gICAgfSk7XG4gICAgY29uc3QgYW5zd2VyID0gbGF0ZXN0RGF0YVsxXS50b1N0cmluZygpO1xuICAgIGNvbnN0IHVwZGF0ZWRBdCA9IE51bWJlcihsYXRlc3REYXRhWzNdKTtcbiAgICByZXR1cm4gW2Fuc3dlciwgdXBkYXRlZEF0XTtcbn07XG4vKipcbiAqIFJldHJpZXZlIGJvcnJvdyBkZXRhaWxzOiBhbW91bnQsIGJhc2UgdG9rZW4gc3ltYm9sLCBhbmQgcHJpY2UuXG4gKlxuICogQHBhcmFtIHdhbGxldCAtIFRoZSB3YWxsZXQgcHJvdmlkZXIgaW5zdGFuY2VcbiAqIEBwYXJhbSBjb21ldEFkZHJlc3MgLSBUaGUgYWRkcmVzcyBvZiB0aGUgQ29tZXQgY29udHJhY3RcbiAqIEByZXR1cm5zIEFuIG9iamVjdCBjb250YWluaW5nIGJvcnJvdyBkZXRhaWxzXG4gKi9cbmNvbnN0IGdldEJvcnJvd0RldGFpbHMgPSBhc3luYyAod2FsbGV0LCBjb21ldEFkZHJlc3MpID0+IHtcbiAgICBjb25zdCBib3Jyb3dBbW91bnRSYXcgPSBhd2FpdCB3YWxsZXQucmVhZENvbnRyYWN0KHtcbiAgICAgICAgYWRkcmVzczogY29tZXRBZGRyZXNzLFxuICAgICAgICBhYmk6IGNvbnN0YW50c18xLkNPTUVUX0FCSSxcbiAgICAgICAgZnVuY3Rpb25OYW1lOiBcImJvcnJvd0JhbGFuY2VPZlwiLFxuICAgICAgICBhcmdzOiBbKGF3YWl0IHdhbGxldC5nZXRBZGRyZXNzKCkpXSxcbiAgICB9KTtcbiAgICBjb25zdCBiYXNlVG9rZW4gPSBhd2FpdCAoMCwgZXhwb3J0cy5nZXRCYXNlVG9rZW5BZGRyZXNzKSh3YWxsZXQsIGNvbWV0QWRkcmVzcyk7XG4gICAgY29uc3QgYmFzZURlY2ltYWxzID0gYXdhaXQgKDAsIGV4cG9ydHMuZ2V0VG9rZW5EZWNpbWFscykod2FsbGV0LCBiYXNlVG9rZW4pO1xuICAgIGNvbnN0IGJhc2VUb2tlblN5bWJvbCA9IGF3YWl0ICgwLCBleHBvcnRzLmdldFRva2VuU3ltYm9sKSh3YWxsZXQsIGJhc2VUb2tlbik7XG4gICAgY29uc3QgYmFzZVByaWNlRmVlZCA9IGF3YWl0IHdhbGxldC5yZWFkQ29udHJhY3Qoe1xuICAgICAgICBhZGRyZXNzOiBjb21ldEFkZHJlc3MsXG4gICAgICAgIGFiaTogY29uc3RhbnRzXzEuQ09NRVRfQUJJLFxuICAgICAgICBmdW5jdGlvbk5hbWU6IFwiYmFzZVRva2VuUHJpY2VGZWVkXCIsXG4gICAgICAgIGFyZ3M6IFtdLFxuICAgIH0pO1xuICAgIGNvbnN0IFtiYXNlUHJpY2VSYXddID0gYXdhaXQgZ2V0UHJpY2VGZWVkRGF0YSh3YWxsZXQsIGJhc2VQcmljZUZlZWQpO1xuICAgIGNvbnN0IGh1bWFuQm9ycm93QW1vdW50ID0gbmV3IGRlY2ltYWxfanNfMS5EZWNpbWFsKCgwLCB2aWVtXzEuZm9ybWF0VW5pdHMpKGJvcnJvd0Ftb3VudFJhdywgYmFzZURlY2ltYWxzKSk7XG4gICAgY29uc3QgcHJpY2UgPSBuZXcgZGVjaW1hbF9qc18xLkRlY2ltYWwoYmFzZVByaWNlUmF3KS5kaXYobmV3IGRlY2ltYWxfanNfMS5EZWNpbWFsKDEwKS5wb3coOCkpO1xuICAgIHJldHVybiB7IHRva2VuU3ltYm9sOiBiYXNlVG9rZW5TeW1ib2wsIGJvcnJvd0Ftb3VudDogaHVtYW5Cb3Jyb3dBbW91bnQsIHByaWNlIH07XG59O1xuLyoqXG4gKiBSZXRyaWV2ZSBzdXBwbHkgZGV0YWlscyBhY3Jvc3MgYWxsIGNvbGxhdGVyYWwgYXNzZXRzLlxuICpcbiAqIEBwYXJhbSB3YWxsZXQgLSBUaGUgd2FsbGV0IHByb3ZpZGVyIGluc3RhbmNlXG4gKiBAcGFyYW0gY29tZXRBZGRyZXNzIC0gVGhlIGFkZHJlc3Mgb2YgdGhlIENvbWV0IGNvbnRyYWN0XG4gKiBAcmV0dXJucyBBbiBhcnJheSBvZiBzdXBwbHkgZGV0YWlscyBmb3IgZWFjaCBhc3NldFxuICovXG5jb25zdCBnZXRTdXBwbHlEZXRhaWxzID0gYXN5bmMgKHdhbGxldCwgY29tZXRBZGRyZXNzKSA9PiB7XG4gICAgY29uc3QgbnVtQXNzZXRzID0gYXdhaXQgd2FsbGV0LnJlYWRDb250cmFjdCh7XG4gICAgICAgIGFkZHJlc3M6IGNvbWV0QWRkcmVzcyxcbiAgICAgICAgYWJpOiBjb25zdGFudHNfMS5DT01FVF9BQkksXG4gICAgICAgIGZ1bmN0aW9uTmFtZTogXCJudW1Bc3NldHNcIixcbiAgICAgICAgYXJnczogW10sXG4gICAgfSk7XG4gICAgY29uc3Qgc3VwcGx5RGV0YWlscyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtQXNzZXRzOyBpKyspIHtcbiAgICAgICAgY29uc3QgYXNzZXRJbmZvID0gYXdhaXQgd2FsbGV0LnJlYWRDb250cmFjdCh7XG4gICAgICAgICAgICBhZGRyZXNzOiBjb21ldEFkZHJlc3MsXG4gICAgICAgICAgICBhYmk6IGNvbnN0YW50c18xLkNPTUVUX0FCSSxcbiAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogXCJnZXRBc3NldEluZm9cIixcbiAgICAgICAgICAgIGFyZ3M6IFtpXSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGFzc2V0QWRkcmVzcyA9IGFzc2V0SW5mby5hc3NldDtcbiAgICAgICAgY29uc3QgY29sbGF0ZXJhbEJhbGFuY2UgPSBhd2FpdCAoMCwgZXhwb3J0cy5nZXRDb2xsYXRlcmFsQmFsYW5jZSkod2FsbGV0LCBjb21ldEFkZHJlc3MsIGFzc2V0QWRkcmVzcyk7XG4gICAgICAgIGlmIChjb2xsYXRlcmFsQmFsYW5jZSA+IDBuKSB7XG4gICAgICAgICAgICBjb25zdCB0b2tlblN5bWJvbCA9IGF3YWl0ICgwLCBleHBvcnRzLmdldFRva2VuU3ltYm9sKSh3YWxsZXQsIGFzc2V0QWRkcmVzcyk7XG4gICAgICAgICAgICBjb25zdCBkZWNpbWFscyA9IGF3YWl0ICgwLCBleHBvcnRzLmdldFRva2VuRGVjaW1hbHMpKHdhbGxldCwgYXNzZXRBZGRyZXNzKTtcbiAgICAgICAgICAgIGNvbnN0IFtwcmljZVJhd10gPSBhd2FpdCBnZXRQcmljZUZlZWREYXRhKHdhbGxldCwgYXNzZXRJbmZvLnByaWNlRmVlZCk7XG4gICAgICAgICAgICBjb25zdCBodW1hblN1cHBseUFtb3VudCA9IG5ldyBkZWNpbWFsX2pzXzEuRGVjaW1hbCgoMCwgdmllbV8xLmZvcm1hdFVuaXRzKShjb2xsYXRlcmFsQmFsYW5jZSwgZGVjaW1hbHMpKTtcbiAgICAgICAgICAgIGNvbnN0IHByaWNlID0gbmV3IGRlY2ltYWxfanNfMS5EZWNpbWFsKHByaWNlUmF3KS5kaXYobmV3IGRlY2ltYWxfanNfMS5EZWNpbWFsKDEwKS5wb3coOCkpO1xuICAgICAgICAgICAgY29uc3QgY29sbGF0ZXJhbEZhY3RvciA9IG5ldyBkZWNpbWFsX2pzXzEuRGVjaW1hbChhc3NldEluZm8uYm9ycm93Q29sbGF0ZXJhbEZhY3Rvci50b1N0cmluZygpKS5kaXYobmV3IGRlY2ltYWxfanNfMS5EZWNpbWFsKDEwKS5wb3coMTgpKTtcbiAgICAgICAgICAgIHN1cHBseURldGFpbHMucHVzaCh7XG4gICAgICAgICAgICAgICAgdG9rZW5TeW1ib2wsXG4gICAgICAgICAgICAgICAgc3VwcGx5QW1vdW50OiBodW1hblN1cHBseUFtb3VudCxcbiAgICAgICAgICAgICAgICBwcmljZSxcbiAgICAgICAgICAgICAgICBjb2xsYXRlcmFsRmFjdG9yLFxuICAgICAgICAgICAgICAgIGRlY2ltYWxzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN1cHBseURldGFpbHM7XG59O1xuLyoqXG4gKiBHZXRzIHRoZSBDb21ldCBhZGRyZXNzIGZvciB0aGUgY3VycmVudCBuZXR3b3JrLlxuICpcbiAqIEBwYXJhbSBuZXR3b3JrIC0gVGhlIG5ldHdvcmsgaW5zdGFuY2VcbiAqIEByZXR1cm5zIFRoZSBDb21ldCBjb250cmFjdCBhZGRyZXNzXG4gKi9cbmNvbnN0IGdldENvbWV0QWRkcmVzcyA9IChuZXR3b3JrKSA9PiB7XG4gICAgaWYgKCFuZXR3b3JrLm5ldHdvcmtJZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOZXR3b3JrIElEIGlzIHJlcXVpcmVkXCIpO1xuICAgIH1cbiAgICBpZiAobmV0d29yay5uZXR3b3JrSWQgPT09IFwiYmFzZS1tYWlubmV0XCIpIHtcbiAgICAgICAgcmV0dXJuIGNvbnN0YW50c18yLkNPTUVUX0FERFJFU1NFU1tcImJhc2UtbWFpbm5ldFwiXTtcbiAgICB9XG4gICAgZWxzZSBpZiAobmV0d29yay5uZXR3b3JrSWQgPT09IFwiYmFzZS1zZXBvbGlhXCIpIHtcbiAgICAgICAgcmV0dXJuIGNvbnN0YW50c18yLkNPTUVUX0FERFJFU1NFU1tcImJhc2Utc2Vwb2xpYVwiXTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBOZXR3b3JrICR7bmV0d29yay5uZXR3b3JrSWR9IG5vdCBzdXBwb3J0ZWRgKTtcbn07XG5leHBvcnRzLmdldENvbWV0QWRkcmVzcyA9IGdldENvbWV0QWRkcmVzcztcbi8qKlxuICogR2V0cyB0aGUgYXNzZXQgYWRkcmVzcyBmb3IgYSBnaXZlbiBhc3NldElkIG9uIHRoZSBjdXJyZW50IG5ldHdvcmsuXG4gKlxuICogQHBhcmFtIG5ldHdvcmsgLSBUaGUgbmV0d29yayBpbnN0YW5jZVxuICogQHBhcmFtIGFzc2V0SWQgLSBUaGUgaWRlbnRpZmllciBvZiB0aGUgYXNzZXRcbiAqIEByZXR1cm5zIFRoZSBhc3NldCBjb250cmFjdCBhZGRyZXNzXG4gKi9cbmNvbnN0IGdldEFzc2V0QWRkcmVzcyA9IChuZXR3b3JrLCBhc3NldElkKSA9PiB7XG4gICAgaWYgKCFuZXR3b3JrLm5ldHdvcmtJZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOZXR3b3JrIElEIGlzIHJlcXVpcmVkXCIpO1xuICAgIH1cbiAgICBjb25zdCBub3JtYWxpemVkQXNzZXRJZCA9IGFzc2V0SWQudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAobmV0d29yay5uZXR3b3JrSWQgPT09IFwiYmFzZS1tYWlubmV0XCIpIHtcbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IGNvbnN0YW50c18yLkFTU0VUX0FERFJFU1NFU1tcImJhc2UtbWFpbm5ldFwiXVtub3JtYWxpemVkQXNzZXRJZF07XG4gICAgICAgIGlmICghYWRkcmVzcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBc3NldCAke2Fzc2V0SWR9IG5vdCBzdXBwb3J0ZWQgb24gQmFzZSBNYWlubmV0YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFkZHJlc3M7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5ldHdvcmsubmV0d29ya0lkID09PSBcImJhc2Utc2Vwb2xpYVwiKSB7XG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSBjb25zdGFudHNfMi5BU1NFVF9BRERSRVNTRVNbXCJiYXNlLXNlcG9saWFcIl1bbm9ybWFsaXplZEFzc2V0SWRdO1xuICAgICAgICBpZiAoIWFkZHJlc3MpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQXNzZXQgJHthc3NldElkfSBub3Qgc3VwcG9ydGVkIG9uIEJhc2UgU2Vwb2xpYWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhZGRyZXNzO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYE5ldHdvcmsgJHtuZXR3b3JrLm5ldHdvcmtJZH0gbm90IHN1cHBvcnRlZGApO1xufTtcbmV4cG9ydHMuZ2V0QXNzZXRBZGRyZXNzID0gZ2V0QXNzZXRBZGRyZXNzO1xuLyoqXG4gKiBHZXQgdGhlIGJhc2UgdG9rZW4gYWRkcmVzcyBmb3IgYSBDb21wb3VuZCBtYXJrZXRcbiAqXG4gKiBAcGFyYW0gd2FsbGV0IC0gVGhlIHdhbGxldCBwcm92aWRlciBpbnN0YW5jZVxuICogQHBhcmFtIGNvbWV0QWRkcmVzcyAtIFRoZSBhZGRyZXNzIG9mIHRoZSBDb21ldCBjb250cmFjdFxuICogQHJldHVybnMgVGhlIGJhc2UgdG9rZW4gYWRkcmVzc1xuICovXG5jb25zdCBnZXRCYXNlVG9rZW5BZGRyZXNzID0gYXN5bmMgKHdhbGxldCwgY29tZXRBZGRyZXNzKSA9PiB7XG4gICAgY29uc3QgYmFzZVRva2VuID0gYXdhaXQgd2FsbGV0LnJlYWRDb250cmFjdCh7XG4gICAgICAgIGFkZHJlc3M6IGNvbWV0QWRkcmVzcyxcbiAgICAgICAgYWJpOiBjb25zdGFudHNfMS5DT01FVF9BQkksXG4gICAgICAgIGZ1bmN0aW9uTmFtZTogXCJiYXNlVG9rZW5cIixcbiAgICAgICAgYXJnczogW10sXG4gICAgfSk7XG4gICAgcmV0dXJuIGJhc2VUb2tlbjtcbn07XG5leHBvcnRzLmdldEJhc2VUb2tlbkFkZHJlc3MgPSBnZXRCYXNlVG9rZW5BZGRyZXNzO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/compound/utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/customActionProvider.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/customActionProvider.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/* eslint-disable @typescript-eslint/no-explicit-any */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.customActionProvider = exports.CustomActionProvider = void 0;\nconst actionDecorator_1 = __webpack_require__(/*! ./actionDecorator */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/actionDecorator.js\");\nconst actionProvider_1 = __webpack_require__(/*! ./actionProvider */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/actionProvider.js\");\nconst wallet_providers_1 = __webpack_require__(/*! ../wallet-providers */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/wallet-providers/index.js\");\n/**\n * CustomActionProvider is a custom action provider that allows for custom action registration\n */\nclass CustomActionProvider extends actionProvider_1.ActionProvider {\n    /**\n     * Creates a new CustomActionProvider that dynamically adds decorated action methods\n     *\n     * @param actions - Array of custom actions to be added to the provider\n     */\n    constructor(actions) {\n        super(\"custom\", []);\n        actions.forEach(({ name, description, schema, invoke }) => {\n            // Check if the invoke function expects a wallet provider\n            const takesWalletProvider = invoke.length === 2;\n            // Define the method on the prototype with the correct signature\n            Object.defineProperty(CustomActionProvider.prototype, name, {\n                value: takesWalletProvider\n                    ? async function (walletProvider, args) {\n                        const parsedArgs = schema.parse(args);\n                        return await invoke(walletProvider, parsedArgs);\n                    }\n                    : async function (args) {\n                        const parsedArgs = schema.parse(args);\n                        return await invoke(parsedArgs);\n                    },\n                configurable: true,\n                writable: true,\n                enumerable: true,\n            });\n            // Manually set the parameter metadata\n            const paramTypes = takesWalletProvider ? [wallet_providers_1.WalletProvider, Object] : [Object];\n            Reflect.defineMetadata(\"design:paramtypes\", paramTypes, CustomActionProvider.prototype, name);\n            // Apply the decorator using original name\n            const decoratedMethod = (0, actionDecorator_1.CreateAction)({\n                name,\n                description,\n                schema,\n            })(CustomActionProvider.prototype, name, Object.getOwnPropertyDescriptor(CustomActionProvider.prototype, name));\n            // Add the decorated method to the instance\n            Object.defineProperty(this, name, {\n                value: decoratedMethod,\n                configurable: true,\n                writable: true,\n            });\n        });\n    }\n    /**\n     * Custom action providers are supported on all networks\n     *\n     * @param _ - The network to checkpointSaver\n     * @returns true\n     */\n    supportsNetwork(_) {\n        return true;\n    }\n}\nexports.CustomActionProvider = CustomActionProvider;\nconst customActionProvider = (actions) => new CustomActionProvider(Array.isArray(actions) ? actions : [actions]);\nexports.customActionProvider = customActionProvider;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9jdXN0b21BY3Rpb25Qcm92aWRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDRCQUE0QixHQUFHLDRCQUE0QjtBQUMzRCwwQkFBMEIsbUJBQU8sQ0FBQywyR0FBbUI7QUFDckQseUJBQXlCLG1CQUFPLENBQUMseUdBQWtCO0FBQ25ELDJCQUEyQixtQkFBTyxDQUFDLG1HQUFxQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG1DQUFtQztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBLDRCQUE0QiIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cnZpdmFsLWZ1bi8uL25vZGVfbW9kdWxlcy9AY29pbmJhc2UvYWdlbnRraXQvZGlzdC9hY3Rpb24tcHJvdmlkZXJzL2N1c3RvbUFjdGlvblByb3ZpZGVyLmpzPzdjYmUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmN1c3RvbUFjdGlvblByb3ZpZGVyID0gZXhwb3J0cy5DdXN0b21BY3Rpb25Qcm92aWRlciA9IHZvaWQgMDtcbmNvbnN0IGFjdGlvbkRlY29yYXRvcl8xID0gcmVxdWlyZShcIi4vYWN0aW9uRGVjb3JhdG9yXCIpO1xuY29uc3QgYWN0aW9uUHJvdmlkZXJfMSA9IHJlcXVpcmUoXCIuL2FjdGlvblByb3ZpZGVyXCIpO1xuY29uc3Qgd2FsbGV0X3Byb3ZpZGVyc18xID0gcmVxdWlyZShcIi4uL3dhbGxldC1wcm92aWRlcnNcIik7XG4vKipcbiAqIEN1c3RvbUFjdGlvblByb3ZpZGVyIGlzIGEgY3VzdG9tIGFjdGlvbiBwcm92aWRlciB0aGF0IGFsbG93cyBmb3IgY3VzdG9tIGFjdGlvbiByZWdpc3RyYXRpb25cbiAqL1xuY2xhc3MgQ3VzdG9tQWN0aW9uUHJvdmlkZXIgZXh0ZW5kcyBhY3Rpb25Qcm92aWRlcl8xLkFjdGlvblByb3ZpZGVyIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IEN1c3RvbUFjdGlvblByb3ZpZGVyIHRoYXQgZHluYW1pY2FsbHkgYWRkcyBkZWNvcmF0ZWQgYWN0aW9uIG1ldGhvZHNcbiAgICAgKlxuICAgICAqIEBwYXJhbSBhY3Rpb25zIC0gQXJyYXkgb2YgY3VzdG9tIGFjdGlvbnMgdG8gYmUgYWRkZWQgdG8gdGhlIHByb3ZpZGVyXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoYWN0aW9ucykge1xuICAgICAgICBzdXBlcihcImN1c3RvbVwiLCBbXSk7XG4gICAgICAgIGFjdGlvbnMuZm9yRWFjaCgoeyBuYW1lLCBkZXNjcmlwdGlvbiwgc2NoZW1hLCBpbnZva2UgfSkgPT4ge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGludm9rZSBmdW5jdGlvbiBleHBlY3RzIGEgd2FsbGV0IHByb3ZpZGVyXG4gICAgICAgICAgICBjb25zdCB0YWtlc1dhbGxldFByb3ZpZGVyID0gaW52b2tlLmxlbmd0aCA9PT0gMjtcbiAgICAgICAgICAgIC8vIERlZmluZSB0aGUgbWV0aG9kIG9uIHRoZSBwcm90b3R5cGUgd2l0aCB0aGUgY29ycmVjdCBzaWduYXR1cmVcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDdXN0b21BY3Rpb25Qcm92aWRlci5wcm90b3R5cGUsIG5hbWUsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogdGFrZXNXYWxsZXRQcm92aWRlclxuICAgICAgICAgICAgICAgICAgICA/IGFzeW5jIGZ1bmN0aW9uICh3YWxsZXRQcm92aWRlciwgYXJncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkQXJncyA9IHNjaGVtYS5wYXJzZShhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBpbnZva2Uod2FsbGV0UHJvdmlkZXIsIHBhcnNlZEFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIDogYXN5bmMgZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZEFyZ3MgPSBzY2hlbWEucGFyc2UoYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgaW52b2tlKHBhcnNlZEFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBNYW51YWxseSBzZXQgdGhlIHBhcmFtZXRlciBtZXRhZGF0YVxuICAgICAgICAgICAgY29uc3QgcGFyYW1UeXBlcyA9IHRha2VzV2FsbGV0UHJvdmlkZXIgPyBbd2FsbGV0X3Byb3ZpZGVyc18xLldhbGxldFByb3ZpZGVyLCBPYmplY3RdIDogW09iamVjdF07XG4gICAgICAgICAgICBSZWZsZWN0LmRlZmluZU1ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgcGFyYW1UeXBlcywgQ3VzdG9tQWN0aW9uUHJvdmlkZXIucHJvdG90eXBlLCBuYW1lKTtcbiAgICAgICAgICAgIC8vIEFwcGx5IHRoZSBkZWNvcmF0b3IgdXNpbmcgb3JpZ2luYWwgbmFtZVxuICAgICAgICAgICAgY29uc3QgZGVjb3JhdGVkTWV0aG9kID0gKDAsIGFjdGlvbkRlY29yYXRvcl8xLkNyZWF0ZUFjdGlvbikoe1xuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgc2NoZW1hLFxuICAgICAgICAgICAgfSkoQ3VzdG9tQWN0aW9uUHJvdmlkZXIucHJvdG90eXBlLCBuYW1lLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKEN1c3RvbUFjdGlvblByb3ZpZGVyLnByb3RvdHlwZSwgbmFtZSkpO1xuICAgICAgICAgICAgLy8gQWRkIHRoZSBkZWNvcmF0ZWQgbWV0aG9kIHRvIHRoZSBpbnN0YW5jZVxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIG5hbWUsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogZGVjb3JhdGVkTWV0aG9kLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3VzdG9tIGFjdGlvbiBwcm92aWRlcnMgYXJlIHN1cHBvcnRlZCBvbiBhbGwgbmV0d29ya3NcbiAgICAgKlxuICAgICAqIEBwYXJhbSBfIC0gVGhlIG5ldHdvcmsgdG8gY2hlY2twb2ludFNhdmVyXG4gICAgICogQHJldHVybnMgdHJ1ZVxuICAgICAqL1xuICAgIHN1cHBvcnRzTmV0d29yayhfKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cbmV4cG9ydHMuQ3VzdG9tQWN0aW9uUHJvdmlkZXIgPSBDdXN0b21BY3Rpb25Qcm92aWRlcjtcbmNvbnN0IGN1c3RvbUFjdGlvblByb3ZpZGVyID0gKGFjdGlvbnMpID0+IG5ldyBDdXN0b21BY3Rpb25Qcm92aWRlcihBcnJheS5pc0FycmF5KGFjdGlvbnMpID8gYWN0aW9ucyA6IFthY3Rpb25zXSk7XG5leHBvcnRzLmN1c3RvbUFjdGlvblByb3ZpZGVyID0gY3VzdG9tQWN0aW9uUHJvdmlkZXI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/customActionProvider.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/defillama/constants.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/defillama/constants.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DEFILLAMA_PRICES_URL = exports.DEFILLAMA_BASE_URL = void 0;\n/**\n * Base URL for the DefiLlama API\n */\nexports.DEFILLAMA_BASE_URL = \"https://api.llama.fi\";\n/**\n * URL for the DefiLlama price API\n */\nexports.DEFILLAMA_PRICES_URL = \"https://coins.llama.fi\";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9kZWZpbGxhbWEvY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDRCQUE0QixHQUFHLDBCQUEwQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3Vydml2YWwtZnVuLy4vbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9hZ2VudGtpdC9kaXN0L2FjdGlvbi1wcm92aWRlcnMvZGVmaWxsYW1hL2NvbnN0YW50cy5qcz80YTZlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ERUZJTExBTUFfUFJJQ0VTX1VSTCA9IGV4cG9ydHMuREVGSUxMQU1BX0JBU0VfVVJMID0gdm9pZCAwO1xuLyoqXG4gKiBCYXNlIFVSTCBmb3IgdGhlIERlZmlMbGFtYSBBUElcbiAqL1xuZXhwb3J0cy5ERUZJTExBTUFfQkFTRV9VUkwgPSBcImh0dHBzOi8vYXBpLmxsYW1hLmZpXCI7XG4vKipcbiAqIFVSTCBmb3IgdGhlIERlZmlMbGFtYSBwcmljZSBBUElcbiAqL1xuZXhwb3J0cy5ERUZJTExBTUFfUFJJQ0VTX1VSTCA9IFwiaHR0cHM6Ly9jb2lucy5sbGFtYS5maVwiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/defillama/constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/defillama/defillamaActionProvider.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/defillama/defillamaActionProvider.js ***!
  \****************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.defillamaActionProvider = exports.DefiLlamaActionProvider = void 0;\nconst zod_1 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/lib/index.js\");\nconst actionProvider_1 = __webpack_require__(/*! ../actionProvider */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/actionProvider.js\");\nconst actionDecorator_1 = __webpack_require__(/*! ../actionDecorator */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/actionDecorator.js\");\nconst schemas_1 = __webpack_require__(/*! ./schemas */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/defillama/schemas.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/defillama/constants.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/defillama/utils.js\");\n/**\n * DefiLlamaActionProvider is an action provider for DefiLlama API interactions.\n * Provides functionality to fetch token prices, protocol information, and search protocols.\n */\nclass DefiLlamaActionProvider extends actionProvider_1.ActionProvider {\n    /**\n     * Constructor for the DefiLlamaActionProvider class.\n     */\n    constructor() {\n        super(\"defillama\", []);\n    }\n    /**\n     * Searches for protocols on DefiLlama.\n     * Note: This performs a case-insensitive search on protocol names.\n     * Returns all protocols whose names contain the search query.\n     *\n     * @param args - The protocol search parameters\n     * @returns A JSON string containing matching protocols or error message\n     */\n    async searchProtocols(args) {\n        try {\n            const url = `${constants_1.DEFILLAMA_BASE_URL}/protocols`;\n            const response = await fetch(url);\n            if (!response.ok) {\n                throw new Error(`HTTP error! status: ${response.status}`);\n            }\n            const protocols = await response.json();\n            const searchResults = protocols.filter((protocol) => protocol.name.toLowerCase().includes(args.query.toLowerCase()));\n            if (searchResults.length === 0) {\n                return `No protocols found matching \"${args.query}\"`;\n            }\n            return JSON.stringify(searchResults, null, 2);\n        }\n        catch (error) {\n            return `Error searching protocols: ${error}`;\n        }\n    }\n    /**\n     * Gets detailed information about a specific protocol.\n     * Note: Returns null if the protocol is not found.\n     * The response includes TVL, description, category, and other metadata.\n     * Time-series data is pruned to keep response size manageable.\n     *\n     * @param args - The protocol request parameters\n     * @returns A JSON string containing time-series pruned protocol information\n     */\n    async getProtocol(args) {\n        try {\n            const url = `${constants_1.DEFILLAMA_BASE_URL}/protocol/${args.protocolId}`;\n            const response = await fetch(url);\n            if (!response.ok) {\n                throw new Error(`HTTP error! status: ${response.status}`);\n            }\n            const data = (await response.json());\n            const prunedData = (0, utils_1.pruneGetProtocolResponse)(data);\n            return JSON.stringify(prunedData, null, 2);\n        }\n        catch (error) {\n            return `Error fetching protocol information: ${error instanceof Error ? error.message : String(error)}`;\n        }\n    }\n    /**\n     * Gets current token prices from DefiLlama.\n     * Note: Token addresses must include chain prefix (e.g., 'ethereum:0x...')\n     * The searchWidth parameter can be used to specify a time range in minutes.\n     *\n     * @param args - The token price request parameters\n     * @returns A JSON string containing token prices or error message\n     */\n    async getTokenPrices(args) {\n        try {\n            const params = new URLSearchParams({});\n            const tokens = args.tokens.join(\",\");\n            if (args.searchWidth) {\n                params.set(\"searchWidth\", args.searchWidth);\n            }\n            const url = `${constants_1.DEFILLAMA_PRICES_URL}/prices/current/${tokens}?${params.toString()}`;\n            const response = await fetch(url);\n            if (!response.ok) {\n                throw new Error(`HTTP error! status: ${response.status}`);\n            }\n            const data = await response.json();\n            return JSON.stringify(data, null, 2);\n        }\n        catch (error) {\n            return `Error fetching token prices: ${error instanceof Error ? error.message : String(error)}`;\n        }\n    }\n    /**\n     * Checks if the DefiLlama action provider supports the given network.\n     * DefiLlama is network-agnostic, so this always returns true.\n     *\n     * @returns True, as DefiLlama actions are supported on all networks.\n     */\n    supportsNetwork() {\n        return true;\n    }\n}\nexports.DefiLlamaActionProvider = DefiLlamaActionProvider;\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"find_protocol\",\n        description: `This tool will search for DeFi protocols on DefiLlama by name.\nIt takes the following inputs:\n- A search query string to match against protocol names\n\nImportant notes:\n- The search is case-insensitive\n- Returns all protocols whose names contain the search query\n- Returns metadata including TVL, chain, category, and other protocol details\n- Returns a \"No protocols found\" message if no matches are found`,\n        schema: schemas_1.SearchProtocolsSchema,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [void 0]),\n    __metadata(\"design:returntype\", Promise)\n], DefiLlamaActionProvider.prototype, \"searchProtocols\", null);\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"get_protocol\",\n        description: `This tool will fetch detailed information about a specific protocol from DefiLlama.\nIt takes the following inputs:\n- The protocol identifier from DefiLlama (e.g. uniswap)\n\nImportant notes:\n- Returns null if the protocol is not found\n- Returns comprehensive data including TVL, description, category, and other metadata\n- Includes historical TVL data and chain-specific breakdowns where available\n- Returns error message if the protocol ID is invalid or the request fails\n- Prunes time-series data to 5 most recent entries to make the response more manageable`,\n        schema: schemas_1.GetProtocolSchema,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [void 0]),\n    __metadata(\"design:returntype\", Promise)\n], DefiLlamaActionProvider.prototype, \"getProtocol\", null);\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"get_token_prices\",\n        description: `This tool will fetch current token prices from DefiLlama.\nIt takes the following inputs:\n- An array of token addresses with chain prefixes\n- Optional time range in minutes for historical prices\n\nImportant notes:\n- Token addresses MUST include chain prefix (e.g., 'ethereum:0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48')\n- The searchWidth parameter is optional, it's default api value is '4h', leave this blank if unspecified\n- Returns current prices for all specified tokens\n- Returns error message if any token address is invalid or the request fails`,\n        schema: schemas_1.GetTokenPricesSchema,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [void 0]),\n    __metadata(\"design:returntype\", Promise)\n], DefiLlamaActionProvider.prototype, \"getTokenPrices\", null);\n/**\n * Creates a new instance of the DefiLlama action provider.\n *\n * @returns A new DefiLlamaActionProvider instance\n */\nconst defillamaActionProvider = () => new DefiLlamaActionProvider();\nexports.defillamaActionProvider = defillamaActionProvider;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9kZWZpbGxhbWEvZGVmaWxsYW1hQWN0aW9uUHJvdmlkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsUUFBUTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELCtCQUErQixHQUFHLCtCQUErQjtBQUNqRSxjQUFjLG1CQUFPLENBQUMsa0RBQUs7QUFDM0IseUJBQXlCLG1CQUFPLENBQUMsMEdBQW1CO0FBQ3BELDBCQUEwQixtQkFBTyxDQUFDLDRHQUFvQjtBQUN0RCxrQkFBa0IsbUJBQU8sQ0FBQyxxR0FBVztBQUNyQyxvQkFBb0IsbUJBQU8sQ0FBQyx5R0FBYTtBQUN6QyxnQkFBZ0IsbUJBQU8sQ0FBQyxpR0FBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsK0JBQStCO0FBQzFEO0FBQ0E7QUFDQSx1REFBdUQsZ0JBQWdCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELFdBQVc7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsTUFBTTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwrQkFBK0IsWUFBWSxnQkFBZ0I7QUFDdEY7QUFDQTtBQUNBLHVEQUF1RCxnQkFBZ0I7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELHVEQUF1RDtBQUNsSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaUNBQWlDLGtCQUFrQixPQUFPLEdBQUcsa0JBQWtCO0FBQzFHO0FBQ0E7QUFDQSx1REFBdUQsZ0JBQWdCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsdURBQXVEO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3Vydml2YWwtZnVuLy4vbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9hZ2VudGtpdC9kaXN0L2FjdGlvbi1wcm92aWRlcnMvZGVmaWxsYW1hL2RlZmlsbGFtYUFjdGlvblByb3ZpZGVyLmpzP2Q2ZDAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZpbGxhbWFBY3Rpb25Qcm92aWRlciA9IGV4cG9ydHMuRGVmaUxsYW1hQWN0aW9uUHJvdmlkZXIgPSB2b2lkIDA7XG5jb25zdCB6b2RfMSA9IHJlcXVpcmUoXCJ6b2RcIik7XG5jb25zdCBhY3Rpb25Qcm92aWRlcl8xID0gcmVxdWlyZShcIi4uL2FjdGlvblByb3ZpZGVyXCIpO1xuY29uc3QgYWN0aW9uRGVjb3JhdG9yXzEgPSByZXF1aXJlKFwiLi4vYWN0aW9uRGVjb3JhdG9yXCIpO1xuY29uc3Qgc2NoZW1hc18xID0gcmVxdWlyZShcIi4vc2NoZW1hc1wiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuLyoqXG4gKiBEZWZpTGxhbWFBY3Rpb25Qcm92aWRlciBpcyBhbiBhY3Rpb24gcHJvdmlkZXIgZm9yIERlZmlMbGFtYSBBUEkgaW50ZXJhY3Rpb25zLlxuICogUHJvdmlkZXMgZnVuY3Rpb25hbGl0eSB0byBmZXRjaCB0b2tlbiBwcmljZXMsIHByb3RvY29sIGluZm9ybWF0aW9uLCBhbmQgc2VhcmNoIHByb3RvY29scy5cbiAqL1xuY2xhc3MgRGVmaUxsYW1hQWN0aW9uUHJvdmlkZXIgZXh0ZW5kcyBhY3Rpb25Qcm92aWRlcl8xLkFjdGlvblByb3ZpZGVyIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgdGhlIERlZmlMbGFtYUFjdGlvblByb3ZpZGVyIGNsYXNzLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihcImRlZmlsbGFtYVwiLCBbXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlYXJjaGVzIGZvciBwcm90b2NvbHMgb24gRGVmaUxsYW1hLlxuICAgICAqIE5vdGU6IFRoaXMgcGVyZm9ybXMgYSBjYXNlLWluc2Vuc2l0aXZlIHNlYXJjaCBvbiBwcm90b2NvbCBuYW1lcy5cbiAgICAgKiBSZXR1cm5zIGFsbCBwcm90b2NvbHMgd2hvc2UgbmFtZXMgY29udGFpbiB0aGUgc2VhcmNoIHF1ZXJ5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGFyZ3MgLSBUaGUgcHJvdG9jb2wgc2VhcmNoIHBhcmFtZXRlcnNcbiAgICAgKiBAcmV0dXJucyBBIEpTT04gc3RyaW5nIGNvbnRhaW5pbmcgbWF0Y2hpbmcgcHJvdG9jb2xzIG9yIGVycm9yIG1lc3NhZ2VcbiAgICAgKi9cbiAgICBhc3luYyBzZWFyY2hQcm90b2NvbHMoYXJncykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgdXJsID0gYCR7Y29uc3RhbnRzXzEuREVGSUxMQU1BX0JBU0VfVVJMfS9wcm90b2NvbHNgO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwpO1xuICAgICAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCBlcnJvciEgc3RhdHVzOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHByb3RvY29scyA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIGNvbnN0IHNlYXJjaFJlc3VsdHMgPSBwcm90b2NvbHMuZmlsdGVyKChwcm90b2NvbCkgPT4gcHJvdG9jb2wubmFtZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKGFyZ3MucXVlcnkudG9Mb3dlckNhc2UoKSkpO1xuICAgICAgICAgICAgaWYgKHNlYXJjaFJlc3VsdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGBObyBwcm90b2NvbHMgZm91bmQgbWF0Y2hpbmcgXCIke2FyZ3MucXVlcnl9XCJgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHNlYXJjaFJlc3VsdHMsIG51bGwsIDIpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGBFcnJvciBzZWFyY2hpbmcgcHJvdG9jb2xzOiAke2Vycm9yfWA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBkZXRhaWxlZCBpbmZvcm1hdGlvbiBhYm91dCBhIHNwZWNpZmljIHByb3RvY29sLlxuICAgICAqIE5vdGU6IFJldHVybnMgbnVsbCBpZiB0aGUgcHJvdG9jb2wgaXMgbm90IGZvdW5kLlxuICAgICAqIFRoZSByZXNwb25zZSBpbmNsdWRlcyBUVkwsIGRlc2NyaXB0aW9uLCBjYXRlZ29yeSwgYW5kIG90aGVyIG1ldGFkYXRhLlxuICAgICAqIFRpbWUtc2VyaWVzIGRhdGEgaXMgcHJ1bmVkIHRvIGtlZXAgcmVzcG9uc2Ugc2l6ZSBtYW5hZ2VhYmxlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFyZ3MgLSBUaGUgcHJvdG9jb2wgcmVxdWVzdCBwYXJhbWV0ZXJzXG4gICAgICogQHJldHVybnMgQSBKU09OIHN0cmluZyBjb250YWluaW5nIHRpbWUtc2VyaWVzIHBydW5lZCBwcm90b2NvbCBpbmZvcm1hdGlvblxuICAgICAqL1xuICAgIGFzeW5jIGdldFByb3RvY29sKGFyZ3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IGAke2NvbnN0YW50c18xLkRFRklMTEFNQV9CQVNFX1VSTH0vcHJvdG9jb2wvJHthcmdzLnByb3RvY29sSWR9YDtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsKTtcbiAgICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEhUVFAgZXJyb3IhIHN0YXR1czogJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gKGF3YWl0IHJlc3BvbnNlLmpzb24oKSk7XG4gICAgICAgICAgICBjb25zdCBwcnVuZWREYXRhID0gKDAsIHV0aWxzXzEucHJ1bmVHZXRQcm90b2NvbFJlc3BvbnNlKShkYXRhKTtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShwcnVuZWREYXRhLCBudWxsLCAyKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBgRXJyb3IgZmV0Y2hpbmcgcHJvdG9jb2wgaW5mb3JtYXRpb246ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpfWA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBjdXJyZW50IHRva2VuIHByaWNlcyBmcm9tIERlZmlMbGFtYS5cbiAgICAgKiBOb3RlOiBUb2tlbiBhZGRyZXNzZXMgbXVzdCBpbmNsdWRlIGNoYWluIHByZWZpeCAoZS5nLiwgJ2V0aGVyZXVtOjB4Li4uJylcbiAgICAgKiBUaGUgc2VhcmNoV2lkdGggcGFyYW1ldGVyIGNhbiBiZSB1c2VkIHRvIHNwZWNpZnkgYSB0aW1lIHJhbmdlIGluIG1pbnV0ZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXJncyAtIFRoZSB0b2tlbiBwcmljZSByZXF1ZXN0IHBhcmFtZXRlcnNcbiAgICAgKiBAcmV0dXJucyBBIEpTT04gc3RyaW5nIGNvbnRhaW5pbmcgdG9rZW4gcHJpY2VzIG9yIGVycm9yIG1lc3NhZ2VcbiAgICAgKi9cbiAgICBhc3luYyBnZXRUb2tlblByaWNlcyhhcmdzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHt9KTtcbiAgICAgICAgICAgIGNvbnN0IHRva2VucyA9IGFyZ3MudG9rZW5zLmpvaW4oXCIsXCIpO1xuICAgICAgICAgICAgaWYgKGFyZ3Muc2VhcmNoV2lkdGgpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMuc2V0KFwic2VhcmNoV2lkdGhcIiwgYXJncy5zZWFyY2hXaWR0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB1cmwgPSBgJHtjb25zdGFudHNfMS5ERUZJTExBTUFfUFJJQ0VTX1VSTH0vcHJpY2VzL2N1cnJlbnQvJHt0b2tlbnN9PyR7cGFyYW1zLnRvU3RyaW5nKCl9YDtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsKTtcbiAgICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEhUVFAgZXJyb3IhIHN0YXR1czogJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGRhdGEsIG51bGwsIDIpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGBFcnJvciBmZXRjaGluZyB0b2tlbiBwcmljZXM6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpfWA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBEZWZpTGxhbWEgYWN0aW9uIHByb3ZpZGVyIHN1cHBvcnRzIHRoZSBnaXZlbiBuZXR3b3JrLlxuICAgICAqIERlZmlMbGFtYSBpcyBuZXR3b3JrLWFnbm9zdGljLCBzbyB0aGlzIGFsd2F5cyByZXR1cm5zIHRydWUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUcnVlLCBhcyBEZWZpTGxhbWEgYWN0aW9ucyBhcmUgc3VwcG9ydGVkIG9uIGFsbCBuZXR3b3Jrcy5cbiAgICAgKi9cbiAgICBzdXBwb3J0c05ldHdvcmsoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cbmV4cG9ydHMuRGVmaUxsYW1hQWN0aW9uUHJvdmlkZXIgPSBEZWZpTGxhbWFBY3Rpb25Qcm92aWRlcjtcbl9fZGVjb3JhdGUoW1xuICAgICgwLCBhY3Rpb25EZWNvcmF0b3JfMS5DcmVhdGVBY3Rpb24pKHtcbiAgICAgICAgbmFtZTogXCJmaW5kX3Byb3RvY29sXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgVGhpcyB0b29sIHdpbGwgc2VhcmNoIGZvciBEZUZpIHByb3RvY29scyBvbiBEZWZpTGxhbWEgYnkgbmFtZS5cbkl0IHRha2VzIHRoZSBmb2xsb3dpbmcgaW5wdXRzOlxuLSBBIHNlYXJjaCBxdWVyeSBzdHJpbmcgdG8gbWF0Y2ggYWdhaW5zdCBwcm90b2NvbCBuYW1lc1xuXG5JbXBvcnRhbnQgbm90ZXM6XG4tIFRoZSBzZWFyY2ggaXMgY2FzZS1pbnNlbnNpdGl2ZVxuLSBSZXR1cm5zIGFsbCBwcm90b2NvbHMgd2hvc2UgbmFtZXMgY29udGFpbiB0aGUgc2VhcmNoIHF1ZXJ5XG4tIFJldHVybnMgbWV0YWRhdGEgaW5jbHVkaW5nIFRWTCwgY2hhaW4sIGNhdGVnb3J5LCBhbmQgb3RoZXIgcHJvdG9jb2wgZGV0YWlsc1xuLSBSZXR1cm5zIGEgXCJObyBwcm90b2NvbHMgZm91bmRcIiBtZXNzYWdlIGlmIG5vIG1hdGNoZXMgYXJlIGZvdW5kYCxcbiAgICAgICAgc2NoZW1hOiBzY2hlbWFzXzEuU2VhcmNoUHJvdG9jb2xzU2NoZW1hLFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFt2b2lkIDBdKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgUHJvbWlzZSlcbl0sIERlZmlMbGFtYUFjdGlvblByb3ZpZGVyLnByb3RvdHlwZSwgXCJzZWFyY2hQcm90b2NvbHNcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICAoMCwgYWN0aW9uRGVjb3JhdG9yXzEuQ3JlYXRlQWN0aW9uKSh7XG4gICAgICAgIG5hbWU6IFwiZ2V0X3Byb3RvY29sXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgVGhpcyB0b29sIHdpbGwgZmV0Y2ggZGV0YWlsZWQgaW5mb3JtYXRpb24gYWJvdXQgYSBzcGVjaWZpYyBwcm90b2NvbCBmcm9tIERlZmlMbGFtYS5cbkl0IHRha2VzIHRoZSBmb2xsb3dpbmcgaW5wdXRzOlxuLSBUaGUgcHJvdG9jb2wgaWRlbnRpZmllciBmcm9tIERlZmlMbGFtYSAoZS5nLiB1bmlzd2FwKVxuXG5JbXBvcnRhbnQgbm90ZXM6XG4tIFJldHVybnMgbnVsbCBpZiB0aGUgcHJvdG9jb2wgaXMgbm90IGZvdW5kXG4tIFJldHVybnMgY29tcHJlaGVuc2l2ZSBkYXRhIGluY2x1ZGluZyBUVkwsIGRlc2NyaXB0aW9uLCBjYXRlZ29yeSwgYW5kIG90aGVyIG1ldGFkYXRhXG4tIEluY2x1ZGVzIGhpc3RvcmljYWwgVFZMIGRhdGEgYW5kIGNoYWluLXNwZWNpZmljIGJyZWFrZG93bnMgd2hlcmUgYXZhaWxhYmxlXG4tIFJldHVybnMgZXJyb3IgbWVzc2FnZSBpZiB0aGUgcHJvdG9jb2wgSUQgaXMgaW52YWxpZCBvciB0aGUgcmVxdWVzdCBmYWlsc1xuLSBQcnVuZXMgdGltZS1zZXJpZXMgZGF0YSB0byA1IG1vc3QgcmVjZW50IGVudHJpZXMgdG8gbWFrZSB0aGUgcmVzcG9uc2UgbW9yZSBtYW5hZ2VhYmxlYCxcbiAgICAgICAgc2NoZW1hOiBzY2hlbWFzXzEuR2V0UHJvdG9jb2xTY2hlbWEsXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW3ZvaWQgMF0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCBQcm9taXNlKVxuXSwgRGVmaUxsYW1hQWN0aW9uUHJvdmlkZXIucHJvdG90eXBlLCBcImdldFByb3RvY29sXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgKDAsIGFjdGlvbkRlY29yYXRvcl8xLkNyZWF0ZUFjdGlvbikoe1xuICAgICAgICBuYW1lOiBcImdldF90b2tlbl9wcmljZXNcIixcbiAgICAgICAgZGVzY3JpcHRpb246IGBUaGlzIHRvb2wgd2lsbCBmZXRjaCBjdXJyZW50IHRva2VuIHByaWNlcyBmcm9tIERlZmlMbGFtYS5cbkl0IHRha2VzIHRoZSBmb2xsb3dpbmcgaW5wdXRzOlxuLSBBbiBhcnJheSBvZiB0b2tlbiBhZGRyZXNzZXMgd2l0aCBjaGFpbiBwcmVmaXhlc1xuLSBPcHRpb25hbCB0aW1lIHJhbmdlIGluIG1pbnV0ZXMgZm9yIGhpc3RvcmljYWwgcHJpY2VzXG5cbkltcG9ydGFudCBub3Rlczpcbi0gVG9rZW4gYWRkcmVzc2VzIE1VU1QgaW5jbHVkZSBjaGFpbiBwcmVmaXggKGUuZy4sICdldGhlcmV1bToweGEwYjg2OTkxYzYyMThiMzZjMWQxOWQ0YTJlOWViMGNlMzYwNmViNDgnKVxuLSBUaGUgc2VhcmNoV2lkdGggcGFyYW1ldGVyIGlzIG9wdGlvbmFsLCBpdCdzIGRlZmF1bHQgYXBpIHZhbHVlIGlzICc0aCcsIGxlYXZlIHRoaXMgYmxhbmsgaWYgdW5zcGVjaWZpZWRcbi0gUmV0dXJucyBjdXJyZW50IHByaWNlcyBmb3IgYWxsIHNwZWNpZmllZCB0b2tlbnNcbi0gUmV0dXJucyBlcnJvciBtZXNzYWdlIGlmIGFueSB0b2tlbiBhZGRyZXNzIGlzIGludmFsaWQgb3IgdGhlIHJlcXVlc3QgZmFpbHNgLFxuICAgICAgICBzY2hlbWE6IHNjaGVtYXNfMS5HZXRUb2tlblByaWNlc1NjaGVtYSxcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbdm9pZCAwXSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIFByb21pc2UpXG5dLCBEZWZpTGxhbWFBY3Rpb25Qcm92aWRlci5wcm90b3R5cGUsIFwiZ2V0VG9rZW5QcmljZXNcIiwgbnVsbCk7XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIERlZmlMbGFtYSBhY3Rpb24gcHJvdmlkZXIuXG4gKlxuICogQHJldHVybnMgQSBuZXcgRGVmaUxsYW1hQWN0aW9uUHJvdmlkZXIgaW5zdGFuY2VcbiAqL1xuY29uc3QgZGVmaWxsYW1hQWN0aW9uUHJvdmlkZXIgPSAoKSA9PiBuZXcgRGVmaUxsYW1hQWN0aW9uUHJvdmlkZXIoKTtcbmV4cG9ydHMuZGVmaWxsYW1hQWN0aW9uUHJvdmlkZXIgPSBkZWZpbGxhbWFBY3Rpb25Qcm92aWRlcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/defillama/defillamaActionProvider.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/defillama/index.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/defillama/index.js ***!
  \**********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./defillamaActionProvider */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/defillama/defillamaActionProvider.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9kZWZpbGxhbWEvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYSxtQkFBTyxDQUFDLHFJQUEyQiIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cnZpdmFsLWZ1bi8uL25vZGVfbW9kdWxlcy9AY29pbmJhc2UvYWdlbnRraXQvZGlzdC9hY3Rpb24tcHJvdmlkZXJzL2RlZmlsbGFtYS9pbmRleC5qcz8wMjY3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZGVmaWxsYW1hQWN0aW9uUHJvdmlkZXJcIiksIGV4cG9ydHMpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/defillama/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/defillama/schemas.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/defillama/schemas.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SearchProtocolsSchema = exports.GetTokenPricesSchema = exports.GetProtocolSchema = void 0;\nconst zod_1 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/lib/index.js\");\n/**\n * Input schema for getting protocol information\n */\nexports.GetProtocolSchema = zod_1.z\n    .object({\n    protocolId: zod_1.z.string().describe(\"The protocol identifier from DefiLlama\"),\n})\n    .strict();\n/**\n * Input schema for getting token prices\n */\nexports.GetTokenPricesSchema = zod_1.z\n    .object({\n    tokens: zod_1.z\n        .array(zod_1.z.string())\n        .describe(\"Array of token addresses with chain prefix, e.g., ['ethereum:0x...']\"),\n    searchWidth: zod_1.z\n        .string()\n        .optional()\n        .describe(\"Optional time range in minutes to search for prices, default api value is '4h'\"),\n})\n    .strict();\n/**\n * Input schema for searching protocols\n */\nexports.SearchProtocolsSchema = zod_1.z\n    .object({\n    query: zod_1.z.string().describe(\"Search query to find protocols\"),\n})\n    .strict();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9kZWZpbGxhbWEvc2NoZW1hcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw2QkFBNkIsR0FBRyw0QkFBNEIsR0FBRyx5QkFBeUI7QUFDeEYsY0FBYyxtQkFBTyxDQUFDLGtEQUFLO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLENBQUM7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cnZpdmFsLWZ1bi8uL25vZGVfbW9kdWxlcy9AY29pbmJhc2UvYWdlbnRraXQvZGlzdC9hY3Rpb24tcHJvdmlkZXJzL2RlZmlsbGFtYS9zY2hlbWFzLmpzP2UyYjIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNlYXJjaFByb3RvY29sc1NjaGVtYSA9IGV4cG9ydHMuR2V0VG9rZW5QcmljZXNTY2hlbWEgPSBleHBvcnRzLkdldFByb3RvY29sU2NoZW1hID0gdm9pZCAwO1xuY29uc3Qgem9kXzEgPSByZXF1aXJlKFwiem9kXCIpO1xuLyoqXG4gKiBJbnB1dCBzY2hlbWEgZm9yIGdldHRpbmcgcHJvdG9jb2wgaW5mb3JtYXRpb25cbiAqL1xuZXhwb3J0cy5HZXRQcm90b2NvbFNjaGVtYSA9IHpvZF8xLnpcbiAgICAub2JqZWN0KHtcbiAgICBwcm90b2NvbElkOiB6b2RfMS56LnN0cmluZygpLmRlc2NyaWJlKFwiVGhlIHByb3RvY29sIGlkZW50aWZpZXIgZnJvbSBEZWZpTGxhbWFcIiksXG59KVxuICAgIC5zdHJpY3QoKTtcbi8qKlxuICogSW5wdXQgc2NoZW1hIGZvciBnZXR0aW5nIHRva2VuIHByaWNlc1xuICovXG5leHBvcnRzLkdldFRva2VuUHJpY2VzU2NoZW1hID0gem9kXzEuelxuICAgIC5vYmplY3Qoe1xuICAgIHRva2Vuczogem9kXzEuelxuICAgICAgICAuYXJyYXkoem9kXzEuei5zdHJpbmcoKSlcbiAgICAgICAgLmRlc2NyaWJlKFwiQXJyYXkgb2YgdG9rZW4gYWRkcmVzc2VzIHdpdGggY2hhaW4gcHJlZml4LCBlLmcuLCBbJ2V0aGVyZXVtOjB4Li4uJ11cIiksXG4gICAgc2VhcmNoV2lkdGg6IHpvZF8xLnpcbiAgICAgICAgLnN0cmluZygpXG4gICAgICAgIC5vcHRpb25hbCgpXG4gICAgICAgIC5kZXNjcmliZShcIk9wdGlvbmFsIHRpbWUgcmFuZ2UgaW4gbWludXRlcyB0byBzZWFyY2ggZm9yIHByaWNlcywgZGVmYXVsdCBhcGkgdmFsdWUgaXMgJzRoJ1wiKSxcbn0pXG4gICAgLnN0cmljdCgpO1xuLyoqXG4gKiBJbnB1dCBzY2hlbWEgZm9yIHNlYXJjaGluZyBwcm90b2NvbHNcbiAqL1xuZXhwb3J0cy5TZWFyY2hQcm90b2NvbHNTY2hlbWEgPSB6b2RfMS56XG4gICAgLm9iamVjdCh7XG4gICAgcXVlcnk6IHpvZF8xLnouc3RyaW5nKCkuZGVzY3JpYmUoXCJTZWFyY2ggcXVlcnkgdG8gZmluZCBwcm90b2NvbHNcIiksXG59KVxuICAgIC5zdHJpY3QoKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/defillama/schemas.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/defillama/utils.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/defillama/utils.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.pruneGetProtocolResponse = void 0;\n/**\n * Processes a time-series array by sorting by date (newest first) and limiting to maxEntries\n *\n * @param array - The time-series array to process\n * @param maxEntries - Maximum number of entries to keep\n * @returns The processed array (sorted and limited)\n */\nconst processTimeSeriesArray = (array, maxEntries) => {\n    if (array.length <= maxEntries) {\n        return array;\n    }\n    // Sort by date if array items have date property\n    if (array.length > 0 && typeof array[0] === \"object\" && array[0] !== null && \"date\" in array[0]) {\n        array.sort((a, b) => {\n            if (a &&\n                b &&\n                typeof a === \"object\" &&\n                typeof b === \"object\" &&\n                \"date\" in a &&\n                \"date\" in b &&\n                typeof a.date === \"number\" &&\n                typeof b.date === \"number\") {\n                return b.date - a.date;\n            }\n            return 0;\n        });\n    }\n    return array.slice(0, maxEntries);\n};\n/**\n * Prunes the protocol response by limiting time-series data arrays\n * to show only the most recent entries.\n *\n * @param data - The original protocol data from DefiLlama API\n * @param maxEntries - The maximum number of time-series entries to keep (default: 5)\n * @returns A pruned copy of the protocol data\n */\nconst pruneGetProtocolResponse = (data, maxEntries = 5) => {\n    if (!data) {\n        return null;\n    }\n    const result = { ...data };\n    const timeSeriesArrayPaths = [\"tvl\", \"tokens\", \"tokensInUsd\"];\n    const processNestedObject = (obj, currentPath = \"\") => {\n        if (!obj || typeof obj !== \"object\") {\n            return obj;\n        }\n        if (Array.isArray(obj)) {\n            const isTimeSeriesArray = timeSeriesArrayPaths.some(path => currentPath === path || currentPath.endsWith(`.${path}`));\n            if (isTimeSeriesArray) {\n                return processTimeSeriesArray(obj, maxEntries);\n            }\n            for (let i = 0; i < obj.length; i++) {\n                obj[i] = processNestedObject(obj[i], `${currentPath}[${i}]`);\n            }\n        }\n        else if (obj !== null) {\n            // Safe to cast to Record<string, unknown> since we know it's an object and not null\n            const record = obj;\n            for (const key of Object.keys(record)) {\n                const newPath = currentPath ? `${currentPath}.${key}` : key;\n                const value = record[key];\n                if (value && typeof value === \"object\") {\n                    record[key] = processNestedObject(value, newPath);\n                }\n            }\n        }\n        return obj;\n    };\n    // Special handling for chainTvls if it exists\n    if (result.chainTvls) {\n        for (const chain of Object.keys(result.chainTvls)) {\n            const chainData = result.chainTvls[chain];\n            for (const timeSeriesKey of timeSeriesArrayPaths) {\n                if (chainData[timeSeriesKey] && Array.isArray(chainData[timeSeriesKey])) {\n                    chainData[timeSeriesKey] = processTimeSeriesArray(chainData[timeSeriesKey], maxEntries);\n                }\n            }\n        }\n    }\n    processNestedObject(result);\n    return result;\n};\nexports.pruneGetProtocolResponse = pruneGetProtocolResponse;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9kZWZpbGxhbWEvdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5SEFBeUgsS0FBSztBQUM5SDtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZ0JBQWdCO0FBQzVDLHdEQUF3RCxZQUFZLEdBQUcsRUFBRTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsWUFBWSxHQUFHLElBQUk7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXJ2aXZhbC1mdW4vLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9kZWZpbGxhbWEvdXRpbHMuanM/ZGUzNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucHJ1bmVHZXRQcm90b2NvbFJlc3BvbnNlID0gdm9pZCAwO1xuLyoqXG4gKiBQcm9jZXNzZXMgYSB0aW1lLXNlcmllcyBhcnJheSBieSBzb3J0aW5nIGJ5IGRhdGUgKG5ld2VzdCBmaXJzdCkgYW5kIGxpbWl0aW5nIHRvIG1heEVudHJpZXNcbiAqXG4gKiBAcGFyYW0gYXJyYXkgLSBUaGUgdGltZS1zZXJpZXMgYXJyYXkgdG8gcHJvY2Vzc1xuICogQHBhcmFtIG1heEVudHJpZXMgLSBNYXhpbXVtIG51bWJlciBvZiBlbnRyaWVzIHRvIGtlZXBcbiAqIEByZXR1cm5zIFRoZSBwcm9jZXNzZWQgYXJyYXkgKHNvcnRlZCBhbmQgbGltaXRlZClcbiAqL1xuY29uc3QgcHJvY2Vzc1RpbWVTZXJpZXNBcnJheSA9IChhcnJheSwgbWF4RW50cmllcykgPT4ge1xuICAgIGlmIChhcnJheS5sZW5ndGggPD0gbWF4RW50cmllcykge1xuICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuICAgIC8vIFNvcnQgYnkgZGF0ZSBpZiBhcnJheSBpdGVtcyBoYXZlIGRhdGUgcHJvcGVydHlcbiAgICBpZiAoYXJyYXkubGVuZ3RoID4gMCAmJiB0eXBlb2YgYXJyYXlbMF0gPT09IFwib2JqZWN0XCIgJiYgYXJyYXlbMF0gIT09IG51bGwgJiYgXCJkYXRlXCIgaW4gYXJyYXlbMF0pIHtcbiAgICAgICAgYXJyYXkuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgICAgaWYgKGEgJiZcbiAgICAgICAgICAgICAgICBiICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGEgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgYiA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgICAgIFwiZGF0ZVwiIGluIGEgJiZcbiAgICAgICAgICAgICAgICBcImRhdGVcIiBpbiBiICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGEuZGF0ZSA9PT0gXCJudW1iZXJcIiAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBiLmRhdGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYi5kYXRlIC0gYS5kYXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXkuc2xpY2UoMCwgbWF4RW50cmllcyk7XG59O1xuLyoqXG4gKiBQcnVuZXMgdGhlIHByb3RvY29sIHJlc3BvbnNlIGJ5IGxpbWl0aW5nIHRpbWUtc2VyaWVzIGRhdGEgYXJyYXlzXG4gKiB0byBzaG93IG9ubHkgdGhlIG1vc3QgcmVjZW50IGVudHJpZXMuXG4gKlxuICogQHBhcmFtIGRhdGEgLSBUaGUgb3JpZ2luYWwgcHJvdG9jb2wgZGF0YSBmcm9tIERlZmlMbGFtYSBBUElcbiAqIEBwYXJhbSBtYXhFbnRyaWVzIC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIHRpbWUtc2VyaWVzIGVudHJpZXMgdG8ga2VlcCAoZGVmYXVsdDogNSlcbiAqIEByZXR1cm5zIEEgcHJ1bmVkIGNvcHkgb2YgdGhlIHByb3RvY29sIGRhdGFcbiAqL1xuY29uc3QgcHJ1bmVHZXRQcm90b2NvbFJlc3BvbnNlID0gKGRhdGEsIG1heEVudHJpZXMgPSA1KSA9PiB7XG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSB7IC4uLmRhdGEgfTtcbiAgICBjb25zdCB0aW1lU2VyaWVzQXJyYXlQYXRocyA9IFtcInR2bFwiLCBcInRva2Vuc1wiLCBcInRva2Vuc0luVXNkXCJdO1xuICAgIGNvbnN0IHByb2Nlc3NOZXN0ZWRPYmplY3QgPSAob2JqLCBjdXJyZW50UGF0aCA9IFwiXCIpID0+IHtcbiAgICAgICAgaWYgKCFvYmogfHwgdHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgICAgICBjb25zdCBpc1RpbWVTZXJpZXNBcnJheSA9IHRpbWVTZXJpZXNBcnJheVBhdGhzLnNvbWUocGF0aCA9PiBjdXJyZW50UGF0aCA9PT0gcGF0aCB8fCBjdXJyZW50UGF0aC5lbmRzV2l0aChgLiR7cGF0aH1gKSk7XG4gICAgICAgICAgICBpZiAoaXNUaW1lU2VyaWVzQXJyYXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvY2Vzc1RpbWVTZXJpZXNBcnJheShvYmosIG1heEVudHJpZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvYmoubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBvYmpbaV0gPSBwcm9jZXNzTmVzdGVkT2JqZWN0KG9ialtpXSwgYCR7Y3VycmVudFBhdGh9WyR7aX1dYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob2JqICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBTYWZlIHRvIGNhc3QgdG8gUmVjb3JkPHN0cmluZywgdW5rbm93bj4gc2luY2Ugd2Uga25vdyBpdCdzIGFuIG9iamVjdCBhbmQgbm90IG51bGxcbiAgICAgICAgICAgIGNvbnN0IHJlY29yZCA9IG9iajtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHJlY29yZCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdQYXRoID0gY3VycmVudFBhdGggPyBgJHtjdXJyZW50UGF0aH0uJHtrZXl9YCA6IGtleTtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHJlY29yZFtrZXldO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjb3JkW2tleV0gPSBwcm9jZXNzTmVzdGVkT2JqZWN0KHZhbHVlLCBuZXdQYXRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9O1xuICAgIC8vIFNwZWNpYWwgaGFuZGxpbmcgZm9yIGNoYWluVHZscyBpZiBpdCBleGlzdHNcbiAgICBpZiAocmVzdWx0LmNoYWluVHZscykge1xuICAgICAgICBmb3IgKGNvbnN0IGNoYWluIG9mIE9iamVjdC5rZXlzKHJlc3VsdC5jaGFpblR2bHMpKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFpbkRhdGEgPSByZXN1bHQuY2hhaW5UdmxzW2NoYWluXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdGltZVNlcmllc0tleSBvZiB0aW1lU2VyaWVzQXJyYXlQYXRocykge1xuICAgICAgICAgICAgICAgIGlmIChjaGFpbkRhdGFbdGltZVNlcmllc0tleV0gJiYgQXJyYXkuaXNBcnJheShjaGFpbkRhdGFbdGltZVNlcmllc0tleV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYWluRGF0YVt0aW1lU2VyaWVzS2V5XSA9IHByb2Nlc3NUaW1lU2VyaWVzQXJyYXkoY2hhaW5EYXRhW3RpbWVTZXJpZXNLZXldLCBtYXhFbnRyaWVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJvY2Vzc05lc3RlZE9iamVjdChyZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuZXhwb3J0cy5wcnVuZUdldFByb3RvY29sUmVzcG9uc2UgPSBwcnVuZUdldFByb3RvY29sUmVzcG9uc2U7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/defillama/utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/erc20/constants.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/erc20/constants.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BaseSepoliaTokenToAssetId = exports.BaseTokenToAssetId = exports.abi = void 0;\nconst coinbase_sdk_1 = __webpack_require__(/*! @coinbase/coinbase-sdk */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/index.js\");\nexports.abi = [\n    {\n        type: \"event\",\n        name: \"Approval\",\n        inputs: [\n            {\n                indexed: true,\n                name: \"owner\",\n                type: \"address\",\n            },\n            {\n                indexed: true,\n                name: \"spender\",\n                type: \"address\",\n            },\n            {\n                indexed: false,\n                name: \"value\",\n                type: \"uint256\",\n            },\n        ],\n    },\n    {\n        type: \"event\",\n        name: \"Transfer\",\n        inputs: [\n            {\n                indexed: true,\n                name: \"from\",\n                type: \"address\",\n            },\n            {\n                indexed: true,\n                name: \"to\",\n                type: \"address\",\n            },\n            {\n                indexed: false,\n                name: \"value\",\n                type: \"uint256\",\n            },\n        ],\n    },\n    {\n        type: \"function\",\n        name: \"allowance\",\n        stateMutability: \"view\",\n        inputs: [\n            {\n                name: \"owner\",\n                type: \"address\",\n            },\n            {\n                name: \"spender\",\n                type: \"address\",\n            },\n        ],\n        outputs: [\n            {\n                type: \"uint256\",\n            },\n        ],\n    },\n    {\n        type: \"function\",\n        name: \"approve\",\n        stateMutability: \"nonpayable\",\n        inputs: [\n            {\n                name: \"spender\",\n                type: \"address\",\n            },\n            {\n                name: \"amount\",\n                type: \"uint256\",\n            },\n        ],\n        outputs: [\n            {\n                type: \"bool\",\n            },\n        ],\n    },\n    {\n        type: \"function\",\n        name: \"balanceOf\",\n        stateMutability: \"view\",\n        inputs: [\n            {\n                name: \"account\",\n                type: \"address\",\n            },\n        ],\n        outputs: [\n            {\n                type: \"uint256\",\n            },\n        ],\n    },\n    {\n        type: \"function\",\n        name: \"decimals\",\n        stateMutability: \"view\",\n        inputs: [],\n        outputs: [\n            {\n                type: \"uint8\",\n            },\n        ],\n    },\n    {\n        type: \"function\",\n        name: \"name\",\n        stateMutability: \"view\",\n        inputs: [],\n        outputs: [\n            {\n                type: \"string\",\n            },\n        ],\n    },\n    {\n        type: \"function\",\n        name: \"symbol\",\n        stateMutability: \"view\",\n        inputs: [],\n        outputs: [\n            {\n                type: \"string\",\n            },\n        ],\n    },\n    {\n        type: \"function\",\n        name: \"totalSupply\",\n        stateMutability: \"view\",\n        inputs: [],\n        outputs: [\n            {\n                type: \"uint256\",\n            },\n        ],\n    },\n    {\n        type: \"function\",\n        name: \"transfer\",\n        stateMutability: \"nonpayable\",\n        inputs: [\n            {\n                name: \"recipient\",\n                type: \"address\",\n            },\n            {\n                name: \"amount\",\n                type: \"uint256\",\n            },\n        ],\n        outputs: [\n            {\n                type: \"bool\",\n            },\n        ],\n    },\n    {\n        type: \"function\",\n        name: \"transferFrom\",\n        stateMutability: \"nonpayable\",\n        inputs: [\n            {\n                name: \"sender\",\n                type: \"address\",\n            },\n            {\n                name: \"recipient\",\n                type: \"address\",\n            },\n            {\n                name: \"amount\",\n                type: \"uint256\",\n            },\n        ],\n        outputs: [\n            {\n                type: \"bool\",\n            },\n        ],\n    },\n];\nexports.BaseTokenToAssetId = new Map([\n    [\"0xcbB7C0000aB88B473b1f5aFd9ef808440eed33Bf\", coinbase_sdk_1.Coinbase.assets.Cbbtc],\n    [\"0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913\", coinbase_sdk_1.Coinbase.assets.Usdc],\n    [\"0x60a3E35Cc302bFA44Cb288Bc5a4F316Fdb1adb42\", coinbase_sdk_1.Coinbase.assets.Eurc],\n]);\nexports.BaseSepoliaTokenToAssetId = new Map([\n    [\"0xcbB7C0006F23900c38EB856149F799620fcb8A4a\", coinbase_sdk_1.Coinbase.assets.Cbbtc],\n    [\"0x036CbD53842c5426634e7929541eC2318f3dCF7e\", coinbase_sdk_1.Coinbase.assets.Usdc],\n    [\"0x808456652fdb597867f38412077A9182bf77359F\", coinbase_sdk_1.Coinbase.assets.Eurc],\n]);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9lcmMyMC9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUNBQWlDLEdBQUcsMEJBQTBCLEdBQUcsV0FBVztBQUM1RSx1QkFBdUIsbUJBQU8sQ0FBQyx5RkFBd0I7QUFDdkQsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3Vydml2YWwtZnVuLy4vbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9hZ2VudGtpdC9kaXN0L2FjdGlvbi1wcm92aWRlcnMvZXJjMjAvY29uc3RhbnRzLmpzPzMwZmIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJhc2VTZXBvbGlhVG9rZW5Ub0Fzc2V0SWQgPSBleHBvcnRzLkJhc2VUb2tlblRvQXNzZXRJZCA9IGV4cG9ydHMuYWJpID0gdm9pZCAwO1xuY29uc3QgY29pbmJhc2Vfc2RrXzEgPSByZXF1aXJlKFwiQGNvaW5iYXNlL2NvaW5iYXNlLXNka1wiKTtcbmV4cG9ydHMuYWJpID0gW1xuICAgIHtcbiAgICAgICAgdHlwZTogXCJldmVudFwiLFxuICAgICAgICBuYW1lOiBcIkFwcHJvdmFsXCIsXG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGluZGV4ZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJvd25lclwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbmRleGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgIG5hbWU6IFwic3BlbmRlclwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbmRleGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBuYW1lOiBcInZhbHVlXCIsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgIH0sXG4gICAge1xuICAgICAgICB0eXBlOiBcImV2ZW50XCIsXG4gICAgICAgIG5hbWU6IFwiVHJhbnNmZXJcIixcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW5kZXhlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBuYW1lOiBcImZyb21cIixcbiAgICAgICAgICAgICAgICB0eXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW5kZXhlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBuYW1lOiBcInRvXCIsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGluZGV4ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIG5hbWU6IFwidmFsdWVcIixcbiAgICAgICAgICAgICAgICB0eXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgbmFtZTogXCJhbGxvd2FuY2VcIixcbiAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIixcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJvd25lclwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcInNwZW5kZXJcIixcbiAgICAgICAgICAgICAgICB0eXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIG91dHB1dHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgbmFtZTogXCJhcHByb3ZlXCIsXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogXCJub25wYXlhYmxlXCIsXG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6IFwic3BlbmRlclwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcImFtb3VudFwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgb3V0cHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiYm9vbFwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICBuYW1lOiBcImJhbGFuY2VPZlwiLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6IFwidmlld1wiLFxuICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcImFjY291bnRcIixcbiAgICAgICAgICAgICAgICB0eXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIG91dHB1dHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgbmFtZTogXCJkZWNpbWFsc1wiLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6IFwidmlld1wiLFxuICAgICAgICBpbnB1dHM6IFtdLFxuICAgICAgICBvdXRwdXRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJ1aW50OFwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICBuYW1lOiBcIm5hbWVcIixcbiAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIixcbiAgICAgICAgaW5wdXRzOiBbXSxcbiAgICAgICAgb3V0cHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgIH0sXG4gICAge1xuICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgIG5hbWU6IFwic3ltYm9sXCIsXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgICAgIGlucHV0czogW10sXG4gICAgICAgIG91dHB1dHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICBuYW1lOiBcInRvdGFsU3VwcGx5XCIsXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgICAgIGlucHV0czogW10sXG4gICAgICAgIG91dHB1dHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgbmFtZTogXCJ0cmFuc2ZlclwiLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6IFwibm9ucGF5YWJsZVwiLFxuICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcInJlY2lwaWVudFwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcImFtb3VudFwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgb3V0cHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiYm9vbFwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICBuYW1lOiBcInRyYW5zZmVyRnJvbVwiLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6IFwibm9ucGF5YWJsZVwiLFxuICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcInNlbmRlclwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcInJlY2lwaWVudFwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcImFtb3VudFwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgb3V0cHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiYm9vbFwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICB9LFxuXTtcbmV4cG9ydHMuQmFzZVRva2VuVG9Bc3NldElkID0gbmV3IE1hcChbXG4gICAgW1wiMHhjYkI3QzAwMDBhQjg4QjQ3M2IxZjVhRmQ5ZWY4MDg0NDBlZWQzM0JmXCIsIGNvaW5iYXNlX3Nka18xLkNvaW5iYXNlLmFzc2V0cy5DYmJ0Y10sXG4gICAgW1wiMHg4MzM1ODlmQ0Q2ZURiNkUwOGY0YzdDMzJENGY3MWI1NGJkQTAyOTEzXCIsIGNvaW5iYXNlX3Nka18xLkNvaW5iYXNlLmFzc2V0cy5Vc2RjXSxcbiAgICBbXCIweDYwYTNFMzVDYzMwMmJGQTQ0Q2IyODhCYzVhNEYzMTZGZGIxYWRiNDJcIiwgY29pbmJhc2Vfc2RrXzEuQ29pbmJhc2UuYXNzZXRzLkV1cmNdLFxuXSk7XG5leHBvcnRzLkJhc2VTZXBvbGlhVG9rZW5Ub0Fzc2V0SWQgPSBuZXcgTWFwKFtcbiAgICBbXCIweGNiQjdDMDAwNkYyMzkwMGMzOEVCODU2MTQ5Rjc5OTYyMGZjYjhBNGFcIiwgY29pbmJhc2Vfc2RrXzEuQ29pbmJhc2UuYXNzZXRzLkNiYnRjXSxcbiAgICBbXCIweDAzNkNiRDUzODQyYzU0MjY2MzRlNzkyOTU0MWVDMjMxOGYzZENGN2VcIiwgY29pbmJhc2Vfc2RrXzEuQ29pbmJhc2UuYXNzZXRzLlVzZGNdLFxuICAgIFtcIjB4ODA4NDU2NjUyZmRiNTk3ODY3ZjM4NDEyMDc3QTkxODJiZjc3MzU5RlwiLCBjb2luYmFzZV9zZGtfMS5Db2luYmFzZS5hc3NldHMuRXVyY10sXG5dKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/erc20/constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/erc20/erc20ActionProvider.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/erc20/erc20ActionProvider.js ***!
  \********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.erc20ActionProvider = exports.ERC20ActionProvider = void 0;\nconst zod_1 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/lib/index.js\");\nconst actionProvider_1 = __webpack_require__(/*! ../actionProvider */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/actionProvider.js\");\nconst actionDecorator_1 = __webpack_require__(/*! ../actionDecorator */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/actionDecorator.js\");\nconst schemas_1 = __webpack_require__(/*! ./schemas */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/erc20/schemas.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/erc20/constants.js\");\nconst viem_1 = __webpack_require__(/*! viem */ \"(rsc)/./node_modules/viem/_cjs/index.js\");\nconst wallet_providers_1 = __webpack_require__(/*! ../../wallet-providers */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/wallet-providers/index.js\");\n/**\n * ERC20ActionProvider is an action provider for ERC20 tokens.\n */\nclass ERC20ActionProvider extends actionProvider_1.ActionProvider {\n    /**\n     * Constructor for the ERC20ActionProvider.\n     */\n    constructor() {\n        super(\"erc20\", []);\n        /**\n         * Checks if the ERC20 action provider supports the given network.\n         *\n         * @param network - The network to check.\n         * @returns True if the ERC20 action provider supports the network, false otherwise.\n         */\n        this.supportsNetwork = (network) => network.protocolFamily === \"evm\";\n    }\n    /**\n     * Gets the balance of an ERC20 token.\n     *\n     * @param walletProvider - The wallet provider to get the balance from.\n     * @param args - The input arguments for the action.\n     * @returns A message containing the balance.\n     */\n    async getBalance(walletProvider, args) {\n        try {\n            const balance = await walletProvider.readContract({\n                address: args.contractAddress,\n                abi: constants_1.abi,\n                functionName: \"balanceOf\",\n                args: [walletProvider.getAddress()],\n            });\n            const decimals = await walletProvider.readContract({\n                address: args.contractAddress,\n                abi: constants_1.abi,\n                functionName: \"decimals\",\n                args: [],\n            });\n            return `Balance of ${args.contractAddress} is ${(0, viem_1.formatUnits)(balance, decimals)}`;\n        }\n        catch (error) {\n            return `Error getting balance: ${error}`;\n        }\n    }\n    /**\n     * Transfers a specified amount of an ERC20 token to a destination onchain.\n     *\n     * @param walletProvider - The wallet provider to transfer the asset from.\n     * @param args - The input arguments for the action.\n     * @returns A message containing the transfer details.\n     */\n    async transfer(walletProvider, args) {\n        try {\n            // Check if we can do gasless transfer\n            const isCdpWallet = walletProvider.getName() === \"cdp_wallet_provider\";\n            const network = walletProvider.getNetwork();\n            const tokenAddress = (0, viem_1.getAddress)(args.contractAddress);\n            const canDoGasless = isCdpWallet &&\n                ((network.networkId === \"base-mainnet\" && constants_1.BaseTokenToAssetId.has(tokenAddress)) ||\n                    (network.networkId === \"base-sepolia\" && constants_1.BaseSepoliaTokenToAssetId.has(tokenAddress)));\n            if (canDoGasless) {\n                // Cast to CdpWalletProvider to access erc20Transfer\n                const cdpWallet = walletProvider;\n                const assetId = network.networkId === \"base-mainnet\"\n                    ? constants_1.BaseTokenToAssetId.get(tokenAddress)\n                    : constants_1.BaseSepoliaTokenToAssetId.get(tokenAddress);\n                const hash = await cdpWallet.gaslessERC20Transfer(assetId, args.destination, args.amount);\n                await walletProvider.waitForTransactionReceipt(hash);\n                return `Transferred ${args.amount} of ${args.contractAddress} to ${args.destination} using gasless transfer.\\nTransaction hash: ${hash}`;\n            }\n            // Fallback to regular transfer\n            const hash = await walletProvider.sendTransaction({\n                to: args.contractAddress,\n                data: (0, viem_1.encodeFunctionData)({\n                    abi: constants_1.abi,\n                    functionName: \"transfer\",\n                    args: [args.destination, BigInt(args.amount)],\n                }),\n            });\n            await walletProvider.waitForTransactionReceipt(hash);\n            return `Transferred ${args.amount} of ${args.contractAddress} to ${args.destination}.\\nTransaction hash for the transfer: ${hash}`;\n        }\n        catch (error) {\n            return `Error transferring the asset: ${error}`;\n        }\n    }\n}\nexports.ERC20ActionProvider = ERC20ActionProvider;\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"get_balance\",\n        description: `\n    This tool will get the balance of an ERC20 asset in the wallet. It takes the contract address as input.\n    `,\n        schema: schemas_1.GetBalanceSchema,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [wallet_providers_1.EvmWalletProvider, void 0]),\n    __metadata(\"design:returntype\", Promise)\n], ERC20ActionProvider.prototype, \"getBalance\", null);\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"transfer\",\n        description: `\n    This tool will transfer an ERC20 token from the wallet to another onchain address.\n\nIt takes the following inputs:\n- amount: The amount to transfer\n- contractAddress: The contract address of the token to transfer\n- destination: Where to send the funds (can be an onchain address, ENS 'example.eth', or Basename 'example.base.eth')\n\nImportant notes:\n- Ensure sufficient balance of the input asset before transferring\n- When sending native assets (e.g. 'eth' on base-mainnet), ensure there is sufficient balance for the transfer itself AND the gas cost of this transfer\n    `,\n        schema: schemas_1.TransferSchema,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [wallet_providers_1.EvmWalletProvider, void 0]),\n    __metadata(\"design:returntype\", Promise)\n], ERC20ActionProvider.prototype, \"transfer\", null);\nconst erc20ActionProvider = () => new ERC20ActionProvider();\nexports.erc20ActionProvider = erc20ActionProvider;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9lcmMyMC9lcmMyMEFjdGlvblByb3ZpZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFFBQVE7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwyQkFBMkIsR0FBRywyQkFBMkI7QUFDekQsY0FBYyxtQkFBTyxDQUFDLGtEQUFLO0FBQzNCLHlCQUF5QixtQkFBTyxDQUFDLDBHQUFtQjtBQUNwRCwwQkFBMEIsbUJBQU8sQ0FBQyw0R0FBb0I7QUFDdEQsa0JBQWtCLG1CQUFPLENBQUMsaUdBQVc7QUFDckMsb0JBQW9CLG1CQUFPLENBQUMscUdBQWE7QUFDekMsZUFBZSxtQkFBTyxDQUFDLHFEQUFNO0FBQzdCLDJCQUEyQixtQkFBTyxDQUFDLHNHQUF3QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLGlDQUFpQyxzQkFBc0IsS0FBSywyQ0FBMkM7QUFDdkc7QUFDQTtBQUNBLDZDQUE2QyxNQUFNO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsYUFBYSxLQUFLLHNCQUFzQixLQUFLLGtCQUFrQiw2Q0FBNkMsS0FBSztBQUN2SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBLGtDQUFrQyxhQUFhLEtBQUssc0JBQXNCLEtBQUssaUJBQWlCLHdDQUF3QyxLQUFLO0FBQzdJO0FBQ0E7QUFDQSxvREFBb0QsTUFBTTtBQUMxRDtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cnZpdmFsLWZ1bi8uL25vZGVfbW9kdWxlcy9AY29pbmJhc2UvYWdlbnRraXQvZGlzdC9hY3Rpb24tcHJvdmlkZXJzL2VyYzIwL2VyYzIwQWN0aW9uUHJvdmlkZXIuanM/NDM1YiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmVyYzIwQWN0aW9uUHJvdmlkZXIgPSBleHBvcnRzLkVSQzIwQWN0aW9uUHJvdmlkZXIgPSB2b2lkIDA7XG5jb25zdCB6b2RfMSA9IHJlcXVpcmUoXCJ6b2RcIik7XG5jb25zdCBhY3Rpb25Qcm92aWRlcl8xID0gcmVxdWlyZShcIi4uL2FjdGlvblByb3ZpZGVyXCIpO1xuY29uc3QgYWN0aW9uRGVjb3JhdG9yXzEgPSByZXF1aXJlKFwiLi4vYWN0aW9uRGVjb3JhdG9yXCIpO1xuY29uc3Qgc2NoZW1hc18xID0gcmVxdWlyZShcIi4vc2NoZW1hc1wiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgdmllbV8xID0gcmVxdWlyZShcInZpZW1cIik7XG5jb25zdCB3YWxsZXRfcHJvdmlkZXJzXzEgPSByZXF1aXJlKFwiLi4vLi4vd2FsbGV0LXByb3ZpZGVyc1wiKTtcbi8qKlxuICogRVJDMjBBY3Rpb25Qcm92aWRlciBpcyBhbiBhY3Rpb24gcHJvdmlkZXIgZm9yIEVSQzIwIHRva2Vucy5cbiAqL1xuY2xhc3MgRVJDMjBBY3Rpb25Qcm92aWRlciBleHRlbmRzIGFjdGlvblByb3ZpZGVyXzEuQWN0aW9uUHJvdmlkZXIge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciB0aGUgRVJDMjBBY3Rpb25Qcm92aWRlci5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoXCJlcmMyMFwiLCBbXSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVja3MgaWYgdGhlIEVSQzIwIGFjdGlvbiBwcm92aWRlciBzdXBwb3J0cyB0aGUgZ2l2ZW4gbmV0d29yay5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIG5ldHdvcmsgLSBUaGUgbmV0d29yayB0byBjaGVjay5cbiAgICAgICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgRVJDMjAgYWN0aW9uIHByb3ZpZGVyIHN1cHBvcnRzIHRoZSBuZXR3b3JrLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN1cHBvcnRzTmV0d29yayA9IChuZXR3b3JrKSA9PiBuZXR3b3JrLnByb3RvY29sRmFtaWx5ID09PSBcImV2bVwiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBiYWxhbmNlIG9mIGFuIEVSQzIwIHRva2VuLlxuICAgICAqXG4gICAgICogQHBhcmFtIHdhbGxldFByb3ZpZGVyIC0gVGhlIHdhbGxldCBwcm92aWRlciB0byBnZXQgdGhlIGJhbGFuY2UgZnJvbS5cbiAgICAgKiBAcGFyYW0gYXJncyAtIFRoZSBpbnB1dCBhcmd1bWVudHMgZm9yIHRoZSBhY3Rpb24uXG4gICAgICogQHJldHVybnMgQSBtZXNzYWdlIGNvbnRhaW5pbmcgdGhlIGJhbGFuY2UuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QmFsYW5jZSh3YWxsZXRQcm92aWRlciwgYXJncykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgYmFsYW5jZSA9IGF3YWl0IHdhbGxldFByb3ZpZGVyLnJlYWRDb250cmFjdCh7XG4gICAgICAgICAgICAgICAgYWRkcmVzczogYXJncy5jb250cmFjdEFkZHJlc3MsXG4gICAgICAgICAgICAgICAgYWJpOiBjb25zdGFudHNfMS5hYmksXG4gICAgICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiBcImJhbGFuY2VPZlwiLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFt3YWxsZXRQcm92aWRlci5nZXRBZGRyZXNzKCldLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBkZWNpbWFscyA9IGF3YWl0IHdhbGxldFByb3ZpZGVyLnJlYWRDb250cmFjdCh7XG4gICAgICAgICAgICAgICAgYWRkcmVzczogYXJncy5jb250cmFjdEFkZHJlc3MsXG4gICAgICAgICAgICAgICAgYWJpOiBjb25zdGFudHNfMS5hYmksXG4gICAgICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiBcImRlY2ltYWxzXCIsXG4gICAgICAgICAgICAgICAgYXJnczogW10sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBgQmFsYW5jZSBvZiAke2FyZ3MuY29udHJhY3RBZGRyZXNzfSBpcyAkeygwLCB2aWVtXzEuZm9ybWF0VW5pdHMpKGJhbGFuY2UsIGRlY2ltYWxzKX1gO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGBFcnJvciBnZXR0aW5nIGJhbGFuY2U6ICR7ZXJyb3J9YDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmFuc2ZlcnMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGFuIEVSQzIwIHRva2VuIHRvIGEgZGVzdGluYXRpb24gb25jaGFpbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB3YWxsZXRQcm92aWRlciAtIFRoZSB3YWxsZXQgcHJvdmlkZXIgdG8gdHJhbnNmZXIgdGhlIGFzc2V0IGZyb20uXG4gICAgICogQHBhcmFtIGFyZ3MgLSBUaGUgaW5wdXQgYXJndW1lbnRzIGZvciB0aGUgYWN0aW9uLlxuICAgICAqIEByZXR1cm5zIEEgbWVzc2FnZSBjb250YWluaW5nIHRoZSB0cmFuc2ZlciBkZXRhaWxzLlxuICAgICAqL1xuICAgIGFzeW5jIHRyYW5zZmVyKHdhbGxldFByb3ZpZGVyLCBhcmdzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiB3ZSBjYW4gZG8gZ2FzbGVzcyB0cmFuc2ZlclxuICAgICAgICAgICAgY29uc3QgaXNDZHBXYWxsZXQgPSB3YWxsZXRQcm92aWRlci5nZXROYW1lKCkgPT09IFwiY2RwX3dhbGxldF9wcm92aWRlclwiO1xuICAgICAgICAgICAgY29uc3QgbmV0d29yayA9IHdhbGxldFByb3ZpZGVyLmdldE5ldHdvcmsoKTtcbiAgICAgICAgICAgIGNvbnN0IHRva2VuQWRkcmVzcyA9ICgwLCB2aWVtXzEuZ2V0QWRkcmVzcykoYXJncy5jb250cmFjdEFkZHJlc3MpO1xuICAgICAgICAgICAgY29uc3QgY2FuRG9HYXNsZXNzID0gaXNDZHBXYWxsZXQgJiZcbiAgICAgICAgICAgICAgICAoKG5ldHdvcmsubmV0d29ya0lkID09PSBcImJhc2UtbWFpbm5ldFwiICYmIGNvbnN0YW50c18xLkJhc2VUb2tlblRvQXNzZXRJZC5oYXModG9rZW5BZGRyZXNzKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgKG5ldHdvcmsubmV0d29ya0lkID09PSBcImJhc2Utc2Vwb2xpYVwiICYmIGNvbnN0YW50c18xLkJhc2VTZXBvbGlhVG9rZW5Ub0Fzc2V0SWQuaGFzKHRva2VuQWRkcmVzcykpKTtcbiAgICAgICAgICAgIGlmIChjYW5Eb0dhc2xlc3MpIHtcbiAgICAgICAgICAgICAgICAvLyBDYXN0IHRvIENkcFdhbGxldFByb3ZpZGVyIHRvIGFjY2VzcyBlcmMyMFRyYW5zZmVyXG4gICAgICAgICAgICAgICAgY29uc3QgY2RwV2FsbGV0ID0gd2FsbGV0UHJvdmlkZXI7XG4gICAgICAgICAgICAgICAgY29uc3QgYXNzZXRJZCA9IG5ldHdvcmsubmV0d29ya0lkID09PSBcImJhc2UtbWFpbm5ldFwiXG4gICAgICAgICAgICAgICAgICAgID8gY29uc3RhbnRzXzEuQmFzZVRva2VuVG9Bc3NldElkLmdldCh0b2tlbkFkZHJlc3MpXG4gICAgICAgICAgICAgICAgICAgIDogY29uc3RhbnRzXzEuQmFzZVNlcG9saWFUb2tlblRvQXNzZXRJZC5nZXQodG9rZW5BZGRyZXNzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBoYXNoID0gYXdhaXQgY2RwV2FsbGV0Lmdhc2xlc3NFUkMyMFRyYW5zZmVyKGFzc2V0SWQsIGFyZ3MuZGVzdGluYXRpb24sIGFyZ3MuYW1vdW50KTtcbiAgICAgICAgICAgICAgICBhd2FpdCB3YWxsZXRQcm92aWRlci53YWl0Rm9yVHJhbnNhY3Rpb25SZWNlaXB0KGhhc2gpO1xuICAgICAgICAgICAgICAgIHJldHVybiBgVHJhbnNmZXJyZWQgJHthcmdzLmFtb3VudH0gb2YgJHthcmdzLmNvbnRyYWN0QWRkcmVzc30gdG8gJHthcmdzLmRlc3RpbmF0aW9ufSB1c2luZyBnYXNsZXNzIHRyYW5zZmVyLlxcblRyYW5zYWN0aW9uIGhhc2g6ICR7aGFzaH1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRmFsbGJhY2sgdG8gcmVndWxhciB0cmFuc2ZlclxuICAgICAgICAgICAgY29uc3QgaGFzaCA9IGF3YWl0IHdhbGxldFByb3ZpZGVyLnNlbmRUcmFuc2FjdGlvbih7XG4gICAgICAgICAgICAgICAgdG86IGFyZ3MuY29udHJhY3RBZGRyZXNzLFxuICAgICAgICAgICAgICAgIGRhdGE6ICgwLCB2aWVtXzEuZW5jb2RlRnVuY3Rpb25EYXRhKSh7XG4gICAgICAgICAgICAgICAgICAgIGFiaTogY29uc3RhbnRzXzEuYWJpLFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWU6IFwidHJhbnNmZXJcIixcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW2FyZ3MuZGVzdGluYXRpb24sIEJpZ0ludChhcmdzLmFtb3VudCldLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCB3YWxsZXRQcm92aWRlci53YWl0Rm9yVHJhbnNhY3Rpb25SZWNlaXB0KGhhc2gpO1xuICAgICAgICAgICAgcmV0dXJuIGBUcmFuc2ZlcnJlZCAke2FyZ3MuYW1vdW50fSBvZiAke2FyZ3MuY29udHJhY3RBZGRyZXNzfSB0byAke2FyZ3MuZGVzdGluYXRpb259LlxcblRyYW5zYWN0aW9uIGhhc2ggZm9yIHRoZSB0cmFuc2ZlcjogJHtoYXNofWA7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gYEVycm9yIHRyYW5zZmVycmluZyB0aGUgYXNzZXQ6ICR7ZXJyb3J9YDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuRVJDMjBBY3Rpb25Qcm92aWRlciA9IEVSQzIwQWN0aW9uUHJvdmlkZXI7XG5fX2RlY29yYXRlKFtcbiAgICAoMCwgYWN0aW9uRGVjb3JhdG9yXzEuQ3JlYXRlQWN0aW9uKSh7XG4gICAgICAgIG5hbWU6IFwiZ2V0X2JhbGFuY2VcIixcbiAgICAgICAgZGVzY3JpcHRpb246IGBcbiAgICBUaGlzIHRvb2wgd2lsbCBnZXQgdGhlIGJhbGFuY2Ugb2YgYW4gRVJDMjAgYXNzZXQgaW4gdGhlIHdhbGxldC4gSXQgdGFrZXMgdGhlIGNvbnRyYWN0IGFkZHJlc3MgYXMgaW5wdXQuXG4gICAgYCxcbiAgICAgICAgc2NoZW1hOiBzY2hlbWFzXzEuR2V0QmFsYW5jZVNjaGVtYSxcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbd2FsbGV0X3Byb3ZpZGVyc18xLkV2bVdhbGxldFByb3ZpZGVyLCB2b2lkIDBdKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgUHJvbWlzZSlcbl0sIEVSQzIwQWN0aW9uUHJvdmlkZXIucHJvdG90eXBlLCBcImdldEJhbGFuY2VcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICAoMCwgYWN0aW9uRGVjb3JhdG9yXzEuQ3JlYXRlQWN0aW9uKSh7XG4gICAgICAgIG5hbWU6IFwidHJhbnNmZXJcIixcbiAgICAgICAgZGVzY3JpcHRpb246IGBcbiAgICBUaGlzIHRvb2wgd2lsbCB0cmFuc2ZlciBhbiBFUkMyMCB0b2tlbiBmcm9tIHRoZSB3YWxsZXQgdG8gYW5vdGhlciBvbmNoYWluIGFkZHJlc3MuXG5cbkl0IHRha2VzIHRoZSBmb2xsb3dpbmcgaW5wdXRzOlxuLSBhbW91bnQ6IFRoZSBhbW91bnQgdG8gdHJhbnNmZXJcbi0gY29udHJhY3RBZGRyZXNzOiBUaGUgY29udHJhY3QgYWRkcmVzcyBvZiB0aGUgdG9rZW4gdG8gdHJhbnNmZXJcbi0gZGVzdGluYXRpb246IFdoZXJlIHRvIHNlbmQgdGhlIGZ1bmRzIChjYW4gYmUgYW4gb25jaGFpbiBhZGRyZXNzLCBFTlMgJ2V4YW1wbGUuZXRoJywgb3IgQmFzZW5hbWUgJ2V4YW1wbGUuYmFzZS5ldGgnKVxuXG5JbXBvcnRhbnQgbm90ZXM6XG4tIEVuc3VyZSBzdWZmaWNpZW50IGJhbGFuY2Ugb2YgdGhlIGlucHV0IGFzc2V0IGJlZm9yZSB0cmFuc2ZlcnJpbmdcbi0gV2hlbiBzZW5kaW5nIG5hdGl2ZSBhc3NldHMgKGUuZy4gJ2V0aCcgb24gYmFzZS1tYWlubmV0KSwgZW5zdXJlIHRoZXJlIGlzIHN1ZmZpY2llbnQgYmFsYW5jZSBmb3IgdGhlIHRyYW5zZmVyIGl0c2VsZiBBTkQgdGhlIGdhcyBjb3N0IG9mIHRoaXMgdHJhbnNmZXJcbiAgICBgLFxuICAgICAgICBzY2hlbWE6IHNjaGVtYXNfMS5UcmFuc2ZlclNjaGVtYSxcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbd2FsbGV0X3Byb3ZpZGVyc18xLkV2bVdhbGxldFByb3ZpZGVyLCB2b2lkIDBdKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgUHJvbWlzZSlcbl0sIEVSQzIwQWN0aW9uUHJvdmlkZXIucHJvdG90eXBlLCBcInRyYW5zZmVyXCIsIG51bGwpO1xuY29uc3QgZXJjMjBBY3Rpb25Qcm92aWRlciA9ICgpID0+IG5ldyBFUkMyMEFjdGlvblByb3ZpZGVyKCk7XG5leHBvcnRzLmVyYzIwQWN0aW9uUHJvdmlkZXIgPSBlcmMyMEFjdGlvblByb3ZpZGVyO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/erc20/erc20ActionProvider.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/erc20/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/erc20/index.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./erc20ActionProvider */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/erc20/erc20ActionProvider.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9lcmMyMC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxhQUFhLG1CQUFPLENBQUMseUhBQXVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3Vydml2YWwtZnVuLy4vbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9hZ2VudGtpdC9kaXN0L2FjdGlvbi1wcm92aWRlcnMvZXJjMjAvaW5kZXguanM/NTRkMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2VyYzIwQWN0aW9uUHJvdmlkZXJcIiksIGV4cG9ydHMpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/erc20/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/erc20/schemas.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/erc20/schemas.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GetBalanceSchema = exports.TransferSchema = void 0;\nconst zod_1 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/lib/index.js\");\n/**\n * Input schema for transfer action.\n */\nexports.TransferSchema = zod_1.z\n    .object({\n    amount: zod_1.z.custom().describe(\"The amount of the asset to transfer\"),\n    contractAddress: zod_1.z.string().describe(\"The contract address of the token to transfer\"),\n    destination: zod_1.z.string().describe(\"The destination to transfer the funds\"),\n})\n    .strip()\n    .describe(\"Instructions for transferring assets\");\n/**\n * Input schema for get balance action.\n */\nexports.GetBalanceSchema = zod_1.z\n    .object({\n    contractAddress: zod_1.z\n        .string()\n        .describe(\"The contract address of the token to get the balance for\"),\n})\n    .strip()\n    .describe(\"Instructions for getting wallet balance\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9lcmMyMC9zY2hlbWFzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHdCQUF3QixHQUFHLHNCQUFzQjtBQUNqRCxjQUFjLG1CQUFPLENBQUMsa0RBQUs7QUFDM0I7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cnZpdmFsLWZ1bi8uL25vZGVfbW9kdWxlcy9AY29pbmJhc2UvYWdlbnRraXQvZGlzdC9hY3Rpb24tcHJvdmlkZXJzL2VyYzIwL3NjaGVtYXMuanM/MmM0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuR2V0QmFsYW5jZVNjaGVtYSA9IGV4cG9ydHMuVHJhbnNmZXJTY2hlbWEgPSB2b2lkIDA7XG5jb25zdCB6b2RfMSA9IHJlcXVpcmUoXCJ6b2RcIik7XG4vKipcbiAqIElucHV0IHNjaGVtYSBmb3IgdHJhbnNmZXIgYWN0aW9uLlxuICovXG5leHBvcnRzLlRyYW5zZmVyU2NoZW1hID0gem9kXzEuelxuICAgIC5vYmplY3Qoe1xuICAgIGFtb3VudDogem9kXzEuei5jdXN0b20oKS5kZXNjcmliZShcIlRoZSBhbW91bnQgb2YgdGhlIGFzc2V0IHRvIHRyYW5zZmVyXCIpLFxuICAgIGNvbnRyYWN0QWRkcmVzczogem9kXzEuei5zdHJpbmcoKS5kZXNjcmliZShcIlRoZSBjb250cmFjdCBhZGRyZXNzIG9mIHRoZSB0b2tlbiB0byB0cmFuc2ZlclwiKSxcbiAgICBkZXN0aW5hdGlvbjogem9kXzEuei5zdHJpbmcoKS5kZXNjcmliZShcIlRoZSBkZXN0aW5hdGlvbiB0byB0cmFuc2ZlciB0aGUgZnVuZHNcIiksXG59KVxuICAgIC5zdHJpcCgpXG4gICAgLmRlc2NyaWJlKFwiSW5zdHJ1Y3Rpb25zIGZvciB0cmFuc2ZlcnJpbmcgYXNzZXRzXCIpO1xuLyoqXG4gKiBJbnB1dCBzY2hlbWEgZm9yIGdldCBiYWxhbmNlIGFjdGlvbi5cbiAqL1xuZXhwb3J0cy5HZXRCYWxhbmNlU2NoZW1hID0gem9kXzEuelxuICAgIC5vYmplY3Qoe1xuICAgIGNvbnRyYWN0QWRkcmVzczogem9kXzEuelxuICAgICAgICAuc3RyaW5nKClcbiAgICAgICAgLmRlc2NyaWJlKFwiVGhlIGNvbnRyYWN0IGFkZHJlc3Mgb2YgdGhlIHRva2VuIHRvIGdldCB0aGUgYmFsYW5jZSBmb3JcIiksXG59KVxuICAgIC5zdHJpcCgpXG4gICAgLmRlc2NyaWJlKFwiSW5zdHJ1Y3Rpb25zIGZvciBnZXR0aW5nIHdhbGxldCBiYWxhbmNlXCIpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/erc20/schemas.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/erc721/constants.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/erc721/constants.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ERC721_ABI = void 0;\nexports.ERC721_ABI = [\n    {\n        inputs: [{ internalType: \"address\", name: \"to\", type: \"address\" }],\n        name: \"mint\",\n        outputs: [],\n        payable: false,\n        stateMutability: \"nonpayable\",\n        type: \"function\",\n    },\n    {\n        inputs: [\n            {\n                internalType: \"bytes4\",\n                name: \"interfaceId\",\n                type: \"bytes4\",\n            },\n        ],\n        name: \"supportsInterface\",\n        outputs: [\n            {\n                internalType: \"bool\",\n                name: \"\",\n                type: \"bool\",\n            },\n        ],\n        stateMutability: \"view\",\n        type: \"function\",\n    },\n    {\n        anonymous: false,\n        inputs: [\n            {\n                indexed: true,\n                internalType: \"address\",\n                name: \"from\",\n                type: \"address\",\n            },\n            {\n                indexed: true,\n                internalType: \"address\",\n                name: \"to\",\n                type: \"address\",\n            },\n            {\n                indexed: true,\n                internalType: \"uint256\",\n                name: \"tokenId\",\n                type: \"uint256\",\n            },\n        ],\n        name: \"Transfer\",\n        type: \"event\",\n    },\n    {\n        anonymous: false,\n        inputs: [\n            {\n                indexed: true,\n                internalType: \"address\",\n                name: \"owner\",\n                type: \"address\",\n            },\n            {\n                indexed: true,\n                internalType: \"address\",\n                name: \"approved\",\n                type: \"address\",\n            },\n            {\n                indexed: true,\n                internalType: \"uint256\",\n                name: \"tokenId\",\n                type: \"uint256\",\n            },\n        ],\n        name: \"Approval\",\n        type: \"event\",\n    },\n    {\n        anonymous: false,\n        inputs: [\n            {\n                indexed: true,\n                internalType: \"address\",\n                name: \"owner\",\n                type: \"address\",\n            },\n            {\n                indexed: true,\n                internalType: \"address\",\n                name: \"operator\",\n                type: \"address\",\n            },\n            {\n                indexed: false,\n                internalType: \"bool\",\n                name: \"approved\",\n                type: \"bool\",\n            },\n        ],\n        name: \"ApprovalForAll\",\n        type: \"event\",\n    },\n    {\n        inputs: [\n            {\n                internalType: \"address\",\n                name: \"owner\",\n                type: \"address\",\n            },\n        ],\n        name: \"balanceOf\",\n        outputs: [\n            {\n                internalType: \"uint256\",\n                name: \"balance\",\n                type: \"uint256\",\n            },\n        ],\n        stateMutability: \"view\",\n        type: \"function\",\n    },\n    {\n        inputs: [\n            {\n                internalType: \"uint256\",\n                name: \"tokenId\",\n                type: \"uint256\",\n            },\n        ],\n        name: \"ownerOf\",\n        outputs: [\n            {\n                internalType: \"address\",\n                name: \"owner\",\n                type: \"address\",\n            },\n        ],\n        stateMutability: \"view\",\n        type: \"function\",\n    },\n    {\n        inputs: [\n            {\n                internalType: \"address\",\n                name: \"from\",\n                type: \"address\",\n            },\n            {\n                internalType: \"address\",\n                name: \"to\",\n                type: \"address\",\n            },\n            {\n                internalType: \"uint256\",\n                name: \"tokenId\",\n                type: \"uint256\",\n            },\n            {\n                internalType: \"bytes\",\n                name: \"data\",\n                type: \"bytes\",\n            },\n        ],\n        name: \"safeTransferFrom\",\n        outputs: [],\n        stateMutability: \"nonpayable\",\n        type: \"function\",\n    },\n    {\n        inputs: [\n            {\n                internalType: \"address\",\n                name: \"from\",\n                type: \"address\",\n            },\n            {\n                internalType: \"address\",\n                name: \"to\",\n                type: \"address\",\n            },\n            {\n                internalType: \"uint256\",\n                name: \"tokenId\",\n                type: \"uint256\",\n            },\n        ],\n        name: \"safeTransferFrom\",\n        outputs: [],\n        stateMutability: \"nonpayable\",\n        type: \"function\",\n    },\n    {\n        inputs: [\n            {\n                internalType: \"address\",\n                name: \"from\",\n                type: \"address\",\n            },\n            {\n                internalType: \"address\",\n                name: \"to\",\n                type: \"address\",\n            },\n            {\n                internalType: \"uint256\",\n                name: \"tokenId\",\n                type: \"uint256\",\n            },\n        ],\n        name: \"transferFrom\",\n        outputs: [],\n        stateMutability: \"nonpayable\",\n        type: \"function\",\n    },\n    {\n        inputs: [\n            {\n                internalType: \"address\",\n                name: \"to\",\n                type: \"address\",\n            },\n            {\n                internalType: \"uint256\",\n                name: \"tokenId\",\n                type: \"uint256\",\n            },\n        ],\n        name: \"approve\",\n        outputs: [],\n        stateMutability: \"nonpayable\",\n        type: \"function\",\n    },\n    {\n        inputs: [\n            {\n                internalType: \"address\",\n                name: \"operator\",\n                type: \"address\",\n            },\n            {\n                internalType: \"bool\",\n                name: \"approved\",\n                type: \"bool\",\n            },\n        ],\n        name: \"setApprovalForAll\",\n        outputs: [],\n        stateMutability: \"nonpayable\",\n        type: \"function\",\n    },\n    {\n        inputs: [\n            {\n                internalType: \"uint256\",\n                name: \"tokenId\",\n                type: \"uint256\",\n            },\n        ],\n        name: \"getApproved\",\n        outputs: [\n            {\n                internalType: \"address\",\n                name: \"operator\",\n                type: \"address\",\n            },\n        ],\n        stateMutability: \"view\",\n        type: \"function\",\n    },\n    {\n        inputs: [\n            {\n                internalType: \"address\",\n                name: \"owner\",\n                type: \"address\",\n            },\n            {\n                internalType: \"address\",\n                name: \"operator\",\n                type: \"address\",\n            },\n        ],\n        name: \"isApprovedForAll\",\n        outputs: [\n            {\n                internalType: \"bool\",\n                name: \"\",\n                type: \"bool\",\n            },\n        ],\n        stateMutability: \"view\",\n        type: \"function\",\n    },\n];\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9lcmM3MjEvY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQjtBQUNsQixrQkFBa0I7QUFDbEI7QUFDQSxtQkFBbUIsc0RBQXNEO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3Vydml2YWwtZnVuLy4vbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9hZ2VudGtpdC9kaXN0L2FjdGlvbi1wcm92aWRlcnMvZXJjNzIxL2NvbnN0YW50cy5qcz8yZmVlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5FUkM3MjFfQUJJID0gdm9pZCAwO1xuZXhwb3J0cy5FUkM3MjFfQUJJID0gW1xuICAgIHtcbiAgICAgICAgaW5wdXRzOiBbeyBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLCBuYW1lOiBcInRvXCIsIHR5cGU6IFwiYWRkcmVzc1wiIH1dLFxuICAgICAgICBuYW1lOiBcIm1pbnRcIixcbiAgICAgICAgb3V0cHV0czogW10sXG4gICAgICAgIHBheWFibGU6IGZhbHNlLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6IFwibm9ucGF5YWJsZVwiLFxuICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogXCJieXRlczRcIixcbiAgICAgICAgICAgICAgICBuYW1lOiBcImludGVyZmFjZUlkXCIsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJieXRlczRcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIG5hbWU6IFwic3VwcG9ydHNJbnRlcmZhY2VcIixcbiAgICAgICAgb3V0cHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogXCJib29sXCIsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJcIixcbiAgICAgICAgICAgICAgICB0eXBlOiBcImJvb2xcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICB9LFxuICAgIHtcbiAgICAgICAgYW5vbnltb3VzOiBmYWxzZSxcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW5kZXhlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICAgICAgICAgIG5hbWU6IFwiZnJvbVwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbmRleGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJ0b1wiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbmRleGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJ0b2tlbklkXCIsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBuYW1lOiBcIlRyYW5zZmVyXCIsXG4gICAgICAgIHR5cGU6IFwiZXZlbnRcIixcbiAgICB9LFxuICAgIHtcbiAgICAgICAgYW5vbnltb3VzOiBmYWxzZSxcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW5kZXhlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICAgICAgICAgIG5hbWU6IFwib3duZXJcIixcbiAgICAgICAgICAgICAgICB0eXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW5kZXhlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICAgICAgICAgIG5hbWU6IFwiYXBwcm92ZWRcIixcbiAgICAgICAgICAgICAgICB0eXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW5kZXhlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICAgICAgICAgIG5hbWU6IFwidG9rZW5JZFwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgbmFtZTogXCJBcHByb3ZhbFwiLFxuICAgICAgICB0eXBlOiBcImV2ZW50XCIsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGFub255bW91czogZmFsc2UsXG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGluZGV4ZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgICAgICAgICBuYW1lOiBcIm93bmVyXCIsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGluZGV4ZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgICAgICAgICBuYW1lOiBcIm9wZXJhdG9yXCIsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGluZGV4ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogXCJib29sXCIsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJhcHByb3ZlZFwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiYm9vbFwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgbmFtZTogXCJBcHByb3ZhbEZvckFsbFwiLFxuICAgICAgICB0eXBlOiBcImV2ZW50XCIsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJvd25lclwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgbmFtZTogXCJiYWxhbmNlT2ZcIixcbiAgICAgICAgb3V0cHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJiYWxhbmNlXCIsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6IFwidmlld1wiLFxuICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJ0b2tlbklkXCIsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBuYW1lOiBcIm93bmVyT2ZcIixcbiAgICAgICAgb3V0cHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJvd25lclwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIixcbiAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgIH0sXG4gICAge1xuICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICAgICAgICAgIG5hbWU6IFwiZnJvbVwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICAgICAgICAgIG5hbWU6IFwidG9cIixcbiAgICAgICAgICAgICAgICB0eXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgICAgICAgICBuYW1lOiBcInRva2VuSWRcIixcbiAgICAgICAgICAgICAgICB0eXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiBcImJ5dGVzXCIsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJkYXRhXCIsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJieXRlc1wiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgbmFtZTogXCJzYWZlVHJhbnNmZXJGcm9tXCIsXG4gICAgICAgIG91dHB1dHM6IFtdLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6IFwibm9ucGF5YWJsZVwiLFxuICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJmcm9tXCIsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJ0b1wiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICAgICAgICAgIG5hbWU6IFwidG9rZW5JZFwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgbmFtZTogXCJzYWZlVHJhbnNmZXJGcm9tXCIsXG4gICAgICAgIG91dHB1dHM6IFtdLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6IFwibm9ucGF5YWJsZVwiLFxuICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJmcm9tXCIsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJ0b1wiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICAgICAgICAgIG5hbWU6IFwidG9rZW5JZFwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgbmFtZTogXCJ0cmFuc2ZlckZyb21cIixcbiAgICAgICAgb3V0cHV0czogW10sXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogXCJub25wYXlhYmxlXCIsXG4gICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICB9LFxuICAgIHtcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgICAgICAgICBuYW1lOiBcInRvXCIsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJ0b2tlbklkXCIsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBuYW1lOiBcImFwcHJvdmVcIixcbiAgICAgICAgb3V0cHV0czogW10sXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogXCJub25wYXlhYmxlXCIsXG4gICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICB9LFxuICAgIHtcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgICAgICAgICBuYW1lOiBcIm9wZXJhdG9yXCIsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogXCJib29sXCIsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJhcHByb3ZlZFwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiYm9vbFwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgbmFtZTogXCJzZXRBcHByb3ZhbEZvckFsbFwiLFxuICAgICAgICBvdXRwdXRzOiBbXSxcbiAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiBcIm5vbnBheWFibGVcIixcbiAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgIH0sXG4gICAge1xuICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICAgICAgICAgIG5hbWU6IFwidG9rZW5JZFwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgbmFtZTogXCJnZXRBcHByb3ZlZFwiLFxuICAgICAgICBvdXRwdXRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgICAgICAgICBuYW1lOiBcIm9wZXJhdG9yXCIsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6IFwidmlld1wiLFxuICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJvd25lclwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICAgICAgICAgIG5hbWU6IFwib3BlcmF0b3JcIixcbiAgICAgICAgICAgICAgICB0eXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIG5hbWU6IFwiaXNBcHByb3ZlZEZvckFsbFwiLFxuICAgICAgICBvdXRwdXRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiBcImJvb2xcIixcbiAgICAgICAgICAgICAgICBuYW1lOiBcIlwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiYm9vbFwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIixcbiAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgIH0sXG5dO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/erc721/constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/erc721/erc721ActionProvider.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/erc721/erc721ActionProvider.js ***!
  \**********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.erc721ActionProvider = exports.Erc721ActionProvider = void 0;\nconst zod_1 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/lib/index.js\");\nconst actionProvider_1 = __webpack_require__(/*! ../actionProvider */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/actionProvider.js\");\nconst wallet_providers_1 = __webpack_require__(/*! ../../wallet-providers */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/wallet-providers/index.js\");\nconst actionDecorator_1 = __webpack_require__(/*! ../actionDecorator */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/actionDecorator.js\");\nconst schemas_1 = __webpack_require__(/*! ./schemas */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/erc721/schemas.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/erc721/constants.js\");\nconst viem_1 = __webpack_require__(/*! viem */ \"(rsc)/./node_modules/viem/_cjs/index.js\");\n/**\n * Erc721ActionProvider is an action provider for Erc721 contract interactions.\n */\nclass Erc721ActionProvider extends actionProvider_1.ActionProvider {\n    /**\n     * Constructor for the Erc721ActionProvider class.\n     */\n    constructor() {\n        super(\"erc721\", []);\n        /**\n         * Checks if the Erc721 action provider supports the given network.\n         *\n         * @param network - The network to check.\n         * @returns True if the Erc721 action provider supports the network, false otherwise.\n         */\n        this.supportsNetwork = (network) => network.protocolFamily === \"evm\";\n    }\n    /**\n     * Mints an NFT (ERC-721) to a specified destination address onchain.\n     *\n     * @param walletProvider - The wallet provider to mint the NFT from.\n     * @param args - The input arguments for the action.\n     * @returns A message containing the NFT mint details.\n     */\n    async mint(walletProvider, args) {\n        try {\n            const data = (0, viem_1.encodeFunctionData)({\n                abi: constants_1.ERC721_ABI,\n                functionName: \"mint\",\n                args: [args.destination],\n            });\n            const hash = await walletProvider.sendTransaction({\n                to: args.contractAddress,\n                data,\n            });\n            await walletProvider.waitForTransactionReceipt(hash);\n            return `Successfully minted NFT ${args.contractAddress} to ${args.destination}`;\n        }\n        catch (error) {\n            return `Error minting NFT ${args.contractAddress} to ${args.destination}: ${error}`;\n        }\n    }\n    /**\n     * Transfers an NFT (ERC721 token) to a destination address.\n     *\n     * @param walletProvider - The wallet provider to transfer the NFT from.\n     * @param args - The input arguments for the action.\n     * @returns A message containing the transfer details.\n     */\n    async transfer(walletProvider, args) {\n        try {\n            const data = (0, viem_1.encodeFunctionData)({\n                abi: constants_1.ERC721_ABI,\n                functionName: \"transferFrom\",\n                args: [args.fromAddress, args.destination, BigInt(args.tokenId)],\n            });\n            const hash = await walletProvider.sendTransaction({\n                to: args.contractAddress,\n                data,\n            });\n            await walletProvider.waitForTransactionReceipt(hash);\n            return `Successfully transferred NFT ${args.contractAddress} with tokenId ${args.tokenId} to ${args.destination}`;\n        }\n        catch (error) {\n            return `Error transferring NFT ${args.contractAddress} with tokenId ${args.tokenId} to ${args.destination}: ${error}`;\n        }\n    }\n    /**\n     * Gets the NFT balance for a given address and contract.\n     *\n     * @param walletProvider - The wallet provider to check the balance with.\n     * @param args - The input arguments for the action.\n     * @returns A message containing the NFT balance details.\n     */\n    async getBalance(walletProvider, args) {\n        try {\n            const address = args.address || walletProvider.getAddress();\n            const balance = await walletProvider.readContract({\n                address: args.contractAddress,\n                abi: constants_1.ERC721_ABI,\n                functionName: \"balanceOf\",\n                args: [address],\n            });\n            return `Balance of NFTs for contract ${args.contractAddress} at address ${address} is ${balance}`;\n        }\n        catch (error) {\n            return `Error getting NFT balance for contract ${args.contractAddress}: ${error}`;\n        }\n    }\n}\nexports.Erc721ActionProvider = Erc721ActionProvider;\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"mint\",\n        description: `\nThis tool will mint an NFT (ERC-721) to a specified destination address onchain via a contract invocation. \nIt takes the contract address of the NFT onchain and the destination address onchain that will receive the NFT as inputs. \nDo not use the contract address as the destination address. If you are unsure of the destination address, please ask the user before proceeding.\n`,\n        schema: schemas_1.MintSchema,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [wallet_providers_1.EvmWalletProvider, void 0]),\n    __metadata(\"design:returntype\", Promise)\n], Erc721ActionProvider.prototype, \"mint\", null);\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"transfer\",\n        description: `\nThis tool will transfer an NFT (ERC721 token) from the wallet to another onchain address.\n\nIt takes the following inputs:\n- contractAddress: The NFT contract address\n- tokenId: The ID of the specific NFT to transfer\n- destination: Onchain address to send the NFT\n\nImportant notes:\n- Ensure you have ownership of the NFT before attempting transfer\n- Ensure there is sufficient native token balance for gas fees\n- The wallet must either own the NFT or have approval to transfer it\n`,\n        schema: schemas_1.TransferSchema,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [wallet_providers_1.EvmWalletProvider, void 0]),\n    __metadata(\"design:returntype\", Promise)\n], Erc721ActionProvider.prototype, \"transfer\", null);\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"get_balance\",\n        description: `\nThis tool will check the NFT (ERC721 token) balance for a given address.\n\nIt takes the following inputs:\n- contractAddress: The NFT contract address to check balance for\n- address: (Optional) The address to check NFT balance for. If not provided, uses the wallet's address\n`,\n        schema: schemas_1.GetBalanceSchema,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [wallet_providers_1.EvmWalletProvider, void 0]),\n    __metadata(\"design:returntype\", Promise)\n], Erc721ActionProvider.prototype, \"getBalance\", null);\nconst erc721ActionProvider = () => new Erc721ActionProvider();\nexports.erc721ActionProvider = erc721ActionProvider;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9lcmM3MjEvZXJjNzIxQWN0aW9uUHJvdmlkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsUUFBUTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDRCQUE0QixHQUFHLDRCQUE0QjtBQUMzRCxjQUFjLG1CQUFPLENBQUMsa0RBQUs7QUFDM0IseUJBQXlCLG1CQUFPLENBQUMsMEdBQW1CO0FBQ3BELDJCQUEyQixtQkFBTyxDQUFDLHNHQUF3QjtBQUMzRCwwQkFBMEIsbUJBQU8sQ0FBQyw0R0FBb0I7QUFDdEQsa0JBQWtCLG1CQUFPLENBQUMsa0dBQVc7QUFDckMsb0JBQW9CLG1CQUFPLENBQUMsc0dBQWE7QUFDekMsZUFBZSxtQkFBTyxDQUFDLHFEQUFNO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSw4Q0FBOEMsc0JBQXNCLEtBQUssaUJBQWlCO0FBQzFGO0FBQ0E7QUFDQSx3Q0FBd0Msc0JBQXNCLEtBQUssaUJBQWlCLElBQUksTUFBTTtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsbURBQW1ELHNCQUFzQixlQUFlLGNBQWMsS0FBSyxpQkFBaUI7QUFDNUg7QUFDQTtBQUNBLDZDQUE2QyxzQkFBc0IsZUFBZSxjQUFjLEtBQUssaUJBQWlCLElBQUksTUFBTTtBQUNoSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLG1EQUFtRCxzQkFBc0IsYUFBYSxTQUFTLEtBQUssUUFBUTtBQUM1RztBQUNBO0FBQ0EsNkRBQTZELHFCQUFxQixJQUFJLE1BQU07QUFDNUY7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXJ2aXZhbC1mdW4vLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9lcmM3MjEvZXJjNzIxQWN0aW9uUHJvdmlkZXIuanM/M2NkOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmVyYzcyMUFjdGlvblByb3ZpZGVyID0gZXhwb3J0cy5FcmM3MjFBY3Rpb25Qcm92aWRlciA9IHZvaWQgMDtcbmNvbnN0IHpvZF8xID0gcmVxdWlyZShcInpvZFwiKTtcbmNvbnN0IGFjdGlvblByb3ZpZGVyXzEgPSByZXF1aXJlKFwiLi4vYWN0aW9uUHJvdmlkZXJcIik7XG5jb25zdCB3YWxsZXRfcHJvdmlkZXJzXzEgPSByZXF1aXJlKFwiLi4vLi4vd2FsbGV0LXByb3ZpZGVyc1wiKTtcbmNvbnN0IGFjdGlvbkRlY29yYXRvcl8xID0gcmVxdWlyZShcIi4uL2FjdGlvbkRlY29yYXRvclwiKTtcbmNvbnN0IHNjaGVtYXNfMSA9IHJlcXVpcmUoXCIuL3NjaGVtYXNcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IHZpZW1fMSA9IHJlcXVpcmUoXCJ2aWVtXCIpO1xuLyoqXG4gKiBFcmM3MjFBY3Rpb25Qcm92aWRlciBpcyBhbiBhY3Rpb24gcHJvdmlkZXIgZm9yIEVyYzcyMSBjb250cmFjdCBpbnRlcmFjdGlvbnMuXG4gKi9cbmNsYXNzIEVyYzcyMUFjdGlvblByb3ZpZGVyIGV4dGVuZHMgYWN0aW9uUHJvdmlkZXJfMS5BY3Rpb25Qcm92aWRlciB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIHRoZSBFcmM3MjFBY3Rpb25Qcm92aWRlciBjbGFzcy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoXCJlcmM3MjFcIiwgW10pO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2tzIGlmIHRoZSBFcmM3MjEgYWN0aW9uIHByb3ZpZGVyIHN1cHBvcnRzIHRoZSBnaXZlbiBuZXR3b3JrLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gbmV0d29yayAtIFRoZSBuZXR3b3JrIHRvIGNoZWNrLlxuICAgICAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBFcmM3MjEgYWN0aW9uIHByb3ZpZGVyIHN1cHBvcnRzIHRoZSBuZXR3b3JrLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN1cHBvcnRzTmV0d29yayA9IChuZXR3b3JrKSA9PiBuZXR3b3JrLnByb3RvY29sRmFtaWx5ID09PSBcImV2bVwiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNaW50cyBhbiBORlQgKEVSQy03MjEpIHRvIGEgc3BlY2lmaWVkIGRlc3RpbmF0aW9uIGFkZHJlc3Mgb25jaGFpbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB3YWxsZXRQcm92aWRlciAtIFRoZSB3YWxsZXQgcHJvdmlkZXIgdG8gbWludCB0aGUgTkZUIGZyb20uXG4gICAgICogQHBhcmFtIGFyZ3MgLSBUaGUgaW5wdXQgYXJndW1lbnRzIGZvciB0aGUgYWN0aW9uLlxuICAgICAqIEByZXR1cm5zIEEgbWVzc2FnZSBjb250YWluaW5nIHRoZSBORlQgbWludCBkZXRhaWxzLlxuICAgICAqL1xuICAgIGFzeW5jIG1pbnQod2FsbGV0UHJvdmlkZXIsIGFyZ3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSAoMCwgdmllbV8xLmVuY29kZUZ1bmN0aW9uRGF0YSkoe1xuICAgICAgICAgICAgICAgIGFiaTogY29uc3RhbnRzXzEuRVJDNzIxX0FCSSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWU6IFwibWludFwiLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFthcmdzLmRlc3RpbmF0aW9uXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgaGFzaCA9IGF3YWl0IHdhbGxldFByb3ZpZGVyLnNlbmRUcmFuc2FjdGlvbih7XG4gICAgICAgICAgICAgICAgdG86IGFyZ3MuY29udHJhY3RBZGRyZXNzLFxuICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IHdhbGxldFByb3ZpZGVyLndhaXRGb3JUcmFuc2FjdGlvblJlY2VpcHQoaGFzaCk7XG4gICAgICAgICAgICByZXR1cm4gYFN1Y2Nlc3NmdWxseSBtaW50ZWQgTkZUICR7YXJncy5jb250cmFjdEFkZHJlc3N9IHRvICR7YXJncy5kZXN0aW5hdGlvbn1gO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGBFcnJvciBtaW50aW5nIE5GVCAke2FyZ3MuY29udHJhY3RBZGRyZXNzfSB0byAke2FyZ3MuZGVzdGluYXRpb259OiAke2Vycm9yfWA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhbnNmZXJzIGFuIE5GVCAoRVJDNzIxIHRva2VuKSB0byBhIGRlc3RpbmF0aW9uIGFkZHJlc3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gd2FsbGV0UHJvdmlkZXIgLSBUaGUgd2FsbGV0IHByb3ZpZGVyIHRvIHRyYW5zZmVyIHRoZSBORlQgZnJvbS5cbiAgICAgKiBAcGFyYW0gYXJncyAtIFRoZSBpbnB1dCBhcmd1bWVudHMgZm9yIHRoZSBhY3Rpb24uXG4gICAgICogQHJldHVybnMgQSBtZXNzYWdlIGNvbnRhaW5pbmcgdGhlIHRyYW5zZmVyIGRldGFpbHMuXG4gICAgICovXG4gICAgYXN5bmMgdHJhbnNmZXIod2FsbGV0UHJvdmlkZXIsIGFyZ3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSAoMCwgdmllbV8xLmVuY29kZUZ1bmN0aW9uRGF0YSkoe1xuICAgICAgICAgICAgICAgIGFiaTogY29uc3RhbnRzXzEuRVJDNzIxX0FCSSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWU6IFwidHJhbnNmZXJGcm9tXCIsXG4gICAgICAgICAgICAgICAgYXJnczogW2FyZ3MuZnJvbUFkZHJlc3MsIGFyZ3MuZGVzdGluYXRpb24sIEJpZ0ludChhcmdzLnRva2VuSWQpXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgaGFzaCA9IGF3YWl0IHdhbGxldFByb3ZpZGVyLnNlbmRUcmFuc2FjdGlvbih7XG4gICAgICAgICAgICAgICAgdG86IGFyZ3MuY29udHJhY3RBZGRyZXNzLFxuICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IHdhbGxldFByb3ZpZGVyLndhaXRGb3JUcmFuc2FjdGlvblJlY2VpcHQoaGFzaCk7XG4gICAgICAgICAgICByZXR1cm4gYFN1Y2Nlc3NmdWxseSB0cmFuc2ZlcnJlZCBORlQgJHthcmdzLmNvbnRyYWN0QWRkcmVzc30gd2l0aCB0b2tlbklkICR7YXJncy50b2tlbklkfSB0byAke2FyZ3MuZGVzdGluYXRpb259YDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBgRXJyb3IgdHJhbnNmZXJyaW5nIE5GVCAke2FyZ3MuY29udHJhY3RBZGRyZXNzfSB3aXRoIHRva2VuSWQgJHthcmdzLnRva2VuSWR9IHRvICR7YXJncy5kZXN0aW5hdGlvbn06ICR7ZXJyb3J9YDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBORlQgYmFsYW5jZSBmb3IgYSBnaXZlbiBhZGRyZXNzIGFuZCBjb250cmFjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB3YWxsZXRQcm92aWRlciAtIFRoZSB3YWxsZXQgcHJvdmlkZXIgdG8gY2hlY2sgdGhlIGJhbGFuY2Ugd2l0aC5cbiAgICAgKiBAcGFyYW0gYXJncyAtIFRoZSBpbnB1dCBhcmd1bWVudHMgZm9yIHRoZSBhY3Rpb24uXG4gICAgICogQHJldHVybnMgQSBtZXNzYWdlIGNvbnRhaW5pbmcgdGhlIE5GVCBiYWxhbmNlIGRldGFpbHMuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QmFsYW5jZSh3YWxsZXRQcm92aWRlciwgYXJncykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9IGFyZ3MuYWRkcmVzcyB8fCB3YWxsZXRQcm92aWRlci5nZXRBZGRyZXNzKCk7XG4gICAgICAgICAgICBjb25zdCBiYWxhbmNlID0gYXdhaXQgd2FsbGV0UHJvdmlkZXIucmVhZENvbnRyYWN0KHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzOiBhcmdzLmNvbnRyYWN0QWRkcmVzcyxcbiAgICAgICAgICAgICAgICBhYmk6IGNvbnN0YW50c18xLkVSQzcyMV9BQkksXG4gICAgICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiBcImJhbGFuY2VPZlwiLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFthZGRyZXNzXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGBCYWxhbmNlIG9mIE5GVHMgZm9yIGNvbnRyYWN0ICR7YXJncy5jb250cmFjdEFkZHJlc3N9IGF0IGFkZHJlc3MgJHthZGRyZXNzfSBpcyAke2JhbGFuY2V9YDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBgRXJyb3IgZ2V0dGluZyBORlQgYmFsYW5jZSBmb3IgY29udHJhY3QgJHthcmdzLmNvbnRyYWN0QWRkcmVzc306ICR7ZXJyb3J9YDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuRXJjNzIxQWN0aW9uUHJvdmlkZXIgPSBFcmM3MjFBY3Rpb25Qcm92aWRlcjtcbl9fZGVjb3JhdGUoW1xuICAgICgwLCBhY3Rpb25EZWNvcmF0b3JfMS5DcmVhdGVBY3Rpb24pKHtcbiAgICAgICAgbmFtZTogXCJtaW50XCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgXG5UaGlzIHRvb2wgd2lsbCBtaW50IGFuIE5GVCAoRVJDLTcyMSkgdG8gYSBzcGVjaWZpZWQgZGVzdGluYXRpb24gYWRkcmVzcyBvbmNoYWluIHZpYSBhIGNvbnRyYWN0IGludm9jYXRpb24uIFxuSXQgdGFrZXMgdGhlIGNvbnRyYWN0IGFkZHJlc3Mgb2YgdGhlIE5GVCBvbmNoYWluIGFuZCB0aGUgZGVzdGluYXRpb24gYWRkcmVzcyBvbmNoYWluIHRoYXQgd2lsbCByZWNlaXZlIHRoZSBORlQgYXMgaW5wdXRzLiBcbkRvIG5vdCB1c2UgdGhlIGNvbnRyYWN0IGFkZHJlc3MgYXMgdGhlIGRlc3RpbmF0aW9uIGFkZHJlc3MuIElmIHlvdSBhcmUgdW5zdXJlIG9mIHRoZSBkZXN0aW5hdGlvbiBhZGRyZXNzLCBwbGVhc2UgYXNrIHRoZSB1c2VyIGJlZm9yZSBwcm9jZWVkaW5nLlxuYCxcbiAgICAgICAgc2NoZW1hOiBzY2hlbWFzXzEuTWludFNjaGVtYSxcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbd2FsbGV0X3Byb3ZpZGVyc18xLkV2bVdhbGxldFByb3ZpZGVyLCB2b2lkIDBdKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgUHJvbWlzZSlcbl0sIEVyYzcyMUFjdGlvblByb3ZpZGVyLnByb3RvdHlwZSwgXCJtaW50XCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgKDAsIGFjdGlvbkRlY29yYXRvcl8xLkNyZWF0ZUFjdGlvbikoe1xuICAgICAgICBuYW1lOiBcInRyYW5zZmVyXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgXG5UaGlzIHRvb2wgd2lsbCB0cmFuc2ZlciBhbiBORlQgKEVSQzcyMSB0b2tlbikgZnJvbSB0aGUgd2FsbGV0IHRvIGFub3RoZXIgb25jaGFpbiBhZGRyZXNzLlxuXG5JdCB0YWtlcyB0aGUgZm9sbG93aW5nIGlucHV0czpcbi0gY29udHJhY3RBZGRyZXNzOiBUaGUgTkZUIGNvbnRyYWN0IGFkZHJlc3Ncbi0gdG9rZW5JZDogVGhlIElEIG9mIHRoZSBzcGVjaWZpYyBORlQgdG8gdHJhbnNmZXJcbi0gZGVzdGluYXRpb246IE9uY2hhaW4gYWRkcmVzcyB0byBzZW5kIHRoZSBORlRcblxuSW1wb3J0YW50IG5vdGVzOlxuLSBFbnN1cmUgeW91IGhhdmUgb3duZXJzaGlwIG9mIHRoZSBORlQgYmVmb3JlIGF0dGVtcHRpbmcgdHJhbnNmZXJcbi0gRW5zdXJlIHRoZXJlIGlzIHN1ZmZpY2llbnQgbmF0aXZlIHRva2VuIGJhbGFuY2UgZm9yIGdhcyBmZWVzXG4tIFRoZSB3YWxsZXQgbXVzdCBlaXRoZXIgb3duIHRoZSBORlQgb3IgaGF2ZSBhcHByb3ZhbCB0byB0cmFuc2ZlciBpdFxuYCxcbiAgICAgICAgc2NoZW1hOiBzY2hlbWFzXzEuVHJhbnNmZXJTY2hlbWEsXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW3dhbGxldF9wcm92aWRlcnNfMS5Fdm1XYWxsZXRQcm92aWRlciwgdm9pZCAwXSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIFByb21pc2UpXG5dLCBFcmM3MjFBY3Rpb25Qcm92aWRlci5wcm90b3R5cGUsIFwidHJhbnNmZXJcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICAoMCwgYWN0aW9uRGVjb3JhdG9yXzEuQ3JlYXRlQWN0aW9uKSh7XG4gICAgICAgIG5hbWU6IFwiZ2V0X2JhbGFuY2VcIixcbiAgICAgICAgZGVzY3JpcHRpb246IGBcblRoaXMgdG9vbCB3aWxsIGNoZWNrIHRoZSBORlQgKEVSQzcyMSB0b2tlbikgYmFsYW5jZSBmb3IgYSBnaXZlbiBhZGRyZXNzLlxuXG5JdCB0YWtlcyB0aGUgZm9sbG93aW5nIGlucHV0czpcbi0gY29udHJhY3RBZGRyZXNzOiBUaGUgTkZUIGNvbnRyYWN0IGFkZHJlc3MgdG8gY2hlY2sgYmFsYW5jZSBmb3Jcbi0gYWRkcmVzczogKE9wdGlvbmFsKSBUaGUgYWRkcmVzcyB0byBjaGVjayBORlQgYmFsYW5jZSBmb3IuIElmIG5vdCBwcm92aWRlZCwgdXNlcyB0aGUgd2FsbGV0J3MgYWRkcmVzc1xuYCxcbiAgICAgICAgc2NoZW1hOiBzY2hlbWFzXzEuR2V0QmFsYW5jZVNjaGVtYSxcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbd2FsbGV0X3Byb3ZpZGVyc18xLkV2bVdhbGxldFByb3ZpZGVyLCB2b2lkIDBdKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgUHJvbWlzZSlcbl0sIEVyYzcyMUFjdGlvblByb3ZpZGVyLnByb3RvdHlwZSwgXCJnZXRCYWxhbmNlXCIsIG51bGwpO1xuY29uc3QgZXJjNzIxQWN0aW9uUHJvdmlkZXIgPSAoKSA9PiBuZXcgRXJjNzIxQWN0aW9uUHJvdmlkZXIoKTtcbmV4cG9ydHMuZXJjNzIxQWN0aW9uUHJvdmlkZXIgPSBlcmM3MjFBY3Rpb25Qcm92aWRlcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/erc721/erc721ActionProvider.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/erc721/index.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/erc721/index.js ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./erc721ActionProvider */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/erc721/erc721ActionProvider.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9lcmM3MjEvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYSxtQkFBTyxDQUFDLDRIQUF3QiIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cnZpdmFsLWZ1bi8uL25vZGVfbW9kdWxlcy9AY29pbmJhc2UvYWdlbnRraXQvZGlzdC9hY3Rpb24tcHJvdmlkZXJzL2VyYzcyMS9pbmRleC5qcz8xYTM4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZXJjNzIxQWN0aW9uUHJvdmlkZXJcIiksIGV4cG9ydHMpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/erc721/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/erc721/schemas.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/erc721/schemas.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TransferSchema = exports.MintSchema = exports.GetBalanceSchema = void 0;\nconst zod_1 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/lib/index.js\");\n/**\n * Input schema for get NFT (ERC721) balance action.\n */\nexports.GetBalanceSchema = zod_1.z\n    .object({\n    contractAddress: zod_1.z.string().describe(\"The NFT contract address to check balance for\"),\n    address: zod_1.z\n        .string()\n        .optional()\n        .describe(\"The address to check NFT balance for. If not provided, uses the wallet's default address\"),\n})\n    .strip()\n    .describe(\"Instructions for getting NFT balance\");\n/**\n * Input schema for mint NFT (ERC721) action.\n */\nexports.MintSchema = zod_1.z\n    .object({\n    contractAddress: zod_1.z.string().describe(\"The contract address of the NFT to mint\"),\n    destination: zod_1.z.string().describe(\"The onchain destination address that will receive the NFT\"),\n})\n    .strip()\n    .describe(\"Instructions for minting an NFT\");\n/**\n * Input schema for NFT (ERC721) transfer action.\n */\nexports.TransferSchema = zod_1.z\n    .object({\n    contractAddress: zod_1.z.string().describe(\"The NFT contract address to interact with\"),\n    tokenId: zod_1.z.string().describe(\"The ID of the NFT to transfer\"),\n    destination: zod_1.z\n        .string()\n        .describe(\"The destination to transfer the NFT, e.g. `0x58dBecc0894Ab4C24F98a0e684c989eD07e4e027`, `example.eth`, `example.base.eth`\"),\n    fromAddress: zod_1.z\n        .string()\n        .optional()\n        .describe(\"The address to transfer from. If not provided, defaults to the wallet's default address\"),\n})\n    .strip()\n    .describe(\"Input schema for transferring an NFT\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9lcmM3MjEvc2NoZW1hcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQkFBc0IsR0FBRyxrQkFBa0IsR0FBRyx3QkFBd0I7QUFDdEUsY0FBYyxtQkFBTyxDQUFDLGtEQUFLO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3Vydml2YWwtZnVuLy4vbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9hZ2VudGtpdC9kaXN0L2FjdGlvbi1wcm92aWRlcnMvZXJjNzIxL3NjaGVtYXMuanM/YWIwMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVHJhbnNmZXJTY2hlbWEgPSBleHBvcnRzLk1pbnRTY2hlbWEgPSBleHBvcnRzLkdldEJhbGFuY2VTY2hlbWEgPSB2b2lkIDA7XG5jb25zdCB6b2RfMSA9IHJlcXVpcmUoXCJ6b2RcIik7XG4vKipcbiAqIElucHV0IHNjaGVtYSBmb3IgZ2V0IE5GVCAoRVJDNzIxKSBiYWxhbmNlIGFjdGlvbi5cbiAqL1xuZXhwb3J0cy5HZXRCYWxhbmNlU2NoZW1hID0gem9kXzEuelxuICAgIC5vYmplY3Qoe1xuICAgIGNvbnRyYWN0QWRkcmVzczogem9kXzEuei5zdHJpbmcoKS5kZXNjcmliZShcIlRoZSBORlQgY29udHJhY3QgYWRkcmVzcyB0byBjaGVjayBiYWxhbmNlIGZvclwiKSxcbiAgICBhZGRyZXNzOiB6b2RfMS56XG4gICAgICAgIC5zdHJpbmcoKVxuICAgICAgICAub3B0aW9uYWwoKVxuICAgICAgICAuZGVzY3JpYmUoXCJUaGUgYWRkcmVzcyB0byBjaGVjayBORlQgYmFsYW5jZSBmb3IuIElmIG5vdCBwcm92aWRlZCwgdXNlcyB0aGUgd2FsbGV0J3MgZGVmYXVsdCBhZGRyZXNzXCIpLFxufSlcbiAgICAuc3RyaXAoKVxuICAgIC5kZXNjcmliZShcIkluc3RydWN0aW9ucyBmb3IgZ2V0dGluZyBORlQgYmFsYW5jZVwiKTtcbi8qKlxuICogSW5wdXQgc2NoZW1hIGZvciBtaW50IE5GVCAoRVJDNzIxKSBhY3Rpb24uXG4gKi9cbmV4cG9ydHMuTWludFNjaGVtYSA9IHpvZF8xLnpcbiAgICAub2JqZWN0KHtcbiAgICBjb250cmFjdEFkZHJlc3M6IHpvZF8xLnouc3RyaW5nKCkuZGVzY3JpYmUoXCJUaGUgY29udHJhY3QgYWRkcmVzcyBvZiB0aGUgTkZUIHRvIG1pbnRcIiksXG4gICAgZGVzdGluYXRpb246IHpvZF8xLnouc3RyaW5nKCkuZGVzY3JpYmUoXCJUaGUgb25jaGFpbiBkZXN0aW5hdGlvbiBhZGRyZXNzIHRoYXQgd2lsbCByZWNlaXZlIHRoZSBORlRcIiksXG59KVxuICAgIC5zdHJpcCgpXG4gICAgLmRlc2NyaWJlKFwiSW5zdHJ1Y3Rpb25zIGZvciBtaW50aW5nIGFuIE5GVFwiKTtcbi8qKlxuICogSW5wdXQgc2NoZW1hIGZvciBORlQgKEVSQzcyMSkgdHJhbnNmZXIgYWN0aW9uLlxuICovXG5leHBvcnRzLlRyYW5zZmVyU2NoZW1hID0gem9kXzEuelxuICAgIC5vYmplY3Qoe1xuICAgIGNvbnRyYWN0QWRkcmVzczogem9kXzEuei5zdHJpbmcoKS5kZXNjcmliZShcIlRoZSBORlQgY29udHJhY3QgYWRkcmVzcyB0byBpbnRlcmFjdCB3aXRoXCIpLFxuICAgIHRva2VuSWQ6IHpvZF8xLnouc3RyaW5nKCkuZGVzY3JpYmUoXCJUaGUgSUQgb2YgdGhlIE5GVCB0byB0cmFuc2ZlclwiKSxcbiAgICBkZXN0aW5hdGlvbjogem9kXzEuelxuICAgICAgICAuc3RyaW5nKClcbiAgICAgICAgLmRlc2NyaWJlKFwiVGhlIGRlc3RpbmF0aW9uIHRvIHRyYW5zZmVyIHRoZSBORlQsIGUuZy4gYDB4NThkQmVjYzA4OTRBYjRDMjRGOThhMGU2ODRjOTg5ZUQwN2U0ZTAyN2AsIGBleGFtcGxlLmV0aGAsIGBleGFtcGxlLmJhc2UuZXRoYFwiKSxcbiAgICBmcm9tQWRkcmVzczogem9kXzEuelxuICAgICAgICAuc3RyaW5nKClcbiAgICAgICAgLm9wdGlvbmFsKClcbiAgICAgICAgLmRlc2NyaWJlKFwiVGhlIGFkZHJlc3MgdG8gdHJhbnNmZXIgZnJvbS4gSWYgbm90IHByb3ZpZGVkLCBkZWZhdWx0cyB0byB0aGUgd2FsbGV0J3MgZGVmYXVsdCBhZGRyZXNzXCIpLFxufSlcbiAgICAuc3RyaXAoKVxuICAgIC5kZXNjcmliZShcIklucHV0IHNjaGVtYSBmb3IgdHJhbnNmZXJyaW5nIGFuIE5GVFwiKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/erc721/schemas.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/farcaster/farcasterActionProvider.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/farcaster/farcasterActionProvider.js ***!
  \****************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.farcasterActionProvider = exports.FarcasterActionProvider = void 0;\nconst zod_1 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/lib/index.js\");\nconst actionProvider_1 = __webpack_require__(/*! ../actionProvider */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/actionProvider.js\");\nconst actionDecorator_1 = __webpack_require__(/*! ../actionDecorator */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/actionDecorator.js\");\nconst schemas_1 = __webpack_require__(/*! ./schemas */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/farcaster/schemas.js\");\n/**\n * FarcasterActionProvider is an action provider for Farcaster.\n */\nclass FarcasterActionProvider extends actionProvider_1.ActionProvider {\n    /**\n     * Constructor for the FarcasterActionProvider class.\n     *\n     * @param config - The configuration options for the FarcasterActionProvider.\n     */\n    constructor(config = {}) {\n        super(\"farcaster\", []);\n        /**\n         * Checks if the Farcaster action provider supports the given network.\n         *\n         * @param network - The network to check.\n         * @returns True if the Farcaster action provider supports the network, false otherwise.\n         */\n        this.supportsNetwork = (network) => network.protocolFamily === \"evm\";\n        const neynarApiKey = config.neynarApiKey || process.env.NEYNAR_API_KEY;\n        const signerUuid = config.signerUuid || process.env.NEYNAR_MANAGER_SIGNER;\n        const agentFid = config.agentFid || process.env.AGENT_FID;\n        if (!neynarApiKey) {\n            throw new Error(\"NEYNAR_API_KEY is not configured.\");\n        }\n        if (!signerUuid) {\n            throw new Error(\"NEYNAR_MANAGER_SIGNER is not configured.\");\n        }\n        if (!agentFid) {\n            throw new Error(\"AGENT_FID is not configured.\");\n        }\n        this.neynarApiKey = neynarApiKey;\n        this.signerUuid = signerUuid;\n        this.agentFid = agentFid;\n    }\n    /**\n     * Retrieves agent's Farcaster account details.\n     *\n     * @param _ - The input arguments for the action.\n     * @returns A message containing account details for the agent's Farcaster account.\n     */\n    async accountDetails(_) {\n        try {\n            const headers = {\n                accept: \"application/json\",\n                \"x-api-key\": this.neynarApiKey,\n                \"x-neynar-experimental\": \"true\",\n            };\n            const response = await fetch(`https://api.neynar.com/v2/farcaster/user/bulk?fids=${this.agentFid}`, {\n                method: \"GET\",\n                headers,\n            });\n            const { users } = await response.json();\n            return `Successfully retrieved Farcaster account details:\\n${JSON.stringify(users[0])}`;\n        }\n        catch (error) {\n            return `Error retrieving Farcaster account details:\\n${error}`;\n        }\n    }\n    /**\n     * Posts a cast on Farcaster.\n     *\n     * @param args - The input arguments for the action.\n     * @returns A message indicating the success or failure of the cast posting.\n     */\n    async postCast(args) {\n        try {\n            const headers = {\n                api_key: this.neynarApiKey,\n                \"Content-Type\": \"application/json\",\n            };\n            const response = await fetch(\"https://api.neynar.com/v2/farcaster/cast\", {\n                method: \"POST\",\n                headers,\n                body: JSON.stringify({\n                    signer_uuid: this.signerUuid,\n                    text: args.castText,\n                }),\n            });\n            const data = await response.json();\n            return `Successfully posted cast to Farcaster:\\n${JSON.stringify(data)}`;\n        }\n        catch (error) {\n            return `Error posting to Farcaster:\\n${error}`;\n        }\n    }\n}\nexports.FarcasterActionProvider = FarcasterActionProvider;\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"account_details\",\n        description: `\nThis tool will retrieve the account details for the agent's Farcaster account.\nThe tool takes the FID of the agent's account.\n\nA successful response will return a message with the API response as a JSON payload:\n    { \"object\": \"user\", \"fid\": 193,\" username\": \"derek\", \"display_name\": \"Derek\", ... }\n\nA failure response will return a message with the Farcaster API request error:\n    Unable to retrieve account details.\n`,\n        schema: schemas_1.FarcasterAccountDetailsSchema,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [void 0]),\n    __metadata(\"design:returntype\", Promise)\n], FarcasterActionProvider.prototype, \"accountDetails\", null);\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"post_cast\",\n        description: `\nThis tool will post a cast to Farcaster. The tool takes the text of the cast as input. Casts can be maximum 280 characters.\n\nA successful response will return a message with the API response as a JSON payload:\n    {}\n\nA failure response will return a message with the Farcaster API request error:\n    You are not allowed to post a cast with duplicate content.\n`,\n        schema: schemas_1.FarcasterPostCastSchema,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [void 0]),\n    __metadata(\"design:returntype\", Promise)\n], FarcasterActionProvider.prototype, \"postCast\", null);\nconst farcasterActionProvider = (config = {}) => new FarcasterActionProvider(config);\nexports.farcasterActionProvider = farcasterActionProvider;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9mYXJjYXN0ZXIvZmFyY2FzdGVyQWN0aW9uUHJvdmlkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsUUFBUTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELCtCQUErQixHQUFHLCtCQUErQjtBQUNqRSxjQUFjLG1CQUFPLENBQUMsa0RBQUs7QUFDM0IseUJBQXlCLG1CQUFPLENBQUMsMEdBQW1CO0FBQ3BELDBCQUEwQixtQkFBTyxDQUFDLDRHQUFvQjtBQUN0RCxrQkFBa0IsbUJBQU8sQ0FBQyxxR0FBVztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRkFBK0YsY0FBYztBQUM3RztBQUNBO0FBQ0EsYUFBYTtBQUNiLG9CQUFvQixRQUFRO0FBQzVCLHlFQUF5RSx5QkFBeUI7QUFDbEc7QUFDQTtBQUNBLG1FQUFtRSxNQUFNO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0EsOERBQThELHFCQUFxQjtBQUNuRjtBQUNBO0FBQ0EsbURBQW1ELE1BQU07QUFDekQ7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUMsK0JBQStCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3Vydml2YWwtZnVuLy4vbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9hZ2VudGtpdC9kaXN0L2FjdGlvbi1wcm92aWRlcnMvZmFyY2FzdGVyL2ZhcmNhc3RlckFjdGlvblByb3ZpZGVyLmpzPzc3MGMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5mYXJjYXN0ZXJBY3Rpb25Qcm92aWRlciA9IGV4cG9ydHMuRmFyY2FzdGVyQWN0aW9uUHJvdmlkZXIgPSB2b2lkIDA7XG5jb25zdCB6b2RfMSA9IHJlcXVpcmUoXCJ6b2RcIik7XG5jb25zdCBhY3Rpb25Qcm92aWRlcl8xID0gcmVxdWlyZShcIi4uL2FjdGlvblByb3ZpZGVyXCIpO1xuY29uc3QgYWN0aW9uRGVjb3JhdG9yXzEgPSByZXF1aXJlKFwiLi4vYWN0aW9uRGVjb3JhdG9yXCIpO1xuY29uc3Qgc2NoZW1hc18xID0gcmVxdWlyZShcIi4vc2NoZW1hc1wiKTtcbi8qKlxuICogRmFyY2FzdGVyQWN0aW9uUHJvdmlkZXIgaXMgYW4gYWN0aW9uIHByb3ZpZGVyIGZvciBGYXJjYXN0ZXIuXG4gKi9cbmNsYXNzIEZhcmNhc3RlckFjdGlvblByb3ZpZGVyIGV4dGVuZHMgYWN0aW9uUHJvdmlkZXJfMS5BY3Rpb25Qcm92aWRlciB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIHRoZSBGYXJjYXN0ZXJBY3Rpb25Qcm92aWRlciBjbGFzcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb25maWcgLSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgRmFyY2FzdGVyQWN0aW9uUHJvdmlkZXIuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnID0ge30pIHtcbiAgICAgICAgc3VwZXIoXCJmYXJjYXN0ZXJcIiwgW10pO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2tzIGlmIHRoZSBGYXJjYXN0ZXIgYWN0aW9uIHByb3ZpZGVyIHN1cHBvcnRzIHRoZSBnaXZlbiBuZXR3b3JrLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gbmV0d29yayAtIFRoZSBuZXR3b3JrIHRvIGNoZWNrLlxuICAgICAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBGYXJjYXN0ZXIgYWN0aW9uIHByb3ZpZGVyIHN1cHBvcnRzIHRoZSBuZXR3b3JrLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN1cHBvcnRzTmV0d29yayA9IChuZXR3b3JrKSA9PiBuZXR3b3JrLnByb3RvY29sRmFtaWx5ID09PSBcImV2bVwiO1xuICAgICAgICBjb25zdCBuZXluYXJBcGlLZXkgPSBjb25maWcubmV5bmFyQXBpS2V5IHx8IHByb2Nlc3MuZW52Lk5FWU5BUl9BUElfS0VZO1xuICAgICAgICBjb25zdCBzaWduZXJVdWlkID0gY29uZmlnLnNpZ25lclV1aWQgfHwgcHJvY2Vzcy5lbnYuTkVZTkFSX01BTkFHRVJfU0lHTkVSO1xuICAgICAgICBjb25zdCBhZ2VudEZpZCA9IGNvbmZpZy5hZ2VudEZpZCB8fCBwcm9jZXNzLmVudi5BR0VOVF9GSUQ7XG4gICAgICAgIGlmICghbmV5bmFyQXBpS2V5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJORVlOQVJfQVBJX0tFWSBpcyBub3QgY29uZmlndXJlZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzaWduZXJVdWlkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJORVlOQVJfTUFOQUdFUl9TSUdORVIgaXMgbm90IGNvbmZpZ3VyZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYWdlbnRGaWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFHRU5UX0ZJRCBpcyBub3QgY29uZmlndXJlZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5uZXluYXJBcGlLZXkgPSBuZXluYXJBcGlLZXk7XG4gICAgICAgIHRoaXMuc2lnbmVyVXVpZCA9IHNpZ25lclV1aWQ7XG4gICAgICAgIHRoaXMuYWdlbnRGaWQgPSBhZ2VudEZpZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGFnZW50J3MgRmFyY2FzdGVyIGFjY291bnQgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBfIC0gVGhlIGlucHV0IGFyZ3VtZW50cyBmb3IgdGhlIGFjdGlvbi5cbiAgICAgKiBAcmV0dXJucyBBIG1lc3NhZ2UgY29udGFpbmluZyBhY2NvdW50IGRldGFpbHMgZm9yIHRoZSBhZ2VudCdzIEZhcmNhc3RlciBhY2NvdW50LlxuICAgICAqL1xuICAgIGFzeW5jIGFjY291bnREZXRhaWxzKF8pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgYWNjZXB0OiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgICAgICBcIngtYXBpLWtleVwiOiB0aGlzLm5leW5hckFwaUtleSxcbiAgICAgICAgICAgICAgICBcIngtbmV5bmFyLWV4cGVyaW1lbnRhbFwiOiBcInRydWVcIixcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGBodHRwczovL2FwaS5uZXluYXIuY29tL3YyL2ZhcmNhc3Rlci91c2VyL2J1bGs/Zmlkcz0ke3RoaXMuYWdlbnRGaWR9YCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCB7IHVzZXJzIH0gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICByZXR1cm4gYFN1Y2Nlc3NmdWxseSByZXRyaWV2ZWQgRmFyY2FzdGVyIGFjY291bnQgZGV0YWlsczpcXG4ke0pTT04uc3RyaW5naWZ5KHVzZXJzWzBdKX1gO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGBFcnJvciByZXRyaWV2aW5nIEZhcmNhc3RlciBhY2NvdW50IGRldGFpbHM6XFxuJHtlcnJvcn1gO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBvc3RzIGEgY2FzdCBvbiBGYXJjYXN0ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXJncyAtIFRoZSBpbnB1dCBhcmd1bWVudHMgZm9yIHRoZSBhY3Rpb24uXG4gICAgICogQHJldHVybnMgQSBtZXNzYWdlIGluZGljYXRpbmcgdGhlIHN1Y2Nlc3Mgb3IgZmFpbHVyZSBvZiB0aGUgY2FzdCBwb3N0aW5nLlxuICAgICAqL1xuICAgIGFzeW5jIHBvc3RDYXN0KGFyZ3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgYXBpX2tleTogdGhpcy5uZXluYXJBcGlLZXksXG4gICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcImh0dHBzOi8vYXBpLm5leW5hci5jb20vdjIvZmFyY2FzdGVyL2Nhc3RcIiwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgICAgIHNpZ25lcl91dWlkOiB0aGlzLnNpZ25lclV1aWQsXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IGFyZ3MuY2FzdFRleHQsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICByZXR1cm4gYFN1Y2Nlc3NmdWxseSBwb3N0ZWQgY2FzdCB0byBGYXJjYXN0ZXI6XFxuJHtKU09OLnN0cmluZ2lmeShkYXRhKX1gO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGBFcnJvciBwb3N0aW5nIHRvIEZhcmNhc3RlcjpcXG4ke2Vycm9yfWA7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkZhcmNhc3RlckFjdGlvblByb3ZpZGVyID0gRmFyY2FzdGVyQWN0aW9uUHJvdmlkZXI7XG5fX2RlY29yYXRlKFtcbiAgICAoMCwgYWN0aW9uRGVjb3JhdG9yXzEuQ3JlYXRlQWN0aW9uKSh7XG4gICAgICAgIG5hbWU6IFwiYWNjb3VudF9kZXRhaWxzXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgXG5UaGlzIHRvb2wgd2lsbCByZXRyaWV2ZSB0aGUgYWNjb3VudCBkZXRhaWxzIGZvciB0aGUgYWdlbnQncyBGYXJjYXN0ZXIgYWNjb3VudC5cblRoZSB0b29sIHRha2VzIHRoZSBGSUQgb2YgdGhlIGFnZW50J3MgYWNjb3VudC5cblxuQSBzdWNjZXNzZnVsIHJlc3BvbnNlIHdpbGwgcmV0dXJuIGEgbWVzc2FnZSB3aXRoIHRoZSBBUEkgcmVzcG9uc2UgYXMgYSBKU09OIHBheWxvYWQ6XG4gICAgeyBcIm9iamVjdFwiOiBcInVzZXJcIiwgXCJmaWRcIjogMTkzLFwiIHVzZXJuYW1lXCI6IFwiZGVyZWtcIiwgXCJkaXNwbGF5X25hbWVcIjogXCJEZXJla1wiLCAuLi4gfVxuXG5BIGZhaWx1cmUgcmVzcG9uc2Ugd2lsbCByZXR1cm4gYSBtZXNzYWdlIHdpdGggdGhlIEZhcmNhc3RlciBBUEkgcmVxdWVzdCBlcnJvcjpcbiAgICBVbmFibGUgdG8gcmV0cmlldmUgYWNjb3VudCBkZXRhaWxzLlxuYCxcbiAgICAgICAgc2NoZW1hOiBzY2hlbWFzXzEuRmFyY2FzdGVyQWNjb3VudERldGFpbHNTY2hlbWEsXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW3ZvaWQgMF0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCBQcm9taXNlKVxuXSwgRmFyY2FzdGVyQWN0aW9uUHJvdmlkZXIucHJvdG90eXBlLCBcImFjY291bnREZXRhaWxzXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgKDAsIGFjdGlvbkRlY29yYXRvcl8xLkNyZWF0ZUFjdGlvbikoe1xuICAgICAgICBuYW1lOiBcInBvc3RfY2FzdFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogYFxuVGhpcyB0b29sIHdpbGwgcG9zdCBhIGNhc3QgdG8gRmFyY2FzdGVyLiBUaGUgdG9vbCB0YWtlcyB0aGUgdGV4dCBvZiB0aGUgY2FzdCBhcyBpbnB1dC4gQ2FzdHMgY2FuIGJlIG1heGltdW0gMjgwIGNoYXJhY3RlcnMuXG5cbkEgc3VjY2Vzc2Z1bCByZXNwb25zZSB3aWxsIHJldHVybiBhIG1lc3NhZ2Ugd2l0aCB0aGUgQVBJIHJlc3BvbnNlIGFzIGEgSlNPTiBwYXlsb2FkOlxuICAgIHt9XG5cbkEgZmFpbHVyZSByZXNwb25zZSB3aWxsIHJldHVybiBhIG1lc3NhZ2Ugd2l0aCB0aGUgRmFyY2FzdGVyIEFQSSByZXF1ZXN0IGVycm9yOlxuICAgIFlvdSBhcmUgbm90IGFsbG93ZWQgdG8gcG9zdCBhIGNhc3Qgd2l0aCBkdXBsaWNhdGUgY29udGVudC5cbmAsXG4gICAgICAgIHNjaGVtYTogc2NoZW1hc18xLkZhcmNhc3RlclBvc3RDYXN0U2NoZW1hLFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFt2b2lkIDBdKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgUHJvbWlzZSlcbl0sIEZhcmNhc3RlckFjdGlvblByb3ZpZGVyLnByb3RvdHlwZSwgXCJwb3N0Q2FzdFwiLCBudWxsKTtcbmNvbnN0IGZhcmNhc3RlckFjdGlvblByb3ZpZGVyID0gKGNvbmZpZyA9IHt9KSA9PiBuZXcgRmFyY2FzdGVyQWN0aW9uUHJvdmlkZXIoY29uZmlnKTtcbmV4cG9ydHMuZmFyY2FzdGVyQWN0aW9uUHJvdmlkZXIgPSBmYXJjYXN0ZXJBY3Rpb25Qcm92aWRlcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/farcaster/farcasterActionProvider.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/farcaster/index.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/farcaster/index.js ***!
  \**********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./schemas */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/farcaster/schemas.js\"), exports);\n__exportStar(__webpack_require__(/*! ./farcasterActionProvider */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/farcaster/farcasterActionProvider.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9mYXJjYXN0ZXIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYSxtQkFBTyxDQUFDLHFHQUFXO0FBQ2hDLGFBQWEsbUJBQU8sQ0FBQyxxSUFBMkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXJ2aXZhbC1mdW4vLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9mYXJjYXN0ZXIvaW5kZXguanM/YzU5OSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3NjaGVtYXNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2ZhcmNhc3RlckFjdGlvblByb3ZpZGVyXCIpLCBleHBvcnRzKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/farcaster/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/farcaster/schemas.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/farcaster/schemas.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FarcasterPostCastSchema = exports.FarcasterAccountDetailsSchema = void 0;\nconst zod_1 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/lib/index.js\");\n/**\n * Input argument schema for the account_details action.\n */\nexports.FarcasterAccountDetailsSchema = zod_1.z\n    .object({})\n    .strip()\n    .describe(\"Input schema for retrieving account details\");\n/**\n * Input argument schema for the post cast action.\n */\nexports.FarcasterPostCastSchema = zod_1.z\n    .object({\n    castText: zod_1.z.string().max(280, \"Cast text must be a maximum of 280 characters.\"),\n})\n    .strip()\n    .describe(\"Input schema for posting a text-based cast\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9mYXJjYXN0ZXIvc2NoZW1hcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwrQkFBK0IsR0FBRyxxQ0FBcUM7QUFDdkUsY0FBYyxtQkFBTyxDQUFDLGtEQUFLO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQyxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXJ2aXZhbC1mdW4vLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9mYXJjYXN0ZXIvc2NoZW1hcy5qcz9jNDFkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5GYXJjYXN0ZXJQb3N0Q2FzdFNjaGVtYSA9IGV4cG9ydHMuRmFyY2FzdGVyQWNjb3VudERldGFpbHNTY2hlbWEgPSB2b2lkIDA7XG5jb25zdCB6b2RfMSA9IHJlcXVpcmUoXCJ6b2RcIik7XG4vKipcbiAqIElucHV0IGFyZ3VtZW50IHNjaGVtYSBmb3IgdGhlIGFjY291bnRfZGV0YWlscyBhY3Rpb24uXG4gKi9cbmV4cG9ydHMuRmFyY2FzdGVyQWNjb3VudERldGFpbHNTY2hlbWEgPSB6b2RfMS56XG4gICAgLm9iamVjdCh7fSlcbiAgICAuc3RyaXAoKVxuICAgIC5kZXNjcmliZShcIklucHV0IHNjaGVtYSBmb3IgcmV0cmlldmluZyBhY2NvdW50IGRldGFpbHNcIik7XG4vKipcbiAqIElucHV0IGFyZ3VtZW50IHNjaGVtYSBmb3IgdGhlIHBvc3QgY2FzdCBhY3Rpb24uXG4gKi9cbmV4cG9ydHMuRmFyY2FzdGVyUG9zdENhc3RTY2hlbWEgPSB6b2RfMS56XG4gICAgLm9iamVjdCh7XG4gICAgY2FzdFRleHQ6IHpvZF8xLnouc3RyaW5nKCkubWF4KDI4MCwgXCJDYXN0IHRleHQgbXVzdCBiZSBhIG1heGltdW0gb2YgMjgwIGNoYXJhY3RlcnMuXCIpLFxufSlcbiAgICAuc3RyaXAoKVxuICAgIC5kZXNjcmliZShcIklucHV0IHNjaGVtYSBmb3IgcG9zdGluZyBhIHRleHQtYmFzZWQgY2FzdFwiKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/farcaster/schemas.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/flaunch/constants.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/flaunch/constants.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PERMIT_TYPES = exports.PERMIT_DETAILS = exports.PERMIT2_ABI = exports.UNIVERSAL_ROUTER_ABI = exports.URCommands = exports.V4Actions = exports.IV4RouterAbiExactOutput = exports.IV4RouterAbiExactInput = exports.QUOTER_ABI = exports.POSITION_MANAGER_ABI = exports.FAST_FLAUNCH_ZAP_ABI = exports.Permit2Address = exports.UniversalRouterAddress = exports.QuoterAddress = exports.FLETHHooksAddress = exports.FLETHAddress = exports.FlaunchPositionManagerAddress = exports.FastFlaunchZapAddress = exports.ERC20_ABI = void 0;\nconst viem_1 = __webpack_require__(/*! viem */ \"(rsc)/./node_modules/viem/_cjs/index.js\");\nconst chains_1 = __webpack_require__(/*! viem/chains */ \"(rsc)/./node_modules/viem/_cjs/chains/index.js\");\nconst constants_1 = __webpack_require__(/*! ../erc20/constants */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/erc20/constants.js\");\nObject.defineProperty(exports, \"ERC20_ABI\", ({ enumerable: true, get: function () { return constants_1.abi; } }));\nexports.FastFlaunchZapAddress = {\n    [chains_1.base.id]: \"0xd79e27f51ddf9df5ee76106ee192530f474b02f6\",\n    [chains_1.baseSepolia.id]: \"0x251e97446a7019E5DA4860d4CF47291321C693D0\",\n};\nexports.FlaunchPositionManagerAddress = {\n    [chains_1.base.id]: \"0x51Bba15255406Cfe7099a42183302640ba7dAFDC\",\n    [chains_1.baseSepolia.id]: \"0x9A7059cA00dA92843906Cb4bCa1D005cE848AFdC\",\n};\nexports.FLETHAddress = {\n    [chains_1.base.id]: \"0x000000000D564D5be76f7f0d28fE52605afC7Cf8\",\n    [chains_1.baseSepolia.id]: \"0x79FC52701cD4BE6f9Ba9aDC94c207DE37e3314eb\",\n};\nexports.FLETHHooksAddress = {\n    [chains_1.base.id]: \"0x9E433F32bb5481a9CA7DFF5b3af74A7ed041a888\",\n    [chains_1.baseSepolia.id]: \"0x4bd2ca15286c96e4e731337de8b375da6841e888\",\n};\nexports.QuoterAddress = {\n    [chains_1.base.id]: \"0x0d5e0f971ed27fbff6c2837bf31316121532048d\",\n    [chains_1.baseSepolia.id]: \"0x4a6513c898fe1b2d0e78d3b0e0a4a151589b1cba\",\n};\nexports.UniversalRouterAddress = {\n    [chains_1.base.id]: \"0x6fF5693b99212Da76ad316178A184AB56D299b43\",\n    [chains_1.baseSepolia.id]: \"0x492E6456D9528771018DeB9E87ef7750EF184104\",\n};\nexports.Permit2Address = {\n    [chains_1.base.id]: \"0x000000000022D473030F116dDEE9F6B43aC78BA3\",\n    [chains_1.baseSepolia.id]: \"0x000000000022D473030F116dDEE9F6B43aC78BA3\",\n};\nexports.FAST_FLAUNCH_ZAP_ABI = [\n    {\n        type: \"function\",\n        name: \"flaunch\",\n        inputs: [\n            {\n                name: \"_params\",\n                type: \"tuple\",\n                internalType: \"struct FastFlaunchZap.FastFlaunchParams\",\n                components: [\n                    {\n                        name: \"name\",\n                        type: \"string\",\n                        internalType: \"string\",\n                    },\n                    {\n                        name: \"symbol\",\n                        type: \"string\",\n                        internalType: \"string\",\n                    },\n                    {\n                        name: \"tokenUri\",\n                        type: \"string\",\n                        internalType: \"string\",\n                    },\n                    {\n                        name: \"creator\",\n                        type: \"address\",\n                        internalType: \"address\",\n                    },\n                ],\n            },\n        ],\n        outputs: [\n            {\n                name: \"memecoin_\",\n                type: \"address\",\n                internalType: \"address\",\n            },\n        ],\n        stateMutability: \"nonpayable\",\n    },\n];\nexports.POSITION_MANAGER_ABI = (0, viem_1.parseAbi)([\n    \"event PoolCreated(bytes32 indexed _poolId, address _memecoin, address _memecoinTreasury, uint256 _tokenId, bool _currencyFlipped, uint256 _flaunchFee, (string name, string symbol, string tokenUri, uint256 initialTokenFairLaunch, uint256 premineAmount, address creator, uint24 creatorFeeAllocation, uint256 flaunchAt, bytes initialPriceParams, bytes feeCalculatorParams) _params)\",\n    \"event PoolSwap(bytes32 indexed poolId, int flAmount0, int flAmount1, int flFee0, int flFee1, int ispAmount0, int ispAmount1, int ispFee0, int ispFee1, int uniAmount0, int uniAmount1, int uniFee0, int uniFee1)\",\n]);\nexports.QUOTER_ABI = [\n    {\n        inputs: [\n            {\n                internalType: \"contract IPoolManager\",\n                name: \"_poolManager\",\n                type: \"address\",\n            },\n        ],\n        stateMutability: \"nonpayable\",\n        type: \"constructor\",\n    },\n    {\n        inputs: [{ internalType: \"PoolId\", name: \"poolId\", type: \"bytes32\" }],\n        name: \"NotEnoughLiquidity\",\n        type: \"error\",\n    },\n    { inputs: [], name: \"NotPoolManager\", type: \"error\" },\n    { inputs: [], name: \"NotSelf\", type: \"error\" },\n    {\n        inputs: [{ internalType: \"uint256\", name: \"amount\", type: \"uint256\" }],\n        name: \"QuoteSwap\",\n        type: \"error\",\n    },\n    { inputs: [], name: \"UnexpectedCallSuccess\", type: \"error\" },\n    {\n        inputs: [{ internalType: \"bytes\", name: \"revertData\", type: \"bytes\" }],\n        name: \"UnexpectedRevertBytes\",\n        type: \"error\",\n    },\n    {\n        inputs: [\n            {\n                components: [\n                    { internalType: \"Currency\", name: \"exactCurrency\", type: \"address\" },\n                    {\n                        components: [\n                            {\n                                internalType: \"Currency\",\n                                name: \"intermediateCurrency\",\n                                type: \"address\",\n                            },\n                            { internalType: \"uint24\", name: \"fee\", type: \"uint24\" },\n                            { internalType: \"int24\", name: \"tickSpacing\", type: \"int24\" },\n                            {\n                                internalType: \"contract IHooks\",\n                                name: \"hooks\",\n                                type: \"address\",\n                            },\n                            { internalType: \"bytes\", name: \"hookData\", type: \"bytes\" },\n                        ],\n                        internalType: \"struct PathKey[]\",\n                        name: \"path\",\n                        type: \"tuple[]\",\n                    },\n                    { internalType: \"uint128\", name: \"exactAmount\", type: \"uint128\" },\n                ],\n                internalType: \"struct IV4Quoter.QuoteExactParams\",\n                name: \"params\",\n                type: \"tuple\",\n            },\n        ],\n        name: \"_quoteExactInput\",\n        outputs: [{ internalType: \"bytes\", name: \"\", type: \"bytes\" }],\n        stateMutability: \"nonpayable\",\n        type: \"function\",\n    },\n    {\n        inputs: [\n            {\n                components: [\n                    {\n                        components: [\n                            { internalType: \"Currency\", name: \"currency0\", type: \"address\" },\n                            { internalType: \"Currency\", name: \"currency1\", type: \"address\" },\n                            { internalType: \"uint24\", name: \"fee\", type: \"uint24\" },\n                            { internalType: \"int24\", name: \"tickSpacing\", type: \"int24\" },\n                            {\n                                internalType: \"contract IHooks\",\n                                name: \"hooks\",\n                                type: \"address\",\n                            },\n                        ],\n                        internalType: \"struct PoolKey\",\n                        name: \"poolKey\",\n                        type: \"tuple\",\n                    },\n                    { internalType: \"bool\", name: \"zeroForOne\", type: \"bool\" },\n                    { internalType: \"uint128\", name: \"exactAmount\", type: \"uint128\" },\n                    { internalType: \"bytes\", name: \"hookData\", type: \"bytes\" },\n                ],\n                internalType: \"struct IV4Quoter.QuoteExactSingleParams\",\n                name: \"params\",\n                type: \"tuple\",\n            },\n        ],\n        name: \"_quoteExactInputSingle\",\n        outputs: [{ internalType: \"bytes\", name: \"\", type: \"bytes\" }],\n        stateMutability: \"nonpayable\",\n        type: \"function\",\n    },\n    {\n        inputs: [\n            {\n                components: [\n                    { internalType: \"Currency\", name: \"exactCurrency\", type: \"address\" },\n                    {\n                        components: [\n                            {\n                                internalType: \"Currency\",\n                                name: \"intermediateCurrency\",\n                                type: \"address\",\n                            },\n                            { internalType: \"uint24\", name: \"fee\", type: \"uint24\" },\n                            { internalType: \"int24\", name: \"tickSpacing\", type: \"int24\" },\n                            {\n                                internalType: \"contract IHooks\",\n                                name: \"hooks\",\n                                type: \"address\",\n                            },\n                            { internalType: \"bytes\", name: \"hookData\", type: \"bytes\" },\n                        ],\n                        internalType: \"struct PathKey[]\",\n                        name: \"path\",\n                        type: \"tuple[]\",\n                    },\n                    { internalType: \"uint128\", name: \"exactAmount\", type: \"uint128\" },\n                ],\n                internalType: \"struct IV4Quoter.QuoteExactParams\",\n                name: \"params\",\n                type: \"tuple\",\n            },\n        ],\n        name: \"_quoteExactOutput\",\n        outputs: [{ internalType: \"bytes\", name: \"\", type: \"bytes\" }],\n        stateMutability: \"nonpayable\",\n        type: \"function\",\n    },\n    {\n        inputs: [\n            {\n                components: [\n                    {\n                        components: [\n                            { internalType: \"Currency\", name: \"currency0\", type: \"address\" },\n                            { internalType: \"Currency\", name: \"currency1\", type: \"address\" },\n                            { internalType: \"uint24\", name: \"fee\", type: \"uint24\" },\n                            { internalType: \"int24\", name: \"tickSpacing\", type: \"int24\" },\n                            {\n                                internalType: \"contract IHooks\",\n                                name: \"hooks\",\n                                type: \"address\",\n                            },\n                        ],\n                        internalType: \"struct PoolKey\",\n                        name: \"poolKey\",\n                        type: \"tuple\",\n                    },\n                    { internalType: \"bool\", name: \"zeroForOne\", type: \"bool\" },\n                    { internalType: \"uint128\", name: \"exactAmount\", type: \"uint128\" },\n                    { internalType: \"bytes\", name: \"hookData\", type: \"bytes\" },\n                ],\n                internalType: \"struct IV4Quoter.QuoteExactSingleParams\",\n                name: \"params\",\n                type: \"tuple\",\n            },\n        ],\n        name: \"_quoteExactOutputSingle\",\n        outputs: [{ internalType: \"bytes\", name: \"\", type: \"bytes\" }],\n        stateMutability: \"nonpayable\",\n        type: \"function\",\n    },\n    {\n        inputs: [],\n        name: \"poolManager\",\n        outputs: [{ internalType: \"contract IPoolManager\", name: \"\", type: \"address\" }],\n        stateMutability: \"view\",\n        type: \"function\",\n    },\n    {\n        inputs: [\n            {\n                components: [\n                    { internalType: \"Currency\", name: \"exactCurrency\", type: \"address\" },\n                    {\n                        components: [\n                            {\n                                internalType: \"Currency\",\n                                name: \"intermediateCurrency\",\n                                type: \"address\",\n                            },\n                            { internalType: \"uint24\", name: \"fee\", type: \"uint24\" },\n                            { internalType: \"int24\", name: \"tickSpacing\", type: \"int24\" },\n                            {\n                                internalType: \"contract IHooks\",\n                                name: \"hooks\",\n                                type: \"address\",\n                            },\n                            { internalType: \"bytes\", name: \"hookData\", type: \"bytes\" },\n                        ],\n                        internalType: \"struct PathKey[]\",\n                        name: \"path\",\n                        type: \"tuple[]\",\n                    },\n                    { internalType: \"uint128\", name: \"exactAmount\", type: \"uint128\" },\n                ],\n                internalType: \"struct IV4Quoter.QuoteExactParams\",\n                name: \"params\",\n                type: \"tuple\",\n            },\n        ],\n        name: \"quoteExactInput\",\n        outputs: [\n            { internalType: \"uint256\", name: \"amountOut\", type: \"uint256\" },\n            { internalType: \"uint256\", name: \"gasEstimate\", type: \"uint256\" },\n        ],\n        stateMutability: \"nonpayable\",\n        type: \"function\",\n    },\n    {\n        inputs: [\n            {\n                components: [\n                    {\n                        components: [\n                            { internalType: \"Currency\", name: \"currency0\", type: \"address\" },\n                            { internalType: \"Currency\", name: \"currency1\", type: \"address\" },\n                            { internalType: \"uint24\", name: \"fee\", type: \"uint24\" },\n                            { internalType: \"int24\", name: \"tickSpacing\", type: \"int24\" },\n                            {\n                                internalType: \"contract IHooks\",\n                                name: \"hooks\",\n                                type: \"address\",\n                            },\n                        ],\n                        internalType: \"struct PoolKey\",\n                        name: \"poolKey\",\n                        type: \"tuple\",\n                    },\n                    { internalType: \"bool\", name: \"zeroForOne\", type: \"bool\" },\n                    { internalType: \"uint128\", name: \"exactAmount\", type: \"uint128\" },\n                    { internalType: \"bytes\", name: \"hookData\", type: \"bytes\" },\n                ],\n                internalType: \"struct IV4Quoter.QuoteExactSingleParams\",\n                name: \"params\",\n                type: \"tuple\",\n            },\n        ],\n        name: \"quoteExactInputSingle\",\n        outputs: [\n            { internalType: \"uint256\", name: \"amountOut\", type: \"uint256\" },\n            { internalType: \"uint256\", name: \"gasEstimate\", type: \"uint256\" },\n        ],\n        stateMutability: \"nonpayable\",\n        type: \"function\",\n    },\n    {\n        inputs: [\n            {\n                components: [\n                    { internalType: \"Currency\", name: \"exactCurrency\", type: \"address\" },\n                    {\n                        components: [\n                            {\n                                internalType: \"Currency\",\n                                name: \"intermediateCurrency\",\n                                type: \"address\",\n                            },\n                            { internalType: \"uint24\", name: \"fee\", type: \"uint24\" },\n                            { internalType: \"int24\", name: \"tickSpacing\", type: \"int24\" },\n                            {\n                                internalType: \"contract IHooks\",\n                                name: \"hooks\",\n                                type: \"address\",\n                            },\n                            { internalType: \"bytes\", name: \"hookData\", type: \"bytes\" },\n                        ],\n                        internalType: \"struct PathKey[]\",\n                        name: \"path\",\n                        type: \"tuple[]\",\n                    },\n                    { internalType: \"uint128\", name: \"exactAmount\", type: \"uint128\" },\n                ],\n                internalType: \"struct IV4Quoter.QuoteExactParams\",\n                name: \"params\",\n                type: \"tuple\",\n            },\n        ],\n        name: \"quoteExactOutput\",\n        outputs: [\n            { internalType: \"uint256\", name: \"amountIn\", type: \"uint256\" },\n            { internalType: \"uint256\", name: \"gasEstimate\", type: \"uint256\" },\n        ],\n        stateMutability: \"nonpayable\",\n        type: \"function\",\n    },\n    {\n        inputs: [\n            {\n                components: [\n                    {\n                        components: [\n                            { internalType: \"Currency\", name: \"currency0\", type: \"address\" },\n                            { internalType: \"Currency\", name: \"currency1\", type: \"address\" },\n                            { internalType: \"uint24\", name: \"fee\", type: \"uint24\" },\n                            { internalType: \"int24\", name: \"tickSpacing\", type: \"int24\" },\n                            {\n                                internalType: \"contract IHooks\",\n                                name: \"hooks\",\n                                type: \"address\",\n                            },\n                        ],\n                        internalType: \"struct PoolKey\",\n                        name: \"poolKey\",\n                        type: \"tuple\",\n                    },\n                    { internalType: \"bool\", name: \"zeroForOne\", type: \"bool\" },\n                    { internalType: \"uint128\", name: \"exactAmount\", type: \"uint128\" },\n                    { internalType: \"bytes\", name: \"hookData\", type: \"bytes\" },\n                ],\n                internalType: \"struct IV4Quoter.QuoteExactSingleParams\",\n                name: \"params\",\n                type: \"tuple\",\n            },\n        ],\n        name: \"quoteExactOutputSingle\",\n        outputs: [\n            { internalType: \"uint256\", name: \"amountIn\", type: \"uint256\" },\n            { internalType: \"uint256\", name: \"gasEstimate\", type: \"uint256\" },\n        ],\n        stateMutability: \"nonpayable\",\n        type: \"function\",\n    },\n    {\n        inputs: [{ internalType: \"bytes\", name: \"data\", type: \"bytes\" }],\n        name: \"unlockCallback\",\n        outputs: [{ internalType: \"bytes\", name: \"\", type: \"bytes\" }],\n        stateMutability: \"nonpayable\",\n        type: \"function\",\n    },\n];\nexports.IV4RouterAbiExactInput = [\n    {\n        type: \"tuple\",\n        components: [\n            { type: \"address\", name: \"currencyIn\" },\n            {\n                type: \"tuple[]\",\n                name: \"path\",\n                components: [\n                    { type: \"address\", name: \"intermediateCurrency\" },\n                    { type: \"uint24\", name: \"fee\" },\n                    { type: \"int24\", name: \"tickSpacing\" },\n                    { type: \"address\", name: \"hooks\" },\n                    { type: \"bytes\", name: \"hookData\" },\n                ],\n            },\n            { type: \"uint128\", name: \"amountIn\" },\n            { type: \"uint128\", name: \"amountOutMinimum\" },\n        ],\n    },\n];\nexports.IV4RouterAbiExactOutput = [\n    {\n        type: \"tuple\",\n        components: [\n            { type: \"address\", name: \"currencyOut\" },\n            {\n                type: \"tuple[]\",\n                name: \"path\",\n                components: [\n                    { type: \"address\", name: \"intermediateCurrency\" },\n                    { type: \"uint24\", name: \"fee\" },\n                    { type: \"int24\", name: \"tickSpacing\" },\n                    { type: \"address\", name: \"hooks\" },\n                    { type: \"bytes\", name: \"hookData\" },\n                ],\n            },\n            { type: \"uint128\", name: \"amountOut\" },\n            { type: \"uint128\", name: \"amountInMaximum\" },\n        ],\n    },\n];\nexports.V4Actions = {\n    SWAP_EXACT_IN: \"07\",\n    SWAP_EXACT_OUT: \"09\",\n    SETTLE_ALL: \"0c\",\n    TAKE_ALL: \"0f\",\n};\nexports.URCommands = {\n    V4_SWAP: \"10\",\n    SWEEP: \"04\",\n    PERMIT2_PERMIT: \"0a\",\n};\nexports.UNIVERSAL_ROUTER_ABI = [\n    {\n        inputs: [\n            {\n                components: [\n                    { internalType: \"address\", name: \"permit2\", type: \"address\" },\n                    { internalType: \"address\", name: \"weth9\", type: \"address\" },\n                    { internalType: \"address\", name: \"v2Factory\", type: \"address\" },\n                    { internalType: \"address\", name: \"v3Factory\", type: \"address\" },\n                    {\n                        internalType: \"bytes32\",\n                        name: \"pairInitCodeHash\",\n                        type: \"bytes32\",\n                    },\n                    {\n                        internalType: \"bytes32\",\n                        name: \"poolInitCodeHash\",\n                        type: \"bytes32\",\n                    },\n                    { internalType: \"address\", name: \"v4PoolManager\", type: \"address\" },\n                    {\n                        internalType: \"address\",\n                        name: \"v3NFTPositionManager\",\n                        type: \"address\",\n                    },\n                    {\n                        internalType: \"address\",\n                        name: \"v4PositionManager\",\n                        type: \"address\",\n                    },\n                ],\n                internalType: \"struct RouterParameters\",\n                name: \"params\",\n                type: \"tuple\",\n            },\n        ],\n        stateMutability: \"nonpayable\",\n        type: \"constructor\",\n    },\n    { inputs: [], name: \"BalanceTooLow\", type: \"error\" },\n    { inputs: [], name: \"ContractLocked\", type: \"error\" },\n    {\n        inputs: [{ internalType: \"Currency\", name: \"currency\", type: \"address\" }],\n        name: \"DeltaNotNegative\",\n        type: \"error\",\n    },\n    {\n        inputs: [{ internalType: \"Currency\", name: \"currency\", type: \"address\" }],\n        name: \"DeltaNotPositive\",\n        type: \"error\",\n    },\n    { inputs: [], name: \"ETHNotAccepted\", type: \"error\" },\n    {\n        inputs: [\n            { internalType: \"uint256\", name: \"commandIndex\", type: \"uint256\" },\n            { internalType: \"bytes\", name: \"message\", type: \"bytes\" },\n        ],\n        name: \"ExecutionFailed\",\n        type: \"error\",\n    },\n    { inputs: [], name: \"FromAddressIsNotOwner\", type: \"error\" },\n    { inputs: [], name: \"InputLengthMismatch\", type: \"error\" },\n    { inputs: [], name: \"InsufficientBalance\", type: \"error\" },\n    { inputs: [], name: \"InsufficientETH\", type: \"error\" },\n    { inputs: [], name: \"InsufficientToken\", type: \"error\" },\n    {\n        inputs: [{ internalType: \"bytes4\", name: \"action\", type: \"bytes4\" }],\n        name: \"InvalidAction\",\n        type: \"error\",\n    },\n    { inputs: [], name: \"InvalidBips\", type: \"error\" },\n    {\n        inputs: [{ internalType: \"uint256\", name: \"commandType\", type: \"uint256\" }],\n        name: \"InvalidCommandType\",\n        type: \"error\",\n    },\n    { inputs: [], name: \"InvalidEthSender\", type: \"error\" },\n    { inputs: [], name: \"InvalidPath\", type: \"error\" },\n    { inputs: [], name: \"InvalidReserves\", type: \"error\" },\n    { inputs: [], name: \"LengthMismatch\", type: \"error\" },\n    {\n        inputs: [{ internalType: \"uint256\", name: \"tokenId\", type: \"uint256\" }],\n        name: \"NotAuthorizedForToken\",\n        type: \"error\",\n    },\n    { inputs: [], name: \"NotPoolManager\", type: \"error\" },\n    { inputs: [], name: \"OnlyMintAllowed\", type: \"error\" },\n    { inputs: [], name: \"SliceOutOfBounds\", type: \"error\" },\n    { inputs: [], name: \"TransactionDeadlinePassed\", type: \"error\" },\n    { inputs: [], name: \"UnsafeCast\", type: \"error\" },\n    {\n        inputs: [{ internalType: \"uint256\", name: \"action\", type: \"uint256\" }],\n        name: \"UnsupportedAction\",\n        type: \"error\",\n    },\n    { inputs: [], name: \"V2InvalidPath\", type: \"error\" },\n    { inputs: [], name: \"V2TooLittleReceived\", type: \"error\" },\n    { inputs: [], name: \"V2TooMuchRequested\", type: \"error\" },\n    { inputs: [], name: \"V3InvalidAmountOut\", type: \"error\" },\n    { inputs: [], name: \"V3InvalidCaller\", type: \"error\" },\n    { inputs: [], name: \"V3InvalidSwap\", type: \"error\" },\n    { inputs: [], name: \"V3TooLittleReceived\", type: \"error\" },\n    { inputs: [], name: \"V3TooMuchRequested\", type: \"error\" },\n    {\n        inputs: [\n            {\n                internalType: \"uint256\",\n                name: \"minAmountOutReceived\",\n                type: \"uint256\",\n            },\n            { internalType: \"uint256\", name: \"amountReceived\", type: \"uint256\" },\n        ],\n        name: \"V4TooLittleReceived\",\n        type: \"error\",\n    },\n    {\n        inputs: [\n            {\n                internalType: \"uint256\",\n                name: \"maxAmountInRequested\",\n                type: \"uint256\",\n            },\n            { internalType: \"uint256\", name: \"amountRequested\", type: \"uint256\" },\n        ],\n        name: \"V4TooMuchRequested\",\n        type: \"error\",\n    },\n    {\n        inputs: [],\n        name: \"V3_POSITION_MANAGER\",\n        outputs: [\n            {\n                internalType: \"contract INonfungiblePositionManager\",\n                name: \"\",\n                type: \"address\",\n            },\n        ],\n        stateMutability: \"view\",\n        type: \"function\",\n    },\n    {\n        inputs: [],\n        name: \"V4_POSITION_MANAGER\",\n        outputs: [{ internalType: \"contract IPositionManager\", name: \"\", type: \"address\" }],\n        stateMutability: \"view\",\n        type: \"function\",\n    },\n    {\n        inputs: [\n            { internalType: \"bytes\", name: \"commands\", type: \"bytes\" },\n            { internalType: \"bytes[]\", name: \"inputs\", type: \"bytes[]\" },\n        ],\n        name: \"execute\",\n        outputs: [],\n        stateMutability: \"payable\",\n        type: \"function\",\n    },\n    {\n        inputs: [\n            { internalType: \"bytes\", name: \"commands\", type: \"bytes\" },\n            { internalType: \"bytes[]\", name: \"inputs\", type: \"bytes[]\" },\n            { internalType: \"uint256\", name: \"deadline\", type: \"uint256\" },\n        ],\n        name: \"execute\",\n        outputs: [],\n        stateMutability: \"payable\",\n        type: \"function\",\n    },\n    {\n        inputs: [],\n        name: \"msgSender\",\n        outputs: [{ internalType: \"address\", name: \"\", type: \"address\" }],\n        stateMutability: \"view\",\n        type: \"function\",\n    },\n    {\n        inputs: [],\n        name: \"poolManager\",\n        outputs: [{ internalType: \"contract IPoolManager\", name: \"\", type: \"address\" }],\n        stateMutability: \"view\",\n        type: \"function\",\n    },\n    {\n        inputs: [\n            { internalType: \"int256\", name: \"amount0Delta\", type: \"int256\" },\n            { internalType: \"int256\", name: \"amount1Delta\", type: \"int256\" },\n            { internalType: \"bytes\", name: \"data\", type: \"bytes\" },\n        ],\n        name: \"uniswapV3SwapCallback\",\n        outputs: [],\n        stateMutability: \"nonpayable\",\n        type: \"function\",\n    },\n    {\n        inputs: [{ internalType: \"bytes\", name: \"data\", type: \"bytes\" }],\n        name: \"unlockCallback\",\n        outputs: [{ internalType: \"bytes\", name: \"\", type: \"bytes\" }],\n        stateMutability: \"nonpayable\",\n        type: \"function\",\n    },\n    { stateMutability: \"payable\", type: \"receive\" },\n];\nexports.PERMIT2_ABI = [\n    {\n        inputs: [\n            { internalType: \"address\", name: \"\", type: \"address\" },\n            { internalType: \"address\", name: \"\", type: \"address\" },\n            { internalType: \"address\", name: \"\", type: \"address\" },\n        ],\n        name: \"allowance\",\n        outputs: [\n            { internalType: \"uint160\", name: \"amount\", type: \"uint160\" },\n            { internalType: \"uint48\", name: \"expiration\", type: \"uint48\" },\n            { internalType: \"uint48\", name: \"nonce\", type: \"uint48\" },\n        ],\n        stateMutability: \"view\",\n        type: \"function\",\n    },\n];\nexports.PERMIT_DETAILS = [\n    { name: \"token\", type: \"address\" },\n    { name: \"amount\", type: \"uint160\" },\n    { name: \"expiration\", type: \"uint48\" },\n    { name: \"nonce\", type: \"uint48\" },\n];\nexports.PERMIT_TYPES = {\n    PermitSingle: [\n        { name: \"details\", type: \"PermitDetails\" },\n        { name: \"spender\", type: \"address\" },\n        { name: \"sigDeadline\", type: \"uint256\" },\n    ],\n    PermitDetails: exports.PERMIT_DETAILS,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9mbGF1bmNoL2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0IsR0FBRyxzQkFBc0IsR0FBRyxtQkFBbUIsR0FBRyw0QkFBNEIsR0FBRyxrQkFBa0IsR0FBRyxpQkFBaUIsR0FBRywrQkFBK0IsR0FBRyw4QkFBOEIsR0FBRyxrQkFBa0IsR0FBRyw0QkFBNEIsR0FBRyw0QkFBNEIsR0FBRyxzQkFBc0IsR0FBRyw4QkFBOEIsR0FBRyxxQkFBcUIsR0FBRyx5QkFBeUIsR0FBRyxvQkFBb0IsR0FBRyxxQ0FBcUMsR0FBRyw2QkFBNkIsR0FBRyxpQkFBaUI7QUFDbGdCLGVBQWUsbUJBQU8sQ0FBQyxxREFBTTtBQUM3QixpQkFBaUIsbUJBQU8sQ0FBQyxtRUFBYTtBQUN0QyxvQkFBb0IsbUJBQU8sQ0FBQyw0R0FBb0I7QUFDaEQsNkNBQTRDLEVBQUUscUNBQXFDLDJCQUEyQixFQUFDO0FBQy9HLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxtQkFBbUIseURBQXlEO0FBQzVFO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsTUFBTSxtREFBbUQ7QUFDekQsTUFBTSw0Q0FBNEM7QUFDbEQ7QUFDQSxtQkFBbUIsMERBQTBEO0FBQzdFO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsTUFBTSwwREFBMEQ7QUFDaEU7QUFDQSxtQkFBbUIsMERBQTBEO0FBQzdFO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isa0VBQWtFO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3Qiw4QkFBOEIscURBQXFEO0FBQ25GLDhCQUE4QiwyREFBMkQ7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IsOEJBQThCLHdEQUF3RDtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixzQkFBc0IsK0RBQStEO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxvQkFBb0IsZ0RBQWdEO0FBQ3BFO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDhEQUE4RDtBQUM1Riw4QkFBOEIsOERBQThEO0FBQzVGLDhCQUE4QixxREFBcUQ7QUFDbkYsOEJBQThCLDJEQUEyRDtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixzQkFBc0Isd0RBQXdEO0FBQzlFLHNCQUFzQiwrREFBK0Q7QUFDckYsc0JBQXNCLHdEQUF3RDtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0Esb0JBQW9CLGdEQUFnRDtBQUNwRTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGtFQUFrRTtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IsOEJBQThCLHFEQUFxRDtBQUNuRiw4QkFBOEIsMkRBQTJEO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLDhCQUE4Qix3REFBd0Q7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsc0JBQXNCLCtEQUErRDtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0Esb0JBQW9CLGdEQUFnRDtBQUNwRTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qiw4REFBOEQ7QUFDNUYsOEJBQThCLDhEQUE4RDtBQUM1Riw4QkFBOEIscURBQXFEO0FBQ25GLDhCQUE4QiwyREFBMkQ7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsc0JBQXNCLHdEQUF3RDtBQUM5RSxzQkFBc0IsK0RBQStEO0FBQ3JGLHNCQUFzQix3REFBd0Q7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLG9CQUFvQixnREFBZ0Q7QUFDcEU7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0VBQWtFO0FBQ3RGO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isa0VBQWtFO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3Qiw4QkFBOEIscURBQXFEO0FBQ25GLDhCQUE4QiwyREFBMkQ7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IsOEJBQThCLHdEQUF3RDtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixzQkFBc0IsK0RBQStEO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGNBQWMsNkRBQTZEO0FBQzNFLGNBQWMsK0RBQStEO0FBQzdFO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsOERBQThEO0FBQzVGLDhCQUE4Qiw4REFBOEQ7QUFDNUYsOEJBQThCLHFEQUFxRDtBQUNuRiw4QkFBOEIsMkRBQTJEO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLHNCQUFzQix3REFBd0Q7QUFDOUUsc0JBQXNCLCtEQUErRDtBQUNyRixzQkFBc0Isd0RBQXdEO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGNBQWMsNkRBQTZEO0FBQzNFLGNBQWMsK0RBQStEO0FBQzdFO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixrRUFBa0U7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLDhCQUE4QixxREFBcUQ7QUFDbkYsOEJBQThCLDJEQUEyRDtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3Qiw4QkFBOEIsd0RBQXdEO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLHNCQUFzQiwrREFBK0Q7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsY0FBYyw0REFBNEQ7QUFDMUUsY0FBYywrREFBK0Q7QUFDN0U7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qiw4REFBOEQ7QUFDNUYsOEJBQThCLDhEQUE4RDtBQUM1Riw4QkFBOEIscURBQXFEO0FBQ25GLDhCQUE4QiwyREFBMkQ7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsc0JBQXNCLHdEQUF3RDtBQUM5RSxzQkFBc0IsK0RBQStEO0FBQ3JGLHNCQUFzQix3REFBd0Q7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsY0FBYyw0REFBNEQ7QUFDMUUsY0FBYywrREFBK0Q7QUFDN0U7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsbUJBQW1CLG9EQUFvRDtBQUN2RTtBQUNBLG9CQUFvQixnREFBZ0Q7QUFDcEU7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxjQUFjLHFDQUFxQztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwrQ0FBK0M7QUFDckUsc0JBQXNCLDZCQUE2QjtBQUNuRCxzQkFBc0Isb0NBQW9DO0FBQzFELHNCQUFzQixnQ0FBZ0M7QUFDdEQsc0JBQXNCLGlDQUFpQztBQUN2RDtBQUNBLGFBQWE7QUFDYixjQUFjLG1DQUFtQztBQUNqRCxjQUFjLDJDQUEyQztBQUN6RDtBQUNBLEtBQUs7QUFDTDtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxjQUFjLHNDQUFzQztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwrQ0FBK0M7QUFDckUsc0JBQXNCLDZCQUE2QjtBQUNuRCxzQkFBc0Isb0NBQW9DO0FBQzFELHNCQUFzQixnQ0FBZ0M7QUFDdEQsc0JBQXNCLGlDQUFpQztBQUN2RDtBQUNBLGFBQWE7QUFDYixjQUFjLG9DQUFvQztBQUNsRCxjQUFjLDBDQUEwQztBQUN4RDtBQUNBLEtBQUs7QUFDTDtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDJEQUEyRDtBQUNqRixzQkFBc0IseURBQXlEO0FBQy9FLHNCQUFzQiw2REFBNkQ7QUFDbkYsc0JBQXNCLDZEQUE2RDtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixzQkFBc0IsaUVBQWlFO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxNQUFNLGtEQUFrRDtBQUN4RCxNQUFNLG1EQUFtRDtBQUN6RDtBQUNBLG1CQUFtQiw2REFBNkQ7QUFDaEY7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLG1CQUFtQiw2REFBNkQ7QUFDaEY7QUFDQTtBQUNBLEtBQUs7QUFDTCxNQUFNLG1EQUFtRDtBQUN6RDtBQUNBO0FBQ0EsY0FBYyxnRUFBZ0U7QUFDOUUsY0FBYyx1REFBdUQ7QUFDckU7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLE1BQU0sMERBQTBEO0FBQ2hFLE1BQU0sd0RBQXdEO0FBQzlELE1BQU0sd0RBQXdEO0FBQzlELE1BQU0sb0RBQW9EO0FBQzFELE1BQU0sc0RBQXNEO0FBQzVEO0FBQ0EsbUJBQW1CLHdEQUF3RDtBQUMzRTtBQUNBO0FBQ0EsS0FBSztBQUNMLE1BQU0sZ0RBQWdEO0FBQ3REO0FBQ0EsbUJBQW1CLCtEQUErRDtBQUNsRjtBQUNBO0FBQ0EsS0FBSztBQUNMLE1BQU0scURBQXFEO0FBQzNELE1BQU0sZ0RBQWdEO0FBQ3RELE1BQU0sb0RBQW9EO0FBQzFELE1BQU0sbURBQW1EO0FBQ3pEO0FBQ0EsbUJBQW1CLDJEQUEyRDtBQUM5RTtBQUNBO0FBQ0EsS0FBSztBQUNMLE1BQU0sbURBQW1EO0FBQ3pELE1BQU0sb0RBQW9EO0FBQzFELE1BQU0scURBQXFEO0FBQzNELE1BQU0sOERBQThEO0FBQ3BFLE1BQU0sK0NBQStDO0FBQ3JEO0FBQ0EsbUJBQW1CLDBEQUEwRDtBQUM3RTtBQUNBO0FBQ0EsS0FBSztBQUNMLE1BQU0sa0RBQWtEO0FBQ3hELE1BQU0sd0RBQXdEO0FBQzlELE1BQU0sdURBQXVEO0FBQzdELE1BQU0sdURBQXVEO0FBQzdELE1BQU0sb0RBQW9EO0FBQzFELE1BQU0sa0RBQWtEO0FBQ3hELE1BQU0sd0RBQXdEO0FBQzlELE1BQU0sdURBQXVEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixjQUFjLGtFQUFrRTtBQUNoRjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLGNBQWMsbUVBQW1FO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0VBQXNFO0FBQzFGO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGNBQWMsd0RBQXdEO0FBQ3RFLGNBQWMsMERBQTBEO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGNBQWMsd0RBQXdEO0FBQ3RFLGNBQWMsMERBQTBEO0FBQ3hFLGNBQWMsNERBQTREO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9EQUFvRDtBQUN4RTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrRUFBa0U7QUFDdEY7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsY0FBYyw4REFBOEQ7QUFDNUUsY0FBYyw4REFBOEQ7QUFDNUUsY0FBYyxvREFBb0Q7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLG1CQUFtQixvREFBb0Q7QUFDdkU7QUFDQSxvQkFBb0IsZ0RBQWdEO0FBQ3BFO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsTUFBTSw2Q0FBNkM7QUFDbkQ7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLGNBQWMsb0RBQW9EO0FBQ2xFLGNBQWMsb0RBQW9EO0FBQ2xFLGNBQWMsb0RBQW9EO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBLGNBQWMsMERBQTBEO0FBQ3hFLGNBQWMsNERBQTREO0FBQzFFLGNBQWMsdURBQXVEO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHNCQUFzQjtBQUN0QixNQUFNLGdDQUFnQztBQUN0QyxNQUFNLGlDQUFpQztBQUN2QyxNQUFNLG9DQUFvQztBQUMxQyxNQUFNLCtCQUErQjtBQUNyQztBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLFVBQVUsd0NBQXdDO0FBQ2xELFVBQVUsa0NBQWtDO0FBQzVDLFVBQVUsc0NBQXNDO0FBQ2hEO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cnZpdmFsLWZ1bi8uL25vZGVfbW9kdWxlcy9AY29pbmJhc2UvYWdlbnRraXQvZGlzdC9hY3Rpb24tcHJvdmlkZXJzL2ZsYXVuY2gvY29uc3RhbnRzLmpzP2MzZjAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlBFUk1JVF9UWVBFUyA9IGV4cG9ydHMuUEVSTUlUX0RFVEFJTFMgPSBleHBvcnRzLlBFUk1JVDJfQUJJID0gZXhwb3J0cy5VTklWRVJTQUxfUk9VVEVSX0FCSSA9IGV4cG9ydHMuVVJDb21tYW5kcyA9IGV4cG9ydHMuVjRBY3Rpb25zID0gZXhwb3J0cy5JVjRSb3V0ZXJBYmlFeGFjdE91dHB1dCA9IGV4cG9ydHMuSVY0Um91dGVyQWJpRXhhY3RJbnB1dCA9IGV4cG9ydHMuUVVPVEVSX0FCSSA9IGV4cG9ydHMuUE9TSVRJT05fTUFOQUdFUl9BQkkgPSBleHBvcnRzLkZBU1RfRkxBVU5DSF9aQVBfQUJJID0gZXhwb3J0cy5QZXJtaXQyQWRkcmVzcyA9IGV4cG9ydHMuVW5pdmVyc2FsUm91dGVyQWRkcmVzcyA9IGV4cG9ydHMuUXVvdGVyQWRkcmVzcyA9IGV4cG9ydHMuRkxFVEhIb29rc0FkZHJlc3MgPSBleHBvcnRzLkZMRVRIQWRkcmVzcyA9IGV4cG9ydHMuRmxhdW5jaFBvc2l0aW9uTWFuYWdlckFkZHJlc3MgPSBleHBvcnRzLkZhc3RGbGF1bmNoWmFwQWRkcmVzcyA9IGV4cG9ydHMuRVJDMjBfQUJJID0gdm9pZCAwO1xuY29uc3QgdmllbV8xID0gcmVxdWlyZShcInZpZW1cIik7XG5jb25zdCBjaGFpbnNfMSA9IHJlcXVpcmUoXCJ2aWVtL2NoYWluc1wiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4uL2VyYzIwL2NvbnN0YW50c1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkVSQzIwX0FCSVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uc3RhbnRzXzEuYWJpOyB9IH0pO1xuZXhwb3J0cy5GYXN0RmxhdW5jaFphcEFkZHJlc3MgPSB7XG4gICAgW2NoYWluc18xLmJhc2UuaWRdOiBcIjB4ZDc5ZTI3ZjUxZGRmOWRmNWVlNzYxMDZlZTE5MjUzMGY0NzRiMDJmNlwiLFxuICAgIFtjaGFpbnNfMS5iYXNlU2Vwb2xpYS5pZF06IFwiMHgyNTFlOTc0NDZhNzAxOUU1REE0ODYwZDRDRjQ3MjkxMzIxQzY5M0QwXCIsXG59O1xuZXhwb3J0cy5GbGF1bmNoUG9zaXRpb25NYW5hZ2VyQWRkcmVzcyA9IHtcbiAgICBbY2hhaW5zXzEuYmFzZS5pZF06IFwiMHg1MUJiYTE1MjU1NDA2Q2ZlNzA5OWE0MjE4MzMwMjY0MGJhN2RBRkRDXCIsXG4gICAgW2NoYWluc18xLmJhc2VTZXBvbGlhLmlkXTogXCIweDlBNzA1OWNBMDBkQTkyODQzOTA2Q2I0YkNhMUQwMDVjRTg0OEFGZENcIixcbn07XG5leHBvcnRzLkZMRVRIQWRkcmVzcyA9IHtcbiAgICBbY2hhaW5zXzEuYmFzZS5pZF06IFwiMHgwMDAwMDAwMDBENTY0RDViZTc2ZjdmMGQyOGZFNTI2MDVhZkM3Q2Y4XCIsXG4gICAgW2NoYWluc18xLmJhc2VTZXBvbGlhLmlkXTogXCIweDc5RkM1MjcwMWNENEJFNmY5QmE5YURDOTRjMjA3REUzN2UzMzE0ZWJcIixcbn07XG5leHBvcnRzLkZMRVRISG9va3NBZGRyZXNzID0ge1xuICAgIFtjaGFpbnNfMS5iYXNlLmlkXTogXCIweDlFNDMzRjMyYmI1NDgxYTlDQTdERkY1YjNhZjc0QTdlZDA0MWE4ODhcIixcbiAgICBbY2hhaW5zXzEuYmFzZVNlcG9saWEuaWRdOiBcIjB4NGJkMmNhMTUyODZjOTZlNGU3MzEzMzdkZThiMzc1ZGE2ODQxZTg4OFwiLFxufTtcbmV4cG9ydHMuUXVvdGVyQWRkcmVzcyA9IHtcbiAgICBbY2hhaW5zXzEuYmFzZS5pZF06IFwiMHgwZDVlMGY5NzFlZDI3ZmJmZjZjMjgzN2JmMzEzMTYxMjE1MzIwNDhkXCIsXG4gICAgW2NoYWluc18xLmJhc2VTZXBvbGlhLmlkXTogXCIweDRhNjUxM2M4OThmZTFiMmQwZTc4ZDNiMGUwYTRhMTUxNTg5YjFjYmFcIixcbn07XG5leHBvcnRzLlVuaXZlcnNhbFJvdXRlckFkZHJlc3MgPSB7XG4gICAgW2NoYWluc18xLmJhc2UuaWRdOiBcIjB4NmZGNTY5M2I5OTIxMkRhNzZhZDMxNjE3OEExODRBQjU2RDI5OWI0M1wiLFxuICAgIFtjaGFpbnNfMS5iYXNlU2Vwb2xpYS5pZF06IFwiMHg0OTJFNjQ1NkQ5NTI4NzcxMDE4RGVCOUU4N2VmNzc1MEVGMTg0MTA0XCIsXG59O1xuZXhwb3J0cy5QZXJtaXQyQWRkcmVzcyA9IHtcbiAgICBbY2hhaW5zXzEuYmFzZS5pZF06IFwiMHgwMDAwMDAwMDAwMjJENDczMDMwRjExNmRERUU5RjZCNDNhQzc4QkEzXCIsXG4gICAgW2NoYWluc18xLmJhc2VTZXBvbGlhLmlkXTogXCIweDAwMDAwMDAwMDAyMkQ0NzMwMzBGMTE2ZERFRTlGNkI0M2FDNzhCQTNcIixcbn07XG5leHBvcnRzLkZBU1RfRkxBVU5DSF9aQVBfQUJJID0gW1xuICAgIHtcbiAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICBuYW1lOiBcImZsYXVuY2hcIixcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJfcGFyYW1zXCIsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJ0dXBsZVwiLFxuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogXCJzdHJ1Y3QgRmFzdEZsYXVuY2haYXAuRmFzdEZsYXVuY2hQYXJhbXNcIixcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwibmFtZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJzeW1ib2xcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwidG9rZW5VcmlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiY3JlYXRvclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBvdXRwdXRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJtZW1lY29pbl9cIixcbiAgICAgICAgICAgICAgICB0eXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiBcIm5vbnBheWFibGVcIixcbiAgICB9LFxuXTtcbmV4cG9ydHMuUE9TSVRJT05fTUFOQUdFUl9BQkkgPSAoMCwgdmllbV8xLnBhcnNlQWJpKShbXG4gICAgXCJldmVudCBQb29sQ3JlYXRlZChieXRlczMyIGluZGV4ZWQgX3Bvb2xJZCwgYWRkcmVzcyBfbWVtZWNvaW4sIGFkZHJlc3MgX21lbWVjb2luVHJlYXN1cnksIHVpbnQyNTYgX3Rva2VuSWQsIGJvb2wgX2N1cnJlbmN5RmxpcHBlZCwgdWludDI1NiBfZmxhdW5jaEZlZSwgKHN0cmluZyBuYW1lLCBzdHJpbmcgc3ltYm9sLCBzdHJpbmcgdG9rZW5VcmksIHVpbnQyNTYgaW5pdGlhbFRva2VuRmFpckxhdW5jaCwgdWludDI1NiBwcmVtaW5lQW1vdW50LCBhZGRyZXNzIGNyZWF0b3IsIHVpbnQyNCBjcmVhdG9yRmVlQWxsb2NhdGlvbiwgdWludDI1NiBmbGF1bmNoQXQsIGJ5dGVzIGluaXRpYWxQcmljZVBhcmFtcywgYnl0ZXMgZmVlQ2FsY3VsYXRvclBhcmFtcykgX3BhcmFtcylcIixcbiAgICBcImV2ZW50IFBvb2xTd2FwKGJ5dGVzMzIgaW5kZXhlZCBwb29sSWQsIGludCBmbEFtb3VudDAsIGludCBmbEFtb3VudDEsIGludCBmbEZlZTAsIGludCBmbEZlZTEsIGludCBpc3BBbW91bnQwLCBpbnQgaXNwQW1vdW50MSwgaW50IGlzcEZlZTAsIGludCBpc3BGZWUxLCBpbnQgdW5pQW1vdW50MCwgaW50IHVuaUFtb3VudDEsIGludCB1bmlGZWUwLCBpbnQgdW5pRmVlMSlcIixcbl0pO1xuZXhwb3J0cy5RVU9URVJfQUJJID0gW1xuICAgIHtcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiBcImNvbnRyYWN0IElQb29sTWFuYWdlclwiLFxuICAgICAgICAgICAgICAgIG5hbWU6IFwiX3Bvb2xNYW5hZ2VyXCIsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6IFwibm9ucGF5YWJsZVwiLFxuICAgICAgICB0eXBlOiBcImNvbnN0cnVjdG9yXCIsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlucHV0czogW3sgaW50ZXJuYWxUeXBlOiBcIlBvb2xJZFwiLCBuYW1lOiBcInBvb2xJZFwiLCB0eXBlOiBcImJ5dGVzMzJcIiB9XSxcbiAgICAgICAgbmFtZTogXCJOb3RFbm91Z2hMaXF1aWRpdHlcIixcbiAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgIH0sXG4gICAgeyBpbnB1dHM6IFtdLCBuYW1lOiBcIk5vdFBvb2xNYW5hZ2VyXCIsIHR5cGU6IFwiZXJyb3JcIiB9LFxuICAgIHsgaW5wdXRzOiBbXSwgbmFtZTogXCJOb3RTZWxmXCIsIHR5cGU6IFwiZXJyb3JcIiB9LFxuICAgIHtcbiAgICAgICAgaW5wdXRzOiBbeyBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLCBuYW1lOiBcImFtb3VudFwiLCB0eXBlOiBcInVpbnQyNTZcIiB9XSxcbiAgICAgICAgbmFtZTogXCJRdW90ZVN3YXBcIixcbiAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgIH0sXG4gICAgeyBpbnB1dHM6IFtdLCBuYW1lOiBcIlVuZXhwZWN0ZWRDYWxsU3VjY2Vzc1wiLCB0eXBlOiBcImVycm9yXCIgfSxcbiAgICB7XG4gICAgICAgIGlucHV0czogW3sgaW50ZXJuYWxUeXBlOiBcImJ5dGVzXCIsIG5hbWU6IFwicmV2ZXJ0RGF0YVwiLCB0eXBlOiBcImJ5dGVzXCIgfV0sXG4gICAgICAgIG5hbWU6IFwiVW5leHBlY3RlZFJldmVydEJ5dGVzXCIsXG4gICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICB9LFxuICAgIHtcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50czogW1xuICAgICAgICAgICAgICAgICAgICB7IGludGVybmFsVHlwZTogXCJDdXJyZW5jeVwiLCBuYW1lOiBcImV4YWN0Q3VycmVuY3lcIiwgdHlwZTogXCJhZGRyZXNzXCIgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50czogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiBcIkN1cnJlbmN5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiaW50ZXJtZWRpYXRlQ3VycmVuY3lcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IGludGVybmFsVHlwZTogXCJ1aW50MjRcIiwgbmFtZTogXCJmZWVcIiwgdHlwZTogXCJ1aW50MjRcIiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgaW50ZXJuYWxUeXBlOiBcImludDI0XCIsIG5hbWU6IFwidGlja1NwYWNpbmdcIiwgdHlwZTogXCJpbnQyNFwiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6IFwiY29udHJhY3QgSUhvb2tzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiaG9va3NcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IGludGVybmFsVHlwZTogXCJieXRlc1wiLCBuYW1lOiBcImhvb2tEYXRhXCIsIHR5cGU6IFwiYnl0ZXNcIiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogXCJzdHJ1Y3QgUGF0aEtleVtdXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcInBhdGhcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidHVwbGVbXVwiLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7IGludGVybmFsVHlwZTogXCJ1aW50MTI4XCIsIG5hbWU6IFwiZXhhY3RBbW91bnRcIiwgdHlwZTogXCJ1aW50MTI4XCIgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogXCJzdHJ1Y3QgSVY0UXVvdGVyLlF1b3RlRXhhY3RQYXJhbXNcIixcbiAgICAgICAgICAgICAgICBuYW1lOiBcInBhcmFtc1wiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwidHVwbGVcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIG5hbWU6IFwiX3F1b3RlRXhhY3RJbnB1dFwiLFxuICAgICAgICBvdXRwdXRzOiBbeyBpbnRlcm5hbFR5cGU6IFwiYnl0ZXNcIiwgbmFtZTogXCJcIiwgdHlwZTogXCJieXRlc1wiIH1dLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6IFwibm9ucGF5YWJsZVwiLFxuICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudHM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50czogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgaW50ZXJuYWxUeXBlOiBcIkN1cnJlbmN5XCIsIG5hbWU6IFwiY3VycmVuY3kwXCIsIHR5cGU6IFwiYWRkcmVzc1wiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBpbnRlcm5hbFR5cGU6IFwiQ3VycmVuY3lcIiwgbmFtZTogXCJjdXJyZW5jeTFcIiwgdHlwZTogXCJhZGRyZXNzXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IGludGVybmFsVHlwZTogXCJ1aW50MjRcIiwgbmFtZTogXCJmZWVcIiwgdHlwZTogXCJ1aW50MjRcIiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgaW50ZXJuYWxUeXBlOiBcImludDI0XCIsIG5hbWU6IFwidGlja1NwYWNpbmdcIiwgdHlwZTogXCJpbnQyNFwiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6IFwiY29udHJhY3QgSUhvb2tzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiaG9va3NcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6IFwic3RydWN0IFBvb2xLZXlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwicG9vbEtleVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0dXBsZVwiLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7IGludGVybmFsVHlwZTogXCJib29sXCIsIG5hbWU6IFwiemVyb0Zvck9uZVwiLCB0eXBlOiBcImJvb2xcIiB9LFxuICAgICAgICAgICAgICAgICAgICB7IGludGVybmFsVHlwZTogXCJ1aW50MTI4XCIsIG5hbWU6IFwiZXhhY3RBbW91bnRcIiwgdHlwZTogXCJ1aW50MTI4XCIgfSxcbiAgICAgICAgICAgICAgICAgICAgeyBpbnRlcm5hbFR5cGU6IFwiYnl0ZXNcIiwgbmFtZTogXCJob29rRGF0YVwiLCB0eXBlOiBcImJ5dGVzXCIgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogXCJzdHJ1Y3QgSVY0UXVvdGVyLlF1b3RlRXhhY3RTaW5nbGVQYXJhbXNcIixcbiAgICAgICAgICAgICAgICBuYW1lOiBcInBhcmFtc1wiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwidHVwbGVcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIG5hbWU6IFwiX3F1b3RlRXhhY3RJbnB1dFNpbmdsZVwiLFxuICAgICAgICBvdXRwdXRzOiBbeyBpbnRlcm5hbFR5cGU6IFwiYnl0ZXNcIiwgbmFtZTogXCJcIiwgdHlwZTogXCJieXRlc1wiIH1dLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6IFwibm9ucGF5YWJsZVwiLFxuICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudHM6IFtcbiAgICAgICAgICAgICAgICAgICAgeyBpbnRlcm5hbFR5cGU6IFwiQ3VycmVuY3lcIiwgbmFtZTogXCJleGFjdEN1cnJlbmN5XCIsIHR5cGU6IFwiYWRkcmVzc1wiIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogXCJDdXJyZW5jeVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcImludGVybWVkaWF0ZUN1cnJlbmN5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBpbnRlcm5hbFR5cGU6IFwidWludDI0XCIsIG5hbWU6IFwiZmVlXCIsIHR5cGU6IFwidWludDI0XCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IGludGVybmFsVHlwZTogXCJpbnQyNFwiLCBuYW1lOiBcInRpY2tTcGFjaW5nXCIsIHR5cGU6IFwiaW50MjRcIiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiBcImNvbnRyYWN0IElIb29rc1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcImhvb2tzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBpbnRlcm5hbFR5cGU6IFwiYnl0ZXNcIiwgbmFtZTogXCJob29rRGF0YVwiLCB0eXBlOiBcImJ5dGVzXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6IFwic3RydWN0IFBhdGhLZXlbXVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJwYXRoXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInR1cGxlW11cIixcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgeyBpbnRlcm5hbFR5cGU6IFwidWludDEyOFwiLCBuYW1lOiBcImV4YWN0QW1vdW50XCIsIHR5cGU6IFwidWludDEyOFwiIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6IFwic3RydWN0IElWNFF1b3Rlci5RdW90ZUV4YWN0UGFyYW1zXCIsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJwYXJhbXNcIixcbiAgICAgICAgICAgICAgICB0eXBlOiBcInR1cGxlXCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBuYW1lOiBcIl9xdW90ZUV4YWN0T3V0cHV0XCIsXG4gICAgICAgIG91dHB1dHM6IFt7IGludGVybmFsVHlwZTogXCJieXRlc1wiLCBuYW1lOiBcIlwiLCB0eXBlOiBcImJ5dGVzXCIgfV0sXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogXCJub25wYXlhYmxlXCIsXG4gICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICB9LFxuICAgIHtcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50czogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBpbnRlcm5hbFR5cGU6IFwiQ3VycmVuY3lcIiwgbmFtZTogXCJjdXJyZW5jeTBcIiwgdHlwZTogXCJhZGRyZXNzXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IGludGVybmFsVHlwZTogXCJDdXJyZW5jeVwiLCBuYW1lOiBcImN1cnJlbmN5MVwiLCB0eXBlOiBcImFkZHJlc3NcIiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgaW50ZXJuYWxUeXBlOiBcInVpbnQyNFwiLCBuYW1lOiBcImZlZVwiLCB0eXBlOiBcInVpbnQyNFwiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBpbnRlcm5hbFR5cGU6IFwiaW50MjRcIiwgbmFtZTogXCJ0aWNrU3BhY2luZ1wiLCB0eXBlOiBcImludDI0XCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogXCJjb250cmFjdCBJSG9va3NcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJob29rc1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogXCJzdHJ1Y3QgUG9vbEtleVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJwb29sS2V5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInR1cGxlXCIsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHsgaW50ZXJuYWxUeXBlOiBcImJvb2xcIiwgbmFtZTogXCJ6ZXJvRm9yT25lXCIsIHR5cGU6IFwiYm9vbFwiIH0sXG4gICAgICAgICAgICAgICAgICAgIHsgaW50ZXJuYWxUeXBlOiBcInVpbnQxMjhcIiwgbmFtZTogXCJleGFjdEFtb3VudFwiLCB0eXBlOiBcInVpbnQxMjhcIiB9LFxuICAgICAgICAgICAgICAgICAgICB7IGludGVybmFsVHlwZTogXCJieXRlc1wiLCBuYW1lOiBcImhvb2tEYXRhXCIsIHR5cGU6IFwiYnl0ZXNcIiB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiBcInN0cnVjdCBJVjRRdW90ZXIuUXVvdGVFeGFjdFNpbmdsZVBhcmFtc1wiLFxuICAgICAgICAgICAgICAgIG5hbWU6IFwicGFyYW1zXCIsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJ0dXBsZVwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgbmFtZTogXCJfcXVvdGVFeGFjdE91dHB1dFNpbmdsZVwiLFxuICAgICAgICBvdXRwdXRzOiBbeyBpbnRlcm5hbFR5cGU6IFwiYnl0ZXNcIiwgbmFtZTogXCJcIiwgdHlwZTogXCJieXRlc1wiIH1dLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6IFwibm9ucGF5YWJsZVwiLFxuICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlucHV0czogW10sXG4gICAgICAgIG5hbWU6IFwicG9vbE1hbmFnZXJcIixcbiAgICAgICAgb3V0cHV0czogW3sgaW50ZXJuYWxUeXBlOiBcImNvbnRyYWN0IElQb29sTWFuYWdlclwiLCBuYW1lOiBcIlwiLCB0eXBlOiBcImFkZHJlc3NcIiB9XSxcbiAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIixcbiAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgIH0sXG4gICAge1xuICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzOiBbXG4gICAgICAgICAgICAgICAgICAgIHsgaW50ZXJuYWxUeXBlOiBcIkN1cnJlbmN5XCIsIG5hbWU6IFwiZXhhY3RDdXJyZW5jeVwiLCB0eXBlOiBcImFkZHJlc3NcIiB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6IFwiQ3VycmVuY3lcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJpbnRlcm1lZGlhdGVDdXJyZW5jeVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgaW50ZXJuYWxUeXBlOiBcInVpbnQyNFwiLCBuYW1lOiBcImZlZVwiLCB0eXBlOiBcInVpbnQyNFwiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBpbnRlcm5hbFR5cGU6IFwiaW50MjRcIiwgbmFtZTogXCJ0aWNrU3BhY2luZ1wiLCB0eXBlOiBcImludDI0XCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogXCJjb250cmFjdCBJSG9va3NcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJob29rc1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgaW50ZXJuYWxUeXBlOiBcImJ5dGVzXCIsIG5hbWU6IFwiaG9va0RhdGFcIiwgdHlwZTogXCJieXRlc1wiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiBcInN0cnVjdCBQYXRoS2V5W11cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwicGF0aFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0dXBsZVtdXCIsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHsgaW50ZXJuYWxUeXBlOiBcInVpbnQxMjhcIiwgbmFtZTogXCJleGFjdEFtb3VudFwiLCB0eXBlOiBcInVpbnQxMjhcIiB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiBcInN0cnVjdCBJVjRRdW90ZXIuUXVvdGVFeGFjdFBhcmFtc1wiLFxuICAgICAgICAgICAgICAgIG5hbWU6IFwicGFyYW1zXCIsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJ0dXBsZVwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgbmFtZTogXCJxdW90ZUV4YWN0SW5wdXRcIixcbiAgICAgICAgb3V0cHV0czogW1xuICAgICAgICAgICAgeyBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLCBuYW1lOiBcImFtb3VudE91dFwiLCB0eXBlOiBcInVpbnQyNTZcIiB9LFxuICAgICAgICAgICAgeyBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLCBuYW1lOiBcImdhc0VzdGltYXRlXCIsIHR5cGU6IFwidWludDI1NlwiIH0sXG4gICAgICAgIF0sXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogXCJub25wYXlhYmxlXCIsXG4gICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICB9LFxuICAgIHtcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50czogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBpbnRlcm5hbFR5cGU6IFwiQ3VycmVuY3lcIiwgbmFtZTogXCJjdXJyZW5jeTBcIiwgdHlwZTogXCJhZGRyZXNzXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IGludGVybmFsVHlwZTogXCJDdXJyZW5jeVwiLCBuYW1lOiBcImN1cnJlbmN5MVwiLCB0eXBlOiBcImFkZHJlc3NcIiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgaW50ZXJuYWxUeXBlOiBcInVpbnQyNFwiLCBuYW1lOiBcImZlZVwiLCB0eXBlOiBcInVpbnQyNFwiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBpbnRlcm5hbFR5cGU6IFwiaW50MjRcIiwgbmFtZTogXCJ0aWNrU3BhY2luZ1wiLCB0eXBlOiBcImludDI0XCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogXCJjb250cmFjdCBJSG9va3NcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJob29rc1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogXCJzdHJ1Y3QgUG9vbEtleVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJwb29sS2V5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInR1cGxlXCIsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHsgaW50ZXJuYWxUeXBlOiBcImJvb2xcIiwgbmFtZTogXCJ6ZXJvRm9yT25lXCIsIHR5cGU6IFwiYm9vbFwiIH0sXG4gICAgICAgICAgICAgICAgICAgIHsgaW50ZXJuYWxUeXBlOiBcInVpbnQxMjhcIiwgbmFtZTogXCJleGFjdEFtb3VudFwiLCB0eXBlOiBcInVpbnQxMjhcIiB9LFxuICAgICAgICAgICAgICAgICAgICB7IGludGVybmFsVHlwZTogXCJieXRlc1wiLCBuYW1lOiBcImhvb2tEYXRhXCIsIHR5cGU6IFwiYnl0ZXNcIiB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiBcInN0cnVjdCBJVjRRdW90ZXIuUXVvdGVFeGFjdFNpbmdsZVBhcmFtc1wiLFxuICAgICAgICAgICAgICAgIG5hbWU6IFwicGFyYW1zXCIsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJ0dXBsZVwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgbmFtZTogXCJxdW90ZUV4YWN0SW5wdXRTaW5nbGVcIixcbiAgICAgICAgb3V0cHV0czogW1xuICAgICAgICAgICAgeyBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLCBuYW1lOiBcImFtb3VudE91dFwiLCB0eXBlOiBcInVpbnQyNTZcIiB9LFxuICAgICAgICAgICAgeyBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLCBuYW1lOiBcImdhc0VzdGltYXRlXCIsIHR5cGU6IFwidWludDI1NlwiIH0sXG4gICAgICAgIF0sXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogXCJub25wYXlhYmxlXCIsXG4gICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICB9LFxuICAgIHtcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50czogW1xuICAgICAgICAgICAgICAgICAgICB7IGludGVybmFsVHlwZTogXCJDdXJyZW5jeVwiLCBuYW1lOiBcImV4YWN0Q3VycmVuY3lcIiwgdHlwZTogXCJhZGRyZXNzXCIgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50czogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiBcIkN1cnJlbmN5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiaW50ZXJtZWRpYXRlQ3VycmVuY3lcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IGludGVybmFsVHlwZTogXCJ1aW50MjRcIiwgbmFtZTogXCJmZWVcIiwgdHlwZTogXCJ1aW50MjRcIiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgaW50ZXJuYWxUeXBlOiBcImludDI0XCIsIG5hbWU6IFwidGlja1NwYWNpbmdcIiwgdHlwZTogXCJpbnQyNFwiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6IFwiY29udHJhY3QgSUhvb2tzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiaG9va3NcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IGludGVybmFsVHlwZTogXCJieXRlc1wiLCBuYW1lOiBcImhvb2tEYXRhXCIsIHR5cGU6IFwiYnl0ZXNcIiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogXCJzdHJ1Y3QgUGF0aEtleVtdXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcInBhdGhcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidHVwbGVbXVwiLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7IGludGVybmFsVHlwZTogXCJ1aW50MTI4XCIsIG5hbWU6IFwiZXhhY3RBbW91bnRcIiwgdHlwZTogXCJ1aW50MTI4XCIgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogXCJzdHJ1Y3QgSVY0UXVvdGVyLlF1b3RlRXhhY3RQYXJhbXNcIixcbiAgICAgICAgICAgICAgICBuYW1lOiBcInBhcmFtc1wiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwidHVwbGVcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIG5hbWU6IFwicXVvdGVFeGFjdE91dHB1dFwiLFxuICAgICAgICBvdXRwdXRzOiBbXG4gICAgICAgICAgICB7IGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsIG5hbWU6IFwiYW1vdW50SW5cIiwgdHlwZTogXCJ1aW50MjU2XCIgfSxcbiAgICAgICAgICAgIHsgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIiwgbmFtZTogXCJnYXNFc3RpbWF0ZVwiLCB0eXBlOiBcInVpbnQyNTZcIiB9LFxuICAgICAgICBdLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6IFwibm9ucGF5YWJsZVwiLFxuICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudHM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50czogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgaW50ZXJuYWxUeXBlOiBcIkN1cnJlbmN5XCIsIG5hbWU6IFwiY3VycmVuY3kwXCIsIHR5cGU6IFwiYWRkcmVzc1wiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBpbnRlcm5hbFR5cGU6IFwiQ3VycmVuY3lcIiwgbmFtZTogXCJjdXJyZW5jeTFcIiwgdHlwZTogXCJhZGRyZXNzXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IGludGVybmFsVHlwZTogXCJ1aW50MjRcIiwgbmFtZTogXCJmZWVcIiwgdHlwZTogXCJ1aW50MjRcIiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgaW50ZXJuYWxUeXBlOiBcImludDI0XCIsIG5hbWU6IFwidGlja1NwYWNpbmdcIiwgdHlwZTogXCJpbnQyNFwiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6IFwiY29udHJhY3QgSUhvb2tzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiaG9va3NcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6IFwic3RydWN0IFBvb2xLZXlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwicG9vbEtleVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0dXBsZVwiLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7IGludGVybmFsVHlwZTogXCJib29sXCIsIG5hbWU6IFwiemVyb0Zvck9uZVwiLCB0eXBlOiBcImJvb2xcIiB9LFxuICAgICAgICAgICAgICAgICAgICB7IGludGVybmFsVHlwZTogXCJ1aW50MTI4XCIsIG5hbWU6IFwiZXhhY3RBbW91bnRcIiwgdHlwZTogXCJ1aW50MTI4XCIgfSxcbiAgICAgICAgICAgICAgICAgICAgeyBpbnRlcm5hbFR5cGU6IFwiYnl0ZXNcIiwgbmFtZTogXCJob29rRGF0YVwiLCB0eXBlOiBcImJ5dGVzXCIgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogXCJzdHJ1Y3QgSVY0UXVvdGVyLlF1b3RlRXhhY3RTaW5nbGVQYXJhbXNcIixcbiAgICAgICAgICAgICAgICBuYW1lOiBcInBhcmFtc1wiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwidHVwbGVcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIG5hbWU6IFwicXVvdGVFeGFjdE91dHB1dFNpbmdsZVwiLFxuICAgICAgICBvdXRwdXRzOiBbXG4gICAgICAgICAgICB7IGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsIG5hbWU6IFwiYW1vdW50SW5cIiwgdHlwZTogXCJ1aW50MjU2XCIgfSxcbiAgICAgICAgICAgIHsgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIiwgbmFtZTogXCJnYXNFc3RpbWF0ZVwiLCB0eXBlOiBcInVpbnQyNTZcIiB9LFxuICAgICAgICBdLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6IFwibm9ucGF5YWJsZVwiLFxuICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlucHV0czogW3sgaW50ZXJuYWxUeXBlOiBcImJ5dGVzXCIsIG5hbWU6IFwiZGF0YVwiLCB0eXBlOiBcImJ5dGVzXCIgfV0sXG4gICAgICAgIG5hbWU6IFwidW5sb2NrQ2FsbGJhY2tcIixcbiAgICAgICAgb3V0cHV0czogW3sgaW50ZXJuYWxUeXBlOiBcImJ5dGVzXCIsIG5hbWU6IFwiXCIsIHR5cGU6IFwiYnl0ZXNcIiB9XSxcbiAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiBcIm5vbnBheWFibGVcIixcbiAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgIH0sXG5dO1xuZXhwb3J0cy5JVjRSb3V0ZXJBYmlFeGFjdElucHV0ID0gW1xuICAgIHtcbiAgICAgICAgdHlwZTogXCJ0dXBsZVwiLFxuICAgICAgICBjb21wb25lbnRzOiBbXG4gICAgICAgICAgICB7IHR5cGU6IFwiYWRkcmVzc1wiLCBuYW1lOiBcImN1cnJlbmN5SW5cIiB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidHVwbGVbXVwiLFxuICAgICAgICAgICAgICAgIG5hbWU6IFwicGF0aFwiLFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudHM6IFtcbiAgICAgICAgICAgICAgICAgICAgeyB0eXBlOiBcImFkZHJlc3NcIiwgbmFtZTogXCJpbnRlcm1lZGlhdGVDdXJyZW5jeVwiIH0sXG4gICAgICAgICAgICAgICAgICAgIHsgdHlwZTogXCJ1aW50MjRcIiwgbmFtZTogXCJmZWVcIiB9LFxuICAgICAgICAgICAgICAgICAgICB7IHR5cGU6IFwiaW50MjRcIiwgbmFtZTogXCJ0aWNrU3BhY2luZ1wiIH0sXG4gICAgICAgICAgICAgICAgICAgIHsgdHlwZTogXCJhZGRyZXNzXCIsIG5hbWU6IFwiaG9va3NcIiB9LFxuICAgICAgICAgICAgICAgICAgICB7IHR5cGU6IFwiYnl0ZXNcIiwgbmFtZTogXCJob29rRGF0YVwiIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7IHR5cGU6IFwidWludDEyOFwiLCBuYW1lOiBcImFtb3VudEluXCIgfSxcbiAgICAgICAgICAgIHsgdHlwZTogXCJ1aW50MTI4XCIsIG5hbWU6IFwiYW1vdW50T3V0TWluaW11bVwiIH0sXG4gICAgICAgIF0sXG4gICAgfSxcbl07XG5leHBvcnRzLklWNFJvdXRlckFiaUV4YWN0T3V0cHV0ID0gW1xuICAgIHtcbiAgICAgICAgdHlwZTogXCJ0dXBsZVwiLFxuICAgICAgICBjb21wb25lbnRzOiBbXG4gICAgICAgICAgICB7IHR5cGU6IFwiYWRkcmVzc1wiLCBuYW1lOiBcImN1cnJlbmN5T3V0XCIgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInR1cGxlW11cIixcbiAgICAgICAgICAgICAgICBuYW1lOiBcInBhdGhcIixcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzOiBbXG4gICAgICAgICAgICAgICAgICAgIHsgdHlwZTogXCJhZGRyZXNzXCIsIG5hbWU6IFwiaW50ZXJtZWRpYXRlQ3VycmVuY3lcIiB9LFxuICAgICAgICAgICAgICAgICAgICB7IHR5cGU6IFwidWludDI0XCIsIG5hbWU6IFwiZmVlXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgeyB0eXBlOiBcImludDI0XCIsIG5hbWU6IFwidGlja1NwYWNpbmdcIiB9LFxuICAgICAgICAgICAgICAgICAgICB7IHR5cGU6IFwiYWRkcmVzc1wiLCBuYW1lOiBcImhvb2tzXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgeyB0eXBlOiBcImJ5dGVzXCIsIG5hbWU6IFwiaG9va0RhdGFcIiB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeyB0eXBlOiBcInVpbnQxMjhcIiwgbmFtZTogXCJhbW91bnRPdXRcIiB9LFxuICAgICAgICAgICAgeyB0eXBlOiBcInVpbnQxMjhcIiwgbmFtZTogXCJhbW91bnRJbk1heGltdW1cIiB9LFxuICAgICAgICBdLFxuICAgIH0sXG5dO1xuZXhwb3J0cy5WNEFjdGlvbnMgPSB7XG4gICAgU1dBUF9FWEFDVF9JTjogXCIwN1wiLFxuICAgIFNXQVBfRVhBQ1RfT1VUOiBcIjA5XCIsXG4gICAgU0VUVExFX0FMTDogXCIwY1wiLFxuICAgIFRBS0VfQUxMOiBcIjBmXCIsXG59O1xuZXhwb3J0cy5VUkNvbW1hbmRzID0ge1xuICAgIFY0X1NXQVA6IFwiMTBcIixcbiAgICBTV0VFUDogXCIwNFwiLFxuICAgIFBFUk1JVDJfUEVSTUlUOiBcIjBhXCIsXG59O1xuZXhwb3J0cy5VTklWRVJTQUxfUk9VVEVSX0FCSSA9IFtcbiAgICB7XG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudHM6IFtcbiAgICAgICAgICAgICAgICAgICAgeyBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLCBuYW1lOiBcInBlcm1pdDJcIiwgdHlwZTogXCJhZGRyZXNzXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgeyBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLCBuYW1lOiBcIndldGg5XCIsIHR5cGU6IFwiYWRkcmVzc1wiIH0sXG4gICAgICAgICAgICAgICAgICAgIHsgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIiwgbmFtZTogXCJ2MkZhY3RvcnlcIiwgdHlwZTogXCJhZGRyZXNzXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgeyBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLCBuYW1lOiBcInYzRmFjdG9yeVwiLCB0eXBlOiBcImFkZHJlc3NcIiB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYnl0ZXMzMlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJwYWlySW5pdENvZGVIYXNoXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImJ5dGVzMzJcIixcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiBcImJ5dGVzMzJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwicG9vbEluaXRDb2RlSGFzaFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJieXRlczMyXCIsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHsgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIiwgbmFtZTogXCJ2NFBvb2xNYW5hZ2VyXCIsIHR5cGU6IFwiYWRkcmVzc1wiIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcInYzTkZUUG9zaXRpb25NYW5hZ2VyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwidjRQb3NpdGlvbk1hbmFnZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiBcInN0cnVjdCBSb3V0ZXJQYXJhbWV0ZXJzXCIsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJwYXJhbXNcIixcbiAgICAgICAgICAgICAgICB0eXBlOiBcInR1cGxlXCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6IFwibm9ucGF5YWJsZVwiLFxuICAgICAgICB0eXBlOiBcImNvbnN0cnVjdG9yXCIsXG4gICAgfSxcbiAgICB7IGlucHV0czogW10sIG5hbWU6IFwiQmFsYW5jZVRvb0xvd1wiLCB0eXBlOiBcImVycm9yXCIgfSxcbiAgICB7IGlucHV0czogW10sIG5hbWU6IFwiQ29udHJhY3RMb2NrZWRcIiwgdHlwZTogXCJlcnJvclwiIH0sXG4gICAge1xuICAgICAgICBpbnB1dHM6IFt7IGludGVybmFsVHlwZTogXCJDdXJyZW5jeVwiLCBuYW1lOiBcImN1cnJlbmN5XCIsIHR5cGU6IFwiYWRkcmVzc1wiIH1dLFxuICAgICAgICBuYW1lOiBcIkRlbHRhTm90TmVnYXRpdmVcIixcbiAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgIH0sXG4gICAge1xuICAgICAgICBpbnB1dHM6IFt7IGludGVybmFsVHlwZTogXCJDdXJyZW5jeVwiLCBuYW1lOiBcImN1cnJlbmN5XCIsIHR5cGU6IFwiYWRkcmVzc1wiIH1dLFxuICAgICAgICBuYW1lOiBcIkRlbHRhTm90UG9zaXRpdmVcIixcbiAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgIH0sXG4gICAgeyBpbnB1dHM6IFtdLCBuYW1lOiBcIkVUSE5vdEFjY2VwdGVkXCIsIHR5cGU6IFwiZXJyb3JcIiB9LFxuICAgIHtcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7IGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsIG5hbWU6IFwiY29tbWFuZEluZGV4XCIsIHR5cGU6IFwidWludDI1NlwiIH0sXG4gICAgICAgICAgICB7IGludGVybmFsVHlwZTogXCJieXRlc1wiLCBuYW1lOiBcIm1lc3NhZ2VcIiwgdHlwZTogXCJieXRlc1wiIH0sXG4gICAgICAgIF0sXG4gICAgICAgIG5hbWU6IFwiRXhlY3V0aW9uRmFpbGVkXCIsXG4gICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICB9LFxuICAgIHsgaW5wdXRzOiBbXSwgbmFtZTogXCJGcm9tQWRkcmVzc0lzTm90T3duZXJcIiwgdHlwZTogXCJlcnJvclwiIH0sXG4gICAgeyBpbnB1dHM6IFtdLCBuYW1lOiBcIklucHV0TGVuZ3RoTWlzbWF0Y2hcIiwgdHlwZTogXCJlcnJvclwiIH0sXG4gICAgeyBpbnB1dHM6IFtdLCBuYW1lOiBcIkluc3VmZmljaWVudEJhbGFuY2VcIiwgdHlwZTogXCJlcnJvclwiIH0sXG4gICAgeyBpbnB1dHM6IFtdLCBuYW1lOiBcIkluc3VmZmljaWVudEVUSFwiLCB0eXBlOiBcImVycm9yXCIgfSxcbiAgICB7IGlucHV0czogW10sIG5hbWU6IFwiSW5zdWZmaWNpZW50VG9rZW5cIiwgdHlwZTogXCJlcnJvclwiIH0sXG4gICAge1xuICAgICAgICBpbnB1dHM6IFt7IGludGVybmFsVHlwZTogXCJieXRlczRcIiwgbmFtZTogXCJhY3Rpb25cIiwgdHlwZTogXCJieXRlczRcIiB9XSxcbiAgICAgICAgbmFtZTogXCJJbnZhbGlkQWN0aW9uXCIsXG4gICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICB9LFxuICAgIHsgaW5wdXRzOiBbXSwgbmFtZTogXCJJbnZhbGlkQmlwc1wiLCB0eXBlOiBcImVycm9yXCIgfSxcbiAgICB7XG4gICAgICAgIGlucHV0czogW3sgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIiwgbmFtZTogXCJjb21tYW5kVHlwZVwiLCB0eXBlOiBcInVpbnQyNTZcIiB9XSxcbiAgICAgICAgbmFtZTogXCJJbnZhbGlkQ29tbWFuZFR5cGVcIixcbiAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgIH0sXG4gICAgeyBpbnB1dHM6IFtdLCBuYW1lOiBcIkludmFsaWRFdGhTZW5kZXJcIiwgdHlwZTogXCJlcnJvclwiIH0sXG4gICAgeyBpbnB1dHM6IFtdLCBuYW1lOiBcIkludmFsaWRQYXRoXCIsIHR5cGU6IFwiZXJyb3JcIiB9LFxuICAgIHsgaW5wdXRzOiBbXSwgbmFtZTogXCJJbnZhbGlkUmVzZXJ2ZXNcIiwgdHlwZTogXCJlcnJvclwiIH0sXG4gICAgeyBpbnB1dHM6IFtdLCBuYW1lOiBcIkxlbmd0aE1pc21hdGNoXCIsIHR5cGU6IFwiZXJyb3JcIiB9LFxuICAgIHtcbiAgICAgICAgaW5wdXRzOiBbeyBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLCBuYW1lOiBcInRva2VuSWRcIiwgdHlwZTogXCJ1aW50MjU2XCIgfV0sXG4gICAgICAgIG5hbWU6IFwiTm90QXV0aG9yaXplZEZvclRva2VuXCIsXG4gICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICB9LFxuICAgIHsgaW5wdXRzOiBbXSwgbmFtZTogXCJOb3RQb29sTWFuYWdlclwiLCB0eXBlOiBcImVycm9yXCIgfSxcbiAgICB7IGlucHV0czogW10sIG5hbWU6IFwiT25seU1pbnRBbGxvd2VkXCIsIHR5cGU6IFwiZXJyb3JcIiB9LFxuICAgIHsgaW5wdXRzOiBbXSwgbmFtZTogXCJTbGljZU91dE9mQm91bmRzXCIsIHR5cGU6IFwiZXJyb3JcIiB9LFxuICAgIHsgaW5wdXRzOiBbXSwgbmFtZTogXCJUcmFuc2FjdGlvbkRlYWRsaW5lUGFzc2VkXCIsIHR5cGU6IFwiZXJyb3JcIiB9LFxuICAgIHsgaW5wdXRzOiBbXSwgbmFtZTogXCJVbnNhZmVDYXN0XCIsIHR5cGU6IFwiZXJyb3JcIiB9LFxuICAgIHtcbiAgICAgICAgaW5wdXRzOiBbeyBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLCBuYW1lOiBcImFjdGlvblwiLCB0eXBlOiBcInVpbnQyNTZcIiB9XSxcbiAgICAgICAgbmFtZTogXCJVbnN1cHBvcnRlZEFjdGlvblwiLFxuICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgfSxcbiAgICB7IGlucHV0czogW10sIG5hbWU6IFwiVjJJbnZhbGlkUGF0aFwiLCB0eXBlOiBcImVycm9yXCIgfSxcbiAgICB7IGlucHV0czogW10sIG5hbWU6IFwiVjJUb29MaXR0bGVSZWNlaXZlZFwiLCB0eXBlOiBcImVycm9yXCIgfSxcbiAgICB7IGlucHV0czogW10sIG5hbWU6IFwiVjJUb29NdWNoUmVxdWVzdGVkXCIsIHR5cGU6IFwiZXJyb3JcIiB9LFxuICAgIHsgaW5wdXRzOiBbXSwgbmFtZTogXCJWM0ludmFsaWRBbW91bnRPdXRcIiwgdHlwZTogXCJlcnJvclwiIH0sXG4gICAgeyBpbnB1dHM6IFtdLCBuYW1lOiBcIlYzSW52YWxpZENhbGxlclwiLCB0eXBlOiBcImVycm9yXCIgfSxcbiAgICB7IGlucHV0czogW10sIG5hbWU6IFwiVjNJbnZhbGlkU3dhcFwiLCB0eXBlOiBcImVycm9yXCIgfSxcbiAgICB7IGlucHV0czogW10sIG5hbWU6IFwiVjNUb29MaXR0bGVSZWNlaXZlZFwiLCB0eXBlOiBcImVycm9yXCIgfSxcbiAgICB7IGlucHV0czogW10sIG5hbWU6IFwiVjNUb29NdWNoUmVxdWVzdGVkXCIsIHR5cGU6IFwiZXJyb3JcIiB9LFxuICAgIHtcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgICAgICAgICBuYW1lOiBcIm1pbkFtb3VudE91dFJlY2VpdmVkXCIsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeyBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLCBuYW1lOiBcImFtb3VudFJlY2VpdmVkXCIsIHR5cGU6IFwidWludDI1NlwiIH0sXG4gICAgICAgIF0sXG4gICAgICAgIG5hbWU6IFwiVjRUb29MaXR0bGVSZWNlaXZlZFwiLFxuICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJtYXhBbW91bnRJblJlcXVlc3RlZFwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHsgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIiwgbmFtZTogXCJhbW91bnRSZXF1ZXN0ZWRcIiwgdHlwZTogXCJ1aW50MjU2XCIgfSxcbiAgICAgICAgXSxcbiAgICAgICAgbmFtZTogXCJWNFRvb011Y2hSZXF1ZXN0ZWRcIixcbiAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgIH0sXG4gICAge1xuICAgICAgICBpbnB1dHM6IFtdLFxuICAgICAgICBuYW1lOiBcIlYzX1BPU0lUSU9OX01BTkFHRVJcIixcbiAgICAgICAgb3V0cHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogXCJjb250cmFjdCBJTm9uZnVuZ2libGVQb3NpdGlvbk1hbmFnZXJcIixcbiAgICAgICAgICAgICAgICBuYW1lOiBcIlwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIixcbiAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgIH0sXG4gICAge1xuICAgICAgICBpbnB1dHM6IFtdLFxuICAgICAgICBuYW1lOiBcIlY0X1BPU0lUSU9OX01BTkFHRVJcIixcbiAgICAgICAgb3V0cHV0czogW3sgaW50ZXJuYWxUeXBlOiBcImNvbnRyYWN0IElQb3NpdGlvbk1hbmFnZXJcIiwgbmFtZTogXCJcIiwgdHlwZTogXCJhZGRyZXNzXCIgfV0sXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICB9LFxuICAgIHtcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7IGludGVybmFsVHlwZTogXCJieXRlc1wiLCBuYW1lOiBcImNvbW1hbmRzXCIsIHR5cGU6IFwiYnl0ZXNcIiB9LFxuICAgICAgICAgICAgeyBpbnRlcm5hbFR5cGU6IFwiYnl0ZXNbXVwiLCBuYW1lOiBcImlucHV0c1wiLCB0eXBlOiBcImJ5dGVzW11cIiB9LFxuICAgICAgICBdLFxuICAgICAgICBuYW1lOiBcImV4ZWN1dGVcIixcbiAgICAgICAgb3V0cHV0czogW10sXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogXCJwYXlhYmxlXCIsXG4gICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICB9LFxuICAgIHtcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7IGludGVybmFsVHlwZTogXCJieXRlc1wiLCBuYW1lOiBcImNvbW1hbmRzXCIsIHR5cGU6IFwiYnl0ZXNcIiB9LFxuICAgICAgICAgICAgeyBpbnRlcm5hbFR5cGU6IFwiYnl0ZXNbXVwiLCBuYW1lOiBcImlucHV0c1wiLCB0eXBlOiBcImJ5dGVzW11cIiB9LFxuICAgICAgICAgICAgeyBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLCBuYW1lOiBcImRlYWRsaW5lXCIsIHR5cGU6IFwidWludDI1NlwiIH0sXG4gICAgICAgIF0sXG4gICAgICAgIG5hbWU6IFwiZXhlY3V0ZVwiLFxuICAgICAgICBvdXRwdXRzOiBbXSxcbiAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiBcInBheWFibGVcIixcbiAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgIH0sXG4gICAge1xuICAgICAgICBpbnB1dHM6IFtdLFxuICAgICAgICBuYW1lOiBcIm1zZ1NlbmRlclwiLFxuICAgICAgICBvdXRwdXRzOiBbeyBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLCBuYW1lOiBcIlwiLCB0eXBlOiBcImFkZHJlc3NcIiB9XSxcbiAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIixcbiAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgIH0sXG4gICAge1xuICAgICAgICBpbnB1dHM6IFtdLFxuICAgICAgICBuYW1lOiBcInBvb2xNYW5hZ2VyXCIsXG4gICAgICAgIG91dHB1dHM6IFt7IGludGVybmFsVHlwZTogXCJjb250cmFjdCBJUG9vbE1hbmFnZXJcIiwgbmFtZTogXCJcIiwgdHlwZTogXCJhZGRyZXNzXCIgfV0sXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICB9LFxuICAgIHtcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7IGludGVybmFsVHlwZTogXCJpbnQyNTZcIiwgbmFtZTogXCJhbW91bnQwRGVsdGFcIiwgdHlwZTogXCJpbnQyNTZcIiB9LFxuICAgICAgICAgICAgeyBpbnRlcm5hbFR5cGU6IFwiaW50MjU2XCIsIG5hbWU6IFwiYW1vdW50MURlbHRhXCIsIHR5cGU6IFwiaW50MjU2XCIgfSxcbiAgICAgICAgICAgIHsgaW50ZXJuYWxUeXBlOiBcImJ5dGVzXCIsIG5hbWU6IFwiZGF0YVwiLCB0eXBlOiBcImJ5dGVzXCIgfSxcbiAgICAgICAgXSxcbiAgICAgICAgbmFtZTogXCJ1bmlzd2FwVjNTd2FwQ2FsbGJhY2tcIixcbiAgICAgICAgb3V0cHV0czogW10sXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogXCJub25wYXlhYmxlXCIsXG4gICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICB9LFxuICAgIHtcbiAgICAgICAgaW5wdXRzOiBbeyBpbnRlcm5hbFR5cGU6IFwiYnl0ZXNcIiwgbmFtZTogXCJkYXRhXCIsIHR5cGU6IFwiYnl0ZXNcIiB9XSxcbiAgICAgICAgbmFtZTogXCJ1bmxvY2tDYWxsYmFja1wiLFxuICAgICAgICBvdXRwdXRzOiBbeyBpbnRlcm5hbFR5cGU6IFwiYnl0ZXNcIiwgbmFtZTogXCJcIiwgdHlwZTogXCJieXRlc1wiIH1dLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6IFwibm9ucGF5YWJsZVwiLFxuICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgfSxcbiAgICB7IHN0YXRlTXV0YWJpbGl0eTogXCJwYXlhYmxlXCIsIHR5cGU6IFwicmVjZWl2ZVwiIH0sXG5dO1xuZXhwb3J0cy5QRVJNSVQyX0FCSSA9IFtcbiAgICB7XG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAgeyBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLCBuYW1lOiBcIlwiLCB0eXBlOiBcImFkZHJlc3NcIiB9LFxuICAgICAgICAgICAgeyBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLCBuYW1lOiBcIlwiLCB0eXBlOiBcImFkZHJlc3NcIiB9LFxuICAgICAgICAgICAgeyBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLCBuYW1lOiBcIlwiLCB0eXBlOiBcImFkZHJlc3NcIiB9LFxuICAgICAgICBdLFxuICAgICAgICBuYW1lOiBcImFsbG93YW5jZVwiLFxuICAgICAgICBvdXRwdXRzOiBbXG4gICAgICAgICAgICB7IGludGVybmFsVHlwZTogXCJ1aW50MTYwXCIsIG5hbWU6IFwiYW1vdW50XCIsIHR5cGU6IFwidWludDE2MFwiIH0sXG4gICAgICAgICAgICB7IGludGVybmFsVHlwZTogXCJ1aW50NDhcIiwgbmFtZTogXCJleHBpcmF0aW9uXCIsIHR5cGU6IFwidWludDQ4XCIgfSxcbiAgICAgICAgICAgIHsgaW50ZXJuYWxUeXBlOiBcInVpbnQ0OFwiLCBuYW1lOiBcIm5vbmNlXCIsIHR5cGU6IFwidWludDQ4XCIgfSxcbiAgICAgICAgXSxcbiAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIixcbiAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgIH0sXG5dO1xuZXhwb3J0cy5QRVJNSVRfREVUQUlMUyA9IFtcbiAgICB7IG5hbWU6IFwidG9rZW5cIiwgdHlwZTogXCJhZGRyZXNzXCIgfSxcbiAgICB7IG5hbWU6IFwiYW1vdW50XCIsIHR5cGU6IFwidWludDE2MFwiIH0sXG4gICAgeyBuYW1lOiBcImV4cGlyYXRpb25cIiwgdHlwZTogXCJ1aW50NDhcIiB9LFxuICAgIHsgbmFtZTogXCJub25jZVwiLCB0eXBlOiBcInVpbnQ0OFwiIH0sXG5dO1xuZXhwb3J0cy5QRVJNSVRfVFlQRVMgPSB7XG4gICAgUGVybWl0U2luZ2xlOiBbXG4gICAgICAgIHsgbmFtZTogXCJkZXRhaWxzXCIsIHR5cGU6IFwiUGVybWl0RGV0YWlsc1wiIH0sXG4gICAgICAgIHsgbmFtZTogXCJzcGVuZGVyXCIsIHR5cGU6IFwiYWRkcmVzc1wiIH0sXG4gICAgICAgIHsgbmFtZTogXCJzaWdEZWFkbGluZVwiLCB0eXBlOiBcInVpbnQyNTZcIiB9LFxuICAgIF0sXG4gICAgUGVybWl0RGV0YWlsczogZXhwb3J0cy5QRVJNSVRfREVUQUlMUyxcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/flaunch/constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/flaunch/flaunchActionProvider.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/flaunch/flaunchActionProvider.js ***!
  \************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Flaunch Action Provider\n *\n * This file contains the implementation of the FlaunchActionProvider,\n * which provides actions for flaunch operations.\n *\n * @module flaunch\n */\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.flaunchActionProvider = exports.FlaunchActionProvider = void 0;\nconst zod_1 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/lib/index.js\");\nconst actionProvider_1 = __webpack_require__(/*! ../actionProvider */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/actionProvider.js\");\nconst network_1 = __webpack_require__(/*! ../../network */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/network/index.js\");\nconst actionDecorator_1 = __webpack_require__(/*! ../actionDecorator */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/actionDecorator.js\");\nconst wallet_providers_1 = __webpack_require__(/*! ../../wallet-providers */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/wallet-providers/index.js\");\nconst viem_1 = __webpack_require__(/*! viem */ \"(rsc)/./node_modules/viem/_cjs/index.js\");\nconst chains_1 = __webpack_require__(/*! viem/chains */ \"(rsc)/./node_modules/viem/_cjs/chains/index.js\");\nconst schemas_1 = __webpack_require__(/*! ./schemas */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/flaunch/schemas.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/flaunch/utils.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/flaunch/constants.js\");\nconst SUPPORTED_NETWORKS = [\"base-mainnet\", \"base-sepolia\"];\n/**\n * FlaunchActionProvider provides actions for flaunch operations.\n *\n * @description\n * This provider is designed to work with EvmWalletProvider for blockchain interactions.\n * It supports all evm networks.\n */\nclass FlaunchActionProvider extends actionProvider_1.ActionProvider {\n    /**\n     * Constructor for the FlaunchActionProvider.\n     *\n     * @param config - The configuration options for the FlaunchActionProvider.\n     */\n    constructor(config = {}) {\n        super(\"flaunch\", []);\n        const pinataJwt = config.pinataJwt || process.env.PINATA_JWT;\n        if (!pinataJwt) {\n            throw new Error(\"PINATA_JWT is not configured.\");\n        }\n        this.pinataJwt = pinataJwt;\n    }\n    /**\n     * Example action implementation.\n     * Replace or modify this with your actual action.\n     *\n     * @description\n     * This is a template action that demonstrates the basic structure.\n     * Replace it with your actual implementation.\n     *\n     * @param walletProvider - The wallet provider instance for blockchain interactions\n     * @param args - Arguments defined by FlaunchSchema\n     * @returns A promise that resolves to a string describing the action result\n     */\n    async flaunch(walletProvider, args) {\n        try {\n            const network = walletProvider.getNetwork();\n            const networkId = network.networkId;\n            const chainId = network.chainId;\n            if (!chainId || !networkId) {\n                throw new Error(\"Chain ID is not set.\");\n            }\n            // upload image & token uri to ipfs\n            const tokenUri = await (0, utils_1.generateTokenUri)(args.name, {\n                pinataConfig: { jwt: this.pinataJwt },\n                metadata: {\n                    imageUrl: args.imageUrl,\n                    description: args.description,\n                    websiteUrl: args.websiteUrl,\n                    discordUrl: args.discordUrl,\n                    twitterUrl: args.twitterUrl,\n                    telegramUrl: args.telegramUrl,\n                },\n            });\n            const data = (0, viem_1.encodeFunctionData)({\n                abi: constants_1.FAST_FLAUNCH_ZAP_ABI,\n                functionName: \"flaunch\",\n                args: [\n                    {\n                        name: args.name,\n                        symbol: args.symbol,\n                        tokenUri,\n                        creator: walletProvider.getAddress(),\n                    },\n                ],\n            });\n            const hash = await walletProvider.sendTransaction({\n                to: constants_1.FastFlaunchZapAddress[chainId],\n                data,\n            });\n            const receipt = await walletProvider.waitForTransactionReceipt(hash);\n            const filteredPoolCreatedEvent = receipt.logs\n                .map(log => {\n                try {\n                    if (log.address.toLowerCase() !== constants_1.FlaunchPositionManagerAddress[chainId].toLowerCase()) {\n                        return null;\n                    }\n                    const event = (0, viem_1.decodeEventLog)({\n                        abi: constants_1.POSITION_MANAGER_ABI,\n                        data: log.data,\n                        topics: log.topics,\n                    });\n                    return event.eventName === \"PoolCreated\" ? event.args : null;\n                }\n                catch {\n                    return null;\n                }\n            })\n                .filter((event) => event !== null)[0];\n            const memecoinAddress = filteredPoolCreatedEvent._memecoin;\n            const chainSlug = Number(chainId) === chains_1.base.id ? \"base\" : \"base-sepolia\";\n            return `Flaunched\\n ${JSON.stringify({\n                coinSymbol: `$${args.symbol}`,\n                coinName: args.name,\n                coinAddress: memecoinAddress,\n                flaunchCoinUrl: `https://flaunch.gg/${chainSlug}/coin/${memecoinAddress}`,\n                transactionHash: hash,\n                transactionUrl: `${network_1.NETWORK_ID_TO_VIEM_CHAIN[networkId].blockExplorers?.default.url}/tx/${hash}`,\n            })}`;\n        }\n        catch (error) {\n            return `Error launching coin: ${error}`;\n        }\n    }\n    /**\n     * Buys a flaunch coin using ETH input.\n     *\n     * @param walletProvider - The wallet provider instance for blockchain interactions\n     * @param args - Arguments defined by BuyCoinSchema\n     * @returns A promise that resolves to a string describing the transaction result\n     */\n    async buyCoinWithETHInput(walletProvider, args) {\n        return this._buyFlaunchCoin(walletProvider, args.coinAddress, \"EXACT_IN\", { amountIn: args.amountIn }, args.slippagePercent);\n    }\n    /**\n     * Buys a flaunch coin using Coin input.\n     *\n     * @param walletProvider - The wallet provider instance for blockchain interactions\n     * @param args - Arguments defined by BuyCoinSchema\n     * @returns A promise that resolves to a string describing the transaction result\n     */\n    async buyCoinWithCoinInput(walletProvider, args) {\n        return this._buyFlaunchCoin(walletProvider, args.coinAddress, \"EXACT_OUT\", { amountOut: args.amountOut }, args.slippagePercent);\n    }\n    /**\n     * Sells a flaunch coin into ETH.\n     *\n     * @param walletProvider - The wallet provider instance for blockchain interactions\n     * @param args - Arguments defined by SellCoinSchema\n     * @returns A promise that resolves to a string describing the transaction result\n     */\n    async sellCoin(walletProvider, args) {\n        const network = walletProvider.getNetwork();\n        const chainId = network.chainId;\n        const networkId = network.networkId;\n        if (!chainId || !networkId) {\n            throw new Error(\"Chain ID is not set.\");\n        }\n        try {\n            const amountIn = (0, viem_1.parseEther)(args.amountIn);\n            // fetch permit2 allowance\n            const [allowance, nonce] = await walletProvider.readContract({\n                address: constants_1.Permit2Address[chainId],\n                abi: constants_1.PERMIT2_ABI,\n                functionName: \"allowance\",\n                args: [\n                    walletProvider.getAddress(),\n                    args.coinAddress,\n                    constants_1.UniversalRouterAddress[chainId],\n                ],\n            });\n            let signature;\n            let permitSingle;\n            // approve\n            if (allowance < amountIn) {\n                // 10 years in seconds\n                const defaultDeadline = BigInt(Math.floor(Date.now() / 1000) + 60 * 60 * 24 * 365 * 10);\n                const domain = {\n                    name: \"Permit2\",\n                    chainId: Number(chainId),\n                    verifyingContract: constants_1.Permit2Address[chainId],\n                };\n                const message = {\n                    details: {\n                        token: args.coinAddress,\n                        amount: viem_1.maxUint160,\n                        expiration: Number(defaultDeadline),\n                        nonce,\n                    },\n                    spender: constants_1.UniversalRouterAddress[chainId],\n                    sigDeadline: defaultDeadline,\n                };\n                const typedData = {\n                    primaryType: \"PermitSingle\",\n                    domain,\n                    types: constants_1.PERMIT_TYPES,\n                    message,\n                };\n                signature = await walletProvider.signTypedData(typedData);\n                permitSingle = message;\n            }\n            const viemPublicClient = (0, viem_1.createPublicClient)({\n                chain: network_1.NETWORK_ID_TO_VIEM_CHAIN[networkId],\n                transport: (0, viem_1.http)(),\n            });\n            const quoteResult = await viemPublicClient.simulateContract({\n                address: constants_1.QuoterAddress[chainId],\n                abi: constants_1.QUOTER_ABI,\n                functionName: \"quoteExactInput\",\n                args: [\n                    {\n                        exactAmount: amountIn,\n                        exactCurrency: args.coinAddress,\n                        path: [\n                            {\n                                fee: 0,\n                                tickSpacing: 60,\n                                hooks: constants_1.FlaunchPositionManagerAddress[chainId],\n                                hookData: \"0x\",\n                                intermediateCurrency: constants_1.FLETHAddress[chainId],\n                            },\n                            {\n                                fee: 0,\n                                tickSpacing: 60,\n                                hookData: \"0x\",\n                                hooks: constants_1.FLETHHooksAddress[chainId],\n                                intermediateCurrency: viem_1.zeroAddress,\n                            },\n                        ],\n                    },\n                ],\n            });\n            const ethOutMin = (0, utils_1.getAmountWithSlippage)(quoteResult.result[0], // amountOut\n            (args.slippagePercent / 100).toFixed(18).toString(), \"EXACT_IN\");\n            const { commands, inputs } = (0, utils_1.memecoinToEthWithPermit2)({\n                chainId: Number(chainId),\n                memecoin: args.coinAddress,\n                amountIn,\n                ethOutMin,\n                permitSingle,\n                signature,\n                referrer: viem_1.zeroAddress,\n            });\n            const data = (0, viem_1.encodeFunctionData)({\n                abi: constants_1.UNIVERSAL_ROUTER_ABI,\n                functionName: \"execute\",\n                args: [commands, inputs],\n            });\n            const hash = await walletProvider.sendTransaction({\n                to: constants_1.UniversalRouterAddress[chainId],\n                data,\n            });\n            const receipt = await walletProvider.waitForTransactionReceipt(hash);\n            const swapAmounts = (0, utils_1.getSwapAmountsFromReceipt)({\n                receipt,\n                coinAddress: args.coinAddress,\n                chainId: Number(chainId),\n            });\n            const coinSymbol = await walletProvider.readContract({\n                address: args.coinAddress,\n                abi: constants_1.ERC20_ABI,\n                functionName: \"symbol\",\n            });\n            return `Sold ${(0, viem_1.formatEther)(swapAmounts.coinsSold)} $${coinSymbol} for ${(0, viem_1.formatEther)(swapAmounts.ethBought)} ETH\\n\n        Tx hash: [${hash}](${network_1.NETWORK_ID_TO_VIEM_CHAIN[networkId].blockExplorers?.default.url}/tx/${hash})`;\n        }\n        catch (error) {\n            return `Error selling coin: ${error}`;\n        }\n    }\n    /**\n     * Checks if this provider supports the given network.\n     *\n     * @param network - The network to check support for\n     * @returns True if the network is supported\n     */\n    supportsNetwork(network) {\n        // all protocol networks\n        return network.protocolFamily === \"evm\" && SUPPORTED_NETWORKS.includes(network.networkId);\n    }\n    /**\n     * Handles the process of buying a flaunch coin with ETH.\n     *\n     * @param walletProvider - The wallet provider instance\n     * @param coinAddress - The address of the flaunch coin\n     * @param swapType - The type of swap (EXACT_IN or EXACT_OUT)\n     * @param swapParams - Parameters specific to the swap type\n     * @param swapParams.amountIn - The amount of ETH to spend (for EXACT_IN)\n     * @param swapParams.amountOut - The amount of coins to buy (for EXACT_OUT)\n     * @param slippagePercent - The slippage percentage\n     * @returns A promise that resolves to a string describing the transaction result\n     */\n    async _buyFlaunchCoin(walletProvider, coinAddress, swapType, swapParams, slippagePercent) {\n        const network = walletProvider.getNetwork();\n        const chainId = network.chainId;\n        const networkId = network.networkId;\n        if (!chainId || !networkId) {\n            throw new Error(\"Chain ID is not set.\");\n        }\n        try {\n            const viemPublicClient = (0, viem_1.createPublicClient)({\n                chain: network_1.NETWORK_ID_TO_VIEM_CHAIN[networkId],\n                transport: (0, viem_1.http)(),\n            });\n            let amountIn;\n            let amountOutMin;\n            let amountOut;\n            let amountInMax;\n            if (swapType === \"EXACT_IN\") {\n                amountIn = (0, viem_1.parseEther)(swapParams.amountIn);\n                const quoteResult = await viemPublicClient.simulateContract({\n                    address: constants_1.QuoterAddress[chainId],\n                    abi: constants_1.QUOTER_ABI,\n                    functionName: \"quoteExactInput\",\n                    args: [\n                        {\n                            exactAmount: amountIn,\n                            exactCurrency: viem_1.zeroAddress, // ETH\n                            path: [\n                                {\n                                    fee: 0,\n                                    tickSpacing: 60,\n                                    hookData: \"0x\",\n                                    hooks: constants_1.FLETHHooksAddress[chainId],\n                                    intermediateCurrency: constants_1.FLETHAddress[chainId],\n                                },\n                                {\n                                    fee: 0,\n                                    tickSpacing: 60,\n                                    hooks: constants_1.FlaunchPositionManagerAddress[chainId],\n                                    hookData: \"0x\",\n                                    intermediateCurrency: coinAddress,\n                                },\n                            ],\n                        },\n                    ],\n                });\n                amountOutMin = (0, utils_1.getAmountWithSlippage)(quoteResult.result[0], // amountOut\n                (slippagePercent / 100).toFixed(18).toString(), swapType);\n            }\n            else {\n                // EXACT_OUT\n                amountOut = (0, viem_1.parseEther)(swapParams.amountOut);\n                const quoteResult = await viemPublicClient.simulateContract({\n                    address: constants_1.QuoterAddress[chainId],\n                    abi: constants_1.QUOTER_ABI,\n                    functionName: \"quoteExactOutput\",\n                    args: [\n                        {\n                            path: [\n                                {\n                                    intermediateCurrency: viem_1.zeroAddress,\n                                    fee: 0,\n                                    tickSpacing: 60,\n                                    hookData: \"0x\",\n                                    hooks: constants_1.FLETHHooksAddress[chainId],\n                                },\n                                {\n                                    intermediateCurrency: constants_1.FLETHAddress[chainId],\n                                    fee: 0,\n                                    tickSpacing: 60,\n                                    hooks: constants_1.FlaunchPositionManagerAddress[chainId],\n                                    hookData: \"0x\",\n                                },\n                            ],\n                            exactCurrency: coinAddress,\n                            exactAmount: amountOut,\n                        },\n                    ],\n                });\n                amountInMax = (0, utils_1.getAmountWithSlippage)(quoteResult.result[0], // amountIn\n                (slippagePercent / 100).toFixed(18).toString(), swapType);\n            }\n            const { commands, inputs } = (0, utils_1.ethToMemecoin)({\n                sender: walletProvider.getAddress(),\n                memecoin: coinAddress,\n                chainId: Number(chainId),\n                referrer: viem_1.zeroAddress,\n                swapType,\n                amountIn,\n                amountOutMin,\n                amountOut,\n                amountInMax,\n            });\n            const data = (0, viem_1.encodeFunctionData)({\n                abi: constants_1.UNIVERSAL_ROUTER_ABI,\n                functionName: \"execute\",\n                args: [commands, inputs],\n            });\n            const hash = await walletProvider.sendTransaction({\n                to: constants_1.UniversalRouterAddress[chainId],\n                data,\n                value: swapType === \"EXACT_IN\" ? amountIn : amountInMax,\n            });\n            const receipt = await walletProvider.waitForTransactionReceipt(hash);\n            const swapAmounts = (0, utils_1.getSwapAmountsFromReceipt)({\n                receipt,\n                coinAddress: coinAddress,\n                chainId: Number(chainId),\n            });\n            const coinSymbol = await walletProvider.readContract({\n                address: coinAddress,\n                abi: constants_1.ERC20_ABI,\n                functionName: \"symbol\",\n            });\n            return `Bought ${(0, viem_1.formatEther)(swapAmounts.coinsBought)} $${coinSymbol} for ${(0, viem_1.formatEther)(swapAmounts.ethSold)} ETH\\n\n        Tx hash: [${hash}](${network_1.NETWORK_ID_TO_VIEM_CHAIN[networkId].blockExplorers?.default.url}/tx/${hash})`;\n        }\n        catch (error) {\n            return `Error buying coin: ${error}`;\n        }\n    }\n}\nexports.FlaunchActionProvider = FlaunchActionProvider;\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"flaunch\",\n        description: `\nThis tool allows launching a new memecoin using the flaunch protocol.\n\nIt takes:\n- name: The name of the token\n- symbol: The symbol of the token\n- imageUrl: URL to the token image\n- description: Description of the token\n\n- websiteUrl: (optional) URL to the token website\n- discordUrl: (optional) URL to the token Discord\n- twitterUrl: (optional) URL to the token Twitter\n- telegramUrl: (optional) URL to the token Telegram\n\nNote:\n- If the optional fields are not provided, don't include them in the call.\n    `,\n        schema: schemas_1.FlaunchSchema,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [wallet_providers_1.EvmWalletProvider, void 0]),\n    __metadata(\"design:returntype\", Promise)\n], FlaunchActionProvider.prototype, \"flaunch\", null);\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"buyCoinWithETHInput\",\n        description: `\nThis tool allows buying a flaunch coin using ETH, when the user has specified the ETH amount to spend.\n\nIt takes:\n- coinAddress: The address of the flaunch coin to buy\n- amountIn: The quantity of ETH to spend on the flaunch coin, in whole units\n  Examples:\n  - 0.001 ETH\n  - 0.01 ETH\n  - 1 ETH\n- slippagePercent: (optional) The slippage percentage. Default to 5%\n    `,\n        schema: schemas_1.BuyCoinWithETHInputSchema,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [wallet_providers_1.EvmWalletProvider, void 0]),\n    __metadata(\"design:returntype\", Promise)\n], FlaunchActionProvider.prototype, \"buyCoinWithETHInput\", null);\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"buyCoinWithCoinInput\",\n        description: `\nThis tool allows buying a flaunch coin using ETH, when the user has specified the Coin amount to buy.\n\nIt takes:\n- coinAddress: The address of the flaunch coin to buy\n- amountOut: The quantity of the flaunch coin to buy, in whole units\n  Examples:\n  - 1000 coins\n  - 1_000_000 coins\n- slippagePercent: (optional) The slippage percentage. Default to 5%\n    `,\n        schema: schemas_1.BuyCoinWithCoinInputSchema,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [wallet_providers_1.EvmWalletProvider, void 0]),\n    __metadata(\"design:returntype\", Promise)\n], FlaunchActionProvider.prototype, \"buyCoinWithCoinInput\", null);\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"sellCoin\",\n        description: `\nThis tool allows selling a flaunch coin into ETH, when the user has specified the Coin amount to sell.\n\nIt takes:\n- coinAddress: The address of the flaunch coin to sell\n- amountIn: The quantity of the flaunch coin to sell, in whole units\n  Examples:\n  - 1000 coins\n  - 1_000_000 coins\n- slippagePercent: (optional) The slippage percentage. Default to 5%\n    `,\n        schema: schemas_1.SellCoinSchema,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [wallet_providers_1.EvmWalletProvider, void 0]),\n    __metadata(\"design:returntype\", Promise)\n], FlaunchActionProvider.prototype, \"sellCoin\", null);\n/**\n * Factory function to create a new FlaunchActionProvider instance.\n *\n * @param config - Configuration options for the FlaunchActionProvider\n * @returns A new FlaunchActionProvider instance\n */\nconst flaunchActionProvider = (config) => new FlaunchActionProvider(config);\nexports.flaunchActionProvider = flaunchActionProvider;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9mbGF1bmNoL2ZsYXVuY2hBY3Rpb25Qcm92aWRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsUUFBUTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDZCQUE2QixHQUFHLDZCQUE2QjtBQUM3RCxjQUFjLG1CQUFPLENBQUMsa0RBQUs7QUFDM0IseUJBQXlCLG1CQUFPLENBQUMsMEdBQW1CO0FBQ3BELGtCQUFrQixtQkFBTyxDQUFDLG9GQUFlO0FBQ3pDLDBCQUEwQixtQkFBTyxDQUFDLDRHQUFvQjtBQUN0RCwyQkFBMkIsbUJBQU8sQ0FBQyxzR0FBd0I7QUFDM0QsZUFBZSxtQkFBTyxDQUFDLHFEQUFNO0FBQzdCLGlCQUFpQixtQkFBTyxDQUFDLG1FQUFhO0FBQ3RDLGtCQUFrQixtQkFBTyxDQUFDLG1HQUFXO0FBQ3JDLGdCQUFnQixtQkFBTyxDQUFDLCtGQUFTO0FBQ2pDLG9CQUFvQixtQkFBTyxDQUFDLHVHQUFhO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxxQkFBcUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQyxnQ0FBZ0MsWUFBWTtBQUM1QztBQUNBO0FBQ0Esc0RBQXNELFVBQVUsUUFBUSxnQkFBZ0I7QUFDeEY7QUFDQSxtQ0FBbUMsMEVBQTBFLE1BQU0sS0FBSztBQUN4SCxhQUFhLEVBQUU7QUFDZjtBQUNBO0FBQ0EsNENBQTRDLE1BQU07QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRkFBb0YseUJBQXlCO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRiwyQkFBMkI7QUFDaEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsMkJBQTJCLGdEQUFnRCxHQUFHLFlBQVksTUFBTSxnREFBZ0Q7QUFDaEosb0JBQW9CLEtBQUssSUFBSSwwRUFBMEUsTUFBTSxLQUFLO0FBQ2xIO0FBQ0E7QUFDQSwwQ0FBMEMsTUFBTTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLDZCQUE2QixrREFBa0QsR0FBRyxZQUFZLE1BQU0sOENBQThDO0FBQ2xKLG9CQUFvQixLQUFLLElBQUksMEVBQTBFLE1BQU0sS0FBSztBQUNsSDtBQUNBO0FBQ0EseUNBQXlDLE1BQU07QUFDL0M7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXJ2aXZhbC1mdW4vLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9mbGF1bmNoL2ZsYXVuY2hBY3Rpb25Qcm92aWRlci5qcz9iZDI4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBGbGF1bmNoIEFjdGlvbiBQcm92aWRlclxuICpcbiAqIFRoaXMgZmlsZSBjb250YWlucyB0aGUgaW1wbGVtZW50YXRpb24gb2YgdGhlIEZsYXVuY2hBY3Rpb25Qcm92aWRlcixcbiAqIHdoaWNoIHByb3ZpZGVzIGFjdGlvbnMgZm9yIGZsYXVuY2ggb3BlcmF0aW9ucy5cbiAqXG4gKiBAbW9kdWxlIGZsYXVuY2hcbiAqL1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZmxhdW5jaEFjdGlvblByb3ZpZGVyID0gZXhwb3J0cy5GbGF1bmNoQWN0aW9uUHJvdmlkZXIgPSB2b2lkIDA7XG5jb25zdCB6b2RfMSA9IHJlcXVpcmUoXCJ6b2RcIik7XG5jb25zdCBhY3Rpb25Qcm92aWRlcl8xID0gcmVxdWlyZShcIi4uL2FjdGlvblByb3ZpZGVyXCIpO1xuY29uc3QgbmV0d29ya18xID0gcmVxdWlyZShcIi4uLy4uL25ldHdvcmtcIik7XG5jb25zdCBhY3Rpb25EZWNvcmF0b3JfMSA9IHJlcXVpcmUoXCIuLi9hY3Rpb25EZWNvcmF0b3JcIik7XG5jb25zdCB3YWxsZXRfcHJvdmlkZXJzXzEgPSByZXF1aXJlKFwiLi4vLi4vd2FsbGV0LXByb3ZpZGVyc1wiKTtcbmNvbnN0IHZpZW1fMSA9IHJlcXVpcmUoXCJ2aWVtXCIpO1xuY29uc3QgY2hhaW5zXzEgPSByZXF1aXJlKFwidmllbS9jaGFpbnNcIik7XG5jb25zdCBzY2hlbWFzXzEgPSByZXF1aXJlKFwiLi9zY2hlbWFzXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCBTVVBQT1JURURfTkVUV09SS1MgPSBbXCJiYXNlLW1haW5uZXRcIiwgXCJiYXNlLXNlcG9saWFcIl07XG4vKipcbiAqIEZsYXVuY2hBY3Rpb25Qcm92aWRlciBwcm92aWRlcyBhY3Rpb25zIGZvciBmbGF1bmNoIG9wZXJhdGlvbnMuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBUaGlzIHByb3ZpZGVyIGlzIGRlc2lnbmVkIHRvIHdvcmsgd2l0aCBFdm1XYWxsZXRQcm92aWRlciBmb3IgYmxvY2tjaGFpbiBpbnRlcmFjdGlvbnMuXG4gKiBJdCBzdXBwb3J0cyBhbGwgZXZtIG5ldHdvcmtzLlxuICovXG5jbGFzcyBGbGF1bmNoQWN0aW9uUHJvdmlkZXIgZXh0ZW5kcyBhY3Rpb25Qcm92aWRlcl8xLkFjdGlvblByb3ZpZGVyIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgdGhlIEZsYXVuY2hBY3Rpb25Qcm92aWRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb25maWcgLSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgRmxhdW5jaEFjdGlvblByb3ZpZGVyLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKFwiZmxhdW5jaFwiLCBbXSk7XG4gICAgICAgIGNvbnN0IHBpbmF0YUp3dCA9IGNvbmZpZy5waW5hdGFKd3QgfHwgcHJvY2Vzcy5lbnYuUElOQVRBX0pXVDtcbiAgICAgICAgaWYgKCFwaW5hdGFKd3QpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBJTkFUQV9KV1QgaXMgbm90IGNvbmZpZ3VyZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGluYXRhSnd0ID0gcGluYXRhSnd0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeGFtcGxlIGFjdGlvbiBpbXBsZW1lbnRhdGlvbi5cbiAgICAgKiBSZXBsYWNlIG9yIG1vZGlmeSB0aGlzIHdpdGggeW91ciBhY3R1YWwgYWN0aW9uLlxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogVGhpcyBpcyBhIHRlbXBsYXRlIGFjdGlvbiB0aGF0IGRlbW9uc3RyYXRlcyB0aGUgYmFzaWMgc3RydWN0dXJlLlxuICAgICAqIFJlcGxhY2UgaXQgd2l0aCB5b3VyIGFjdHVhbCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB3YWxsZXRQcm92aWRlciAtIFRoZSB3YWxsZXQgcHJvdmlkZXIgaW5zdGFuY2UgZm9yIGJsb2NrY2hhaW4gaW50ZXJhY3Rpb25zXG4gICAgICogQHBhcmFtIGFyZ3MgLSBBcmd1bWVudHMgZGVmaW5lZCBieSBGbGF1bmNoU2NoZW1hXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBzdHJpbmcgZGVzY3JpYmluZyB0aGUgYWN0aW9uIHJlc3VsdFxuICAgICAqL1xuICAgIGFzeW5jIGZsYXVuY2god2FsbGV0UHJvdmlkZXIsIGFyZ3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IG5ldHdvcmsgPSB3YWxsZXRQcm92aWRlci5nZXROZXR3b3JrKCk7XG4gICAgICAgICAgICBjb25zdCBuZXR3b3JrSWQgPSBuZXR3b3JrLm5ldHdvcmtJZDtcbiAgICAgICAgICAgIGNvbnN0IGNoYWluSWQgPSBuZXR3b3JrLmNoYWluSWQ7XG4gICAgICAgICAgICBpZiAoIWNoYWluSWQgfHwgIW5ldHdvcmtJZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNoYWluIElEIGlzIG5vdCBzZXQuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdXBsb2FkIGltYWdlICYgdG9rZW4gdXJpIHRvIGlwZnNcbiAgICAgICAgICAgIGNvbnN0IHRva2VuVXJpID0gYXdhaXQgKDAsIHV0aWxzXzEuZ2VuZXJhdGVUb2tlblVyaSkoYXJncy5uYW1lLCB7XG4gICAgICAgICAgICAgICAgcGluYXRhQ29uZmlnOiB7IGp3dDogdGhpcy5waW5hdGFKd3QgfSxcbiAgICAgICAgICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgICAgICAgICAgICBpbWFnZVVybDogYXJncy5pbWFnZVVybCxcbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IGFyZ3MuZGVzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgICAgIHdlYnNpdGVVcmw6IGFyZ3Mud2Vic2l0ZVVybCxcbiAgICAgICAgICAgICAgICAgICAgZGlzY29yZFVybDogYXJncy5kaXNjb3JkVXJsLFxuICAgICAgICAgICAgICAgICAgICB0d2l0dGVyVXJsOiBhcmdzLnR3aXR0ZXJVcmwsXG4gICAgICAgICAgICAgICAgICAgIHRlbGVncmFtVXJsOiBhcmdzLnRlbGVncmFtVXJsLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSAoMCwgdmllbV8xLmVuY29kZUZ1bmN0aW9uRGF0YSkoe1xuICAgICAgICAgICAgICAgIGFiaTogY29uc3RhbnRzXzEuRkFTVF9GTEFVTkNIX1pBUF9BQkksXG4gICAgICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiBcImZsYXVuY2hcIixcbiAgICAgICAgICAgICAgICBhcmdzOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGFyZ3MubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbDogYXJncy5zeW1ib2wsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlblVyaSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0b3I6IHdhbGxldFByb3ZpZGVyLmdldEFkZHJlc3MoKSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBoYXNoID0gYXdhaXQgd2FsbGV0UHJvdmlkZXIuc2VuZFRyYW5zYWN0aW9uKHtcbiAgICAgICAgICAgICAgICB0bzogY29uc3RhbnRzXzEuRmFzdEZsYXVuY2haYXBBZGRyZXNzW2NoYWluSWRdLFxuICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCB3YWxsZXRQcm92aWRlci53YWl0Rm9yVHJhbnNhY3Rpb25SZWNlaXB0KGhhc2gpO1xuICAgICAgICAgICAgY29uc3QgZmlsdGVyZWRQb29sQ3JlYXRlZEV2ZW50ID0gcmVjZWlwdC5sb2dzXG4gICAgICAgICAgICAgICAgLm1hcChsb2cgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsb2cuYWRkcmVzcy50b0xvd2VyQ2FzZSgpICE9PSBjb25zdGFudHNfMS5GbGF1bmNoUG9zaXRpb25NYW5hZ2VyQWRkcmVzc1tjaGFpbklkXS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBldmVudCA9ICgwLCB2aWVtXzEuZGVjb2RlRXZlbnRMb2cpKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFiaTogY29uc3RhbnRzXzEuUE9TSVRJT05fTUFOQUdFUl9BQkksXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBsb2cuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcGljczogbG9nLnRvcGljcyxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBldmVudC5ldmVudE5hbWUgPT09IFwiUG9vbENyZWF0ZWRcIiA/IGV2ZW50LmFyZ3MgOiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmZpbHRlcigoZXZlbnQpID0+IGV2ZW50ICE9PSBudWxsKVswXTtcbiAgICAgICAgICAgIGNvbnN0IG1lbWVjb2luQWRkcmVzcyA9IGZpbHRlcmVkUG9vbENyZWF0ZWRFdmVudC5fbWVtZWNvaW47XG4gICAgICAgICAgICBjb25zdCBjaGFpblNsdWcgPSBOdW1iZXIoY2hhaW5JZCkgPT09IGNoYWluc18xLmJhc2UuaWQgPyBcImJhc2VcIiA6IFwiYmFzZS1zZXBvbGlhXCI7XG4gICAgICAgICAgICByZXR1cm4gYEZsYXVuY2hlZFxcbiAke0pTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICBjb2luU3ltYm9sOiBgJCR7YXJncy5zeW1ib2x9YCxcbiAgICAgICAgICAgICAgICBjb2luTmFtZTogYXJncy5uYW1lLFxuICAgICAgICAgICAgICAgIGNvaW5BZGRyZXNzOiBtZW1lY29pbkFkZHJlc3MsXG4gICAgICAgICAgICAgICAgZmxhdW5jaENvaW5Vcmw6IGBodHRwczovL2ZsYXVuY2guZ2cvJHtjaGFpblNsdWd9L2NvaW4vJHttZW1lY29pbkFkZHJlc3N9YCxcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbkhhc2g6IGhhc2gsXG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25Vcmw6IGAke25ldHdvcmtfMS5ORVRXT1JLX0lEX1RPX1ZJRU1fQ0hBSU5bbmV0d29ya0lkXS5ibG9ja0V4cGxvcmVycz8uZGVmYXVsdC51cmx9L3R4LyR7aGFzaH1gLFxuICAgICAgICAgICAgfSl9YDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBgRXJyb3IgbGF1bmNoaW5nIGNvaW46ICR7ZXJyb3J9YDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBCdXlzIGEgZmxhdW5jaCBjb2luIHVzaW5nIEVUSCBpbnB1dC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB3YWxsZXRQcm92aWRlciAtIFRoZSB3YWxsZXQgcHJvdmlkZXIgaW5zdGFuY2UgZm9yIGJsb2NrY2hhaW4gaW50ZXJhY3Rpb25zXG4gICAgICogQHBhcmFtIGFyZ3MgLSBBcmd1bWVudHMgZGVmaW5lZCBieSBCdXlDb2luU2NoZW1hXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBzdHJpbmcgZGVzY3JpYmluZyB0aGUgdHJhbnNhY3Rpb24gcmVzdWx0XG4gICAgICovXG4gICAgYXN5bmMgYnV5Q29pbldpdGhFVEhJbnB1dCh3YWxsZXRQcm92aWRlciwgYXJncykge1xuICAgICAgICByZXR1cm4gdGhpcy5fYnV5RmxhdW5jaENvaW4od2FsbGV0UHJvdmlkZXIsIGFyZ3MuY29pbkFkZHJlc3MsIFwiRVhBQ1RfSU5cIiwgeyBhbW91bnRJbjogYXJncy5hbW91bnRJbiB9LCBhcmdzLnNsaXBwYWdlUGVyY2VudCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJ1eXMgYSBmbGF1bmNoIGNvaW4gdXNpbmcgQ29pbiBpbnB1dC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB3YWxsZXRQcm92aWRlciAtIFRoZSB3YWxsZXQgcHJvdmlkZXIgaW5zdGFuY2UgZm9yIGJsb2NrY2hhaW4gaW50ZXJhY3Rpb25zXG4gICAgICogQHBhcmFtIGFyZ3MgLSBBcmd1bWVudHMgZGVmaW5lZCBieSBCdXlDb2luU2NoZW1hXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBzdHJpbmcgZGVzY3JpYmluZyB0aGUgdHJhbnNhY3Rpb24gcmVzdWx0XG4gICAgICovXG4gICAgYXN5bmMgYnV5Q29pbldpdGhDb2luSW5wdXQod2FsbGV0UHJvdmlkZXIsIGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2J1eUZsYXVuY2hDb2luKHdhbGxldFByb3ZpZGVyLCBhcmdzLmNvaW5BZGRyZXNzLCBcIkVYQUNUX09VVFwiLCB7IGFtb3VudE91dDogYXJncy5hbW91bnRPdXQgfSwgYXJncy5zbGlwcGFnZVBlcmNlbnQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZWxscyBhIGZsYXVuY2ggY29pbiBpbnRvIEVUSC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB3YWxsZXRQcm92aWRlciAtIFRoZSB3YWxsZXQgcHJvdmlkZXIgaW5zdGFuY2UgZm9yIGJsb2NrY2hhaW4gaW50ZXJhY3Rpb25zXG4gICAgICogQHBhcmFtIGFyZ3MgLSBBcmd1bWVudHMgZGVmaW5lZCBieSBTZWxsQ29pblNjaGVtYVxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgc3RyaW5nIGRlc2NyaWJpbmcgdGhlIHRyYW5zYWN0aW9uIHJlc3VsdFxuICAgICAqL1xuICAgIGFzeW5jIHNlbGxDb2luKHdhbGxldFByb3ZpZGVyLCBhcmdzKSB7XG4gICAgICAgIGNvbnN0IG5ldHdvcmsgPSB3YWxsZXRQcm92aWRlci5nZXROZXR3b3JrKCk7XG4gICAgICAgIGNvbnN0IGNoYWluSWQgPSBuZXR3b3JrLmNoYWluSWQ7XG4gICAgICAgIGNvbnN0IG5ldHdvcmtJZCA9IG5ldHdvcmsubmV0d29ya0lkO1xuICAgICAgICBpZiAoIWNoYWluSWQgfHwgIW5ldHdvcmtJZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2hhaW4gSUQgaXMgbm90IHNldC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGFtb3VudEluID0gKDAsIHZpZW1fMS5wYXJzZUV0aGVyKShhcmdzLmFtb3VudEluKTtcbiAgICAgICAgICAgIC8vIGZldGNoIHBlcm1pdDIgYWxsb3dhbmNlXG4gICAgICAgICAgICBjb25zdCBbYWxsb3dhbmNlLCBub25jZV0gPSBhd2FpdCB3YWxsZXRQcm92aWRlci5yZWFkQ29udHJhY3Qoe1xuICAgICAgICAgICAgICAgIGFkZHJlc3M6IGNvbnN0YW50c18xLlBlcm1pdDJBZGRyZXNzW2NoYWluSWRdLFxuICAgICAgICAgICAgICAgIGFiaTogY29uc3RhbnRzXzEuUEVSTUlUMl9BQkksXG4gICAgICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiBcImFsbG93YW5jZVwiLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtcbiAgICAgICAgICAgICAgICAgICAgd2FsbGV0UHJvdmlkZXIuZ2V0QWRkcmVzcygpLFxuICAgICAgICAgICAgICAgICAgICBhcmdzLmNvaW5BZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICBjb25zdGFudHNfMS5Vbml2ZXJzYWxSb3V0ZXJBZGRyZXNzW2NoYWluSWRdLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxldCBzaWduYXR1cmU7XG4gICAgICAgICAgICBsZXQgcGVybWl0U2luZ2xlO1xuICAgICAgICAgICAgLy8gYXBwcm92ZVxuICAgICAgICAgICAgaWYgKGFsbG93YW5jZSA8IGFtb3VudEluKSB7XG4gICAgICAgICAgICAgICAgLy8gMTAgeWVhcnMgaW4gc2Vjb25kc1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlZmF1bHREZWFkbGluZSA9IEJpZ0ludChNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKSArIDYwICogNjAgKiAyNCAqIDM2NSAqIDEwKTtcbiAgICAgICAgICAgICAgICBjb25zdCBkb21haW4gPSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiUGVybWl0MlwiLFxuICAgICAgICAgICAgICAgICAgICBjaGFpbklkOiBOdW1iZXIoY2hhaW5JZCksXG4gICAgICAgICAgICAgICAgICAgIHZlcmlmeWluZ0NvbnRyYWN0OiBjb25zdGFudHNfMS5QZXJtaXQyQWRkcmVzc1tjaGFpbklkXSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB7XG4gICAgICAgICAgICAgICAgICAgIGRldGFpbHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuOiBhcmdzLmNvaW5BZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgYW1vdW50OiB2aWVtXzEubWF4VWludDE2MCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGlyYXRpb246IE51bWJlcihkZWZhdWx0RGVhZGxpbmUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbm9uY2UsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHNwZW5kZXI6IGNvbnN0YW50c18xLlVuaXZlcnNhbFJvdXRlckFkZHJlc3NbY2hhaW5JZF0sXG4gICAgICAgICAgICAgICAgICAgIHNpZ0RlYWRsaW5lOiBkZWZhdWx0RGVhZGxpbmUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZERhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgIHByaW1hcnlUeXBlOiBcIlBlcm1pdFNpbmdsZVwiLFxuICAgICAgICAgICAgICAgICAgICBkb21haW4sXG4gICAgICAgICAgICAgICAgICAgIHR5cGVzOiBjb25zdGFudHNfMS5QRVJNSVRfVFlQRVMsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBzaWduYXR1cmUgPSBhd2FpdCB3YWxsZXRQcm92aWRlci5zaWduVHlwZWREYXRhKHR5cGVkRGF0YSk7XG4gICAgICAgICAgICAgICAgcGVybWl0U2luZ2xlID0gbWVzc2FnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHZpZW1QdWJsaWNDbGllbnQgPSAoMCwgdmllbV8xLmNyZWF0ZVB1YmxpY0NsaWVudCkoe1xuICAgICAgICAgICAgICAgIGNoYWluOiBuZXR3b3JrXzEuTkVUV09SS19JRF9UT19WSUVNX0NIQUlOW25ldHdvcmtJZF0sXG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0OiAoMCwgdmllbV8xLmh0dHApKCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHF1b3RlUmVzdWx0ID0gYXdhaXQgdmllbVB1YmxpY0NsaWVudC5zaW11bGF0ZUNvbnRyYWN0KHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzOiBjb25zdGFudHNfMS5RdW90ZXJBZGRyZXNzW2NoYWluSWRdLFxuICAgICAgICAgICAgICAgIGFiaTogY29uc3RhbnRzXzEuUVVPVEVSX0FCSSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWU6IFwicXVvdGVFeGFjdElucHV0XCIsXG4gICAgICAgICAgICAgICAgYXJnczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleGFjdEFtb3VudDogYW1vdW50SW4sXG4gICAgICAgICAgICAgICAgICAgICAgICBleGFjdEN1cnJlbmN5OiBhcmdzLmNvaW5BZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmVlOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aWNrU3BhY2luZzogNjAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvb2tzOiBjb25zdGFudHNfMS5GbGF1bmNoUG9zaXRpb25NYW5hZ2VyQWRkcmVzc1tjaGFpbklkXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9va0RhdGE6IFwiMHhcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJtZWRpYXRlQ3VycmVuY3k6IGNvbnN0YW50c18xLkZMRVRIQWRkcmVzc1tjaGFpbklkXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmVlOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aWNrU3BhY2luZzogNjAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvb2tEYXRhOiBcIjB4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvb2tzOiBjb25zdGFudHNfMS5GTEVUSEhvb2tzQWRkcmVzc1tjaGFpbklkXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJtZWRpYXRlQ3VycmVuY3k6IHZpZW1fMS56ZXJvQWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBldGhPdXRNaW4gPSAoMCwgdXRpbHNfMS5nZXRBbW91bnRXaXRoU2xpcHBhZ2UpKHF1b3RlUmVzdWx0LnJlc3VsdFswXSwgLy8gYW1vdW50T3V0XG4gICAgICAgICAgICAoYXJncy5zbGlwcGFnZVBlcmNlbnQgLyAxMDApLnRvRml4ZWQoMTgpLnRvU3RyaW5nKCksIFwiRVhBQ1RfSU5cIik7XG4gICAgICAgICAgICBjb25zdCB7IGNvbW1hbmRzLCBpbnB1dHMgfSA9ICgwLCB1dGlsc18xLm1lbWVjb2luVG9FdGhXaXRoUGVybWl0Mikoe1xuICAgICAgICAgICAgICAgIGNoYWluSWQ6IE51bWJlcihjaGFpbklkKSxcbiAgICAgICAgICAgICAgICBtZW1lY29pbjogYXJncy5jb2luQWRkcmVzcyxcbiAgICAgICAgICAgICAgICBhbW91bnRJbixcbiAgICAgICAgICAgICAgICBldGhPdXRNaW4sXG4gICAgICAgICAgICAgICAgcGVybWl0U2luZ2xlLFxuICAgICAgICAgICAgICAgIHNpZ25hdHVyZSxcbiAgICAgICAgICAgICAgICByZWZlcnJlcjogdmllbV8xLnplcm9BZGRyZXNzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gKDAsIHZpZW1fMS5lbmNvZGVGdW5jdGlvbkRhdGEpKHtcbiAgICAgICAgICAgICAgICBhYmk6IGNvbnN0YW50c18xLlVOSVZFUlNBTF9ST1VURVJfQUJJLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogXCJleGVjdXRlXCIsXG4gICAgICAgICAgICAgICAgYXJnczogW2NvbW1hbmRzLCBpbnB1dHNdLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBoYXNoID0gYXdhaXQgd2FsbGV0UHJvdmlkZXIuc2VuZFRyYW5zYWN0aW9uKHtcbiAgICAgICAgICAgICAgICB0bzogY29uc3RhbnRzXzEuVW5pdmVyc2FsUm91dGVyQWRkcmVzc1tjaGFpbklkXSxcbiAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCByZWNlaXB0ID0gYXdhaXQgd2FsbGV0UHJvdmlkZXIud2FpdEZvclRyYW5zYWN0aW9uUmVjZWlwdChoYXNoKTtcbiAgICAgICAgICAgIGNvbnN0IHN3YXBBbW91bnRzID0gKDAsIHV0aWxzXzEuZ2V0U3dhcEFtb3VudHNGcm9tUmVjZWlwdCkoe1xuICAgICAgICAgICAgICAgIHJlY2VpcHQsXG4gICAgICAgICAgICAgICAgY29pbkFkZHJlc3M6IGFyZ3MuY29pbkFkZHJlc3MsXG4gICAgICAgICAgICAgICAgY2hhaW5JZDogTnVtYmVyKGNoYWluSWQpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBjb2luU3ltYm9sID0gYXdhaXQgd2FsbGV0UHJvdmlkZXIucmVhZENvbnRyYWN0KHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzOiBhcmdzLmNvaW5BZGRyZXNzLFxuICAgICAgICAgICAgICAgIGFiaTogY29uc3RhbnRzXzEuRVJDMjBfQUJJLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogXCJzeW1ib2xcIixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGBTb2xkICR7KDAsIHZpZW1fMS5mb3JtYXRFdGhlcikoc3dhcEFtb3VudHMuY29pbnNTb2xkKX0gJCR7Y29pblN5bWJvbH0gZm9yICR7KDAsIHZpZW1fMS5mb3JtYXRFdGhlcikoc3dhcEFtb3VudHMuZXRoQm91Z2h0KX0gRVRIXFxuXG4gICAgICAgIFR4IGhhc2g6IFske2hhc2h9XSgke25ldHdvcmtfMS5ORVRXT1JLX0lEX1RPX1ZJRU1fQ0hBSU5bbmV0d29ya0lkXS5ibG9ja0V4cGxvcmVycz8uZGVmYXVsdC51cmx9L3R4LyR7aGFzaH0pYDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBgRXJyb3Igc2VsbGluZyBjb2luOiAke2Vycm9yfWA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoaXMgcHJvdmlkZXIgc3VwcG9ydHMgdGhlIGdpdmVuIG5ldHdvcmsuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmV0d29yayAtIFRoZSBuZXR3b3JrIHRvIGNoZWNrIHN1cHBvcnQgZm9yXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgbmV0d29yayBpcyBzdXBwb3J0ZWRcbiAgICAgKi9cbiAgICBzdXBwb3J0c05ldHdvcmsobmV0d29yaykge1xuICAgICAgICAvLyBhbGwgcHJvdG9jb2wgbmV0d29ya3NcbiAgICAgICAgcmV0dXJuIG5ldHdvcmsucHJvdG9jb2xGYW1pbHkgPT09IFwiZXZtXCIgJiYgU1VQUE9SVEVEX05FVFdPUktTLmluY2x1ZGVzKG5ldHdvcmsubmV0d29ya0lkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyB0aGUgcHJvY2VzcyBvZiBidXlpbmcgYSBmbGF1bmNoIGNvaW4gd2l0aCBFVEguXG4gICAgICpcbiAgICAgKiBAcGFyYW0gd2FsbGV0UHJvdmlkZXIgLSBUaGUgd2FsbGV0IHByb3ZpZGVyIGluc3RhbmNlXG4gICAgICogQHBhcmFtIGNvaW5BZGRyZXNzIC0gVGhlIGFkZHJlc3Mgb2YgdGhlIGZsYXVuY2ggY29pblxuICAgICAqIEBwYXJhbSBzd2FwVHlwZSAtIFRoZSB0eXBlIG9mIHN3YXAgKEVYQUNUX0lOIG9yIEVYQUNUX09VVClcbiAgICAgKiBAcGFyYW0gc3dhcFBhcmFtcyAtIFBhcmFtZXRlcnMgc3BlY2lmaWMgdG8gdGhlIHN3YXAgdHlwZVxuICAgICAqIEBwYXJhbSBzd2FwUGFyYW1zLmFtb3VudEluIC0gVGhlIGFtb3VudCBvZiBFVEggdG8gc3BlbmQgKGZvciBFWEFDVF9JTilcbiAgICAgKiBAcGFyYW0gc3dhcFBhcmFtcy5hbW91bnRPdXQgLSBUaGUgYW1vdW50IG9mIGNvaW5zIHRvIGJ1eSAoZm9yIEVYQUNUX09VVClcbiAgICAgKiBAcGFyYW0gc2xpcHBhZ2VQZXJjZW50IC0gVGhlIHNsaXBwYWdlIHBlcmNlbnRhZ2VcbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIHN0cmluZyBkZXNjcmliaW5nIHRoZSB0cmFuc2FjdGlvbiByZXN1bHRcbiAgICAgKi9cbiAgICBhc3luYyBfYnV5RmxhdW5jaENvaW4od2FsbGV0UHJvdmlkZXIsIGNvaW5BZGRyZXNzLCBzd2FwVHlwZSwgc3dhcFBhcmFtcywgc2xpcHBhZ2VQZXJjZW50KSB7XG4gICAgICAgIGNvbnN0IG5ldHdvcmsgPSB3YWxsZXRQcm92aWRlci5nZXROZXR3b3JrKCk7XG4gICAgICAgIGNvbnN0IGNoYWluSWQgPSBuZXR3b3JrLmNoYWluSWQ7XG4gICAgICAgIGNvbnN0IG5ldHdvcmtJZCA9IG5ldHdvcmsubmV0d29ya0lkO1xuICAgICAgICBpZiAoIWNoYWluSWQgfHwgIW5ldHdvcmtJZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2hhaW4gSUQgaXMgbm90IHNldC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHZpZW1QdWJsaWNDbGllbnQgPSAoMCwgdmllbV8xLmNyZWF0ZVB1YmxpY0NsaWVudCkoe1xuICAgICAgICAgICAgICAgIGNoYWluOiBuZXR3b3JrXzEuTkVUV09SS19JRF9UT19WSUVNX0NIQUlOW25ldHdvcmtJZF0sXG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0OiAoMCwgdmllbV8xLmh0dHApKCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxldCBhbW91bnRJbjtcbiAgICAgICAgICAgIGxldCBhbW91bnRPdXRNaW47XG4gICAgICAgICAgICBsZXQgYW1vdW50T3V0O1xuICAgICAgICAgICAgbGV0IGFtb3VudEluTWF4O1xuICAgICAgICAgICAgaWYgKHN3YXBUeXBlID09PSBcIkVYQUNUX0lOXCIpIHtcbiAgICAgICAgICAgICAgICBhbW91bnRJbiA9ICgwLCB2aWVtXzEucGFyc2VFdGhlcikoc3dhcFBhcmFtcy5hbW91bnRJbik7XG4gICAgICAgICAgICAgICAgY29uc3QgcXVvdGVSZXN1bHQgPSBhd2FpdCB2aWVtUHVibGljQ2xpZW50LnNpbXVsYXRlQ29udHJhY3Qoe1xuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzOiBjb25zdGFudHNfMS5RdW90ZXJBZGRyZXNzW2NoYWluSWRdLFxuICAgICAgICAgICAgICAgICAgICBhYmk6IGNvbnN0YW50c18xLlFVT1RFUl9BQkksXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogXCJxdW90ZUV4YWN0SW5wdXRcIixcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4YWN0QW1vdW50OiBhbW91bnRJbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGFjdEN1cnJlbmN5OiB2aWVtXzEuemVyb0FkZHJlc3MsIC8vIEVUSFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmVlOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGlja1NwYWNpbmc6IDYwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9va0RhdGE6IFwiMHhcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvb2tzOiBjb25zdGFudHNfMS5GTEVUSEhvb2tzQWRkcmVzc1tjaGFpbklkXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVybWVkaWF0ZUN1cnJlbmN5OiBjb25zdGFudHNfMS5GTEVUSEFkZHJlc3NbY2hhaW5JZF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZlZTogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpY2tTcGFjaW5nOiA2MCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvb2tzOiBjb25zdGFudHNfMS5GbGF1bmNoUG9zaXRpb25NYW5hZ2VyQWRkcmVzc1tjaGFpbklkXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvb2tEYXRhOiBcIjB4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm1lZGlhdGVDdXJyZW5jeTogY29pbkFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYW1vdW50T3V0TWluID0gKDAsIHV0aWxzXzEuZ2V0QW1vdW50V2l0aFNsaXBwYWdlKShxdW90ZVJlc3VsdC5yZXN1bHRbMF0sIC8vIGFtb3VudE91dFxuICAgICAgICAgICAgICAgIChzbGlwcGFnZVBlcmNlbnQgLyAxMDApLnRvRml4ZWQoMTgpLnRvU3RyaW5nKCksIHN3YXBUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEVYQUNUX09VVFxuICAgICAgICAgICAgICAgIGFtb3VudE91dCA9ICgwLCB2aWVtXzEucGFyc2VFdGhlcikoc3dhcFBhcmFtcy5hbW91bnRPdXQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHF1b3RlUmVzdWx0ID0gYXdhaXQgdmllbVB1YmxpY0NsaWVudC5zaW11bGF0ZUNvbnRyYWN0KHtcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzczogY29uc3RhbnRzXzEuUXVvdGVyQWRkcmVzc1tjaGFpbklkXSxcbiAgICAgICAgICAgICAgICAgICAgYWJpOiBjb25zdGFudHNfMS5RVU9URVJfQUJJLFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWU6IFwicXVvdGVFeGFjdE91dHB1dFwiLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm1lZGlhdGVDdXJyZW5jeTogdmllbV8xLnplcm9BZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmVlOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGlja1NwYWNpbmc6IDYwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9va0RhdGE6IFwiMHhcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvb2tzOiBjb25zdGFudHNfMS5GTEVUSEhvb2tzQWRkcmVzc1tjaGFpbklkXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJtZWRpYXRlQ3VycmVuY3k6IGNvbnN0YW50c18xLkZMRVRIQWRkcmVzc1tjaGFpbklkXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZlZTogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpY2tTcGFjaW5nOiA2MCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvb2tzOiBjb25zdGFudHNfMS5GbGF1bmNoUG9zaXRpb25NYW5hZ2VyQWRkcmVzc1tjaGFpbklkXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvb2tEYXRhOiBcIjB4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGFjdEN1cnJlbmN5OiBjb2luQWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGFjdEFtb3VudDogYW1vdW50T3V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBhbW91bnRJbk1heCA9ICgwLCB1dGlsc18xLmdldEFtb3VudFdpdGhTbGlwcGFnZSkocXVvdGVSZXN1bHQucmVzdWx0WzBdLCAvLyBhbW91bnRJblxuICAgICAgICAgICAgICAgIChzbGlwcGFnZVBlcmNlbnQgLyAxMDApLnRvRml4ZWQoMTgpLnRvU3RyaW5nKCksIHN3YXBUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgY29tbWFuZHMsIGlucHV0cyB9ID0gKDAsIHV0aWxzXzEuZXRoVG9NZW1lY29pbikoe1xuICAgICAgICAgICAgICAgIHNlbmRlcjogd2FsbGV0UHJvdmlkZXIuZ2V0QWRkcmVzcygpLFxuICAgICAgICAgICAgICAgIG1lbWVjb2luOiBjb2luQWRkcmVzcyxcbiAgICAgICAgICAgICAgICBjaGFpbklkOiBOdW1iZXIoY2hhaW5JZCksXG4gICAgICAgICAgICAgICAgcmVmZXJyZXI6IHZpZW1fMS56ZXJvQWRkcmVzcyxcbiAgICAgICAgICAgICAgICBzd2FwVHlwZSxcbiAgICAgICAgICAgICAgICBhbW91bnRJbixcbiAgICAgICAgICAgICAgICBhbW91bnRPdXRNaW4sXG4gICAgICAgICAgICAgICAgYW1vdW50T3V0LFxuICAgICAgICAgICAgICAgIGFtb3VudEluTWF4LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gKDAsIHZpZW1fMS5lbmNvZGVGdW5jdGlvbkRhdGEpKHtcbiAgICAgICAgICAgICAgICBhYmk6IGNvbnN0YW50c18xLlVOSVZFUlNBTF9ST1VURVJfQUJJLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogXCJleGVjdXRlXCIsXG4gICAgICAgICAgICAgICAgYXJnczogW2NvbW1hbmRzLCBpbnB1dHNdLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBoYXNoID0gYXdhaXQgd2FsbGV0UHJvdmlkZXIuc2VuZFRyYW5zYWN0aW9uKHtcbiAgICAgICAgICAgICAgICB0bzogY29uc3RhbnRzXzEuVW5pdmVyc2FsUm91dGVyQWRkcmVzc1tjaGFpbklkXSxcbiAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBzd2FwVHlwZSA9PT0gXCJFWEFDVF9JTlwiID8gYW1vdW50SW4gOiBhbW91bnRJbk1heCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcmVjZWlwdCA9IGF3YWl0IHdhbGxldFByb3ZpZGVyLndhaXRGb3JUcmFuc2FjdGlvblJlY2VpcHQoaGFzaCk7XG4gICAgICAgICAgICBjb25zdCBzd2FwQW1vdW50cyA9ICgwLCB1dGlsc18xLmdldFN3YXBBbW91bnRzRnJvbVJlY2VpcHQpKHtcbiAgICAgICAgICAgICAgICByZWNlaXB0LFxuICAgICAgICAgICAgICAgIGNvaW5BZGRyZXNzOiBjb2luQWRkcmVzcyxcbiAgICAgICAgICAgICAgICBjaGFpbklkOiBOdW1iZXIoY2hhaW5JZCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGNvaW5TeW1ib2wgPSBhd2FpdCB3YWxsZXRQcm92aWRlci5yZWFkQ29udHJhY3Qoe1xuICAgICAgICAgICAgICAgIGFkZHJlc3M6IGNvaW5BZGRyZXNzLFxuICAgICAgICAgICAgICAgIGFiaTogY29uc3RhbnRzXzEuRVJDMjBfQUJJLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogXCJzeW1ib2xcIixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGBCb3VnaHQgJHsoMCwgdmllbV8xLmZvcm1hdEV0aGVyKShzd2FwQW1vdW50cy5jb2luc0JvdWdodCl9ICQke2NvaW5TeW1ib2x9IGZvciAkeygwLCB2aWVtXzEuZm9ybWF0RXRoZXIpKHN3YXBBbW91bnRzLmV0aFNvbGQpfSBFVEhcXG5cbiAgICAgICAgVHggaGFzaDogWyR7aGFzaH1dKCR7bmV0d29ya18xLk5FVFdPUktfSURfVE9fVklFTV9DSEFJTltuZXR3b3JrSWRdLmJsb2NrRXhwbG9yZXJzPy5kZWZhdWx0LnVybH0vdHgvJHtoYXNofSlgO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGBFcnJvciBidXlpbmcgY29pbjogJHtlcnJvcn1gO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5GbGF1bmNoQWN0aW9uUHJvdmlkZXIgPSBGbGF1bmNoQWN0aW9uUHJvdmlkZXI7XG5fX2RlY29yYXRlKFtcbiAgICAoMCwgYWN0aW9uRGVjb3JhdG9yXzEuQ3JlYXRlQWN0aW9uKSh7XG4gICAgICAgIG5hbWU6IFwiZmxhdW5jaFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogYFxuVGhpcyB0b29sIGFsbG93cyBsYXVuY2hpbmcgYSBuZXcgbWVtZWNvaW4gdXNpbmcgdGhlIGZsYXVuY2ggcHJvdG9jb2wuXG5cbkl0IHRha2VzOlxuLSBuYW1lOiBUaGUgbmFtZSBvZiB0aGUgdG9rZW5cbi0gc3ltYm9sOiBUaGUgc3ltYm9sIG9mIHRoZSB0b2tlblxuLSBpbWFnZVVybDogVVJMIHRvIHRoZSB0b2tlbiBpbWFnZVxuLSBkZXNjcmlwdGlvbjogRGVzY3JpcHRpb24gb2YgdGhlIHRva2VuXG5cbi0gd2Vic2l0ZVVybDogKG9wdGlvbmFsKSBVUkwgdG8gdGhlIHRva2VuIHdlYnNpdGVcbi0gZGlzY29yZFVybDogKG9wdGlvbmFsKSBVUkwgdG8gdGhlIHRva2VuIERpc2NvcmRcbi0gdHdpdHRlclVybDogKG9wdGlvbmFsKSBVUkwgdG8gdGhlIHRva2VuIFR3aXR0ZXJcbi0gdGVsZWdyYW1Vcmw6IChvcHRpb25hbCkgVVJMIHRvIHRoZSB0b2tlbiBUZWxlZ3JhbVxuXG5Ob3RlOlxuLSBJZiB0aGUgb3B0aW9uYWwgZmllbGRzIGFyZSBub3QgcHJvdmlkZWQsIGRvbid0IGluY2x1ZGUgdGhlbSBpbiB0aGUgY2FsbC5cbiAgICBgLFxuICAgICAgICBzY2hlbWE6IHNjaGVtYXNfMS5GbGF1bmNoU2NoZW1hLFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFt3YWxsZXRfcHJvdmlkZXJzXzEuRXZtV2FsbGV0UHJvdmlkZXIsIHZvaWQgMF0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCBQcm9taXNlKVxuXSwgRmxhdW5jaEFjdGlvblByb3ZpZGVyLnByb3RvdHlwZSwgXCJmbGF1bmNoXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgKDAsIGFjdGlvbkRlY29yYXRvcl8xLkNyZWF0ZUFjdGlvbikoe1xuICAgICAgICBuYW1lOiBcImJ1eUNvaW5XaXRoRVRISW5wdXRcIixcbiAgICAgICAgZGVzY3JpcHRpb246IGBcblRoaXMgdG9vbCBhbGxvd3MgYnV5aW5nIGEgZmxhdW5jaCBjb2luIHVzaW5nIEVUSCwgd2hlbiB0aGUgdXNlciBoYXMgc3BlY2lmaWVkIHRoZSBFVEggYW1vdW50IHRvIHNwZW5kLlxuXG5JdCB0YWtlczpcbi0gY29pbkFkZHJlc3M6IFRoZSBhZGRyZXNzIG9mIHRoZSBmbGF1bmNoIGNvaW4gdG8gYnV5XG4tIGFtb3VudEluOiBUaGUgcXVhbnRpdHkgb2YgRVRIIHRvIHNwZW5kIG9uIHRoZSBmbGF1bmNoIGNvaW4sIGluIHdob2xlIHVuaXRzXG4gIEV4YW1wbGVzOlxuICAtIDAuMDAxIEVUSFxuICAtIDAuMDEgRVRIXG4gIC0gMSBFVEhcbi0gc2xpcHBhZ2VQZXJjZW50OiAob3B0aW9uYWwpIFRoZSBzbGlwcGFnZSBwZXJjZW50YWdlLiBEZWZhdWx0IHRvIDUlXG4gICAgYCxcbiAgICAgICAgc2NoZW1hOiBzY2hlbWFzXzEuQnV5Q29pbldpdGhFVEhJbnB1dFNjaGVtYSxcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbd2FsbGV0X3Byb3ZpZGVyc18xLkV2bVdhbGxldFByb3ZpZGVyLCB2b2lkIDBdKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgUHJvbWlzZSlcbl0sIEZsYXVuY2hBY3Rpb25Qcm92aWRlci5wcm90b3R5cGUsIFwiYnV5Q29pbldpdGhFVEhJbnB1dFwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgICgwLCBhY3Rpb25EZWNvcmF0b3JfMS5DcmVhdGVBY3Rpb24pKHtcbiAgICAgICAgbmFtZTogXCJidXlDb2luV2l0aENvaW5JbnB1dFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogYFxuVGhpcyB0b29sIGFsbG93cyBidXlpbmcgYSBmbGF1bmNoIGNvaW4gdXNpbmcgRVRILCB3aGVuIHRoZSB1c2VyIGhhcyBzcGVjaWZpZWQgdGhlIENvaW4gYW1vdW50IHRvIGJ1eS5cblxuSXQgdGFrZXM6XG4tIGNvaW5BZGRyZXNzOiBUaGUgYWRkcmVzcyBvZiB0aGUgZmxhdW5jaCBjb2luIHRvIGJ1eVxuLSBhbW91bnRPdXQ6IFRoZSBxdWFudGl0eSBvZiB0aGUgZmxhdW5jaCBjb2luIHRvIGJ1eSwgaW4gd2hvbGUgdW5pdHNcbiAgRXhhbXBsZXM6XG4gIC0gMTAwMCBjb2luc1xuICAtIDFfMDAwXzAwMCBjb2luc1xuLSBzbGlwcGFnZVBlcmNlbnQ6IChvcHRpb25hbCkgVGhlIHNsaXBwYWdlIHBlcmNlbnRhZ2UuIERlZmF1bHQgdG8gNSVcbiAgICBgLFxuICAgICAgICBzY2hlbWE6IHNjaGVtYXNfMS5CdXlDb2luV2l0aENvaW5JbnB1dFNjaGVtYSxcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbd2FsbGV0X3Byb3ZpZGVyc18xLkV2bVdhbGxldFByb3ZpZGVyLCB2b2lkIDBdKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgUHJvbWlzZSlcbl0sIEZsYXVuY2hBY3Rpb25Qcm92aWRlci5wcm90b3R5cGUsIFwiYnV5Q29pbldpdGhDb2luSW5wdXRcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICAoMCwgYWN0aW9uRGVjb3JhdG9yXzEuQ3JlYXRlQWN0aW9uKSh7XG4gICAgICAgIG5hbWU6IFwic2VsbENvaW5cIixcbiAgICAgICAgZGVzY3JpcHRpb246IGBcblRoaXMgdG9vbCBhbGxvd3Mgc2VsbGluZyBhIGZsYXVuY2ggY29pbiBpbnRvIEVUSCwgd2hlbiB0aGUgdXNlciBoYXMgc3BlY2lmaWVkIHRoZSBDb2luIGFtb3VudCB0byBzZWxsLlxuXG5JdCB0YWtlczpcbi0gY29pbkFkZHJlc3M6IFRoZSBhZGRyZXNzIG9mIHRoZSBmbGF1bmNoIGNvaW4gdG8gc2VsbFxuLSBhbW91bnRJbjogVGhlIHF1YW50aXR5IG9mIHRoZSBmbGF1bmNoIGNvaW4gdG8gc2VsbCwgaW4gd2hvbGUgdW5pdHNcbiAgRXhhbXBsZXM6XG4gIC0gMTAwMCBjb2luc1xuICAtIDFfMDAwXzAwMCBjb2luc1xuLSBzbGlwcGFnZVBlcmNlbnQ6IChvcHRpb25hbCkgVGhlIHNsaXBwYWdlIHBlcmNlbnRhZ2UuIERlZmF1bHQgdG8gNSVcbiAgICBgLFxuICAgICAgICBzY2hlbWE6IHNjaGVtYXNfMS5TZWxsQ29pblNjaGVtYSxcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbd2FsbGV0X3Byb3ZpZGVyc18xLkV2bVdhbGxldFByb3ZpZGVyLCB2b2lkIDBdKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgUHJvbWlzZSlcbl0sIEZsYXVuY2hBY3Rpb25Qcm92aWRlci5wcm90b3R5cGUsIFwic2VsbENvaW5cIiwgbnVsbCk7XG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb24gdG8gY3JlYXRlIGEgbmV3IEZsYXVuY2hBY3Rpb25Qcm92aWRlciBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0gY29uZmlnIC0gQ29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgRmxhdW5jaEFjdGlvblByb3ZpZGVyXG4gKiBAcmV0dXJucyBBIG5ldyBGbGF1bmNoQWN0aW9uUHJvdmlkZXIgaW5zdGFuY2VcbiAqL1xuY29uc3QgZmxhdW5jaEFjdGlvblByb3ZpZGVyID0gKGNvbmZpZykgPT4gbmV3IEZsYXVuY2hBY3Rpb25Qcm92aWRlcihjb25maWcpO1xuZXhwb3J0cy5mbGF1bmNoQWN0aW9uUHJvdmlkZXIgPSBmbGF1bmNoQWN0aW9uUHJvdmlkZXI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/flaunch/flaunchActionProvider.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/flaunch/index.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/flaunch/index.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Exports for flaunch action provider\n *\n * @module flaunch\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./flaunchActionProvider */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/flaunch/flaunchActionProvider.js\"), exports);\n__exportStar(__webpack_require__(/*! ./schemas */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/flaunch/schemas.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9mbGF1bmNoL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxhQUFhLG1CQUFPLENBQUMsK0hBQXlCO0FBQzlDLGFBQWEsbUJBQU8sQ0FBQyxtR0FBVyIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cnZpdmFsLWZ1bi8uL25vZGVfbW9kdWxlcy9AY29pbmJhc2UvYWdlbnRraXQvZGlzdC9hY3Rpb24tcHJvdmlkZXJzL2ZsYXVuY2gvaW5kZXguanM/Y2Y0NSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogRXhwb3J0cyBmb3IgZmxhdW5jaCBhY3Rpb24gcHJvdmlkZXJcbiAqXG4gKiBAbW9kdWxlIGZsYXVuY2hcbiAqL1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZmxhdW5jaEFjdGlvblByb3ZpZGVyXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9zY2hlbWFzXCIpLCBleHBvcnRzKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/flaunch/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/flaunch/schemas.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/flaunch/schemas.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SellCoinSchema = exports.BuyCoinWithCoinInputSchema = exports.BuyCoinWithETHInputSchema = exports.FlaunchSchema = void 0;\nconst zod_1 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/lib/index.js\");\n/**\n * Action schemas for the flaunch action provider.\n *\n * This file contains the Zod schemas that define the shape and validation\n * rules for action parameters in the flaunch action provider.\n */\n/**\n * Schema for Flaunch token creation\n */\nexports.FlaunchSchema = zod_1.z.object({\n    name: zod_1.z.string().min(1).describe(\"The name of the token\"),\n    symbol: zod_1.z.string().min(1).describe(\"The symbol of the token\"),\n    imageUrl: zod_1.z.string().url().describe(\"The URL to the token image\"),\n    description: zod_1.z.string().describe(\"The description of the token\"),\n    websiteUrl: zod_1.z.string().url().optional().describe(\"The (optional) URL to the token website\"),\n    discordUrl: zod_1.z.string().url().optional().describe(\"The (optional) URL to the token Discord\"),\n    twitterUrl: zod_1.z.string().url().optional().describe(\"The (optional) URL to the token Twitter\"),\n    telegramUrl: zod_1.z.string().url().optional().describe(\"The (optional) URL to the token Telegram\"),\n});\nexports.BuyCoinWithETHInputSchema = zod_1.z.object({\n    coinAddress: zod_1.z\n        .string()\n        .describe(\"The address of the flaunch coin to buy\")\n        .regex(/^0x[a-fA-F0-9]{40}$/, \"Invalid Ethereum address format\"),\n    amountIn: zod_1.z\n        .string()\n        .regex(/^\\d+(\\.\\d+)?$/, \"Must be a valid integer or decimal value\")\n        .describe(\"The quantity of ETH to spend on the flaunch coin, in whole units\"),\n    slippagePercent: zod_1.z\n        .number()\n        .min(0)\n        .max(100)\n        .default(5)\n        .describe(\"The slippage percentage. Default to 5%\"),\n});\nexports.BuyCoinWithCoinInputSchema = zod_1.z.object({\n    coinAddress: zod_1.z\n        .string()\n        .describe(\"The address of the flaunch coin to buy\")\n        .regex(/^0x[a-fA-F0-9]{40}$/, \"Invalid Ethereum address format\"),\n    amountOut: zod_1.z\n        .string()\n        .regex(/^\\d+(\\.\\d+)?$/, \"Must be a valid integer or decimal value\")\n        .describe(\"The quantity of the flaunch coin to buy, in whole units\"),\n    slippagePercent: zod_1.z\n        .number()\n        .min(0)\n        .max(100)\n        .default(5)\n        .describe(\"The slippage percentage. Default to 5%\"),\n});\nexports.SellCoinSchema = zod_1.z.object({\n    coinAddress: zod_1.z\n        .string()\n        .describe(\"The address of the flaunch coin to sell\")\n        .regex(/^0x[a-fA-F0-9]{40}$/, \"Invalid Ethereum address format\"),\n    amountIn: zod_1.z\n        .string()\n        .regex(/^\\d+(\\.\\d+)?$/, \"Must be a valid integer or decimal value\")\n        .describe(\"The quantity of the flaunch coin to sell, in whole units\"),\n    slippagePercent: zod_1.z\n        .number()\n        .min(0)\n        .max(100)\n        .default(5)\n        .describe(\"The slippage percentage. Default to 5%\"),\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9mbGF1bmNoL3NjaGVtYXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsc0JBQXNCLEdBQUcsa0NBQWtDLEdBQUcsaUNBQWlDLEdBQUcscUJBQXFCO0FBQ3ZILGNBQWMsbUJBQU8sQ0FBQyxrREFBSztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLEdBQUc7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixHQUFHO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsR0FBRztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXJ2aXZhbC1mdW4vLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9mbGF1bmNoL3NjaGVtYXMuanM/MjYyMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU2VsbENvaW5TY2hlbWEgPSBleHBvcnRzLkJ1eUNvaW5XaXRoQ29pbklucHV0U2NoZW1hID0gZXhwb3J0cy5CdXlDb2luV2l0aEVUSElucHV0U2NoZW1hID0gZXhwb3J0cy5GbGF1bmNoU2NoZW1hID0gdm9pZCAwO1xuY29uc3Qgem9kXzEgPSByZXF1aXJlKFwiem9kXCIpO1xuLyoqXG4gKiBBY3Rpb24gc2NoZW1hcyBmb3IgdGhlIGZsYXVuY2ggYWN0aW9uIHByb3ZpZGVyLlxuICpcbiAqIFRoaXMgZmlsZSBjb250YWlucyB0aGUgWm9kIHNjaGVtYXMgdGhhdCBkZWZpbmUgdGhlIHNoYXBlIGFuZCB2YWxpZGF0aW9uXG4gKiBydWxlcyBmb3IgYWN0aW9uIHBhcmFtZXRlcnMgaW4gdGhlIGZsYXVuY2ggYWN0aW9uIHByb3ZpZGVyLlxuICovXG4vKipcbiAqIFNjaGVtYSBmb3IgRmxhdW5jaCB0b2tlbiBjcmVhdGlvblxuICovXG5leHBvcnRzLkZsYXVuY2hTY2hlbWEgPSB6b2RfMS56Lm9iamVjdCh7XG4gICAgbmFtZTogem9kXzEuei5zdHJpbmcoKS5taW4oMSkuZGVzY3JpYmUoXCJUaGUgbmFtZSBvZiB0aGUgdG9rZW5cIiksXG4gICAgc3ltYm9sOiB6b2RfMS56LnN0cmluZygpLm1pbigxKS5kZXNjcmliZShcIlRoZSBzeW1ib2wgb2YgdGhlIHRva2VuXCIpLFxuICAgIGltYWdlVXJsOiB6b2RfMS56LnN0cmluZygpLnVybCgpLmRlc2NyaWJlKFwiVGhlIFVSTCB0byB0aGUgdG9rZW4gaW1hZ2VcIiksXG4gICAgZGVzY3JpcHRpb246IHpvZF8xLnouc3RyaW5nKCkuZGVzY3JpYmUoXCJUaGUgZGVzY3JpcHRpb24gb2YgdGhlIHRva2VuXCIpLFxuICAgIHdlYnNpdGVVcmw6IHpvZF8xLnouc3RyaW5nKCkudXJsKCkub3B0aW9uYWwoKS5kZXNjcmliZShcIlRoZSAob3B0aW9uYWwpIFVSTCB0byB0aGUgdG9rZW4gd2Vic2l0ZVwiKSxcbiAgICBkaXNjb3JkVXJsOiB6b2RfMS56LnN0cmluZygpLnVybCgpLm9wdGlvbmFsKCkuZGVzY3JpYmUoXCJUaGUgKG9wdGlvbmFsKSBVUkwgdG8gdGhlIHRva2VuIERpc2NvcmRcIiksXG4gICAgdHdpdHRlclVybDogem9kXzEuei5zdHJpbmcoKS51cmwoKS5vcHRpb25hbCgpLmRlc2NyaWJlKFwiVGhlIChvcHRpb25hbCkgVVJMIHRvIHRoZSB0b2tlbiBUd2l0dGVyXCIpLFxuICAgIHRlbGVncmFtVXJsOiB6b2RfMS56LnN0cmluZygpLnVybCgpLm9wdGlvbmFsKCkuZGVzY3JpYmUoXCJUaGUgKG9wdGlvbmFsKSBVUkwgdG8gdGhlIHRva2VuIFRlbGVncmFtXCIpLFxufSk7XG5leHBvcnRzLkJ1eUNvaW5XaXRoRVRISW5wdXRTY2hlbWEgPSB6b2RfMS56Lm9iamVjdCh7XG4gICAgY29pbkFkZHJlc3M6IHpvZF8xLnpcbiAgICAgICAgLnN0cmluZygpXG4gICAgICAgIC5kZXNjcmliZShcIlRoZSBhZGRyZXNzIG9mIHRoZSBmbGF1bmNoIGNvaW4gdG8gYnV5XCIpXG4gICAgICAgIC5yZWdleCgvXjB4W2EtZkEtRjAtOV17NDB9JC8sIFwiSW52YWxpZCBFdGhlcmV1bSBhZGRyZXNzIGZvcm1hdFwiKSxcbiAgICBhbW91bnRJbjogem9kXzEuelxuICAgICAgICAuc3RyaW5nKClcbiAgICAgICAgLnJlZ2V4KC9eXFxkKyhcXC5cXGQrKT8kLywgXCJNdXN0IGJlIGEgdmFsaWQgaW50ZWdlciBvciBkZWNpbWFsIHZhbHVlXCIpXG4gICAgICAgIC5kZXNjcmliZShcIlRoZSBxdWFudGl0eSBvZiBFVEggdG8gc3BlbmQgb24gdGhlIGZsYXVuY2ggY29pbiwgaW4gd2hvbGUgdW5pdHNcIiksXG4gICAgc2xpcHBhZ2VQZXJjZW50OiB6b2RfMS56XG4gICAgICAgIC5udW1iZXIoKVxuICAgICAgICAubWluKDApXG4gICAgICAgIC5tYXgoMTAwKVxuICAgICAgICAuZGVmYXVsdCg1KVxuICAgICAgICAuZGVzY3JpYmUoXCJUaGUgc2xpcHBhZ2UgcGVyY2VudGFnZS4gRGVmYXVsdCB0byA1JVwiKSxcbn0pO1xuZXhwb3J0cy5CdXlDb2luV2l0aENvaW5JbnB1dFNjaGVtYSA9IHpvZF8xLnoub2JqZWN0KHtcbiAgICBjb2luQWRkcmVzczogem9kXzEuelxuICAgICAgICAuc3RyaW5nKClcbiAgICAgICAgLmRlc2NyaWJlKFwiVGhlIGFkZHJlc3Mgb2YgdGhlIGZsYXVuY2ggY29pbiB0byBidXlcIilcbiAgICAgICAgLnJlZ2V4KC9eMHhbYS1mQS1GMC05XXs0MH0kLywgXCJJbnZhbGlkIEV0aGVyZXVtIGFkZHJlc3MgZm9ybWF0XCIpLFxuICAgIGFtb3VudE91dDogem9kXzEuelxuICAgICAgICAuc3RyaW5nKClcbiAgICAgICAgLnJlZ2V4KC9eXFxkKyhcXC5cXGQrKT8kLywgXCJNdXN0IGJlIGEgdmFsaWQgaW50ZWdlciBvciBkZWNpbWFsIHZhbHVlXCIpXG4gICAgICAgIC5kZXNjcmliZShcIlRoZSBxdWFudGl0eSBvZiB0aGUgZmxhdW5jaCBjb2luIHRvIGJ1eSwgaW4gd2hvbGUgdW5pdHNcIiksXG4gICAgc2xpcHBhZ2VQZXJjZW50OiB6b2RfMS56XG4gICAgICAgIC5udW1iZXIoKVxuICAgICAgICAubWluKDApXG4gICAgICAgIC5tYXgoMTAwKVxuICAgICAgICAuZGVmYXVsdCg1KVxuICAgICAgICAuZGVzY3JpYmUoXCJUaGUgc2xpcHBhZ2UgcGVyY2VudGFnZS4gRGVmYXVsdCB0byA1JVwiKSxcbn0pO1xuZXhwb3J0cy5TZWxsQ29pblNjaGVtYSA9IHpvZF8xLnoub2JqZWN0KHtcbiAgICBjb2luQWRkcmVzczogem9kXzEuelxuICAgICAgICAuc3RyaW5nKClcbiAgICAgICAgLmRlc2NyaWJlKFwiVGhlIGFkZHJlc3Mgb2YgdGhlIGZsYXVuY2ggY29pbiB0byBzZWxsXCIpXG4gICAgICAgIC5yZWdleCgvXjB4W2EtZkEtRjAtOV17NDB9JC8sIFwiSW52YWxpZCBFdGhlcmV1bSBhZGRyZXNzIGZvcm1hdFwiKSxcbiAgICBhbW91bnRJbjogem9kXzEuelxuICAgICAgICAuc3RyaW5nKClcbiAgICAgICAgLnJlZ2V4KC9eXFxkKyhcXC5cXGQrKT8kLywgXCJNdXN0IGJlIGEgdmFsaWQgaW50ZWdlciBvciBkZWNpbWFsIHZhbHVlXCIpXG4gICAgICAgIC5kZXNjcmliZShcIlRoZSBxdWFudGl0eSBvZiB0aGUgZmxhdW5jaCBjb2luIHRvIHNlbGwsIGluIHdob2xlIHVuaXRzXCIpLFxuICAgIHNsaXBwYWdlUGVyY2VudDogem9kXzEuelxuICAgICAgICAubnVtYmVyKClcbiAgICAgICAgLm1pbigwKVxuICAgICAgICAubWF4KDEwMClcbiAgICAgICAgLmRlZmF1bHQoNSlcbiAgICAgICAgLmRlc2NyaWJlKFwiVGhlIHNsaXBwYWdlIHBlcmNlbnRhZ2UuIERlZmF1bHQgdG8gNSVcIiksXG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/flaunch/schemas.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/flaunch/utils.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/flaunch/utils.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getSwapAmountsFromReceipt = exports.getSwapAmountsFromLog = exports.memecoinToEthWithPermit2 = exports.ethToMemecoin = exports.getAmountWithSlippage = exports.generateTokenUri = void 0;\nconst viem_1 = __webpack_require__(/*! viem */ \"(rsc)/./node_modules/viem/_cjs/index.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/flaunch/constants.js\");\n/**\n * Uploads a base64 image to IPFS using Pinata\n *\n * @param params - Configuration and base64 image data\n * @param params.pinataConfig - Pinata configuration including JWT\n * @param params.base64Image - Base64 encoded image data\n * @param params.name - Optional name for the uploaded file\n * @param params.metadata - Optional metadata key-value pairs\n * @returns Upload response with CID and other details\n */\nconst uploadImageToIPFS = async (params) => {\n    try {\n        const formData = new FormData();\n        // Convert base64 to Blob and then to File\n        // Remove data URL prefix if present (e.g., \"data:image/jpeg;base64,\")\n        const base64Data = params.base64Image.split(\",\")[1] || params.base64Image;\n        const byteCharacters = atob(base64Data);\n        const byteArrays = [];\n        for (let offset = 0; offset < byteCharacters.length; offset += 1024) {\n            const slice = byteCharacters.slice(offset, offset + 1024);\n            const byteNumbers = new Array(slice.length);\n            for (let i = 0; i < slice.length; i++) {\n                byteNumbers[i] = slice.charCodeAt(i);\n            }\n            const byteArray = new Uint8Array(byteNumbers);\n            byteArrays.push(byteArray);\n        }\n        // Detect mime type from base64 string\n        let mimeType = \"image/png\"; // default\n        if (params.base64Image.startsWith(\"data:\")) {\n            mimeType = params.base64Image.split(\";\")[0].split(\":\")[1];\n        }\n        const blob = new Blob(byteArrays, { type: mimeType });\n        const fileName = params.name || `image.${mimeType.split(\"/\")[1]}`;\n        const file = new File([blob], fileName, { type: mimeType });\n        formData.append(\"file\", file);\n        const pinataMetadata = {\n            name: params.name || null,\n            keyvalues: params.metadata || {},\n        };\n        formData.append(\"pinataMetadata\", JSON.stringify(pinataMetadata));\n        const pinataOptions = {\n            cidVersion: 1,\n        };\n        formData.append(\"pinataOptions\", JSON.stringify(pinataOptions));\n        const response = await fetch(\"https://api.pinata.cloud/pinning/pinFileToIPFS\", {\n            method: \"POST\",\n            headers: {\n                Authorization: `Bearer ${params.pinataConfig.jwt}`,\n            },\n            body: formData,\n        });\n        if (!response.ok) {\n            const error = await response.json();\n            throw new Error(`Failed to upload image to IPFS: ${error.message || response.statusText}`);\n        }\n        const data = await response.json();\n        return {\n            IpfsHash: data.IpfsHash,\n            PinSize: data.PinSize,\n            Timestamp: data.Timestamp,\n            isDuplicate: data.isDuplicate || false,\n        };\n    }\n    catch (error) {\n        if (error instanceof Error) {\n            throw new Error(`Failed to upload image to IPFS: ${error.message}`);\n        }\n        throw error;\n    }\n};\n/**\n * Uploads JSON data to IPFS using Pinata\n *\n * @param params - Configuration and JSON data\n * @param params.pinataConfig - Pinata configuration including JWT\n * @param params.json - JSON data to upload\n * @param params.name - Optional name for the uploaded file\n * @param params.metadata - Optional metadata key-value pairs\n * @returns Upload response with CID and other details\n */\nconst uploadJsonToIPFS = async (params) => {\n    try {\n        const requestBody = {\n            pinataOptions: {\n                cidVersion: 1,\n            },\n            pinataMetadata: {\n                name: params.name || null,\n                keyvalues: params.metadata || {},\n            },\n            pinataContent: params.json,\n        };\n        const response = await fetch(\"https://api.pinata.cloud/pinning/pinJSONToIPFS\", {\n            method: \"POST\",\n            headers: {\n                Authorization: `Bearer ${params.pinataConfig.jwt}`,\n                \"Content-Type\": \"application/json\",\n            },\n            body: JSON.stringify(requestBody),\n        });\n        if (!response.ok) {\n            const error = await response.json();\n            throw new Error(`Failed to upload JSON to IPFS: ${error.message || response.statusText}`);\n        }\n        const data = await response.json();\n        return {\n            IpfsHash: data.IpfsHash,\n            PinSize: data.PinSize,\n            Timestamp: data.Timestamp,\n            isDuplicate: data.isDuplicate || false,\n        };\n    }\n    catch (error) {\n        if (error instanceof Error) {\n            throw new Error(`Failed to upload JSON to IPFS: ${error.message}`);\n        }\n        throw error;\n    }\n};\nconst generateTokenUriBase64Image = async (name, params) => {\n    // 1. upload image to IPFS\n    const imageRes = await uploadImageToIPFS({\n        pinataConfig: params.pinataConfig,\n        base64Image: params.metadata.base64Image,\n    });\n    // 2. upload metadata to IPFS\n    const coinMetadata = {\n        name,\n        description: params.metadata.description,\n        image: `ipfs://${imageRes.IpfsHash}`,\n        external_link: params.metadata.websiteUrl || \"\",\n        collaborators: [],\n        discordUrl: params.metadata.discordUrl || \"\",\n        twitterUrl: params.metadata.twitterUrl || \"\",\n        telegramUrl: params.metadata.telegramUrl || \"\",\n    };\n    const metadataRes = await uploadJsonToIPFS({\n        pinataConfig: params.pinataConfig,\n        json: coinMetadata,\n    });\n    return `ipfs://${metadataRes.IpfsHash}`;\n};\nconst generateTokenUri = async (name, params) => {\n    // 1. get base64Image from imageUrl\n    const response = await fetch(params.metadata.imageUrl);\n    if (!response.ok) {\n        throw new Error(`Failed to fetch image: ${response.statusText}`);\n    }\n    const arrayBuffer = await response.arrayBuffer();\n    const base64Image = Buffer.from(arrayBuffer).toString(\"base64\");\n    // 2. generate token uri\n    const tokenUri = await generateTokenUriBase64Image(name, {\n        pinataConfig: params.pinataConfig,\n        metadata: {\n            base64Image,\n            description: params.metadata.description,\n            websiteUrl: params.metadata.websiteUrl,\n            discordUrl: params.metadata.discordUrl,\n            twitterUrl: params.metadata.twitterUrl,\n            telegramUrl: params.metadata.telegramUrl,\n        },\n    });\n    return tokenUri;\n};\nexports.generateTokenUri = generateTokenUri;\nconst getAmountWithSlippage = (amount, slippage, swapType) => {\n    if (amount == null) {\n        return 0n;\n    }\n    const absAmount = amount < 0n ? -amount : amount;\n    const slippageMultiplier = swapType === \"EXACT_IN\"\n        ? BigInt(1e18) - (0, viem_1.parseEther)(slippage)\n        : BigInt(1e18) + (0, viem_1.parseEther)(slippage);\n    return (absAmount * slippageMultiplier) / BigInt(1e18);\n};\nexports.getAmountWithSlippage = getAmountWithSlippage;\nconst ETH = viem_1.zeroAddress;\nconst ethToMemecoin = (params) => {\n    const flETH = constants_1.FLETHAddress[params.chainId];\n    const flETHHooks = constants_1.FLETHHooksAddress[params.chainId];\n    const flaunchHooks = constants_1.FlaunchPositionManagerAddress[params.chainId];\n    // Determine actions based on swapType\n    const v4Actions = (\"0x\" +\n        (params.swapType === \"EXACT_IN\" ? constants_1.V4Actions.SWAP_EXACT_IN : constants_1.V4Actions.SWAP_EXACT_OUT) +\n        constants_1.V4Actions.SETTLE_ALL +\n        constants_1.V4Actions.TAKE_ALL);\n    // Initialize variables for path and v4Params\n    let path;\n    let v4Params;\n    // Configure path and parameters based on swapType\n    if (params.swapType === \"EXACT_IN\") {\n        if (params.amountIn == null || params.amountOutMin == null) {\n            throw new Error(\"amountIn and amountOutMin are required for EXACT_IN swap\");\n        }\n        // Path for 'EXACT_IN' swap\n        path = [\n            {\n                intermediateCurrency: flETH,\n                fee: 0,\n                tickSpacing: 60,\n                hooks: flETHHooks,\n                hookData: \"0x\",\n            },\n            {\n                intermediateCurrency: params.memecoin,\n                fee: 0,\n                tickSpacing: 60,\n                hooks: flaunchHooks,\n                hookData: (0, viem_1.encodeAbiParameters)([{ type: \"address\", name: \"referrer\" }], [params.referrer ?? viem_1.zeroAddress]),\n            },\n        ];\n        // Parameters for 'EXACT_IN' swap\n        v4Params = (0, viem_1.encodeAbiParameters)(constants_1.IV4RouterAbiExactInput, [\n            {\n                currencyIn: ETH,\n                path: path,\n                amountIn: params.amountIn,\n                amountOutMinimum: params.amountOutMin,\n            },\n        ]);\n    }\n    else {\n        if (params.amountOut == null || params.amountInMax == null) {\n            throw new Error(\"amountOut and amountInMax are required for EXACT_OUT swap\");\n        }\n        // Path for 'EXACT_OUT' swap\n        path = [\n            {\n                fee: 0,\n                tickSpacing: 60,\n                hookData: \"0x\",\n                hooks: flETHHooks,\n                intermediateCurrency: ETH,\n            },\n            {\n                fee: 0,\n                tickSpacing: 60,\n                hooks: flaunchHooks,\n                intermediateCurrency: flETH,\n                hookData: (0, viem_1.encodeAbiParameters)([{ type: \"address\", name: \"referrer\" }], [params.referrer ?? viem_1.zeroAddress]),\n            },\n        ];\n        // Parameters for 'EXACT_OUT' swap\n        v4Params = (0, viem_1.encodeAbiParameters)(constants_1.IV4RouterAbiExactOutput, [\n            {\n                currencyOut: params.memecoin,\n                path: path,\n                amountOut: params.amountOut,\n                amountInMaximum: params.amountInMax,\n            },\n        ]);\n    }\n    // Common parameters for both swap types\n    const settleParams = (0, viem_1.encodeAbiParameters)([\n        {\n            type: \"address\",\n            name: \"currency\",\n        },\n        {\n            type: \"uint256\",\n            name: \"maxAmount\",\n        },\n    ], [\n        ETH,\n        params.swapType === \"EXACT_IN\"\n            ? (params.amountIn ?? viem_1.maxUint256)\n            : (params.amountInMax ?? viem_1.maxUint256),\n    ]);\n    const takeParams = (0, viem_1.encodeAbiParameters)([\n        {\n            type: \"address\",\n            name: \"currency\",\n        },\n        {\n            type: \"uint256\",\n            name: \"minAmount\",\n        },\n    ], [\n        params.memecoin,\n        params.swapType === \"EXACT_IN\"\n            ? (params.amountOutMin ?? viem_1.maxUint256)\n            : (params.amountOut ?? viem_1.maxUint256),\n    ]);\n    // Encode router data\n    const v4RouterData = (0, viem_1.encodeAbiParameters)([\n        { type: \"bytes\", name: \"actions\" },\n        { type: \"bytes[]\", name: \"params\" },\n    ], [v4Actions, [v4Params, settleParams, takeParams]]);\n    // Commands for Universal Router\n    const urCommands = (\"0x\" + constants_1.URCommands.V4_SWAP + constants_1.URCommands.SWEEP);\n    const sweepInput = (0, viem_1.encodeAbiParameters)([\n        { type: \"address\", name: \"token\" },\n        { type: \"address\", name: \"recipient\" },\n        { type: \"uint160\", name: \"amountIn\" },\n    ], [ETH, params.sender, 0n]);\n    // Encode calldata for Universal Router\n    const inputs = [v4RouterData, sweepInput];\n    const urExecuteCalldata = (0, viem_1.encodeFunctionData)({\n        abi: constants_1.UNIVERSAL_ROUTER_ABI,\n        functionName: \"execute\",\n        args: [urCommands, inputs],\n    });\n    return {\n        calldata: urExecuteCalldata,\n        commands: urCommands,\n        inputs,\n    };\n};\nexports.ethToMemecoin = ethToMemecoin;\n// @notice Beofre calling the UniversalRouter the user must have:\n// 1. Given the Permit2 contract allowance to spend the memecoin\nconst memecoinToEthWithPermit2 = (params) => {\n    const flETH = constants_1.FLETHAddress[params.chainId];\n    const flETHHooks = constants_1.FLETHHooksAddress[params.chainId];\n    const flaunchHooks = constants_1.FlaunchPositionManagerAddress[params.chainId];\n    const v4Actions = (\"0x\" +\n        constants_1.V4Actions.SWAP_EXACT_IN +\n        constants_1.V4Actions.SETTLE_ALL +\n        constants_1.V4Actions.TAKE_ALL);\n    const v4ExactInputParams = (0, viem_1.encodeAbiParameters)(constants_1.IV4RouterAbiExactInput, [\n        {\n            currencyIn: params.memecoin,\n            path: [\n                {\n                    intermediateCurrency: flETH,\n                    fee: 0,\n                    tickSpacing: 60,\n                    hooks: flaunchHooks,\n                    hookData: (0, viem_1.encodeAbiParameters)([\n                        {\n                            type: \"address\",\n                            name: \"referrer\",\n                        },\n                    ], [params.referrer ?? viem_1.zeroAddress]),\n                },\n                {\n                    intermediateCurrency: ETH,\n                    fee: 0,\n                    tickSpacing: 60,\n                    hooks: flETHHooks,\n                    hookData: \"0x\",\n                },\n            ],\n            amountIn: params.amountIn,\n            amountOutMinimum: params.ethOutMin,\n        },\n    ]);\n    const settleParams = (0, viem_1.encodeAbiParameters)([\n        {\n            type: \"address\",\n            name: \"currency\",\n        },\n        {\n            type: \"uint256\",\n            name: \"maxAmount\",\n        },\n    ], [params.memecoin, params.amountIn]);\n    const takeParams = (0, viem_1.encodeAbiParameters)([\n        {\n            type: \"address\",\n            name: \"currency\",\n        },\n        {\n            type: \"uint256\",\n            name: \"minAmount\",\n        },\n    ], [ETH, params.ethOutMin]);\n    const v4RouterData = (0, viem_1.encodeAbiParameters)([\n        { type: \"bytes\", name: \"actions\" },\n        { type: \"bytes[]\", name: \"params\" },\n    ], [v4Actions, [v4ExactInputParams, settleParams, takeParams]]);\n    if (params.signature && params.permitSingle) {\n        const urCommands = (\"0x\" + constants_1.URCommands.PERMIT2_PERMIT + constants_1.URCommands.V4_SWAP);\n        const permit2PermitInput = (0, viem_1.encodeAbiParameters)([\n            {\n                type: \"tuple\",\n                components: [\n                    {\n                        type: \"tuple\",\n                        components: [\n                            { type: \"address\", name: \"token\" },\n                            { type: \"uint160\", name: \"amount\" },\n                            { type: \"uint48\", name: \"expiration\" },\n                            { type: \"uint48\", name: \"nonce\" },\n                        ],\n                        name: \"details\",\n                    },\n                    { type: \"address\", name: \"spender\" },\n                    { type: \"uint256\", name: \"sigDeadline\" },\n                ],\n                name: \"PermitSingle\",\n            },\n            { type: \"bytes\", name: \"signature\" },\n        ], [params.permitSingle, params.signature]);\n        const inputs = [permit2PermitInput, v4RouterData];\n        const urExecuteCalldata = (0, viem_1.encodeFunctionData)({\n            abi: constants_1.UNIVERSAL_ROUTER_ABI,\n            functionName: \"execute\",\n            args: [urCommands, inputs],\n        });\n        return {\n            calldata: urExecuteCalldata,\n            commands: urCommands,\n            inputs,\n        };\n    }\n    else {\n        const urCommands = (\"0x\" + constants_1.URCommands.V4_SWAP);\n        const inputs = [v4RouterData];\n        const urExecuteCalldata = (0, viem_1.encodeFunctionData)({\n            abi: constants_1.UNIVERSAL_ROUTER_ABI,\n            functionName: \"execute\",\n            args: [urCommands, inputs],\n        });\n        return {\n            calldata: urExecuteCalldata,\n            commands: urCommands,\n            inputs,\n        };\n    }\n};\nexports.memecoinToEthWithPermit2 = memecoinToEthWithPermit2;\nconst getSwapAmountsFromLog = ({ filteredPoolSwapEvent, coinAddress, chainId, }) => {\n    const { flAmount0, flAmount1, flFee0, flFee1, ispAmount0, ispAmount1, ispFee0, ispFee1, uniAmount0, uniAmount1, uniFee0, uniFee1, } = filteredPoolSwapEvent;\n    const currency0Delta = flAmount0 + ispAmount0 + uniAmount0;\n    const currency1Delta = flAmount1 + ispAmount1 + uniAmount1;\n    const currency0Fees = flFee0 + ispFee0 + uniFee0;\n    const currency1Fees = flFee1 + ispFee1 + uniFee1;\n    let feesIsInFLETH;\n    let swapType;\n    const flETHIsCurrencyZero = coinAddress > constants_1.FLETHAddress[chainId];\n    if (flETHIsCurrencyZero) {\n        swapType = currency0Delta < 0 ? \"BUY\" : \"SELL\";\n        feesIsInFLETH = currency0Fees < 0;\n    }\n    else {\n        swapType = currency1Delta < 0 ? \"BUY\" : \"SELL\";\n        feesIsInFLETH = currency1Fees < 0;\n    }\n    const absCurrency0Delta = currency0Delta < 0 ? -currency0Delta : currency0Delta;\n    const absCurrency1Delta = currency1Delta < 0 ? -currency1Delta : currency1Delta;\n    const absCurrency0Fees = currency0Fees < 0 ? -currency0Fees : currency0Fees;\n    const absCurrency1Fees = currency1Fees < 0 ? -currency1Fees : currency1Fees;\n    const fees = {\n        isInFLETH: feesIsInFLETH,\n        amount: flETHIsCurrencyZero\n            ? feesIsInFLETH\n                ? absCurrency0Fees\n                : absCurrency1Fees\n            : feesIsInFLETH\n                ? absCurrency1Fees\n                : absCurrency0Fees,\n    };\n    if (swapType === \"BUY\") {\n        return {\n            coinsBought: flETHIsCurrencyZero\n                ? absCurrency1Delta - (!fees.isInFLETH ? fees.amount : 0n)\n                : absCurrency0Delta - (!fees.isInFLETH ? fees.amount : 0n),\n            ethSold: flETHIsCurrencyZero\n                ? absCurrency0Delta - (fees.isInFLETH ? fees.amount : 0n)\n                : absCurrency1Delta - (fees.isInFLETH ? fees.amount : 0n),\n        };\n    }\n    else {\n        return {\n            coinsSold: flETHIsCurrencyZero\n                ? absCurrency1Delta - (!fees.isInFLETH ? fees.amount : 0n)\n                : absCurrency0Delta - (!fees.isInFLETH ? fees.amount : 0n),\n            ethBought: flETHIsCurrencyZero\n                ? absCurrency0Delta - (fees.isInFLETH ? fees.amount : 0n)\n                : absCurrency1Delta - (fees.isInFLETH ? fees.amount : 0n),\n        };\n    }\n};\nexports.getSwapAmountsFromLog = getSwapAmountsFromLog;\nconst getSwapAmountsFromReceipt = ({ receipt, coinAddress, chainId, }) => {\n    const filteredPoolSwapEvent = receipt.logs\n        .map(log => {\n        try {\n            if (log.address.toLowerCase() !== constants_1.FlaunchPositionManagerAddress[chainId].toLowerCase()) {\n                return null;\n            }\n            const event = (0, viem_1.decodeEventLog)({\n                abi: constants_1.POSITION_MANAGER_ABI,\n                data: log.data,\n                topics: log.topics,\n            });\n            return event.eventName === \"PoolSwap\" ? event.args : null;\n        }\n        catch {\n            return null;\n        }\n    })\n        .filter((event) => event !== null)[0];\n    return (0, exports.getSwapAmountsFromLog)({\n        filteredPoolSwapEvent,\n        coinAddress,\n        chainId,\n    });\n};\nexports.getSwapAmountsFromReceipt = getSwapAmountsFromReceipt;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9mbGF1bmNoL3V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlDQUFpQyxHQUFHLDZCQUE2QixHQUFHLGdDQUFnQyxHQUFHLHFCQUFxQixHQUFHLDZCQUE2QixHQUFHLHdCQUF3QjtBQUN2TCxlQUFlLG1CQUFPLENBQUMscURBQU07QUFDN0Isb0JBQW9CLG1CQUFPLENBQUMsdUdBQWE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsZ0NBQWdDO0FBQzdEO0FBQ0E7QUFDQSw0QkFBNEIsa0JBQWtCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBLGtEQUFrRDtBQUNsRDtBQUNBLDRDQUE0QyxnQkFBZ0I7QUFDNUQsaURBQWlELHVCQUF1QjtBQUN4RSxrREFBa0QsZ0JBQWdCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsd0JBQXdCO0FBQ2pFLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsK0RBQStELHFDQUFxQztBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELGNBQWM7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qyx3QkFBd0I7QUFDakU7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDhEQUE4RCxxQ0FBcUM7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxjQUFjO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixrQkFBa0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHFCQUFxQixxQkFBcUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxvQkFBb0I7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELG1DQUFtQztBQUNoRyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsbUNBQW1DO0FBQ2hHLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsZ0NBQWdDO0FBQzFDLFVBQVUsaUNBQWlDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxnQ0FBZ0M7QUFDMUMsVUFBVSxvQ0FBb0M7QUFDOUMsVUFBVSxtQ0FBbUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsVUFBVSxnQ0FBZ0M7QUFDMUMsVUFBVSxpQ0FBaUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsZ0NBQWdDO0FBQzlELDhCQUE4QixpQ0FBaUM7QUFDL0QsOEJBQThCLG9DQUFvQztBQUNsRSw4QkFBOEIsK0JBQStCO0FBQzdEO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsc0JBQXNCLGtDQUFrQztBQUN4RCxzQkFBc0Isc0NBQXNDO0FBQzVEO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsY0FBYyxrQ0FBa0M7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLGlDQUFpQyw4Q0FBOEM7QUFDL0UsWUFBWSw0SEFBNEg7QUFDeEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QixxQ0FBcUMsZ0NBQWdDO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cnZpdmFsLWZ1bi8uL25vZGVfbW9kdWxlcy9AY29pbmJhc2UvYWdlbnRraXQvZGlzdC9hY3Rpb24tcHJvdmlkZXJzL2ZsYXVuY2gvdXRpbHMuanM/MGU3OCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0U3dhcEFtb3VudHNGcm9tUmVjZWlwdCA9IGV4cG9ydHMuZ2V0U3dhcEFtb3VudHNGcm9tTG9nID0gZXhwb3J0cy5tZW1lY29pblRvRXRoV2l0aFBlcm1pdDIgPSBleHBvcnRzLmV0aFRvTWVtZWNvaW4gPSBleHBvcnRzLmdldEFtb3VudFdpdGhTbGlwcGFnZSA9IGV4cG9ydHMuZ2VuZXJhdGVUb2tlblVyaSA9IHZvaWQgMDtcbmNvbnN0IHZpZW1fMSA9IHJlcXVpcmUoXCJ2aWVtXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG4vKipcbiAqIFVwbG9hZHMgYSBiYXNlNjQgaW1hZ2UgdG8gSVBGUyB1c2luZyBQaW5hdGFcbiAqXG4gKiBAcGFyYW0gcGFyYW1zIC0gQ29uZmlndXJhdGlvbiBhbmQgYmFzZTY0IGltYWdlIGRhdGFcbiAqIEBwYXJhbSBwYXJhbXMucGluYXRhQ29uZmlnIC0gUGluYXRhIGNvbmZpZ3VyYXRpb24gaW5jbHVkaW5nIEpXVFxuICogQHBhcmFtIHBhcmFtcy5iYXNlNjRJbWFnZSAtIEJhc2U2NCBlbmNvZGVkIGltYWdlIGRhdGFcbiAqIEBwYXJhbSBwYXJhbXMubmFtZSAtIE9wdGlvbmFsIG5hbWUgZm9yIHRoZSB1cGxvYWRlZCBmaWxlXG4gKiBAcGFyYW0gcGFyYW1zLm1ldGFkYXRhIC0gT3B0aW9uYWwgbWV0YWRhdGEga2V5LXZhbHVlIHBhaXJzXG4gKiBAcmV0dXJucyBVcGxvYWQgcmVzcG9uc2Ugd2l0aCBDSUQgYW5kIG90aGVyIGRldGFpbHNcbiAqL1xuY29uc3QgdXBsb2FkSW1hZ2VUb0lQRlMgPSBhc3luYyAocGFyYW1zKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgICAgICAgLy8gQ29udmVydCBiYXNlNjQgdG8gQmxvYiBhbmQgdGhlbiB0byBGaWxlXG4gICAgICAgIC8vIFJlbW92ZSBkYXRhIFVSTCBwcmVmaXggaWYgcHJlc2VudCAoZS5nLiwgXCJkYXRhOmltYWdlL2pwZWc7YmFzZTY0LFwiKVxuICAgICAgICBjb25zdCBiYXNlNjREYXRhID0gcGFyYW1zLmJhc2U2NEltYWdlLnNwbGl0KFwiLFwiKVsxXSB8fCBwYXJhbXMuYmFzZTY0SW1hZ2U7XG4gICAgICAgIGNvbnN0IGJ5dGVDaGFyYWN0ZXJzID0gYXRvYihiYXNlNjREYXRhKTtcbiAgICAgICAgY29uc3QgYnl0ZUFycmF5cyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBvZmZzZXQgPSAwOyBvZmZzZXQgPCBieXRlQ2hhcmFjdGVycy5sZW5ndGg7IG9mZnNldCArPSAxMDI0KSB7XG4gICAgICAgICAgICBjb25zdCBzbGljZSA9IGJ5dGVDaGFyYWN0ZXJzLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgMTAyNCk7XG4gICAgICAgICAgICBjb25zdCBieXRlTnVtYmVycyA9IG5ldyBBcnJheShzbGljZS5sZW5ndGgpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbGljZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGJ5dGVOdW1iZXJzW2ldID0gc2xpY2UuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGJ5dGVBcnJheSA9IG5ldyBVaW50OEFycmF5KGJ5dGVOdW1iZXJzKTtcbiAgICAgICAgICAgIGJ5dGVBcnJheXMucHVzaChieXRlQXJyYXkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIERldGVjdCBtaW1lIHR5cGUgZnJvbSBiYXNlNjQgc3RyaW5nXG4gICAgICAgIGxldCBtaW1lVHlwZSA9IFwiaW1hZ2UvcG5nXCI7IC8vIGRlZmF1bHRcbiAgICAgICAgaWYgKHBhcmFtcy5iYXNlNjRJbWFnZS5zdGFydHNXaXRoKFwiZGF0YTpcIikpIHtcbiAgICAgICAgICAgIG1pbWVUeXBlID0gcGFyYW1zLmJhc2U2NEltYWdlLnNwbGl0KFwiO1wiKVswXS5zcGxpdChcIjpcIilbMV07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYmxvYiA9IG5ldyBCbG9iKGJ5dGVBcnJheXMsIHsgdHlwZTogbWltZVR5cGUgfSk7XG4gICAgICAgIGNvbnN0IGZpbGVOYW1lID0gcGFyYW1zLm5hbWUgfHwgYGltYWdlLiR7bWltZVR5cGUuc3BsaXQoXCIvXCIpWzFdfWA7XG4gICAgICAgIGNvbnN0IGZpbGUgPSBuZXcgRmlsZShbYmxvYl0sIGZpbGVOYW1lLCB7IHR5cGU6IG1pbWVUeXBlIH0pO1xuICAgICAgICBmb3JtRGF0YS5hcHBlbmQoXCJmaWxlXCIsIGZpbGUpO1xuICAgICAgICBjb25zdCBwaW5hdGFNZXRhZGF0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6IHBhcmFtcy5uYW1lIHx8IG51bGwsXG4gICAgICAgICAgICBrZXl2YWx1ZXM6IHBhcmFtcy5tZXRhZGF0YSB8fCB7fSxcbiAgICAgICAgfTtcbiAgICAgICAgZm9ybURhdGEuYXBwZW5kKFwicGluYXRhTWV0YWRhdGFcIiwgSlNPTi5zdHJpbmdpZnkocGluYXRhTWV0YWRhdGEpKTtcbiAgICAgICAgY29uc3QgcGluYXRhT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGNpZFZlcnNpb246IDEsXG4gICAgICAgIH07XG4gICAgICAgIGZvcm1EYXRhLmFwcGVuZChcInBpbmF0YU9wdGlvbnNcIiwgSlNPTi5zdHJpbmdpZnkocGluYXRhT3B0aW9ucykpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKFwiaHR0cHM6Ly9hcGkucGluYXRhLmNsb3VkL3Bpbm5pbmcvcGluRmlsZVRvSVBGU1wiLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHtwYXJhbXMucGluYXRhQ29uZmlnLmp3dH1gLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJvZHk6IGZvcm1EYXRhLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byB1cGxvYWQgaW1hZ2UgdG8gSVBGUzogJHtlcnJvci5tZXNzYWdlIHx8IHJlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIElwZnNIYXNoOiBkYXRhLklwZnNIYXNoLFxuICAgICAgICAgICAgUGluU2l6ZTogZGF0YS5QaW5TaXplLFxuICAgICAgICAgICAgVGltZXN0YW1wOiBkYXRhLlRpbWVzdGFtcCxcbiAgICAgICAgICAgIGlzRHVwbGljYXRlOiBkYXRhLmlzRHVwbGljYXRlIHx8IGZhbHNlLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHVwbG9hZCBpbWFnZSB0byBJUEZTOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxufTtcbi8qKlxuICogVXBsb2FkcyBKU09OIGRhdGEgdG8gSVBGUyB1c2luZyBQaW5hdGFcbiAqXG4gKiBAcGFyYW0gcGFyYW1zIC0gQ29uZmlndXJhdGlvbiBhbmQgSlNPTiBkYXRhXG4gKiBAcGFyYW0gcGFyYW1zLnBpbmF0YUNvbmZpZyAtIFBpbmF0YSBjb25maWd1cmF0aW9uIGluY2x1ZGluZyBKV1RcbiAqIEBwYXJhbSBwYXJhbXMuanNvbiAtIEpTT04gZGF0YSB0byB1cGxvYWRcbiAqIEBwYXJhbSBwYXJhbXMubmFtZSAtIE9wdGlvbmFsIG5hbWUgZm9yIHRoZSB1cGxvYWRlZCBmaWxlXG4gKiBAcGFyYW0gcGFyYW1zLm1ldGFkYXRhIC0gT3B0aW9uYWwgbWV0YWRhdGEga2V5LXZhbHVlIHBhaXJzXG4gKiBAcmV0dXJucyBVcGxvYWQgcmVzcG9uc2Ugd2l0aCBDSUQgYW5kIG90aGVyIGRldGFpbHNcbiAqL1xuY29uc3QgdXBsb2FkSnNvblRvSVBGUyA9IGFzeW5jIChwYXJhbXMpID0+IHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXF1ZXN0Qm9keSA9IHtcbiAgICAgICAgICAgIHBpbmF0YU9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICBjaWRWZXJzaW9uOiAxLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBpbmF0YU1ldGFkYXRhOiB7XG4gICAgICAgICAgICAgICAgbmFtZTogcGFyYW1zLm5hbWUgfHwgbnVsbCxcbiAgICAgICAgICAgICAgICBrZXl2YWx1ZXM6IHBhcmFtcy5tZXRhZGF0YSB8fCB7fSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwaW5hdGFDb250ZW50OiBwYXJhbXMuanNvbixcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcImh0dHBzOi8vYXBpLnBpbmF0YS5jbG91ZC9waW5uaW5nL3BpbkpTT05Ub0lQRlNcIiwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7cGFyYW1zLnBpbmF0YUNvbmZpZy5qd3R9YCxcbiAgICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShyZXF1ZXN0Qm9keSksXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHVwbG9hZCBKU09OIHRvIElQRlM6ICR7ZXJyb3IubWVzc2FnZSB8fCByZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBJcGZzSGFzaDogZGF0YS5JcGZzSGFzaCxcbiAgICAgICAgICAgIFBpblNpemU6IGRhdGEuUGluU2l6ZSxcbiAgICAgICAgICAgIFRpbWVzdGFtcDogZGF0YS5UaW1lc3RhbXAsXG4gICAgICAgICAgICBpc0R1cGxpY2F0ZTogZGF0YS5pc0R1cGxpY2F0ZSB8fCBmYWxzZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byB1cGxvYWQgSlNPTiB0byBJUEZTOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxufTtcbmNvbnN0IGdlbmVyYXRlVG9rZW5VcmlCYXNlNjRJbWFnZSA9IGFzeW5jIChuYW1lLCBwYXJhbXMpID0+IHtcbiAgICAvLyAxLiB1cGxvYWQgaW1hZ2UgdG8gSVBGU1xuICAgIGNvbnN0IGltYWdlUmVzID0gYXdhaXQgdXBsb2FkSW1hZ2VUb0lQRlMoe1xuICAgICAgICBwaW5hdGFDb25maWc6IHBhcmFtcy5waW5hdGFDb25maWcsXG4gICAgICAgIGJhc2U2NEltYWdlOiBwYXJhbXMubWV0YWRhdGEuYmFzZTY0SW1hZ2UsXG4gICAgfSk7XG4gICAgLy8gMi4gdXBsb2FkIG1ldGFkYXRhIHRvIElQRlNcbiAgICBjb25zdCBjb2luTWV0YWRhdGEgPSB7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBwYXJhbXMubWV0YWRhdGEuZGVzY3JpcHRpb24sXG4gICAgICAgIGltYWdlOiBgaXBmczovLyR7aW1hZ2VSZXMuSXBmc0hhc2h9YCxcbiAgICAgICAgZXh0ZXJuYWxfbGluazogcGFyYW1zLm1ldGFkYXRhLndlYnNpdGVVcmwgfHwgXCJcIixcbiAgICAgICAgY29sbGFib3JhdG9yczogW10sXG4gICAgICAgIGRpc2NvcmRVcmw6IHBhcmFtcy5tZXRhZGF0YS5kaXNjb3JkVXJsIHx8IFwiXCIsXG4gICAgICAgIHR3aXR0ZXJVcmw6IHBhcmFtcy5tZXRhZGF0YS50d2l0dGVyVXJsIHx8IFwiXCIsXG4gICAgICAgIHRlbGVncmFtVXJsOiBwYXJhbXMubWV0YWRhdGEudGVsZWdyYW1VcmwgfHwgXCJcIixcbiAgICB9O1xuICAgIGNvbnN0IG1ldGFkYXRhUmVzID0gYXdhaXQgdXBsb2FkSnNvblRvSVBGUyh7XG4gICAgICAgIHBpbmF0YUNvbmZpZzogcGFyYW1zLnBpbmF0YUNvbmZpZyxcbiAgICAgICAganNvbjogY29pbk1ldGFkYXRhLFxuICAgIH0pO1xuICAgIHJldHVybiBgaXBmczovLyR7bWV0YWRhdGFSZXMuSXBmc0hhc2h9YDtcbn07XG5jb25zdCBnZW5lcmF0ZVRva2VuVXJpID0gYXN5bmMgKG5hbWUsIHBhcmFtcykgPT4ge1xuICAgIC8vIDEuIGdldCBiYXNlNjRJbWFnZSBmcm9tIGltYWdlVXJsXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChwYXJhbXMubWV0YWRhdGEuaW1hZ2VVcmwpO1xuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggaW1hZ2U6ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICB9XG4gICAgY29uc3QgYXJyYXlCdWZmZXIgPSBhd2FpdCByZXNwb25zZS5hcnJheUJ1ZmZlcigpO1xuICAgIGNvbnN0IGJhc2U2NEltYWdlID0gQnVmZmVyLmZyb20oYXJyYXlCdWZmZXIpLnRvU3RyaW5nKFwiYmFzZTY0XCIpO1xuICAgIC8vIDIuIGdlbmVyYXRlIHRva2VuIHVyaVxuICAgIGNvbnN0IHRva2VuVXJpID0gYXdhaXQgZ2VuZXJhdGVUb2tlblVyaUJhc2U2NEltYWdlKG5hbWUsIHtcbiAgICAgICAgcGluYXRhQ29uZmlnOiBwYXJhbXMucGluYXRhQ29uZmlnLFxuICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgICAgYmFzZTY0SW1hZ2UsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogcGFyYW1zLm1ldGFkYXRhLmRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgd2Vic2l0ZVVybDogcGFyYW1zLm1ldGFkYXRhLndlYnNpdGVVcmwsXG4gICAgICAgICAgICBkaXNjb3JkVXJsOiBwYXJhbXMubWV0YWRhdGEuZGlzY29yZFVybCxcbiAgICAgICAgICAgIHR3aXR0ZXJVcmw6IHBhcmFtcy5tZXRhZGF0YS50d2l0dGVyVXJsLFxuICAgICAgICAgICAgdGVsZWdyYW1Vcmw6IHBhcmFtcy5tZXRhZGF0YS50ZWxlZ3JhbVVybCxcbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICByZXR1cm4gdG9rZW5Vcmk7XG59O1xuZXhwb3J0cy5nZW5lcmF0ZVRva2VuVXJpID0gZ2VuZXJhdGVUb2tlblVyaTtcbmNvbnN0IGdldEFtb3VudFdpdGhTbGlwcGFnZSA9IChhbW91bnQsIHNsaXBwYWdlLCBzd2FwVHlwZSkgPT4ge1xuICAgIGlmIChhbW91bnQgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gMG47XG4gICAgfVxuICAgIGNvbnN0IGFic0Ftb3VudCA9IGFtb3VudCA8IDBuID8gLWFtb3VudCA6IGFtb3VudDtcbiAgICBjb25zdCBzbGlwcGFnZU11bHRpcGxpZXIgPSBzd2FwVHlwZSA9PT0gXCJFWEFDVF9JTlwiXG4gICAgICAgID8gQmlnSW50KDFlMTgpIC0gKDAsIHZpZW1fMS5wYXJzZUV0aGVyKShzbGlwcGFnZSlcbiAgICAgICAgOiBCaWdJbnQoMWUxOCkgKyAoMCwgdmllbV8xLnBhcnNlRXRoZXIpKHNsaXBwYWdlKTtcbiAgICByZXR1cm4gKGFic0Ftb3VudCAqIHNsaXBwYWdlTXVsdGlwbGllcikgLyBCaWdJbnQoMWUxOCk7XG59O1xuZXhwb3J0cy5nZXRBbW91bnRXaXRoU2xpcHBhZ2UgPSBnZXRBbW91bnRXaXRoU2xpcHBhZ2U7XG5jb25zdCBFVEggPSB2aWVtXzEuemVyb0FkZHJlc3M7XG5jb25zdCBldGhUb01lbWVjb2luID0gKHBhcmFtcykgPT4ge1xuICAgIGNvbnN0IGZsRVRIID0gY29uc3RhbnRzXzEuRkxFVEhBZGRyZXNzW3BhcmFtcy5jaGFpbklkXTtcbiAgICBjb25zdCBmbEVUSEhvb2tzID0gY29uc3RhbnRzXzEuRkxFVEhIb29rc0FkZHJlc3NbcGFyYW1zLmNoYWluSWRdO1xuICAgIGNvbnN0IGZsYXVuY2hIb29rcyA9IGNvbnN0YW50c18xLkZsYXVuY2hQb3NpdGlvbk1hbmFnZXJBZGRyZXNzW3BhcmFtcy5jaGFpbklkXTtcbiAgICAvLyBEZXRlcm1pbmUgYWN0aW9ucyBiYXNlZCBvbiBzd2FwVHlwZVxuICAgIGNvbnN0IHY0QWN0aW9ucyA9IChcIjB4XCIgK1xuICAgICAgICAocGFyYW1zLnN3YXBUeXBlID09PSBcIkVYQUNUX0lOXCIgPyBjb25zdGFudHNfMS5WNEFjdGlvbnMuU1dBUF9FWEFDVF9JTiA6IGNvbnN0YW50c18xLlY0QWN0aW9ucy5TV0FQX0VYQUNUX09VVCkgK1xuICAgICAgICBjb25zdGFudHNfMS5WNEFjdGlvbnMuU0VUVExFX0FMTCArXG4gICAgICAgIGNvbnN0YW50c18xLlY0QWN0aW9ucy5UQUtFX0FMTCk7XG4gICAgLy8gSW5pdGlhbGl6ZSB2YXJpYWJsZXMgZm9yIHBhdGggYW5kIHY0UGFyYW1zXG4gICAgbGV0IHBhdGg7XG4gICAgbGV0IHY0UGFyYW1zO1xuICAgIC8vIENvbmZpZ3VyZSBwYXRoIGFuZCBwYXJhbWV0ZXJzIGJhc2VkIG9uIHN3YXBUeXBlXG4gICAgaWYgKHBhcmFtcy5zd2FwVHlwZSA9PT0gXCJFWEFDVF9JTlwiKSB7XG4gICAgICAgIGlmIChwYXJhbXMuYW1vdW50SW4gPT0gbnVsbCB8fCBwYXJhbXMuYW1vdW50T3V0TWluID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFtb3VudEluIGFuZCBhbW91bnRPdXRNaW4gYXJlIHJlcXVpcmVkIGZvciBFWEFDVF9JTiBzd2FwXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFBhdGggZm9yICdFWEFDVF9JTicgc3dhcFxuICAgICAgICBwYXRoID0gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybWVkaWF0ZUN1cnJlbmN5OiBmbEVUSCxcbiAgICAgICAgICAgICAgICBmZWU6IDAsXG4gICAgICAgICAgICAgICAgdGlja1NwYWNpbmc6IDYwLFxuICAgICAgICAgICAgICAgIGhvb2tzOiBmbEVUSEhvb2tzLFxuICAgICAgICAgICAgICAgIGhvb2tEYXRhOiBcIjB4XCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGludGVybWVkaWF0ZUN1cnJlbmN5OiBwYXJhbXMubWVtZWNvaW4sXG4gICAgICAgICAgICAgICAgZmVlOiAwLFxuICAgICAgICAgICAgICAgIHRpY2tTcGFjaW5nOiA2MCxcbiAgICAgICAgICAgICAgICBob29rczogZmxhdW5jaEhvb2tzLFxuICAgICAgICAgICAgICAgIGhvb2tEYXRhOiAoMCwgdmllbV8xLmVuY29kZUFiaVBhcmFtZXRlcnMpKFt7IHR5cGU6IFwiYWRkcmVzc1wiLCBuYW1lOiBcInJlZmVycmVyXCIgfV0sIFtwYXJhbXMucmVmZXJyZXIgPz8gdmllbV8xLnplcm9BZGRyZXNzXSksXG4gICAgICAgICAgICB9LFxuICAgICAgICBdO1xuICAgICAgICAvLyBQYXJhbWV0ZXJzIGZvciAnRVhBQ1RfSU4nIHN3YXBcbiAgICAgICAgdjRQYXJhbXMgPSAoMCwgdmllbV8xLmVuY29kZUFiaVBhcmFtZXRlcnMpKGNvbnN0YW50c18xLklWNFJvdXRlckFiaUV4YWN0SW5wdXQsIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjdXJyZW5jeUluOiBFVEgsXG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBhbW91bnRJbjogcGFyYW1zLmFtb3VudEluLFxuICAgICAgICAgICAgICAgIGFtb3VudE91dE1pbmltdW06IHBhcmFtcy5hbW91bnRPdXRNaW4sXG4gICAgICAgICAgICB9LFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChwYXJhbXMuYW1vdW50T3V0ID09IG51bGwgfHwgcGFyYW1zLmFtb3VudEluTWF4ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFtb3VudE91dCBhbmQgYW1vdW50SW5NYXggYXJlIHJlcXVpcmVkIGZvciBFWEFDVF9PVVQgc3dhcFwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQYXRoIGZvciAnRVhBQ1RfT1VUJyBzd2FwXG4gICAgICAgIHBhdGggPSBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZmVlOiAwLFxuICAgICAgICAgICAgICAgIHRpY2tTcGFjaW5nOiA2MCxcbiAgICAgICAgICAgICAgICBob29rRGF0YTogXCIweFwiLFxuICAgICAgICAgICAgICAgIGhvb2tzOiBmbEVUSEhvb2tzLFxuICAgICAgICAgICAgICAgIGludGVybWVkaWF0ZUN1cnJlbmN5OiBFVEgsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGZlZTogMCxcbiAgICAgICAgICAgICAgICB0aWNrU3BhY2luZzogNjAsXG4gICAgICAgICAgICAgICAgaG9va3M6IGZsYXVuY2hIb29rcyxcbiAgICAgICAgICAgICAgICBpbnRlcm1lZGlhdGVDdXJyZW5jeTogZmxFVEgsXG4gICAgICAgICAgICAgICAgaG9va0RhdGE6ICgwLCB2aWVtXzEuZW5jb2RlQWJpUGFyYW1ldGVycykoW3sgdHlwZTogXCJhZGRyZXNzXCIsIG5hbWU6IFwicmVmZXJyZXJcIiB9XSwgW3BhcmFtcy5yZWZlcnJlciA/PyB2aWVtXzEuemVyb0FkZHJlc3NdKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8vIFBhcmFtZXRlcnMgZm9yICdFWEFDVF9PVVQnIHN3YXBcbiAgICAgICAgdjRQYXJhbXMgPSAoMCwgdmllbV8xLmVuY29kZUFiaVBhcmFtZXRlcnMpKGNvbnN0YW50c18xLklWNFJvdXRlckFiaUV4YWN0T3V0cHV0LCBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY3VycmVuY3lPdXQ6IHBhcmFtcy5tZW1lY29pbixcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIGFtb3VudE91dDogcGFyYW1zLmFtb3VudE91dCxcbiAgICAgICAgICAgICAgICBhbW91bnRJbk1heGltdW06IHBhcmFtcy5hbW91bnRJbk1heCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICAvLyBDb21tb24gcGFyYW1ldGVycyBmb3IgYm90aCBzd2FwIHR5cGVzXG4gICAgY29uc3Qgc2V0dGxlUGFyYW1zID0gKDAsIHZpZW1fMS5lbmNvZGVBYmlQYXJhbWV0ZXJzKShbXG4gICAgICAgIHtcbiAgICAgICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICAgICAgbmFtZTogXCJjdXJyZW5jeVwiLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICB0eXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgICAgIG5hbWU6IFwibWF4QW1vdW50XCIsXG4gICAgICAgIH0sXG4gICAgXSwgW1xuICAgICAgICBFVEgsXG4gICAgICAgIHBhcmFtcy5zd2FwVHlwZSA9PT0gXCJFWEFDVF9JTlwiXG4gICAgICAgICAgICA/IChwYXJhbXMuYW1vdW50SW4gPz8gdmllbV8xLm1heFVpbnQyNTYpXG4gICAgICAgICAgICA6IChwYXJhbXMuYW1vdW50SW5NYXggPz8gdmllbV8xLm1heFVpbnQyNTYpLFxuICAgIF0pO1xuICAgIGNvbnN0IHRha2VQYXJhbXMgPSAoMCwgdmllbV8xLmVuY29kZUFiaVBhcmFtZXRlcnMpKFtcbiAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgICAgICBuYW1lOiBcImN1cnJlbmN5XCIsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICAgICAgbmFtZTogXCJtaW5BbW91bnRcIixcbiAgICAgICAgfSxcbiAgICBdLCBbXG4gICAgICAgIHBhcmFtcy5tZW1lY29pbixcbiAgICAgICAgcGFyYW1zLnN3YXBUeXBlID09PSBcIkVYQUNUX0lOXCJcbiAgICAgICAgICAgID8gKHBhcmFtcy5hbW91bnRPdXRNaW4gPz8gdmllbV8xLm1heFVpbnQyNTYpXG4gICAgICAgICAgICA6IChwYXJhbXMuYW1vdW50T3V0ID8/IHZpZW1fMS5tYXhVaW50MjU2KSxcbiAgICBdKTtcbiAgICAvLyBFbmNvZGUgcm91dGVyIGRhdGFcbiAgICBjb25zdCB2NFJvdXRlckRhdGEgPSAoMCwgdmllbV8xLmVuY29kZUFiaVBhcmFtZXRlcnMpKFtcbiAgICAgICAgeyB0eXBlOiBcImJ5dGVzXCIsIG5hbWU6IFwiYWN0aW9uc1wiIH0sXG4gICAgICAgIHsgdHlwZTogXCJieXRlc1tdXCIsIG5hbWU6IFwicGFyYW1zXCIgfSxcbiAgICBdLCBbdjRBY3Rpb25zLCBbdjRQYXJhbXMsIHNldHRsZVBhcmFtcywgdGFrZVBhcmFtc11dKTtcbiAgICAvLyBDb21tYW5kcyBmb3IgVW5pdmVyc2FsIFJvdXRlclxuICAgIGNvbnN0IHVyQ29tbWFuZHMgPSAoXCIweFwiICsgY29uc3RhbnRzXzEuVVJDb21tYW5kcy5WNF9TV0FQICsgY29uc3RhbnRzXzEuVVJDb21tYW5kcy5TV0VFUCk7XG4gICAgY29uc3Qgc3dlZXBJbnB1dCA9ICgwLCB2aWVtXzEuZW5jb2RlQWJpUGFyYW1ldGVycykoW1xuICAgICAgICB7IHR5cGU6IFwiYWRkcmVzc1wiLCBuYW1lOiBcInRva2VuXCIgfSxcbiAgICAgICAgeyB0eXBlOiBcImFkZHJlc3NcIiwgbmFtZTogXCJyZWNpcGllbnRcIiB9LFxuICAgICAgICB7IHR5cGU6IFwidWludDE2MFwiLCBuYW1lOiBcImFtb3VudEluXCIgfSxcbiAgICBdLCBbRVRILCBwYXJhbXMuc2VuZGVyLCAwbl0pO1xuICAgIC8vIEVuY29kZSBjYWxsZGF0YSBmb3IgVW5pdmVyc2FsIFJvdXRlclxuICAgIGNvbnN0IGlucHV0cyA9IFt2NFJvdXRlckRhdGEsIHN3ZWVwSW5wdXRdO1xuICAgIGNvbnN0IHVyRXhlY3V0ZUNhbGxkYXRhID0gKDAsIHZpZW1fMS5lbmNvZGVGdW5jdGlvbkRhdGEpKHtcbiAgICAgICAgYWJpOiBjb25zdGFudHNfMS5VTklWRVJTQUxfUk9VVEVSX0FCSSxcbiAgICAgICAgZnVuY3Rpb25OYW1lOiBcImV4ZWN1dGVcIixcbiAgICAgICAgYXJnczogW3VyQ29tbWFuZHMsIGlucHV0c10sXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY2FsbGRhdGE6IHVyRXhlY3V0ZUNhbGxkYXRhLFxuICAgICAgICBjb21tYW5kczogdXJDb21tYW5kcyxcbiAgICAgICAgaW5wdXRzLFxuICAgIH07XG59O1xuZXhwb3J0cy5ldGhUb01lbWVjb2luID0gZXRoVG9NZW1lY29pbjtcbi8vIEBub3RpY2UgQmVvZnJlIGNhbGxpbmcgdGhlIFVuaXZlcnNhbFJvdXRlciB0aGUgdXNlciBtdXN0IGhhdmU6XG4vLyAxLiBHaXZlbiB0aGUgUGVybWl0MiBjb250cmFjdCBhbGxvd2FuY2UgdG8gc3BlbmQgdGhlIG1lbWVjb2luXG5jb25zdCBtZW1lY29pblRvRXRoV2l0aFBlcm1pdDIgPSAocGFyYW1zKSA9PiB7XG4gICAgY29uc3QgZmxFVEggPSBjb25zdGFudHNfMS5GTEVUSEFkZHJlc3NbcGFyYW1zLmNoYWluSWRdO1xuICAgIGNvbnN0IGZsRVRISG9va3MgPSBjb25zdGFudHNfMS5GTEVUSEhvb2tzQWRkcmVzc1twYXJhbXMuY2hhaW5JZF07XG4gICAgY29uc3QgZmxhdW5jaEhvb2tzID0gY29uc3RhbnRzXzEuRmxhdW5jaFBvc2l0aW9uTWFuYWdlckFkZHJlc3NbcGFyYW1zLmNoYWluSWRdO1xuICAgIGNvbnN0IHY0QWN0aW9ucyA9IChcIjB4XCIgK1xuICAgICAgICBjb25zdGFudHNfMS5WNEFjdGlvbnMuU1dBUF9FWEFDVF9JTiArXG4gICAgICAgIGNvbnN0YW50c18xLlY0QWN0aW9ucy5TRVRUTEVfQUxMICtcbiAgICAgICAgY29uc3RhbnRzXzEuVjRBY3Rpb25zLlRBS0VfQUxMKTtcbiAgICBjb25zdCB2NEV4YWN0SW5wdXRQYXJhbXMgPSAoMCwgdmllbV8xLmVuY29kZUFiaVBhcmFtZXRlcnMpKGNvbnN0YW50c18xLklWNFJvdXRlckFiaUV4YWN0SW5wdXQsIFtcbiAgICAgICAge1xuICAgICAgICAgICAgY3VycmVuY3lJbjogcGFyYW1zLm1lbWVjb2luLFxuICAgICAgICAgICAgcGF0aDogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJtZWRpYXRlQ3VycmVuY3k6IGZsRVRILFxuICAgICAgICAgICAgICAgICAgICBmZWU6IDAsXG4gICAgICAgICAgICAgICAgICAgIHRpY2tTcGFjaW5nOiA2MCxcbiAgICAgICAgICAgICAgICAgICAgaG9va3M6IGZsYXVuY2hIb29rcyxcbiAgICAgICAgICAgICAgICAgICAgaG9va0RhdGE6ICgwLCB2aWVtXzEuZW5jb2RlQWJpUGFyYW1ldGVycykoW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwicmVmZXJyZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIF0sIFtwYXJhbXMucmVmZXJyZXIgPz8gdmllbV8xLnplcm9BZGRyZXNzXSksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGludGVybWVkaWF0ZUN1cnJlbmN5OiBFVEgsXG4gICAgICAgICAgICAgICAgICAgIGZlZTogMCxcbiAgICAgICAgICAgICAgICAgICAgdGlja1NwYWNpbmc6IDYwLFxuICAgICAgICAgICAgICAgICAgICBob29rczogZmxFVEhIb29rcyxcbiAgICAgICAgICAgICAgICAgICAgaG9va0RhdGE6IFwiMHhcIixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGFtb3VudEluOiBwYXJhbXMuYW1vdW50SW4sXG4gICAgICAgICAgICBhbW91bnRPdXRNaW5pbXVtOiBwYXJhbXMuZXRoT3V0TWluLFxuICAgICAgICB9LFxuICAgIF0pO1xuICAgIGNvbnN0IHNldHRsZVBhcmFtcyA9ICgwLCB2aWVtXzEuZW5jb2RlQWJpUGFyYW1ldGVycykoW1xuICAgICAgICB7XG4gICAgICAgICAgICB0eXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgICAgIG5hbWU6IFwiY3VycmVuY3lcIixcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgICAgICBuYW1lOiBcIm1heEFtb3VudFwiLFxuICAgICAgICB9LFxuICAgIF0sIFtwYXJhbXMubWVtZWNvaW4sIHBhcmFtcy5hbW91bnRJbl0pO1xuICAgIGNvbnN0IHRha2VQYXJhbXMgPSAoMCwgdmllbV8xLmVuY29kZUFiaVBhcmFtZXRlcnMpKFtcbiAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgICAgICBuYW1lOiBcImN1cnJlbmN5XCIsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICAgICAgbmFtZTogXCJtaW5BbW91bnRcIixcbiAgICAgICAgfSxcbiAgICBdLCBbRVRILCBwYXJhbXMuZXRoT3V0TWluXSk7XG4gICAgY29uc3QgdjRSb3V0ZXJEYXRhID0gKDAsIHZpZW1fMS5lbmNvZGVBYmlQYXJhbWV0ZXJzKShbXG4gICAgICAgIHsgdHlwZTogXCJieXRlc1wiLCBuYW1lOiBcImFjdGlvbnNcIiB9LFxuICAgICAgICB7IHR5cGU6IFwiYnl0ZXNbXVwiLCBuYW1lOiBcInBhcmFtc1wiIH0sXG4gICAgXSwgW3Y0QWN0aW9ucywgW3Y0RXhhY3RJbnB1dFBhcmFtcywgc2V0dGxlUGFyYW1zLCB0YWtlUGFyYW1zXV0pO1xuICAgIGlmIChwYXJhbXMuc2lnbmF0dXJlICYmIHBhcmFtcy5wZXJtaXRTaW5nbGUpIHtcbiAgICAgICAgY29uc3QgdXJDb21tYW5kcyA9IChcIjB4XCIgKyBjb25zdGFudHNfMS5VUkNvbW1hbmRzLlBFUk1JVDJfUEVSTUlUICsgY29uc3RhbnRzXzEuVVJDb21tYW5kcy5WNF9TV0FQKTtcbiAgICAgICAgY29uc3QgcGVybWl0MlBlcm1pdElucHV0ID0gKDAsIHZpZW1fMS5lbmNvZGVBYmlQYXJhbWV0ZXJzKShbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJ0dXBsZVwiLFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudHM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0dXBsZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50czogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgdHlwZTogXCJhZGRyZXNzXCIsIG5hbWU6IFwidG9rZW5cIiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgdHlwZTogXCJ1aW50MTYwXCIsIG5hbWU6IFwiYW1vdW50XCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHR5cGU6IFwidWludDQ4XCIsIG5hbWU6IFwiZXhwaXJhdGlvblwiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyB0eXBlOiBcInVpbnQ0OFwiLCBuYW1lOiBcIm5vbmNlXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcImRldGFpbHNcIixcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgeyB0eXBlOiBcImFkZHJlc3NcIiwgbmFtZTogXCJzcGVuZGVyXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgeyB0eXBlOiBcInVpbnQyNTZcIiwgbmFtZTogXCJzaWdEZWFkbGluZVwiIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBuYW1lOiBcIlBlcm1pdFNpbmdsZVwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHsgdHlwZTogXCJieXRlc1wiLCBuYW1lOiBcInNpZ25hdHVyZVwiIH0sXG4gICAgICAgIF0sIFtwYXJhbXMucGVybWl0U2luZ2xlLCBwYXJhbXMuc2lnbmF0dXJlXSk7XG4gICAgICAgIGNvbnN0IGlucHV0cyA9IFtwZXJtaXQyUGVybWl0SW5wdXQsIHY0Um91dGVyRGF0YV07XG4gICAgICAgIGNvbnN0IHVyRXhlY3V0ZUNhbGxkYXRhID0gKDAsIHZpZW1fMS5lbmNvZGVGdW5jdGlvbkRhdGEpKHtcbiAgICAgICAgICAgIGFiaTogY29uc3RhbnRzXzEuVU5JVkVSU0FMX1JPVVRFUl9BQkksXG4gICAgICAgICAgICBmdW5jdGlvbk5hbWU6IFwiZXhlY3V0ZVwiLFxuICAgICAgICAgICAgYXJnczogW3VyQ29tbWFuZHMsIGlucHV0c10sXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2FsbGRhdGE6IHVyRXhlY3V0ZUNhbGxkYXRhLFxuICAgICAgICAgICAgY29tbWFuZHM6IHVyQ29tbWFuZHMsXG4gICAgICAgICAgICBpbnB1dHMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCB1ckNvbW1hbmRzID0gKFwiMHhcIiArIGNvbnN0YW50c18xLlVSQ29tbWFuZHMuVjRfU1dBUCk7XG4gICAgICAgIGNvbnN0IGlucHV0cyA9IFt2NFJvdXRlckRhdGFdO1xuICAgICAgICBjb25zdCB1ckV4ZWN1dGVDYWxsZGF0YSA9ICgwLCB2aWVtXzEuZW5jb2RlRnVuY3Rpb25EYXRhKSh7XG4gICAgICAgICAgICBhYmk6IGNvbnN0YW50c18xLlVOSVZFUlNBTF9ST1VURVJfQUJJLFxuICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiBcImV4ZWN1dGVcIixcbiAgICAgICAgICAgIGFyZ3M6IFt1ckNvbW1hbmRzLCBpbnB1dHNdLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNhbGxkYXRhOiB1ckV4ZWN1dGVDYWxsZGF0YSxcbiAgICAgICAgICAgIGNvbW1hbmRzOiB1ckNvbW1hbmRzLFxuICAgICAgICAgICAgaW5wdXRzLFxuICAgICAgICB9O1xuICAgIH1cbn07XG5leHBvcnRzLm1lbWVjb2luVG9FdGhXaXRoUGVybWl0MiA9IG1lbWVjb2luVG9FdGhXaXRoUGVybWl0MjtcbmNvbnN0IGdldFN3YXBBbW91bnRzRnJvbUxvZyA9ICh7IGZpbHRlcmVkUG9vbFN3YXBFdmVudCwgY29pbkFkZHJlc3MsIGNoYWluSWQsIH0pID0+IHtcbiAgICBjb25zdCB7IGZsQW1vdW50MCwgZmxBbW91bnQxLCBmbEZlZTAsIGZsRmVlMSwgaXNwQW1vdW50MCwgaXNwQW1vdW50MSwgaXNwRmVlMCwgaXNwRmVlMSwgdW5pQW1vdW50MCwgdW5pQW1vdW50MSwgdW5pRmVlMCwgdW5pRmVlMSwgfSA9IGZpbHRlcmVkUG9vbFN3YXBFdmVudDtcbiAgICBjb25zdCBjdXJyZW5jeTBEZWx0YSA9IGZsQW1vdW50MCArIGlzcEFtb3VudDAgKyB1bmlBbW91bnQwO1xuICAgIGNvbnN0IGN1cnJlbmN5MURlbHRhID0gZmxBbW91bnQxICsgaXNwQW1vdW50MSArIHVuaUFtb3VudDE7XG4gICAgY29uc3QgY3VycmVuY3kwRmVlcyA9IGZsRmVlMCArIGlzcEZlZTAgKyB1bmlGZWUwO1xuICAgIGNvbnN0IGN1cnJlbmN5MUZlZXMgPSBmbEZlZTEgKyBpc3BGZWUxICsgdW5pRmVlMTtcbiAgICBsZXQgZmVlc0lzSW5GTEVUSDtcbiAgICBsZXQgc3dhcFR5cGU7XG4gICAgY29uc3QgZmxFVEhJc0N1cnJlbmN5WmVybyA9IGNvaW5BZGRyZXNzID4gY29uc3RhbnRzXzEuRkxFVEhBZGRyZXNzW2NoYWluSWRdO1xuICAgIGlmIChmbEVUSElzQ3VycmVuY3laZXJvKSB7XG4gICAgICAgIHN3YXBUeXBlID0gY3VycmVuY3kwRGVsdGEgPCAwID8gXCJCVVlcIiA6IFwiU0VMTFwiO1xuICAgICAgICBmZWVzSXNJbkZMRVRIID0gY3VycmVuY3kwRmVlcyA8IDA7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzd2FwVHlwZSA9IGN1cnJlbmN5MURlbHRhIDwgMCA/IFwiQlVZXCIgOiBcIlNFTExcIjtcbiAgICAgICAgZmVlc0lzSW5GTEVUSCA9IGN1cnJlbmN5MUZlZXMgPCAwO1xuICAgIH1cbiAgICBjb25zdCBhYnNDdXJyZW5jeTBEZWx0YSA9IGN1cnJlbmN5MERlbHRhIDwgMCA/IC1jdXJyZW5jeTBEZWx0YSA6IGN1cnJlbmN5MERlbHRhO1xuICAgIGNvbnN0IGFic0N1cnJlbmN5MURlbHRhID0gY3VycmVuY3kxRGVsdGEgPCAwID8gLWN1cnJlbmN5MURlbHRhIDogY3VycmVuY3kxRGVsdGE7XG4gICAgY29uc3QgYWJzQ3VycmVuY3kwRmVlcyA9IGN1cnJlbmN5MEZlZXMgPCAwID8gLWN1cnJlbmN5MEZlZXMgOiBjdXJyZW5jeTBGZWVzO1xuICAgIGNvbnN0IGFic0N1cnJlbmN5MUZlZXMgPSBjdXJyZW5jeTFGZWVzIDwgMCA/IC1jdXJyZW5jeTFGZWVzIDogY3VycmVuY3kxRmVlcztcbiAgICBjb25zdCBmZWVzID0ge1xuICAgICAgICBpc0luRkxFVEg6IGZlZXNJc0luRkxFVEgsXG4gICAgICAgIGFtb3VudDogZmxFVEhJc0N1cnJlbmN5WmVyb1xuICAgICAgICAgICAgPyBmZWVzSXNJbkZMRVRIXG4gICAgICAgICAgICAgICAgPyBhYnNDdXJyZW5jeTBGZWVzXG4gICAgICAgICAgICAgICAgOiBhYnNDdXJyZW5jeTFGZWVzXG4gICAgICAgICAgICA6IGZlZXNJc0luRkxFVEhcbiAgICAgICAgICAgICAgICA/IGFic0N1cnJlbmN5MUZlZXNcbiAgICAgICAgICAgICAgICA6IGFic0N1cnJlbmN5MEZlZXMsXG4gICAgfTtcbiAgICBpZiAoc3dhcFR5cGUgPT09IFwiQlVZXCIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvaW5zQm91Z2h0OiBmbEVUSElzQ3VycmVuY3laZXJvXG4gICAgICAgICAgICAgICAgPyBhYnNDdXJyZW5jeTFEZWx0YSAtICghZmVlcy5pc0luRkxFVEggPyBmZWVzLmFtb3VudCA6IDBuKVxuICAgICAgICAgICAgICAgIDogYWJzQ3VycmVuY3kwRGVsdGEgLSAoIWZlZXMuaXNJbkZMRVRIID8gZmVlcy5hbW91bnQgOiAwbiksXG4gICAgICAgICAgICBldGhTb2xkOiBmbEVUSElzQ3VycmVuY3laZXJvXG4gICAgICAgICAgICAgICAgPyBhYnNDdXJyZW5jeTBEZWx0YSAtIChmZWVzLmlzSW5GTEVUSCA/IGZlZXMuYW1vdW50IDogMG4pXG4gICAgICAgICAgICAgICAgOiBhYnNDdXJyZW5jeTFEZWx0YSAtIChmZWVzLmlzSW5GTEVUSCA/IGZlZXMuYW1vdW50IDogMG4pLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvaW5zU29sZDogZmxFVEhJc0N1cnJlbmN5WmVyb1xuICAgICAgICAgICAgICAgID8gYWJzQ3VycmVuY3kxRGVsdGEgLSAoIWZlZXMuaXNJbkZMRVRIID8gZmVlcy5hbW91bnQgOiAwbilcbiAgICAgICAgICAgICAgICA6IGFic0N1cnJlbmN5MERlbHRhIC0gKCFmZWVzLmlzSW5GTEVUSCA/IGZlZXMuYW1vdW50IDogMG4pLFxuICAgICAgICAgICAgZXRoQm91Z2h0OiBmbEVUSElzQ3VycmVuY3laZXJvXG4gICAgICAgICAgICAgICAgPyBhYnNDdXJyZW5jeTBEZWx0YSAtIChmZWVzLmlzSW5GTEVUSCA/IGZlZXMuYW1vdW50IDogMG4pXG4gICAgICAgICAgICAgICAgOiBhYnNDdXJyZW5jeTFEZWx0YSAtIChmZWVzLmlzSW5GTEVUSCA/IGZlZXMuYW1vdW50IDogMG4pLFxuICAgICAgICB9O1xuICAgIH1cbn07XG5leHBvcnRzLmdldFN3YXBBbW91bnRzRnJvbUxvZyA9IGdldFN3YXBBbW91bnRzRnJvbUxvZztcbmNvbnN0IGdldFN3YXBBbW91bnRzRnJvbVJlY2VpcHQgPSAoeyByZWNlaXB0LCBjb2luQWRkcmVzcywgY2hhaW5JZCwgfSkgPT4ge1xuICAgIGNvbnN0IGZpbHRlcmVkUG9vbFN3YXBFdmVudCA9IHJlY2VpcHQubG9nc1xuICAgICAgICAubWFwKGxvZyA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAobG9nLmFkZHJlc3MudG9Mb3dlckNhc2UoKSAhPT0gY29uc3RhbnRzXzEuRmxhdW5jaFBvc2l0aW9uTWFuYWdlckFkZHJlc3NbY2hhaW5JZF0udG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSAoMCwgdmllbV8xLmRlY29kZUV2ZW50TG9nKSh7XG4gICAgICAgICAgICAgICAgYWJpOiBjb25zdGFudHNfMS5QT1NJVElPTl9NQU5BR0VSX0FCSSxcbiAgICAgICAgICAgICAgICBkYXRhOiBsb2cuZGF0YSxcbiAgICAgICAgICAgICAgICB0b3BpY3M6IGxvZy50b3BpY3MsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBldmVudC5ldmVudE5hbWUgPT09IFwiUG9vbFN3YXBcIiA/IGV2ZW50LmFyZ3MgOiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfSlcbiAgICAgICAgLmZpbHRlcigoZXZlbnQpID0+IGV2ZW50ICE9PSBudWxsKVswXTtcbiAgICByZXR1cm4gKDAsIGV4cG9ydHMuZ2V0U3dhcEFtb3VudHNGcm9tTG9nKSh7XG4gICAgICAgIGZpbHRlcmVkUG9vbFN3YXBFdmVudCxcbiAgICAgICAgY29pbkFkZHJlc3MsXG4gICAgICAgIGNoYWluSWQsXG4gICAgfSk7XG59O1xuZXhwb3J0cy5nZXRTd2FwQW1vdW50c0Zyb21SZWNlaXB0ID0gZ2V0U3dhcEFtb3VudHNGcm9tUmVjZWlwdDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/flaunch/utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/index.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./actionDecorator */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/actionDecorator.js\"), exports);\n__exportStar(__webpack_require__(/*! ./actionProvider */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/actionProvider.js\"), exports);\n__exportStar(__webpack_require__(/*! ./customActionProvider */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/customActionProvider.js\"), exports);\n__exportStar(__webpack_require__(/*! ./across */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/across/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./alchemy */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/alchemy/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./basename */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/basename/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./cdp */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/cdp/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./compound */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/compound/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./defillama */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/defillama/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./erc20 */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/erc20/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./erc721 */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/erc721/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./farcaster */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/farcaster/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./jupiter */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/jupiter/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./messari */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/messari/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./pyth */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/pyth/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./moonwell */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/moonwell/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./morpho */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/morpho/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./opensea */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/opensea/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./spl */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/spl/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./twitter */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/twitter/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./wallet */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/wallet/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./weth */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/weth/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./wow */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/wow/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./allora */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/allora/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./flaunch */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/flaunch/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./onramp */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/onramp/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./vaultsfyi */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/vaultsfyi/index.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxhQUFhLG1CQUFPLENBQUMsMkdBQW1CO0FBQ3hDLGFBQWEsbUJBQU8sQ0FBQyx5R0FBa0I7QUFDdkMsYUFBYSxtQkFBTyxDQUFDLHFIQUF3QjtBQUM3QyxhQUFhLG1CQUFPLENBQUMsK0ZBQVU7QUFDL0IsYUFBYSxtQkFBTyxDQUFDLGlHQUFXO0FBQ2hDLGFBQWEsbUJBQU8sQ0FBQyxtR0FBWTtBQUNqQyxhQUFhLG1CQUFPLENBQUMseUZBQU87QUFDNUIsYUFBYSxtQkFBTyxDQUFDLG1HQUFZO0FBQ2pDLGFBQWEsbUJBQU8sQ0FBQyxxR0FBYTtBQUNsQyxhQUFhLG1CQUFPLENBQUMsNkZBQVM7QUFDOUIsYUFBYSxtQkFBTyxDQUFDLCtGQUFVO0FBQy9CLGFBQWEsbUJBQU8sQ0FBQyxxR0FBYTtBQUNsQyxhQUFhLG1CQUFPLENBQUMsaUdBQVc7QUFDaEMsYUFBYSxtQkFBTyxDQUFDLGlHQUFXO0FBQ2hDLGFBQWEsbUJBQU8sQ0FBQywyRkFBUTtBQUM3QixhQUFhLG1CQUFPLENBQUMsbUdBQVk7QUFDakMsYUFBYSxtQkFBTyxDQUFDLCtGQUFVO0FBQy9CLGFBQWEsbUJBQU8sQ0FBQyxpR0FBVztBQUNoQyxhQUFhLG1CQUFPLENBQUMseUZBQU87QUFDNUIsYUFBYSxtQkFBTyxDQUFDLGlHQUFXO0FBQ2hDLGFBQWEsbUJBQU8sQ0FBQywrRkFBVTtBQUMvQixhQUFhLG1CQUFPLENBQUMsMkZBQVE7QUFDN0IsYUFBYSxtQkFBTyxDQUFDLHlGQUFPO0FBQzVCLGFBQWEsbUJBQU8sQ0FBQywrRkFBVTtBQUMvQixhQUFhLG1CQUFPLENBQUMsaUdBQVc7QUFDaEMsYUFBYSxtQkFBTyxDQUFDLCtGQUFVO0FBQy9CLGFBQWEsbUJBQU8sQ0FBQyxxR0FBYSIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cnZpdmFsLWZ1bi8uL25vZGVfbW9kdWxlcy9AY29pbmJhc2UvYWdlbnRraXQvZGlzdC9hY3Rpb24tcHJvdmlkZXJzL2luZGV4LmpzP2IyYzYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9hY3Rpb25EZWNvcmF0b3JcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2FjdGlvblByb3ZpZGVyXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jdXN0b21BY3Rpb25Qcm92aWRlclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYWNyb3NzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9hbGNoZW15XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9iYXNlbmFtZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY2RwXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jb21wb3VuZFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZGVmaWxsYW1hXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9lcmMyMFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZXJjNzIxXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9mYXJjYXN0ZXJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2p1cGl0ZXJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL21lc3NhcmlcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3B5dGhcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL21vb253ZWxsXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9tb3JwaG9cIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL29wZW5zZWFcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3NwbFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdHdpdHRlclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vd2FsbGV0XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi93ZXRoXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi93b3dcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2FsbG9yYVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZmxhdW5jaFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vb25yYW1wXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi92YXVsdHNmeWlcIiksIGV4cG9ydHMpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/jupiter/index.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/jupiter/index.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./jupiterActionProvider */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/jupiter/jupiterActionProvider.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9qdXBpdGVyL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWEsbUJBQU8sQ0FBQywrSEFBeUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXJ2aXZhbC1mdW4vLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9qdXBpdGVyL2luZGV4LmpzP2ZjNGYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9qdXBpdGVyQWN0aW9uUHJvdmlkZXJcIiksIGV4cG9ydHMpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/jupiter/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/jupiter/jupiterActionProvider.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/jupiter/jupiterActionProvider.js ***!
  \************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.jupiterActionProvider = exports.JupiterActionProvider = void 0;\nconst actionProvider_1 = __webpack_require__(/*! ../actionProvider */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/actionProvider.js\");\nconst svmWalletProvider_1 = __webpack_require__(/*! ../../wallet-providers/svmWalletProvider */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/wallet-providers/svmWalletProvider.js\");\nconst zod_1 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/lib/index.js\");\nconst actionDecorator_1 = __webpack_require__(/*! ../actionDecorator */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/actionDecorator.js\");\nconst schemas_1 = __webpack_require__(/*! ./schemas */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/jupiter/schemas.js\");\nconst web3_js_1 = __webpack_require__(/*! @solana/web3.js */ \"(rsc)/./node_modules/@solana/web3.js/lib/index.esm.js\");\nconst api_1 = __webpack_require__(/*! @jup-ag/api */ \"(rsc)/./node_modules/@jup-ag/api/dist/index.mjs\");\n/**\n * JupiterActionProvider handles token swaps using Jupiter's API.\n */\nclass JupiterActionProvider extends actionProvider_1.ActionProvider {\n    /**\n     * Initializes Jupiter API client.\n     */\n    constructor() {\n        super(\"jupiter\", []);\n    }\n    /**\n     * Swaps tokens using Jupiter's API.\n     *\n     * @param walletProvider - The wallet provider to use for the swap\n     * @param args - Swap parameters including input token, output token, and amount\n     * @returns A message indicating success or failure with transaction details\n     */\n    async swap(walletProvider, args) {\n        try {\n            const jupiterApi = (0, api_1.createJupiterApiClient)();\n            const userPublicKey = walletProvider.getPublicKey();\n            const inputMint = new web3_js_1.PublicKey(args.inputMint);\n            const outputMint = new web3_js_1.PublicKey(args.outputMint);\n            const { getMint } = await Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/@solana\"), __webpack_require__.e(\"vendor-chunks/bignumber.js\"), __webpack_require__.e(\"vendor-chunks/file-uri-to-path\"), __webpack_require__.e(\"vendor-chunks/bindings\"), __webpack_require__.e(\"vendor-chunks/bigint-buffer\")]).then(__webpack_require__.bind(__webpack_require__, /*! @solana/spl-token */ \"(rsc)/./node_modules/@solana/spl-token/lib/esm/index.js\"));\n            let mintInfo;\n            try {\n                mintInfo = await getMint(walletProvider.getConnection(), inputMint);\n            }\n            catch (error) {\n                return `Failed to fetch mint info for mint address ${args.inputMint}. Error: ${error}`;\n            }\n            const amount = args.amount * 10 ** mintInfo.decimals;\n            const quoteResponse = await jupiterApi.quoteGet({\n                inputMint: inputMint.toBase58(),\n                outputMint: outputMint.toBase58(),\n                amount: amount,\n                slippageBps: args.slippageBps || 50, // 0.5% default slippage\n            });\n            if (!quoteResponse) {\n                throw new Error(\"Failed to get a swap quote.\");\n            }\n            const swapRequest = {\n                userPublicKey: userPublicKey.toBase58(),\n                wrapAndUnwrapSol: true,\n                useSharedAccounts: true, // Optimize for low transaction costs\n                quoteResponse,\n            };\n            const swapResponse = await jupiterApi.swapPost({ swapRequest });\n            if (!swapResponse || !swapResponse.swapTransaction) {\n                throw new Error(\"Failed to generate swap transaction.\");\n            }\n            const transactionBuffer = Buffer.from(swapResponse.swapTransaction, \"base64\");\n            const tx = web3_js_1.VersionedTransaction.deserialize(transactionBuffer);\n            const signature = await walletProvider.signAndSendTransaction(tx);\n            await walletProvider.waitForSignatureResult(signature);\n            return `Successfully swapped ${args.amount} tokens! Signature: ${signature}`;\n        }\n        catch (error) {\n            return `Error swapping tokens: ${error}`;\n        }\n    }\n    /**\n     * Checks if the action provider supports the given network.\n     * Only supports Solana networks.\n     *\n     * @param network - The network to check support for\n     * @returns True if the network is a Solana network\n     */\n    supportsNetwork(network) {\n        return network.protocolFamily == \"svm\" && network.networkId === \"solana-mainnet\";\n    }\n}\nexports.JupiterActionProvider = JupiterActionProvider;\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"swap\",\n        description: `\n    Swaps tokens using Jupiter's DEX aggregator.\n    - Input and output tokens must be valid SPL token mints.\n    - Ensures sufficient balance before executing swap.\n    - If says \"SOL\" as the input or output, use the mint address So11111111111111111111111111111111111111112\n    NOTE: Only available on Solana mainnet.\n    `,\n        schema: schemas_1.SwapTokenSchema,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [svmWalletProvider_1.SvmWalletProvider, void 0]),\n    __metadata(\"design:returntype\", Promise)\n], JupiterActionProvider.prototype, \"swap\", null);\n/**\n * Factory function to create a new JupiterActionProvider instance.\n *\n * @returns A new JupiterActionProvider instance\n */\nconst jupiterActionProvider = () => new JupiterActionProvider();\nexports.jupiterActionProvider = jupiterActionProvider;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9qdXBpdGVyL2p1cGl0ZXJBY3Rpb25Qcm92aWRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxRQUFRO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNkJBQTZCLEdBQUcsNkJBQTZCO0FBQzdELHlCQUF5QixtQkFBTyxDQUFDLDBHQUFtQjtBQUNwRCw0QkFBNEIsbUJBQU8sQ0FBQyxvSUFBMEM7QUFDOUUsY0FBYyxtQkFBTyxDQUFDLGtEQUFLO0FBQzNCLDBCQUEwQixtQkFBTyxDQUFDLDRHQUFvQjtBQUN0RCxrQkFBa0IsbUJBQU8sQ0FBQyxtR0FBVztBQUNyQyxrQkFBa0IsbUJBQU8sQ0FBQyw4RUFBaUI7QUFDM0MsY0FBYyxtQkFBTyxDQUFDLG9FQUFhO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVSxRQUFRLHlhQUEyQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLGVBQWUsV0FBVyxNQUFNO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxhQUFhO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGFBQWEscUJBQXFCLFVBQVU7QUFDdkY7QUFDQTtBQUNBLDZDQUE2QyxNQUFNO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXJ2aXZhbC1mdW4vLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9qdXBpdGVyL2p1cGl0ZXJBY3Rpb25Qcm92aWRlci5qcz8yNjFhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuanVwaXRlckFjdGlvblByb3ZpZGVyID0gZXhwb3J0cy5KdXBpdGVyQWN0aW9uUHJvdmlkZXIgPSB2b2lkIDA7XG5jb25zdCBhY3Rpb25Qcm92aWRlcl8xID0gcmVxdWlyZShcIi4uL2FjdGlvblByb3ZpZGVyXCIpO1xuY29uc3Qgc3ZtV2FsbGV0UHJvdmlkZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi93YWxsZXQtcHJvdmlkZXJzL3N2bVdhbGxldFByb3ZpZGVyXCIpO1xuY29uc3Qgem9kXzEgPSByZXF1aXJlKFwiem9kXCIpO1xuY29uc3QgYWN0aW9uRGVjb3JhdG9yXzEgPSByZXF1aXJlKFwiLi4vYWN0aW9uRGVjb3JhdG9yXCIpO1xuY29uc3Qgc2NoZW1hc18xID0gcmVxdWlyZShcIi4vc2NoZW1hc1wiKTtcbmNvbnN0IHdlYjNfanNfMSA9IHJlcXVpcmUoXCJAc29sYW5hL3dlYjMuanNcIik7XG5jb25zdCBhcGlfMSA9IHJlcXVpcmUoXCJAanVwLWFnL2FwaVwiKTtcbi8qKlxuICogSnVwaXRlckFjdGlvblByb3ZpZGVyIGhhbmRsZXMgdG9rZW4gc3dhcHMgdXNpbmcgSnVwaXRlcidzIEFQSS5cbiAqL1xuY2xhc3MgSnVwaXRlckFjdGlvblByb3ZpZGVyIGV4dGVuZHMgYWN0aW9uUHJvdmlkZXJfMS5BY3Rpb25Qcm92aWRlciB7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgSnVwaXRlciBBUEkgY2xpZW50LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihcImp1cGl0ZXJcIiwgW10pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTd2FwcyB0b2tlbnMgdXNpbmcgSnVwaXRlcidzIEFQSS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB3YWxsZXRQcm92aWRlciAtIFRoZSB3YWxsZXQgcHJvdmlkZXIgdG8gdXNlIGZvciB0aGUgc3dhcFxuICAgICAqIEBwYXJhbSBhcmdzIC0gU3dhcCBwYXJhbWV0ZXJzIGluY2x1ZGluZyBpbnB1dCB0b2tlbiwgb3V0cHV0IHRva2VuLCBhbmQgYW1vdW50XG4gICAgICogQHJldHVybnMgQSBtZXNzYWdlIGluZGljYXRpbmcgc3VjY2VzcyBvciBmYWlsdXJlIHdpdGggdHJhbnNhY3Rpb24gZGV0YWlsc1xuICAgICAqL1xuICAgIGFzeW5jIHN3YXAod2FsbGV0UHJvdmlkZXIsIGFyZ3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGp1cGl0ZXJBcGkgPSAoMCwgYXBpXzEuY3JlYXRlSnVwaXRlckFwaUNsaWVudCkoKTtcbiAgICAgICAgICAgIGNvbnN0IHVzZXJQdWJsaWNLZXkgPSB3YWxsZXRQcm92aWRlci5nZXRQdWJsaWNLZXkoKTtcbiAgICAgICAgICAgIGNvbnN0IGlucHV0TWludCA9IG5ldyB3ZWIzX2pzXzEuUHVibGljS2V5KGFyZ3MuaW5wdXRNaW50KTtcbiAgICAgICAgICAgIGNvbnN0IG91dHB1dE1pbnQgPSBuZXcgd2ViM19qc18xLlB1YmxpY0tleShhcmdzLm91dHB1dE1pbnQpO1xuICAgICAgICAgICAgY29uc3QgeyBnZXRNaW50IH0gPSBhd2FpdCBpbXBvcnQoXCJAc29sYW5hL3NwbC10b2tlblwiKTtcbiAgICAgICAgICAgIGxldCBtaW50SW5mbztcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbWludEluZm8gPSBhd2FpdCBnZXRNaW50KHdhbGxldFByb3ZpZGVyLmdldENvbm5lY3Rpb24oKSwgaW5wdXRNaW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBgRmFpbGVkIHRvIGZldGNoIG1pbnQgaW5mbyBmb3IgbWludCBhZGRyZXNzICR7YXJncy5pbnB1dE1pbnR9LiBFcnJvcjogJHtlcnJvcn1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYW1vdW50ID0gYXJncy5hbW91bnQgKiAxMCAqKiBtaW50SW5mby5kZWNpbWFscztcbiAgICAgICAgICAgIGNvbnN0IHF1b3RlUmVzcG9uc2UgPSBhd2FpdCBqdXBpdGVyQXBpLnF1b3RlR2V0KHtcbiAgICAgICAgICAgICAgICBpbnB1dE1pbnQ6IGlucHV0TWludC50b0Jhc2U1OCgpLFxuICAgICAgICAgICAgICAgIG91dHB1dE1pbnQ6IG91dHB1dE1pbnQudG9CYXNlNTgoKSxcbiAgICAgICAgICAgICAgICBhbW91bnQ6IGFtb3VudCxcbiAgICAgICAgICAgICAgICBzbGlwcGFnZUJwczogYXJncy5zbGlwcGFnZUJwcyB8fCA1MCwgLy8gMC41JSBkZWZhdWx0IHNsaXBwYWdlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghcXVvdGVSZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBnZXQgYSBzd2FwIHF1b3RlLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHN3YXBSZXF1ZXN0ID0ge1xuICAgICAgICAgICAgICAgIHVzZXJQdWJsaWNLZXk6IHVzZXJQdWJsaWNLZXkudG9CYXNlNTgoKSxcbiAgICAgICAgICAgICAgICB3cmFwQW5kVW53cmFwU29sOiB0cnVlLFxuICAgICAgICAgICAgICAgIHVzZVNoYXJlZEFjY291bnRzOiB0cnVlLCAvLyBPcHRpbWl6ZSBmb3IgbG93IHRyYW5zYWN0aW9uIGNvc3RzXG4gICAgICAgICAgICAgICAgcXVvdGVSZXNwb25zZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBzd2FwUmVzcG9uc2UgPSBhd2FpdCBqdXBpdGVyQXBpLnN3YXBQb3N0KHsgc3dhcFJlcXVlc3QgfSk7XG4gICAgICAgICAgICBpZiAoIXN3YXBSZXNwb25zZSB8fCAhc3dhcFJlc3BvbnNlLnN3YXBUcmFuc2FjdGlvbikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBnZW5lcmF0ZSBzd2FwIHRyYW5zYWN0aW9uLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uQnVmZmVyID0gQnVmZmVyLmZyb20oc3dhcFJlc3BvbnNlLnN3YXBUcmFuc2FjdGlvbiwgXCJiYXNlNjRcIik7XG4gICAgICAgICAgICBjb25zdCB0eCA9IHdlYjNfanNfMS5WZXJzaW9uZWRUcmFuc2FjdGlvbi5kZXNlcmlhbGl6ZSh0cmFuc2FjdGlvbkJ1ZmZlcik7XG4gICAgICAgICAgICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCB3YWxsZXRQcm92aWRlci5zaWduQW5kU2VuZFRyYW5zYWN0aW9uKHR4KTtcbiAgICAgICAgICAgIGF3YWl0IHdhbGxldFByb3ZpZGVyLndhaXRGb3JTaWduYXR1cmVSZXN1bHQoc2lnbmF0dXJlKTtcbiAgICAgICAgICAgIHJldHVybiBgU3VjY2Vzc2Z1bGx5IHN3YXBwZWQgJHthcmdzLmFtb3VudH0gdG9rZW5zISBTaWduYXR1cmU6ICR7c2lnbmF0dXJlfWA7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gYEVycm9yIHN3YXBwaW5nIHRva2VuczogJHtlcnJvcn1gO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgYWN0aW9uIHByb3ZpZGVyIHN1cHBvcnRzIHRoZSBnaXZlbiBuZXR3b3JrLlxuICAgICAqIE9ubHkgc3VwcG9ydHMgU29sYW5hIG5ldHdvcmtzLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5ldHdvcmsgLSBUaGUgbmV0d29yayB0byBjaGVjayBzdXBwb3J0IGZvclxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIG5ldHdvcmsgaXMgYSBTb2xhbmEgbmV0d29ya1xuICAgICAqL1xuICAgIHN1cHBvcnRzTmV0d29yayhuZXR3b3JrKSB7XG4gICAgICAgIHJldHVybiBuZXR3b3JrLnByb3RvY29sRmFtaWx5ID09IFwic3ZtXCIgJiYgbmV0d29yay5uZXR3b3JrSWQgPT09IFwic29sYW5hLW1haW5uZXRcIjtcbiAgICB9XG59XG5leHBvcnRzLkp1cGl0ZXJBY3Rpb25Qcm92aWRlciA9IEp1cGl0ZXJBY3Rpb25Qcm92aWRlcjtcbl9fZGVjb3JhdGUoW1xuICAgICgwLCBhY3Rpb25EZWNvcmF0b3JfMS5DcmVhdGVBY3Rpb24pKHtcbiAgICAgICAgbmFtZTogXCJzd2FwXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgXG4gICAgU3dhcHMgdG9rZW5zIHVzaW5nIEp1cGl0ZXIncyBERVggYWdncmVnYXRvci5cbiAgICAtIElucHV0IGFuZCBvdXRwdXQgdG9rZW5zIG11c3QgYmUgdmFsaWQgU1BMIHRva2VuIG1pbnRzLlxuICAgIC0gRW5zdXJlcyBzdWZmaWNpZW50IGJhbGFuY2UgYmVmb3JlIGV4ZWN1dGluZyBzd2FwLlxuICAgIC0gSWYgc2F5cyBcIlNPTFwiIGFzIHRoZSBpbnB1dCBvciBvdXRwdXQsIHVzZSB0aGUgbWludCBhZGRyZXNzIFNvMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTJcbiAgICBOT1RFOiBPbmx5IGF2YWlsYWJsZSBvbiBTb2xhbmEgbWFpbm5ldC5cbiAgICBgLFxuICAgICAgICBzY2hlbWE6IHNjaGVtYXNfMS5Td2FwVG9rZW5TY2hlbWEsXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW3N2bVdhbGxldFByb3ZpZGVyXzEuU3ZtV2FsbGV0UHJvdmlkZXIsIHZvaWQgMF0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCBQcm9taXNlKVxuXSwgSnVwaXRlckFjdGlvblByb3ZpZGVyLnByb3RvdHlwZSwgXCJzd2FwXCIsIG51bGwpO1xuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIHRvIGNyZWF0ZSBhIG5ldyBKdXBpdGVyQWN0aW9uUHJvdmlkZXIgaW5zdGFuY2UuXG4gKlxuICogQHJldHVybnMgQSBuZXcgSnVwaXRlckFjdGlvblByb3ZpZGVyIGluc3RhbmNlXG4gKi9cbmNvbnN0IGp1cGl0ZXJBY3Rpb25Qcm92aWRlciA9ICgpID0+IG5ldyBKdXBpdGVyQWN0aW9uUHJvdmlkZXIoKTtcbmV4cG9ydHMuanVwaXRlckFjdGlvblByb3ZpZGVyID0ganVwaXRlckFjdGlvblByb3ZpZGVyO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/jupiter/jupiterActionProvider.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/jupiter/schemas.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/jupiter/schemas.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SwapTokenSchema = void 0;\nconst zod_1 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/lib/index.js\");\n/**\n * Schema for swapping tokens using Jupiter.\n */\nexports.SwapTokenSchema = zod_1.z\n    .object({\n    inputMint: zod_1.z.string().describe(\"The mint address of the token to swap from\"),\n    outputMint: zod_1.z.string().describe(\"The mint address of the token to swap to\"),\n    amount: zod_1.z.number().positive().describe(\"Amount of tokens to swap\"),\n    slippageBps: zod_1.z\n        .number()\n        .int()\n        .positive()\n        .default(50)\n        .describe(\"Slippage tolerance in basis points (e.g., 50 = 0.5%)\"),\n})\n    .describe(\"Swap tokens using Jupiter DEX aggregator\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9qdXBpdGVyL3NjaGVtYXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsdUJBQXVCO0FBQ3ZCLGNBQWMsbUJBQU8sQ0FBQyxrREFBSztBQUMzQjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXJ2aXZhbC1mdW4vLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9qdXBpdGVyL3NjaGVtYXMuanM/MjYwYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU3dhcFRva2VuU2NoZW1hID0gdm9pZCAwO1xuY29uc3Qgem9kXzEgPSByZXF1aXJlKFwiem9kXCIpO1xuLyoqXG4gKiBTY2hlbWEgZm9yIHN3YXBwaW5nIHRva2VucyB1c2luZyBKdXBpdGVyLlxuICovXG5leHBvcnRzLlN3YXBUb2tlblNjaGVtYSA9IHpvZF8xLnpcbiAgICAub2JqZWN0KHtcbiAgICBpbnB1dE1pbnQ6IHpvZF8xLnouc3RyaW5nKCkuZGVzY3JpYmUoXCJUaGUgbWludCBhZGRyZXNzIG9mIHRoZSB0b2tlbiB0byBzd2FwIGZyb21cIiksXG4gICAgb3V0cHV0TWludDogem9kXzEuei5zdHJpbmcoKS5kZXNjcmliZShcIlRoZSBtaW50IGFkZHJlc3Mgb2YgdGhlIHRva2VuIHRvIHN3YXAgdG9cIiksXG4gICAgYW1vdW50OiB6b2RfMS56Lm51bWJlcigpLnBvc2l0aXZlKCkuZGVzY3JpYmUoXCJBbW91bnQgb2YgdG9rZW5zIHRvIHN3YXBcIiksXG4gICAgc2xpcHBhZ2VCcHM6IHpvZF8xLnpcbiAgICAgICAgLm51bWJlcigpXG4gICAgICAgIC5pbnQoKVxuICAgICAgICAucG9zaXRpdmUoKVxuICAgICAgICAuZGVmYXVsdCg1MClcbiAgICAgICAgLmRlc2NyaWJlKFwiU2xpcHBhZ2UgdG9sZXJhbmNlIGluIGJhc2lzIHBvaW50cyAoZS5nLiwgNTAgPSAwLjUlKVwiKSxcbn0pXG4gICAgLmRlc2NyaWJlKFwiU3dhcCB0b2tlbnMgdXNpbmcgSnVwaXRlciBERVggYWdncmVnYXRvclwiKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/jupiter/schemas.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/messari/constants.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/messari/constants.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RATE_LIMITS = exports.API_KEY_MISSING_ERROR = exports.MESSARI_BASE_URL = void 0;\n/**\n * Base URL for the Messari API\n */\nexports.MESSARI_BASE_URL = \"https://api.messari.io/ai/v1\";\n/**\n * Default error message when API key is missing\n */\nexports.API_KEY_MISSING_ERROR = \"MESSARI_API_KEY is not configured.\";\n/**\n * Rate limits by subscription tier\n */\nexports.RATE_LIMITS = {\n    FREE: \"2 requests per day\",\n    LITE: \"10 requests per day\",\n    PRO: \"20 requests per day\",\n    ENTERPRISE: \"50 requests per day\",\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9tZXNzYXJpL2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUIsR0FBRyw2QkFBNkIsR0FBRyx3QkFBd0I7QUFDOUU7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cnZpdmFsLWZ1bi8uL25vZGVfbW9kdWxlcy9AY29pbmJhc2UvYWdlbnRraXQvZGlzdC9hY3Rpb24tcHJvdmlkZXJzL21lc3NhcmkvY29uc3RhbnRzLmpzPzJjYzUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJBVEVfTElNSVRTID0gZXhwb3J0cy5BUElfS0VZX01JU1NJTkdfRVJST1IgPSBleHBvcnRzLk1FU1NBUklfQkFTRV9VUkwgPSB2b2lkIDA7XG4vKipcbiAqIEJhc2UgVVJMIGZvciB0aGUgTWVzc2FyaSBBUElcbiAqL1xuZXhwb3J0cy5NRVNTQVJJX0JBU0VfVVJMID0gXCJodHRwczovL2FwaS5tZXNzYXJpLmlvL2FpL3YxXCI7XG4vKipcbiAqIERlZmF1bHQgZXJyb3IgbWVzc2FnZSB3aGVuIEFQSSBrZXkgaXMgbWlzc2luZ1xuICovXG5leHBvcnRzLkFQSV9LRVlfTUlTU0lOR19FUlJPUiA9IFwiTUVTU0FSSV9BUElfS0VZIGlzIG5vdCBjb25maWd1cmVkLlwiO1xuLyoqXG4gKiBSYXRlIGxpbWl0cyBieSBzdWJzY3JpcHRpb24gdGllclxuICovXG5leHBvcnRzLlJBVEVfTElNSVRTID0ge1xuICAgIEZSRUU6IFwiMiByZXF1ZXN0cyBwZXIgZGF5XCIsXG4gICAgTElURTogXCIxMCByZXF1ZXN0cyBwZXIgZGF5XCIsXG4gICAgUFJPOiBcIjIwIHJlcXVlc3RzIHBlciBkYXlcIixcbiAgICBFTlRFUlBSSVNFOiBcIjUwIHJlcXVlc3RzIHBlciBkYXlcIixcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/messari/constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/messari/index.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/messari/index.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./messariActionProvider */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/messari/messariActionProvider.js\"), exports);\n__exportStar(__webpack_require__(/*! ./schemas */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/messari/schemas.js\"), exports);\n__exportStar(__webpack_require__(/*! ./types */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/messari/types.js\"), exports);\n__exportStar(__webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/messari/constants.js\"), exports);\n__exportStar(__webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/messari/utils.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9tZXNzYXJpL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWEsbUJBQU8sQ0FBQywrSEFBeUI7QUFDOUMsYUFBYSxtQkFBTyxDQUFDLG1HQUFXO0FBQ2hDLGFBQWEsbUJBQU8sQ0FBQywrRkFBUztBQUM5QixhQUFhLG1CQUFPLENBQUMsdUdBQWE7QUFDbEMsYUFBYSxtQkFBTyxDQUFDLCtGQUFTIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3Vydml2YWwtZnVuLy4vbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9hZ2VudGtpdC9kaXN0L2FjdGlvbi1wcm92aWRlcnMvbWVzc2FyaS9pbmRleC5qcz9hMTJhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbWVzc2FyaUFjdGlvblByb3ZpZGVyXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9zY2hlbWFzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi90eXBlc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY29uc3RhbnRzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi91dGlsc1wiKSwgZXhwb3J0cyk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/messari/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/messari/messariActionProvider.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/messari/messariActionProvider.js ***!
  \************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.messariActionProvider = exports.MessariActionProvider = void 0;\nconst zod_1 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/lib/index.js\");\nconst actionProvider_1 = __webpack_require__(/*! ../actionProvider */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/actionProvider.js\");\nconst actionDecorator_1 = __webpack_require__(/*! ../actionDecorator */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/actionDecorator.js\");\nconst schemas_1 = __webpack_require__(/*! ./schemas */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/messari/schemas.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/messari/constants.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/messari/utils.js\");\n/**\n * MessariActionProvider is an action provider for Messari AI toolkit interactions.\n * It enables AI agents to ask research questions about crypto markets, protocols, and tokens.\n *\n * @augments ActionProvider\n */\nclass MessariActionProvider extends actionProvider_1.ActionProvider {\n    /**\n     * Constructor for the MessariActionProvider class.\n     *\n     * @param config - The configuration options for the MessariActionProvider\n     */\n    constructor(config = {}) {\n        super(\"messari\", []);\n        config.apiKey || (config.apiKey = process.env.MESSARI_API_KEY);\n        if (!config.apiKey) {\n            throw new Error(constants_1.API_KEY_MISSING_ERROR);\n        }\n        this.apiKey = config.apiKey;\n    }\n    /**\n     * Makes a request to the Messari AI API with a research question\n     *\n     * @param args - The arguments containing the research question\n     * @returns A string containing the research results or an error message\n     */\n    async researchQuestion(args) {\n        try {\n            // Make API request\n            const response = await fetch(`${constants_1.MESSARI_BASE_URL}/chat/completions`, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    \"x-messari-api-key\": this.apiKey,\n                },\n                body: JSON.stringify({\n                    messages: [\n                        {\n                            role: \"user\",\n                            content: args.question,\n                        },\n                    ],\n                }),\n            });\n            if (!response.ok) {\n                throw await (0, utils_1.createMessariError)(response);\n            }\n            // Parse and validate response\n            let data;\n            try {\n                data = (await response.json());\n            }\n            catch (jsonError) {\n                throw new Error(`Failed to parse API response: ${jsonError instanceof Error ? jsonError.message : String(jsonError)}`);\n            }\n            if (!data.data?.messages?.[0]?.content) {\n                throw new Error(\"Received invalid response format from Messari API\");\n            }\n            const result = data.data.messages[0].content;\n            return `Messari Research Results:\\n\\n${result}`;\n        }\n        catch (error) {\n            if (error instanceof Error && \"responseText\" in error) {\n                return (0, utils_1.formatMessariApiError)(error);\n            }\n            return (0, utils_1.formatGenericError)(error);\n        }\n    }\n    /**\n     * Checks if the action provider supports the given network.\n     * Messari research is network-agnostic, so it supports all networks.\n     *\n     * @param _ - The network to check\n     * @returns Always returns true as Messari research is network-agnostic\n     */\n    supportsNetwork(_) {\n        return true; // Messari research is network-agnostic\n    }\n}\nexports.MessariActionProvider = MessariActionProvider;\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"research_question\",\n        description: `\nThis tool queries Messari AI for comprehensive crypto research across these datasets:\n1. News/Content - Latest crypto news, blogs, podcasts\n2. Exchanges - CEX/DEX volumes, market share, assets listed\n3. Onchain Data - Active addresses, transaction fees, total transactions.\n4. Token Unlocks - Upcoming supply unlocks, vesting schedules, and token emission details\n5. Market Data - Asset prices, trading volume, market cap, TVL, and historical performance\n6. Fundraising - Investment data, funding rounds, venture capital activity.\n7. Protocol Research - Technical analysis of how protocols work, tokenomics, and yield mechanisms\n8. Social Data - Twitter followers and Reddit subscribers metrics, growth trends\n\nExamples: \"Which DEXs have the highest trading volume this month?\", \"When is Arbitrum's next major token unlock?\", \"How does Morpho generate yield for users?\", \"Which cryptocurrency has gained the most Twitter followers in 2023?\", \"What did Vitalik Buterin say about rollups in his recent blog posts?\"\n    `,\n        schema: schemas_1.MessariResearchQuestionSchema,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [void 0]),\n    __metadata(\"design:returntype\", Promise)\n], MessariActionProvider.prototype, \"researchQuestion\", null);\n/**\n * Factory function to create a new MessariActionProvider instance.\n *\n * @param config - The configuration options for the MessariActionProvider\n * @returns A new instance of MessariActionProvider\n */\nconst messariActionProvider = (config = {}) => new MessariActionProvider(config);\nexports.messariActionProvider = messariActionProvider;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9tZXNzYXJpL21lc3NhcmlBY3Rpb25Qcm92aWRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxRQUFRO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNkJBQTZCLEdBQUcsNkJBQTZCO0FBQzdELGNBQWMsbUJBQU8sQ0FBQyxrREFBSztBQUMzQix5QkFBeUIsbUJBQU8sQ0FBQywwR0FBbUI7QUFDcEQsMEJBQTBCLG1CQUFPLENBQUMsNEdBQW9CO0FBQ3RELGtCQUFrQixtQkFBTyxDQUFDLG1HQUFXO0FBQ3JDLG9CQUFvQixtQkFBTyxDQUFDLHVHQUFhO0FBQ3pDLGdCQUFnQixtQkFBTyxDQUFDLCtGQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyw2QkFBNkI7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLG1FQUFtRTtBQUNwSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELE9BQU87QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUMsNkJBQTZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3Vydml2YWwtZnVuLy4vbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9hZ2VudGtpdC9kaXN0L2FjdGlvbi1wcm92aWRlcnMvbWVzc2FyaS9tZXNzYXJpQWN0aW9uUHJvdmlkZXIuanM/NmRjZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm1lc3NhcmlBY3Rpb25Qcm92aWRlciA9IGV4cG9ydHMuTWVzc2FyaUFjdGlvblByb3ZpZGVyID0gdm9pZCAwO1xuY29uc3Qgem9kXzEgPSByZXF1aXJlKFwiem9kXCIpO1xuY29uc3QgYWN0aW9uUHJvdmlkZXJfMSA9IHJlcXVpcmUoXCIuLi9hY3Rpb25Qcm92aWRlclwiKTtcbmNvbnN0IGFjdGlvbkRlY29yYXRvcl8xID0gcmVxdWlyZShcIi4uL2FjdGlvbkRlY29yYXRvclwiKTtcbmNvbnN0IHNjaGVtYXNfMSA9IHJlcXVpcmUoXCIuL3NjaGVtYXNcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbi8qKlxuICogTWVzc2FyaUFjdGlvblByb3ZpZGVyIGlzIGFuIGFjdGlvbiBwcm92aWRlciBmb3IgTWVzc2FyaSBBSSB0b29sa2l0IGludGVyYWN0aW9ucy5cbiAqIEl0IGVuYWJsZXMgQUkgYWdlbnRzIHRvIGFzayByZXNlYXJjaCBxdWVzdGlvbnMgYWJvdXQgY3J5cHRvIG1hcmtldHMsIHByb3RvY29scywgYW5kIHRva2Vucy5cbiAqXG4gKiBAYXVnbWVudHMgQWN0aW9uUHJvdmlkZXJcbiAqL1xuY2xhc3MgTWVzc2FyaUFjdGlvblByb3ZpZGVyIGV4dGVuZHMgYWN0aW9uUHJvdmlkZXJfMS5BY3Rpb25Qcm92aWRlciB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIHRoZSBNZXNzYXJpQWN0aW9uUHJvdmlkZXIgY2xhc3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29uZmlnIC0gVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIE1lc3NhcmlBY3Rpb25Qcm92aWRlclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKFwibWVzc2FyaVwiLCBbXSk7XG4gICAgICAgIGNvbmZpZy5hcGlLZXkgfHwgKGNvbmZpZy5hcGlLZXkgPSBwcm9jZXNzLmVudi5NRVNTQVJJX0FQSV9LRVkpO1xuICAgICAgICBpZiAoIWNvbmZpZy5hcGlLZXkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihjb25zdGFudHNfMS5BUElfS0VZX01JU1NJTkdfRVJST1IpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXBpS2V5ID0gY29uZmlnLmFwaUtleTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFrZXMgYSByZXF1ZXN0IHRvIHRoZSBNZXNzYXJpIEFJIEFQSSB3aXRoIGEgcmVzZWFyY2ggcXVlc3Rpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhcmdzIC0gVGhlIGFyZ3VtZW50cyBjb250YWluaW5nIHRoZSByZXNlYXJjaCBxdWVzdGlvblxuICAgICAqIEByZXR1cm5zIEEgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIHJlc2VhcmNoIHJlc3VsdHMgb3IgYW4gZXJyb3IgbWVzc2FnZVxuICAgICAqL1xuICAgIGFzeW5jIHJlc2VhcmNoUXVlc3Rpb24oYXJncykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTWFrZSBBUEkgcmVxdWVzdFxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtjb25zdGFudHNfMS5NRVNTQVJJX0JBU0VfVVJMfS9jaGF0L2NvbXBsZXRpb25zYCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgICAgICAgICAgXCJ4LW1lc3NhcmktYXBpLWtleVwiOiB0aGlzLmFwaUtleSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb2xlOiBcInVzZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBhcmdzLnF1ZXN0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgICAgIHRocm93IGF3YWl0ICgwLCB1dGlsc18xLmNyZWF0ZU1lc3NhcmlFcnJvcikocmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUGFyc2UgYW5kIHZhbGlkYXRlIHJlc3BvbnNlXG4gICAgICAgICAgICBsZXQgZGF0YTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IChhd2FpdCByZXNwb25zZS5qc29uKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGpzb25FcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHBhcnNlIEFQSSByZXNwb25zZTogJHtqc29uRXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGpzb25FcnJvci5tZXNzYWdlIDogU3RyaW5nKGpzb25FcnJvcil9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWRhdGEuZGF0YT8ubWVzc2FnZXM/LlswXT8uY29udGVudCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlY2VpdmVkIGludmFsaWQgcmVzcG9uc2UgZm9ybWF0IGZyb20gTWVzc2FyaSBBUElcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBkYXRhLmRhdGEubWVzc2FnZXNbMF0uY29udGVudDtcbiAgICAgICAgICAgIHJldHVybiBgTWVzc2FyaSBSZXNlYXJjaCBSZXN1bHRzOlxcblxcbiR7cmVzdWx0fWA7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBcInJlc3BvbnNlVGV4dFwiIGluIGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCB1dGlsc18xLmZvcm1hdE1lc3NhcmlBcGlFcnJvcikoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICgwLCB1dGlsc18xLmZvcm1hdEdlbmVyaWNFcnJvcikoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgYWN0aW9uIHByb3ZpZGVyIHN1cHBvcnRzIHRoZSBnaXZlbiBuZXR3b3JrLlxuICAgICAqIE1lc3NhcmkgcmVzZWFyY2ggaXMgbmV0d29yay1hZ25vc3RpYywgc28gaXQgc3VwcG9ydHMgYWxsIG5ldHdvcmtzLlxuICAgICAqXG4gICAgICogQHBhcmFtIF8gLSBUaGUgbmV0d29yayB0byBjaGVja1xuICAgICAqIEByZXR1cm5zIEFsd2F5cyByZXR1cm5zIHRydWUgYXMgTWVzc2FyaSByZXNlYXJjaCBpcyBuZXR3b3JrLWFnbm9zdGljXG4gICAgICovXG4gICAgc3VwcG9ydHNOZXR3b3JrKF8pIHtcbiAgICAgICAgcmV0dXJuIHRydWU7IC8vIE1lc3NhcmkgcmVzZWFyY2ggaXMgbmV0d29yay1hZ25vc3RpY1xuICAgIH1cbn1cbmV4cG9ydHMuTWVzc2FyaUFjdGlvblByb3ZpZGVyID0gTWVzc2FyaUFjdGlvblByb3ZpZGVyO1xuX19kZWNvcmF0ZShbXG4gICAgKDAsIGFjdGlvbkRlY29yYXRvcl8xLkNyZWF0ZUFjdGlvbikoe1xuICAgICAgICBuYW1lOiBcInJlc2VhcmNoX3F1ZXN0aW9uXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgXG5UaGlzIHRvb2wgcXVlcmllcyBNZXNzYXJpIEFJIGZvciBjb21wcmVoZW5zaXZlIGNyeXB0byByZXNlYXJjaCBhY3Jvc3MgdGhlc2UgZGF0YXNldHM6XG4xLiBOZXdzL0NvbnRlbnQgLSBMYXRlc3QgY3J5cHRvIG5ld3MsIGJsb2dzLCBwb2RjYXN0c1xuMi4gRXhjaGFuZ2VzIC0gQ0VYL0RFWCB2b2x1bWVzLCBtYXJrZXQgc2hhcmUsIGFzc2V0cyBsaXN0ZWRcbjMuIE9uY2hhaW4gRGF0YSAtIEFjdGl2ZSBhZGRyZXNzZXMsIHRyYW5zYWN0aW9uIGZlZXMsIHRvdGFsIHRyYW5zYWN0aW9ucy5cbjQuIFRva2VuIFVubG9ja3MgLSBVcGNvbWluZyBzdXBwbHkgdW5sb2NrcywgdmVzdGluZyBzY2hlZHVsZXMsIGFuZCB0b2tlbiBlbWlzc2lvbiBkZXRhaWxzXG41LiBNYXJrZXQgRGF0YSAtIEFzc2V0IHByaWNlcywgdHJhZGluZyB2b2x1bWUsIG1hcmtldCBjYXAsIFRWTCwgYW5kIGhpc3RvcmljYWwgcGVyZm9ybWFuY2VcbjYuIEZ1bmRyYWlzaW5nIC0gSW52ZXN0bWVudCBkYXRhLCBmdW5kaW5nIHJvdW5kcywgdmVudHVyZSBjYXBpdGFsIGFjdGl2aXR5LlxuNy4gUHJvdG9jb2wgUmVzZWFyY2ggLSBUZWNobmljYWwgYW5hbHlzaXMgb2YgaG93IHByb3RvY29scyB3b3JrLCB0b2tlbm9taWNzLCBhbmQgeWllbGQgbWVjaGFuaXNtc1xuOC4gU29jaWFsIERhdGEgLSBUd2l0dGVyIGZvbGxvd2VycyBhbmQgUmVkZGl0IHN1YnNjcmliZXJzIG1ldHJpY3MsIGdyb3d0aCB0cmVuZHNcblxuRXhhbXBsZXM6IFwiV2hpY2ggREVYcyBoYXZlIHRoZSBoaWdoZXN0IHRyYWRpbmcgdm9sdW1lIHRoaXMgbW9udGg/XCIsIFwiV2hlbiBpcyBBcmJpdHJ1bSdzIG5leHQgbWFqb3IgdG9rZW4gdW5sb2NrP1wiLCBcIkhvdyBkb2VzIE1vcnBobyBnZW5lcmF0ZSB5aWVsZCBmb3IgdXNlcnM/XCIsIFwiV2hpY2ggY3J5cHRvY3VycmVuY3kgaGFzIGdhaW5lZCB0aGUgbW9zdCBUd2l0dGVyIGZvbGxvd2VycyBpbiAyMDIzP1wiLCBcIldoYXQgZGlkIFZpdGFsaWsgQnV0ZXJpbiBzYXkgYWJvdXQgcm9sbHVwcyBpbiBoaXMgcmVjZW50IGJsb2cgcG9zdHM/XCJcbiAgICBgLFxuICAgICAgICBzY2hlbWE6IHNjaGVtYXNfMS5NZXNzYXJpUmVzZWFyY2hRdWVzdGlvblNjaGVtYSxcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbdm9pZCAwXSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIFByb21pc2UpXG5dLCBNZXNzYXJpQWN0aW9uUHJvdmlkZXIucHJvdG90eXBlLCBcInJlc2VhcmNoUXVlc3Rpb25cIiwgbnVsbCk7XG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb24gdG8gY3JlYXRlIGEgbmV3IE1lc3NhcmlBY3Rpb25Qcm92aWRlciBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0gY29uZmlnIC0gVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIE1lc3NhcmlBY3Rpb25Qcm92aWRlclxuICogQHJldHVybnMgQSBuZXcgaW5zdGFuY2Ugb2YgTWVzc2FyaUFjdGlvblByb3ZpZGVyXG4gKi9cbmNvbnN0IG1lc3NhcmlBY3Rpb25Qcm92aWRlciA9IChjb25maWcgPSB7fSkgPT4gbmV3IE1lc3NhcmlBY3Rpb25Qcm92aWRlcihjb25maWcpO1xuZXhwb3J0cy5tZXNzYXJpQWN0aW9uUHJvdmlkZXIgPSBtZXNzYXJpQWN0aW9uUHJvdmlkZXI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/messari/messariActionProvider.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/messari/schemas.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/messari/schemas.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MessariResearchQuestionSchema = void 0;\nconst zod_1 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/lib/index.js\");\n/**\n * Input schema for submitting a research question to Messari AI.\n */\nexports.MessariResearchQuestionSchema = zod_1.z\n    .object({\n    question: zod_1.z\n        .string()\n        .min(1, \"Research question is required.\")\n        .describe(\"The research question about crypto markets, protocols, or tokens\"),\n})\n    .strip()\n    .describe(\"Input schema for submitting a research question to Messari AI\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9tZXNzYXJpL3NjaGVtYXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUNBQXFDO0FBQ3JDLGNBQWMsbUJBQU8sQ0FBQyxrREFBSztBQUMzQjtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3Vydml2YWwtZnVuLy4vbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9hZ2VudGtpdC9kaXN0L2FjdGlvbi1wcm92aWRlcnMvbWVzc2FyaS9zY2hlbWFzLmpzPzRkZDgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1lc3NhcmlSZXNlYXJjaFF1ZXN0aW9uU2NoZW1hID0gdm9pZCAwO1xuY29uc3Qgem9kXzEgPSByZXF1aXJlKFwiem9kXCIpO1xuLyoqXG4gKiBJbnB1dCBzY2hlbWEgZm9yIHN1Ym1pdHRpbmcgYSByZXNlYXJjaCBxdWVzdGlvbiB0byBNZXNzYXJpIEFJLlxuICovXG5leHBvcnRzLk1lc3NhcmlSZXNlYXJjaFF1ZXN0aW9uU2NoZW1hID0gem9kXzEuelxuICAgIC5vYmplY3Qoe1xuICAgIHF1ZXN0aW9uOiB6b2RfMS56XG4gICAgICAgIC5zdHJpbmcoKVxuICAgICAgICAubWluKDEsIFwiUmVzZWFyY2ggcXVlc3Rpb24gaXMgcmVxdWlyZWQuXCIpXG4gICAgICAgIC5kZXNjcmliZShcIlRoZSByZXNlYXJjaCBxdWVzdGlvbiBhYm91dCBjcnlwdG8gbWFya2V0cywgcHJvdG9jb2xzLCBvciB0b2tlbnNcIiksXG59KVxuICAgIC5zdHJpcCgpXG4gICAgLmRlc2NyaWJlKFwiSW5wdXQgc2NoZW1hIGZvciBzdWJtaXR0aW5nIGEgcmVzZWFyY2ggcXVlc3Rpb24gdG8gTWVzc2FyaSBBSVwiKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/messari/schemas.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/messari/types.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/messari/types.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9tZXNzYXJpL3R5cGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3Vydml2YWwtZnVuLy4vbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9hZ2VudGtpdC9kaXN0L2FjdGlvbi1wcm92aWRlcnMvbWVzc2FyaS90eXBlcy5qcz9kYTYwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/messari/types.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/messari/utils.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/messari/utils.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createMessariError = createMessariError;\nexports.formatMessariApiError = formatMessariApiError;\nexports.formatGenericError = formatGenericError;\n/**\n * Creates a MessariError from an HTTP response\n *\n * @param response - The fetch Response object\n * @returns A MessariError with response details\n */\nasync function createMessariError(response) {\n    const error = new Error(`Messari API returned ${response.status} ${response.statusText}`);\n    error.status = response.status;\n    error.statusText = response.statusText;\n    const responseText = await response.text();\n    error.responseText = responseText;\n    try {\n        const errorJson = JSON.parse(responseText);\n        error.errorResponse = errorJson;\n    }\n    catch {\n        // If parsing fails, just use the raw text\n    }\n    return error;\n}\n/**\n * Formats error details for API errors\n *\n * @param error - The MessariError to format\n * @returns Formatted error message\n */\nfunction formatMessariApiError(error) {\n    if (error.errorResponse?.error) {\n        return `Messari API Error: ${error.errorResponse.error}`;\n    }\n    const errorDetails = {\n        status: error.status,\n        statusText: error.statusText,\n        responseText: error.responseText,\n        message: error.message,\n    };\n    return `Messari API Error: ${JSON.stringify(errorDetails, null, 2)}`;\n}\n/**\n * Formats generic errors\n *\n * @param error - The error to format\n * @returns Formatted error message\n */\nfunction formatGenericError(error) {\n    // Check if this might be a JSON string containing an error message\n    if (typeof error === \"string\") {\n        try {\n            const parsedError = JSON.parse(error);\n            if (parsedError.error) {\n                return `Messari API Error: ${parsedError.error}`;\n            }\n        }\n        catch {\n            // Not valid JSON, continue with normal handling\n        }\n    }\n    return `Unexpected error: ${error instanceof Error ? error.message : String(error)}`;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9tZXNzYXJpL3V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDBCQUEwQjtBQUMxQiw2QkFBNkI7QUFDN0IsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGlCQUFpQixFQUFFLG9CQUFvQjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsMEJBQTBCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHNDQUFzQztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxrQkFBa0I7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHVEQUF1RDtBQUN2RiIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cnZpdmFsLWZ1bi8uL25vZGVfbW9kdWxlcy9AY29pbmJhc2UvYWdlbnRraXQvZGlzdC9hY3Rpb24tcHJvdmlkZXJzL21lc3NhcmkvdXRpbHMuanM/ODdlMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlTWVzc2FyaUVycm9yID0gY3JlYXRlTWVzc2FyaUVycm9yO1xuZXhwb3J0cy5mb3JtYXRNZXNzYXJpQXBpRXJyb3IgPSBmb3JtYXRNZXNzYXJpQXBpRXJyb3I7XG5leHBvcnRzLmZvcm1hdEdlbmVyaWNFcnJvciA9IGZvcm1hdEdlbmVyaWNFcnJvcjtcbi8qKlxuICogQ3JlYXRlcyBhIE1lc3NhcmlFcnJvciBmcm9tIGFuIEhUVFAgcmVzcG9uc2VcbiAqXG4gKiBAcGFyYW0gcmVzcG9uc2UgLSBUaGUgZmV0Y2ggUmVzcG9uc2Ugb2JqZWN0XG4gKiBAcmV0dXJucyBBIE1lc3NhcmlFcnJvciB3aXRoIHJlc3BvbnNlIGRldGFpbHNcbiAqL1xuYXN5bmMgZnVuY3Rpb24gY3JlYXRlTWVzc2FyaUVycm9yKHJlc3BvbnNlKSB7XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYE1lc3NhcmkgQVBJIHJldHVybmVkICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgZXJyb3Iuc3RhdHVzID0gcmVzcG9uc2Uuc3RhdHVzO1xuICAgIGVycm9yLnN0YXR1c1RleHQgPSByZXNwb25zZS5zdGF0dXNUZXh0O1xuICAgIGNvbnN0IHJlc3BvbnNlVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICBlcnJvci5yZXNwb25zZVRleHQgPSByZXNwb25zZVRleHQ7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZXJyb3JKc29uID0gSlNPTi5wYXJzZShyZXNwb25zZVRleHQpO1xuICAgICAgICBlcnJvci5lcnJvclJlc3BvbnNlID0gZXJyb3JKc29uO1xuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIC8vIElmIHBhcnNpbmcgZmFpbHMsIGp1c3QgdXNlIHRoZSByYXcgdGV4dFxuICAgIH1cbiAgICByZXR1cm4gZXJyb3I7XG59XG4vKipcbiAqIEZvcm1hdHMgZXJyb3IgZGV0YWlscyBmb3IgQVBJIGVycm9yc1xuICpcbiAqIEBwYXJhbSBlcnJvciAtIFRoZSBNZXNzYXJpRXJyb3IgdG8gZm9ybWF0XG4gKiBAcmV0dXJucyBGb3JtYXR0ZWQgZXJyb3IgbWVzc2FnZVxuICovXG5mdW5jdGlvbiBmb3JtYXRNZXNzYXJpQXBpRXJyb3IoZXJyb3IpIHtcbiAgICBpZiAoZXJyb3IuZXJyb3JSZXNwb25zZT8uZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGBNZXNzYXJpIEFQSSBFcnJvcjogJHtlcnJvci5lcnJvclJlc3BvbnNlLmVycm9yfWA7XG4gICAgfVxuICAgIGNvbnN0IGVycm9yRGV0YWlscyA9IHtcbiAgICAgICAgc3RhdHVzOiBlcnJvci5zdGF0dXMsXG4gICAgICAgIHN0YXR1c1RleHQ6IGVycm9yLnN0YXR1c1RleHQsXG4gICAgICAgIHJlc3BvbnNlVGV4dDogZXJyb3IucmVzcG9uc2VUZXh0LFxuICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlLFxuICAgIH07XG4gICAgcmV0dXJuIGBNZXNzYXJpIEFQSSBFcnJvcjogJHtKU09OLnN0cmluZ2lmeShlcnJvckRldGFpbHMsIG51bGwsIDIpfWA7XG59XG4vKipcbiAqIEZvcm1hdHMgZ2VuZXJpYyBlcnJvcnNcbiAqXG4gKiBAcGFyYW0gZXJyb3IgLSBUaGUgZXJyb3IgdG8gZm9ybWF0XG4gKiBAcmV0dXJucyBGb3JtYXR0ZWQgZXJyb3IgbWVzc2FnZVxuICovXG5mdW5jdGlvbiBmb3JtYXRHZW5lcmljRXJyb3IoZXJyb3IpIHtcbiAgICAvLyBDaGVjayBpZiB0aGlzIG1pZ2h0IGJlIGEgSlNPTiBzdHJpbmcgY29udGFpbmluZyBhbiBlcnJvciBtZXNzYWdlXG4gICAgaWYgKHR5cGVvZiBlcnJvciA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkRXJyb3IgPSBKU09OLnBhcnNlKGVycm9yKTtcbiAgICAgICAgICAgIGlmIChwYXJzZWRFcnJvci5lcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBgTWVzc2FyaSBBUEkgRXJyb3I6ICR7cGFyc2VkRXJyb3IuZXJyb3J9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICAvLyBOb3QgdmFsaWQgSlNPTiwgY29udGludWUgd2l0aCBub3JtYWwgaGFuZGxpbmdcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYFVuZXhwZWN0ZWQgZXJyb3I6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpfWA7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/messari/utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/moonwell/constants.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/moonwell/constants.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MTOKEN_ABI = exports.ETH_ROUTER_ABI = exports.MTOKENS_UNDERLYING_DECIMALS = exports.TOKEN_DECIMALS = exports.WETH_ROUTER_ADDRESS = exports.MOONWELL_BASE_SEPOLIA_ADDRESSES = exports.MOONWELL_BASE_ADDRESSES = void 0;\nexports.MOONWELL_BASE_ADDRESSES = {\n    \"0xEdc817A28E8B93B03976FBd4a3dDBc9f7D176c22\": \"MOONWELL_USDC\",\n    \"0x73b06D8d18De422E269645eaCe15400DE7462417\": \"MOONWELL_DAI\",\n    \"0x628ff693426583D9a7FB391E54366292F509D457\": \"MOONWELL_WETH\",\n    \"0x3bf93770f2d4a794c3d9EBEfBAeBAE2a8f09A5E5\": \"MOONWELL_cbETH\",\n    \"0x627Fe393Bc6EdDA28e99AE648fD6fF362514304b\": \"MOONWELL_wstETH\",\n    \"0x73902f619CEB9B31FD8EFecf435CbDf89E369Ba6\": \"MOONWELL_AERO\",\n    \"0xb8051464C8c92209C92F3a4CD9C73746C4c3CFb3\": \"MOONWELL_weETH\",\n    \"0xF877ACaFA28c19b96727966690b2f44d35aD5976\": \"MOONWELL_cbBTC\",\n    \"0xb682c840B5F4FC58B20769E691A6fa1305A501a2\": \"MOONWELL_EURC\",\n    \"0xfC41B49d064Ac646015b459C522820DB9472F4B5\": \"MOONWELL_wrsETH\",\n    \"0xdC7810B47eAAb250De623F0eE07764afa5F71ED1\": \"MOONWELL_WELL\",\n    \"0xb6419c6C2e60c4025D6D06eE4F913ce89425a357\": \"MOONWELL_USDS\",\n    \"0x9A858ebfF1bEb0D3495BB0e2897c1528eD84A218\": \"MOONWELL_TBTC\",\n    \"0x70778cfcFC475c7eA0f24cC625Baf6EaE475D0c9\": \"WETH_ROUTER\",\n};\nexports.MOONWELL_BASE_SEPOLIA_ADDRESSES = {\n    \"0x876852425331a113d8E432eFFB3aC5BEf38f033a\": \"MOONWELL_USDBC\",\n    \"0x5302EbD8BC32435C823c2e22B04Cd6c45f593e89\": \"MOONWELL_cbETH\",\n    \"0x2F39a349A79492a70E152760ce7123A1933eCf28\": \"MOONWELL_WETH\",\n};\nexports.WETH_ROUTER_ADDRESS = \"0x70778cfcFC475c7eA0f24cC625Baf6EaE475D0c9\";\n// Token decimals mapping\nexports.TOKEN_DECIMALS = {\n    \"0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913\": 6, // USDC\n    \"0x60a3E35Cc302bFA44Cb288Bc5a4F316Fdb1adb42\": 6, // EURC\n    \"0x04C0599Ae5A44757c0af6F9eC3b93da8976c150A\": 18, // weETH\n    \"0xEDfa23602D0EC14714057867A78d01e94176BEA0\": 18, // wrsETH\n    \"0x236aa50979D5f3De3Bd1Eeb40E81137F22ab794b\": 18, // tBTC\n    \"0xA88594D404727625A9437C3f886C7643872296AE\": 18, // WELL\n    \"0x820C137fa70C8691f0e44Dc420a5e53c168921Dc\": 18, // USDS\n    \"0x50c5725949A6F0c72E6C4a641F24049A917DB0Cb\": 18, // DAI\n    \"0x4200000000000000000000000000000000000006\": 18, // WETH\n    \"0x2Ae3F1Ec7F1F5012CFEab0185bfc7aa3cf0DEc22\": 18, // cbETH\n    \"0xc1CBa3fCea344f92D9239c08C0568f6F2F0ee452\": 18, // wstETH\n    \"0x940181a94a35a4569e4529a3cdfb74e38fd98631\": 18, // AERO\n    \"0x0000000000000000000000000000000000000000\": 18, // ETH (native)\n};\nexports.MTOKENS_UNDERLYING_DECIMALS = {\n    MOONWELL_USDC: 6,\n    MOONWELL_DAI: 18,\n    MOONWELL_WETH: 18,\n    MOONWELL_cbETH: 18,\n    MOONWELL_wstETH: 18,\n    MOONWELL_AERO: 18,\n    MOONWELL_weETH: 18,\n    MOONWELL_cbBTC: 18,\n    MOONWELL_EURC: 6,\n    MOONWELL_wrsETH: 18,\n    MOONWELL_WELL: 18,\n    MOONWELL_USDS: 18,\n    MOONWELL_TBTC: 18,\n};\nexports.ETH_ROUTER_ABI = [\n    {\n        name: \"mint\",\n        inputs: [\n            {\n                internalType: \"address\",\n                name: \"receiver\",\n                type: \"address\",\n            },\n        ],\n        outputs: [],\n        stateMutability: \"payable\",\n        type: \"function\",\n    },\n];\nexports.MTOKEN_ABI = [\n    {\n        type: \"function\",\n        name: \"mint\",\n        inputs: [\n            {\n                name: \"mintAmount\",\n                type: \"uint256\",\n                internalType: \"uint256\",\n            },\n        ],\n        outputs: [\n            {\n                name: \"\",\n                type: \"uint256\",\n                internalType: \"uint256\",\n            },\n        ],\n        stateMutability: \"nonpayable\",\n    },\n    {\n        type: \"function\",\n        name: \"redeemUnderlying\",\n        inputs: [\n            {\n                name: \"redeemAmount\",\n                type: \"uint256\",\n                internalType: \"uint256\",\n            },\n        ],\n        outputs: [\n            {\n                name: \"\",\n                type: \"uint256\",\n                internalType: \"uint256\",\n            },\n        ],\n        stateMutability: \"nonpayable\",\n    },\n];\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9tb29ud2VsbC9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCLEdBQUcsc0JBQXNCLEdBQUcsbUNBQW1DLEdBQUcsc0JBQXNCLEdBQUcsMkJBQTJCLEdBQUcsdUNBQXVDLEdBQUcsK0JBQStCO0FBQ3BOLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLEtBQUs7QUFDTCIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cnZpdmFsLWZ1bi8uL25vZGVfbW9kdWxlcy9AY29pbmJhc2UvYWdlbnRraXQvZGlzdC9hY3Rpb24tcHJvdmlkZXJzL21vb253ZWxsL2NvbnN0YW50cy5qcz9jMmZhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NVE9LRU5fQUJJID0gZXhwb3J0cy5FVEhfUk9VVEVSX0FCSSA9IGV4cG9ydHMuTVRPS0VOU19VTkRFUkxZSU5HX0RFQ0lNQUxTID0gZXhwb3J0cy5UT0tFTl9ERUNJTUFMUyA9IGV4cG9ydHMuV0VUSF9ST1VURVJfQUREUkVTUyA9IGV4cG9ydHMuTU9PTldFTExfQkFTRV9TRVBPTElBX0FERFJFU1NFUyA9IGV4cG9ydHMuTU9PTldFTExfQkFTRV9BRERSRVNTRVMgPSB2b2lkIDA7XG5leHBvcnRzLk1PT05XRUxMX0JBU0VfQUREUkVTU0VTID0ge1xuICAgIFwiMHhFZGM4MTdBMjhFOEI5M0IwMzk3NkZCZDRhM2REQmM5ZjdEMTc2YzIyXCI6IFwiTU9PTldFTExfVVNEQ1wiLFxuICAgIFwiMHg3M2IwNkQ4ZDE4RGU0MjJFMjY5NjQ1ZWFDZTE1NDAwREU3NDYyNDE3XCI6IFwiTU9PTldFTExfREFJXCIsXG4gICAgXCIweDYyOGZmNjkzNDI2NTgzRDlhN0ZCMzkxRTU0MzY2MjkyRjUwOUQ0NTdcIjogXCJNT09OV0VMTF9XRVRIXCIsXG4gICAgXCIweDNiZjkzNzcwZjJkNGE3OTRjM2Q5RUJFZkJBZUJBRTJhOGYwOUE1RTVcIjogXCJNT09OV0VMTF9jYkVUSFwiLFxuICAgIFwiMHg2MjdGZTM5M0JjNkVkREEyOGU5OUFFNjQ4ZkQ2ZkYzNjI1MTQzMDRiXCI6IFwiTU9PTldFTExfd3N0RVRIXCIsXG4gICAgXCIweDczOTAyZjYxOUNFQjlCMzFGRDhFRmVjZjQzNUNiRGY4OUUzNjlCYTZcIjogXCJNT09OV0VMTF9BRVJPXCIsXG4gICAgXCIweGI4MDUxNDY0QzhjOTIyMDlDOTJGM2E0Q0Q5QzczNzQ2QzRjM0NGYjNcIjogXCJNT09OV0VMTF93ZUVUSFwiLFxuICAgIFwiMHhGODc3QUNhRkEyOGMxOWI5NjcyNzk2NjY5MGIyZjQ0ZDM1YUQ1OTc2XCI6IFwiTU9PTldFTExfY2JCVENcIixcbiAgICBcIjB4YjY4MmM4NDBCNUY0RkM1OEIyMDc2OUU2OTFBNmZhMTMwNUE1MDFhMlwiOiBcIk1PT05XRUxMX0VVUkNcIixcbiAgICBcIjB4ZkM0MUI0OWQwNjRBYzY0NjAxNWI0NTlDNTIyODIwREI5NDcyRjRCNVwiOiBcIk1PT05XRUxMX3dyc0VUSFwiLFxuICAgIFwiMHhkQzc4MTBCNDdlQUFiMjUwRGU2MjNGMGVFMDc3NjRhZmE1RjcxRUQxXCI6IFwiTU9PTldFTExfV0VMTFwiLFxuICAgIFwiMHhiNjQxOWM2QzJlNjBjNDAyNUQ2RDA2ZUU0RjkxM2NlODk0MjVhMzU3XCI6IFwiTU9PTldFTExfVVNEU1wiLFxuICAgIFwiMHg5QTg1OGViZkYxYkViMEQzNDk1QkIwZTI4OTdjMTUyOGVEODRBMjE4XCI6IFwiTU9PTldFTExfVEJUQ1wiLFxuICAgIFwiMHg3MDc3OGNmY0ZDNDc1YzdlQTBmMjRjQzYyNUJhZjZFYUU0NzVEMGM5XCI6IFwiV0VUSF9ST1VURVJcIixcbn07XG5leHBvcnRzLk1PT05XRUxMX0JBU0VfU0VQT0xJQV9BRERSRVNTRVMgPSB7XG4gICAgXCIweDg3Njg1MjQyNTMzMWExMTNkOEU0MzJlRkZCM2FDNUJFZjM4ZjAzM2FcIjogXCJNT09OV0VMTF9VU0RCQ1wiLFxuICAgIFwiMHg1MzAyRWJEOEJDMzI0MzVDODIzYzJlMjJCMDRDZDZjNDVmNTkzZTg5XCI6IFwiTU9PTldFTExfY2JFVEhcIixcbiAgICBcIjB4MkYzOWEzNDlBNzk0OTJhNzBFMTUyNzYwY2U3MTIzQTE5MzNlQ2YyOFwiOiBcIk1PT05XRUxMX1dFVEhcIixcbn07XG5leHBvcnRzLldFVEhfUk9VVEVSX0FERFJFU1MgPSBcIjB4NzA3NzhjZmNGQzQ3NWM3ZUEwZjI0Y0M2MjVCYWY2RWFFNDc1RDBjOVwiO1xuLy8gVG9rZW4gZGVjaW1hbHMgbWFwcGluZ1xuZXhwb3J0cy5UT0tFTl9ERUNJTUFMUyA9IHtcbiAgICBcIjB4ODMzNTg5ZkNENmVEYjZFMDhmNGM3QzMyRDRmNzFiNTRiZEEwMjkxM1wiOiA2LCAvLyBVU0RDXG4gICAgXCIweDYwYTNFMzVDYzMwMmJGQTQ0Q2IyODhCYzVhNEYzMTZGZGIxYWRiNDJcIjogNiwgLy8gRVVSQ1xuICAgIFwiMHgwNEMwNTk5QWU1QTQ0NzU3YzBhZjZGOWVDM2I5M2RhODk3NmMxNTBBXCI6IDE4LCAvLyB3ZUVUSFxuICAgIFwiMHhFRGZhMjM2MDJEMEVDMTQ3MTQwNTc4NjdBNzhkMDFlOTQxNzZCRUEwXCI6IDE4LCAvLyB3cnNFVEhcbiAgICBcIjB4MjM2YWE1MDk3OUQ1ZjNEZTNCZDFFZWI0MEU4MTEzN0YyMmFiNzk0YlwiOiAxOCwgLy8gdEJUQ1xuICAgIFwiMHhBODg1OTRENDA0NzI3NjI1QTk0MzdDM2Y4ODZDNzY0Mzg3MjI5NkFFXCI6IDE4LCAvLyBXRUxMXG4gICAgXCIweDgyMEMxMzdmYTcwQzg2OTFmMGU0NERjNDIwYTVlNTNjMTY4OTIxRGNcIjogMTgsIC8vIFVTRFNcbiAgICBcIjB4NTBjNTcyNTk0OUE2RjBjNzJFNkM0YTY0MUYyNDA0OUE5MTdEQjBDYlwiOiAxOCwgLy8gREFJXG4gICAgXCIweDQyMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDZcIjogMTgsIC8vIFdFVEhcbiAgICBcIjB4MkFlM0YxRWM3RjFGNTAxMkNGRWFiMDE4NWJmYzdhYTNjZjBERWMyMlwiOiAxOCwgLy8gY2JFVEhcbiAgICBcIjB4YzFDQmEzZkNlYTM0NGY5MkQ5MjM5YzA4QzA1NjhmNkYyRjBlZTQ1MlwiOiAxOCwgLy8gd3N0RVRIXG4gICAgXCIweDk0MDE4MWE5NGEzNWE0NTY5ZTQ1MjlhM2NkZmI3NGUzOGZkOTg2MzFcIjogMTgsIC8vIEFFUk9cbiAgICBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiOiAxOCwgLy8gRVRIIChuYXRpdmUpXG59O1xuZXhwb3J0cy5NVE9LRU5TX1VOREVSTFlJTkdfREVDSU1BTFMgPSB7XG4gICAgTU9PTldFTExfVVNEQzogNixcbiAgICBNT09OV0VMTF9EQUk6IDE4LFxuICAgIE1PT05XRUxMX1dFVEg6IDE4LFxuICAgIE1PT05XRUxMX2NiRVRIOiAxOCxcbiAgICBNT09OV0VMTF93c3RFVEg6IDE4LFxuICAgIE1PT05XRUxMX0FFUk86IDE4LFxuICAgIE1PT05XRUxMX3dlRVRIOiAxOCxcbiAgICBNT09OV0VMTF9jYkJUQzogMTgsXG4gICAgTU9PTldFTExfRVVSQzogNixcbiAgICBNT09OV0VMTF93cnNFVEg6IDE4LFxuICAgIE1PT05XRUxMX1dFTEw6IDE4LFxuICAgIE1PT05XRUxMX1VTRFM6IDE4LFxuICAgIE1PT05XRUxMX1RCVEM6IDE4LFxufTtcbmV4cG9ydHMuRVRIX1JPVVRFUl9BQkkgPSBbXG4gICAge1xuICAgICAgICBuYW1lOiBcIm1pbnRcIixcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgICAgICAgICBuYW1lOiBcInJlY2VpdmVyXCIsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBvdXRwdXRzOiBbXSxcbiAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiBcInBheWFibGVcIixcbiAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgIH0sXG5dO1xuZXhwb3J0cy5NVE9LRU5fQUJJID0gW1xuICAgIHtcbiAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICBuYW1lOiBcIm1pbnRcIixcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJtaW50QW1vdW50XCIsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIG91dHB1dHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcIlwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6IFwibm9ucGF5YWJsZVwiLFxuICAgIH0sXG4gICAge1xuICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgIG5hbWU6IFwicmVkZWVtVW5kZXJseWluZ1wiLFxuICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcInJlZGVlbUFtb3VudFwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBvdXRwdXRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJcIixcbiAgICAgICAgICAgICAgICB0eXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiBcIm5vbnBheWFibGVcIixcbiAgICB9LFxuXTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/moonwell/constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/moonwell/index.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/moonwell/index.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.moonwellActionProvider = void 0;\nvar moonwellActionProvider_1 = __webpack_require__(/*! ./moonwellActionProvider */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/moonwell/moonwellActionProvider.js\");\nObject.defineProperty(exports, \"moonwellActionProvider\", ({ enumerable: true, get: function () { return moonwellActionProvider_1.moonwellActionProvider; } }));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9tb29ud2VsbC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw4QkFBOEI7QUFDOUIsK0JBQStCLG1CQUFPLENBQUMsa0lBQTBCO0FBQ2pFLDBEQUF5RCxFQUFFLHFDQUFxQywyREFBMkQsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cnZpdmFsLWZ1bi8uL25vZGVfbW9kdWxlcy9AY29pbmJhc2UvYWdlbnRraXQvZGlzdC9hY3Rpb24tcHJvdmlkZXJzL21vb253ZWxsL2luZGV4LmpzPzEyNDMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm1vb253ZWxsQWN0aW9uUHJvdmlkZXIgPSB2b2lkIDA7XG52YXIgbW9vbndlbGxBY3Rpb25Qcm92aWRlcl8xID0gcmVxdWlyZShcIi4vbW9vbndlbGxBY3Rpb25Qcm92aWRlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm1vb253ZWxsQWN0aW9uUHJvdmlkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1vb253ZWxsQWN0aW9uUHJvdmlkZXJfMS5tb29ud2VsbEFjdGlvblByb3ZpZGVyOyB9IH0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/moonwell/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/moonwell/moonwellActionProvider.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/moonwell/moonwellActionProvider.js ***!
  \**************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.moonwellActionProvider = exports.MoonwellActionProvider = exports.SUPPORTED_NETWORKS = void 0;\nconst zod_1 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/lib/index.js\");\nconst decimal_js_1 = __webpack_require__(/*! decimal.js */ \"(rsc)/./node_modules/decimal.js/decimal.js\");\nconst viem_1 = __webpack_require__(/*! viem */ \"(rsc)/./node_modules/viem/_cjs/index.js\");\nconst actionProvider_1 = __webpack_require__(/*! ../actionProvider */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/actionProvider.js\");\nconst wallet_providers_1 = __webpack_require__(/*! ../../wallet-providers */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/wallet-providers/index.js\");\nconst actionDecorator_1 = __webpack_require__(/*! ../actionDecorator */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/actionDecorator.js\");\nconst utils_1 = __webpack_require__(/*! ../../utils */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/utils.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/moonwell/constants.js\");\nconst schemas_1 = __webpack_require__(/*! ./schemas */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/moonwell/schemas.js\");\nexports.SUPPORTED_NETWORKS = [\"base-mainnet\", \"base-sepolia\"];\n/**\n * MoonwellActionProvider is an action provider for Moonwell MToken interactions.\n */\nclass MoonwellActionProvider extends actionProvider_1.ActionProvider {\n    /**\n     * Constructor for the MoonwellActionProvider class.\n     */\n    constructor() {\n        super(\"moonwell\", []);\n        /**\n         * Checks if the Moonwell action provider supports the given network.\n         *\n         * @param network - The network to check.\n         * @returns True if the Moonwell action provider supports the network, false otherwise.\n         */\n        this.supportsNetwork = (network) => network.protocolFamily === \"evm\" && exports.SUPPORTED_NETWORKS.includes(network.networkId);\n    }\n    /**\n     * Deposits assets into a Moonwell MToken\n     *\n     * @param wallet - The wallet instance to execute the transaction\n     * @param args - The input arguments for the action\n     * @returns A success message with transaction details or an error message\n     */\n    async mint(wallet, args) {\n        const assets = new decimal_js_1.Decimal(args.assets);\n        if (assets.comparedTo(new decimal_js_1.Decimal(0.0)) != 1) {\n            return \"Error: Assets amount must be greater than 0\";\n        }\n        const network = wallet.getNetwork();\n        const networkObject = network.networkId === \"base-mainnet\"\n            ? constants_1.MOONWELL_BASE_ADDRESSES\n            : constants_1.MOONWELL_BASE_SEPOLIA_ADDRESSES;\n        if (!networkObject[args.mTokenAddress]) {\n            return \"Error: Invalid MToken address\";\n        }\n        try {\n            // Handle different token decimals\n            let atomicAssets;\n            const userAddress = wallet.getAddress();\n            if (network.networkId === \"base-mainnet\" &&\n                \"MOONWELL_WETH\" === networkObject[args.mTokenAddress]) {\n                // For ETH minting, use parseEther (18 decimals)\n                atomicAssets = (0, viem_1.parseEther)(args.assets);\n            }\n            else {\n                // For other tokens, use the correct decimals\n                const decimals = constants_1.TOKEN_DECIMALS[args.tokenAddress];\n                if (!decimals) {\n                    return `Error: Unsupported token address ${args.tokenAddress}. Please verify the token address is correct.`;\n                }\n                atomicAssets = (0, viem_1.parseUnits)(args.assets, decimals);\n            }\n            // Check if this is a WETH mint on mainnet\n            if (network.networkId === \"base-mainnet\" &&\n                \"MOONWELL_WETH\" === networkObject[args.mTokenAddress]) {\n                // Use the router for ETH mints - no approval needed since we're sending native ETH\n                const data = (0, viem_1.encodeFunctionData)({\n                    abi: constants_1.ETH_ROUTER_ABI,\n                    functionName: \"mint\",\n                    args: [userAddress],\n                });\n                const txHash = await wallet.sendTransaction({\n                    to: constants_1.WETH_ROUTER_ADDRESS,\n                    data,\n                    value: atomicAssets,\n                });\n                const receipt = await wallet.waitForTransactionReceipt(txHash);\n                return `Deposited ${args.assets} ETH to Moonwell WETH via router with transaction hash: ${txHash}\\nTransaction receipt: ${JSON.stringify(receipt, (_, value) => (typeof value === \"bigint\" ? value.toString() : value))}`;\n            }\n            else {\n                // For all other tokens, we need approval first\n                const approvalResult = await (0, utils_1.approve)(wallet, args.tokenAddress, args.mTokenAddress, atomicAssets);\n                if (approvalResult.startsWith(\"Error\")) {\n                    return `Error approving Moonwell MToken as spender: ${approvalResult}`;\n                }\n                const data = (0, viem_1.encodeFunctionData)({\n                    abi: constants_1.MTOKEN_ABI,\n                    functionName: \"mint\",\n                    args: [atomicAssets],\n                });\n                const txHash = await wallet.sendTransaction({\n                    to: args.mTokenAddress,\n                    data,\n                    value: 0n,\n                });\n                const receipt = await wallet.waitForTransactionReceipt(txHash);\n                if (!receipt) {\n                    throw new Error(\"No receipt received for mint transaction\");\n                }\n                if (receipt.status !== \"success\") {\n                    throw new Error(`Mint transaction failed with status ${receipt.status}`);\n                }\n                return `Deposited ${args.assets} to Moonwell MToken ${args.mTokenAddress} with transaction hash: ${txHash}\\nTransaction receipt: ${JSON.stringify(receipt, (_, value) => (typeof value === \"bigint\" ? value.toString() : value))}`;\n            }\n        }\n        catch (error) {\n            console.error(\"DEBUG - Mint error:\", error);\n            if (error instanceof Error) {\n                return `Error minting Moonwell MToken: ${error.message}`;\n            }\n            return `Error minting Moonwell MToken: ${error}`;\n        }\n    }\n    /**\n     * Redeems assets from a Moonwell MToken\n     *\n     * @param wallet - The wallet instance to execute the transaction\n     * @param args - The input arguments for the action\n     * @returns A success message with transaction details or an error message\n     */\n    async redeem(wallet, args) {\n        const assets = new decimal_js_1.Decimal(args.assets);\n        if (assets.comparedTo(new decimal_js_1.Decimal(0.0)) != 1) {\n            return \"Error: Assets amount must be greater than 0\";\n        }\n        const network = wallet.getNetwork();\n        const networkObject = network.networkId === \"base-mainnet\"\n            ? constants_1.MOONWELL_BASE_ADDRESSES\n            : constants_1.MOONWELL_BASE_SEPOLIA_ADDRESSES;\n        if (!networkObject[args.mTokenAddress]) {\n            return \"Error: Invalid MToken address\";\n        }\n        try {\n            // Handle different token decimals\n            const decimals = constants_1.MTOKENS_UNDERLYING_DECIMALS[constants_1.MOONWELL_BASE_ADDRESSES[args.mTokenAddress]];\n            if (!decimals) {\n                return `Error: Unsupported token address ${args.mTokenAddress}. Please verify the token address is correct.`;\n            }\n            const atomicAssets = (0, viem_1.parseUnits)(args.assets, decimals);\n            const data = (0, viem_1.encodeFunctionData)({\n                abi: constants_1.MTOKEN_ABI,\n                functionName: \"redeemUnderlying\",\n                args: [atomicAssets],\n            });\n            const txHash = await wallet.sendTransaction({\n                to: args.mTokenAddress,\n                data,\n                value: 0n,\n            });\n            const receipt = await wallet.waitForTransactionReceipt(txHash);\n            if (!receipt) {\n                throw new Error(\"No receipt received for redeem transaction\");\n            }\n            if (receipt.status !== \"success\") {\n                throw new Error(`Redeem transaction failed with status ${receipt.status}`);\n            }\n            return `Redeemed ${args.assets} from Moonwell MToken ${args.mTokenAddress} with transaction hash: ${txHash}\\nTransaction receipt: ${JSON.stringify(receipt, (_, value) => (typeof value === \"bigint\" ? value.toString() : value))}`;\n        }\n        catch (error) {\n            console.error(\"DEBUG - Redeem error:\", error);\n            if (error instanceof Error) {\n                return `Error redeeming from Moonwell MToken: ${error.message}`;\n            }\n            return `Error redeeming from Moonwell MToken: ${error}`;\n        }\n    }\n}\nexports.MoonwellActionProvider = MoonwellActionProvider;\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"mint\",\n        description: `\nThis tool allows minting assets into a Moonwell MToken. \n\nIt takes:\n- mTokenAddress: The address of the Moonwell MToken to mint to\n- assets: The amount of assets that will be approved to spend by the mToken in whole units\n  Examples for WETH:\n  - 1 WETH\n  - 0.1 WETH\n  - 0.01 WETH\n  Examples for cbETH:\n  - 1 cbETH\n  - 0.1 cbETH\n  - 0.01 cbETH\n  Examples for USDC:\n  - 1 USDC\n  - 0.1 USDC\n  - 0.01 USDC\n- tokenAddress: The address of the token to approve\n\nImportant notes:\n- Make sure to use the exact amount provided. Do not convert units for assets for this action.\n- Please use a token address (example 0x4200000000000000000000000000000000000006) for the tokenAddress field.\n- This tool handles token approval. If requested to mint on Moonwell, do not use any other actions to approve tokens.\n`,\n        schema: schemas_1.MintSchema,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [wallet_providers_1.EvmWalletProvider, void 0]),\n    __metadata(\"design:returntype\", Promise)\n], MoonwellActionProvider.prototype, \"mint\", null);\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"redeem\",\n        description: `\nThis tool allows redeeming assets from a Moonwell MToken. \n\nIt takes:\n- mTokenAddress: The address of the Moonwell MToken to redeem from\n- assets: The amount of assets to redeem in whole units\n  Examples for WETH:\n  - 1 WETH\n  - 0.1 WETH\n  - 0.01 WETH\n  Examples for cbETH:\n  - 1 cbETH\n  - 0.1 cbETH\n  - 0.01 cbETH\n  Examples for USDC:\n  - 1 USDC\n  - 0.1 USDC\n  - 0.01 USDC\n\nImportant notes:\n- Make sure to use the exact amount provided. Do not convert units for assets for this action.\n- Please use a token address (example 0x4200000000000000000000000000000000000006) for the tokenAddress field.\n`,\n        schema: schemas_1.RedeemSchema,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [wallet_providers_1.EvmWalletProvider, void 0]),\n    __metadata(\"design:returntype\", Promise)\n], MoonwellActionProvider.prototype, \"redeem\", null);\nconst moonwellActionProvider = () => new MoonwellActionProvider();\nexports.moonwellActionProvider = moonwellActionProvider;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9tb29ud2VsbC9tb29ud2VsbEFjdGlvblByb3ZpZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFFBQVE7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw4QkFBOEIsR0FBRyw4QkFBOEIsR0FBRywwQkFBMEI7QUFDNUYsY0FBYyxtQkFBTyxDQUFDLGtEQUFLO0FBQzNCLHFCQUFxQixtQkFBTyxDQUFDLDhEQUFZO0FBQ3pDLGVBQWUsbUJBQU8sQ0FBQyxxREFBTTtBQUM3Qix5QkFBeUIsbUJBQU8sQ0FBQywwR0FBbUI7QUFDcEQsMkJBQTJCLG1CQUFPLENBQUMsc0dBQXdCO0FBQzNELDBCQUEwQixtQkFBTyxDQUFDLDRHQUFvQjtBQUN0RCxnQkFBZ0IsbUJBQU8sQ0FBQywwRUFBYTtBQUNyQyxvQkFBb0IsbUJBQU8sQ0FBQyx3R0FBYTtBQUN6QyxrQkFBa0IsbUJBQU8sQ0FBQyxvR0FBVztBQUNyQywwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Qsa0JBQWtCO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxvQ0FBb0MsYUFBYSx5REFBeUQsT0FBTyx5QkFBeUIsOEZBQThGO0FBQ3hPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsZUFBZTtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsZUFBZTtBQUMxRjtBQUNBLG9DQUFvQyxhQUFhLHFCQUFxQixvQkFBb0IseUJBQXlCLE9BQU8seUJBQXlCLDhGQUE4RjtBQUNqUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELGNBQWM7QUFDdkU7QUFDQSxxREFBcUQsTUFBTTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxtQkFBbUI7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsZUFBZTtBQUN4RjtBQUNBLCtCQUErQixhQUFhLHVCQUF1QixvQkFBb0IseUJBQXlCLE9BQU8seUJBQXlCLDhGQUE4RjtBQUM5TztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxjQUFjO0FBQzlFO0FBQ0EsNERBQTRELE1BQU07QUFDbEU7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3Vydml2YWwtZnVuLy4vbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9hZ2VudGtpdC9kaXN0L2FjdGlvbi1wcm92aWRlcnMvbW9vbndlbGwvbW9vbndlbGxBY3Rpb25Qcm92aWRlci5qcz9jYzhhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubW9vbndlbGxBY3Rpb25Qcm92aWRlciA9IGV4cG9ydHMuTW9vbndlbGxBY3Rpb25Qcm92aWRlciA9IGV4cG9ydHMuU1VQUE9SVEVEX05FVFdPUktTID0gdm9pZCAwO1xuY29uc3Qgem9kXzEgPSByZXF1aXJlKFwiem9kXCIpO1xuY29uc3QgZGVjaW1hbF9qc18xID0gcmVxdWlyZShcImRlY2ltYWwuanNcIik7XG5jb25zdCB2aWVtXzEgPSByZXF1aXJlKFwidmllbVwiKTtcbmNvbnN0IGFjdGlvblByb3ZpZGVyXzEgPSByZXF1aXJlKFwiLi4vYWN0aW9uUHJvdmlkZXJcIik7XG5jb25zdCB3YWxsZXRfcHJvdmlkZXJzXzEgPSByZXF1aXJlKFwiLi4vLi4vd2FsbGV0LXByb3ZpZGVyc1wiKTtcbmNvbnN0IGFjdGlvbkRlY29yYXRvcl8xID0gcmVxdWlyZShcIi4uL2FjdGlvbkRlY29yYXRvclwiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHNcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IHNjaGVtYXNfMSA9IHJlcXVpcmUoXCIuL3NjaGVtYXNcIik7XG5leHBvcnRzLlNVUFBPUlRFRF9ORVRXT1JLUyA9IFtcImJhc2UtbWFpbm5ldFwiLCBcImJhc2Utc2Vwb2xpYVwiXTtcbi8qKlxuICogTW9vbndlbGxBY3Rpb25Qcm92aWRlciBpcyBhbiBhY3Rpb24gcHJvdmlkZXIgZm9yIE1vb253ZWxsIE1Ub2tlbiBpbnRlcmFjdGlvbnMuXG4gKi9cbmNsYXNzIE1vb253ZWxsQWN0aW9uUHJvdmlkZXIgZXh0ZW5kcyBhY3Rpb25Qcm92aWRlcl8xLkFjdGlvblByb3ZpZGVyIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgdGhlIE1vb253ZWxsQWN0aW9uUHJvdmlkZXIgY2xhc3MuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKFwibW9vbndlbGxcIiwgW10pO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2tzIGlmIHRoZSBNb29ud2VsbCBhY3Rpb24gcHJvdmlkZXIgc3VwcG9ydHMgdGhlIGdpdmVuIG5ldHdvcmsuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBuZXR3b3JrIC0gVGhlIG5ldHdvcmsgdG8gY2hlY2suXG4gICAgICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIE1vb253ZWxsIGFjdGlvbiBwcm92aWRlciBzdXBwb3J0cyB0aGUgbmV0d29yaywgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdXBwb3J0c05ldHdvcmsgPSAobmV0d29yaykgPT4gbmV0d29yay5wcm90b2NvbEZhbWlseSA9PT0gXCJldm1cIiAmJiBleHBvcnRzLlNVUFBPUlRFRF9ORVRXT1JLUy5pbmNsdWRlcyhuZXR3b3JrLm5ldHdvcmtJZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlcG9zaXRzIGFzc2V0cyBpbnRvIGEgTW9vbndlbGwgTVRva2VuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gd2FsbGV0IC0gVGhlIHdhbGxldCBpbnN0YW5jZSB0byBleGVjdXRlIHRoZSB0cmFuc2FjdGlvblxuICAgICAqIEBwYXJhbSBhcmdzIC0gVGhlIGlucHV0IGFyZ3VtZW50cyBmb3IgdGhlIGFjdGlvblxuICAgICAqIEByZXR1cm5zIEEgc3VjY2VzcyBtZXNzYWdlIHdpdGggdHJhbnNhY3Rpb24gZGV0YWlscyBvciBhbiBlcnJvciBtZXNzYWdlXG4gICAgICovXG4gICAgYXN5bmMgbWludCh3YWxsZXQsIGFyZ3MpIHtcbiAgICAgICAgY29uc3QgYXNzZXRzID0gbmV3IGRlY2ltYWxfanNfMS5EZWNpbWFsKGFyZ3MuYXNzZXRzKTtcbiAgICAgICAgaWYgKGFzc2V0cy5jb21wYXJlZFRvKG5ldyBkZWNpbWFsX2pzXzEuRGVjaW1hbCgwLjApKSAhPSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJFcnJvcjogQXNzZXRzIGFtb3VudCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwXCI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV0d29yayA9IHdhbGxldC5nZXROZXR3b3JrKCk7XG4gICAgICAgIGNvbnN0IG5ldHdvcmtPYmplY3QgPSBuZXR3b3JrLm5ldHdvcmtJZCA9PT0gXCJiYXNlLW1haW5uZXRcIlxuICAgICAgICAgICAgPyBjb25zdGFudHNfMS5NT09OV0VMTF9CQVNFX0FERFJFU1NFU1xuICAgICAgICAgICAgOiBjb25zdGFudHNfMS5NT09OV0VMTF9CQVNFX1NFUE9MSUFfQUREUkVTU0VTO1xuICAgICAgICBpZiAoIW5ldHdvcmtPYmplY3RbYXJncy5tVG9rZW5BZGRyZXNzXSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiRXJyb3I6IEludmFsaWQgTVRva2VuIGFkZHJlc3NcIjtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gSGFuZGxlIGRpZmZlcmVudCB0b2tlbiBkZWNpbWFsc1xuICAgICAgICAgICAgbGV0IGF0b21pY0Fzc2V0cztcbiAgICAgICAgICAgIGNvbnN0IHVzZXJBZGRyZXNzID0gd2FsbGV0LmdldEFkZHJlc3MoKTtcbiAgICAgICAgICAgIGlmIChuZXR3b3JrLm5ldHdvcmtJZCA9PT0gXCJiYXNlLW1haW5uZXRcIiAmJlxuICAgICAgICAgICAgICAgIFwiTU9PTldFTExfV0VUSFwiID09PSBuZXR3b3JrT2JqZWN0W2FyZ3MubVRva2VuQWRkcmVzc10pIHtcbiAgICAgICAgICAgICAgICAvLyBGb3IgRVRIIG1pbnRpbmcsIHVzZSBwYXJzZUV0aGVyICgxOCBkZWNpbWFscylcbiAgICAgICAgICAgICAgICBhdG9taWNBc3NldHMgPSAoMCwgdmllbV8xLnBhcnNlRXRoZXIpKGFyZ3MuYXNzZXRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEZvciBvdGhlciB0b2tlbnMsIHVzZSB0aGUgY29ycmVjdCBkZWNpbWFsc1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlY2ltYWxzID0gY29uc3RhbnRzXzEuVE9LRU5fREVDSU1BTFNbYXJncy50b2tlbkFkZHJlc3NdO1xuICAgICAgICAgICAgICAgIGlmICghZGVjaW1hbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGBFcnJvcjogVW5zdXBwb3J0ZWQgdG9rZW4gYWRkcmVzcyAke2FyZ3MudG9rZW5BZGRyZXNzfS4gUGxlYXNlIHZlcmlmeSB0aGUgdG9rZW4gYWRkcmVzcyBpcyBjb3JyZWN0LmA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGF0b21pY0Fzc2V0cyA9ICgwLCB2aWVtXzEucGFyc2VVbml0cykoYXJncy5hc3NldHMsIGRlY2ltYWxzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoaXMgaXMgYSBXRVRIIG1pbnQgb24gbWFpbm5ldFxuICAgICAgICAgICAgaWYgKG5ldHdvcmsubmV0d29ya0lkID09PSBcImJhc2UtbWFpbm5ldFwiICYmXG4gICAgICAgICAgICAgICAgXCJNT09OV0VMTF9XRVRIXCIgPT09IG5ldHdvcmtPYmplY3RbYXJncy5tVG9rZW5BZGRyZXNzXSkge1xuICAgICAgICAgICAgICAgIC8vIFVzZSB0aGUgcm91dGVyIGZvciBFVEggbWludHMgLSBubyBhcHByb3ZhbCBuZWVkZWQgc2luY2Ugd2UncmUgc2VuZGluZyBuYXRpdmUgRVRIXG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9ICgwLCB2aWVtXzEuZW5jb2RlRnVuY3Rpb25EYXRhKSh7XG4gICAgICAgICAgICAgICAgICAgIGFiaTogY29uc3RhbnRzXzEuRVRIX1JPVVRFUl9BQkksXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogXCJtaW50XCIsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFt1c2VyQWRkcmVzc10sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHhIYXNoID0gYXdhaXQgd2FsbGV0LnNlbmRUcmFuc2FjdGlvbih7XG4gICAgICAgICAgICAgICAgICAgIHRvOiBjb25zdGFudHNfMS5XRVRIX1JPVVRFUl9BRERSRVNTLFxuICAgICAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogYXRvbWljQXNzZXRzLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCB3YWxsZXQud2FpdEZvclRyYW5zYWN0aW9uUmVjZWlwdCh0eEhhc2gpO1xuICAgICAgICAgICAgICAgIHJldHVybiBgRGVwb3NpdGVkICR7YXJncy5hc3NldHN9IEVUSCB0byBNb29ud2VsbCBXRVRIIHZpYSByb3V0ZXIgd2l0aCB0cmFuc2FjdGlvbiBoYXNoOiAke3R4SGFzaH1cXG5UcmFuc2FjdGlvbiByZWNlaXB0OiAke0pTT04uc3RyaW5naWZ5KHJlY2VpcHQsIChfLCB2YWx1ZSkgPT4gKHR5cGVvZiB2YWx1ZSA9PT0gXCJiaWdpbnRcIiA/IHZhbHVlLnRvU3RyaW5nKCkgOiB2YWx1ZSkpfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBGb3IgYWxsIG90aGVyIHRva2Vucywgd2UgbmVlZCBhcHByb3ZhbCBmaXJzdFxuICAgICAgICAgICAgICAgIGNvbnN0IGFwcHJvdmFsUmVzdWx0ID0gYXdhaXQgKDAsIHV0aWxzXzEuYXBwcm92ZSkod2FsbGV0LCBhcmdzLnRva2VuQWRkcmVzcywgYXJncy5tVG9rZW5BZGRyZXNzLCBhdG9taWNBc3NldHMpO1xuICAgICAgICAgICAgICAgIGlmIChhcHByb3ZhbFJlc3VsdC5zdGFydHNXaXRoKFwiRXJyb3JcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGBFcnJvciBhcHByb3ZpbmcgTW9vbndlbGwgTVRva2VuIGFzIHNwZW5kZXI6ICR7YXBwcm92YWxSZXN1bHR9YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9ICgwLCB2aWVtXzEuZW5jb2RlRnVuY3Rpb25EYXRhKSh7XG4gICAgICAgICAgICAgICAgICAgIGFiaTogY29uc3RhbnRzXzEuTVRPS0VOX0FCSSxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiBcIm1pbnRcIixcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW2F0b21pY0Fzc2V0c10sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHhIYXNoID0gYXdhaXQgd2FsbGV0LnNlbmRUcmFuc2FjdGlvbih7XG4gICAgICAgICAgICAgICAgICAgIHRvOiBhcmdzLm1Ub2tlbkFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiAwbixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCByZWNlaXB0ID0gYXdhaXQgd2FsbGV0LndhaXRGb3JUcmFuc2FjdGlvblJlY2VpcHQodHhIYXNoKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlY2VpcHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gcmVjZWlwdCByZWNlaXZlZCBmb3IgbWludCB0cmFuc2FjdGlvblwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlY2VpcHQuc3RhdHVzICE9PSBcInN1Y2Nlc3NcIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1pbnQgdHJhbnNhY3Rpb24gZmFpbGVkIHdpdGggc3RhdHVzICR7cmVjZWlwdC5zdGF0dXN9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBgRGVwb3NpdGVkICR7YXJncy5hc3NldHN9IHRvIE1vb253ZWxsIE1Ub2tlbiAke2FyZ3MubVRva2VuQWRkcmVzc30gd2l0aCB0cmFuc2FjdGlvbiBoYXNoOiAke3R4SGFzaH1cXG5UcmFuc2FjdGlvbiByZWNlaXB0OiAke0pTT04uc3RyaW5naWZ5KHJlY2VpcHQsIChfLCB2YWx1ZSkgPT4gKHR5cGVvZiB2YWx1ZSA9PT0gXCJiaWdpbnRcIiA/IHZhbHVlLnRvU3RyaW5nKCkgOiB2YWx1ZSkpfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiREVCVUcgLSBNaW50IGVycm9yOlwiLCBlcnJvcik7XG4gICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBgRXJyb3IgbWludGluZyBNb29ud2VsbCBNVG9rZW46ICR7ZXJyb3IubWVzc2FnZX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGBFcnJvciBtaW50aW5nIE1vb253ZWxsIE1Ub2tlbjogJHtlcnJvcn1gO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZGVlbXMgYXNzZXRzIGZyb20gYSBNb29ud2VsbCBNVG9rZW5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB3YWxsZXQgLSBUaGUgd2FsbGV0IGluc3RhbmNlIHRvIGV4ZWN1dGUgdGhlIHRyYW5zYWN0aW9uXG4gICAgICogQHBhcmFtIGFyZ3MgLSBUaGUgaW5wdXQgYXJndW1lbnRzIGZvciB0aGUgYWN0aW9uXG4gICAgICogQHJldHVybnMgQSBzdWNjZXNzIG1lc3NhZ2Ugd2l0aCB0cmFuc2FjdGlvbiBkZXRhaWxzIG9yIGFuIGVycm9yIG1lc3NhZ2VcbiAgICAgKi9cbiAgICBhc3luYyByZWRlZW0od2FsbGV0LCBhcmdzKSB7XG4gICAgICAgIGNvbnN0IGFzc2V0cyA9IG5ldyBkZWNpbWFsX2pzXzEuRGVjaW1hbChhcmdzLmFzc2V0cyk7XG4gICAgICAgIGlmIChhc3NldHMuY29tcGFyZWRUbyhuZXcgZGVjaW1hbF9qc18xLkRlY2ltYWwoMC4wKSkgIT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiRXJyb3I6IEFzc2V0cyBhbW91bnQgbXVzdCBiZSBncmVhdGVyIHRoYW4gMFwiO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ldHdvcmsgPSB3YWxsZXQuZ2V0TmV0d29yaygpO1xuICAgICAgICBjb25zdCBuZXR3b3JrT2JqZWN0ID0gbmV0d29yay5uZXR3b3JrSWQgPT09IFwiYmFzZS1tYWlubmV0XCJcbiAgICAgICAgICAgID8gY29uc3RhbnRzXzEuTU9PTldFTExfQkFTRV9BRERSRVNTRVNcbiAgICAgICAgICAgIDogY29uc3RhbnRzXzEuTU9PTldFTExfQkFTRV9TRVBPTElBX0FERFJFU1NFUztcbiAgICAgICAgaWYgKCFuZXR3b3JrT2JqZWN0W2FyZ3MubVRva2VuQWRkcmVzc10pIHtcbiAgICAgICAgICAgIHJldHVybiBcIkVycm9yOiBJbnZhbGlkIE1Ub2tlbiBhZGRyZXNzXCI7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIEhhbmRsZSBkaWZmZXJlbnQgdG9rZW4gZGVjaW1hbHNcbiAgICAgICAgICAgIGNvbnN0IGRlY2ltYWxzID0gY29uc3RhbnRzXzEuTVRPS0VOU19VTkRFUkxZSU5HX0RFQ0lNQUxTW2NvbnN0YW50c18xLk1PT05XRUxMX0JBU0VfQUREUkVTU0VTW2FyZ3MubVRva2VuQWRkcmVzc11dO1xuICAgICAgICAgICAgaWYgKCFkZWNpbWFscykge1xuICAgICAgICAgICAgICAgIHJldHVybiBgRXJyb3I6IFVuc3VwcG9ydGVkIHRva2VuIGFkZHJlc3MgJHthcmdzLm1Ub2tlbkFkZHJlc3N9LiBQbGVhc2UgdmVyaWZ5IHRoZSB0b2tlbiBhZGRyZXNzIGlzIGNvcnJlY3QuYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGF0b21pY0Fzc2V0cyA9ICgwLCB2aWVtXzEucGFyc2VVbml0cykoYXJncy5hc3NldHMsIGRlY2ltYWxzKTtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSAoMCwgdmllbV8xLmVuY29kZUZ1bmN0aW9uRGF0YSkoe1xuICAgICAgICAgICAgICAgIGFiaTogY29uc3RhbnRzXzEuTVRPS0VOX0FCSSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWU6IFwicmVkZWVtVW5kZXJseWluZ1wiLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFthdG9taWNBc3NldHNdLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCB0eEhhc2ggPSBhd2FpdCB3YWxsZXQuc2VuZFRyYW5zYWN0aW9uKHtcbiAgICAgICAgICAgICAgICB0bzogYXJncy5tVG9rZW5BZGRyZXNzLFxuICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICAgdmFsdWU6IDBuLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCByZWNlaXB0ID0gYXdhaXQgd2FsbGV0LndhaXRGb3JUcmFuc2FjdGlvblJlY2VpcHQodHhIYXNoKTtcbiAgICAgICAgICAgIGlmICghcmVjZWlwdCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHJlY2VpcHQgcmVjZWl2ZWQgZm9yIHJlZGVlbSB0cmFuc2FjdGlvblwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZWNlaXB0LnN0YXR1cyAhPT0gXCJzdWNjZXNzXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFJlZGVlbSB0cmFuc2FjdGlvbiBmYWlsZWQgd2l0aCBzdGF0dXMgJHtyZWNlaXB0LnN0YXR1c31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBgUmVkZWVtZWQgJHthcmdzLmFzc2V0c30gZnJvbSBNb29ud2VsbCBNVG9rZW4gJHthcmdzLm1Ub2tlbkFkZHJlc3N9IHdpdGggdHJhbnNhY3Rpb24gaGFzaDogJHt0eEhhc2h9XFxuVHJhbnNhY3Rpb24gcmVjZWlwdDogJHtKU09OLnN0cmluZ2lmeShyZWNlaXB0LCAoXywgdmFsdWUpID0+ICh0eXBlb2YgdmFsdWUgPT09IFwiYmlnaW50XCIgPyB2YWx1ZS50b1N0cmluZygpIDogdmFsdWUpKX1gO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkRFQlVHIC0gUmVkZWVtIGVycm9yOlwiLCBlcnJvcik7XG4gICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBgRXJyb3IgcmVkZWVtaW5nIGZyb20gTW9vbndlbGwgTVRva2VuOiAke2Vycm9yLm1lc3NhZ2V9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBgRXJyb3IgcmVkZWVtaW5nIGZyb20gTW9vbndlbGwgTVRva2VuOiAke2Vycm9yfWA7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLk1vb253ZWxsQWN0aW9uUHJvdmlkZXIgPSBNb29ud2VsbEFjdGlvblByb3ZpZGVyO1xuX19kZWNvcmF0ZShbXG4gICAgKDAsIGFjdGlvbkRlY29yYXRvcl8xLkNyZWF0ZUFjdGlvbikoe1xuICAgICAgICBuYW1lOiBcIm1pbnRcIixcbiAgICAgICAgZGVzY3JpcHRpb246IGBcblRoaXMgdG9vbCBhbGxvd3MgbWludGluZyBhc3NldHMgaW50byBhIE1vb253ZWxsIE1Ub2tlbi4gXG5cbkl0IHRha2VzOlxuLSBtVG9rZW5BZGRyZXNzOiBUaGUgYWRkcmVzcyBvZiB0aGUgTW9vbndlbGwgTVRva2VuIHRvIG1pbnQgdG9cbi0gYXNzZXRzOiBUaGUgYW1vdW50IG9mIGFzc2V0cyB0aGF0IHdpbGwgYmUgYXBwcm92ZWQgdG8gc3BlbmQgYnkgdGhlIG1Ub2tlbiBpbiB3aG9sZSB1bml0c1xuICBFeGFtcGxlcyBmb3IgV0VUSDpcbiAgLSAxIFdFVEhcbiAgLSAwLjEgV0VUSFxuICAtIDAuMDEgV0VUSFxuICBFeGFtcGxlcyBmb3IgY2JFVEg6XG4gIC0gMSBjYkVUSFxuICAtIDAuMSBjYkVUSFxuICAtIDAuMDEgY2JFVEhcbiAgRXhhbXBsZXMgZm9yIFVTREM6XG4gIC0gMSBVU0RDXG4gIC0gMC4xIFVTRENcbiAgLSAwLjAxIFVTRENcbi0gdG9rZW5BZGRyZXNzOiBUaGUgYWRkcmVzcyBvZiB0aGUgdG9rZW4gdG8gYXBwcm92ZVxuXG5JbXBvcnRhbnQgbm90ZXM6XG4tIE1ha2Ugc3VyZSB0byB1c2UgdGhlIGV4YWN0IGFtb3VudCBwcm92aWRlZC4gRG8gbm90IGNvbnZlcnQgdW5pdHMgZm9yIGFzc2V0cyBmb3IgdGhpcyBhY3Rpb24uXG4tIFBsZWFzZSB1c2UgYSB0b2tlbiBhZGRyZXNzIChleGFtcGxlIDB4NDIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwNikgZm9yIHRoZSB0b2tlbkFkZHJlc3MgZmllbGQuXG4tIFRoaXMgdG9vbCBoYW5kbGVzIHRva2VuIGFwcHJvdmFsLiBJZiByZXF1ZXN0ZWQgdG8gbWludCBvbiBNb29ud2VsbCwgZG8gbm90IHVzZSBhbnkgb3RoZXIgYWN0aW9ucyB0byBhcHByb3ZlIHRva2Vucy5cbmAsXG4gICAgICAgIHNjaGVtYTogc2NoZW1hc18xLk1pbnRTY2hlbWEsXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW3dhbGxldF9wcm92aWRlcnNfMS5Fdm1XYWxsZXRQcm92aWRlciwgdm9pZCAwXSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIFByb21pc2UpXG5dLCBNb29ud2VsbEFjdGlvblByb3ZpZGVyLnByb3RvdHlwZSwgXCJtaW50XCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgKDAsIGFjdGlvbkRlY29yYXRvcl8xLkNyZWF0ZUFjdGlvbikoe1xuICAgICAgICBuYW1lOiBcInJlZGVlbVwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogYFxuVGhpcyB0b29sIGFsbG93cyByZWRlZW1pbmcgYXNzZXRzIGZyb20gYSBNb29ud2VsbCBNVG9rZW4uIFxuXG5JdCB0YWtlczpcbi0gbVRva2VuQWRkcmVzczogVGhlIGFkZHJlc3Mgb2YgdGhlIE1vb253ZWxsIE1Ub2tlbiB0byByZWRlZW0gZnJvbVxuLSBhc3NldHM6IFRoZSBhbW91bnQgb2YgYXNzZXRzIHRvIHJlZGVlbSBpbiB3aG9sZSB1bml0c1xuICBFeGFtcGxlcyBmb3IgV0VUSDpcbiAgLSAxIFdFVEhcbiAgLSAwLjEgV0VUSFxuICAtIDAuMDEgV0VUSFxuICBFeGFtcGxlcyBmb3IgY2JFVEg6XG4gIC0gMSBjYkVUSFxuICAtIDAuMSBjYkVUSFxuICAtIDAuMDEgY2JFVEhcbiAgRXhhbXBsZXMgZm9yIFVTREM6XG4gIC0gMSBVU0RDXG4gIC0gMC4xIFVTRENcbiAgLSAwLjAxIFVTRENcblxuSW1wb3J0YW50IG5vdGVzOlxuLSBNYWtlIHN1cmUgdG8gdXNlIHRoZSBleGFjdCBhbW91bnQgcHJvdmlkZWQuIERvIG5vdCBjb252ZXJ0IHVuaXRzIGZvciBhc3NldHMgZm9yIHRoaXMgYWN0aW9uLlxuLSBQbGVhc2UgdXNlIGEgdG9rZW4gYWRkcmVzcyAoZXhhbXBsZSAweDQyMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDYpIGZvciB0aGUgdG9rZW5BZGRyZXNzIGZpZWxkLlxuYCxcbiAgICAgICAgc2NoZW1hOiBzY2hlbWFzXzEuUmVkZWVtU2NoZW1hLFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFt3YWxsZXRfcHJvdmlkZXJzXzEuRXZtV2FsbGV0UHJvdmlkZXIsIHZvaWQgMF0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCBQcm9taXNlKVxuXSwgTW9vbndlbGxBY3Rpb25Qcm92aWRlci5wcm90b3R5cGUsIFwicmVkZWVtXCIsIG51bGwpO1xuY29uc3QgbW9vbndlbGxBY3Rpb25Qcm92aWRlciA9ICgpID0+IG5ldyBNb29ud2VsbEFjdGlvblByb3ZpZGVyKCk7XG5leHBvcnRzLm1vb253ZWxsQWN0aW9uUHJvdmlkZXIgPSBtb29ud2VsbEFjdGlvblByb3ZpZGVyO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/moonwell/moonwellActionProvider.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/moonwell/schemas.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/moonwell/schemas.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RedeemSchema = exports.MintSchema = void 0;\nconst zod_1 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/lib/index.js\");\n/**\n * Input schema for Moonwell MToken mint action.\n */\nexports.MintSchema = zod_1.z\n    .object({\n    assets: zod_1.z\n        .string()\n        .regex(/^\\d+(\\.\\d+)?$/, \"Must be a valid integer or decimal value\")\n        .describe(\"The quantity of assets to use to mint, in whole units\"),\n    tokenAddress: zod_1.z\n        .string()\n        .regex(/^0x[a-fA-F0-9]{40}$/, \"Invalid Ethereum address format\")\n        .describe(\"The address of the assets token to approve for minting\"),\n    mTokenAddress: zod_1.z\n        .string()\n        .regex(/^0x[a-fA-F0-9]{40}$/, \"Invalid Ethereum address format\")\n        .describe(\"The address of the Moonwell MToken to mint from\"),\n})\n    .describe(\"Input schema for Moonwell MToken mint action\");\n/**\n * Input schema for Moonwell MToken redeem action.\n */\nexports.RedeemSchema = zod_1.z\n    .object({\n    mTokenAddress: zod_1.z\n        .string()\n        .regex(/^0x[a-fA-F0-9]{40}$/, \"Invalid Ethereum address format\")\n        .describe(\"The address of the Moonwell MToken to redeem from\"),\n    assets: zod_1.z\n        .string()\n        .regex(/^\\d+(\\.\\d+)?$/, \"Must be a valid integer or decimal value\")\n        .describe(\"The quantity of assets to redeem, in whole units\"),\n})\n    .strip()\n    .describe(\"Input schema for Moonwell MToken redeem action\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9tb29ud2VsbC9zY2hlbWFzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9CQUFvQixHQUFHLGtCQUFrQjtBQUN6QyxjQUFjLG1CQUFPLENBQUMsa0RBQUs7QUFDM0I7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLEdBQUc7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLEdBQUc7QUFDbEM7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLEdBQUc7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3Vydml2YWwtZnVuLy4vbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9hZ2VudGtpdC9kaXN0L2FjdGlvbi1wcm92aWRlcnMvbW9vbndlbGwvc2NoZW1hcy5qcz83Nzg2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5SZWRlZW1TY2hlbWEgPSBleHBvcnRzLk1pbnRTY2hlbWEgPSB2b2lkIDA7XG5jb25zdCB6b2RfMSA9IHJlcXVpcmUoXCJ6b2RcIik7XG4vKipcbiAqIElucHV0IHNjaGVtYSBmb3IgTW9vbndlbGwgTVRva2VuIG1pbnQgYWN0aW9uLlxuICovXG5leHBvcnRzLk1pbnRTY2hlbWEgPSB6b2RfMS56XG4gICAgLm9iamVjdCh7XG4gICAgYXNzZXRzOiB6b2RfMS56XG4gICAgICAgIC5zdHJpbmcoKVxuICAgICAgICAucmVnZXgoL15cXGQrKFxcLlxcZCspPyQvLCBcIk11c3QgYmUgYSB2YWxpZCBpbnRlZ2VyIG9yIGRlY2ltYWwgdmFsdWVcIilcbiAgICAgICAgLmRlc2NyaWJlKFwiVGhlIHF1YW50aXR5IG9mIGFzc2V0cyB0byB1c2UgdG8gbWludCwgaW4gd2hvbGUgdW5pdHNcIiksXG4gICAgdG9rZW5BZGRyZXNzOiB6b2RfMS56XG4gICAgICAgIC5zdHJpbmcoKVxuICAgICAgICAucmVnZXgoL14weFthLWZBLUYwLTldezQwfSQvLCBcIkludmFsaWQgRXRoZXJldW0gYWRkcmVzcyBmb3JtYXRcIilcbiAgICAgICAgLmRlc2NyaWJlKFwiVGhlIGFkZHJlc3Mgb2YgdGhlIGFzc2V0cyB0b2tlbiB0byBhcHByb3ZlIGZvciBtaW50aW5nXCIpLFxuICAgIG1Ub2tlbkFkZHJlc3M6IHpvZF8xLnpcbiAgICAgICAgLnN0cmluZygpXG4gICAgICAgIC5yZWdleCgvXjB4W2EtZkEtRjAtOV17NDB9JC8sIFwiSW52YWxpZCBFdGhlcmV1bSBhZGRyZXNzIGZvcm1hdFwiKVxuICAgICAgICAuZGVzY3JpYmUoXCJUaGUgYWRkcmVzcyBvZiB0aGUgTW9vbndlbGwgTVRva2VuIHRvIG1pbnQgZnJvbVwiKSxcbn0pXG4gICAgLmRlc2NyaWJlKFwiSW5wdXQgc2NoZW1hIGZvciBNb29ud2VsbCBNVG9rZW4gbWludCBhY3Rpb25cIik7XG4vKipcbiAqIElucHV0IHNjaGVtYSBmb3IgTW9vbndlbGwgTVRva2VuIHJlZGVlbSBhY3Rpb24uXG4gKi9cbmV4cG9ydHMuUmVkZWVtU2NoZW1hID0gem9kXzEuelxuICAgIC5vYmplY3Qoe1xuICAgIG1Ub2tlbkFkZHJlc3M6IHpvZF8xLnpcbiAgICAgICAgLnN0cmluZygpXG4gICAgICAgIC5yZWdleCgvXjB4W2EtZkEtRjAtOV17NDB9JC8sIFwiSW52YWxpZCBFdGhlcmV1bSBhZGRyZXNzIGZvcm1hdFwiKVxuICAgICAgICAuZGVzY3JpYmUoXCJUaGUgYWRkcmVzcyBvZiB0aGUgTW9vbndlbGwgTVRva2VuIHRvIHJlZGVlbSBmcm9tXCIpLFxuICAgIGFzc2V0czogem9kXzEuelxuICAgICAgICAuc3RyaW5nKClcbiAgICAgICAgLnJlZ2V4KC9eXFxkKyhcXC5cXGQrKT8kLywgXCJNdXN0IGJlIGEgdmFsaWQgaW50ZWdlciBvciBkZWNpbWFsIHZhbHVlXCIpXG4gICAgICAgIC5kZXNjcmliZShcIlRoZSBxdWFudGl0eSBvZiBhc3NldHMgdG8gcmVkZWVtLCBpbiB3aG9sZSB1bml0c1wiKSxcbn0pXG4gICAgLnN0cmlwKClcbiAgICAuZGVzY3JpYmUoXCJJbnB1dCBzY2hlbWEgZm9yIE1vb253ZWxsIE1Ub2tlbiByZWRlZW0gYWN0aW9uXCIpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/moonwell/schemas.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/morpho/constants.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/morpho/constants.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.METAMORPHO_ABI = exports.MORPHO_BASE_ADDRESS = void 0;\nexports.MORPHO_BASE_ADDRESS = \"0xBBBBBbbBBb9cC5e90e3b3Af64bdAF62C37EEFFCb\";\nexports.METAMORPHO_ABI = [\n    {\n        inputs: [\n            { internalType: \"uint256\", name: \"assets\", type: \"uint256\" },\n            { internalType: \"address\", name: \"receiver\", type: \"address\" },\n        ],\n        name: \"deposit\",\n        outputs: [{ internalType: \"uint256\", name: \"shares\", type: \"uint256\" }],\n        stateMutability: \"nonpayable\",\n        type: \"function\",\n    },\n    {\n        inputs: [\n            { internalType: \"uint256\", name: \"assets\", type: \"uint256\" },\n            { internalType: \"address\", name: \"receiver\", type: \"address\" },\n            { internalType: \"address\", name: \"owner\", type: \"address\" },\n        ],\n        name: \"withdraw\",\n        outputs: [{ internalType: \"uint256\", name: \"shares\", type: \"uint256\" }],\n        stateMutability: \"nonpayable\",\n        type: \"function\",\n    },\n];\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9tb3JwaG8vY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHNCQUFzQixHQUFHLDJCQUEyQjtBQUNwRCwyQkFBMkI7QUFDM0Isc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxjQUFjLDBEQUEwRDtBQUN4RSxjQUFjLDREQUE0RDtBQUMxRTtBQUNBO0FBQ0Esb0JBQW9CLDBEQUEwRDtBQUM5RTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxjQUFjLDBEQUEwRDtBQUN4RSxjQUFjLDREQUE0RDtBQUMxRSxjQUFjLHlEQUF5RDtBQUN2RTtBQUNBO0FBQ0Esb0JBQW9CLDBEQUEwRDtBQUM5RTtBQUNBO0FBQ0EsS0FBSztBQUNMIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3Vydml2YWwtZnVuLy4vbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9hZ2VudGtpdC9kaXN0L2FjdGlvbi1wcm92aWRlcnMvbW9ycGhvL2NvbnN0YW50cy5qcz83MWE1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NRVRBTU9SUEhPX0FCSSA9IGV4cG9ydHMuTU9SUEhPX0JBU0VfQUREUkVTUyA9IHZvaWQgMDtcbmV4cG9ydHMuTU9SUEhPX0JBU0VfQUREUkVTUyA9IFwiMHhCQkJCQmJiQkJiOWNDNWU5MGUzYjNBZjY0YmRBRjYyQzM3RUVGRkNiXCI7XG5leHBvcnRzLk1FVEFNT1JQSE9fQUJJID0gW1xuICAgIHtcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7IGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsIG5hbWU6IFwiYXNzZXRzXCIsIHR5cGU6IFwidWludDI1NlwiIH0sXG4gICAgICAgICAgICB7IGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsIG5hbWU6IFwicmVjZWl2ZXJcIiwgdHlwZTogXCJhZGRyZXNzXCIgfSxcbiAgICAgICAgXSxcbiAgICAgICAgbmFtZTogXCJkZXBvc2l0XCIsXG4gICAgICAgIG91dHB1dHM6IFt7IGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsIG5hbWU6IFwic2hhcmVzXCIsIHR5cGU6IFwidWludDI1NlwiIH1dLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6IFwibm9ucGF5YWJsZVwiLFxuICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAgeyBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLCBuYW1lOiBcImFzc2V0c1wiLCB0eXBlOiBcInVpbnQyNTZcIiB9LFxuICAgICAgICAgICAgeyBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLCBuYW1lOiBcInJlY2VpdmVyXCIsIHR5cGU6IFwiYWRkcmVzc1wiIH0sXG4gICAgICAgICAgICB7IGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsIG5hbWU6IFwib3duZXJcIiwgdHlwZTogXCJhZGRyZXNzXCIgfSxcbiAgICAgICAgXSxcbiAgICAgICAgbmFtZTogXCJ3aXRoZHJhd1wiLFxuICAgICAgICBvdXRwdXRzOiBbeyBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLCBuYW1lOiBcInNoYXJlc1wiLCB0eXBlOiBcInVpbnQyNTZcIiB9XSxcbiAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiBcIm5vbnBheWFibGVcIixcbiAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgIH0sXG5dO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/morpho/constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/morpho/index.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/morpho/index.js ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./schemas */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/morpho/schemas.js\"), exports);\n__exportStar(__webpack_require__(/*! ./morphoActionProvider */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/morpho/morphoActionProvider.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9tb3JwaG8vaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYSxtQkFBTyxDQUFDLGtHQUFXO0FBQ2hDLGFBQWEsbUJBQU8sQ0FBQyw0SEFBd0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXJ2aXZhbC1mdW4vLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9tb3JwaG8vaW5kZXguanM/ZjNhYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3NjaGVtYXNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL21vcnBob0FjdGlvblByb3ZpZGVyXCIpLCBleHBvcnRzKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/morpho/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/morpho/morphoActionProvider.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/morpho/morphoActionProvider.js ***!
  \**********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.morphoActionProvider = exports.MorphoActionProvider = exports.SUPPORTED_NETWORKS = void 0;\nconst zod_1 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/lib/index.js\");\nconst decimal_js_1 = __webpack_require__(/*! decimal.js */ \"(rsc)/./node_modules/decimal.js/decimal.js\");\nconst viem_1 = __webpack_require__(/*! viem */ \"(rsc)/./node_modules/viem/_cjs/index.js\");\nconst constants_1 = __webpack_require__(/*! ../erc20/constants */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/erc20/constants.js\");\nconst actionProvider_1 = __webpack_require__(/*! ../actionProvider */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/actionProvider.js\");\nconst wallet_providers_1 = __webpack_require__(/*! ../../wallet-providers */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/wallet-providers/index.js\");\nconst actionDecorator_1 = __webpack_require__(/*! ../actionDecorator */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/actionDecorator.js\");\nconst utils_1 = __webpack_require__(/*! ../../utils */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/utils.js\");\nconst constants_2 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/morpho/constants.js\");\nconst schemas_1 = __webpack_require__(/*! ./schemas */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/morpho/schemas.js\");\nexports.SUPPORTED_NETWORKS = [\"base-mainnet\", \"base-sepolia\"];\n/**\n * MorphoActionProvider is an action provider for Morpho Vault interactions.\n */\nclass MorphoActionProvider extends actionProvider_1.ActionProvider {\n    /**\n     * Constructor for the MorphoActionProvider class.\n     */\n    constructor() {\n        super(\"morpho\", []);\n        /**\n         * Checks if the Morpho action provider supports the given network.\n         *\n         * @param network - The network to check.\n         * @returns True if the Morpho action provider supports the network, false otherwise.\n         */\n        this.supportsNetwork = (network) => network.protocolFamily === \"evm\" && exports.SUPPORTED_NETWORKS.includes(network.networkId);\n    }\n    /**\n     * Deposits assets into a Morpho Vault\n     *\n     * @param wallet - The wallet instance to execute the transaction\n     * @param args - The input arguments for the action\n     * @returns A success message with transaction details or an error message\n     */\n    async deposit(wallet, args) {\n        const assets = new decimal_js_1.Decimal(args.assets);\n        if (assets.comparedTo(new decimal_js_1.Decimal(0.0)) != 1) {\n            return \"Error: Assets amount must be greater than 0\";\n        }\n        try {\n            const decimals = await wallet.readContract({\n                address: args.tokenAddress,\n                abi: constants_1.abi,\n                functionName: \"decimals\",\n                args: [],\n            });\n            const atomicAssets = (0, viem_1.parseUnits)(args.assets, decimals);\n            const approvalResult = await (0, utils_1.approve)(wallet, args.tokenAddress, args.vaultAddress, atomicAssets);\n            if (approvalResult.startsWith(\"Error\")) {\n                return `Error approving Morpho Vault as spender: ${approvalResult}`;\n            }\n            const data = (0, viem_1.encodeFunctionData)({\n                abi: constants_2.METAMORPHO_ABI,\n                functionName: \"deposit\",\n                args: [atomicAssets, args.receiver],\n            });\n            const txHash = await wallet.sendTransaction({\n                to: args.vaultAddress,\n                data,\n            });\n            const receipt = await wallet.waitForTransactionReceipt(txHash);\n            return `Deposited ${args.assets} to Morpho Vault ${args.vaultAddress} with transaction hash: ${txHash}\\nTransaction receipt: ${JSON.stringify(receipt)}`;\n        }\n        catch (error) {\n            return `Error depositing to Morpho Vault: ${error}`;\n        }\n    }\n    /**\n     * Withdraws assets from a Morpho Vault\n     *\n     * @param wallet - The wallet instance to execute the transaction\n     * @param args - The input arguments for the action\n     * @returns A success message with transaction details or an error message\n     */\n    async withdraw(wallet, args) {\n        if (BigInt(args.assets) <= 0) {\n            return \"Error: Assets amount must be greater than 0\";\n        }\n        try {\n            const data = (0, viem_1.encodeFunctionData)({\n                abi: constants_2.METAMORPHO_ABI,\n                functionName: \"withdraw\",\n                args: [BigInt(args.assets), args.receiver, args.receiver],\n            });\n            const txHash = await wallet.sendTransaction({\n                to: args.vaultAddress,\n                data,\n            });\n            const receipt = await wallet.waitForTransactionReceipt(txHash);\n            return `Withdrawn ${args.assets} from Morpho Vault ${args.vaultAddress} with transaction hash: ${txHash}\\nTransaction receipt: ${JSON.stringify(receipt)}`;\n        }\n        catch (error) {\n            return `Error withdrawing from Morpho Vault: ${error}`;\n        }\n    }\n}\nexports.MorphoActionProvider = MorphoActionProvider;\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"deposit\",\n        description: `\nThis tool allows depositing assets into a Morpho Vault. \n\nIt takes:\n- vaultAddress: The address of the Morpho Vault to deposit to\n- assets: The amount of assets to deposit in whole units\n  Examples for WETH:\n  - 1 WETH\n  - 0.1 WETH\n  - 0.01 WETH\n- receiver: The address to receive the shares\n- tokenAddress: The address of the token to approve\n\nImportant notes:\n- Make sure to use the exact amount provided. Do not convert units for assets for this action.\n- Please use a token address (example 0x4200000000000000000000000000000000000006) for the tokenAddress field.\n`,\n        schema: schemas_1.DepositSchema,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [wallet_providers_1.EvmWalletProvider, void 0]),\n    __metadata(\"design:returntype\", Promise)\n], MorphoActionProvider.prototype, \"deposit\", null);\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"withdraw\",\n        description: `\nThis tool allows withdrawing assets from a Morpho Vault. It takes:\n\n- vaultAddress: The address of the Morpho Vault to withdraw from\n- assets: The amount of assets to withdraw in atomic units (wei)\n- receiver: The address to receive the shares\n`,\n        schema: schemas_1.WithdrawSchema,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [wallet_providers_1.EvmWalletProvider, void 0]),\n    __metadata(\"design:returntype\", Promise)\n], MorphoActionProvider.prototype, \"withdraw\", null);\nconst morphoActionProvider = () => new MorphoActionProvider();\nexports.morphoActionProvider = morphoActionProvider;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9tb3JwaG8vbW9ycGhvQWN0aW9uUHJvdmlkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsUUFBUTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDRCQUE0QixHQUFHLDRCQUE0QixHQUFHLDBCQUEwQjtBQUN4RixjQUFjLG1CQUFPLENBQUMsa0RBQUs7QUFDM0IscUJBQXFCLG1CQUFPLENBQUMsOERBQVk7QUFDekMsZUFBZSxtQkFBTyxDQUFDLHFEQUFNO0FBQzdCLG9CQUFvQixtQkFBTyxDQUFDLDRHQUFvQjtBQUNoRCx5QkFBeUIsbUJBQU8sQ0FBQywwR0FBbUI7QUFDcEQsMkJBQTJCLG1CQUFPLENBQUMsc0dBQXdCO0FBQzNELDBCQUEwQixtQkFBTyxDQUFDLDRHQUFvQjtBQUN0RCxnQkFBZ0IsbUJBQU8sQ0FBQywwRUFBYTtBQUNyQyxvQkFBb0IsbUJBQU8sQ0FBQyxzR0FBYTtBQUN6QyxrQkFBa0IsbUJBQU8sQ0FBQyxrR0FBVztBQUNyQywwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsZUFBZTtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGdDQUFnQyxhQUFhLGtCQUFrQixtQkFBbUIseUJBQXlCLE9BQU8seUJBQXlCLHdCQUF3QjtBQUNuSztBQUNBO0FBQ0Esd0RBQXdELE1BQU07QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGdDQUFnQyxhQUFhLG9CQUFvQixtQkFBbUIseUJBQXlCLE9BQU8seUJBQXlCLHdCQUF3QjtBQUNySztBQUNBO0FBQ0EsMkRBQTJELE1BQU07QUFDakU7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cnZpdmFsLWZ1bi8uL25vZGVfbW9kdWxlcy9AY29pbmJhc2UvYWdlbnRraXQvZGlzdC9hY3Rpb24tcHJvdmlkZXJzL21vcnBoby9tb3JwaG9BY3Rpb25Qcm92aWRlci5qcz80NzZjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubW9ycGhvQWN0aW9uUHJvdmlkZXIgPSBleHBvcnRzLk1vcnBob0FjdGlvblByb3ZpZGVyID0gZXhwb3J0cy5TVVBQT1JURURfTkVUV09SS1MgPSB2b2lkIDA7XG5jb25zdCB6b2RfMSA9IHJlcXVpcmUoXCJ6b2RcIik7XG5jb25zdCBkZWNpbWFsX2pzXzEgPSByZXF1aXJlKFwiZGVjaW1hbC5qc1wiKTtcbmNvbnN0IHZpZW1fMSA9IHJlcXVpcmUoXCJ2aWVtXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi4vZXJjMjAvY29uc3RhbnRzXCIpO1xuY29uc3QgYWN0aW9uUHJvdmlkZXJfMSA9IHJlcXVpcmUoXCIuLi9hY3Rpb25Qcm92aWRlclwiKTtcbmNvbnN0IHdhbGxldF9wcm92aWRlcnNfMSA9IHJlcXVpcmUoXCIuLi8uLi93YWxsZXQtcHJvdmlkZXJzXCIpO1xuY29uc3QgYWN0aW9uRGVjb3JhdG9yXzEgPSByZXF1aXJlKFwiLi4vYWN0aW9uRGVjb3JhdG9yXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsc1wiKTtcbmNvbnN0IGNvbnN0YW50c18yID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3Qgc2NoZW1hc18xID0gcmVxdWlyZShcIi4vc2NoZW1hc1wiKTtcbmV4cG9ydHMuU1VQUE9SVEVEX05FVFdPUktTID0gW1wiYmFzZS1tYWlubmV0XCIsIFwiYmFzZS1zZXBvbGlhXCJdO1xuLyoqXG4gKiBNb3JwaG9BY3Rpb25Qcm92aWRlciBpcyBhbiBhY3Rpb24gcHJvdmlkZXIgZm9yIE1vcnBobyBWYXVsdCBpbnRlcmFjdGlvbnMuXG4gKi9cbmNsYXNzIE1vcnBob0FjdGlvblByb3ZpZGVyIGV4dGVuZHMgYWN0aW9uUHJvdmlkZXJfMS5BY3Rpb25Qcm92aWRlciB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIHRoZSBNb3JwaG9BY3Rpb25Qcm92aWRlciBjbGFzcy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoXCJtb3JwaG9cIiwgW10pO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2tzIGlmIHRoZSBNb3JwaG8gYWN0aW9uIHByb3ZpZGVyIHN1cHBvcnRzIHRoZSBnaXZlbiBuZXR3b3JrLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gbmV0d29yayAtIFRoZSBuZXR3b3JrIHRvIGNoZWNrLlxuICAgICAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBNb3JwaG8gYWN0aW9uIHByb3ZpZGVyIHN1cHBvcnRzIHRoZSBuZXR3b3JrLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN1cHBvcnRzTmV0d29yayA9IChuZXR3b3JrKSA9PiBuZXR3b3JrLnByb3RvY29sRmFtaWx5ID09PSBcImV2bVwiICYmIGV4cG9ydHMuU1VQUE9SVEVEX05FVFdPUktTLmluY2x1ZGVzKG5ldHdvcmsubmV0d29ya0lkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVwb3NpdHMgYXNzZXRzIGludG8gYSBNb3JwaG8gVmF1bHRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB3YWxsZXQgLSBUaGUgd2FsbGV0IGluc3RhbmNlIHRvIGV4ZWN1dGUgdGhlIHRyYW5zYWN0aW9uXG4gICAgICogQHBhcmFtIGFyZ3MgLSBUaGUgaW5wdXQgYXJndW1lbnRzIGZvciB0aGUgYWN0aW9uXG4gICAgICogQHJldHVybnMgQSBzdWNjZXNzIG1lc3NhZ2Ugd2l0aCB0cmFuc2FjdGlvbiBkZXRhaWxzIG9yIGFuIGVycm9yIG1lc3NhZ2VcbiAgICAgKi9cbiAgICBhc3luYyBkZXBvc2l0KHdhbGxldCwgYXJncykge1xuICAgICAgICBjb25zdCBhc3NldHMgPSBuZXcgZGVjaW1hbF9qc18xLkRlY2ltYWwoYXJncy5hc3NldHMpO1xuICAgICAgICBpZiAoYXNzZXRzLmNvbXBhcmVkVG8obmV3IGRlY2ltYWxfanNfMS5EZWNpbWFsKDAuMCkpICE9IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBcIkVycm9yOiBBc3NldHMgYW1vdW50IG11c3QgYmUgZ3JlYXRlciB0aGFuIDBcIjtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZGVjaW1hbHMgPSBhd2FpdCB3YWxsZXQucmVhZENvbnRyYWN0KHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzOiBhcmdzLnRva2VuQWRkcmVzcyxcbiAgICAgICAgICAgICAgICBhYmk6IGNvbnN0YW50c18xLmFiaSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWU6IFwiZGVjaW1hbHNcIixcbiAgICAgICAgICAgICAgICBhcmdzOiBbXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgYXRvbWljQXNzZXRzID0gKDAsIHZpZW1fMS5wYXJzZVVuaXRzKShhcmdzLmFzc2V0cywgZGVjaW1hbHMpO1xuICAgICAgICAgICAgY29uc3QgYXBwcm92YWxSZXN1bHQgPSBhd2FpdCAoMCwgdXRpbHNfMS5hcHByb3ZlKSh3YWxsZXQsIGFyZ3MudG9rZW5BZGRyZXNzLCBhcmdzLnZhdWx0QWRkcmVzcywgYXRvbWljQXNzZXRzKTtcbiAgICAgICAgICAgIGlmIChhcHByb3ZhbFJlc3VsdC5zdGFydHNXaXRoKFwiRXJyb3JcIikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYEVycm9yIGFwcHJvdmluZyBNb3JwaG8gVmF1bHQgYXMgc3BlbmRlcjogJHthcHByb3ZhbFJlc3VsdH1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGF0YSA9ICgwLCB2aWVtXzEuZW5jb2RlRnVuY3Rpb25EYXRhKSh7XG4gICAgICAgICAgICAgICAgYWJpOiBjb25zdGFudHNfMi5NRVRBTU9SUEhPX0FCSSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWU6IFwiZGVwb3NpdFwiLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFthdG9taWNBc3NldHMsIGFyZ3MucmVjZWl2ZXJdLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCB0eEhhc2ggPSBhd2FpdCB3YWxsZXQuc2VuZFRyYW5zYWN0aW9uKHtcbiAgICAgICAgICAgICAgICB0bzogYXJncy52YXVsdEFkZHJlc3MsXG4gICAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcmVjZWlwdCA9IGF3YWl0IHdhbGxldC53YWl0Rm9yVHJhbnNhY3Rpb25SZWNlaXB0KHR4SGFzaCk7XG4gICAgICAgICAgICByZXR1cm4gYERlcG9zaXRlZCAke2FyZ3MuYXNzZXRzfSB0byBNb3JwaG8gVmF1bHQgJHthcmdzLnZhdWx0QWRkcmVzc30gd2l0aCB0cmFuc2FjdGlvbiBoYXNoOiAke3R4SGFzaH1cXG5UcmFuc2FjdGlvbiByZWNlaXB0OiAke0pTT04uc3RyaW5naWZ5KHJlY2VpcHQpfWA7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gYEVycm9yIGRlcG9zaXRpbmcgdG8gTW9ycGhvIFZhdWx0OiAke2Vycm9yfWA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogV2l0aGRyYXdzIGFzc2V0cyBmcm9tIGEgTW9ycGhvIFZhdWx0XG4gICAgICpcbiAgICAgKiBAcGFyYW0gd2FsbGV0IC0gVGhlIHdhbGxldCBpbnN0YW5jZSB0byBleGVjdXRlIHRoZSB0cmFuc2FjdGlvblxuICAgICAqIEBwYXJhbSBhcmdzIC0gVGhlIGlucHV0IGFyZ3VtZW50cyBmb3IgdGhlIGFjdGlvblxuICAgICAqIEByZXR1cm5zIEEgc3VjY2VzcyBtZXNzYWdlIHdpdGggdHJhbnNhY3Rpb24gZGV0YWlscyBvciBhbiBlcnJvciBtZXNzYWdlXG4gICAgICovXG4gICAgYXN5bmMgd2l0aGRyYXcod2FsbGV0LCBhcmdzKSB7XG4gICAgICAgIGlmIChCaWdJbnQoYXJncy5hc3NldHMpIDw9IDApIHtcbiAgICAgICAgICAgIHJldHVybiBcIkVycm9yOiBBc3NldHMgYW1vdW50IG11c3QgYmUgZ3JlYXRlciB0aGFuIDBcIjtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9ICgwLCB2aWVtXzEuZW5jb2RlRnVuY3Rpb25EYXRhKSh7XG4gICAgICAgICAgICAgICAgYWJpOiBjb25zdGFudHNfMi5NRVRBTU9SUEhPX0FCSSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWU6IFwid2l0aGRyYXdcIixcbiAgICAgICAgICAgICAgICBhcmdzOiBbQmlnSW50KGFyZ3MuYXNzZXRzKSwgYXJncy5yZWNlaXZlciwgYXJncy5yZWNlaXZlcl0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHR4SGFzaCA9IGF3YWl0IHdhbGxldC5zZW5kVHJhbnNhY3Rpb24oe1xuICAgICAgICAgICAgICAgIHRvOiBhcmdzLnZhdWx0QWRkcmVzcyxcbiAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCByZWNlaXB0ID0gYXdhaXQgd2FsbGV0LndhaXRGb3JUcmFuc2FjdGlvblJlY2VpcHQodHhIYXNoKTtcbiAgICAgICAgICAgIHJldHVybiBgV2l0aGRyYXduICR7YXJncy5hc3NldHN9IGZyb20gTW9ycGhvIFZhdWx0ICR7YXJncy52YXVsdEFkZHJlc3N9IHdpdGggdHJhbnNhY3Rpb24gaGFzaDogJHt0eEhhc2h9XFxuVHJhbnNhY3Rpb24gcmVjZWlwdDogJHtKU09OLnN0cmluZ2lmeShyZWNlaXB0KX1gO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGBFcnJvciB3aXRoZHJhd2luZyBmcm9tIE1vcnBobyBWYXVsdDogJHtlcnJvcn1gO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5Nb3JwaG9BY3Rpb25Qcm92aWRlciA9IE1vcnBob0FjdGlvblByb3ZpZGVyO1xuX19kZWNvcmF0ZShbXG4gICAgKDAsIGFjdGlvbkRlY29yYXRvcl8xLkNyZWF0ZUFjdGlvbikoe1xuICAgICAgICBuYW1lOiBcImRlcG9zaXRcIixcbiAgICAgICAgZGVzY3JpcHRpb246IGBcblRoaXMgdG9vbCBhbGxvd3MgZGVwb3NpdGluZyBhc3NldHMgaW50byBhIE1vcnBobyBWYXVsdC4gXG5cbkl0IHRha2VzOlxuLSB2YXVsdEFkZHJlc3M6IFRoZSBhZGRyZXNzIG9mIHRoZSBNb3JwaG8gVmF1bHQgdG8gZGVwb3NpdCB0b1xuLSBhc3NldHM6IFRoZSBhbW91bnQgb2YgYXNzZXRzIHRvIGRlcG9zaXQgaW4gd2hvbGUgdW5pdHNcbiAgRXhhbXBsZXMgZm9yIFdFVEg6XG4gIC0gMSBXRVRIXG4gIC0gMC4xIFdFVEhcbiAgLSAwLjAxIFdFVEhcbi0gcmVjZWl2ZXI6IFRoZSBhZGRyZXNzIHRvIHJlY2VpdmUgdGhlIHNoYXJlc1xuLSB0b2tlbkFkZHJlc3M6IFRoZSBhZGRyZXNzIG9mIHRoZSB0b2tlbiB0byBhcHByb3ZlXG5cbkltcG9ydGFudCBub3Rlczpcbi0gTWFrZSBzdXJlIHRvIHVzZSB0aGUgZXhhY3QgYW1vdW50IHByb3ZpZGVkLiBEbyBub3QgY29udmVydCB1bml0cyBmb3IgYXNzZXRzIGZvciB0aGlzIGFjdGlvbi5cbi0gUGxlYXNlIHVzZSBhIHRva2VuIGFkZHJlc3MgKGV4YW1wbGUgMHg0MjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA2KSBmb3IgdGhlIHRva2VuQWRkcmVzcyBmaWVsZC5cbmAsXG4gICAgICAgIHNjaGVtYTogc2NoZW1hc18xLkRlcG9zaXRTY2hlbWEsXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW3dhbGxldF9wcm92aWRlcnNfMS5Fdm1XYWxsZXRQcm92aWRlciwgdm9pZCAwXSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIFByb21pc2UpXG5dLCBNb3JwaG9BY3Rpb25Qcm92aWRlci5wcm90b3R5cGUsIFwiZGVwb3NpdFwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgICgwLCBhY3Rpb25EZWNvcmF0b3JfMS5DcmVhdGVBY3Rpb24pKHtcbiAgICAgICAgbmFtZTogXCJ3aXRoZHJhd1wiLFxuICAgICAgICBkZXNjcmlwdGlvbjogYFxuVGhpcyB0b29sIGFsbG93cyB3aXRoZHJhd2luZyBhc3NldHMgZnJvbSBhIE1vcnBobyBWYXVsdC4gSXQgdGFrZXM6XG5cbi0gdmF1bHRBZGRyZXNzOiBUaGUgYWRkcmVzcyBvZiB0aGUgTW9ycGhvIFZhdWx0IHRvIHdpdGhkcmF3IGZyb21cbi0gYXNzZXRzOiBUaGUgYW1vdW50IG9mIGFzc2V0cyB0byB3aXRoZHJhdyBpbiBhdG9taWMgdW5pdHMgKHdlaSlcbi0gcmVjZWl2ZXI6IFRoZSBhZGRyZXNzIHRvIHJlY2VpdmUgdGhlIHNoYXJlc1xuYCxcbiAgICAgICAgc2NoZW1hOiBzY2hlbWFzXzEuV2l0aGRyYXdTY2hlbWEsXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW3dhbGxldF9wcm92aWRlcnNfMS5Fdm1XYWxsZXRQcm92aWRlciwgdm9pZCAwXSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIFByb21pc2UpXG5dLCBNb3JwaG9BY3Rpb25Qcm92aWRlci5wcm90b3R5cGUsIFwid2l0aGRyYXdcIiwgbnVsbCk7XG5jb25zdCBtb3JwaG9BY3Rpb25Qcm92aWRlciA9ICgpID0+IG5ldyBNb3JwaG9BY3Rpb25Qcm92aWRlcigpO1xuZXhwb3J0cy5tb3JwaG9BY3Rpb25Qcm92aWRlciA9IG1vcnBob0FjdGlvblByb3ZpZGVyO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/morpho/morphoActionProvider.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/morpho/schemas.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/morpho/schemas.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.WithdrawSchema = exports.DepositSchema = void 0;\nconst zod_1 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/lib/index.js\");\n/**\n * Input schema for Morpho Vault deposit action.\n */\nexports.DepositSchema = zod_1.z\n    .object({\n    assets: zod_1.z\n        .string()\n        .regex(/^\\d+(\\.\\d+)?$/, \"Must be a valid integer or decimal value\")\n        .describe(\"The quantity of assets to deposit, in whole units\"),\n    receiver: zod_1.z\n        .string()\n        .regex(/^0x[a-fA-F0-9]{40}$/, \"Invalid Ethereum address format\")\n        .describe(\"The address that will own the position on the vault which will receive the shares\"),\n    tokenAddress: zod_1.z\n        .string()\n        .regex(/^0x[a-fA-F0-9]{40}$/, \"Invalid Ethereum address format\")\n        .describe(\"The address of the assets token to approve for deposit\"),\n    vaultAddress: zod_1.z\n        .string()\n        .regex(/^0x[a-fA-F0-9]{40}$/, \"Invalid Ethereum address format\")\n        .describe(\"The address of the Morpho Vault to deposit to\"),\n})\n    .describe(\"Input schema for Morpho Vault deposit action\");\n/**\n * Input schema for Morpho Vault withdraw action.\n */\nexports.WithdrawSchema = zod_1.z\n    .object({\n    vaultAddress: zod_1.z\n        .string()\n        .regex(/^0x[a-fA-F0-9]{40}$/, \"Invalid Ethereum address format\")\n        .describe(\"The address of the Morpho Vault to withdraw from\"),\n    assets: zod_1.z\n        .string()\n        .regex(/^\\d+$/, \"Must be a valid whole number\")\n        .describe(\"The amount of assets to withdraw in atomic units e.g. 1\"),\n    receiver: zod_1.z\n        .string()\n        .regex(/^0x[a-fA-F0-9]{40}$/, \"Invalid Ethereum address format\")\n        .describe(\"The address to receive the shares\"),\n})\n    .strip()\n    .describe(\"Input schema for Morpho Vault withdraw action\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9tb3JwaG8vc2NoZW1hcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQkFBc0IsR0FBRyxxQkFBcUI7QUFDOUMsY0FBYyxtQkFBTyxDQUFDLGtEQUFLO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixHQUFHO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixHQUFHO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixHQUFHO0FBQ2xDO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixHQUFHO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLEdBQUc7QUFDbEM7QUFDQSxDQUFDO0FBQ0Q7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cnZpdmFsLWZ1bi8uL25vZGVfbW9kdWxlcy9AY29pbmJhc2UvYWdlbnRraXQvZGlzdC9hY3Rpb24tcHJvdmlkZXJzL21vcnBoby9zY2hlbWFzLmpzP2EzZTYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLldpdGhkcmF3U2NoZW1hID0gZXhwb3J0cy5EZXBvc2l0U2NoZW1hID0gdm9pZCAwO1xuY29uc3Qgem9kXzEgPSByZXF1aXJlKFwiem9kXCIpO1xuLyoqXG4gKiBJbnB1dCBzY2hlbWEgZm9yIE1vcnBobyBWYXVsdCBkZXBvc2l0IGFjdGlvbi5cbiAqL1xuZXhwb3J0cy5EZXBvc2l0U2NoZW1hID0gem9kXzEuelxuICAgIC5vYmplY3Qoe1xuICAgIGFzc2V0czogem9kXzEuelxuICAgICAgICAuc3RyaW5nKClcbiAgICAgICAgLnJlZ2V4KC9eXFxkKyhcXC5cXGQrKT8kLywgXCJNdXN0IGJlIGEgdmFsaWQgaW50ZWdlciBvciBkZWNpbWFsIHZhbHVlXCIpXG4gICAgICAgIC5kZXNjcmliZShcIlRoZSBxdWFudGl0eSBvZiBhc3NldHMgdG8gZGVwb3NpdCwgaW4gd2hvbGUgdW5pdHNcIiksXG4gICAgcmVjZWl2ZXI6IHpvZF8xLnpcbiAgICAgICAgLnN0cmluZygpXG4gICAgICAgIC5yZWdleCgvXjB4W2EtZkEtRjAtOV17NDB9JC8sIFwiSW52YWxpZCBFdGhlcmV1bSBhZGRyZXNzIGZvcm1hdFwiKVxuICAgICAgICAuZGVzY3JpYmUoXCJUaGUgYWRkcmVzcyB0aGF0IHdpbGwgb3duIHRoZSBwb3NpdGlvbiBvbiB0aGUgdmF1bHQgd2hpY2ggd2lsbCByZWNlaXZlIHRoZSBzaGFyZXNcIiksXG4gICAgdG9rZW5BZGRyZXNzOiB6b2RfMS56XG4gICAgICAgIC5zdHJpbmcoKVxuICAgICAgICAucmVnZXgoL14weFthLWZBLUYwLTldezQwfSQvLCBcIkludmFsaWQgRXRoZXJldW0gYWRkcmVzcyBmb3JtYXRcIilcbiAgICAgICAgLmRlc2NyaWJlKFwiVGhlIGFkZHJlc3Mgb2YgdGhlIGFzc2V0cyB0b2tlbiB0byBhcHByb3ZlIGZvciBkZXBvc2l0XCIpLFxuICAgIHZhdWx0QWRkcmVzczogem9kXzEuelxuICAgICAgICAuc3RyaW5nKClcbiAgICAgICAgLnJlZ2V4KC9eMHhbYS1mQS1GMC05XXs0MH0kLywgXCJJbnZhbGlkIEV0aGVyZXVtIGFkZHJlc3MgZm9ybWF0XCIpXG4gICAgICAgIC5kZXNjcmliZShcIlRoZSBhZGRyZXNzIG9mIHRoZSBNb3JwaG8gVmF1bHQgdG8gZGVwb3NpdCB0b1wiKSxcbn0pXG4gICAgLmRlc2NyaWJlKFwiSW5wdXQgc2NoZW1hIGZvciBNb3JwaG8gVmF1bHQgZGVwb3NpdCBhY3Rpb25cIik7XG4vKipcbiAqIElucHV0IHNjaGVtYSBmb3IgTW9ycGhvIFZhdWx0IHdpdGhkcmF3IGFjdGlvbi5cbiAqL1xuZXhwb3J0cy5XaXRoZHJhd1NjaGVtYSA9IHpvZF8xLnpcbiAgICAub2JqZWN0KHtcbiAgICB2YXVsdEFkZHJlc3M6IHpvZF8xLnpcbiAgICAgICAgLnN0cmluZygpXG4gICAgICAgIC5yZWdleCgvXjB4W2EtZkEtRjAtOV17NDB9JC8sIFwiSW52YWxpZCBFdGhlcmV1bSBhZGRyZXNzIGZvcm1hdFwiKVxuICAgICAgICAuZGVzY3JpYmUoXCJUaGUgYWRkcmVzcyBvZiB0aGUgTW9ycGhvIFZhdWx0IHRvIHdpdGhkcmF3IGZyb21cIiksXG4gICAgYXNzZXRzOiB6b2RfMS56XG4gICAgICAgIC5zdHJpbmcoKVxuICAgICAgICAucmVnZXgoL15cXGQrJC8sIFwiTXVzdCBiZSBhIHZhbGlkIHdob2xlIG51bWJlclwiKVxuICAgICAgICAuZGVzY3JpYmUoXCJUaGUgYW1vdW50IG9mIGFzc2V0cyB0byB3aXRoZHJhdyBpbiBhdG9taWMgdW5pdHMgZS5nLiAxXCIpLFxuICAgIHJlY2VpdmVyOiB6b2RfMS56XG4gICAgICAgIC5zdHJpbmcoKVxuICAgICAgICAucmVnZXgoL14weFthLWZBLUYwLTldezQwfSQvLCBcIkludmFsaWQgRXRoZXJldW0gYWRkcmVzcyBmb3JtYXRcIilcbiAgICAgICAgLmRlc2NyaWJlKFwiVGhlIGFkZHJlc3MgdG8gcmVjZWl2ZSB0aGUgc2hhcmVzXCIpLFxufSlcbiAgICAuc3RyaXAoKVxuICAgIC5kZXNjcmliZShcIklucHV0IHNjaGVtYSBmb3IgTW9ycGhvIFZhdWx0IHdpdGhkcmF3IGFjdGlvblwiKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/morpho/schemas.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/onramp/index.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/onramp/index.js ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Exports for onramp action provider\n *\n * @module onramp\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./onrampActionProvider */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/onramp/onrampActionProvider.js\"), exports);\n__exportStar(__webpack_require__(/*! ./schemas */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/onramp/schemas.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9vbnJhbXAvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWEsbUJBQU8sQ0FBQyw0SEFBd0I7QUFDN0MsYUFBYSxtQkFBTyxDQUFDLGtHQUFXIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3Vydml2YWwtZnVuLy4vbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9hZ2VudGtpdC9kaXN0L2FjdGlvbi1wcm92aWRlcnMvb25yYW1wL2luZGV4LmpzPzI4ODkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEV4cG9ydHMgZm9yIG9ucmFtcCBhY3Rpb24gcHJvdmlkZXJcbiAqXG4gKiBAbW9kdWxlIG9ucmFtcFxuICovXG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9vbnJhbXBBY3Rpb25Qcm92aWRlclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc2NoZW1hc1wiKSwgZXhwb3J0cyk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/onramp/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/onramp/onrampActionProvider.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/onramp/onrampActionProvider.js ***!
  \**********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Onramp Action Provider\n *\n * This file contains the implementation of the OnrampActionProvider,\n * which provides actions for onramp operations.\n *\n * @module onramp\n */\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.onrampActionProvider = exports.OnrampActionProvider = void 0;\nconst zod_1 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/lib/index.js\");\nconst actionProvider_1 = __webpack_require__(/*! ../actionProvider */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/actionProvider.js\");\nconst actionDecorator_1 = __webpack_require__(/*! ../actionDecorator */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/actionDecorator.js\");\nconst wallet_providers_1 = __webpack_require__(/*! ../../wallet-providers */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/wallet-providers/index.js\");\nconst schemas_1 = __webpack_require__(/*! ./schemas */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/onramp/schemas.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/onramp/utils.js\");\n/**\n * OnrampActionProvider provides actions for onramp operations.\n *\n * @description\n * This provider is designed to work with EvmWalletProvider for blockchain interactions.\n * It supports all evm networks.\n */\nclass OnrampActionProvider extends actionProvider_1.ActionProvider {\n    /**\n     * Constructor for the OnrampActionProvider.\n     *\n     * @param props - The props for the OnrampActionProvider\n     * @param props.projectId - The project ID for the OnrampActionProvider\n     */\n    constructor(props) {\n        super(\"onramp\", []);\n        this.projectId = props.projectId;\n    }\n    /**\n     * This action provides a link to buy more cryptocurrency (ETH, USDC, or BTC) using fiat currency (regular money like USD).\n     *\n     * @param walletProvider - The wallet provider instance for blockchain interactions\n     * @param _ - The arguments for the action (not used)\n     * @returns A promise that resolves to a string describing the action result\n     */\n    async getOnrampBuyUrl(walletProvider, _ = {}) {\n        const networkId = walletProvider.getNetwork().networkId;\n        if (!networkId) {\n            throw new Error(\"Network ID is not set\");\n        }\n        const network = (0, utils_1.convertNetworkIdToOnrampNetworkId)(networkId);\n        if (!network) {\n            throw new Error(\"Network ID is not supported. Make sure you are using a supported mainnet network.\");\n        }\n        return (0, utils_1.getOnrampBuyUrl)({\n            projectId: this.projectId,\n            addresses: {\n                [walletProvider.getAddress()]: [network],\n            },\n            defaultNetwork: network,\n        });\n    }\n    /**\n     * Checks if this provider supports the given network.\n     *\n     * @param network - The network to check support for\n     * @returns True if the network is supported\n     */\n    supportsNetwork(network) {\n        return Boolean(network.networkId &&\n            (0, utils_1.convertNetworkIdToOnrampNetworkId)(network.networkId) !== null &&\n            network.protocolFamily === \"evm\");\n    }\n}\nexports.OnrampActionProvider = OnrampActionProvider;\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"get_onramp_buy_url\",\n        description: `\n      Get a URL to purchase more cryptocurrency when funds are low. This action provides a link to buy more \n      cryptocurrency, defaulting to ETH, using fiat currency (regular money like USD). \n      \n      Use this when:\n      - You detect that the wallet has insufficient funds for a transaction\n      - You need to guide the user to purchase more cryptocurrency\n      - The user asks how to buy more crypto\n      \n      The URL will direct to a secure Coinbase-powered purchase interface.\n    `,\n        schema: schemas_1.GetOnrampBuyUrlActionSchema,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [wallet_providers_1.EvmWalletProvider, void 0]),\n    __metadata(\"design:returntype\", Promise)\n], OnrampActionProvider.prototype, \"getOnrampBuyUrl\", null);\n/**\n * Factory function to create a new OnrampActionProvider instance.\n *\n * @param props - The props for the OnrampActionProvider\n * @returns A new OnrampActionProvider instance\n */\nconst onrampActionProvider = (props) => new OnrampActionProvider(props);\nexports.onrampActionProvider = onrampActionProvider;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9vbnJhbXAvb25yYW1wQWN0aW9uUHJvdmlkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFFBQVE7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw0QkFBNEIsR0FBRyw0QkFBNEI7QUFDM0QsY0FBYyxtQkFBTyxDQUFDLGtEQUFLO0FBQzNCLHlCQUF5QixtQkFBTyxDQUFDLDBHQUFtQjtBQUNwRCwwQkFBMEIsbUJBQU8sQ0FBQyw0R0FBb0I7QUFDdEQsMkJBQTJCLG1CQUFPLENBQUMsc0dBQXdCO0FBQzNELGtCQUFrQixtQkFBTyxDQUFDLGtHQUFXO0FBQ3JDLGdCQUFnQixtQkFBTyxDQUFDLDhGQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cnZpdmFsLWZ1bi8uL25vZGVfbW9kdWxlcy9AY29pbmJhc2UvYWdlbnRraXQvZGlzdC9hY3Rpb24tcHJvdmlkZXJzL29ucmFtcC9vbnJhbXBBY3Rpb25Qcm92aWRlci5qcz82ZGJmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBPbnJhbXAgQWN0aW9uIFByb3ZpZGVyXG4gKlxuICogVGhpcyBmaWxlIGNvbnRhaW5zIHRoZSBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgT25yYW1wQWN0aW9uUHJvdmlkZXIsXG4gKiB3aGljaCBwcm92aWRlcyBhY3Rpb25zIGZvciBvbnJhbXAgb3BlcmF0aW9ucy5cbiAqXG4gKiBAbW9kdWxlIG9ucmFtcFxuICovXG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5vbnJhbXBBY3Rpb25Qcm92aWRlciA9IGV4cG9ydHMuT25yYW1wQWN0aW9uUHJvdmlkZXIgPSB2b2lkIDA7XG5jb25zdCB6b2RfMSA9IHJlcXVpcmUoXCJ6b2RcIik7XG5jb25zdCBhY3Rpb25Qcm92aWRlcl8xID0gcmVxdWlyZShcIi4uL2FjdGlvblByb3ZpZGVyXCIpO1xuY29uc3QgYWN0aW9uRGVjb3JhdG9yXzEgPSByZXF1aXJlKFwiLi4vYWN0aW9uRGVjb3JhdG9yXCIpO1xuY29uc3Qgd2FsbGV0X3Byb3ZpZGVyc18xID0gcmVxdWlyZShcIi4uLy4uL3dhbGxldC1wcm92aWRlcnNcIik7XG5jb25zdCBzY2hlbWFzXzEgPSByZXF1aXJlKFwiLi9zY2hlbWFzXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuLyoqXG4gKiBPbnJhbXBBY3Rpb25Qcm92aWRlciBwcm92aWRlcyBhY3Rpb25zIGZvciBvbnJhbXAgb3BlcmF0aW9ucy5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFRoaXMgcHJvdmlkZXIgaXMgZGVzaWduZWQgdG8gd29yayB3aXRoIEV2bVdhbGxldFByb3ZpZGVyIGZvciBibG9ja2NoYWluIGludGVyYWN0aW9ucy5cbiAqIEl0IHN1cHBvcnRzIGFsbCBldm0gbmV0d29ya3MuXG4gKi9cbmNsYXNzIE9ucmFtcEFjdGlvblByb3ZpZGVyIGV4dGVuZHMgYWN0aW9uUHJvdmlkZXJfMS5BY3Rpb25Qcm92aWRlciB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIHRoZSBPbnJhbXBBY3Rpb25Qcm92aWRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwcm9wcyAtIFRoZSBwcm9wcyBmb3IgdGhlIE9ucmFtcEFjdGlvblByb3ZpZGVyXG4gICAgICogQHBhcmFtIHByb3BzLnByb2plY3RJZCAtIFRoZSBwcm9qZWN0IElEIGZvciB0aGUgT25yYW1wQWN0aW9uUHJvdmlkZXJcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICBzdXBlcihcIm9ucmFtcFwiLCBbXSk7XG4gICAgICAgIHRoaXMucHJvamVjdElkID0gcHJvcHMucHJvamVjdElkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGFjdGlvbiBwcm92aWRlcyBhIGxpbmsgdG8gYnV5IG1vcmUgY3J5cHRvY3VycmVuY3kgKEVUSCwgVVNEQywgb3IgQlRDKSB1c2luZyBmaWF0IGN1cnJlbmN5IChyZWd1bGFyIG1vbmV5IGxpa2UgVVNEKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB3YWxsZXRQcm92aWRlciAtIFRoZSB3YWxsZXQgcHJvdmlkZXIgaW5zdGFuY2UgZm9yIGJsb2NrY2hhaW4gaW50ZXJhY3Rpb25zXG4gICAgICogQHBhcmFtIF8gLSBUaGUgYXJndW1lbnRzIGZvciB0aGUgYWN0aW9uIChub3QgdXNlZClcbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIHN0cmluZyBkZXNjcmliaW5nIHRoZSBhY3Rpb24gcmVzdWx0XG4gICAgICovXG4gICAgYXN5bmMgZ2V0T25yYW1wQnV5VXJsKHdhbGxldFByb3ZpZGVyLCBfID0ge30pIHtcbiAgICAgICAgY29uc3QgbmV0d29ya0lkID0gd2FsbGV0UHJvdmlkZXIuZ2V0TmV0d29yaygpLm5ldHdvcmtJZDtcbiAgICAgICAgaWYgKCFuZXR3b3JrSWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5ldHdvcmsgSUQgaXMgbm90IHNldFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXR3b3JrID0gKDAsIHV0aWxzXzEuY29udmVydE5ldHdvcmtJZFRvT25yYW1wTmV0d29ya0lkKShuZXR3b3JrSWQpO1xuICAgICAgICBpZiAoIW5ldHdvcmspIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5ldHdvcmsgSUQgaXMgbm90IHN1cHBvcnRlZC4gTWFrZSBzdXJlIHlvdSBhcmUgdXNpbmcgYSBzdXBwb3J0ZWQgbWFpbm5ldCBuZXR3b3JrLlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKDAsIHV0aWxzXzEuZ2V0T25yYW1wQnV5VXJsKSh7XG4gICAgICAgICAgICBwcm9qZWN0SWQ6IHRoaXMucHJvamVjdElkLFxuICAgICAgICAgICAgYWRkcmVzc2VzOiB7XG4gICAgICAgICAgICAgICAgW3dhbGxldFByb3ZpZGVyLmdldEFkZHJlc3MoKV06IFtuZXR3b3JrXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWZhdWx0TmV0d29yazogbmV0d29yayxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGlzIHByb3ZpZGVyIHN1cHBvcnRzIHRoZSBnaXZlbiBuZXR3b3JrLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5ldHdvcmsgLSBUaGUgbmV0d29yayB0byBjaGVjayBzdXBwb3J0IGZvclxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIG5ldHdvcmsgaXMgc3VwcG9ydGVkXG4gICAgICovXG4gICAgc3VwcG9ydHNOZXR3b3JrKG5ldHdvcmspIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4obmV0d29yay5uZXR3b3JrSWQgJiZcbiAgICAgICAgICAgICgwLCB1dGlsc18xLmNvbnZlcnROZXR3b3JrSWRUb09ucmFtcE5ldHdvcmtJZCkobmV0d29yay5uZXR3b3JrSWQpICE9PSBudWxsICYmXG4gICAgICAgICAgICBuZXR3b3JrLnByb3RvY29sRmFtaWx5ID09PSBcImV2bVwiKTtcbiAgICB9XG59XG5leHBvcnRzLk9ucmFtcEFjdGlvblByb3ZpZGVyID0gT25yYW1wQWN0aW9uUHJvdmlkZXI7XG5fX2RlY29yYXRlKFtcbiAgICAoMCwgYWN0aW9uRGVjb3JhdG9yXzEuQ3JlYXRlQWN0aW9uKSh7XG4gICAgICAgIG5hbWU6IFwiZ2V0X29ucmFtcF9idXlfdXJsXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgXG4gICAgICBHZXQgYSBVUkwgdG8gcHVyY2hhc2UgbW9yZSBjcnlwdG9jdXJyZW5jeSB3aGVuIGZ1bmRzIGFyZSBsb3cuIFRoaXMgYWN0aW9uIHByb3ZpZGVzIGEgbGluayB0byBidXkgbW9yZSBcbiAgICAgIGNyeXB0b2N1cnJlbmN5LCBkZWZhdWx0aW5nIHRvIEVUSCwgdXNpbmcgZmlhdCBjdXJyZW5jeSAocmVndWxhciBtb25leSBsaWtlIFVTRCkuIFxuICAgICAgXG4gICAgICBVc2UgdGhpcyB3aGVuOlxuICAgICAgLSBZb3UgZGV0ZWN0IHRoYXQgdGhlIHdhbGxldCBoYXMgaW5zdWZmaWNpZW50IGZ1bmRzIGZvciBhIHRyYW5zYWN0aW9uXG4gICAgICAtIFlvdSBuZWVkIHRvIGd1aWRlIHRoZSB1c2VyIHRvIHB1cmNoYXNlIG1vcmUgY3J5cHRvY3VycmVuY3lcbiAgICAgIC0gVGhlIHVzZXIgYXNrcyBob3cgdG8gYnV5IG1vcmUgY3J5cHRvXG4gICAgICBcbiAgICAgIFRoZSBVUkwgd2lsbCBkaXJlY3QgdG8gYSBzZWN1cmUgQ29pbmJhc2UtcG93ZXJlZCBwdXJjaGFzZSBpbnRlcmZhY2UuXG4gICAgYCxcbiAgICAgICAgc2NoZW1hOiBzY2hlbWFzXzEuR2V0T25yYW1wQnV5VXJsQWN0aW9uU2NoZW1hLFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFt3YWxsZXRfcHJvdmlkZXJzXzEuRXZtV2FsbGV0UHJvdmlkZXIsIHZvaWQgMF0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCBQcm9taXNlKVxuXSwgT25yYW1wQWN0aW9uUHJvdmlkZXIucHJvdG90eXBlLCBcImdldE9ucmFtcEJ1eVVybFwiLCBudWxsKTtcbi8qKlxuICogRmFjdG9yeSBmdW5jdGlvbiB0byBjcmVhdGUgYSBuZXcgT25yYW1wQWN0aW9uUHJvdmlkZXIgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIHByb3BzIC0gVGhlIHByb3BzIGZvciB0aGUgT25yYW1wQWN0aW9uUHJvdmlkZXJcbiAqIEByZXR1cm5zIEEgbmV3IE9ucmFtcEFjdGlvblByb3ZpZGVyIGluc3RhbmNlXG4gKi9cbmNvbnN0IG9ucmFtcEFjdGlvblByb3ZpZGVyID0gKHByb3BzKSA9PiBuZXcgT25yYW1wQWN0aW9uUHJvdmlkZXIocHJvcHMpO1xuZXhwb3J0cy5vbnJhbXBBY3Rpb25Qcm92aWRlciA9IG9ucmFtcEFjdGlvblByb3ZpZGVyO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/onramp/onrampActionProvider.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/onramp/schemas.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/onramp/schemas.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GetOnrampBuyUrlActionSchema = void 0;\nconst zod_1 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/lib/index.js\");\n/**\n * Action schemas for the onramp action provider.\n *\n * This file contains the Zod schemas that define the shape and validation\n * rules for action parameters in the onramp action provider.\n */\n/**\n * Example action schema demonstrating various field types and validations.\n * Replace or modify this with your actual action schemas.\n */\nexports.GetOnrampBuyUrlActionSchema = zod_1.z.object({});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9vbnJhbXAvc2NoZW1hcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQ0FBbUM7QUFDbkMsY0FBYyxtQkFBTyxDQUFDLGtEQUFLO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLG9CQUFvQiIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cnZpdmFsLWZ1bi8uL25vZGVfbW9kdWxlcy9AY29pbmJhc2UvYWdlbnRraXQvZGlzdC9hY3Rpb24tcHJvdmlkZXJzL29ucmFtcC9zY2hlbWFzLmpzPzI4ZjUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkdldE9ucmFtcEJ1eVVybEFjdGlvblNjaGVtYSA9IHZvaWQgMDtcbmNvbnN0IHpvZF8xID0gcmVxdWlyZShcInpvZFwiKTtcbi8qKlxuICogQWN0aW9uIHNjaGVtYXMgZm9yIHRoZSBvbnJhbXAgYWN0aW9uIHByb3ZpZGVyLlxuICpcbiAqIFRoaXMgZmlsZSBjb250YWlucyB0aGUgWm9kIHNjaGVtYXMgdGhhdCBkZWZpbmUgdGhlIHNoYXBlIGFuZCB2YWxpZGF0aW9uXG4gKiBydWxlcyBmb3IgYWN0aW9uIHBhcmFtZXRlcnMgaW4gdGhlIG9ucmFtcCBhY3Rpb24gcHJvdmlkZXIuXG4gKi9cbi8qKlxuICogRXhhbXBsZSBhY3Rpb24gc2NoZW1hIGRlbW9uc3RyYXRpbmcgdmFyaW91cyBmaWVsZCB0eXBlcyBhbmQgdmFsaWRhdGlvbnMuXG4gKiBSZXBsYWNlIG9yIG1vZGlmeSB0aGlzIHdpdGggeW91ciBhY3R1YWwgYWN0aW9uIHNjaGVtYXMuXG4gKi9cbmV4cG9ydHMuR2V0T25yYW1wQnV5VXJsQWN0aW9uU2NoZW1hID0gem9kXzEuei5vYmplY3Qoe30pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/onramp/schemas.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/onramp/utils.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/onramp/utils.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.convertNetworkIdToOnrampNetworkId = void 0;\nexports.getOnrampBuyUrl = getOnrampBuyUrl;\nconst version_1 = __webpack_require__(/*! ./version */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/onramp/version.js\");\n/**\n * Builds a Coinbase Onramp buy URL using the provided parameters.\n *\n * @param props - Configuration options for the Onramp buy URL\n * @param props.projectId - A projectId generated in the Coinbase Developer Portal\n * @returns The generated Onramp buy URL\n */\nfunction getOnrampBuyUrl({ projectId, ...props }) {\n    const url = new URL(version_1.ONRAMP_BUY_URL);\n    if (projectId !== undefined) {\n        // Coinbase Onramp requires projectId to be passed as appId\n        url.searchParams.append(\"appId\", projectId);\n    }\n    for (const key of Object.keys(props)) {\n        const value = props[key];\n        if (value !== undefined) {\n            if ([\"string\", \"number\", \"boolean\"].includes(typeof value)) {\n                url.searchParams.append(key, value.toString());\n            }\n            else {\n                url.searchParams.append(key, JSON.stringify(value));\n            }\n        }\n    }\n    url.searchParams.append(\"sdkVersion\", `onchainkit@${version_1.VERSION}`);\n    url.searchParams.sort();\n    return url.toString();\n}\n/**\n * Converts a network ID to an Onramp network ID.\n *\n * @param networkId - The network ID to convert\n * @returns The Onramp network ID or null if the network ID is not supported\n */\nconst convertNetworkIdToOnrampNetworkId = (networkId) => {\n    switch (networkId) {\n        case \"base-mainnet\":\n            return \"base\";\n        case \"ethereum-mainnet\":\n            return \"ethereum\";\n        case \"polygon-mainnet\":\n            return \"polygon\";\n        case \"optimism-mainnet\":\n            return \"optimism\";\n        case \"arbitrum-mainnet\":\n            return \"arbitrum\";\n        default:\n            return null;\n    }\n};\nexports.convertNetworkIdToOnrampNetworkId = convertNetworkIdToOnrampNetworkId;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9vbnJhbXAvdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QseUNBQXlDO0FBQ3pDLHVCQUF1QjtBQUN2QixrQkFBa0IsbUJBQU8sQ0FBQyxrR0FBVztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixxQkFBcUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Qsa0JBQWtCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3Vydml2YWwtZnVuLy4vbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9hZ2VudGtpdC9kaXN0L2FjdGlvbi1wcm92aWRlcnMvb25yYW1wL3V0aWxzLmpzPzgzMjQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNvbnZlcnROZXR3b3JrSWRUb09ucmFtcE5ldHdvcmtJZCA9IHZvaWQgMDtcbmV4cG9ydHMuZ2V0T25yYW1wQnV5VXJsID0gZ2V0T25yYW1wQnV5VXJsO1xuY29uc3QgdmVyc2lvbl8xID0gcmVxdWlyZShcIi4vdmVyc2lvblwiKTtcbi8qKlxuICogQnVpbGRzIGEgQ29pbmJhc2UgT25yYW1wIGJ1eSBVUkwgdXNpbmcgdGhlIHByb3ZpZGVkIHBhcmFtZXRlcnMuXG4gKlxuICogQHBhcmFtIHByb3BzIC0gQ29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgT25yYW1wIGJ1eSBVUkxcbiAqIEBwYXJhbSBwcm9wcy5wcm9qZWN0SWQgLSBBIHByb2plY3RJZCBnZW5lcmF0ZWQgaW4gdGhlIENvaW5iYXNlIERldmVsb3BlciBQb3J0YWxcbiAqIEByZXR1cm5zIFRoZSBnZW5lcmF0ZWQgT25yYW1wIGJ1eSBVUkxcbiAqL1xuZnVuY3Rpb24gZ2V0T25yYW1wQnV5VXJsKHsgcHJvamVjdElkLCAuLi5wcm9wcyB9KSB7XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTCh2ZXJzaW9uXzEuT05SQU1QX0JVWV9VUkwpO1xuICAgIGlmIChwcm9qZWN0SWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBDb2luYmFzZSBPbnJhbXAgcmVxdWlyZXMgcHJvamVjdElkIHRvIGJlIHBhc3NlZCBhcyBhcHBJZFxuICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChcImFwcElkXCIsIHByb2plY3RJZCk7XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHByb3BzKSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHByb3BzW2tleV07XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoW1wic3RyaW5nXCIsIFwibnVtYmVyXCIsIFwiYm9vbGVhblwiXS5pbmNsdWRlcyh0eXBlb2YgdmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoa2V5LCB2YWx1ZS50b1N0cmluZygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGtleSwgSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB1cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChcInNka1ZlcnNpb25cIiwgYG9uY2hhaW5raXRAJHt2ZXJzaW9uXzEuVkVSU0lPTn1gKTtcbiAgICB1cmwuc2VhcmNoUGFyYW1zLnNvcnQoKTtcbiAgICByZXR1cm4gdXJsLnRvU3RyaW5nKCk7XG59XG4vKipcbiAqIENvbnZlcnRzIGEgbmV0d29yayBJRCB0byBhbiBPbnJhbXAgbmV0d29yayBJRC5cbiAqXG4gKiBAcGFyYW0gbmV0d29ya0lkIC0gVGhlIG5ldHdvcmsgSUQgdG8gY29udmVydFxuICogQHJldHVybnMgVGhlIE9ucmFtcCBuZXR3b3JrIElEIG9yIG51bGwgaWYgdGhlIG5ldHdvcmsgSUQgaXMgbm90IHN1cHBvcnRlZFxuICovXG5jb25zdCBjb252ZXJ0TmV0d29ya0lkVG9PbnJhbXBOZXR3b3JrSWQgPSAobmV0d29ya0lkKSA9PiB7XG4gICAgc3dpdGNoIChuZXR3b3JrSWQpIHtcbiAgICAgICAgY2FzZSBcImJhc2UtbWFpbm5ldFwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiYmFzZVwiO1xuICAgICAgICBjYXNlIFwiZXRoZXJldW0tbWFpbm5ldFwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiZXRoZXJldW1cIjtcbiAgICAgICAgY2FzZSBcInBvbHlnb24tbWFpbm5ldFwiOlxuICAgICAgICAgICAgcmV0dXJuIFwicG9seWdvblwiO1xuICAgICAgICBjYXNlIFwib3B0aW1pc20tbWFpbm5ldFwiOlxuICAgICAgICAgICAgcmV0dXJuIFwib3B0aW1pc21cIjtcbiAgICAgICAgY2FzZSBcImFyYml0cnVtLW1haW5uZXRcIjpcbiAgICAgICAgICAgIHJldHVybiBcImFyYml0cnVtXCI7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59O1xuZXhwb3J0cy5jb252ZXJ0TmV0d29ya0lkVG9PbnJhbXBOZXR3b3JrSWQgPSBjb252ZXJ0TmV0d29ya0lkVG9PbnJhbXBOZXR3b3JrSWQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/onramp/utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/onramp/version.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/onramp/version.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ONRAMP_BUY_URL = exports.VERSION = void 0;\nexports.VERSION = \"0.38.2\";\nexports.ONRAMP_BUY_URL = \"https://pay.coinbase.com/buy\";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9vbnJhbXAvdmVyc2lvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQkFBc0IsR0FBRyxlQUFlO0FBQ3hDLGVBQWU7QUFDZixzQkFBc0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXJ2aXZhbC1mdW4vLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9vbnJhbXAvdmVyc2lvbi5qcz9lOTAyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5PTlJBTVBfQlVZX1VSTCA9IGV4cG9ydHMuVkVSU0lPTiA9IHZvaWQgMDtcbmV4cG9ydHMuVkVSU0lPTiA9IFwiMC4zOC4yXCI7XG5leHBvcnRzLk9OUkFNUF9CVVlfVVJMID0gXCJodHRwczovL3BheS5jb2luYmFzZS5jb20vYnV5XCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/onramp/version.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/opensea/index.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/opensea/index.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./openseaActionProvider */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/opensea/openseaActionProvider.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9vcGVuc2VhL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWEsbUJBQU8sQ0FBQywrSEFBeUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXJ2aXZhbC1mdW4vLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9vcGVuc2VhL2luZGV4LmpzP2JjOTAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9vcGVuc2VhQWN0aW9uUHJvdmlkZXJcIiksIGV4cG9ydHMpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/opensea/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/opensea/openseaActionProvider.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/opensea/openseaActionProvider.js ***!
  \************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.openseaActionProvider = exports.OpenseaActionProvider = void 0;\nconst zod_1 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/lib/index.js\");\nconst actionProvider_1 = __webpack_require__(/*! ../actionProvider */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/actionProvider.js\");\nconst actionDecorator_1 = __webpack_require__(/*! ../actionDecorator */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/actionDecorator.js\");\nconst schemas_1 = __webpack_require__(/*! ./schemas */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/opensea/schemas.js\");\nconst opensea_js_1 = __webpack_require__(/*! opensea-js */ \"(rsc)/./node_modules/opensea-js/lib/index.js\");\nconst network_1 = __webpack_require__(/*! ../../network */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/network/index.js\");\nconst ethers_1 = __webpack_require__(/*! ethers */ \"(rsc)/./node_modules/ethers/lib.commonjs/index.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/opensea/utils.js\");\n/**\n * OpenseaActionProvider is an action provider for OpenSea marketplace interactions.\n */\nclass OpenseaActionProvider extends actionProvider_1.ActionProvider {\n    /**\n     * Constructor for the OpenseaActionProvider class.\n     *\n     * @param config - The configuration options for the OpenseaActionProvider.\n     */\n    constructor(config = {}) {\n        super(\"opensea\", []);\n        /**\n         * Checks if the Opensea action provider supports the given network.\n         *\n         * @param network - The network to check.\n         * @returns True if the Opensea action provider supports the network, false otherwise.\n         */\n        this.supportsNetwork = (network) => network.chainId !== undefined && utils_1.supportedChains[network.chainId] !== undefined;\n        const apiKey = config.apiKey || process.env.OPENSEA_API_KEY;\n        if (!apiKey) {\n            throw new Error(\"OPENSEA_API_KEY is not configured.\");\n        }\n        this.apiKey = apiKey;\n        const chainId = network_1.NETWORK_ID_TO_CHAIN_ID[config.networkId || \"base-sepolia\"];\n        const provider = ethers_1.ethers.getDefaultProvider(parseInt(chainId));\n        const walletWithProvider = new ethers_1.Wallet(config.privateKey, provider);\n        this.walletWithProvider = walletWithProvider;\n        const openseaSDK = new opensea_js_1.OpenSeaSDK(walletWithProvider, {\n            chain: (0, utils_1.chainIdToOpenseaChain)(chainId),\n            apiKey: this.apiKey,\n        });\n        this.openseaSDK = openseaSDK;\n        this.openseaBaseUrl = this.openseaSDK.api.apiBaseUrl.replace(\"-api\", \"\").replace(\"api\", \"\");\n    }\n    /**\n     * Lists an NFT for sale on OpenSea.\n     *\n     * @param args - The input arguments for the action.\n     * @returns A message containing the listing details.\n     */\n    async listNft(args) {\n        try {\n            const expirationTime = Math.round(Date.now() / 1000 + args.expirationDays * 24 * 60 * 60);\n            await this.openseaSDK.createListing({\n                asset: {\n                    tokenId: args.tokenId,\n                    tokenAddress: args.contractAddress,\n                },\n                startAmount: args.price,\n                quantity: 1,\n                paymentTokenAddress: \"0x0000000000000000000000000000000000000000\", // ETH\n                expirationTime,\n                accountAddress: this.walletWithProvider.address,\n            });\n            const listingLink = `${this.openseaBaseUrl}/assets/${this.openseaSDK.chain}/${args.contractAddress}/${args.tokenId}`;\n            return `Successfully listed NFT ${args.contractAddress} token ${args.tokenId} for ${args.price} ETH, expiring in ${args.expirationDays} days. Listing on OpenSea: ${listingLink}.`;\n        }\n        catch (error) {\n            return `Error listing NFT ${args.contractAddress} token ${args.tokenId} for ${args.price} ETH using account ${this.walletWithProvider.address}: ${error}`;\n        }\n    }\n    /**\n     * Fetch NFTs of a specific wallet address.\n     *\n     * @param args - The input arguments for the action.\n     * @returns A JSON string containing the NFTs or error message\n     */\n    async getNftsByAccount(args) {\n        try {\n            const address = args.accountAddress || this.walletWithProvider.address;\n            const { nfts } = await this.openseaSDK.api.getNFTsByAccount(address);\n            return JSON.stringify(nfts);\n        }\n        catch (error) {\n            const address = args.accountAddress || this.walletWithProvider.address;\n            return `Error fetching NFTs for account ${address}: ${error}`;\n        }\n    }\n}\nexports.OpenseaActionProvider = OpenseaActionProvider;\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"list_nft\",\n        description: `\nThis tool will list an NFT for sale on the OpenSea marketplace. \nEVM networks are supported on mainnet and testnets.\n\nIt takes the following inputs:\n- contractAddress: The NFT contract address to list\n- tokenId: The ID of the NFT to list\n- price: The price in ETH for which the NFT will be listed\n- expirationDays: (Optional) Number of days the listing should be active for (default: 90)\n\nImportant notes:\n- The wallet must own the NFT\n- Price is in ETH (e.g., 1.5 for 1.5 ETH). This is the amount the seller will receive if the NFT is sold. It is not required to have this amount in the wallet.\n- Listing the NFT requires approval for OpenSea to manage the entire NFT collection:  \n  - If the collection is not already approved, an onchain transaction is required, which will incur gas fees.  \n  - If already approved, listing is gasless and does not require any onchain transaction. \n  - EVM networks are supported on mainnet and testnets, for example: base-mainnet and base-sepolia.\n  `,\n        schema: schemas_1.ListNftSchema,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [void 0]),\n    __metadata(\"design:returntype\", Promise)\n], OpenseaActionProvider.prototype, \"listNft\", null);\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"get_nfts_by_account\",\n        description: `\nThis tool will fetch NFTs owned by a specific wallet address on OpenSea.\n\nIt takes the following inputs:\n- accountAddress: (Optional) The wallet address to fetch NFTs for. If not provided, uses the connected wallet address.\n\nThe tool will return a JSON string containing the NFTs owned by the specified address.\n    `,\n        schema: schemas_1.GetNftsByAccountSchema,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [void 0]),\n    __metadata(\"design:returntype\", Promise)\n], OpenseaActionProvider.prototype, \"getNftsByAccount\", null);\nconst openseaActionProvider = (config) => new OpenseaActionProvider(config);\nexports.openseaActionProvider = openseaActionProvider;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9vcGVuc2VhL29wZW5zZWFBY3Rpb25Qcm92aWRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxRQUFRO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNkJBQTZCLEdBQUcsNkJBQTZCO0FBQzdELGNBQWMsbUJBQU8sQ0FBQyxrREFBSztBQUMzQix5QkFBeUIsbUJBQU8sQ0FBQywwR0FBbUI7QUFDcEQsMEJBQTBCLG1CQUFPLENBQUMsNEdBQW9CO0FBQ3RELGtCQUFrQixtQkFBTyxDQUFDLG1HQUFXO0FBQ3JDLHFCQUFxQixtQkFBTyxDQUFDLGdFQUFZO0FBQ3pDLGtCQUFrQixtQkFBTyxDQUFDLG9GQUFlO0FBQ3pDLGlCQUFpQixtQkFBTyxDQUFDLGlFQUFRO0FBQ2pDLGdCQUFnQixtQkFBTyxDQUFDLCtGQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsbUNBQW1DLG9CQUFvQixVQUFVLHNCQUFzQixHQUFHLHFCQUFxQixHQUFHLGFBQWE7QUFDL0gsOENBQThDLHNCQUFzQixRQUFRLGNBQWMsTUFBTSxZQUFZLG1CQUFtQixxQkFBcUIsNEJBQTRCLFlBQVk7QUFDNUw7QUFDQTtBQUNBLHdDQUF3QyxzQkFBc0IsUUFBUSxjQUFjLE1BQU0sWUFBWSxvQkFBb0IsZ0NBQWdDLElBQUksTUFBTTtBQUNwSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsUUFBUSxJQUFJLE1BQU07QUFDeEU7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QiIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cnZpdmFsLWZ1bi8uL25vZGVfbW9kdWxlcy9AY29pbmJhc2UvYWdlbnRraXQvZGlzdC9hY3Rpb24tcHJvdmlkZXJzL29wZW5zZWEvb3BlbnNlYUFjdGlvblByb3ZpZGVyLmpzPzBkMGUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5vcGVuc2VhQWN0aW9uUHJvdmlkZXIgPSBleHBvcnRzLk9wZW5zZWFBY3Rpb25Qcm92aWRlciA9IHZvaWQgMDtcbmNvbnN0IHpvZF8xID0gcmVxdWlyZShcInpvZFwiKTtcbmNvbnN0IGFjdGlvblByb3ZpZGVyXzEgPSByZXF1aXJlKFwiLi4vYWN0aW9uUHJvdmlkZXJcIik7XG5jb25zdCBhY3Rpb25EZWNvcmF0b3JfMSA9IHJlcXVpcmUoXCIuLi9hY3Rpb25EZWNvcmF0b3JcIik7XG5jb25zdCBzY2hlbWFzXzEgPSByZXF1aXJlKFwiLi9zY2hlbWFzXCIpO1xuY29uc3Qgb3BlbnNlYV9qc18xID0gcmVxdWlyZShcIm9wZW5zZWEtanNcIik7XG5jb25zdCBuZXR3b3JrXzEgPSByZXF1aXJlKFwiLi4vLi4vbmV0d29ya1wiKTtcbmNvbnN0IGV0aGVyc18xID0gcmVxdWlyZShcImV0aGVyc1wiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbi8qKlxuICogT3BlbnNlYUFjdGlvblByb3ZpZGVyIGlzIGFuIGFjdGlvbiBwcm92aWRlciBmb3IgT3BlblNlYSBtYXJrZXRwbGFjZSBpbnRlcmFjdGlvbnMuXG4gKi9cbmNsYXNzIE9wZW5zZWFBY3Rpb25Qcm92aWRlciBleHRlbmRzIGFjdGlvblByb3ZpZGVyXzEuQWN0aW9uUHJvdmlkZXIge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciB0aGUgT3BlbnNlYUFjdGlvblByb3ZpZGVyIGNsYXNzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbmZpZyAtIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBPcGVuc2VhQWN0aW9uUHJvdmlkZXIuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnID0ge30pIHtcbiAgICAgICAgc3VwZXIoXCJvcGVuc2VhXCIsIFtdKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrcyBpZiB0aGUgT3BlbnNlYSBhY3Rpb24gcHJvdmlkZXIgc3VwcG9ydHMgdGhlIGdpdmVuIG5ldHdvcmsuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBuZXR3b3JrIC0gVGhlIG5ldHdvcmsgdG8gY2hlY2suXG4gICAgICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIE9wZW5zZWEgYWN0aW9uIHByb3ZpZGVyIHN1cHBvcnRzIHRoZSBuZXR3b3JrLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN1cHBvcnRzTmV0d29yayA9IChuZXR3b3JrKSA9PiBuZXR3b3JrLmNoYWluSWQgIT09IHVuZGVmaW5lZCAmJiB1dGlsc18xLnN1cHBvcnRlZENoYWluc1tuZXR3b3JrLmNoYWluSWRdICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IGFwaUtleSA9IGNvbmZpZy5hcGlLZXkgfHwgcHJvY2Vzcy5lbnYuT1BFTlNFQV9BUElfS0VZO1xuICAgICAgICBpZiAoIWFwaUtleSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT1BFTlNFQV9BUElfS0VZIGlzIG5vdCBjb25maWd1cmVkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFwaUtleSA9IGFwaUtleTtcbiAgICAgICAgY29uc3QgY2hhaW5JZCA9IG5ldHdvcmtfMS5ORVRXT1JLX0lEX1RPX0NIQUlOX0lEW2NvbmZpZy5uZXR3b3JrSWQgfHwgXCJiYXNlLXNlcG9saWFcIl07XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gZXRoZXJzXzEuZXRoZXJzLmdldERlZmF1bHRQcm92aWRlcihwYXJzZUludChjaGFpbklkKSk7XG4gICAgICAgIGNvbnN0IHdhbGxldFdpdGhQcm92aWRlciA9IG5ldyBldGhlcnNfMS5XYWxsZXQoY29uZmlnLnByaXZhdGVLZXksIHByb3ZpZGVyKTtcbiAgICAgICAgdGhpcy53YWxsZXRXaXRoUHJvdmlkZXIgPSB3YWxsZXRXaXRoUHJvdmlkZXI7XG4gICAgICAgIGNvbnN0IG9wZW5zZWFTREsgPSBuZXcgb3BlbnNlYV9qc18xLk9wZW5TZWFTREsod2FsbGV0V2l0aFByb3ZpZGVyLCB7XG4gICAgICAgICAgICBjaGFpbjogKDAsIHV0aWxzXzEuY2hhaW5JZFRvT3BlbnNlYUNoYWluKShjaGFpbklkKSxcbiAgICAgICAgICAgIGFwaUtleTogdGhpcy5hcGlLZXksXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm9wZW5zZWFTREsgPSBvcGVuc2VhU0RLO1xuICAgICAgICB0aGlzLm9wZW5zZWFCYXNlVXJsID0gdGhpcy5vcGVuc2VhU0RLLmFwaS5hcGlCYXNlVXJsLnJlcGxhY2UoXCItYXBpXCIsIFwiXCIpLnJlcGxhY2UoXCJhcGlcIiwgXCJcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3RzIGFuIE5GVCBmb3Igc2FsZSBvbiBPcGVuU2VhLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFyZ3MgLSBUaGUgaW5wdXQgYXJndW1lbnRzIGZvciB0aGUgYWN0aW9uLlxuICAgICAqIEByZXR1cm5zIEEgbWVzc2FnZSBjb250YWluaW5nIHRoZSBsaXN0aW5nIGRldGFpbHMuXG4gICAgICovXG4gICAgYXN5bmMgbGlzdE5mdChhcmdzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBleHBpcmF0aW9uVGltZSA9IE1hdGgucm91bmQoRGF0ZS5ub3coKSAvIDEwMDAgKyBhcmdzLmV4cGlyYXRpb25EYXlzICogMjQgKiA2MCAqIDYwKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMub3BlbnNlYVNESy5jcmVhdGVMaXN0aW5nKHtcbiAgICAgICAgICAgICAgICBhc3NldDoge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbklkOiBhcmdzLnRva2VuSWQsXG4gICAgICAgICAgICAgICAgICAgIHRva2VuQWRkcmVzczogYXJncy5jb250cmFjdEFkZHJlc3MsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzdGFydEFtb3VudDogYXJncy5wcmljZSxcbiAgICAgICAgICAgICAgICBxdWFudGl0eTogMSxcbiAgICAgICAgICAgICAgICBwYXltZW50VG9rZW5BZGRyZXNzOiBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiLCAvLyBFVEhcbiAgICAgICAgICAgICAgICBleHBpcmF0aW9uVGltZSxcbiAgICAgICAgICAgICAgICBhY2NvdW50QWRkcmVzczogdGhpcy53YWxsZXRXaXRoUHJvdmlkZXIuYWRkcmVzcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgbGlzdGluZ0xpbmsgPSBgJHt0aGlzLm9wZW5zZWFCYXNlVXJsfS9hc3NldHMvJHt0aGlzLm9wZW5zZWFTREsuY2hhaW59LyR7YXJncy5jb250cmFjdEFkZHJlc3N9LyR7YXJncy50b2tlbklkfWA7XG4gICAgICAgICAgICByZXR1cm4gYFN1Y2Nlc3NmdWxseSBsaXN0ZWQgTkZUICR7YXJncy5jb250cmFjdEFkZHJlc3N9IHRva2VuICR7YXJncy50b2tlbklkfSBmb3IgJHthcmdzLnByaWNlfSBFVEgsIGV4cGlyaW5nIGluICR7YXJncy5leHBpcmF0aW9uRGF5c30gZGF5cy4gTGlzdGluZyBvbiBPcGVuU2VhOiAke2xpc3RpbmdMaW5rfS5gO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGBFcnJvciBsaXN0aW5nIE5GVCAke2FyZ3MuY29udHJhY3RBZGRyZXNzfSB0b2tlbiAke2FyZ3MudG9rZW5JZH0gZm9yICR7YXJncy5wcmljZX0gRVRIIHVzaW5nIGFjY291bnQgJHt0aGlzLndhbGxldFdpdGhQcm92aWRlci5hZGRyZXNzfTogJHtlcnJvcn1gO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoIE5GVHMgb2YgYSBzcGVjaWZpYyB3YWxsZXQgYWRkcmVzcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhcmdzIC0gVGhlIGlucHV0IGFyZ3VtZW50cyBmb3IgdGhlIGFjdGlvbi5cbiAgICAgKiBAcmV0dXJucyBBIEpTT04gc3RyaW5nIGNvbnRhaW5pbmcgdGhlIE5GVHMgb3IgZXJyb3IgbWVzc2FnZVxuICAgICAqL1xuICAgIGFzeW5jIGdldE5mdHNCeUFjY291bnQoYXJncykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9IGFyZ3MuYWNjb3VudEFkZHJlc3MgfHwgdGhpcy53YWxsZXRXaXRoUHJvdmlkZXIuYWRkcmVzcztcbiAgICAgICAgICAgIGNvbnN0IHsgbmZ0cyB9ID0gYXdhaXQgdGhpcy5vcGVuc2VhU0RLLmFwaS5nZXRORlRzQnlBY2NvdW50KGFkZHJlc3MpO1xuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG5mdHMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9IGFyZ3MuYWNjb3VudEFkZHJlc3MgfHwgdGhpcy53YWxsZXRXaXRoUHJvdmlkZXIuYWRkcmVzcztcbiAgICAgICAgICAgIHJldHVybiBgRXJyb3IgZmV0Y2hpbmcgTkZUcyBmb3IgYWNjb3VudCAke2FkZHJlc3N9OiAke2Vycm9yfWA7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLk9wZW5zZWFBY3Rpb25Qcm92aWRlciA9IE9wZW5zZWFBY3Rpb25Qcm92aWRlcjtcbl9fZGVjb3JhdGUoW1xuICAgICgwLCBhY3Rpb25EZWNvcmF0b3JfMS5DcmVhdGVBY3Rpb24pKHtcbiAgICAgICAgbmFtZTogXCJsaXN0X25mdFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogYFxuVGhpcyB0b29sIHdpbGwgbGlzdCBhbiBORlQgZm9yIHNhbGUgb24gdGhlIE9wZW5TZWEgbWFya2V0cGxhY2UuIFxuRVZNIG5ldHdvcmtzIGFyZSBzdXBwb3J0ZWQgb24gbWFpbm5ldCBhbmQgdGVzdG5ldHMuXG5cbkl0IHRha2VzIHRoZSBmb2xsb3dpbmcgaW5wdXRzOlxuLSBjb250cmFjdEFkZHJlc3M6IFRoZSBORlQgY29udHJhY3QgYWRkcmVzcyB0byBsaXN0XG4tIHRva2VuSWQ6IFRoZSBJRCBvZiB0aGUgTkZUIHRvIGxpc3Rcbi0gcHJpY2U6IFRoZSBwcmljZSBpbiBFVEggZm9yIHdoaWNoIHRoZSBORlQgd2lsbCBiZSBsaXN0ZWRcbi0gZXhwaXJhdGlvbkRheXM6IChPcHRpb25hbCkgTnVtYmVyIG9mIGRheXMgdGhlIGxpc3Rpbmcgc2hvdWxkIGJlIGFjdGl2ZSBmb3IgKGRlZmF1bHQ6IDkwKVxuXG5JbXBvcnRhbnQgbm90ZXM6XG4tIFRoZSB3YWxsZXQgbXVzdCBvd24gdGhlIE5GVFxuLSBQcmljZSBpcyBpbiBFVEggKGUuZy4sIDEuNSBmb3IgMS41IEVUSCkuIFRoaXMgaXMgdGhlIGFtb3VudCB0aGUgc2VsbGVyIHdpbGwgcmVjZWl2ZSBpZiB0aGUgTkZUIGlzIHNvbGQuIEl0IGlzIG5vdCByZXF1aXJlZCB0byBoYXZlIHRoaXMgYW1vdW50IGluIHRoZSB3YWxsZXQuXG4tIExpc3RpbmcgdGhlIE5GVCByZXF1aXJlcyBhcHByb3ZhbCBmb3IgT3BlblNlYSB0byBtYW5hZ2UgdGhlIGVudGlyZSBORlQgY29sbGVjdGlvbjogIFxuICAtIElmIHRoZSBjb2xsZWN0aW9uIGlzIG5vdCBhbHJlYWR5IGFwcHJvdmVkLCBhbiBvbmNoYWluIHRyYW5zYWN0aW9uIGlzIHJlcXVpcmVkLCB3aGljaCB3aWxsIGluY3VyIGdhcyBmZWVzLiAgXG4gIC0gSWYgYWxyZWFkeSBhcHByb3ZlZCwgbGlzdGluZyBpcyBnYXNsZXNzIGFuZCBkb2VzIG5vdCByZXF1aXJlIGFueSBvbmNoYWluIHRyYW5zYWN0aW9uLiBcbiAgLSBFVk0gbmV0d29ya3MgYXJlIHN1cHBvcnRlZCBvbiBtYWlubmV0IGFuZCB0ZXN0bmV0cywgZm9yIGV4YW1wbGU6IGJhc2UtbWFpbm5ldCBhbmQgYmFzZS1zZXBvbGlhLlxuICBgLFxuICAgICAgICBzY2hlbWE6IHNjaGVtYXNfMS5MaXN0TmZ0U2NoZW1hLFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFt2b2lkIDBdKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgUHJvbWlzZSlcbl0sIE9wZW5zZWFBY3Rpb25Qcm92aWRlci5wcm90b3R5cGUsIFwibGlzdE5mdFwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgICgwLCBhY3Rpb25EZWNvcmF0b3JfMS5DcmVhdGVBY3Rpb24pKHtcbiAgICAgICAgbmFtZTogXCJnZXRfbmZ0c19ieV9hY2NvdW50XCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgXG5UaGlzIHRvb2wgd2lsbCBmZXRjaCBORlRzIG93bmVkIGJ5IGEgc3BlY2lmaWMgd2FsbGV0IGFkZHJlc3Mgb24gT3BlblNlYS5cblxuSXQgdGFrZXMgdGhlIGZvbGxvd2luZyBpbnB1dHM6XG4tIGFjY291bnRBZGRyZXNzOiAoT3B0aW9uYWwpIFRoZSB3YWxsZXQgYWRkcmVzcyB0byBmZXRjaCBORlRzIGZvci4gSWYgbm90IHByb3ZpZGVkLCB1c2VzIHRoZSBjb25uZWN0ZWQgd2FsbGV0IGFkZHJlc3MuXG5cblRoZSB0b29sIHdpbGwgcmV0dXJuIGEgSlNPTiBzdHJpbmcgY29udGFpbmluZyB0aGUgTkZUcyBvd25lZCBieSB0aGUgc3BlY2lmaWVkIGFkZHJlc3MuXG4gICAgYCxcbiAgICAgICAgc2NoZW1hOiBzY2hlbWFzXzEuR2V0TmZ0c0J5QWNjb3VudFNjaGVtYSxcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbdm9pZCAwXSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIFByb21pc2UpXG5dLCBPcGVuc2VhQWN0aW9uUHJvdmlkZXIucHJvdG90eXBlLCBcImdldE5mdHNCeUFjY291bnRcIiwgbnVsbCk7XG5jb25zdCBvcGVuc2VhQWN0aW9uUHJvdmlkZXIgPSAoY29uZmlnKSA9PiBuZXcgT3BlbnNlYUFjdGlvblByb3ZpZGVyKGNvbmZpZyk7XG5leHBvcnRzLm9wZW5zZWFBY3Rpb25Qcm92aWRlciA9IG9wZW5zZWFBY3Rpb25Qcm92aWRlcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/opensea/openseaActionProvider.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/opensea/schemas.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/opensea/schemas.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GetNftsByAccountSchema = exports.ListNftSchema = void 0;\nconst zod_1 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/lib/index.js\");\n/**\n * Input schema for listing an NFT on OpenSea.\n */\nexports.ListNftSchema = zod_1.z\n    .object({\n    contractAddress: zod_1.z.string().nonempty().describe(\"The NFT contract address to list\"),\n    tokenId: zod_1.z.string().nonempty().describe(\"The tokenID of the NFT to list\"),\n    price: zod_1.z.number().positive().describe(\"The price in ETH to list the NFT for\"),\n    expirationDays: zod_1.z\n        .number()\n        .positive()\n        .optional()\n        .default(90)\n        .describe(\"Number of days the listing should be active for (default: 90)\"),\n})\n    .strip()\n    .describe(\"Input schema for listing an NFT on OpenSea\");\n/**\n * Input schema for getting NFTs from a specific wallet address.\n */\nexports.GetNftsByAccountSchema = zod_1.z\n    .object({\n    accountAddress: zod_1.z\n        .string()\n        .optional()\n        .describe(\"The wallet address to fetch NFTs for (defaults to connected wallet if not provided)\"),\n})\n    .strip()\n    .describe(\"Input schema for fetching NFTs by account\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9vcGVuc2VhL3NjaGVtYXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsOEJBQThCLEdBQUcscUJBQXFCO0FBQ3RELGNBQWMsbUJBQU8sQ0FBQyxrREFBSztBQUMzQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXJ2aXZhbC1mdW4vLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9vcGVuc2VhL3NjaGVtYXMuanM/MzM3NyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuR2V0TmZ0c0J5QWNjb3VudFNjaGVtYSA9IGV4cG9ydHMuTGlzdE5mdFNjaGVtYSA9IHZvaWQgMDtcbmNvbnN0IHpvZF8xID0gcmVxdWlyZShcInpvZFwiKTtcbi8qKlxuICogSW5wdXQgc2NoZW1hIGZvciBsaXN0aW5nIGFuIE5GVCBvbiBPcGVuU2VhLlxuICovXG5leHBvcnRzLkxpc3ROZnRTY2hlbWEgPSB6b2RfMS56XG4gICAgLm9iamVjdCh7XG4gICAgY29udHJhY3RBZGRyZXNzOiB6b2RfMS56LnN0cmluZygpLm5vbmVtcHR5KCkuZGVzY3JpYmUoXCJUaGUgTkZUIGNvbnRyYWN0IGFkZHJlc3MgdG8gbGlzdFwiKSxcbiAgICB0b2tlbklkOiB6b2RfMS56LnN0cmluZygpLm5vbmVtcHR5KCkuZGVzY3JpYmUoXCJUaGUgdG9rZW5JRCBvZiB0aGUgTkZUIHRvIGxpc3RcIiksXG4gICAgcHJpY2U6IHpvZF8xLnoubnVtYmVyKCkucG9zaXRpdmUoKS5kZXNjcmliZShcIlRoZSBwcmljZSBpbiBFVEggdG8gbGlzdCB0aGUgTkZUIGZvclwiKSxcbiAgICBleHBpcmF0aW9uRGF5czogem9kXzEuelxuICAgICAgICAubnVtYmVyKClcbiAgICAgICAgLnBvc2l0aXZlKClcbiAgICAgICAgLm9wdGlvbmFsKClcbiAgICAgICAgLmRlZmF1bHQoOTApXG4gICAgICAgIC5kZXNjcmliZShcIk51bWJlciBvZiBkYXlzIHRoZSBsaXN0aW5nIHNob3VsZCBiZSBhY3RpdmUgZm9yIChkZWZhdWx0OiA5MClcIiksXG59KVxuICAgIC5zdHJpcCgpXG4gICAgLmRlc2NyaWJlKFwiSW5wdXQgc2NoZW1hIGZvciBsaXN0aW5nIGFuIE5GVCBvbiBPcGVuU2VhXCIpO1xuLyoqXG4gKiBJbnB1dCBzY2hlbWEgZm9yIGdldHRpbmcgTkZUcyBmcm9tIGEgc3BlY2lmaWMgd2FsbGV0IGFkZHJlc3MuXG4gKi9cbmV4cG9ydHMuR2V0TmZ0c0J5QWNjb3VudFNjaGVtYSA9IHpvZF8xLnpcbiAgICAub2JqZWN0KHtcbiAgICBhY2NvdW50QWRkcmVzczogem9kXzEuelxuICAgICAgICAuc3RyaW5nKClcbiAgICAgICAgLm9wdGlvbmFsKClcbiAgICAgICAgLmRlc2NyaWJlKFwiVGhlIHdhbGxldCBhZGRyZXNzIHRvIGZldGNoIE5GVHMgZm9yIChkZWZhdWx0cyB0byBjb25uZWN0ZWQgd2FsbGV0IGlmIG5vdCBwcm92aWRlZClcIiksXG59KVxuICAgIC5zdHJpcCgpXG4gICAgLmRlc2NyaWJlKFwiSW5wdXQgc2NoZW1hIGZvciBmZXRjaGluZyBORlRzIGJ5IGFjY291bnRcIik7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/opensea/schemas.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/opensea/utils.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/opensea/utils.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.chainIdToOpenseaChain = exports.supportedChains = void 0;\nconst opensea_js_1 = __webpack_require__(/*! opensea-js */ \"(rsc)/./node_modules/opensea-js/lib/index.js\");\n/**\n * Supported Opensea chains\n */\nexports.supportedChains = {\n    \"1\": opensea_js_1.Chain.Mainnet,\n    \"137\": opensea_js_1.Chain.Polygon,\n    \"80002\": opensea_js_1.Chain.Amoy,\n    \"11155111\": opensea_js_1.Chain.Sepolia,\n    \"8217\": opensea_js_1.Chain.Klaytn,\n    \"1001\": opensea_js_1.Chain.Baobab,\n    \"43114\": opensea_js_1.Chain.Avalanche,\n    \"43113\": opensea_js_1.Chain.Fuji,\n    \"42161\": opensea_js_1.Chain.Arbitrum,\n    \"42170\": opensea_js_1.Chain.ArbitrumNova,\n    \"421614\": opensea_js_1.Chain.ArbitrumSepolia,\n    \"238\": opensea_js_1.Chain.Blast,\n    \"168587773\": opensea_js_1.Chain.BlastSepolia,\n    \"8453\": opensea_js_1.Chain.Base,\n    \"84532\": opensea_js_1.Chain.BaseSepolia,\n    \"10\": opensea_js_1.Chain.Optimism,\n    \"11155420\": opensea_js_1.Chain.OptimismSepolia,\n    \"7777777\": opensea_js_1.Chain.Zora,\n    \"999999999\": opensea_js_1.Chain.ZoraSepolia,\n    \"1329\": opensea_js_1.Chain.Sei,\n    \"1328\": opensea_js_1.Chain.SeiTestnet,\n    \"8333\": opensea_js_1.Chain.B3,\n    \"1993\": opensea_js_1.Chain.B3Sepolia,\n    \"80094\": opensea_js_1.Chain.BeraChain,\n};\n/**\n * Maps EVM chain IDs to Opensea chain\n *\n * @param chainId - The EVM chain ID to map\n * @returns The corresponding OpenSea Chain enum value\n */\nconst chainIdToOpenseaChain = (chainId) => {\n    const chain = exports.supportedChains[chainId];\n    if (!chain) {\n        throw new Error(`Unsupported chain ID on Opensea: ${chainId}`);\n    }\n    return chain;\n};\nexports.chainIdToOpenseaChain = chainIdToOpenseaChain;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9vcGVuc2VhL3V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDZCQUE2QixHQUFHLHVCQUF1QjtBQUN2RCxxQkFBcUIsbUJBQU8sQ0FBQyxnRUFBWTtBQUN6QztBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsUUFBUTtBQUNwRTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXJ2aXZhbC1mdW4vLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9vcGVuc2VhL3V0aWxzLmpzPzVlYjIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNoYWluSWRUb09wZW5zZWFDaGFpbiA9IGV4cG9ydHMuc3VwcG9ydGVkQ2hhaW5zID0gdm9pZCAwO1xuY29uc3Qgb3BlbnNlYV9qc18xID0gcmVxdWlyZShcIm9wZW5zZWEtanNcIik7XG4vKipcbiAqIFN1cHBvcnRlZCBPcGVuc2VhIGNoYWluc1xuICovXG5leHBvcnRzLnN1cHBvcnRlZENoYWlucyA9IHtcbiAgICBcIjFcIjogb3BlbnNlYV9qc18xLkNoYWluLk1haW5uZXQsXG4gICAgXCIxMzdcIjogb3BlbnNlYV9qc18xLkNoYWluLlBvbHlnb24sXG4gICAgXCI4MDAwMlwiOiBvcGVuc2VhX2pzXzEuQ2hhaW4uQW1veSxcbiAgICBcIjExMTU1MTExXCI6IG9wZW5zZWFfanNfMS5DaGFpbi5TZXBvbGlhLFxuICAgIFwiODIxN1wiOiBvcGVuc2VhX2pzXzEuQ2hhaW4uS2xheXRuLFxuICAgIFwiMTAwMVwiOiBvcGVuc2VhX2pzXzEuQ2hhaW4uQmFvYmFiLFxuICAgIFwiNDMxMTRcIjogb3BlbnNlYV9qc18xLkNoYWluLkF2YWxhbmNoZSxcbiAgICBcIjQzMTEzXCI6IG9wZW5zZWFfanNfMS5DaGFpbi5GdWppLFxuICAgIFwiNDIxNjFcIjogb3BlbnNlYV9qc18xLkNoYWluLkFyYml0cnVtLFxuICAgIFwiNDIxNzBcIjogb3BlbnNlYV9qc18xLkNoYWluLkFyYml0cnVtTm92YSxcbiAgICBcIjQyMTYxNFwiOiBvcGVuc2VhX2pzXzEuQ2hhaW4uQXJiaXRydW1TZXBvbGlhLFxuICAgIFwiMjM4XCI6IG9wZW5zZWFfanNfMS5DaGFpbi5CbGFzdCxcbiAgICBcIjE2ODU4Nzc3M1wiOiBvcGVuc2VhX2pzXzEuQ2hhaW4uQmxhc3RTZXBvbGlhLFxuICAgIFwiODQ1M1wiOiBvcGVuc2VhX2pzXzEuQ2hhaW4uQmFzZSxcbiAgICBcIjg0NTMyXCI6IG9wZW5zZWFfanNfMS5DaGFpbi5CYXNlU2Vwb2xpYSxcbiAgICBcIjEwXCI6IG9wZW5zZWFfanNfMS5DaGFpbi5PcHRpbWlzbSxcbiAgICBcIjExMTU1NDIwXCI6IG9wZW5zZWFfanNfMS5DaGFpbi5PcHRpbWlzbVNlcG9saWEsXG4gICAgXCI3Nzc3Nzc3XCI6IG9wZW5zZWFfanNfMS5DaGFpbi5ab3JhLFxuICAgIFwiOTk5OTk5OTk5XCI6IG9wZW5zZWFfanNfMS5DaGFpbi5ab3JhU2Vwb2xpYSxcbiAgICBcIjEzMjlcIjogb3BlbnNlYV9qc18xLkNoYWluLlNlaSxcbiAgICBcIjEzMjhcIjogb3BlbnNlYV9qc18xLkNoYWluLlNlaVRlc3RuZXQsXG4gICAgXCI4MzMzXCI6IG9wZW5zZWFfanNfMS5DaGFpbi5CMyxcbiAgICBcIjE5OTNcIjogb3BlbnNlYV9qc18xLkNoYWluLkIzU2Vwb2xpYSxcbiAgICBcIjgwMDk0XCI6IG9wZW5zZWFfanNfMS5DaGFpbi5CZXJhQ2hhaW4sXG59O1xuLyoqXG4gKiBNYXBzIEVWTSBjaGFpbiBJRHMgdG8gT3BlbnNlYSBjaGFpblxuICpcbiAqIEBwYXJhbSBjaGFpbklkIC0gVGhlIEVWTSBjaGFpbiBJRCB0byBtYXBcbiAqIEByZXR1cm5zIFRoZSBjb3JyZXNwb25kaW5nIE9wZW5TZWEgQ2hhaW4gZW51bSB2YWx1ZVxuICovXG5jb25zdCBjaGFpbklkVG9PcGVuc2VhQ2hhaW4gPSAoY2hhaW5JZCkgPT4ge1xuICAgIGNvbnN0IGNoYWluID0gZXhwb3J0cy5zdXBwb3J0ZWRDaGFpbnNbY2hhaW5JZF07XG4gICAgaWYgKCFjaGFpbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGNoYWluIElEIG9uIE9wZW5zZWE6ICR7Y2hhaW5JZH1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGNoYWluO1xufTtcbmV4cG9ydHMuY2hhaW5JZFRvT3BlbnNlYUNoYWluID0gY2hhaW5JZFRvT3BlbnNlYUNoYWluO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/opensea/utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/pyth/index.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/pyth/index.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./pythActionProvider */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/pyth/pythActionProvider.js\"), exports);\n__exportStar(__webpack_require__(/*! ./schemas */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/pyth/schemas.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9weXRoL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWEsbUJBQU8sQ0FBQyxzSEFBc0I7QUFDM0MsYUFBYSxtQkFBTyxDQUFDLGdHQUFXIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3Vydml2YWwtZnVuLy4vbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9hZ2VudGtpdC9kaXN0L2FjdGlvbi1wcm92aWRlcnMvcHl0aC9pbmRleC5qcz8wZDI1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vcHl0aEFjdGlvblByb3ZpZGVyXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9zY2hlbWFzXCIpLCBleHBvcnRzKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/pyth/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/pyth/pythActionProvider.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/pyth/pythActionProvider.js ***!
  \******************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.pythActionProvider = exports.PythActionProvider = void 0;\nconst zod_1 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/lib/index.js\");\nconst actionProvider_1 = __webpack_require__(/*! ../actionProvider */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/actionProvider.js\");\nconst actionDecorator_1 = __webpack_require__(/*! ../actionDecorator */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/actionDecorator.js\");\nconst schemas_1 = __webpack_require__(/*! ./schemas */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/pyth/schemas.js\");\n/**\n * PythActionProvider is an action provider for Pyth.\n */\nclass PythActionProvider extends actionProvider_1.ActionProvider {\n    /**\n     * Constructs a new PythActionProvider.\n     */\n    constructor() {\n        super(\"pyth\", []);\n        /**\n         * Checks if the Pyth action provider supports the given network.\n         *\n         * @returns True if the Pyth action provider supports the network, false otherwise.\n         */\n        this.supportsNetwork = () => true;\n    }\n    /**\n     * Fetch the price feed ID for a given token symbol from Pyth.\n     *\n     * @param args - The arguments for the action.\n     * @returns The price feed ID as a string.\n     */\n    async fetchPriceFeed(args) {\n        const url = `https://hermes.pyth.network/v2/price_feeds?query=${args.tokenSymbol}&asset_type=crypto`;\n        const response = await fetch(url);\n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        const data = await response.json();\n        if (data.length === 0) {\n            throw new Error(`No price feed found for ${args.tokenSymbol}`);\n        }\n        const filteredData = data.filter(\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        (item) => item.attributes.base.toLowerCase() === args.tokenSymbol.toLowerCase());\n        if (filteredData.length === 0) {\n            throw new Error(`No price feed found for ${args.tokenSymbol}`);\n        }\n        return filteredData[0].id;\n    }\n    /**\n     * Fetches the price from Pyth given a Pyth price feed ID.\n     *\n     * @param args - The arguments for the action.\n     * @returns The price as a string.\n     */\n    async fetchPrice(args) {\n        const url = `https://hermes.pyth.network/v2/updates/price/latest?ids[]=${args.priceFeedID}`;\n        const response = await fetch(url);\n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        const data = await response.json();\n        const parsedData = data.parsed;\n        if (parsedData.length === 0) {\n            throw new Error(`No price data found for ${args.priceFeedID}`);\n        }\n        const priceInfo = parsedData[0].price;\n        const price = BigInt(priceInfo.price);\n        const exponent = priceInfo.expo;\n        if (exponent < 0) {\n            const adjustedPrice = price * BigInt(100);\n            const divisor = BigInt(10) ** BigInt(-exponent);\n            const scaledPrice = adjustedPrice / BigInt(divisor);\n            const priceStr = scaledPrice.toString();\n            const formattedPrice = `${priceStr.slice(0, -2)}.${priceStr.slice(-2)}`;\n            return formattedPrice.startsWith(\".\") ? `0${formattedPrice}` : formattedPrice;\n        }\n        const scaledPrice = price / BigInt(10) ** BigInt(exponent);\n        return scaledPrice.toString();\n    }\n}\nexports.PythActionProvider = PythActionProvider;\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"fetch_price_feed\",\n        description: \"Fetch the price feed ID for a given token symbol from Pyth.\",\n        schema: schemas_1.PythFetchPriceFeedIDSchema,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [void 0]),\n    __metadata(\"design:returntype\", Promise)\n], PythActionProvider.prototype, \"fetchPriceFeed\", null);\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"fetch_price\",\n        description: `Fetch the price of a given price feed from Pyth.\n\nInputs:\n- Pyth price feed ID\n\nImportant notes:\n- Do not assume that a random ID is a Pyth price feed ID. If you are confused, ask a clarifying question.\n- This action only fetches price inputs from Pyth price feeds. No other source.\n- If you are asked to fetch the price from Pyth for a ticker symbol such as BTC, you must first use the pyth_fetch_price_feed_id\naction to retrieve the price feed ID before invoking the pyth_Fetch_price action\n`,\n        schema: schemas_1.PythFetchPriceSchema,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [void 0]),\n    __metadata(\"design:returntype\", Promise)\n], PythActionProvider.prototype, \"fetchPrice\", null);\nconst pythActionProvider = () => new PythActionProvider();\nexports.pythActionProvider = pythActionProvider;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9weXRoL3B5dGhBY3Rpb25Qcm92aWRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxRQUFRO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMEJBQTBCLEdBQUcsMEJBQTBCO0FBQ3ZELGNBQWMsbUJBQU8sQ0FBQyxrREFBSztBQUMzQix5QkFBeUIsbUJBQU8sQ0FBQywwR0FBbUI7QUFDcEQsMEJBQTBCLG1CQUFPLENBQUMsNEdBQW9CO0FBQ3RELGtCQUFrQixtQkFBTyxDQUFDLGdHQUFXO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsaUJBQWlCO0FBQ3pGO0FBQ0E7QUFDQSxtREFBbUQsZ0JBQWdCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxpQkFBaUI7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxpQkFBaUI7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUYsaUJBQWlCO0FBQ2xHO0FBQ0E7QUFDQSxtREFBbUQsZ0JBQWdCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELGlCQUFpQjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msc0JBQXNCLEdBQUcsbUJBQW1CO0FBQ2xGLHdEQUF3RCxlQUFlO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cnZpdmFsLWZ1bi8uL25vZGVfbW9kdWxlcy9AY29pbmJhc2UvYWdlbnRraXQvZGlzdC9hY3Rpb24tcHJvdmlkZXJzL3B5dGgvcHl0aEFjdGlvblByb3ZpZGVyLmpzPzNjY2UiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5weXRoQWN0aW9uUHJvdmlkZXIgPSBleHBvcnRzLlB5dGhBY3Rpb25Qcm92aWRlciA9IHZvaWQgMDtcbmNvbnN0IHpvZF8xID0gcmVxdWlyZShcInpvZFwiKTtcbmNvbnN0IGFjdGlvblByb3ZpZGVyXzEgPSByZXF1aXJlKFwiLi4vYWN0aW9uUHJvdmlkZXJcIik7XG5jb25zdCBhY3Rpb25EZWNvcmF0b3JfMSA9IHJlcXVpcmUoXCIuLi9hY3Rpb25EZWNvcmF0b3JcIik7XG5jb25zdCBzY2hlbWFzXzEgPSByZXF1aXJlKFwiLi9zY2hlbWFzXCIpO1xuLyoqXG4gKiBQeXRoQWN0aW9uUHJvdmlkZXIgaXMgYW4gYWN0aW9uIHByb3ZpZGVyIGZvciBQeXRoLlxuICovXG5jbGFzcyBQeXRoQWN0aW9uUHJvdmlkZXIgZXh0ZW5kcyBhY3Rpb25Qcm92aWRlcl8xLkFjdGlvblByb3ZpZGVyIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IFB5dGhBY3Rpb25Qcm92aWRlci5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoXCJweXRoXCIsIFtdKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrcyBpZiB0aGUgUHl0aCBhY3Rpb24gcHJvdmlkZXIgc3VwcG9ydHMgdGhlIGdpdmVuIG5ldHdvcmsuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIFB5dGggYWN0aW9uIHByb3ZpZGVyIHN1cHBvcnRzIHRoZSBuZXR3b3JrLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN1cHBvcnRzTmV0d29yayA9ICgpID0+IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoIHRoZSBwcmljZSBmZWVkIElEIGZvciBhIGdpdmVuIHRva2VuIHN5bWJvbCBmcm9tIFB5dGguXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXJncyAtIFRoZSBhcmd1bWVudHMgZm9yIHRoZSBhY3Rpb24uXG4gICAgICogQHJldHVybnMgVGhlIHByaWNlIGZlZWQgSUQgYXMgYSBzdHJpbmcuXG4gICAgICovXG4gICAgYXN5bmMgZmV0Y2hQcmljZUZlZWQoYXJncykge1xuICAgICAgICBjb25zdCB1cmwgPSBgaHR0cHM6Ly9oZXJtZXMucHl0aC5uZXR3b3JrL3YyL3ByaWNlX2ZlZWRzP3F1ZXJ5PSR7YXJncy50b2tlblN5bWJvbH0mYXNzZXRfdHlwZT1jcnlwdG9gO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCk7XG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCBlcnJvciEgc3RhdHVzOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICBpZiAoZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gcHJpY2UgZmVlZCBmb3VuZCBmb3IgJHthcmdzLnRva2VuU3ltYm9sfWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZpbHRlcmVkRGF0YSA9IGRhdGEuZmlsdGVyKFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAoaXRlbSkgPT4gaXRlbS5hdHRyaWJ1dGVzLmJhc2UudG9Mb3dlckNhc2UoKSA9PT0gYXJncy50b2tlblN5bWJvbC50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgaWYgKGZpbHRlcmVkRGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gcHJpY2UgZmVlZCBmb3VuZCBmb3IgJHthcmdzLnRva2VuU3ltYm9sfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaWx0ZXJlZERhdGFbMF0uaWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoZXMgdGhlIHByaWNlIGZyb20gUHl0aCBnaXZlbiBhIFB5dGggcHJpY2UgZmVlZCBJRC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhcmdzIC0gVGhlIGFyZ3VtZW50cyBmb3IgdGhlIGFjdGlvbi5cbiAgICAgKiBAcmV0dXJucyBUaGUgcHJpY2UgYXMgYSBzdHJpbmcuXG4gICAgICovXG4gICAgYXN5bmMgZmV0Y2hQcmljZShhcmdzKSB7XG4gICAgICAgIGNvbnN0IHVybCA9IGBodHRwczovL2hlcm1lcy5weXRoLm5ldHdvcmsvdjIvdXBkYXRlcy9wcmljZS9sYXRlc3Q/aWRzW109JHthcmdzLnByaWNlRmVlZElEfWA7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsKTtcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBIVFRQIGVycm9yISBzdGF0dXM6ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIGNvbnN0IHBhcnNlZERhdGEgPSBkYXRhLnBhcnNlZDtcbiAgICAgICAgaWYgKHBhcnNlZERhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIHByaWNlIGRhdGEgZm91bmQgZm9yICR7YXJncy5wcmljZUZlZWRJRH1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmljZUluZm8gPSBwYXJzZWREYXRhWzBdLnByaWNlO1xuICAgICAgICBjb25zdCBwcmljZSA9IEJpZ0ludChwcmljZUluZm8ucHJpY2UpO1xuICAgICAgICBjb25zdCBleHBvbmVudCA9IHByaWNlSW5mby5leHBvO1xuICAgICAgICBpZiAoZXhwb25lbnQgPCAwKSB7XG4gICAgICAgICAgICBjb25zdCBhZGp1c3RlZFByaWNlID0gcHJpY2UgKiBCaWdJbnQoMTAwKTtcbiAgICAgICAgICAgIGNvbnN0IGRpdmlzb3IgPSBCaWdJbnQoMTApICoqIEJpZ0ludCgtZXhwb25lbnQpO1xuICAgICAgICAgICAgY29uc3Qgc2NhbGVkUHJpY2UgPSBhZGp1c3RlZFByaWNlIC8gQmlnSW50KGRpdmlzb3IpO1xuICAgICAgICAgICAgY29uc3QgcHJpY2VTdHIgPSBzY2FsZWRQcmljZS50b1N0cmluZygpO1xuICAgICAgICAgICAgY29uc3QgZm9ybWF0dGVkUHJpY2UgPSBgJHtwcmljZVN0ci5zbGljZSgwLCAtMil9LiR7cHJpY2VTdHIuc2xpY2UoLTIpfWA7XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0dGVkUHJpY2Uuc3RhcnRzV2l0aChcIi5cIikgPyBgMCR7Zm9ybWF0dGVkUHJpY2V9YCA6IGZvcm1hdHRlZFByaWNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNjYWxlZFByaWNlID0gcHJpY2UgLyBCaWdJbnQoMTApICoqIEJpZ0ludChleHBvbmVudCk7XG4gICAgICAgIHJldHVybiBzY2FsZWRQcmljZS50b1N0cmluZygpO1xuICAgIH1cbn1cbmV4cG9ydHMuUHl0aEFjdGlvblByb3ZpZGVyID0gUHl0aEFjdGlvblByb3ZpZGVyO1xuX19kZWNvcmF0ZShbXG4gICAgKDAsIGFjdGlvbkRlY29yYXRvcl8xLkNyZWF0ZUFjdGlvbikoe1xuICAgICAgICBuYW1lOiBcImZldGNoX3ByaWNlX2ZlZWRcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiRmV0Y2ggdGhlIHByaWNlIGZlZWQgSUQgZm9yIGEgZ2l2ZW4gdG9rZW4gc3ltYm9sIGZyb20gUHl0aC5cIixcbiAgICAgICAgc2NoZW1hOiBzY2hlbWFzXzEuUHl0aEZldGNoUHJpY2VGZWVkSURTY2hlbWEsXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW3ZvaWQgMF0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCBQcm9taXNlKVxuXSwgUHl0aEFjdGlvblByb3ZpZGVyLnByb3RvdHlwZSwgXCJmZXRjaFByaWNlRmVlZFwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgICgwLCBhY3Rpb25EZWNvcmF0b3JfMS5DcmVhdGVBY3Rpb24pKHtcbiAgICAgICAgbmFtZTogXCJmZXRjaF9wcmljZVwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogYEZldGNoIHRoZSBwcmljZSBvZiBhIGdpdmVuIHByaWNlIGZlZWQgZnJvbSBQeXRoLlxuXG5JbnB1dHM6XG4tIFB5dGggcHJpY2UgZmVlZCBJRFxuXG5JbXBvcnRhbnQgbm90ZXM6XG4tIERvIG5vdCBhc3N1bWUgdGhhdCBhIHJhbmRvbSBJRCBpcyBhIFB5dGggcHJpY2UgZmVlZCBJRC4gSWYgeW91IGFyZSBjb25mdXNlZCwgYXNrIGEgY2xhcmlmeWluZyBxdWVzdGlvbi5cbi0gVGhpcyBhY3Rpb24gb25seSBmZXRjaGVzIHByaWNlIGlucHV0cyBmcm9tIFB5dGggcHJpY2UgZmVlZHMuIE5vIG90aGVyIHNvdXJjZS5cbi0gSWYgeW91IGFyZSBhc2tlZCB0byBmZXRjaCB0aGUgcHJpY2UgZnJvbSBQeXRoIGZvciBhIHRpY2tlciBzeW1ib2wgc3VjaCBhcyBCVEMsIHlvdSBtdXN0IGZpcnN0IHVzZSB0aGUgcHl0aF9mZXRjaF9wcmljZV9mZWVkX2lkXG5hY3Rpb24gdG8gcmV0cmlldmUgdGhlIHByaWNlIGZlZWQgSUQgYmVmb3JlIGludm9raW5nIHRoZSBweXRoX0ZldGNoX3ByaWNlIGFjdGlvblxuYCxcbiAgICAgICAgc2NoZW1hOiBzY2hlbWFzXzEuUHl0aEZldGNoUHJpY2VTY2hlbWEsXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW3ZvaWQgMF0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCBQcm9taXNlKVxuXSwgUHl0aEFjdGlvblByb3ZpZGVyLnByb3RvdHlwZSwgXCJmZXRjaFByaWNlXCIsIG51bGwpO1xuY29uc3QgcHl0aEFjdGlvblByb3ZpZGVyID0gKCkgPT4gbmV3IFB5dGhBY3Rpb25Qcm92aWRlcigpO1xuZXhwb3J0cy5weXRoQWN0aW9uUHJvdmlkZXIgPSBweXRoQWN0aW9uUHJvdmlkZXI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/pyth/pythActionProvider.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/pyth/schemas.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/pyth/schemas.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PythFetchPriceSchema = exports.PythFetchPriceFeedIDSchema = void 0;\nconst zod_1 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/lib/index.js\");\n/**\n * Input schema for Pyth fetch price feed ID action.\n */\nexports.PythFetchPriceFeedIDSchema = zod_1.z\n    .object({\n    tokenSymbol: zod_1.z.string().describe(\"The token symbol to fetch the price feed ID for\"),\n})\n    .strict();\n/**\n * Input schema for Pyth fetch price action.\n */\nexports.PythFetchPriceSchema = zod_1.z\n    .object({\n    priceFeedID: zod_1.z.string().describe(\"The price feed ID to fetch the price for\"),\n})\n    .strict();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9weXRoL3NjaGVtYXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNEJBQTRCLEdBQUcsa0NBQWtDO0FBQ2pFLGNBQWMsbUJBQU8sQ0FBQyxrREFBSztBQUMzQjtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0EsQ0FBQztBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3Vydml2YWwtZnVuLy4vbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9hZ2VudGtpdC9kaXN0L2FjdGlvbi1wcm92aWRlcnMvcHl0aC9zY2hlbWFzLmpzPzdmZmMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlB5dGhGZXRjaFByaWNlU2NoZW1hID0gZXhwb3J0cy5QeXRoRmV0Y2hQcmljZUZlZWRJRFNjaGVtYSA9IHZvaWQgMDtcbmNvbnN0IHpvZF8xID0gcmVxdWlyZShcInpvZFwiKTtcbi8qKlxuICogSW5wdXQgc2NoZW1hIGZvciBQeXRoIGZldGNoIHByaWNlIGZlZWQgSUQgYWN0aW9uLlxuICovXG5leHBvcnRzLlB5dGhGZXRjaFByaWNlRmVlZElEU2NoZW1hID0gem9kXzEuelxuICAgIC5vYmplY3Qoe1xuICAgIHRva2VuU3ltYm9sOiB6b2RfMS56LnN0cmluZygpLmRlc2NyaWJlKFwiVGhlIHRva2VuIHN5bWJvbCB0byBmZXRjaCB0aGUgcHJpY2UgZmVlZCBJRCBmb3JcIiksXG59KVxuICAgIC5zdHJpY3QoKTtcbi8qKlxuICogSW5wdXQgc2NoZW1hIGZvciBQeXRoIGZldGNoIHByaWNlIGFjdGlvbi5cbiAqL1xuZXhwb3J0cy5QeXRoRmV0Y2hQcmljZVNjaGVtYSA9IHpvZF8xLnpcbiAgICAub2JqZWN0KHtcbiAgICBwcmljZUZlZWRJRDogem9kXzEuei5zdHJpbmcoKS5kZXNjcmliZShcIlRoZSBwcmljZSBmZWVkIElEIHRvIGZldGNoIHRoZSBwcmljZSBmb3JcIiksXG59KVxuICAgIC5zdHJpY3QoKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/pyth/schemas.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/spl/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/spl/index.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./splActionProvider */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/spl/splActionProvider.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9zcGwvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYSxtQkFBTyxDQUFDLG1IQUFxQiIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cnZpdmFsLWZ1bi8uL25vZGVfbW9kdWxlcy9AY29pbmJhc2UvYWdlbnRraXQvZGlzdC9hY3Rpb24tcHJvdmlkZXJzL3NwbC9pbmRleC5qcz8yZGNhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc3BsQWN0aW9uUHJvdmlkZXJcIiksIGV4cG9ydHMpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/spl/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/spl/schemas.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/spl/schemas.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GetBalanceSchema = exports.TransferTokenSchema = void 0;\nconst zod_1 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/lib/index.js\");\n/**\n * Schema for transferring SPL tokens to another address.\n */\nexports.TransferTokenSchema = zod_1.z\n    .object({\n    recipient: zod_1.z.string().describe(\"The recipient's Solana address\"),\n    mintAddress: zod_1.z.string().describe(\"The SPL token's mint address\"),\n    amount: zod_1.z.number().positive().describe(\"Amount of tokens to transfer\"),\n})\n    .describe(\"Transfer SPL tokens to another Solana address\");\n/**\n * Schema for getting SPL token balance.\n */\nexports.GetBalanceSchema = zod_1.z\n    .object({\n    mintAddress: zod_1.z.string().describe(\"The SPL token's mint address\"),\n    address: zod_1.z\n        .string()\n        .optional()\n        .describe(\"Optional address to check balance for. If not provided, uses the wallet's address\"),\n})\n    .describe(\"Get SPL token balance for an address\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9zcGwvc2NoZW1hcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx3QkFBd0IsR0FBRywyQkFBMkI7QUFDdEQsY0FBYyxtQkFBTyxDQUFDLGtEQUFLO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXJ2aXZhbC1mdW4vLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9zcGwvc2NoZW1hcy5qcz84MTRkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5HZXRCYWxhbmNlU2NoZW1hID0gZXhwb3J0cy5UcmFuc2ZlclRva2VuU2NoZW1hID0gdm9pZCAwO1xuY29uc3Qgem9kXzEgPSByZXF1aXJlKFwiem9kXCIpO1xuLyoqXG4gKiBTY2hlbWEgZm9yIHRyYW5zZmVycmluZyBTUEwgdG9rZW5zIHRvIGFub3RoZXIgYWRkcmVzcy5cbiAqL1xuZXhwb3J0cy5UcmFuc2ZlclRva2VuU2NoZW1hID0gem9kXzEuelxuICAgIC5vYmplY3Qoe1xuICAgIHJlY2lwaWVudDogem9kXzEuei5zdHJpbmcoKS5kZXNjcmliZShcIlRoZSByZWNpcGllbnQncyBTb2xhbmEgYWRkcmVzc1wiKSxcbiAgICBtaW50QWRkcmVzczogem9kXzEuei5zdHJpbmcoKS5kZXNjcmliZShcIlRoZSBTUEwgdG9rZW4ncyBtaW50IGFkZHJlc3NcIiksXG4gICAgYW1vdW50OiB6b2RfMS56Lm51bWJlcigpLnBvc2l0aXZlKCkuZGVzY3JpYmUoXCJBbW91bnQgb2YgdG9rZW5zIHRvIHRyYW5zZmVyXCIpLFxufSlcbiAgICAuZGVzY3JpYmUoXCJUcmFuc2ZlciBTUEwgdG9rZW5zIHRvIGFub3RoZXIgU29sYW5hIGFkZHJlc3NcIik7XG4vKipcbiAqIFNjaGVtYSBmb3IgZ2V0dGluZyBTUEwgdG9rZW4gYmFsYW5jZS5cbiAqL1xuZXhwb3J0cy5HZXRCYWxhbmNlU2NoZW1hID0gem9kXzEuelxuICAgIC5vYmplY3Qoe1xuICAgIG1pbnRBZGRyZXNzOiB6b2RfMS56LnN0cmluZygpLmRlc2NyaWJlKFwiVGhlIFNQTCB0b2tlbidzIG1pbnQgYWRkcmVzc1wiKSxcbiAgICBhZGRyZXNzOiB6b2RfMS56XG4gICAgICAgIC5zdHJpbmcoKVxuICAgICAgICAub3B0aW9uYWwoKVxuICAgICAgICAuZGVzY3JpYmUoXCJPcHRpb25hbCBhZGRyZXNzIHRvIGNoZWNrIGJhbGFuY2UgZm9yLiBJZiBub3QgcHJvdmlkZWQsIHVzZXMgdGhlIHdhbGxldCdzIGFkZHJlc3NcIiksXG59KVxuICAgIC5kZXNjcmliZShcIkdldCBTUEwgdG9rZW4gYmFsYW5jZSBmb3IgYW4gYWRkcmVzc1wiKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/spl/schemas.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/spl/splActionProvider.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/spl/splActionProvider.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.splActionProvider = exports.SplActionProvider = void 0;\nconst actionProvider_1 = __webpack_require__(/*! ../actionProvider */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/actionProvider.js\");\nconst svmWalletProvider_1 = __webpack_require__(/*! ../../wallet-providers/svmWalletProvider */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/wallet-providers/svmWalletProvider.js\");\nconst zod_1 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/lib/index.js\");\nconst actionDecorator_1 = __webpack_require__(/*! ../actionDecorator */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/actionDecorator.js\");\nconst schemas_1 = __webpack_require__(/*! ./schemas */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/spl/schemas.js\");\nconst web3_js_1 = __webpack_require__(/*! @solana/web3.js */ \"(rsc)/./node_modules/@solana/web3.js/lib/index.esm.js\");\n/**\n * SplActionProvider serves as a provider for SPL token actions.\n * It provides SPL token transfer functionality.\n */\nclass SplActionProvider extends actionProvider_1.ActionProvider {\n    /**\n     * Creates a new SplActionProvider instance.\n     */\n    constructor() {\n        super(\"spl\", []);\n    }\n    /**\n     * Get the balance of SPL tokens for an address.\n     *\n     * @param walletProvider - The wallet provider to use\n     * @param args - Parameters including mint address and optional target address\n     * @returns A message indicating the token balance\n     */\n    async getBalance(walletProvider, args) {\n        try {\n            if (!args.address) {\n                args.address = walletProvider.getAddress();\n            }\n            const connection = walletProvider.getConnection();\n            const mintPubkey = new web3_js_1.PublicKey(args.mintAddress);\n            const ownerPubkey = new web3_js_1.PublicKey(args.address);\n            const { getMint, getAssociatedTokenAddress, getAccount, TokenAccountNotFoundError } = await Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/@solana\"), __webpack_require__.e(\"vendor-chunks/bignumber.js\"), __webpack_require__.e(\"vendor-chunks/file-uri-to-path\"), __webpack_require__.e(\"vendor-chunks/bindings\"), __webpack_require__.e(\"vendor-chunks/bigint-buffer\")]).then(__webpack_require__.bind(__webpack_require__, /*! @solana/spl-token */ \"(rsc)/./node_modules/@solana/spl-token/lib/esm/index.js\"));\n            let mintInfo;\n            try {\n                mintInfo = await getMint(connection, mintPubkey);\n            }\n            catch (error) {\n                return `Failed to fetch mint info for mint address ${args.mintAddress}. Error: ${error}`;\n            }\n            try {\n                const ata = await getAssociatedTokenAddress(mintPubkey, ownerPubkey);\n                const account = await getAccount(connection, ata);\n                const balance = Number(account.amount) / Math.pow(10, mintInfo.decimals);\n                return `Balance for ${args.address} is ${balance} tokens`;\n            }\n            catch (error) {\n                if (error instanceof TokenAccountNotFoundError) {\n                    return `Balance for ${args.address} is 0 tokens`;\n                }\n                throw error;\n            }\n        }\n        catch (error) {\n            return `Error getting SPL token balance: ${error}`;\n        }\n    }\n    /**\n     * Transfer SPL tokens to another address.\n     *\n     * @param walletProvider - The wallet provider to use for the transfer\n     * @param args - Transfer parameters including recipient address, mint address, and amount\n     * @returns A message indicating success or failure with transaction details\n     */\n    async transfer(walletProvider, args) {\n        try {\n            const connection = walletProvider.getConnection();\n            const fromPubkey = walletProvider.getPublicKey();\n            const toPubkey = new web3_js_1.PublicKey(args.recipient);\n            const mintPubkey = new web3_js_1.PublicKey(args.mintAddress);\n            const { getMint, getAssociatedTokenAddress, getAccount, createAssociatedTokenAccountInstruction, createTransferCheckedInstruction, } = await Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/@solana\"), __webpack_require__.e(\"vendor-chunks/bignumber.js\"), __webpack_require__.e(\"vendor-chunks/file-uri-to-path\"), __webpack_require__.e(\"vendor-chunks/bindings\"), __webpack_require__.e(\"vendor-chunks/bigint-buffer\")]).then(__webpack_require__.bind(__webpack_require__, /*! @solana/spl-token */ \"(rsc)/./node_modules/@solana/spl-token/lib/esm/index.js\"));\n            let mintInfo;\n            try {\n                mintInfo = await getMint(connection, mintPubkey);\n            }\n            catch (error) {\n                return `Failed to fetch mint info for mint address ${args.mintAddress}. Error: ${error}`;\n            }\n            const adjustedAmount = args.amount * Math.pow(10, mintInfo.decimals);\n            const sourceAta = await getAssociatedTokenAddress(mintPubkey, fromPubkey);\n            const destinationAta = await getAssociatedTokenAddress(mintPubkey, toPubkey);\n            const instructions = [];\n            const sourceAccount = await getAccount(connection, sourceAta);\n            if (sourceAccount.amount < BigInt(adjustedAmount)) {\n                throw new Error(`Insufficient token balance. Have ${sourceAccount.amount}, need ${adjustedAmount}`);\n            }\n            try {\n                await getAccount(connection, destinationAta);\n            }\n            catch {\n                instructions.push(createAssociatedTokenAccountInstruction(fromPubkey, destinationAta, toPubkey, mintPubkey));\n            }\n            instructions.push(createTransferCheckedInstruction(sourceAta, mintPubkey, destinationAta, fromPubkey, adjustedAmount, mintInfo.decimals));\n            const tx = new web3_js_1.VersionedTransaction(web3_js_1.MessageV0.compile({\n                payerKey: fromPubkey,\n                instructions: instructions,\n                recentBlockhash: (await connection.getLatestBlockhash()).blockhash,\n            }));\n            const signature = await walletProvider.signAndSendTransaction(tx);\n            await walletProvider.waitForSignatureResult(signature);\n            return [\n                `Successfully transferred ${args.amount} tokens to ${args.recipient}`,\n                `Token mint: ${args.mintAddress}`,\n                `Signature: ${signature}`,\n            ].join(\"\\n\");\n        }\n        catch (error) {\n            return `Error transferring SPL tokens: ${error}`;\n        }\n    }\n    /**\n     * Checks if the action provider supports the given network.\n     * Only supports Solana networks.\n     *\n     * @param network - The network to check support for\n     * @returns True if the network is a Solana network\n     */\n    supportsNetwork(network) {\n        return network.protocolFamily === \"svm\";\n    }\n}\nexports.SplActionProvider = SplActionProvider;\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"get_balance\",\n        description: `\n    This tool will get the balance of SPL tokens for an address.\n    - Mint address must be a valid SPL token mint\n    - If no address is provided, uses the connected wallet's address\n    - Returns the token balance in token units (not raw)\n    `,\n        schema: schemas_1.GetBalanceSchema,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [svmWalletProvider_1.SvmWalletProvider, void 0]),\n    __metadata(\"design:returntype\", Promise)\n], SplActionProvider.prototype, \"getBalance\", null);\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"transfer\",\n        description: `\n    This tool will transfer SPL tokens to another address.\n    - Amount should be specified in token units (not raw)\n    - Recipient must be a valid Solana address\n    - Mint address must be a valid SPL token mint\n    - Ensures sufficient token balance before transfer\n    - Returns transaction details\n    `,\n        schema: schemas_1.TransferTokenSchema,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [svmWalletProvider_1.SvmWalletProvider, void 0]),\n    __metadata(\"design:returntype\", Promise)\n], SplActionProvider.prototype, \"transfer\", null);\n/**\n * Factory function to create a new SplActionProvider instance.\n *\n * @returns A new SplActionProvider instance\n */\nconst splActionProvider = () => new SplActionProvider();\nexports.splActionProvider = splActionProvider;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy9zcGwvc3BsQWN0aW9uUHJvdmlkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsUUFBUTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHlCQUF5QixHQUFHLHlCQUF5QjtBQUNyRCx5QkFBeUIsbUJBQU8sQ0FBQywwR0FBbUI7QUFDcEQsNEJBQTRCLG1CQUFPLENBQUMsb0lBQTBDO0FBQzlFLGNBQWMsbUJBQU8sQ0FBQyxrREFBSztBQUMzQiwwQkFBMEIsbUJBQU8sQ0FBQyw0R0FBb0I7QUFDdEQsa0JBQWtCLG1CQUFPLENBQUMsK0ZBQVc7QUFDckMsa0JBQWtCLG1CQUFPLENBQUMsOEVBQWlCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNEVBQTRFLFFBQVEseWFBQTJCO0FBQ25JO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsaUJBQWlCLFdBQVcsTUFBTTtBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGNBQWMsS0FBSyxTQUFTO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxjQUFjO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsTUFBTTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNkhBQTZILFFBQVEseWFBQTJCO0FBQ3BMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsaUJBQWlCLFdBQVcsTUFBTTtBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxxQkFBcUIsU0FBUyxlQUFlO0FBQ2pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsYUFBYSxZQUFZLGVBQWU7QUFDcEYsK0JBQStCLGlCQUFpQjtBQUNoRCw4QkFBOEIsVUFBVTtBQUN4QztBQUNBO0FBQ0E7QUFDQSxxREFBcUQsTUFBTTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QiIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cnZpdmFsLWZ1bi8uL25vZGVfbW9kdWxlcy9AY29pbmJhc2UvYWdlbnRraXQvZGlzdC9hY3Rpb24tcHJvdmlkZXJzL3NwbC9zcGxBY3Rpb25Qcm92aWRlci5qcz9mNmRkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc3BsQWN0aW9uUHJvdmlkZXIgPSBleHBvcnRzLlNwbEFjdGlvblByb3ZpZGVyID0gdm9pZCAwO1xuY29uc3QgYWN0aW9uUHJvdmlkZXJfMSA9IHJlcXVpcmUoXCIuLi9hY3Rpb25Qcm92aWRlclwiKTtcbmNvbnN0IHN2bVdhbGxldFByb3ZpZGVyXzEgPSByZXF1aXJlKFwiLi4vLi4vd2FsbGV0LXByb3ZpZGVycy9zdm1XYWxsZXRQcm92aWRlclwiKTtcbmNvbnN0IHpvZF8xID0gcmVxdWlyZShcInpvZFwiKTtcbmNvbnN0IGFjdGlvbkRlY29yYXRvcl8xID0gcmVxdWlyZShcIi4uL2FjdGlvbkRlY29yYXRvclwiKTtcbmNvbnN0IHNjaGVtYXNfMSA9IHJlcXVpcmUoXCIuL3NjaGVtYXNcIik7XG5jb25zdCB3ZWIzX2pzXzEgPSByZXF1aXJlKFwiQHNvbGFuYS93ZWIzLmpzXCIpO1xuLyoqXG4gKiBTcGxBY3Rpb25Qcm92aWRlciBzZXJ2ZXMgYXMgYSBwcm92aWRlciBmb3IgU1BMIHRva2VuIGFjdGlvbnMuXG4gKiBJdCBwcm92aWRlcyBTUEwgdG9rZW4gdHJhbnNmZXIgZnVuY3Rpb25hbGl0eS5cbiAqL1xuY2xhc3MgU3BsQWN0aW9uUHJvdmlkZXIgZXh0ZW5kcyBhY3Rpb25Qcm92aWRlcl8xLkFjdGlvblByb3ZpZGVyIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFNwbEFjdGlvblByb3ZpZGVyIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihcInNwbFwiLCBbXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgYmFsYW5jZSBvZiBTUEwgdG9rZW5zIGZvciBhbiBhZGRyZXNzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHdhbGxldFByb3ZpZGVyIC0gVGhlIHdhbGxldCBwcm92aWRlciB0byB1c2VcbiAgICAgKiBAcGFyYW0gYXJncyAtIFBhcmFtZXRlcnMgaW5jbHVkaW5nIG1pbnQgYWRkcmVzcyBhbmQgb3B0aW9uYWwgdGFyZ2V0IGFkZHJlc3NcbiAgICAgKiBAcmV0dXJucyBBIG1lc3NhZ2UgaW5kaWNhdGluZyB0aGUgdG9rZW4gYmFsYW5jZVxuICAgICAqL1xuICAgIGFzeW5jIGdldEJhbGFuY2Uod2FsbGV0UHJvdmlkZXIsIGFyZ3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghYXJncy5hZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgYXJncy5hZGRyZXNzID0gd2FsbGV0UHJvdmlkZXIuZ2V0QWRkcmVzcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY29ubmVjdGlvbiA9IHdhbGxldFByb3ZpZGVyLmdldENvbm5lY3Rpb24oKTtcbiAgICAgICAgICAgIGNvbnN0IG1pbnRQdWJrZXkgPSBuZXcgd2ViM19qc18xLlB1YmxpY0tleShhcmdzLm1pbnRBZGRyZXNzKTtcbiAgICAgICAgICAgIGNvbnN0IG93bmVyUHVia2V5ID0gbmV3IHdlYjNfanNfMS5QdWJsaWNLZXkoYXJncy5hZGRyZXNzKTtcbiAgICAgICAgICAgIGNvbnN0IHsgZ2V0TWludCwgZ2V0QXNzb2NpYXRlZFRva2VuQWRkcmVzcywgZ2V0QWNjb3VudCwgVG9rZW5BY2NvdW50Tm90Rm91bmRFcnJvciB9ID0gYXdhaXQgaW1wb3J0KFwiQHNvbGFuYS9zcGwtdG9rZW5cIik7XG4gICAgICAgICAgICBsZXQgbWludEluZm87XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG1pbnRJbmZvID0gYXdhaXQgZ2V0TWludChjb25uZWN0aW9uLCBtaW50UHVia2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBgRmFpbGVkIHRvIGZldGNoIG1pbnQgaW5mbyBmb3IgbWludCBhZGRyZXNzICR7YXJncy5taW50QWRkcmVzc30uIEVycm9yOiAke2Vycm9yfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGF0YSA9IGF3YWl0IGdldEFzc29jaWF0ZWRUb2tlbkFkZHJlc3MobWludFB1YmtleSwgb3duZXJQdWJrZXkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFjY291bnQgPSBhd2FpdCBnZXRBY2NvdW50KGNvbm5lY3Rpb24sIGF0YSk7XG4gICAgICAgICAgICAgICAgY29uc3QgYmFsYW5jZSA9IE51bWJlcihhY2NvdW50LmFtb3VudCkgLyBNYXRoLnBvdygxMCwgbWludEluZm8uZGVjaW1hbHMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBgQmFsYW5jZSBmb3IgJHthcmdzLmFkZHJlc3N9IGlzICR7YmFsYW5jZX0gdG9rZW5zYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFRva2VuQWNjb3VudE5vdEZvdW5kRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGBCYWxhbmNlIGZvciAke2FyZ3MuYWRkcmVzc30gaXMgMCB0b2tlbnNgO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBgRXJyb3IgZ2V0dGluZyBTUEwgdG9rZW4gYmFsYW5jZTogJHtlcnJvcn1gO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyYW5zZmVyIFNQTCB0b2tlbnMgdG8gYW5vdGhlciBhZGRyZXNzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHdhbGxldFByb3ZpZGVyIC0gVGhlIHdhbGxldCBwcm92aWRlciB0byB1c2UgZm9yIHRoZSB0cmFuc2ZlclxuICAgICAqIEBwYXJhbSBhcmdzIC0gVHJhbnNmZXIgcGFyYW1ldGVycyBpbmNsdWRpbmcgcmVjaXBpZW50IGFkZHJlc3MsIG1pbnQgYWRkcmVzcywgYW5kIGFtb3VudFxuICAgICAqIEByZXR1cm5zIEEgbWVzc2FnZSBpbmRpY2F0aW5nIHN1Y2Nlc3Mgb3IgZmFpbHVyZSB3aXRoIHRyYW5zYWN0aW9uIGRldGFpbHNcbiAgICAgKi9cbiAgICBhc3luYyB0cmFuc2Zlcih3YWxsZXRQcm92aWRlciwgYXJncykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgY29ubmVjdGlvbiA9IHdhbGxldFByb3ZpZGVyLmdldENvbm5lY3Rpb24oKTtcbiAgICAgICAgICAgIGNvbnN0IGZyb21QdWJrZXkgPSB3YWxsZXRQcm92aWRlci5nZXRQdWJsaWNLZXkoKTtcbiAgICAgICAgICAgIGNvbnN0IHRvUHVia2V5ID0gbmV3IHdlYjNfanNfMS5QdWJsaWNLZXkoYXJncy5yZWNpcGllbnQpO1xuICAgICAgICAgICAgY29uc3QgbWludFB1YmtleSA9IG5ldyB3ZWIzX2pzXzEuUHVibGljS2V5KGFyZ3MubWludEFkZHJlc3MpO1xuICAgICAgICAgICAgY29uc3QgeyBnZXRNaW50LCBnZXRBc3NvY2lhdGVkVG9rZW5BZGRyZXNzLCBnZXRBY2NvdW50LCBjcmVhdGVBc3NvY2lhdGVkVG9rZW5BY2NvdW50SW5zdHJ1Y3Rpb24sIGNyZWF0ZVRyYW5zZmVyQ2hlY2tlZEluc3RydWN0aW9uLCB9ID0gYXdhaXQgaW1wb3J0KFwiQHNvbGFuYS9zcGwtdG9rZW5cIik7XG4gICAgICAgICAgICBsZXQgbWludEluZm87XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG1pbnRJbmZvID0gYXdhaXQgZ2V0TWludChjb25uZWN0aW9uLCBtaW50UHVia2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBgRmFpbGVkIHRvIGZldGNoIG1pbnQgaW5mbyBmb3IgbWludCBhZGRyZXNzICR7YXJncy5taW50QWRkcmVzc30uIEVycm9yOiAke2Vycm9yfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhZGp1c3RlZEFtb3VudCA9IGFyZ3MuYW1vdW50ICogTWF0aC5wb3coMTAsIG1pbnRJbmZvLmRlY2ltYWxzKTtcbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZUF0YSA9IGF3YWl0IGdldEFzc29jaWF0ZWRUb2tlbkFkZHJlc3MobWludFB1YmtleSwgZnJvbVB1YmtleSk7XG4gICAgICAgICAgICBjb25zdCBkZXN0aW5hdGlvbkF0YSA9IGF3YWl0IGdldEFzc29jaWF0ZWRUb2tlbkFkZHJlc3MobWludFB1YmtleSwgdG9QdWJrZXkpO1xuICAgICAgICAgICAgY29uc3QgaW5zdHJ1Y3Rpb25zID0gW107XG4gICAgICAgICAgICBjb25zdCBzb3VyY2VBY2NvdW50ID0gYXdhaXQgZ2V0QWNjb3VudChjb25uZWN0aW9uLCBzb3VyY2VBdGEpO1xuICAgICAgICAgICAgaWYgKHNvdXJjZUFjY291bnQuYW1vdW50IDwgQmlnSW50KGFkanVzdGVkQW1vdW50KSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW5zdWZmaWNpZW50IHRva2VuIGJhbGFuY2UuIEhhdmUgJHtzb3VyY2VBY2NvdW50LmFtb3VudH0sIG5lZWQgJHthZGp1c3RlZEFtb3VudH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgZ2V0QWNjb3VudChjb25uZWN0aW9uLCBkZXN0aW5hdGlvbkF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zLnB1c2goY3JlYXRlQXNzb2NpYXRlZFRva2VuQWNjb3VudEluc3RydWN0aW9uKGZyb21QdWJrZXksIGRlc3RpbmF0aW9uQXRhLCB0b1B1YmtleSwgbWludFB1YmtleSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zLnB1c2goY3JlYXRlVHJhbnNmZXJDaGVja2VkSW5zdHJ1Y3Rpb24oc291cmNlQXRhLCBtaW50UHVia2V5LCBkZXN0aW5hdGlvbkF0YSwgZnJvbVB1YmtleSwgYWRqdXN0ZWRBbW91bnQsIG1pbnRJbmZvLmRlY2ltYWxzKSk7XG4gICAgICAgICAgICBjb25zdCB0eCA9IG5ldyB3ZWIzX2pzXzEuVmVyc2lvbmVkVHJhbnNhY3Rpb24od2ViM19qc18xLk1lc3NhZ2VWMC5jb21waWxlKHtcbiAgICAgICAgICAgICAgICBwYXllcktleTogZnJvbVB1YmtleSxcbiAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbnM6IGluc3RydWN0aW9ucyxcbiAgICAgICAgICAgICAgICByZWNlbnRCbG9ja2hhc2g6IChhd2FpdCBjb25uZWN0aW9uLmdldExhdGVzdEJsb2NraGFzaCgpKS5ibG9ja2hhc2gsXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCB3YWxsZXRQcm92aWRlci5zaWduQW5kU2VuZFRyYW5zYWN0aW9uKHR4KTtcbiAgICAgICAgICAgIGF3YWl0IHdhbGxldFByb3ZpZGVyLndhaXRGb3JTaWduYXR1cmVSZXN1bHQoc2lnbmF0dXJlKTtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgYFN1Y2Nlc3NmdWxseSB0cmFuc2ZlcnJlZCAke2FyZ3MuYW1vdW50fSB0b2tlbnMgdG8gJHthcmdzLnJlY2lwaWVudH1gLFxuICAgICAgICAgICAgICAgIGBUb2tlbiBtaW50OiAke2FyZ3MubWludEFkZHJlc3N9YCxcbiAgICAgICAgICAgICAgICBgU2lnbmF0dXJlOiAke3NpZ25hdHVyZX1gLFxuICAgICAgICAgICAgXS5qb2luKFwiXFxuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGBFcnJvciB0cmFuc2ZlcnJpbmcgU1BMIHRva2VuczogJHtlcnJvcn1gO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgYWN0aW9uIHByb3ZpZGVyIHN1cHBvcnRzIHRoZSBnaXZlbiBuZXR3b3JrLlxuICAgICAqIE9ubHkgc3VwcG9ydHMgU29sYW5hIG5ldHdvcmtzLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5ldHdvcmsgLSBUaGUgbmV0d29yayB0byBjaGVjayBzdXBwb3J0IGZvclxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIG5ldHdvcmsgaXMgYSBTb2xhbmEgbmV0d29ya1xuICAgICAqL1xuICAgIHN1cHBvcnRzTmV0d29yayhuZXR3b3JrKSB7XG4gICAgICAgIHJldHVybiBuZXR3b3JrLnByb3RvY29sRmFtaWx5ID09PSBcInN2bVwiO1xuICAgIH1cbn1cbmV4cG9ydHMuU3BsQWN0aW9uUHJvdmlkZXIgPSBTcGxBY3Rpb25Qcm92aWRlcjtcbl9fZGVjb3JhdGUoW1xuICAgICgwLCBhY3Rpb25EZWNvcmF0b3JfMS5DcmVhdGVBY3Rpb24pKHtcbiAgICAgICAgbmFtZTogXCJnZXRfYmFsYW5jZVwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogYFxuICAgIFRoaXMgdG9vbCB3aWxsIGdldCB0aGUgYmFsYW5jZSBvZiBTUEwgdG9rZW5zIGZvciBhbiBhZGRyZXNzLlxuICAgIC0gTWludCBhZGRyZXNzIG11c3QgYmUgYSB2YWxpZCBTUEwgdG9rZW4gbWludFxuICAgIC0gSWYgbm8gYWRkcmVzcyBpcyBwcm92aWRlZCwgdXNlcyB0aGUgY29ubmVjdGVkIHdhbGxldCdzIGFkZHJlc3NcbiAgICAtIFJldHVybnMgdGhlIHRva2VuIGJhbGFuY2UgaW4gdG9rZW4gdW5pdHMgKG5vdCByYXcpXG4gICAgYCxcbiAgICAgICAgc2NoZW1hOiBzY2hlbWFzXzEuR2V0QmFsYW5jZVNjaGVtYSxcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbc3ZtV2FsbGV0UHJvdmlkZXJfMS5Tdm1XYWxsZXRQcm92aWRlciwgdm9pZCAwXSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIFByb21pc2UpXG5dLCBTcGxBY3Rpb25Qcm92aWRlci5wcm90b3R5cGUsIFwiZ2V0QmFsYW5jZVwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgICgwLCBhY3Rpb25EZWNvcmF0b3JfMS5DcmVhdGVBY3Rpb24pKHtcbiAgICAgICAgbmFtZTogXCJ0cmFuc2ZlclwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogYFxuICAgIFRoaXMgdG9vbCB3aWxsIHRyYW5zZmVyIFNQTCB0b2tlbnMgdG8gYW5vdGhlciBhZGRyZXNzLlxuICAgIC0gQW1vdW50IHNob3VsZCBiZSBzcGVjaWZpZWQgaW4gdG9rZW4gdW5pdHMgKG5vdCByYXcpXG4gICAgLSBSZWNpcGllbnQgbXVzdCBiZSBhIHZhbGlkIFNvbGFuYSBhZGRyZXNzXG4gICAgLSBNaW50IGFkZHJlc3MgbXVzdCBiZSBhIHZhbGlkIFNQTCB0b2tlbiBtaW50XG4gICAgLSBFbnN1cmVzIHN1ZmZpY2llbnQgdG9rZW4gYmFsYW5jZSBiZWZvcmUgdHJhbnNmZXJcbiAgICAtIFJldHVybnMgdHJhbnNhY3Rpb24gZGV0YWlsc1xuICAgIGAsXG4gICAgICAgIHNjaGVtYTogc2NoZW1hc18xLlRyYW5zZmVyVG9rZW5TY2hlbWEsXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW3N2bVdhbGxldFByb3ZpZGVyXzEuU3ZtV2FsbGV0UHJvdmlkZXIsIHZvaWQgMF0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCBQcm9taXNlKVxuXSwgU3BsQWN0aW9uUHJvdmlkZXIucHJvdG90eXBlLCBcInRyYW5zZmVyXCIsIG51bGwpO1xuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIHRvIGNyZWF0ZSBhIG5ldyBTcGxBY3Rpb25Qcm92aWRlciBpbnN0YW5jZS5cbiAqXG4gKiBAcmV0dXJucyBBIG5ldyBTcGxBY3Rpb25Qcm92aWRlciBpbnN0YW5jZVxuICovXG5jb25zdCBzcGxBY3Rpb25Qcm92aWRlciA9ICgpID0+IG5ldyBTcGxBY3Rpb25Qcm92aWRlcigpO1xuZXhwb3J0cy5zcGxBY3Rpb25Qcm92aWRlciA9IHNwbEFjdGlvblByb3ZpZGVyO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/spl/splActionProvider.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/twitter/index.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/twitter/index.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./schemas */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/twitter/schemas.js\"), exports);\n__exportStar(__webpack_require__(/*! ./twitterActionProvider */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/twitter/twitterActionProvider.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy90d2l0dGVyL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWEsbUJBQU8sQ0FBQyxtR0FBVztBQUNoQyxhQUFhLG1CQUFPLENBQUMsK0hBQXlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3Vydml2YWwtZnVuLy4vbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9hZ2VudGtpdC9kaXN0L2FjdGlvbi1wcm92aWRlcnMvdHdpdHRlci9pbmRleC5qcz82MjU4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc2NoZW1hc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdHdpdHRlckFjdGlvblByb3ZpZGVyXCIpLCBleHBvcnRzKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/twitter/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/twitter/schemas.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/twitter/schemas.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TwitterPostTweetReplySchema = exports.TwitterPostTweetSchema = exports.TwitterAccountMentionsSchema = exports.TwitterAccountDetailsSchema = void 0;\nconst zod_1 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/lib/index.js\");\n/**\n * Input schema for retrieving account details.\n */\nexports.TwitterAccountDetailsSchema = zod_1.z\n    .object({})\n    .strip()\n    .describe(\"Input schema for retrieving account details\");\n/**\n * Input schema for retrieving account mentions.\n */\nexports.TwitterAccountMentionsSchema = zod_1.z\n    .object({\n    userId: zod_1.z\n        .string()\n        .min(1, \"Account ID is required.\")\n        .describe(\"The Twitter (X) user id to return mentions for\"),\n})\n    .strip()\n    .describe(\"Input schema for retrieving account mentions\");\n/**\n * Input schema for posting a tweet.\n */\nexports.TwitterPostTweetSchema = zod_1.z\n    .object({\n    tweet: zod_1.z.string().max(280, \"Tweet must be a maximum of 280 characters.\"),\n})\n    .strip()\n    .describe(\"Input schema for posting a tweet\");\n/**\n * Input schema for posting a tweet reply.\n */\nexports.TwitterPostTweetReplySchema = zod_1.z\n    .object({\n    tweetId: zod_1.z.string().describe(\"The id of the tweet to reply to\"),\n    tweetReply: zod_1.z\n        .string()\n        .max(280, \"The reply to the tweet which must be a maximum of 280 characters.\"),\n})\n    .strip()\n    .describe(\"Input schema for posting a tweet reply\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy90d2l0dGVyL3NjaGVtYXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUNBQW1DLEdBQUcsOEJBQThCLEdBQUcsb0NBQW9DLEdBQUcsbUNBQW1DO0FBQ2pKLGNBQWMsbUJBQU8sQ0FBQyxrREFBSztBQUMzQjtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXJ2aXZhbC1mdW4vLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy90d2l0dGVyL3NjaGVtYXMuanM/ODRlZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVHdpdHRlclBvc3RUd2VldFJlcGx5U2NoZW1hID0gZXhwb3J0cy5Ud2l0dGVyUG9zdFR3ZWV0U2NoZW1hID0gZXhwb3J0cy5Ud2l0dGVyQWNjb3VudE1lbnRpb25zU2NoZW1hID0gZXhwb3J0cy5Ud2l0dGVyQWNjb3VudERldGFpbHNTY2hlbWEgPSB2b2lkIDA7XG5jb25zdCB6b2RfMSA9IHJlcXVpcmUoXCJ6b2RcIik7XG4vKipcbiAqIElucHV0IHNjaGVtYSBmb3IgcmV0cmlldmluZyBhY2NvdW50IGRldGFpbHMuXG4gKi9cbmV4cG9ydHMuVHdpdHRlckFjY291bnREZXRhaWxzU2NoZW1hID0gem9kXzEuelxuICAgIC5vYmplY3Qoe30pXG4gICAgLnN0cmlwKClcbiAgICAuZGVzY3JpYmUoXCJJbnB1dCBzY2hlbWEgZm9yIHJldHJpZXZpbmcgYWNjb3VudCBkZXRhaWxzXCIpO1xuLyoqXG4gKiBJbnB1dCBzY2hlbWEgZm9yIHJldHJpZXZpbmcgYWNjb3VudCBtZW50aW9ucy5cbiAqL1xuZXhwb3J0cy5Ud2l0dGVyQWNjb3VudE1lbnRpb25zU2NoZW1hID0gem9kXzEuelxuICAgIC5vYmplY3Qoe1xuICAgIHVzZXJJZDogem9kXzEuelxuICAgICAgICAuc3RyaW5nKClcbiAgICAgICAgLm1pbigxLCBcIkFjY291bnQgSUQgaXMgcmVxdWlyZWQuXCIpXG4gICAgICAgIC5kZXNjcmliZShcIlRoZSBUd2l0dGVyIChYKSB1c2VyIGlkIHRvIHJldHVybiBtZW50aW9ucyBmb3JcIiksXG59KVxuICAgIC5zdHJpcCgpXG4gICAgLmRlc2NyaWJlKFwiSW5wdXQgc2NoZW1hIGZvciByZXRyaWV2aW5nIGFjY291bnQgbWVudGlvbnNcIik7XG4vKipcbiAqIElucHV0IHNjaGVtYSBmb3IgcG9zdGluZyBhIHR3ZWV0LlxuICovXG5leHBvcnRzLlR3aXR0ZXJQb3N0VHdlZXRTY2hlbWEgPSB6b2RfMS56XG4gICAgLm9iamVjdCh7XG4gICAgdHdlZXQ6IHpvZF8xLnouc3RyaW5nKCkubWF4KDI4MCwgXCJUd2VldCBtdXN0IGJlIGEgbWF4aW11bSBvZiAyODAgY2hhcmFjdGVycy5cIiksXG59KVxuICAgIC5zdHJpcCgpXG4gICAgLmRlc2NyaWJlKFwiSW5wdXQgc2NoZW1hIGZvciBwb3N0aW5nIGEgdHdlZXRcIik7XG4vKipcbiAqIElucHV0IHNjaGVtYSBmb3IgcG9zdGluZyBhIHR3ZWV0IHJlcGx5LlxuICovXG5leHBvcnRzLlR3aXR0ZXJQb3N0VHdlZXRSZXBseVNjaGVtYSA9IHpvZF8xLnpcbiAgICAub2JqZWN0KHtcbiAgICB0d2VldElkOiB6b2RfMS56LnN0cmluZygpLmRlc2NyaWJlKFwiVGhlIGlkIG9mIHRoZSB0d2VldCB0byByZXBseSB0b1wiKSxcbiAgICB0d2VldFJlcGx5OiB6b2RfMS56XG4gICAgICAgIC5zdHJpbmcoKVxuICAgICAgICAubWF4KDI4MCwgXCJUaGUgcmVwbHkgdG8gdGhlIHR3ZWV0IHdoaWNoIG11c3QgYmUgYSBtYXhpbXVtIG9mIDI4MCBjaGFyYWN0ZXJzLlwiKSxcbn0pXG4gICAgLnN0cmlwKClcbiAgICAuZGVzY3JpYmUoXCJJbnB1dCBzY2hlbWEgZm9yIHBvc3RpbmcgYSB0d2VldCByZXBseVwiKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/twitter/schemas.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/twitter/twitterActionProvider.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/twitter/twitterActionProvider.js ***!
  \************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.twitterActionProvider = exports.TwitterActionProvider = void 0;\nconst zod_1 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/lib/index.js\");\nconst actionProvider_1 = __webpack_require__(/*! ../actionProvider */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/actionProvider.js\");\nconst actionDecorator_1 = __webpack_require__(/*! ../actionDecorator */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/actionDecorator.js\");\nconst twitter_api_v2_1 = __webpack_require__(/*! twitter-api-v2 */ \"(rsc)/./node_modules/twitter-api-v2/dist/esm/index.js\");\nconst schemas_1 = __webpack_require__(/*! ./schemas */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/twitter/schemas.js\");\n/**\n * TwitterActionProvider is an action provider for Twitter (X) interactions.\n *\n * @augments ActionProvider\n */\nclass TwitterActionProvider extends actionProvider_1.ActionProvider {\n    /**\n     * Constructor for the TwitterActionProvider class.\n     *\n     * @param config - The configuration options for the TwitterActionProvider\n     */\n    constructor(config = {}) {\n        super(\"twitter\", []);\n        config.apiKey || (config.apiKey = process.env.TWITTER_API_KEY);\n        config.apiSecret || (config.apiSecret = process.env.TWITTER_API_SECRET);\n        config.accessToken || (config.accessToken = process.env.TWITTER_ACCESS_TOKEN);\n        config.accessTokenSecret || (config.accessTokenSecret = process.env.TWITTER_ACCESS_TOKEN_SECRET);\n        if (!config.apiKey) {\n            throw new Error(\"TWITTER_API_KEY is not configured.\");\n        }\n        if (!config.apiSecret) {\n            throw new Error(\"TWITTER_API_SECRET is not configured.\");\n        }\n        if (!config.accessToken) {\n            throw new Error(\"TWITTER_ACCESS_TOKEN is not configured.\");\n        }\n        if (!config.accessTokenSecret) {\n            throw new Error(\"TWITTER_ACCESS_TOKEN_SECRET is not configured.\");\n        }\n        this.client = new twitter_api_v2_1.TwitterApi({\n            appKey: config.apiKey,\n            appSecret: config.apiSecret,\n            accessToken: config.accessToken,\n            accessSecret: config.accessTokenSecret,\n        });\n    }\n    /**\n     * Get account details for the currently authenticated Twitter (X) user.\n     *\n     * @param _ - Empty parameter object (not used)\n     * @returns A JSON string containing the account details or error message\n     */\n    async accountDetails(_) {\n        try {\n            const response = await this.client.v2.me();\n            response.data.url = `https://x.com/${response.data.username}`;\n            return `Successfully retrieved authenticated user account details:\\n${JSON.stringify(response)}`;\n        }\n        catch (error) {\n            return `Error retrieving authenticated user account details: ${error}`;\n        }\n    }\n    /**\n     * Get mentions for a specified Twitter (X) user.\n     *\n     * @param args - The arguments containing userId\n     * @returns A JSON string containing the mentions or error message\n     */\n    async accountMentions(args) {\n        try {\n            const response = await this.client.v2.userMentionTimeline(args.userId);\n            return `Successfully retrieved account mentions:\\n${JSON.stringify(response)}`;\n        }\n        catch (error) {\n            return `Error retrieving authenticated account mentions: ${error}`;\n        }\n    }\n    /**\n     * Post a tweet on Twitter (X).\n     *\n     * @param args - The arguments containing the tweet text\n     * @returns A JSON string containing the posted tweet details or error message\n     */\n    async postTweet(args) {\n        try {\n            const response = await this.client.v2.tweet(args.tweet);\n            return `Successfully posted to Twitter:\\n${JSON.stringify(response)}`;\n        }\n        catch (error) {\n            return `Error posting to Twitter:\\n${error}`;\n        }\n    }\n    /**\n     * Post a reply to a tweet on Twitter (X).\n     *\n     * @param args - The arguments containing the reply text and tweet ID\n     * @returns A JSON string containing the posted reply details or error message\n     */\n    async postTweetReply(args) {\n        try {\n            const response = await this.client.v2.tweet(args.tweetReply, {\n                reply: { in_reply_to_tweet_id: args.tweetId },\n            });\n            return `Successfully posted reply to Twitter:\\n${JSON.stringify(response)}`;\n        }\n        catch (error) {\n            return `Error posting reply to Twitter: ${error}`;\n        }\n    }\n    /**\n     * Checks if the Twitter action provider supports the given network.\n     * Twitter actions don't depend on blockchain networks, so always return true.\n     *\n     * @param _ - The network to check (not used)\n     * @returns Always returns true as Twitter actions are network-independent\n     */\n    supportsNetwork(_) {\n        return true;\n    }\n}\nexports.TwitterActionProvider = TwitterActionProvider;\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"account_details\",\n        description: `\nThis tool will return account details for the currently authenticated Twitter (X) user context.\n\nA successful response will return a message with the api response as a json payload:\n    {\"data\": {\"id\": \"1853889445319331840\", \"name\": \"CDP AgentKit\", \"username\": \"CDPAgentKit\"}}\n\nA failure response will return a message with a Twitter API request error:\n    Error retrieving authenticated user account: 429 Too Many Requests`,\n        schema: schemas_1.TwitterAccountDetailsSchema,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [void 0]),\n    __metadata(\"design:returntype\", Promise)\n], TwitterActionProvider.prototype, \"accountDetails\", null);\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"account_mentions\",\n        description: `\nThis tool will return mentions for the specified Twitter (X) user id.\n\nA successful response will return a message with the API response as a JSON payload:\n    {\"data\": [{\"id\": \"1857479287504584856\", \"text\": \"@CDPAgentKit reply\"}]}\n\nA failure response will return a message with the Twitter API request error:\n    Error retrieving user mentions: 429 Too Many Requests`,\n        schema: schemas_1.TwitterAccountMentionsSchema,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [void 0]),\n    __metadata(\"design:returntype\", Promise)\n], TwitterActionProvider.prototype, \"accountMentions\", null);\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"post_tweet\",\n        description: `\nThis tool will post a tweet on Twitter. The tool takes the text of the tweet as input. Tweets can be maximum 280 characters.\n\nA successful response will return a message with the API response as a JSON payload:\n    {\"data\": {\"text\": \"hello, world!\", \"id\": \"0123456789012345678\", \"edit_history_tweet_ids\": [\"0123456789012345678\"]}}\n\nA failure response will return a message with the Twitter API request error:\n    You are not allowed to create a Tweet with duplicate content.`,\n        schema: schemas_1.TwitterPostTweetSchema,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [void 0]),\n    __metadata(\"design:returntype\", Promise)\n], TwitterActionProvider.prototype, \"postTweet\", null);\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"post_tweet_reply\",\n        description: `\nThis tool will post a tweet on Twitter. The tool takes the text of the tweet as input. Tweets can be maximum 280 characters.\n\nA successful response will return a message with the API response as a JSON payload:\n    {\"data\": {\"text\": \"hello, world!\", \"id\": \"0123456789012345678\", \"edit_history_tweet_ids\": [\"0123456789012345678\"]}}\n\nA failure response will return a message with the Twitter API request error:\n    You are not allowed to create a Tweet with duplicate content.`,\n        schema: schemas_1.TwitterPostTweetReplySchema,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [void 0]),\n    __metadata(\"design:returntype\", Promise)\n], TwitterActionProvider.prototype, \"postTweetReply\", null);\n/**\n * Factory function to create a new TwitterActionProvider instance.\n *\n * @param config - The configuration options for the TwitterActionProvider\n * @returns A new instance of TwitterActionProvider\n */\nconst twitterActionProvider = (config = {}) => new TwitterActionProvider(config);\nexports.twitterActionProvider = twitterActionProvider;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy90d2l0dGVyL3R3aXR0ZXJBY3Rpb25Qcm92aWRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxRQUFRO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNkJBQTZCLEdBQUcsNkJBQTZCO0FBQzdELGNBQWMsbUJBQU8sQ0FBQyxrREFBSztBQUMzQix5QkFBeUIsbUJBQU8sQ0FBQywwR0FBbUI7QUFDcEQsMEJBQTBCLG1CQUFPLENBQUMsNEdBQW9CO0FBQ3RELHlCQUF5QixtQkFBTyxDQUFDLDZFQUFnQjtBQUNqRCxrQkFBa0IsbUJBQU8sQ0FBQyxtR0FBVztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELHVCQUF1QjtBQUN4RSxrRkFBa0YseUJBQXlCO0FBQzNHO0FBQ0E7QUFDQSwyRUFBMkUsTUFBTTtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLHlCQUF5QjtBQUN6RjtBQUNBO0FBQ0EsdUVBQXVFLE1BQU07QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCx5QkFBeUI7QUFDaEY7QUFDQTtBQUNBLGlEQUFpRCxNQUFNO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsb0NBQW9DO0FBQzdELGFBQWE7QUFDYiw2REFBNkQseUJBQXlCO0FBQ3RGO0FBQ0E7QUFDQSxzREFBc0QsTUFBTTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSyxTQUFTOztBQUVkO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLLFVBQVUsMERBQTBEOztBQUV6RTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSyxTQUFTOztBQUVkO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLLFNBQVM7O0FBRWQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDLDZCQUE2QiIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cnZpdmFsLWZ1bi8uL25vZGVfbW9kdWxlcy9AY29pbmJhc2UvYWdlbnRraXQvZGlzdC9hY3Rpb24tcHJvdmlkZXJzL3R3aXR0ZXIvdHdpdHRlckFjdGlvblByb3ZpZGVyLmpzP2UzZTEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy50d2l0dGVyQWN0aW9uUHJvdmlkZXIgPSBleHBvcnRzLlR3aXR0ZXJBY3Rpb25Qcm92aWRlciA9IHZvaWQgMDtcbmNvbnN0IHpvZF8xID0gcmVxdWlyZShcInpvZFwiKTtcbmNvbnN0IGFjdGlvblByb3ZpZGVyXzEgPSByZXF1aXJlKFwiLi4vYWN0aW9uUHJvdmlkZXJcIik7XG5jb25zdCBhY3Rpb25EZWNvcmF0b3JfMSA9IHJlcXVpcmUoXCIuLi9hY3Rpb25EZWNvcmF0b3JcIik7XG5jb25zdCB0d2l0dGVyX2FwaV92Ml8xID0gcmVxdWlyZShcInR3aXR0ZXItYXBpLXYyXCIpO1xuY29uc3Qgc2NoZW1hc18xID0gcmVxdWlyZShcIi4vc2NoZW1hc1wiKTtcbi8qKlxuICogVHdpdHRlckFjdGlvblByb3ZpZGVyIGlzIGFuIGFjdGlvbiBwcm92aWRlciBmb3IgVHdpdHRlciAoWCkgaW50ZXJhY3Rpb25zLlxuICpcbiAqIEBhdWdtZW50cyBBY3Rpb25Qcm92aWRlclxuICovXG5jbGFzcyBUd2l0dGVyQWN0aW9uUHJvdmlkZXIgZXh0ZW5kcyBhY3Rpb25Qcm92aWRlcl8xLkFjdGlvblByb3ZpZGVyIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgdGhlIFR3aXR0ZXJBY3Rpb25Qcm92aWRlciBjbGFzcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb25maWcgLSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgVHdpdHRlckFjdGlvblByb3ZpZGVyXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnID0ge30pIHtcbiAgICAgICAgc3VwZXIoXCJ0d2l0dGVyXCIsIFtdKTtcbiAgICAgICAgY29uZmlnLmFwaUtleSB8fCAoY29uZmlnLmFwaUtleSA9IHByb2Nlc3MuZW52LlRXSVRURVJfQVBJX0tFWSk7XG4gICAgICAgIGNvbmZpZy5hcGlTZWNyZXQgfHwgKGNvbmZpZy5hcGlTZWNyZXQgPSBwcm9jZXNzLmVudi5UV0lUVEVSX0FQSV9TRUNSRVQpO1xuICAgICAgICBjb25maWcuYWNjZXNzVG9rZW4gfHwgKGNvbmZpZy5hY2Nlc3NUb2tlbiA9IHByb2Nlc3MuZW52LlRXSVRURVJfQUNDRVNTX1RPS0VOKTtcbiAgICAgICAgY29uZmlnLmFjY2Vzc1Rva2VuU2VjcmV0IHx8IChjb25maWcuYWNjZXNzVG9rZW5TZWNyZXQgPSBwcm9jZXNzLmVudi5UV0lUVEVSX0FDQ0VTU19UT0tFTl9TRUNSRVQpO1xuICAgICAgICBpZiAoIWNvbmZpZy5hcGlLZXkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRXSVRURVJfQVBJX0tFWSBpcyBub3QgY29uZmlndXJlZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb25maWcuYXBpU2VjcmV0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUV0lUVEVSX0FQSV9TRUNSRVQgaXMgbm90IGNvbmZpZ3VyZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY29uZmlnLmFjY2Vzc1Rva2VuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUV0lUVEVSX0FDQ0VTU19UT0tFTiBpcyBub3QgY29uZmlndXJlZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb25maWcuYWNjZXNzVG9rZW5TZWNyZXQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRXSVRURVJfQUNDRVNTX1RPS0VOX1NFQ1JFVCBpcyBub3QgY29uZmlndXJlZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbGllbnQgPSBuZXcgdHdpdHRlcl9hcGlfdjJfMS5Ud2l0dGVyQXBpKHtcbiAgICAgICAgICAgIGFwcEtleTogY29uZmlnLmFwaUtleSxcbiAgICAgICAgICAgIGFwcFNlY3JldDogY29uZmlnLmFwaVNlY3JldCxcbiAgICAgICAgICAgIGFjY2Vzc1Rva2VuOiBjb25maWcuYWNjZXNzVG9rZW4sXG4gICAgICAgICAgICBhY2Nlc3NTZWNyZXQ6IGNvbmZpZy5hY2Nlc3NUb2tlblNlY3JldCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhY2NvdW50IGRldGFpbHMgZm9yIHRoZSBjdXJyZW50bHkgYXV0aGVudGljYXRlZCBUd2l0dGVyIChYKSB1c2VyLlxuICAgICAqXG4gICAgICogQHBhcmFtIF8gLSBFbXB0eSBwYXJhbWV0ZXIgb2JqZWN0IChub3QgdXNlZClcbiAgICAgKiBAcmV0dXJucyBBIEpTT04gc3RyaW5nIGNvbnRhaW5pbmcgdGhlIGFjY291bnQgZGV0YWlscyBvciBlcnJvciBtZXNzYWdlXG4gICAgICovXG4gICAgYXN5bmMgYWNjb3VudERldGFpbHMoXykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNsaWVudC52Mi5tZSgpO1xuICAgICAgICAgICAgcmVzcG9uc2UuZGF0YS51cmwgPSBgaHR0cHM6Ly94LmNvbS8ke3Jlc3BvbnNlLmRhdGEudXNlcm5hbWV9YDtcbiAgICAgICAgICAgIHJldHVybiBgU3VjY2Vzc2Z1bGx5IHJldHJpZXZlZCBhdXRoZW50aWNhdGVkIHVzZXIgYWNjb3VudCBkZXRhaWxzOlxcbiR7SlNPTi5zdHJpbmdpZnkocmVzcG9uc2UpfWA7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gYEVycm9yIHJldHJpZXZpbmcgYXV0aGVudGljYXRlZCB1c2VyIGFjY291bnQgZGV0YWlsczogJHtlcnJvcn1gO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBtZW50aW9ucyBmb3IgYSBzcGVjaWZpZWQgVHdpdHRlciAoWCkgdXNlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhcmdzIC0gVGhlIGFyZ3VtZW50cyBjb250YWluaW5nIHVzZXJJZFxuICAgICAqIEByZXR1cm5zIEEgSlNPTiBzdHJpbmcgY29udGFpbmluZyB0aGUgbWVudGlvbnMgb3IgZXJyb3IgbWVzc2FnZVxuICAgICAqL1xuICAgIGFzeW5jIGFjY291bnRNZW50aW9ucyhhcmdzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2xpZW50LnYyLnVzZXJNZW50aW9uVGltZWxpbmUoYXJncy51c2VySWQpO1xuICAgICAgICAgICAgcmV0dXJuIGBTdWNjZXNzZnVsbHkgcmV0cmlldmVkIGFjY291bnQgbWVudGlvbnM6XFxuJHtKU09OLnN0cmluZ2lmeShyZXNwb25zZSl9YDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBgRXJyb3IgcmV0cmlldmluZyBhdXRoZW50aWNhdGVkIGFjY291bnQgbWVudGlvbnM6ICR7ZXJyb3J9YDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQb3N0IGEgdHdlZXQgb24gVHdpdHRlciAoWCkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXJncyAtIFRoZSBhcmd1bWVudHMgY29udGFpbmluZyB0aGUgdHdlZXQgdGV4dFxuICAgICAqIEByZXR1cm5zIEEgSlNPTiBzdHJpbmcgY29udGFpbmluZyB0aGUgcG9zdGVkIHR3ZWV0IGRldGFpbHMgb3IgZXJyb3IgbWVzc2FnZVxuICAgICAqL1xuICAgIGFzeW5jIHBvc3RUd2VldChhcmdzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2xpZW50LnYyLnR3ZWV0KGFyZ3MudHdlZXQpO1xuICAgICAgICAgICAgcmV0dXJuIGBTdWNjZXNzZnVsbHkgcG9zdGVkIHRvIFR3aXR0ZXI6XFxuJHtKU09OLnN0cmluZ2lmeShyZXNwb25zZSl9YDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBgRXJyb3IgcG9zdGluZyB0byBUd2l0dGVyOlxcbiR7ZXJyb3J9YDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQb3N0IGEgcmVwbHkgdG8gYSB0d2VldCBvbiBUd2l0dGVyIChYKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhcmdzIC0gVGhlIGFyZ3VtZW50cyBjb250YWluaW5nIHRoZSByZXBseSB0ZXh0IGFuZCB0d2VldCBJRFxuICAgICAqIEByZXR1cm5zIEEgSlNPTiBzdHJpbmcgY29udGFpbmluZyB0aGUgcG9zdGVkIHJlcGx5IGRldGFpbHMgb3IgZXJyb3IgbWVzc2FnZVxuICAgICAqL1xuICAgIGFzeW5jIHBvc3RUd2VldFJlcGx5KGFyZ3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jbGllbnQudjIudHdlZXQoYXJncy50d2VldFJlcGx5LCB7XG4gICAgICAgICAgICAgICAgcmVwbHk6IHsgaW5fcmVwbHlfdG9fdHdlZXRfaWQ6IGFyZ3MudHdlZXRJZCB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gYFN1Y2Nlc3NmdWxseSBwb3N0ZWQgcmVwbHkgdG8gVHdpdHRlcjpcXG4ke0pTT04uc3RyaW5naWZ5KHJlc3BvbnNlKX1gO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGBFcnJvciBwb3N0aW5nIHJlcGx5IHRvIFR3aXR0ZXI6ICR7ZXJyb3J9YDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIFR3aXR0ZXIgYWN0aW9uIHByb3ZpZGVyIHN1cHBvcnRzIHRoZSBnaXZlbiBuZXR3b3JrLlxuICAgICAqIFR3aXR0ZXIgYWN0aW9ucyBkb24ndCBkZXBlbmQgb24gYmxvY2tjaGFpbiBuZXR3b3Jrcywgc28gYWx3YXlzIHJldHVybiB0cnVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIF8gLSBUaGUgbmV0d29yayB0byBjaGVjayAobm90IHVzZWQpXG4gICAgICogQHJldHVybnMgQWx3YXlzIHJldHVybnMgdHJ1ZSBhcyBUd2l0dGVyIGFjdGlvbnMgYXJlIG5ldHdvcmstaW5kZXBlbmRlbnRcbiAgICAgKi9cbiAgICBzdXBwb3J0c05ldHdvcmsoXykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5leHBvcnRzLlR3aXR0ZXJBY3Rpb25Qcm92aWRlciA9IFR3aXR0ZXJBY3Rpb25Qcm92aWRlcjtcbl9fZGVjb3JhdGUoW1xuICAgICgwLCBhY3Rpb25EZWNvcmF0b3JfMS5DcmVhdGVBY3Rpb24pKHtcbiAgICAgICAgbmFtZTogXCJhY2NvdW50X2RldGFpbHNcIixcbiAgICAgICAgZGVzY3JpcHRpb246IGBcblRoaXMgdG9vbCB3aWxsIHJldHVybiBhY2NvdW50IGRldGFpbHMgZm9yIHRoZSBjdXJyZW50bHkgYXV0aGVudGljYXRlZCBUd2l0dGVyIChYKSB1c2VyIGNvbnRleHQuXG5cbkEgc3VjY2Vzc2Z1bCByZXNwb25zZSB3aWxsIHJldHVybiBhIG1lc3NhZ2Ugd2l0aCB0aGUgYXBpIHJlc3BvbnNlIGFzIGEganNvbiBwYXlsb2FkOlxuICAgIHtcImRhdGFcIjoge1wiaWRcIjogXCIxODUzODg5NDQ1MzE5MzMxODQwXCIsIFwibmFtZVwiOiBcIkNEUCBBZ2VudEtpdFwiLCBcInVzZXJuYW1lXCI6IFwiQ0RQQWdlbnRLaXRcIn19XG5cbkEgZmFpbHVyZSByZXNwb25zZSB3aWxsIHJldHVybiBhIG1lc3NhZ2Ugd2l0aCBhIFR3aXR0ZXIgQVBJIHJlcXVlc3QgZXJyb3I6XG4gICAgRXJyb3IgcmV0cmlldmluZyBhdXRoZW50aWNhdGVkIHVzZXIgYWNjb3VudDogNDI5IFRvbyBNYW55IFJlcXVlc3RzYCxcbiAgICAgICAgc2NoZW1hOiBzY2hlbWFzXzEuVHdpdHRlckFjY291bnREZXRhaWxzU2NoZW1hLFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFt2b2lkIDBdKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgUHJvbWlzZSlcbl0sIFR3aXR0ZXJBY3Rpb25Qcm92aWRlci5wcm90b3R5cGUsIFwiYWNjb3VudERldGFpbHNcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICAoMCwgYWN0aW9uRGVjb3JhdG9yXzEuQ3JlYXRlQWN0aW9uKSh7XG4gICAgICAgIG5hbWU6IFwiYWNjb3VudF9tZW50aW9uc1wiLFxuICAgICAgICBkZXNjcmlwdGlvbjogYFxuVGhpcyB0b29sIHdpbGwgcmV0dXJuIG1lbnRpb25zIGZvciB0aGUgc3BlY2lmaWVkIFR3aXR0ZXIgKFgpIHVzZXIgaWQuXG5cbkEgc3VjY2Vzc2Z1bCByZXNwb25zZSB3aWxsIHJldHVybiBhIG1lc3NhZ2Ugd2l0aCB0aGUgQVBJIHJlc3BvbnNlIGFzIGEgSlNPTiBwYXlsb2FkOlxuICAgIHtcImRhdGFcIjogW3tcImlkXCI6IFwiMTg1NzQ3OTI4NzUwNDU4NDg1NlwiLCBcInRleHRcIjogXCJAQ0RQQWdlbnRLaXQgcmVwbHlcIn1dfVxuXG5BIGZhaWx1cmUgcmVzcG9uc2Ugd2lsbCByZXR1cm4gYSBtZXNzYWdlIHdpdGggdGhlIFR3aXR0ZXIgQVBJIHJlcXVlc3QgZXJyb3I6XG4gICAgRXJyb3IgcmV0cmlldmluZyB1c2VyIG1lbnRpb25zOiA0MjkgVG9vIE1hbnkgUmVxdWVzdHNgLFxuICAgICAgICBzY2hlbWE6IHNjaGVtYXNfMS5Ud2l0dGVyQWNjb3VudE1lbnRpb25zU2NoZW1hLFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFt2b2lkIDBdKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgUHJvbWlzZSlcbl0sIFR3aXR0ZXJBY3Rpb25Qcm92aWRlci5wcm90b3R5cGUsIFwiYWNjb3VudE1lbnRpb25zXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgKDAsIGFjdGlvbkRlY29yYXRvcl8xLkNyZWF0ZUFjdGlvbikoe1xuICAgICAgICBuYW1lOiBcInBvc3RfdHdlZXRcIixcbiAgICAgICAgZGVzY3JpcHRpb246IGBcblRoaXMgdG9vbCB3aWxsIHBvc3QgYSB0d2VldCBvbiBUd2l0dGVyLiBUaGUgdG9vbCB0YWtlcyB0aGUgdGV4dCBvZiB0aGUgdHdlZXQgYXMgaW5wdXQuIFR3ZWV0cyBjYW4gYmUgbWF4aW11bSAyODAgY2hhcmFjdGVycy5cblxuQSBzdWNjZXNzZnVsIHJlc3BvbnNlIHdpbGwgcmV0dXJuIGEgbWVzc2FnZSB3aXRoIHRoZSBBUEkgcmVzcG9uc2UgYXMgYSBKU09OIHBheWxvYWQ6XG4gICAge1wiZGF0YVwiOiB7XCJ0ZXh0XCI6IFwiaGVsbG8sIHdvcmxkIVwiLCBcImlkXCI6IFwiMDEyMzQ1Njc4OTAxMjM0NTY3OFwiLCBcImVkaXRfaGlzdG9yeV90d2VldF9pZHNcIjogW1wiMDEyMzQ1Njc4OTAxMjM0NTY3OFwiXX19XG5cbkEgZmFpbHVyZSByZXNwb25zZSB3aWxsIHJldHVybiBhIG1lc3NhZ2Ugd2l0aCB0aGUgVHdpdHRlciBBUEkgcmVxdWVzdCBlcnJvcjpcbiAgICBZb3UgYXJlIG5vdCBhbGxvd2VkIHRvIGNyZWF0ZSBhIFR3ZWV0IHdpdGggZHVwbGljYXRlIGNvbnRlbnQuYCxcbiAgICAgICAgc2NoZW1hOiBzY2hlbWFzXzEuVHdpdHRlclBvc3RUd2VldFNjaGVtYSxcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbdm9pZCAwXSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIFByb21pc2UpXG5dLCBUd2l0dGVyQWN0aW9uUHJvdmlkZXIucHJvdG90eXBlLCBcInBvc3RUd2VldFwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgICgwLCBhY3Rpb25EZWNvcmF0b3JfMS5DcmVhdGVBY3Rpb24pKHtcbiAgICAgICAgbmFtZTogXCJwb3N0X3R3ZWV0X3JlcGx5XCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgXG5UaGlzIHRvb2wgd2lsbCBwb3N0IGEgdHdlZXQgb24gVHdpdHRlci4gVGhlIHRvb2wgdGFrZXMgdGhlIHRleHQgb2YgdGhlIHR3ZWV0IGFzIGlucHV0LiBUd2VldHMgY2FuIGJlIG1heGltdW0gMjgwIGNoYXJhY3RlcnMuXG5cbkEgc3VjY2Vzc2Z1bCByZXNwb25zZSB3aWxsIHJldHVybiBhIG1lc3NhZ2Ugd2l0aCB0aGUgQVBJIHJlc3BvbnNlIGFzIGEgSlNPTiBwYXlsb2FkOlxuICAgIHtcImRhdGFcIjoge1widGV4dFwiOiBcImhlbGxvLCB3b3JsZCFcIiwgXCJpZFwiOiBcIjAxMjM0NTY3ODkwMTIzNDU2NzhcIiwgXCJlZGl0X2hpc3RvcnlfdHdlZXRfaWRzXCI6IFtcIjAxMjM0NTY3ODkwMTIzNDU2NzhcIl19fVxuXG5BIGZhaWx1cmUgcmVzcG9uc2Ugd2lsbCByZXR1cm4gYSBtZXNzYWdlIHdpdGggdGhlIFR3aXR0ZXIgQVBJIHJlcXVlc3QgZXJyb3I6XG4gICAgWW91IGFyZSBub3QgYWxsb3dlZCB0byBjcmVhdGUgYSBUd2VldCB3aXRoIGR1cGxpY2F0ZSBjb250ZW50LmAsXG4gICAgICAgIHNjaGVtYTogc2NoZW1hc18xLlR3aXR0ZXJQb3N0VHdlZXRSZXBseVNjaGVtYSxcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbdm9pZCAwXSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIFByb21pc2UpXG5dLCBUd2l0dGVyQWN0aW9uUHJvdmlkZXIucHJvdG90eXBlLCBcInBvc3RUd2VldFJlcGx5XCIsIG51bGwpO1xuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIHRvIGNyZWF0ZSBhIG5ldyBUd2l0dGVyQWN0aW9uUHJvdmlkZXIgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIGNvbmZpZyAtIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBUd2l0dGVyQWN0aW9uUHJvdmlkZXJcbiAqIEByZXR1cm5zIEEgbmV3IGluc3RhbmNlIG9mIFR3aXR0ZXJBY3Rpb25Qcm92aWRlclxuICovXG5jb25zdCB0d2l0dGVyQWN0aW9uUHJvdmlkZXIgPSAoY29uZmlnID0ge30pID0+IG5ldyBUd2l0dGVyQWN0aW9uUHJvdmlkZXIoY29uZmlnKTtcbmV4cG9ydHMudHdpdHRlckFjdGlvblByb3ZpZGVyID0gdHdpdHRlckFjdGlvblByb3ZpZGVyO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/twitter/twitterActionProvider.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/vaultsfyi/api/actions.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/vaultsfyi/api/actions.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.fetchVaultActions = fetchVaultActions;\nconst utils_1 = __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/vaultsfyi/utils.js\");\nconst constants_1 = __webpack_require__(/*! ../constants */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/vaultsfyi/constants.js\");\n/**\n * Fetches a list of actions for a vault from the vaultsfyi API.\n *\n * @param root0 - The fetch parameters\n * @param root0.action - The action to fetch\n * @param root0.args - The action parameters\n * @param root0.sender - The sender address\n * @param root0.apiKey - The vaultsfyi API key\n * @returns The list of actions\n */\nasync function fetchVaultActions({ action, args, sender, apiKey, }) {\n    const params = (0, utils_1.createSearchParams)({\n        ...args,\n        sender,\n    });\n    const response = await fetch(`${constants_1.VAULTS_API_URL}/transactions/vaults/${action}?${params}`, {\n        method: \"GET\",\n        headers: {\n            \"x-api-key\": apiKey,\n        },\n    });\n    return (await response.json());\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy92YXVsdHNmeWkvYXBpL2FjdGlvbnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QseUJBQXlCO0FBQ3pCLGdCQUFnQixtQkFBTyxDQUFDLGtHQUFVO0FBQ2xDLG9CQUFvQixtQkFBTyxDQUFDLDBHQUFjO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLCtCQUErQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsb0NBQW9DLDJCQUEyQix1QkFBdUIsT0FBTyxHQUFHLE9BQU87QUFDdkc7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3Vydml2YWwtZnVuLy4vbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9hZ2VudGtpdC9kaXN0L2FjdGlvbi1wcm92aWRlcnMvdmF1bHRzZnlpL2FwaS9hY3Rpb25zLmpzPzNjYmYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmZldGNoVmF1bHRBY3Rpb25zID0gZmV0Y2hWYXVsdEFjdGlvbnM7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi4vY29uc3RhbnRzXCIpO1xuLyoqXG4gKiBGZXRjaGVzIGEgbGlzdCBvZiBhY3Rpb25zIGZvciBhIHZhdWx0IGZyb20gdGhlIHZhdWx0c2Z5aSBBUEkuXG4gKlxuICogQHBhcmFtIHJvb3QwIC0gVGhlIGZldGNoIHBhcmFtZXRlcnNcbiAqIEBwYXJhbSByb290MC5hY3Rpb24gLSBUaGUgYWN0aW9uIHRvIGZldGNoXG4gKiBAcGFyYW0gcm9vdDAuYXJncyAtIFRoZSBhY3Rpb24gcGFyYW1ldGVyc1xuICogQHBhcmFtIHJvb3QwLnNlbmRlciAtIFRoZSBzZW5kZXIgYWRkcmVzc1xuICogQHBhcmFtIHJvb3QwLmFwaUtleSAtIFRoZSB2YXVsdHNmeWkgQVBJIGtleVxuICogQHJldHVybnMgVGhlIGxpc3Qgb2YgYWN0aW9uc1xuICovXG5hc3luYyBmdW5jdGlvbiBmZXRjaFZhdWx0QWN0aW9ucyh7IGFjdGlvbiwgYXJncywgc2VuZGVyLCBhcGlLZXksIH0pIHtcbiAgICBjb25zdCBwYXJhbXMgPSAoMCwgdXRpbHNfMS5jcmVhdGVTZWFyY2hQYXJhbXMpKHtcbiAgICAgICAgLi4uYXJncyxcbiAgICAgICAgc2VuZGVyLFxuICAgIH0pO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7Y29uc3RhbnRzXzEuVkFVTFRTX0FQSV9VUkx9L3RyYW5zYWN0aW9ucy92YXVsdHMvJHthY3Rpb259PyR7cGFyYW1zfWAsIHtcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICBcIngtYXBpLWtleVwiOiBhcGlLZXksXG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgcmV0dXJuIChhd2FpdCByZXNwb25zZS5qc29uKCkpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/vaultsfyi/api/actions.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/vaultsfyi/api/vaults.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/vaultsfyi/api/vaults.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.fetchVaults = fetchVaults;\nconst utils_1 = __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/vaultsfyi/utils.js\");\nconst constants_1 = __webpack_require__(/*! ../constants */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/vaultsfyi/constants.js\");\n/**\n * Fetches a list of vaults from the vaultsfyi API.\n *\n * @param args - The action parameters\n * @param apiKey - The vaultsfyi API key\n * @returns The list of vaults\n */\nasync function fetchVaults(args, apiKey) {\n    const vaults = [];\n    const params = (0, utils_1.createSearchParams)({\n        per_page: 250,\n        token: args.token,\n        network: args.network,\n        tvl_min: args.minTvl ?? 100000,\n        transactional_only: true,\n    });\n    for (let i = 0; i < 10; i++) {\n        const response = await fetch(`${constants_1.VAULTS_API_URL}/detailed/vaults?${params}`, {\n            method: \"GET\",\n            headers: {\n                \"x-api-key\": apiKey,\n            },\n        });\n        const data = (await response.json());\n        if (\"error\" in data)\n            return data;\n        vaults.push(...data.data);\n        if (!data.next_page)\n            break;\n        else\n            params.set(\"page\", data.next_page);\n    }\n    return vaults;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy92YXVsdHNmeWkvYXBpL3ZhdWx0cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUI7QUFDbkIsZ0JBQWdCLG1CQUFPLENBQUMsa0dBQVU7QUFDbEMsb0JBQW9CLG1CQUFPLENBQUMsMEdBQWM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLG9CQUFvQixRQUFRO0FBQzVCLHdDQUF3QywyQkFBMkIsbUJBQW1CLE9BQU87QUFDN0Y7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3Vydml2YWwtZnVuLy4vbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9hZ2VudGtpdC9kaXN0L2FjdGlvbi1wcm92aWRlcnMvdmF1bHRzZnlpL2FwaS92YXVsdHMuanM/MzE5OSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZmV0Y2hWYXVsdHMgPSBmZXRjaFZhdWx0cztcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuLi9jb25zdGFudHNcIik7XG4vKipcbiAqIEZldGNoZXMgYSBsaXN0IG9mIHZhdWx0cyBmcm9tIHRoZSB2YXVsdHNmeWkgQVBJLlxuICpcbiAqIEBwYXJhbSBhcmdzIC0gVGhlIGFjdGlvbiBwYXJhbWV0ZXJzXG4gKiBAcGFyYW0gYXBpS2V5IC0gVGhlIHZhdWx0c2Z5aSBBUEkga2V5XG4gKiBAcmV0dXJucyBUaGUgbGlzdCBvZiB2YXVsdHNcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZmV0Y2hWYXVsdHMoYXJncywgYXBpS2V5KSB7XG4gICAgY29uc3QgdmF1bHRzID0gW107XG4gICAgY29uc3QgcGFyYW1zID0gKDAsIHV0aWxzXzEuY3JlYXRlU2VhcmNoUGFyYW1zKSh7XG4gICAgICAgIHBlcl9wYWdlOiAyNTAsXG4gICAgICAgIHRva2VuOiBhcmdzLnRva2VuLFxuICAgICAgICBuZXR3b3JrOiBhcmdzLm5ldHdvcmssXG4gICAgICAgIHR2bF9taW46IGFyZ3MubWluVHZsID8/IDEwMDAwMCxcbiAgICAgICAgdHJhbnNhY3Rpb25hbF9vbmx5OiB0cnVlLFxuICAgIH0pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke2NvbnN0YW50c18xLlZBVUxUU19BUElfVVJMfS9kZXRhaWxlZC92YXVsdHM/JHtwYXJhbXN9YCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgIFwieC1hcGkta2V5XCI6IGFwaUtleSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBkYXRhID0gKGF3YWl0IHJlc3BvbnNlLmpzb24oKSk7XG4gICAgICAgIGlmIChcImVycm9yXCIgaW4gZGF0YSlcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB2YXVsdHMucHVzaCguLi5kYXRhLmRhdGEpO1xuICAgICAgICBpZiAoIWRhdGEubmV4dF9wYWdlKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHBhcmFtcy5zZXQoXCJwYWdlXCIsIGRhdGEubmV4dF9wYWdlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhdWx0cztcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/vaultsfyi/api/vaults.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/vaultsfyi/constants.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/vaultsfyi/constants.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.VAULTSFYI_SUPPORTED_CHAINS = exports.VAULTS_API_URL = void 0;\nexports.VAULTS_API_URL = \"https://api.vaults.fyi/v1\";\nexports.VAULTSFYI_SUPPORTED_CHAINS = {\n    1: \"mainnet\",\n    42161: \"arbitrum\",\n    10: \"optimism\",\n    137: \"polygon\",\n    100: \"gnosis\",\n    8453: \"base\",\n    130: \"unichain\",\n    1923: \"swellchain\",\n    42220: \"celo\",\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy92YXVsdHNmeWkvY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtDQUFrQyxHQUFHLHNCQUFzQjtBQUMzRCxzQkFBc0I7QUFDdEIsa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3Vydml2YWwtZnVuLy4vbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9hZ2VudGtpdC9kaXN0L2FjdGlvbi1wcm92aWRlcnMvdmF1bHRzZnlpL2NvbnN0YW50cy5qcz8yYjc0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5WQVVMVFNGWUlfU1VQUE9SVEVEX0NIQUlOUyA9IGV4cG9ydHMuVkFVTFRTX0FQSV9VUkwgPSB2b2lkIDA7XG5leHBvcnRzLlZBVUxUU19BUElfVVJMID0gXCJodHRwczovL2FwaS52YXVsdHMuZnlpL3YxXCI7XG5leHBvcnRzLlZBVUxUU0ZZSV9TVVBQT1JURURfQ0hBSU5TID0ge1xuICAgIDE6IFwibWFpbm5ldFwiLFxuICAgIDQyMTYxOiBcImFyYml0cnVtXCIsXG4gICAgMTA6IFwib3B0aW1pc21cIixcbiAgICAxMzc6IFwicG9seWdvblwiLFxuICAgIDEwMDogXCJnbm9zaXNcIixcbiAgICA4NDUzOiBcImJhc2VcIixcbiAgICAxMzA6IFwidW5pY2hhaW5cIixcbiAgICAxOTIzOiBcInN3ZWxsY2hhaW5cIixcbiAgICA0MjIyMDogXCJjZWxvXCIsXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/vaultsfyi/constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/vaultsfyi/index.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/vaultsfyi/index.js ***!
  \**********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Exports for vaultsfyi action provider\n *\n * @module vaultsfyi\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./vaultsfyiActionProvider */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/vaultsfyi/vaultsfyiActionProvider.js\"), exports);\n__exportStar(__webpack_require__(/*! ./schemas */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/vaultsfyi/schemas.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy92YXVsdHNmeWkvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWEsbUJBQU8sQ0FBQyxxSUFBMkI7QUFDaEQsYUFBYSxtQkFBTyxDQUFDLHFHQUFXIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3Vydml2YWwtZnVuLy4vbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9hZ2VudGtpdC9kaXN0L2FjdGlvbi1wcm92aWRlcnMvdmF1bHRzZnlpL2luZGV4LmpzPzhmN2IiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEV4cG9ydHMgZm9yIHZhdWx0c2Z5aSBhY3Rpb24gcHJvdmlkZXJcbiAqXG4gKiBAbW9kdWxlIHZhdWx0c2Z5aVxuICovXG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi92YXVsdHNmeWlBY3Rpb25Qcm92aWRlclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc2NoZW1hc1wiKSwgZXhwb3J0cyk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/vaultsfyi/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/vaultsfyi/schemas.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/vaultsfyi/schemas.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.claimActionSchema = exports.redeemActionSchema = exports.depositActionSchema = exports.VaultsActionSchema = void 0;\nconst zod_1 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/lib/index.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/vaultsfyi/constants.js\");\n/**\n * Action schemas for the vaultsfyi action provider.\n *\n * This file contains the Zod schemas that define the shape and validation\n * rules for action parameters in the vaultsfyi action provider.\n */\nconst NetworkSchema = zod_1.z.enum(Object.values(constants_1.VAULTSFYI_SUPPORTED_CHAINS));\n/**\n * Vaults list action schema.\n */\nexports.VaultsActionSchema = zod_1.z.object({\n    token: zod_1.z\n        .string()\n        .optional()\n        .describe(\"Optional: Name or symbol of the token to filter vaults by\"),\n    protocol: zod_1.z.string().optional().describe(\"Optional: Protocol to filter vaults by\"),\n    network: NetworkSchema.optional().describe(\"Optional: Network name to filter vaults by. Supported networks: mainnet, arbitrum, optimism, polygon, base, gnosis, unichain\"),\n    minTvl: zod_1.z.number().optional().describe(\"Optional: Minimum TVL to filter vaults by\"),\n    sort: zod_1.z\n        .object({\n        field: zod_1.z.enum([\"tvl\", \"apy\", \"name\"]).optional().describe(\"Sort field\"),\n        direction: zod_1.z.enum([\"asc\", \"desc\"]).optional().describe(\"Sort direction\"),\n    })\n        .optional()\n        .describe(\"Sort options\"),\n    take: zod_1.z.number().optional().describe(\"Optional: Limit the number of results\"),\n    page: zod_1.z.number().optional().describe(\"Optional: Page number\"),\n});\n/**\n * Base transaction params schema.\n */\nconst TransactionActionSchema = zod_1.z.object({\n    vaultAddress: zod_1.z.string().describe(\"The address of the vault to interact with\"),\n    assetAddress: zod_1.z.string().describe(\"The address of the vault's underlying token\"),\n    network: NetworkSchema.describe(\"The network of the vault\"),\n    amount: zod_1.z.number().describe(\"The amount of assets to use\"),\n});\nexports.depositActionSchema = TransactionActionSchema;\nexports.redeemActionSchema = TransactionActionSchema.extend({\n    all: zod_1.z.boolean().optional().describe(\"Should redeem all assets\"),\n});\nexports.claimActionSchema = TransactionActionSchema.omit({\n    amount: true,\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy92YXVsdHNmeWkvc2NoZW1hcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx5QkFBeUIsR0FBRywwQkFBMEIsR0FBRywyQkFBMkIsR0FBRywwQkFBMEI7QUFDakgsY0FBYyxtQkFBTyxDQUFDLGtEQUFLO0FBQzNCLG9CQUFvQixtQkFBTyxDQUFDLHlHQUFhO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCwyQkFBMkI7QUFDM0IsMEJBQTBCO0FBQzFCO0FBQ0EsQ0FBQztBQUNELHlCQUF5QjtBQUN6QjtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXJ2aXZhbC1mdW4vLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy92YXVsdHNmeWkvc2NoZW1hcy5qcz81NjllIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jbGFpbUFjdGlvblNjaGVtYSA9IGV4cG9ydHMucmVkZWVtQWN0aW9uU2NoZW1hID0gZXhwb3J0cy5kZXBvc2l0QWN0aW9uU2NoZW1hID0gZXhwb3J0cy5WYXVsdHNBY3Rpb25TY2hlbWEgPSB2b2lkIDA7XG5jb25zdCB6b2RfMSA9IHJlcXVpcmUoXCJ6b2RcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbi8qKlxuICogQWN0aW9uIHNjaGVtYXMgZm9yIHRoZSB2YXVsdHNmeWkgYWN0aW9uIHByb3ZpZGVyLlxuICpcbiAqIFRoaXMgZmlsZSBjb250YWlucyB0aGUgWm9kIHNjaGVtYXMgdGhhdCBkZWZpbmUgdGhlIHNoYXBlIGFuZCB2YWxpZGF0aW9uXG4gKiBydWxlcyBmb3IgYWN0aW9uIHBhcmFtZXRlcnMgaW4gdGhlIHZhdWx0c2Z5aSBhY3Rpb24gcHJvdmlkZXIuXG4gKi9cbmNvbnN0IE5ldHdvcmtTY2hlbWEgPSB6b2RfMS56LmVudW0oT2JqZWN0LnZhbHVlcyhjb25zdGFudHNfMS5WQVVMVFNGWUlfU1VQUE9SVEVEX0NIQUlOUykpO1xuLyoqXG4gKiBWYXVsdHMgbGlzdCBhY3Rpb24gc2NoZW1hLlxuICovXG5leHBvcnRzLlZhdWx0c0FjdGlvblNjaGVtYSA9IHpvZF8xLnoub2JqZWN0KHtcbiAgICB0b2tlbjogem9kXzEuelxuICAgICAgICAuc3RyaW5nKClcbiAgICAgICAgLm9wdGlvbmFsKClcbiAgICAgICAgLmRlc2NyaWJlKFwiT3B0aW9uYWw6IE5hbWUgb3Igc3ltYm9sIG9mIHRoZSB0b2tlbiB0byBmaWx0ZXIgdmF1bHRzIGJ5XCIpLFxuICAgIHByb3RvY29sOiB6b2RfMS56LnN0cmluZygpLm9wdGlvbmFsKCkuZGVzY3JpYmUoXCJPcHRpb25hbDogUHJvdG9jb2wgdG8gZmlsdGVyIHZhdWx0cyBieVwiKSxcbiAgICBuZXR3b3JrOiBOZXR3b3JrU2NoZW1hLm9wdGlvbmFsKCkuZGVzY3JpYmUoXCJPcHRpb25hbDogTmV0d29yayBuYW1lIHRvIGZpbHRlciB2YXVsdHMgYnkuIFN1cHBvcnRlZCBuZXR3b3JrczogbWFpbm5ldCwgYXJiaXRydW0sIG9wdGltaXNtLCBwb2x5Z29uLCBiYXNlLCBnbm9zaXMsIHVuaWNoYWluXCIpLFxuICAgIG1pblR2bDogem9kXzEuei5udW1iZXIoKS5vcHRpb25hbCgpLmRlc2NyaWJlKFwiT3B0aW9uYWw6IE1pbmltdW0gVFZMIHRvIGZpbHRlciB2YXVsdHMgYnlcIiksXG4gICAgc29ydDogem9kXzEuelxuICAgICAgICAub2JqZWN0KHtcbiAgICAgICAgZmllbGQ6IHpvZF8xLnouZW51bShbXCJ0dmxcIiwgXCJhcHlcIiwgXCJuYW1lXCJdKS5vcHRpb25hbCgpLmRlc2NyaWJlKFwiU29ydCBmaWVsZFwiKSxcbiAgICAgICAgZGlyZWN0aW9uOiB6b2RfMS56LmVudW0oW1wiYXNjXCIsIFwiZGVzY1wiXSkub3B0aW9uYWwoKS5kZXNjcmliZShcIlNvcnQgZGlyZWN0aW9uXCIpLFxuICAgIH0pXG4gICAgICAgIC5vcHRpb25hbCgpXG4gICAgICAgIC5kZXNjcmliZShcIlNvcnQgb3B0aW9uc1wiKSxcbiAgICB0YWtlOiB6b2RfMS56Lm51bWJlcigpLm9wdGlvbmFsKCkuZGVzY3JpYmUoXCJPcHRpb25hbDogTGltaXQgdGhlIG51bWJlciBvZiByZXN1bHRzXCIpLFxuICAgIHBhZ2U6IHpvZF8xLnoubnVtYmVyKCkub3B0aW9uYWwoKS5kZXNjcmliZShcIk9wdGlvbmFsOiBQYWdlIG51bWJlclwiKSxcbn0pO1xuLyoqXG4gKiBCYXNlIHRyYW5zYWN0aW9uIHBhcmFtcyBzY2hlbWEuXG4gKi9cbmNvbnN0IFRyYW5zYWN0aW9uQWN0aW9uU2NoZW1hID0gem9kXzEuei5vYmplY3Qoe1xuICAgIHZhdWx0QWRkcmVzczogem9kXzEuei5zdHJpbmcoKS5kZXNjcmliZShcIlRoZSBhZGRyZXNzIG9mIHRoZSB2YXVsdCB0byBpbnRlcmFjdCB3aXRoXCIpLFxuICAgIGFzc2V0QWRkcmVzczogem9kXzEuei5zdHJpbmcoKS5kZXNjcmliZShcIlRoZSBhZGRyZXNzIG9mIHRoZSB2YXVsdCdzIHVuZGVybHlpbmcgdG9rZW5cIiksXG4gICAgbmV0d29yazogTmV0d29ya1NjaGVtYS5kZXNjcmliZShcIlRoZSBuZXR3b3JrIG9mIHRoZSB2YXVsdFwiKSxcbiAgICBhbW91bnQ6IHpvZF8xLnoubnVtYmVyKCkuZGVzY3JpYmUoXCJUaGUgYW1vdW50IG9mIGFzc2V0cyB0byB1c2VcIiksXG59KTtcbmV4cG9ydHMuZGVwb3NpdEFjdGlvblNjaGVtYSA9IFRyYW5zYWN0aW9uQWN0aW9uU2NoZW1hO1xuZXhwb3J0cy5yZWRlZW1BY3Rpb25TY2hlbWEgPSBUcmFuc2FjdGlvbkFjdGlvblNjaGVtYS5leHRlbmQoe1xuICAgIGFsbDogem9kXzEuei5ib29sZWFuKCkub3B0aW9uYWwoKS5kZXNjcmliZShcIlNob3VsZCByZWRlZW0gYWxsIGFzc2V0c1wiKSxcbn0pO1xuZXhwb3J0cy5jbGFpbUFjdGlvblNjaGVtYSA9IFRyYW5zYWN0aW9uQWN0aW9uU2NoZW1hLm9taXQoe1xuICAgIGFtb3VudDogdHJ1ZSxcbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/vaultsfyi/schemas.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/vaultsfyi/utils.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/vaultsfyi/utils.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getVaultsLink = getVaultsLink;\nexports.executeActions = executeActions;\nexports.createSearchParams = createSearchParams;\nexports.parseAssetAmount = parseAssetAmount;\nconst viem_1 = __webpack_require__(/*! viem */ \"(rsc)/./node_modules/viem/_cjs/index.js\");\n/**\n * Get the link to the vaults.fyi page for a vault\n *\n * @param vault - The vault\n * @returns The link to the vaults.fyi page\n */\nfunction getVaultsLink(vault) {\n    if (vault.isTransactional) {\n        return `https://app.vaults.fyi/opportunity/${vault.network}/${vault.address}`;\n    }\n    else {\n        return `https://analytics.vaults.fyi/vaults/${vault.network}/${vault.address}`;\n    }\n}\n/**\n * Execute a list of actions\n *\n * @param wallet - The wallet provider\n * @param actions - The list of actions to execute\n * @returns nothing\n */\nasync function executeActions(wallet, actions) {\n    for (let i = actions.currentActionIndex; i < actions.actions.length; i++) {\n        const action = actions.actions[i];\n        const txHash = await wallet.sendTransaction({\n            ...action.tx,\n            value: action.tx.value ? BigInt(action.tx.value) : undefined,\n        });\n        await wallet.waitForTransactionReceipt(txHash);\n    }\n}\n/**\n * Create a URLSearchParams object from an object\n *\n * @param obj - The object to convert\n * @returns The URLSearchParams object\n */\nfunction createSearchParams(obj) {\n    const params = new URLSearchParams();\n    for (const key in obj) {\n        if (obj[key] !== undefined) {\n            params.append(key, obj[key].toString());\n        }\n    }\n    return params;\n}\n/**\n * Parse an asset amount with decimals\n *\n * @param wallet - The wallet provider\n * @param assetAddress - The address of the asset\n * @param amount - The amount to parse\n * @returns The parsed amount\n */\nasync function parseAssetAmount(wallet, assetAddress, amount) {\n    const decimals = await wallet.readContract({\n        address: assetAddress,\n        abi: viem_1.erc20Abi,\n        functionName: \"decimals\",\n    });\n    return Math.floor(amount * 10 ** decimals);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy92YXVsdHNmeWkvdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCO0FBQ3JCLHNCQUFzQjtBQUN0QiwwQkFBMEI7QUFDMUIsd0JBQXdCO0FBQ3hCLGVBQWUsbUJBQU8sQ0FBQyxxREFBTTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELGNBQWMsR0FBRyxjQUFjO0FBQ3BGO0FBQ0E7QUFDQSxzREFBc0QsY0FBYyxHQUFHLGNBQWM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsNEJBQTRCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXJ2aXZhbC1mdW4vLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy92YXVsdHNmeWkvdXRpbHMuanM/ZWM5MSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0VmF1bHRzTGluayA9IGdldFZhdWx0c0xpbms7XG5leHBvcnRzLmV4ZWN1dGVBY3Rpb25zID0gZXhlY3V0ZUFjdGlvbnM7XG5leHBvcnRzLmNyZWF0ZVNlYXJjaFBhcmFtcyA9IGNyZWF0ZVNlYXJjaFBhcmFtcztcbmV4cG9ydHMucGFyc2VBc3NldEFtb3VudCA9IHBhcnNlQXNzZXRBbW91bnQ7XG5jb25zdCB2aWVtXzEgPSByZXF1aXJlKFwidmllbVwiKTtcbi8qKlxuICogR2V0IHRoZSBsaW5rIHRvIHRoZSB2YXVsdHMuZnlpIHBhZ2UgZm9yIGEgdmF1bHRcbiAqXG4gKiBAcGFyYW0gdmF1bHQgLSBUaGUgdmF1bHRcbiAqIEByZXR1cm5zIFRoZSBsaW5rIHRvIHRoZSB2YXVsdHMuZnlpIHBhZ2VcbiAqL1xuZnVuY3Rpb24gZ2V0VmF1bHRzTGluayh2YXVsdCkge1xuICAgIGlmICh2YXVsdC5pc1RyYW5zYWN0aW9uYWwpIHtcbiAgICAgICAgcmV0dXJuIGBodHRwczovL2FwcC52YXVsdHMuZnlpL29wcG9ydHVuaXR5LyR7dmF1bHQubmV0d29ya30vJHt2YXVsdC5hZGRyZXNzfWA7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gYGh0dHBzOi8vYW5hbHl0aWNzLnZhdWx0cy5meWkvdmF1bHRzLyR7dmF1bHQubmV0d29ya30vJHt2YXVsdC5hZGRyZXNzfWA7XG4gICAgfVxufVxuLyoqXG4gKiBFeGVjdXRlIGEgbGlzdCBvZiBhY3Rpb25zXG4gKlxuICogQHBhcmFtIHdhbGxldCAtIFRoZSB3YWxsZXQgcHJvdmlkZXJcbiAqIEBwYXJhbSBhY3Rpb25zIC0gVGhlIGxpc3Qgb2YgYWN0aW9ucyB0byBleGVjdXRlXG4gKiBAcmV0dXJucyBub3RoaW5nXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGV4ZWN1dGVBY3Rpb25zKHdhbGxldCwgYWN0aW9ucykge1xuICAgIGZvciAobGV0IGkgPSBhY3Rpb25zLmN1cnJlbnRBY3Rpb25JbmRleDsgaSA8IGFjdGlvbnMuYWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBhY3Rpb24gPSBhY3Rpb25zLmFjdGlvbnNbaV07XG4gICAgICAgIGNvbnN0IHR4SGFzaCA9IGF3YWl0IHdhbGxldC5zZW5kVHJhbnNhY3Rpb24oe1xuICAgICAgICAgICAgLi4uYWN0aW9uLnR4LFxuICAgICAgICAgICAgdmFsdWU6IGFjdGlvbi50eC52YWx1ZSA/IEJpZ0ludChhY3Rpb24udHgudmFsdWUpIDogdW5kZWZpbmVkLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgd2FsbGV0LndhaXRGb3JUcmFuc2FjdGlvblJlY2VpcHQodHhIYXNoKTtcbiAgICB9XG59XG4vKipcbiAqIENyZWF0ZSBhIFVSTFNlYXJjaFBhcmFtcyBvYmplY3QgZnJvbSBhbiBvYmplY3RcbiAqXG4gKiBAcGFyYW0gb2JqIC0gVGhlIG9iamVjdCB0byBjb252ZXJ0XG4gKiBAcmV0dXJucyBUaGUgVVJMU2VhcmNoUGFyYW1zIG9iamVjdFxuICovXG5mdW5jdGlvbiBjcmVhdGVTZWFyY2hQYXJhbXMob2JqKSB7XG4gICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgICAgICBpZiAob2JqW2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChrZXksIG9ialtrZXldLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXJhbXM7XG59XG4vKipcbiAqIFBhcnNlIGFuIGFzc2V0IGFtb3VudCB3aXRoIGRlY2ltYWxzXG4gKlxuICogQHBhcmFtIHdhbGxldCAtIFRoZSB3YWxsZXQgcHJvdmlkZXJcbiAqIEBwYXJhbSBhc3NldEFkZHJlc3MgLSBUaGUgYWRkcmVzcyBvZiB0aGUgYXNzZXRcbiAqIEBwYXJhbSBhbW91bnQgLSBUaGUgYW1vdW50IHRvIHBhcnNlXG4gKiBAcmV0dXJucyBUaGUgcGFyc2VkIGFtb3VudFxuICovXG5hc3luYyBmdW5jdGlvbiBwYXJzZUFzc2V0QW1vdW50KHdhbGxldCwgYXNzZXRBZGRyZXNzLCBhbW91bnQpIHtcbiAgICBjb25zdCBkZWNpbWFscyA9IGF3YWl0IHdhbGxldC5yZWFkQ29udHJhY3Qoe1xuICAgICAgICBhZGRyZXNzOiBhc3NldEFkZHJlc3MsXG4gICAgICAgIGFiaTogdmllbV8xLmVyYzIwQWJpLFxuICAgICAgICBmdW5jdGlvbk5hbWU6IFwiZGVjaW1hbHNcIixcbiAgICB9KTtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihhbW91bnQgKiAxMCAqKiBkZWNpbWFscyk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/vaultsfyi/utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/vaultsfyi/vaultsfyiActionProvider.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/vaultsfyi/vaultsfyiActionProvider.js ***!
  \****************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Vaultsfyi Action Provider\n *\n * This file contains the implementation of the VaultsfyiActionProvider,\n * which provides actions for vaultsfyi operations.\n *\n * @module vaultsfyi\n */\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.vaultsfyiActionProvider = exports.VaultsfyiActionProvider = void 0;\nconst zod_1 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/lib/index.js\");\nconst actionProvider_1 = __webpack_require__(/*! ../actionProvider */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/actionProvider.js\");\nconst actionDecorator_1 = __webpack_require__(/*! ../actionDecorator */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/actionDecorator.js\");\nconst wallet_providers_1 = __webpack_require__(/*! ../../wallet-providers */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/wallet-providers/index.js\");\nconst schemas_1 = __webpack_require__(/*! ./schemas */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/vaultsfyi/schemas.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/vaultsfyi/utils.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/vaultsfyi/constants.js\");\nconst actions_1 = __webpack_require__(/*! ./api/actions */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/vaultsfyi/api/actions.js\");\nconst vaults_1 = __webpack_require__(/*! ./api/vaults */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/vaultsfyi/api/vaults.js\");\n/**\n * VaultsfyiActionProvider provides actions for vaultsfyi operations.\n *\n * @description\n * This provider is designed to work with EvmWalletProvider for blockchain interactions.\n * It supports all evm networks.\n */\nclass VaultsfyiActionProvider extends actionProvider_1.ActionProvider {\n    /**\n     * Constructor for the VaultsfyiActionProvider.\n     *\n     * @param config - Configuration options for the provider\n     */\n    constructor(config = {}) {\n        super(\"vaultsfyi\", []);\n        const apiKey = config.apiKey || process.env.VAULTSFYI_API_KEY;\n        if (!apiKey) {\n            throw new Error(\"VAULTSFYI_API_KEY is not configured.\");\n        }\n        this.apiKey = apiKey;\n    }\n    /**\n     * vaults action\n     *\n     * @param wallet - The wallet provider instance for blockchain interactions\n     * @param args - Input arguments: token, network, transactionalOnly...\n     * @returns A list of vaults.\n     */\n    async vaults(wallet, args) {\n        const vaults = await (0, vaults_1.fetchVaults)(args, this.apiKey);\n        if (\"error\" in vaults) {\n            return `Failed to fetch vaults: ${vaults.error}, ${vaults.message}`;\n        }\n        if (args.protocol && !vaults.find(vault => vault.protocol === args.protocol)) {\n            const supportedProtocols = vaults\n                .map(vault => vault.protocol)\n                .filter((value, index, self) => self.indexOf(value) === index);\n            return `Protocol ${args.protocol} is not supported. Supported protocols are: ${supportedProtocols.join(\", \")}`;\n        }\n        const transformedVaults = vaults.map(vault => ({\n            name: vault.name,\n            address: vault.address,\n            network: vault.network,\n            protocol: vault.protocol,\n            tvlInUsd: Number(vault.tvlDetails.tvlUsd),\n            apy: {\n                base: vault.apy.base[\"7day\"] / 100,\n                rewards: vault.apy.rewards?.[\"7day\"] ? vault.apy.rewards[\"7day\"] / 100 : undefined,\n                total: vault.apy.total[\"7day\"] / 100,\n            },\n            token: {\n                address: vault.token.assetAddress,\n                name: vault.token.name,\n                symbol: vault.token.symbol,\n            },\n            link: (0, utils_1.getVaultsLink)(vault),\n        }));\n        const filteredVaults = transformedVaults.filter(vault => args.protocol ? vault.protocol === args.protocol : true);\n        const sortedVaults = filteredVaults.sort((a, b) => {\n            if (args.sort?.field === \"tvl\") {\n                return args.sort.direction === \"asc\" ? a.tvlInUsd - b.tvlInUsd : b.tvlInUsd - a.tvlInUsd;\n            }\n            else if (args.sort?.field === \"apy\") {\n                return args.sort.direction === \"asc\"\n                    ? a.apy.total - b.apy.total\n                    : b.apy.total - a.apy.total;\n            }\n            return a.name.localeCompare(b.name);\n        });\n        const take = args.take || 10;\n        const page = args.page || 1;\n        const start = (page - 1) * take;\n        const end = start + take;\n        const results = sortedVaults.slice(start, end);\n        return JSON.stringify({\n            totalResults: sortedVaults.length,\n            nextPage: end < sortedVaults.length,\n            results,\n        });\n    }\n    /**\n     * Deposit action\n     *\n     * @param wallet - The wallet provider instance for blockchain interactions\n     * @param args - Input arguments\n     * @returns A result message\n     */\n    async deposit(wallet, args) {\n        const actions = await (0, actions_1.fetchVaultActions)({\n            action: \"deposit\",\n            args: { ...args, amount: await (0, utils_1.parseAssetAmount)(wallet, args.assetAddress, args.amount) },\n            sender: wallet.getAddress(),\n            apiKey: this.apiKey,\n        });\n        if (\"error\" in actions) {\n            return `Failed to fetch deposit transactions: ${actions.error}, ${actions.message}`;\n        }\n        await (0, utils_1.executeActions)(wallet, actions);\n        return \"Deposit successful\";\n    }\n    /**\n     * Redeem action\n     *\n     * @param wallet - The wallet provider instance for blockchain interactions\n     * @param args - Input arguments\n     * @returns A result message\n     */\n    async redeem(wallet, args) {\n        const actions = await (0, actions_1.fetchVaultActions)({\n            action: \"redeem\",\n            args: { ...args, amount: await (0, utils_1.parseAssetAmount)(wallet, args.assetAddress, args.amount) },\n            sender: wallet.getAddress(),\n            apiKey: this.apiKey,\n        });\n        if (\"error\" in actions) {\n            return `Failed to fetch redeem transactions: ${actions.error}, ${actions.message}`;\n        }\n        await (0, utils_1.executeActions)(wallet, actions);\n        return \"Redeem successful\";\n    }\n    /**\n     * Claim rewards action\n     *\n     * @param wallet - The wallet provider instance for blockchain interactions\n     * @param args - Input arguments\n     * @returns A result message\n     */\n    async claim(wallet, args) {\n        const actions = await (0, actions_1.fetchVaultActions)({\n            action: \"claim-rewards\",\n            args,\n            sender: wallet.getAddress(),\n            apiKey: this.apiKey,\n        });\n        if (\"error\" in actions) {\n            return `Failed to fetch claim transactions: ${actions.error}, ${actions.message}`;\n        }\n        await (0, utils_1.executeActions)(wallet, actions);\n        return \"Claim successful\";\n    }\n    /**\n     * Returns the users wallet token balances.\n     *\n     * @param wallet - The wallet provider instance for blockchain interactions\n     * @returns A record of the users balances\n     */\n    async balances(wallet) {\n        const params = new URLSearchParams({\n            account: wallet.getAddress(),\n        });\n        const result = await fetch(`${constants_1.VAULTS_API_URL}/portfolio/wallet-balances?${params.toString()}`, {\n            method: \"GET\",\n            headers: {\n                \"x-api-key\": this.apiKey,\n            },\n        });\n        const balances = (await result.json());\n        if (\"error\" in balances) {\n            return `Failed to fetch wallet balances: ${balances.error}, ${balances.message}`;\n        }\n        const entries = Object.entries(balances).map(([network, balances]) => {\n            return [\n                network,\n                balances.map(balance => ({\n                    address: balance.address,\n                    name: balance.name,\n                    symbol: balance.symbol,\n                    balance: Number(balance.balance) / 10 ** balance.decimals,\n                })),\n            ];\n        });\n        return JSON.stringify(Object.fromEntries(entries));\n    }\n    /**\n     * Returns the users positions.\n     *\n     * @param wallet - The wallet provider instance for blockchain interactions\n     * @returns A record of the users positions\n     */\n    async positions(wallet) {\n        const result = await fetch(`${constants_1.VAULTS_API_URL}/portfolio/positions/${wallet.getAddress()}`, {\n            method: \"GET\",\n            headers: {\n                \"x-api-key\": this.apiKey,\n            },\n        });\n        const positions = (await result.json());\n        if (\"error\" in positions) {\n            return `Failed to fetch positions: ${positions.error}, ${positions.message}`;\n        }\n        const entries = Object.entries(positions).map(([network, positions]) => {\n            return [\n                network,\n                positions.map(position => ({\n                    name: position.vaultName,\n                    vaultAddress: position.vaultAddress,\n                    asset: {\n                        address: position.asset.assetAddress,\n                        name: position.asset.name,\n                        symbol: position.asset.symbol,\n                    },\n                    underlyingTokenBalance: Number(position.balanceNative) / 10 ** position.asset.decimals,\n                    lpTokenBalance: Number(position.balanceLp) / 10 ** position.asset.decimals,\n                    unclaimedRewards: Number(position.unclaimedUsd) > 0,\n                    apy: {\n                        base: position.apy.base / 100,\n                        rewards: position.apy.rewards / 100,\n                        total: position.apy.total / 100,\n                    },\n                })),\n            ];\n        });\n        return JSON.stringify(Object.fromEntries(entries));\n    }\n    /**\n     * Checks if this provider supports the given network.\n     *\n     * @param network - The network to check support for\n     * @returns True if the network is supported\n     */\n    supportsNetwork(network) {\n        return (network.protocolFamily == \"evm\" &&\n            (network.chainId ? Object.keys(constants_1.VAULTSFYI_SUPPORTED_CHAINS).includes(network.chainId) : false));\n    }\n}\nexports.VaultsfyiActionProvider = VaultsfyiActionProvider;\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"vaults\",\n        description: `\n      This action returns a list of available vaults.\n      Small vaults (under 100k TVL) are probably best avoided as they may be more risky. Unless the user is looking for high-risk, high-reward opportunities, don't include them.\n      When the user asks for best vaults, optimize for apy, and if the user asks for safest/reliable vaults, optimize for TVL.\n      Try to take a reasonable number of results so its easier to analyze the data.\n      Format result apys as: x% (base: x%, rewards: x%) if rewards apy is available, otherwise: x%\n      Examples:\n      User: \"Show me the best vaults\"\n      args: { sort: { field: 'apy', direction: 'desc' }, take: 5 }\n      User: \"Show me the safest vaults\"\n      args: { sort: { field: 'tvl', direction: 'desc' }, take: 5 }\n      User: \"Show me the best vaults on Arbitrum\"\n      args: { network: 'arbitrum', sort: { field: 'apy', direction: 'desc' }, take: 5 }\n      User: \"I want to earn yield on my usdc on base!\"\n      args: { token: 'usdc', network: 'base', sort: { field: 'apy', direction: 'desc' }, take: 5 }\n      User: \"What are some of the most profitable degen vaults on polygon\"\n      args: { network: 'polygon', sort: { field: 'apy', direction: 'desc' }, take: 5, minTvl: 0 }\n      User: \"Show me some more of those\"\n      args: { network: 'polygon', sort: { field: 'apy', direction: 'desc' }, take: 5, minTvl: 0, page: 2 }\n    `,\n        schema: schemas_1.VaultsActionSchema,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [wallet_providers_1.EvmWalletProvider, void 0]),\n    __metadata(\"design:returntype\", Promise)\n], VaultsfyiActionProvider.prototype, \"vaults\", null);\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"deposit\",\n        description: `\n      This action deposits assets into a selected vault. Before depositing make sure you have the required assets in your wallet using the wallet-balances action.\n      Even if you received the balance from some other source, double-check the user balance.\n      Use examples:\n      User: \"Deposit 1000 USDC into the vault\"\n      actions:\n       - check wallet balance for USDC\n       - deposit USDC into the vault if balance is sufficient\n      User: \"I want more yield on my DAI\"\n      actions:\n       - check positions that the user already has for dai\n       - find high yield vaults for dai\n       - if there is a vault with higher yield available, redeem from the current vault and deposit into the new vault\n       - if users dai wasn't in a vault to begin with, deposit into the new vault\n      User: \"I want to create a diversified yield strategy\"\n      actions:\n       - check wallet balances for all assets\n       - find a couple vaults for each asset, preferably from different protocols\n       - create a diversified strategy using the users assets\n       - propose the strategy to the user before executing\n    `,\n        schema: schemas_1.depositActionSchema,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [wallet_providers_1.EvmWalletProvider, void 0]),\n    __metadata(\"design:returntype\", Promise)\n], VaultsfyiActionProvider.prototype, \"deposit\", null);\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"redeem\",\n        description: `\n      This action redeems assets from a selected vault. Before redeeming make sure you have the required lp tokens in your wallet using the positions action.\n      Even if you received the lp tokens from some other source, double-check the amount before redeeming.\n      lp tokens aren't always 1:1 with the underlying asset, so make sure to check the amount of lp tokens you have before redeeming even if you know the amount of the underlying asset you want to redeem.\n    `,\n        schema: schemas_1.redeemActionSchema,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [wallet_providers_1.EvmWalletProvider, void 0]),\n    __metadata(\"design:returntype\", Promise)\n], VaultsfyiActionProvider.prototype, \"redeem\", null);\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"claim_rewards\",\n        description: `\n      This action claims rewards from a selected vault.\n      assetAddress is the address of the vaults underlying token.\n      If you're not sure what vaults have rewards claimable, use the positions action.\n    `,\n        schema: schemas_1.claimActionSchema,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [wallet_providers_1.EvmWalletProvider, void 0]),\n    __metadata(\"design:returntype\", Promise)\n], VaultsfyiActionProvider.prototype, \"claim\", null);\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"user_wallet_balances\",\n        description: `\n    This action returns the users wallet balances of all tokens supported by vaults.fyi. Useful when you don't know token addresses but want to check if the user has an asset.\n    Example queries:\n    User: \"What tokens do I have?\"\n    User: \"What tokens do I have on Arbitrum?\"\n    User: \"Whats my balance of USDC?\"\n    `,\n        schema: zod_1.z.object({}),\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [wallet_providers_1.EvmWalletProvider]),\n    __metadata(\"design:returntype\", Promise)\n], VaultsfyiActionProvider.prototype, \"balances\", null);\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"positions\",\n        description: `\n      This action returns the users positions in vaults.\n      Example queries:\n      User: \"Show me my positions\"\n      User: \"What vaults am i invested in?\"\n      User: \"What's my average yield?\"\n      User: \"What vaults do I have rewards in?\"\n    `,\n        schema: zod_1.z.object({}),\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [wallet_providers_1.EvmWalletProvider]),\n    __metadata(\"design:returntype\", Promise)\n], VaultsfyiActionProvider.prototype, \"positions\", null);\n/**\n * Factory function to create a new VaultsfyiActionProvider instance.\n *\n * @param config - Configuration options for the provider\n * @returns A new VaultsfyiActionProvider instance\n */\nconst vaultsfyiActionProvider = (config) => new VaultsfyiActionProvider(config);\nexports.vaultsfyiActionProvider = vaultsfyiActionProvider;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy92YXVsdHNmeWkvdmF1bHRzZnlpQWN0aW9uUHJvdmlkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFFBQVE7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwrQkFBK0IsR0FBRywrQkFBK0I7QUFDakUsY0FBYyxtQkFBTyxDQUFDLGtEQUFLO0FBQzNCLHlCQUF5QixtQkFBTyxDQUFDLDBHQUFtQjtBQUNwRCwwQkFBMEIsbUJBQU8sQ0FBQyw0R0FBb0I7QUFDdEQsMkJBQTJCLG1CQUFPLENBQUMsc0dBQXdCO0FBQzNELGtCQUFrQixtQkFBTyxDQUFDLHFHQUFXO0FBQ3JDLGdCQUFnQixtQkFBTyxDQUFDLGlHQUFTO0FBQ2pDLG9CQUFvQixtQkFBTyxDQUFDLHlHQUFhO0FBQ3pDLGtCQUFrQixtQkFBTyxDQUFDLDZHQUFlO0FBQ3pDLGlCQUFpQixtQkFBTyxDQUFDLDJHQUFjO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsYUFBYSxJQUFJLGVBQWU7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixlQUFlLDZDQUE2Qyw4QkFBOEI7QUFDekg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDhGQUE4RjtBQUNsSDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsNERBQTRELGNBQWMsSUFBSSxnQkFBZ0I7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw4RkFBOEY7QUFDbEg7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLDJEQUEyRCxjQUFjLElBQUksZ0JBQWdCO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSwwREFBMEQsY0FBYyxJQUFJLGdCQUFnQjtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxzQ0FBc0MsMkJBQTJCLDZCQUE2QixrQkFBa0I7QUFDaEg7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0EsdURBQXVELGVBQWUsSUFBSSxpQkFBaUI7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQywyQkFBMkIsdUJBQXVCLG9CQUFvQjtBQUM1RztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSxpREFBaUQsZ0JBQWdCLElBQUksa0JBQWtCO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVEsaUNBQWlDO0FBQ3ZEO0FBQ0EsY0FBYyxRQUFRLGlDQUFpQztBQUN2RDtBQUNBLGNBQWMsNkJBQTZCLGlDQUFpQztBQUM1RTtBQUNBLGNBQWMsd0NBQXdDLGlDQUFpQztBQUN2RjtBQUNBLGNBQWMsNEJBQTRCLGlDQUFpQztBQUMzRTtBQUNBLGNBQWMsNEJBQTRCLGlDQUFpQztBQUMzRTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3Vydml2YWwtZnVuLy4vbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9hZ2VudGtpdC9kaXN0L2FjdGlvbi1wcm92aWRlcnMvdmF1bHRzZnlpL3ZhdWx0c2Z5aUFjdGlvblByb3ZpZGVyLmpzP2JmOGIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIFZhdWx0c2Z5aSBBY3Rpb24gUHJvdmlkZXJcbiAqXG4gKiBUaGlzIGZpbGUgY29udGFpbnMgdGhlIGltcGxlbWVudGF0aW9uIG9mIHRoZSBWYXVsdHNmeWlBY3Rpb25Qcm92aWRlcixcbiAqIHdoaWNoIHByb3ZpZGVzIGFjdGlvbnMgZm9yIHZhdWx0c2Z5aSBvcGVyYXRpb25zLlxuICpcbiAqIEBtb2R1bGUgdmF1bHRzZnlpXG4gKi9cbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZhdWx0c2Z5aUFjdGlvblByb3ZpZGVyID0gZXhwb3J0cy5WYXVsdHNmeWlBY3Rpb25Qcm92aWRlciA9IHZvaWQgMDtcbmNvbnN0IHpvZF8xID0gcmVxdWlyZShcInpvZFwiKTtcbmNvbnN0IGFjdGlvblByb3ZpZGVyXzEgPSByZXF1aXJlKFwiLi4vYWN0aW9uUHJvdmlkZXJcIik7XG5jb25zdCBhY3Rpb25EZWNvcmF0b3JfMSA9IHJlcXVpcmUoXCIuLi9hY3Rpb25EZWNvcmF0b3JcIik7XG5jb25zdCB3YWxsZXRfcHJvdmlkZXJzXzEgPSByZXF1aXJlKFwiLi4vLi4vd2FsbGV0LXByb3ZpZGVyc1wiKTtcbmNvbnN0IHNjaGVtYXNfMSA9IHJlcXVpcmUoXCIuL3NjaGVtYXNcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IGFjdGlvbnNfMSA9IHJlcXVpcmUoXCIuL2FwaS9hY3Rpb25zXCIpO1xuY29uc3QgdmF1bHRzXzEgPSByZXF1aXJlKFwiLi9hcGkvdmF1bHRzXCIpO1xuLyoqXG4gKiBWYXVsdHNmeWlBY3Rpb25Qcm92aWRlciBwcm92aWRlcyBhY3Rpb25zIGZvciB2YXVsdHNmeWkgb3BlcmF0aW9ucy5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFRoaXMgcHJvdmlkZXIgaXMgZGVzaWduZWQgdG8gd29yayB3aXRoIEV2bVdhbGxldFByb3ZpZGVyIGZvciBibG9ja2NoYWluIGludGVyYWN0aW9ucy5cbiAqIEl0IHN1cHBvcnRzIGFsbCBldm0gbmV0d29ya3MuXG4gKi9cbmNsYXNzIFZhdWx0c2Z5aUFjdGlvblByb3ZpZGVyIGV4dGVuZHMgYWN0aW9uUHJvdmlkZXJfMS5BY3Rpb25Qcm92aWRlciB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIHRoZSBWYXVsdHNmeWlBY3Rpb25Qcm92aWRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb25maWcgLSBDb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBwcm92aWRlclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKFwidmF1bHRzZnlpXCIsIFtdKTtcbiAgICAgICAgY29uc3QgYXBpS2V5ID0gY29uZmlnLmFwaUtleSB8fCBwcm9jZXNzLmVudi5WQVVMVFNGWUlfQVBJX0tFWTtcbiAgICAgICAgaWYgKCFhcGlLZXkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlZBVUxUU0ZZSV9BUElfS0VZIGlzIG5vdCBjb25maWd1cmVkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFwaUtleSA9IGFwaUtleTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogdmF1bHRzIGFjdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIHdhbGxldCAtIFRoZSB3YWxsZXQgcHJvdmlkZXIgaW5zdGFuY2UgZm9yIGJsb2NrY2hhaW4gaW50ZXJhY3Rpb25zXG4gICAgICogQHBhcmFtIGFyZ3MgLSBJbnB1dCBhcmd1bWVudHM6IHRva2VuLCBuZXR3b3JrLCB0cmFuc2FjdGlvbmFsT25seS4uLlxuICAgICAqIEByZXR1cm5zIEEgbGlzdCBvZiB2YXVsdHMuXG4gICAgICovXG4gICAgYXN5bmMgdmF1bHRzKHdhbGxldCwgYXJncykge1xuICAgICAgICBjb25zdCB2YXVsdHMgPSBhd2FpdCAoMCwgdmF1bHRzXzEuZmV0Y2hWYXVsdHMpKGFyZ3MsIHRoaXMuYXBpS2V5KTtcbiAgICAgICAgaWYgKFwiZXJyb3JcIiBpbiB2YXVsdHMpIHtcbiAgICAgICAgICAgIHJldHVybiBgRmFpbGVkIHRvIGZldGNoIHZhdWx0czogJHt2YXVsdHMuZXJyb3J9LCAke3ZhdWx0cy5tZXNzYWdlfWA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFyZ3MucHJvdG9jb2wgJiYgIXZhdWx0cy5maW5kKHZhdWx0ID0+IHZhdWx0LnByb3RvY29sID09PSBhcmdzLnByb3RvY29sKSkge1xuICAgICAgICAgICAgY29uc3Qgc3VwcG9ydGVkUHJvdG9jb2xzID0gdmF1bHRzXG4gICAgICAgICAgICAgICAgLm1hcCh2YXVsdCA9PiB2YXVsdC5wcm90b2NvbClcbiAgICAgICAgICAgICAgICAuZmlsdGVyKCh2YWx1ZSwgaW5kZXgsIHNlbGYpID0+IHNlbGYuaW5kZXhPZih2YWx1ZSkgPT09IGluZGV4KTtcbiAgICAgICAgICAgIHJldHVybiBgUHJvdG9jb2wgJHthcmdzLnByb3RvY29sfSBpcyBub3Qgc3VwcG9ydGVkLiBTdXBwb3J0ZWQgcHJvdG9jb2xzIGFyZTogJHtzdXBwb3J0ZWRQcm90b2NvbHMuam9pbihcIiwgXCIpfWA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHJhbnNmb3JtZWRWYXVsdHMgPSB2YXVsdHMubWFwKHZhdWx0ID0+ICh7XG4gICAgICAgICAgICBuYW1lOiB2YXVsdC5uYW1lLFxuICAgICAgICAgICAgYWRkcmVzczogdmF1bHQuYWRkcmVzcyxcbiAgICAgICAgICAgIG5ldHdvcms6IHZhdWx0Lm5ldHdvcmssXG4gICAgICAgICAgICBwcm90b2NvbDogdmF1bHQucHJvdG9jb2wsXG4gICAgICAgICAgICB0dmxJblVzZDogTnVtYmVyKHZhdWx0LnR2bERldGFpbHMudHZsVXNkKSxcbiAgICAgICAgICAgIGFweToge1xuICAgICAgICAgICAgICAgIGJhc2U6IHZhdWx0LmFweS5iYXNlW1wiN2RheVwiXSAvIDEwMCxcbiAgICAgICAgICAgICAgICByZXdhcmRzOiB2YXVsdC5hcHkucmV3YXJkcz8uW1wiN2RheVwiXSA/IHZhdWx0LmFweS5yZXdhcmRzW1wiN2RheVwiXSAvIDEwMCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB0b3RhbDogdmF1bHQuYXB5LnRvdGFsW1wiN2RheVwiXSAvIDEwMCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0b2tlbjoge1xuICAgICAgICAgICAgICAgIGFkZHJlc3M6IHZhdWx0LnRva2VuLmFzc2V0QWRkcmVzcyxcbiAgICAgICAgICAgICAgICBuYW1lOiB2YXVsdC50b2tlbi5uYW1lLFxuICAgICAgICAgICAgICAgIHN5bWJvbDogdmF1bHQudG9rZW4uc3ltYm9sLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxpbms6ICgwLCB1dGlsc18xLmdldFZhdWx0c0xpbmspKHZhdWx0KSxcbiAgICAgICAgfSkpO1xuICAgICAgICBjb25zdCBmaWx0ZXJlZFZhdWx0cyA9IHRyYW5zZm9ybWVkVmF1bHRzLmZpbHRlcih2YXVsdCA9PiBhcmdzLnByb3RvY29sID8gdmF1bHQucHJvdG9jb2wgPT09IGFyZ3MucHJvdG9jb2wgOiB0cnVlKTtcbiAgICAgICAgY29uc3Qgc29ydGVkVmF1bHRzID0gZmlsdGVyZWRWYXVsdHMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgICAgaWYgKGFyZ3Muc29ydD8uZmllbGQgPT09IFwidHZsXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJncy5zb3J0LmRpcmVjdGlvbiA9PT0gXCJhc2NcIiA/IGEudHZsSW5Vc2QgLSBiLnR2bEluVXNkIDogYi50dmxJblVzZCAtIGEudHZsSW5Vc2Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhcmdzLnNvcnQ/LmZpZWxkID09PSBcImFweVwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyZ3Muc29ydC5kaXJlY3Rpb24gPT09IFwiYXNjXCJcbiAgICAgICAgICAgICAgICAgICAgPyBhLmFweS50b3RhbCAtIGIuYXB5LnRvdGFsXG4gICAgICAgICAgICAgICAgICAgIDogYi5hcHkudG90YWwgLSBhLmFweS50b3RhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhLm5hbWUubG9jYWxlQ29tcGFyZShiLm5hbWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgdGFrZSA9IGFyZ3MudGFrZSB8fCAxMDtcbiAgICAgICAgY29uc3QgcGFnZSA9IGFyZ3MucGFnZSB8fCAxO1xuICAgICAgICBjb25zdCBzdGFydCA9IChwYWdlIC0gMSkgKiB0YWtlO1xuICAgICAgICBjb25zdCBlbmQgPSBzdGFydCArIHRha2U7XG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBzb3J0ZWRWYXVsdHMuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICB0b3RhbFJlc3VsdHM6IHNvcnRlZFZhdWx0cy5sZW5ndGgsXG4gICAgICAgICAgICBuZXh0UGFnZTogZW5kIDwgc29ydGVkVmF1bHRzLmxlbmd0aCxcbiAgICAgICAgICAgIHJlc3VsdHMsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXBvc2l0IGFjdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIHdhbGxldCAtIFRoZSB3YWxsZXQgcHJvdmlkZXIgaW5zdGFuY2UgZm9yIGJsb2NrY2hhaW4gaW50ZXJhY3Rpb25zXG4gICAgICogQHBhcmFtIGFyZ3MgLSBJbnB1dCBhcmd1bWVudHNcbiAgICAgKiBAcmV0dXJucyBBIHJlc3VsdCBtZXNzYWdlXG4gICAgICovXG4gICAgYXN5bmMgZGVwb3NpdCh3YWxsZXQsIGFyZ3MpIHtcbiAgICAgICAgY29uc3QgYWN0aW9ucyA9IGF3YWl0ICgwLCBhY3Rpb25zXzEuZmV0Y2hWYXVsdEFjdGlvbnMpKHtcbiAgICAgICAgICAgIGFjdGlvbjogXCJkZXBvc2l0XCIsXG4gICAgICAgICAgICBhcmdzOiB7IC4uLmFyZ3MsIGFtb3VudDogYXdhaXQgKDAsIHV0aWxzXzEucGFyc2VBc3NldEFtb3VudCkod2FsbGV0LCBhcmdzLmFzc2V0QWRkcmVzcywgYXJncy5hbW91bnQpIH0sXG4gICAgICAgICAgICBzZW5kZXI6IHdhbGxldC5nZXRBZGRyZXNzKCksXG4gICAgICAgICAgICBhcGlLZXk6IHRoaXMuYXBpS2V5LFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKFwiZXJyb3JcIiBpbiBhY3Rpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gYEZhaWxlZCB0byBmZXRjaCBkZXBvc2l0IHRyYW5zYWN0aW9uczogJHthY3Rpb25zLmVycm9yfSwgJHthY3Rpb25zLm1lc3NhZ2V9YDtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCAoMCwgdXRpbHNfMS5leGVjdXRlQWN0aW9ucykod2FsbGV0LCBhY3Rpb25zKTtcbiAgICAgICAgcmV0dXJuIFwiRGVwb3NpdCBzdWNjZXNzZnVsXCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZGVlbSBhY3Rpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSB3YWxsZXQgLSBUaGUgd2FsbGV0IHByb3ZpZGVyIGluc3RhbmNlIGZvciBibG9ja2NoYWluIGludGVyYWN0aW9uc1xuICAgICAqIEBwYXJhbSBhcmdzIC0gSW5wdXQgYXJndW1lbnRzXG4gICAgICogQHJldHVybnMgQSByZXN1bHQgbWVzc2FnZVxuICAgICAqL1xuICAgIGFzeW5jIHJlZGVlbSh3YWxsZXQsIGFyZ3MpIHtcbiAgICAgICAgY29uc3QgYWN0aW9ucyA9IGF3YWl0ICgwLCBhY3Rpb25zXzEuZmV0Y2hWYXVsdEFjdGlvbnMpKHtcbiAgICAgICAgICAgIGFjdGlvbjogXCJyZWRlZW1cIixcbiAgICAgICAgICAgIGFyZ3M6IHsgLi4uYXJncywgYW1vdW50OiBhd2FpdCAoMCwgdXRpbHNfMS5wYXJzZUFzc2V0QW1vdW50KSh3YWxsZXQsIGFyZ3MuYXNzZXRBZGRyZXNzLCBhcmdzLmFtb3VudCkgfSxcbiAgICAgICAgICAgIHNlbmRlcjogd2FsbGV0LmdldEFkZHJlc3MoKSxcbiAgICAgICAgICAgIGFwaUtleTogdGhpcy5hcGlLZXksXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoXCJlcnJvclwiIGluIGFjdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBgRmFpbGVkIHRvIGZldGNoIHJlZGVlbSB0cmFuc2FjdGlvbnM6ICR7YWN0aW9ucy5lcnJvcn0sICR7YWN0aW9ucy5tZXNzYWdlfWA7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgKDAsIHV0aWxzXzEuZXhlY3V0ZUFjdGlvbnMpKHdhbGxldCwgYWN0aW9ucyk7XG4gICAgICAgIHJldHVybiBcIlJlZGVlbSBzdWNjZXNzZnVsXCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsYWltIHJld2FyZHMgYWN0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gd2FsbGV0IC0gVGhlIHdhbGxldCBwcm92aWRlciBpbnN0YW5jZSBmb3IgYmxvY2tjaGFpbiBpbnRlcmFjdGlvbnNcbiAgICAgKiBAcGFyYW0gYXJncyAtIElucHV0IGFyZ3VtZW50c1xuICAgICAqIEByZXR1cm5zIEEgcmVzdWx0IG1lc3NhZ2VcbiAgICAgKi9cbiAgICBhc3luYyBjbGFpbSh3YWxsZXQsIGFyZ3MpIHtcbiAgICAgICAgY29uc3QgYWN0aW9ucyA9IGF3YWl0ICgwLCBhY3Rpb25zXzEuZmV0Y2hWYXVsdEFjdGlvbnMpKHtcbiAgICAgICAgICAgIGFjdGlvbjogXCJjbGFpbS1yZXdhcmRzXCIsXG4gICAgICAgICAgICBhcmdzLFxuICAgICAgICAgICAgc2VuZGVyOiB3YWxsZXQuZ2V0QWRkcmVzcygpLFxuICAgICAgICAgICAgYXBpS2V5OiB0aGlzLmFwaUtleSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChcImVycm9yXCIgaW4gYWN0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGBGYWlsZWQgdG8gZmV0Y2ggY2xhaW0gdHJhbnNhY3Rpb25zOiAke2FjdGlvbnMuZXJyb3J9LCAke2FjdGlvbnMubWVzc2FnZX1gO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0ICgwLCB1dGlsc18xLmV4ZWN1dGVBY3Rpb25zKSh3YWxsZXQsIGFjdGlvbnMpO1xuICAgICAgICByZXR1cm4gXCJDbGFpbSBzdWNjZXNzZnVsXCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHVzZXJzIHdhbGxldCB0b2tlbiBiYWxhbmNlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB3YWxsZXQgLSBUaGUgd2FsbGV0IHByb3ZpZGVyIGluc3RhbmNlIGZvciBibG9ja2NoYWluIGludGVyYWN0aW9uc1xuICAgICAqIEByZXR1cm5zIEEgcmVjb3JkIG9mIHRoZSB1c2VycyBiYWxhbmNlc1xuICAgICAqL1xuICAgIGFzeW5jIGJhbGFuY2VzKHdhbGxldCkge1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgICAgIGFjY291bnQ6IHdhbGxldC5nZXRBZGRyZXNzKCksXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBmZXRjaChgJHtjb25zdGFudHNfMS5WQVVMVFNfQVBJX1VSTH0vcG9ydGZvbGlvL3dhbGxldC1iYWxhbmNlcz8ke3BhcmFtcy50b1N0cmluZygpfWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICBcIngtYXBpLWtleVwiOiB0aGlzLmFwaUtleSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBiYWxhbmNlcyA9IChhd2FpdCByZXN1bHQuanNvbigpKTtcbiAgICAgICAgaWYgKFwiZXJyb3JcIiBpbiBiYWxhbmNlcykge1xuICAgICAgICAgICAgcmV0dXJuIGBGYWlsZWQgdG8gZmV0Y2ggd2FsbGV0IGJhbGFuY2VzOiAke2JhbGFuY2VzLmVycm9yfSwgJHtiYWxhbmNlcy5tZXNzYWdlfWA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZW50cmllcyA9IE9iamVjdC5lbnRyaWVzKGJhbGFuY2VzKS5tYXAoKFtuZXR3b3JrLCBiYWxhbmNlc10pID0+IHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgbmV0d29yayxcbiAgICAgICAgICAgICAgICBiYWxhbmNlcy5tYXAoYmFsYW5jZSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzOiBiYWxhbmNlLmFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGJhbGFuY2UubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sOiBiYWxhbmNlLnN5bWJvbCxcbiAgICAgICAgICAgICAgICAgICAgYmFsYW5jZTogTnVtYmVyKGJhbGFuY2UuYmFsYW5jZSkgLyAxMCAqKiBiYWxhbmNlLmRlY2ltYWxzLFxuICAgICAgICAgICAgICAgIH0pKSxcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoT2JqZWN0LmZyb21FbnRyaWVzKGVudHJpZXMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdXNlcnMgcG9zaXRpb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHdhbGxldCAtIFRoZSB3YWxsZXQgcHJvdmlkZXIgaW5zdGFuY2UgZm9yIGJsb2NrY2hhaW4gaW50ZXJhY3Rpb25zXG4gICAgICogQHJldHVybnMgQSByZWNvcmQgb2YgdGhlIHVzZXJzIHBvc2l0aW9uc1xuICAgICAqL1xuICAgIGFzeW5jIHBvc2l0aW9ucyh3YWxsZXQpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZmV0Y2goYCR7Y29uc3RhbnRzXzEuVkFVTFRTX0FQSV9VUkx9L3BvcnRmb2xpby9wb3NpdGlvbnMvJHt3YWxsZXQuZ2V0QWRkcmVzcygpfWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICBcIngtYXBpLWtleVwiOiB0aGlzLmFwaUtleSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBwb3NpdGlvbnMgPSAoYXdhaXQgcmVzdWx0Lmpzb24oKSk7XG4gICAgICAgIGlmIChcImVycm9yXCIgaW4gcG9zaXRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gYEZhaWxlZCB0byBmZXRjaCBwb3NpdGlvbnM6ICR7cG9zaXRpb25zLmVycm9yfSwgJHtwb3NpdGlvbnMubWVzc2FnZX1gO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVudHJpZXMgPSBPYmplY3QuZW50cmllcyhwb3NpdGlvbnMpLm1hcCgoW25ldHdvcmssIHBvc2l0aW9uc10pID0+IHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgbmV0d29yayxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbnMubWFwKHBvc2l0aW9uID0+ICh7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHBvc2l0aW9uLnZhdWx0TmFtZSxcbiAgICAgICAgICAgICAgICAgICAgdmF1bHRBZGRyZXNzOiBwb3NpdGlvbi52YXVsdEFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgIGFzc2V0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzOiBwb3NpdGlvbi5hc3NldC5hc3NldEFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBwb3NpdGlvbi5hc3NldC5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sOiBwb3NpdGlvbi5hc3NldC5zeW1ib2wsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHVuZGVybHlpbmdUb2tlbkJhbGFuY2U6IE51bWJlcihwb3NpdGlvbi5iYWxhbmNlTmF0aXZlKSAvIDEwICoqIHBvc2l0aW9uLmFzc2V0LmRlY2ltYWxzLFxuICAgICAgICAgICAgICAgICAgICBscFRva2VuQmFsYW5jZTogTnVtYmVyKHBvc2l0aW9uLmJhbGFuY2VMcCkgLyAxMCAqKiBwb3NpdGlvbi5hc3NldC5kZWNpbWFscyxcbiAgICAgICAgICAgICAgICAgICAgdW5jbGFpbWVkUmV3YXJkczogTnVtYmVyKHBvc2l0aW9uLnVuY2xhaW1lZFVzZCkgPiAwLFxuICAgICAgICAgICAgICAgICAgICBhcHk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhc2U6IHBvc2l0aW9uLmFweS5iYXNlIC8gMTAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV3YXJkczogcG9zaXRpb24uYXB5LnJld2FyZHMgLyAxMDAsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3RhbDogcG9zaXRpb24uYXB5LnRvdGFsIC8gMTAwLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pKSxcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoT2JqZWN0LmZyb21FbnRyaWVzKGVudHJpZXMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoaXMgcHJvdmlkZXIgc3VwcG9ydHMgdGhlIGdpdmVuIG5ldHdvcmsuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmV0d29yayAtIFRoZSBuZXR3b3JrIHRvIGNoZWNrIHN1cHBvcnQgZm9yXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgbmV0d29yayBpcyBzdXBwb3J0ZWRcbiAgICAgKi9cbiAgICBzdXBwb3J0c05ldHdvcmsobmV0d29yaykge1xuICAgICAgICByZXR1cm4gKG5ldHdvcmsucHJvdG9jb2xGYW1pbHkgPT0gXCJldm1cIiAmJlxuICAgICAgICAgICAgKG5ldHdvcmsuY2hhaW5JZCA/IE9iamVjdC5rZXlzKGNvbnN0YW50c18xLlZBVUxUU0ZZSV9TVVBQT1JURURfQ0hBSU5TKS5pbmNsdWRlcyhuZXR3b3JrLmNoYWluSWQpIDogZmFsc2UpKTtcbiAgICB9XG59XG5leHBvcnRzLlZhdWx0c2Z5aUFjdGlvblByb3ZpZGVyID0gVmF1bHRzZnlpQWN0aW9uUHJvdmlkZXI7XG5fX2RlY29yYXRlKFtcbiAgICAoMCwgYWN0aW9uRGVjb3JhdG9yXzEuQ3JlYXRlQWN0aW9uKSh7XG4gICAgICAgIG5hbWU6IFwidmF1bHRzXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgXG4gICAgICBUaGlzIGFjdGlvbiByZXR1cm5zIGEgbGlzdCBvZiBhdmFpbGFibGUgdmF1bHRzLlxuICAgICAgU21hbGwgdmF1bHRzICh1bmRlciAxMDBrIFRWTCkgYXJlIHByb2JhYmx5IGJlc3QgYXZvaWRlZCBhcyB0aGV5IG1heSBiZSBtb3JlIHJpc2t5LiBVbmxlc3MgdGhlIHVzZXIgaXMgbG9va2luZyBmb3IgaGlnaC1yaXNrLCBoaWdoLXJld2FyZCBvcHBvcnR1bml0aWVzLCBkb24ndCBpbmNsdWRlIHRoZW0uXG4gICAgICBXaGVuIHRoZSB1c2VyIGFza3MgZm9yIGJlc3QgdmF1bHRzLCBvcHRpbWl6ZSBmb3IgYXB5LCBhbmQgaWYgdGhlIHVzZXIgYXNrcyBmb3Igc2FmZXN0L3JlbGlhYmxlIHZhdWx0cywgb3B0aW1pemUgZm9yIFRWTC5cbiAgICAgIFRyeSB0byB0YWtlIGEgcmVhc29uYWJsZSBudW1iZXIgb2YgcmVzdWx0cyBzbyBpdHMgZWFzaWVyIHRvIGFuYWx5emUgdGhlIGRhdGEuXG4gICAgICBGb3JtYXQgcmVzdWx0IGFweXMgYXM6IHglIChiYXNlOiB4JSwgcmV3YXJkczogeCUpIGlmIHJld2FyZHMgYXB5IGlzIGF2YWlsYWJsZSwgb3RoZXJ3aXNlOiB4JVxuICAgICAgRXhhbXBsZXM6XG4gICAgICBVc2VyOiBcIlNob3cgbWUgdGhlIGJlc3QgdmF1bHRzXCJcbiAgICAgIGFyZ3M6IHsgc29ydDogeyBmaWVsZDogJ2FweScsIGRpcmVjdGlvbjogJ2Rlc2MnIH0sIHRha2U6IDUgfVxuICAgICAgVXNlcjogXCJTaG93IG1lIHRoZSBzYWZlc3QgdmF1bHRzXCJcbiAgICAgIGFyZ3M6IHsgc29ydDogeyBmaWVsZDogJ3R2bCcsIGRpcmVjdGlvbjogJ2Rlc2MnIH0sIHRha2U6IDUgfVxuICAgICAgVXNlcjogXCJTaG93IG1lIHRoZSBiZXN0IHZhdWx0cyBvbiBBcmJpdHJ1bVwiXG4gICAgICBhcmdzOiB7IG5ldHdvcms6ICdhcmJpdHJ1bScsIHNvcnQ6IHsgZmllbGQ6ICdhcHknLCBkaXJlY3Rpb246ICdkZXNjJyB9LCB0YWtlOiA1IH1cbiAgICAgIFVzZXI6IFwiSSB3YW50IHRvIGVhcm4geWllbGQgb24gbXkgdXNkYyBvbiBiYXNlIVwiXG4gICAgICBhcmdzOiB7IHRva2VuOiAndXNkYycsIG5ldHdvcms6ICdiYXNlJywgc29ydDogeyBmaWVsZDogJ2FweScsIGRpcmVjdGlvbjogJ2Rlc2MnIH0sIHRha2U6IDUgfVxuICAgICAgVXNlcjogXCJXaGF0IGFyZSBzb21lIG9mIHRoZSBtb3N0IHByb2ZpdGFibGUgZGVnZW4gdmF1bHRzIG9uIHBvbHlnb25cIlxuICAgICAgYXJnczogeyBuZXR3b3JrOiAncG9seWdvbicsIHNvcnQ6IHsgZmllbGQ6ICdhcHknLCBkaXJlY3Rpb246ICdkZXNjJyB9LCB0YWtlOiA1LCBtaW5Udmw6IDAgfVxuICAgICAgVXNlcjogXCJTaG93IG1lIHNvbWUgbW9yZSBvZiB0aG9zZVwiXG4gICAgICBhcmdzOiB7IG5ldHdvcms6ICdwb2x5Z29uJywgc29ydDogeyBmaWVsZDogJ2FweScsIGRpcmVjdGlvbjogJ2Rlc2MnIH0sIHRha2U6IDUsIG1pblR2bDogMCwgcGFnZTogMiB9XG4gICAgYCxcbiAgICAgICAgc2NoZW1hOiBzY2hlbWFzXzEuVmF1bHRzQWN0aW9uU2NoZW1hLFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFt3YWxsZXRfcHJvdmlkZXJzXzEuRXZtV2FsbGV0UHJvdmlkZXIsIHZvaWQgMF0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCBQcm9taXNlKVxuXSwgVmF1bHRzZnlpQWN0aW9uUHJvdmlkZXIucHJvdG90eXBlLCBcInZhdWx0c1wiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgICgwLCBhY3Rpb25EZWNvcmF0b3JfMS5DcmVhdGVBY3Rpb24pKHtcbiAgICAgICAgbmFtZTogXCJkZXBvc2l0XCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgXG4gICAgICBUaGlzIGFjdGlvbiBkZXBvc2l0cyBhc3NldHMgaW50byBhIHNlbGVjdGVkIHZhdWx0LiBCZWZvcmUgZGVwb3NpdGluZyBtYWtlIHN1cmUgeW91IGhhdmUgdGhlIHJlcXVpcmVkIGFzc2V0cyBpbiB5b3VyIHdhbGxldCB1c2luZyB0aGUgd2FsbGV0LWJhbGFuY2VzIGFjdGlvbi5cbiAgICAgIEV2ZW4gaWYgeW91IHJlY2VpdmVkIHRoZSBiYWxhbmNlIGZyb20gc29tZSBvdGhlciBzb3VyY2UsIGRvdWJsZS1jaGVjayB0aGUgdXNlciBiYWxhbmNlLlxuICAgICAgVXNlIGV4YW1wbGVzOlxuICAgICAgVXNlcjogXCJEZXBvc2l0IDEwMDAgVVNEQyBpbnRvIHRoZSB2YXVsdFwiXG4gICAgICBhY3Rpb25zOlxuICAgICAgIC0gY2hlY2sgd2FsbGV0IGJhbGFuY2UgZm9yIFVTRENcbiAgICAgICAtIGRlcG9zaXQgVVNEQyBpbnRvIHRoZSB2YXVsdCBpZiBiYWxhbmNlIGlzIHN1ZmZpY2llbnRcbiAgICAgIFVzZXI6IFwiSSB3YW50IG1vcmUgeWllbGQgb24gbXkgREFJXCJcbiAgICAgIGFjdGlvbnM6XG4gICAgICAgLSBjaGVjayBwb3NpdGlvbnMgdGhhdCB0aGUgdXNlciBhbHJlYWR5IGhhcyBmb3IgZGFpXG4gICAgICAgLSBmaW5kIGhpZ2ggeWllbGQgdmF1bHRzIGZvciBkYWlcbiAgICAgICAtIGlmIHRoZXJlIGlzIGEgdmF1bHQgd2l0aCBoaWdoZXIgeWllbGQgYXZhaWxhYmxlLCByZWRlZW0gZnJvbSB0aGUgY3VycmVudCB2YXVsdCBhbmQgZGVwb3NpdCBpbnRvIHRoZSBuZXcgdmF1bHRcbiAgICAgICAtIGlmIHVzZXJzIGRhaSB3YXNuJ3QgaW4gYSB2YXVsdCB0byBiZWdpbiB3aXRoLCBkZXBvc2l0IGludG8gdGhlIG5ldyB2YXVsdFxuICAgICAgVXNlcjogXCJJIHdhbnQgdG8gY3JlYXRlIGEgZGl2ZXJzaWZpZWQgeWllbGQgc3RyYXRlZ3lcIlxuICAgICAgYWN0aW9uczpcbiAgICAgICAtIGNoZWNrIHdhbGxldCBiYWxhbmNlcyBmb3IgYWxsIGFzc2V0c1xuICAgICAgIC0gZmluZCBhIGNvdXBsZSB2YXVsdHMgZm9yIGVhY2ggYXNzZXQsIHByZWZlcmFibHkgZnJvbSBkaWZmZXJlbnQgcHJvdG9jb2xzXG4gICAgICAgLSBjcmVhdGUgYSBkaXZlcnNpZmllZCBzdHJhdGVneSB1c2luZyB0aGUgdXNlcnMgYXNzZXRzXG4gICAgICAgLSBwcm9wb3NlIHRoZSBzdHJhdGVneSB0byB0aGUgdXNlciBiZWZvcmUgZXhlY3V0aW5nXG4gICAgYCxcbiAgICAgICAgc2NoZW1hOiBzY2hlbWFzXzEuZGVwb3NpdEFjdGlvblNjaGVtYSxcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbd2FsbGV0X3Byb3ZpZGVyc18xLkV2bVdhbGxldFByb3ZpZGVyLCB2b2lkIDBdKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgUHJvbWlzZSlcbl0sIFZhdWx0c2Z5aUFjdGlvblByb3ZpZGVyLnByb3RvdHlwZSwgXCJkZXBvc2l0XCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgKDAsIGFjdGlvbkRlY29yYXRvcl8xLkNyZWF0ZUFjdGlvbikoe1xuICAgICAgICBuYW1lOiBcInJlZGVlbVwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogYFxuICAgICAgVGhpcyBhY3Rpb24gcmVkZWVtcyBhc3NldHMgZnJvbSBhIHNlbGVjdGVkIHZhdWx0LiBCZWZvcmUgcmVkZWVtaW5nIG1ha2Ugc3VyZSB5b3UgaGF2ZSB0aGUgcmVxdWlyZWQgbHAgdG9rZW5zIGluIHlvdXIgd2FsbGV0IHVzaW5nIHRoZSBwb3NpdGlvbnMgYWN0aW9uLlxuICAgICAgRXZlbiBpZiB5b3UgcmVjZWl2ZWQgdGhlIGxwIHRva2VucyBmcm9tIHNvbWUgb3RoZXIgc291cmNlLCBkb3VibGUtY2hlY2sgdGhlIGFtb3VudCBiZWZvcmUgcmVkZWVtaW5nLlxuICAgICAgbHAgdG9rZW5zIGFyZW4ndCBhbHdheXMgMToxIHdpdGggdGhlIHVuZGVybHlpbmcgYXNzZXQsIHNvIG1ha2Ugc3VyZSB0byBjaGVjayB0aGUgYW1vdW50IG9mIGxwIHRva2VucyB5b3UgaGF2ZSBiZWZvcmUgcmVkZWVtaW5nIGV2ZW4gaWYgeW91IGtub3cgdGhlIGFtb3VudCBvZiB0aGUgdW5kZXJseWluZyBhc3NldCB5b3Ugd2FudCB0byByZWRlZW0uXG4gICAgYCxcbiAgICAgICAgc2NoZW1hOiBzY2hlbWFzXzEucmVkZWVtQWN0aW9uU2NoZW1hLFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFt3YWxsZXRfcHJvdmlkZXJzXzEuRXZtV2FsbGV0UHJvdmlkZXIsIHZvaWQgMF0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCBQcm9taXNlKVxuXSwgVmF1bHRzZnlpQWN0aW9uUHJvdmlkZXIucHJvdG90eXBlLCBcInJlZGVlbVwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgICgwLCBhY3Rpb25EZWNvcmF0b3JfMS5DcmVhdGVBY3Rpb24pKHtcbiAgICAgICAgbmFtZTogXCJjbGFpbV9yZXdhcmRzXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgXG4gICAgICBUaGlzIGFjdGlvbiBjbGFpbXMgcmV3YXJkcyBmcm9tIGEgc2VsZWN0ZWQgdmF1bHQuXG4gICAgICBhc3NldEFkZHJlc3MgaXMgdGhlIGFkZHJlc3Mgb2YgdGhlIHZhdWx0cyB1bmRlcmx5aW5nIHRva2VuLlxuICAgICAgSWYgeW91J3JlIG5vdCBzdXJlIHdoYXQgdmF1bHRzIGhhdmUgcmV3YXJkcyBjbGFpbWFibGUsIHVzZSB0aGUgcG9zaXRpb25zIGFjdGlvbi5cbiAgICBgLFxuICAgICAgICBzY2hlbWE6IHNjaGVtYXNfMS5jbGFpbUFjdGlvblNjaGVtYSxcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbd2FsbGV0X3Byb3ZpZGVyc18xLkV2bVdhbGxldFByb3ZpZGVyLCB2b2lkIDBdKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgUHJvbWlzZSlcbl0sIFZhdWx0c2Z5aUFjdGlvblByb3ZpZGVyLnByb3RvdHlwZSwgXCJjbGFpbVwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgICgwLCBhY3Rpb25EZWNvcmF0b3JfMS5DcmVhdGVBY3Rpb24pKHtcbiAgICAgICAgbmFtZTogXCJ1c2VyX3dhbGxldF9iYWxhbmNlc1wiLFxuICAgICAgICBkZXNjcmlwdGlvbjogYFxuICAgIFRoaXMgYWN0aW9uIHJldHVybnMgdGhlIHVzZXJzIHdhbGxldCBiYWxhbmNlcyBvZiBhbGwgdG9rZW5zIHN1cHBvcnRlZCBieSB2YXVsdHMuZnlpLiBVc2VmdWwgd2hlbiB5b3UgZG9uJ3Qga25vdyB0b2tlbiBhZGRyZXNzZXMgYnV0IHdhbnQgdG8gY2hlY2sgaWYgdGhlIHVzZXIgaGFzIGFuIGFzc2V0LlxuICAgIEV4YW1wbGUgcXVlcmllczpcbiAgICBVc2VyOiBcIldoYXQgdG9rZW5zIGRvIEkgaGF2ZT9cIlxuICAgIFVzZXI6IFwiV2hhdCB0b2tlbnMgZG8gSSBoYXZlIG9uIEFyYml0cnVtP1wiXG4gICAgVXNlcjogXCJXaGF0cyBteSBiYWxhbmNlIG9mIFVTREM/XCJcbiAgICBgLFxuICAgICAgICBzY2hlbWE6IHpvZF8xLnoub2JqZWN0KHt9KSxcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbd2FsbGV0X3Byb3ZpZGVyc18xLkV2bVdhbGxldFByb3ZpZGVyXSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIFByb21pc2UpXG5dLCBWYXVsdHNmeWlBY3Rpb25Qcm92aWRlci5wcm90b3R5cGUsIFwiYmFsYW5jZXNcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICAoMCwgYWN0aW9uRGVjb3JhdG9yXzEuQ3JlYXRlQWN0aW9uKSh7XG4gICAgICAgIG5hbWU6IFwicG9zaXRpb25zXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgXG4gICAgICBUaGlzIGFjdGlvbiByZXR1cm5zIHRoZSB1c2VycyBwb3NpdGlvbnMgaW4gdmF1bHRzLlxuICAgICAgRXhhbXBsZSBxdWVyaWVzOlxuICAgICAgVXNlcjogXCJTaG93IG1lIG15IHBvc2l0aW9uc1wiXG4gICAgICBVc2VyOiBcIldoYXQgdmF1bHRzIGFtIGkgaW52ZXN0ZWQgaW4/XCJcbiAgICAgIFVzZXI6IFwiV2hhdCdzIG15IGF2ZXJhZ2UgeWllbGQ/XCJcbiAgICAgIFVzZXI6IFwiV2hhdCB2YXVsdHMgZG8gSSBoYXZlIHJld2FyZHMgaW4/XCJcbiAgICBgLFxuICAgICAgICBzY2hlbWE6IHpvZF8xLnoub2JqZWN0KHt9KSxcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbd2FsbGV0X3Byb3ZpZGVyc18xLkV2bVdhbGxldFByb3ZpZGVyXSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIFByb21pc2UpXG5dLCBWYXVsdHNmeWlBY3Rpb25Qcm92aWRlci5wcm90b3R5cGUsIFwicG9zaXRpb25zXCIsIG51bGwpO1xuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIHRvIGNyZWF0ZSBhIG5ldyBWYXVsdHNmeWlBY3Rpb25Qcm92aWRlciBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0gY29uZmlnIC0gQ29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgcHJvdmlkZXJcbiAqIEByZXR1cm5zIEEgbmV3IFZhdWx0c2Z5aUFjdGlvblByb3ZpZGVyIGluc3RhbmNlXG4gKi9cbmNvbnN0IHZhdWx0c2Z5aUFjdGlvblByb3ZpZGVyID0gKGNvbmZpZykgPT4gbmV3IFZhdWx0c2Z5aUFjdGlvblByb3ZpZGVyKGNvbmZpZyk7XG5leHBvcnRzLnZhdWx0c2Z5aUFjdGlvblByb3ZpZGVyID0gdmF1bHRzZnlpQWN0aW9uUHJvdmlkZXI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/vaultsfyi/vaultsfyiActionProvider.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/wallet/index.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/wallet/index.js ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./walletActionProvider */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/wallet/walletActionProvider.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy93YWxsZXQvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYSxtQkFBTyxDQUFDLDRIQUF3QiIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cnZpdmFsLWZ1bi8uL25vZGVfbW9kdWxlcy9AY29pbmJhc2UvYWdlbnRraXQvZGlzdC9hY3Rpb24tcHJvdmlkZXJzL3dhbGxldC9pbmRleC5qcz85NjBjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vd2FsbGV0QWN0aW9uUHJvdmlkZXJcIiksIGV4cG9ydHMpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/wallet/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/wallet/schemas.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/wallet/schemas.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.NativeTransferSchema = exports.GetWalletDetailsSchema = void 0;\nconst zod_1 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/lib/index.js\");\n/**\n * Schema for the get_wallet_details action.\n * This action doesn't require any input parameters, so we use an empty object schema.\n */\nexports.GetWalletDetailsSchema = zod_1.z.object({});\n/**\n * Input schema for native transfer action.\n */\nexports.NativeTransferSchema = zod_1.z\n    .object({\n    to: zod_1.z.string().describe(\"The destination address to receive the funds\"),\n    value: zod_1.z.string().describe(\"The amount to transfer in whole units e.g. 1 ETH or 0.00001 ETH\"),\n})\n    .strip()\n    .describe(\"Instructions for transferring native tokens\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy93YWxsZXQvc2NoZW1hcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw0QkFBNEIsR0FBRyw4QkFBOEI7QUFDN0QsY0FBYyxtQkFBTyxDQUFDLGtEQUFLO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLG9CQUFvQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXJ2aXZhbC1mdW4vLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy93YWxsZXQvc2NoZW1hcy5qcz8zZWE4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5OYXRpdmVUcmFuc2ZlclNjaGVtYSA9IGV4cG9ydHMuR2V0V2FsbGV0RGV0YWlsc1NjaGVtYSA9IHZvaWQgMDtcbmNvbnN0IHpvZF8xID0gcmVxdWlyZShcInpvZFwiKTtcbi8qKlxuICogU2NoZW1hIGZvciB0aGUgZ2V0X3dhbGxldF9kZXRhaWxzIGFjdGlvbi5cbiAqIFRoaXMgYWN0aW9uIGRvZXNuJ3QgcmVxdWlyZSBhbnkgaW5wdXQgcGFyYW1ldGVycywgc28gd2UgdXNlIGFuIGVtcHR5IG9iamVjdCBzY2hlbWEuXG4gKi9cbmV4cG9ydHMuR2V0V2FsbGV0RGV0YWlsc1NjaGVtYSA9IHpvZF8xLnoub2JqZWN0KHt9KTtcbi8qKlxuICogSW5wdXQgc2NoZW1hIGZvciBuYXRpdmUgdHJhbnNmZXIgYWN0aW9uLlxuICovXG5leHBvcnRzLk5hdGl2ZVRyYW5zZmVyU2NoZW1hID0gem9kXzEuelxuICAgIC5vYmplY3Qoe1xuICAgIHRvOiB6b2RfMS56LnN0cmluZygpLmRlc2NyaWJlKFwiVGhlIGRlc3RpbmF0aW9uIGFkZHJlc3MgdG8gcmVjZWl2ZSB0aGUgZnVuZHNcIiksXG4gICAgdmFsdWU6IHpvZF8xLnouc3RyaW5nKCkuZGVzY3JpYmUoXCJUaGUgYW1vdW50IHRvIHRyYW5zZmVyIGluIHdob2xlIHVuaXRzIGUuZy4gMSBFVEggb3IgMC4wMDAwMSBFVEhcIiksXG59KVxuICAgIC5zdHJpcCgpXG4gICAgLmRlc2NyaWJlKFwiSW5zdHJ1Y3Rpb25zIGZvciB0cmFuc2ZlcnJpbmcgbmF0aXZlIHRva2Vuc1wiKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/wallet/schemas.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/wallet/walletActionProvider.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/wallet/walletActionProvider.js ***!
  \**********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.walletActionProvider = exports.WalletActionProvider = void 0;\nconst zod_1 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/lib/index.js\");\nconst actionDecorator_1 = __webpack_require__(/*! ../actionDecorator */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/actionDecorator.js\");\nconst actionProvider_1 = __webpack_require__(/*! ../actionProvider */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/actionProvider.js\");\nconst wallet_providers_1 = __webpack_require__(/*! ../../wallet-providers */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/wallet-providers/index.js\");\nconst schemas_1 = __webpack_require__(/*! ./schemas */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/wallet/schemas.js\");\nconst PROTOCOL_FAMILY_TO_TERMINOLOGY = {\n    evm: { unit: \"WEI\", displayUnit: \"ETH\", type: \"Transaction hash\", verb: \"transaction\" },\n    svm: { unit: \"LAMPORTS\", displayUnit: \"SOL\", type: \"Signature\", verb: \"transfer\" },\n};\nconst DEFAULT_TERMINOLOGY = { unit: \"\", displayUnit: \"\", type: \"Hash\", verb: \"transfer\" };\n/**\n * WalletActionProvider provides actions for getting basic wallet information.\n */\nclass WalletActionProvider extends actionProvider_1.ActionProvider {\n    /**\n     * Constructor for the WalletActionProvider.\n     */\n    constructor() {\n        super(\"wallet\", []);\n        /**\n         * Checks if the wallet action provider supports the given network.\n         * Since wallet actions are network-agnostic, this always returns true.\n         *\n         * @param _ - The network to check.\n         * @returns True, as wallet actions are supported on all networks.\n         */\n        this.supportsNetwork = (_) => true;\n    }\n    /**\n     * Gets the details of the connected wallet including address, network, and balance.\n     *\n     * @param walletProvider - The wallet provider to get the details from.\n     * @param _ - Empty args object (not used).\n     * @returns A formatted string containing the wallet details.\n     */\n    async getWalletDetails(walletProvider, _) {\n        try {\n            const address = walletProvider.getAddress();\n            const network = walletProvider.getNetwork();\n            const balance = await walletProvider.getBalance();\n            const name = walletProvider.getName();\n            const terminology = PROTOCOL_FAMILY_TO_TERMINOLOGY[network.protocolFamily] || DEFAULT_TERMINOLOGY;\n            return [\n                \"Wallet Details:\",\n                `- Provider: ${name}`,\n                `- Address: ${address}`,\n                \"- Network:\",\n                `  * Protocol Family: ${network.protocolFamily}`,\n                `  * Network ID: ${network.networkId || \"N/A\"}`,\n                `  * Chain ID: ${network.chainId || \"N/A\"}`,\n                `- Native Balance: ${balance.toString()} ${terminology.unit}`,\n            ].join(\"\\n\");\n        }\n        catch (error) {\n            return `Error getting wallet details: ${error}`;\n        }\n    }\n    /**\n     * Transfers a specified amount of native currency to a destination onchain.\n     *\n     * @param walletProvider - The wallet provider to transfer from.\n     * @param args - The input arguments for the action.\n     * @returns A message containing the transfer details.\n     */\n    async nativeTransfer(walletProvider, args) {\n        try {\n            const { protocolFamily } = walletProvider.getNetwork();\n            const terminology = PROTOCOL_FAMILY_TO_TERMINOLOGY[protocolFamily] || DEFAULT_TERMINOLOGY;\n            if (protocolFamily === \"evm\" && !args.to.startsWith(\"0x\")) {\n                args.to = `0x${args.to}`;\n            }\n            const result = await walletProvider.nativeTransfer(args.to, args.value);\n            return [\n                `Transferred ${args.value} ${terminology.displayUnit} to ${args.to}`,\n                `${terminology.type}: ${result}`,\n            ].join(\"\\n\");\n        }\n        catch (error) {\n            const { protocolFamily } = walletProvider.getNetwork();\n            const terminology = PROTOCOL_FAMILY_TO_TERMINOLOGY[protocolFamily] || DEFAULT_TERMINOLOGY;\n            return `Error during ${terminology.verb}: ${error}`;\n        }\n    }\n}\nexports.WalletActionProvider = WalletActionProvider;\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"get_wallet_details\",\n        description: `\n    This tool will return the details of the connected wallet including:\n    - Wallet address\n    - Network information (protocol family, network ID, chain ID)\n    - Native token balance (ETH for EVM networks, SOL for Solana networks)\n    - Wallet provider name\n    `,\n        schema: schemas_1.GetWalletDetailsSchema,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [wallet_providers_1.WalletProvider, void 0]),\n    __metadata(\"design:returntype\", Promise)\n], WalletActionProvider.prototype, \"getWalletDetails\", null);\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"native_transfer\",\n        description: `\nThis tool will transfer native tokens from the wallet to another onchain address.\n\nIt takes the following inputs:\n- amount: The amount to transfer in whole units (e.g. 1 ETH, 0.1 SOL)\n- destination: The address to receive the funds\n\nImportant notes:\n- Ensure sufficient balance of the input asset before transferring\n- Ensure there is sufficient native token balance for gas fees\n`,\n        schema: schemas_1.NativeTransferSchema,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [wallet_providers_1.WalletProvider, void 0]),\n    __metadata(\"design:returntype\", Promise)\n], WalletActionProvider.prototype, \"nativeTransfer\", null);\n/**\n * Factory function to create a new WalletActionProvider instance.\n *\n * @returns A new WalletActionProvider instance.\n */\nconst walletActionProvider = () => new WalletActionProvider();\nexports.walletActionProvider = walletActionProvider;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy93YWxsZXQvd2FsbGV0QWN0aW9uUHJvdmlkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsUUFBUTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDRCQUE0QixHQUFHLDRCQUE0QjtBQUMzRCxjQUFjLG1CQUFPLENBQUMsa0RBQUs7QUFDM0IsMEJBQTBCLG1CQUFPLENBQUMsNEdBQW9CO0FBQ3RELHlCQUF5QixtQkFBTyxDQUFDLDBHQUFtQjtBQUNwRCwyQkFBMkIsbUJBQU8sQ0FBQyxzR0FBd0I7QUFDM0Qsa0JBQWtCLG1CQUFPLENBQUMsa0dBQVc7QUFDckM7QUFDQSxXQUFXLGdGQUFnRjtBQUMzRixXQUFXLDJFQUEyRTtBQUN0RjtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixLQUFLO0FBQ3BDLDhCQUE4QixRQUFRO0FBQ3RDO0FBQ0Esd0NBQXdDLHVCQUF1QjtBQUMvRCxtQ0FBbUMsMkJBQTJCO0FBQzlELGlDQUFpQyx5QkFBeUI7QUFDMUQscUNBQXFDLG9CQUFvQixFQUFFLGlCQUFpQjtBQUM1RTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsTUFBTTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0EsK0JBQStCLFFBQVE7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFlBQVksRUFBRSx5QkFBeUIsS0FBSyxRQUFRO0FBQ25GLG1CQUFtQixpQkFBaUIsSUFBSSxPQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQSxtQ0FBbUMsaUJBQWlCLElBQUksTUFBTTtBQUM5RDtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXJ2aXZhbC1mdW4vLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy93YWxsZXQvd2FsbGV0QWN0aW9uUHJvdmlkZXIuanM/ZDRmMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLndhbGxldEFjdGlvblByb3ZpZGVyID0gZXhwb3J0cy5XYWxsZXRBY3Rpb25Qcm92aWRlciA9IHZvaWQgMDtcbmNvbnN0IHpvZF8xID0gcmVxdWlyZShcInpvZFwiKTtcbmNvbnN0IGFjdGlvbkRlY29yYXRvcl8xID0gcmVxdWlyZShcIi4uL2FjdGlvbkRlY29yYXRvclwiKTtcbmNvbnN0IGFjdGlvblByb3ZpZGVyXzEgPSByZXF1aXJlKFwiLi4vYWN0aW9uUHJvdmlkZXJcIik7XG5jb25zdCB3YWxsZXRfcHJvdmlkZXJzXzEgPSByZXF1aXJlKFwiLi4vLi4vd2FsbGV0LXByb3ZpZGVyc1wiKTtcbmNvbnN0IHNjaGVtYXNfMSA9IHJlcXVpcmUoXCIuL3NjaGVtYXNcIik7XG5jb25zdCBQUk9UT0NPTF9GQU1JTFlfVE9fVEVSTUlOT0xPR1kgPSB7XG4gICAgZXZtOiB7IHVuaXQ6IFwiV0VJXCIsIGRpc3BsYXlVbml0OiBcIkVUSFwiLCB0eXBlOiBcIlRyYW5zYWN0aW9uIGhhc2hcIiwgdmVyYjogXCJ0cmFuc2FjdGlvblwiIH0sXG4gICAgc3ZtOiB7IHVuaXQ6IFwiTEFNUE9SVFNcIiwgZGlzcGxheVVuaXQ6IFwiU09MXCIsIHR5cGU6IFwiU2lnbmF0dXJlXCIsIHZlcmI6IFwidHJhbnNmZXJcIiB9LFxufTtcbmNvbnN0IERFRkFVTFRfVEVSTUlOT0xPR1kgPSB7IHVuaXQ6IFwiXCIsIGRpc3BsYXlVbml0OiBcIlwiLCB0eXBlOiBcIkhhc2hcIiwgdmVyYjogXCJ0cmFuc2ZlclwiIH07XG4vKipcbiAqIFdhbGxldEFjdGlvblByb3ZpZGVyIHByb3ZpZGVzIGFjdGlvbnMgZm9yIGdldHRpbmcgYmFzaWMgd2FsbGV0IGluZm9ybWF0aW9uLlxuICovXG5jbGFzcyBXYWxsZXRBY3Rpb25Qcm92aWRlciBleHRlbmRzIGFjdGlvblByb3ZpZGVyXzEuQWN0aW9uUHJvdmlkZXIge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciB0aGUgV2FsbGV0QWN0aW9uUHJvdmlkZXIuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKFwid2FsbGV0XCIsIFtdKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrcyBpZiB0aGUgd2FsbGV0IGFjdGlvbiBwcm92aWRlciBzdXBwb3J0cyB0aGUgZ2l2ZW4gbmV0d29yay5cbiAgICAgICAgICogU2luY2Ugd2FsbGV0IGFjdGlvbnMgYXJlIG5ldHdvcmstYWdub3N0aWMsIHRoaXMgYWx3YXlzIHJldHVybnMgdHJ1ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIF8gLSBUaGUgbmV0d29yayB0byBjaGVjay5cbiAgICAgICAgICogQHJldHVybnMgVHJ1ZSwgYXMgd2FsbGV0IGFjdGlvbnMgYXJlIHN1cHBvcnRlZCBvbiBhbGwgbmV0d29ya3MuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN1cHBvcnRzTmV0d29yayA9IChfKSA9PiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBkZXRhaWxzIG9mIHRoZSBjb25uZWN0ZWQgd2FsbGV0IGluY2x1ZGluZyBhZGRyZXNzLCBuZXR3b3JrLCBhbmQgYmFsYW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB3YWxsZXRQcm92aWRlciAtIFRoZSB3YWxsZXQgcHJvdmlkZXIgdG8gZ2V0IHRoZSBkZXRhaWxzIGZyb20uXG4gICAgICogQHBhcmFtIF8gLSBFbXB0eSBhcmdzIG9iamVjdCAobm90IHVzZWQpLlxuICAgICAqIEByZXR1cm5zIEEgZm9ybWF0dGVkIHN0cmluZyBjb250YWluaW5nIHRoZSB3YWxsZXQgZGV0YWlscy5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRXYWxsZXREZXRhaWxzKHdhbGxldFByb3ZpZGVyLCBfKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBhZGRyZXNzID0gd2FsbGV0UHJvdmlkZXIuZ2V0QWRkcmVzcygpO1xuICAgICAgICAgICAgY29uc3QgbmV0d29yayA9IHdhbGxldFByb3ZpZGVyLmdldE5ldHdvcmsoKTtcbiAgICAgICAgICAgIGNvbnN0IGJhbGFuY2UgPSBhd2FpdCB3YWxsZXRQcm92aWRlci5nZXRCYWxhbmNlKCk7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gd2FsbGV0UHJvdmlkZXIuZ2V0TmFtZSgpO1xuICAgICAgICAgICAgY29uc3QgdGVybWlub2xvZ3kgPSBQUk9UT0NPTF9GQU1JTFlfVE9fVEVSTUlOT0xPR1lbbmV0d29yay5wcm90b2NvbEZhbWlseV0gfHwgREVGQVVMVF9URVJNSU5PTE9HWTtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgXCJXYWxsZXQgRGV0YWlsczpcIixcbiAgICAgICAgICAgICAgICBgLSBQcm92aWRlcjogJHtuYW1lfWAsXG4gICAgICAgICAgICAgICAgYC0gQWRkcmVzczogJHthZGRyZXNzfWAsXG4gICAgICAgICAgICAgICAgXCItIE5ldHdvcms6XCIsXG4gICAgICAgICAgICAgICAgYCAgKiBQcm90b2NvbCBGYW1pbHk6ICR7bmV0d29yay5wcm90b2NvbEZhbWlseX1gLFxuICAgICAgICAgICAgICAgIGAgICogTmV0d29yayBJRDogJHtuZXR3b3JrLm5ldHdvcmtJZCB8fCBcIk4vQVwifWAsXG4gICAgICAgICAgICAgICAgYCAgKiBDaGFpbiBJRDogJHtuZXR3b3JrLmNoYWluSWQgfHwgXCJOL0FcIn1gLFxuICAgICAgICAgICAgICAgIGAtIE5hdGl2ZSBCYWxhbmNlOiAke2JhbGFuY2UudG9TdHJpbmcoKX0gJHt0ZXJtaW5vbG9neS51bml0fWAsXG4gICAgICAgICAgICBdLmpvaW4oXCJcXG5cIik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gYEVycm9yIGdldHRpbmcgd2FsbGV0IGRldGFpbHM6ICR7ZXJyb3J9YDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmFuc2ZlcnMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIG5hdGl2ZSBjdXJyZW5jeSB0byBhIGRlc3RpbmF0aW9uIG9uY2hhaW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gd2FsbGV0UHJvdmlkZXIgLSBUaGUgd2FsbGV0IHByb3ZpZGVyIHRvIHRyYW5zZmVyIGZyb20uXG4gICAgICogQHBhcmFtIGFyZ3MgLSBUaGUgaW5wdXQgYXJndW1lbnRzIGZvciB0aGUgYWN0aW9uLlxuICAgICAqIEByZXR1cm5zIEEgbWVzc2FnZSBjb250YWluaW5nIHRoZSB0cmFuc2ZlciBkZXRhaWxzLlxuICAgICAqL1xuICAgIGFzeW5jIG5hdGl2ZVRyYW5zZmVyKHdhbGxldFByb3ZpZGVyLCBhcmdzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB7IHByb3RvY29sRmFtaWx5IH0gPSB3YWxsZXRQcm92aWRlci5nZXROZXR3b3JrKCk7XG4gICAgICAgICAgICBjb25zdCB0ZXJtaW5vbG9neSA9IFBST1RPQ09MX0ZBTUlMWV9UT19URVJNSU5PTE9HWVtwcm90b2NvbEZhbWlseV0gfHwgREVGQVVMVF9URVJNSU5PTE9HWTtcbiAgICAgICAgICAgIGlmIChwcm90b2NvbEZhbWlseSA9PT0gXCJldm1cIiAmJiAhYXJncy50by5zdGFydHNXaXRoKFwiMHhcIikpIHtcbiAgICAgICAgICAgICAgICBhcmdzLnRvID0gYDB4JHthcmdzLnRvfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB3YWxsZXRQcm92aWRlci5uYXRpdmVUcmFuc2ZlcihhcmdzLnRvLCBhcmdzLnZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgYFRyYW5zZmVycmVkICR7YXJncy52YWx1ZX0gJHt0ZXJtaW5vbG9neS5kaXNwbGF5VW5pdH0gdG8gJHthcmdzLnRvfWAsXG4gICAgICAgICAgICAgICAgYCR7dGVybWlub2xvZ3kudHlwZX06ICR7cmVzdWx0fWAsXG4gICAgICAgICAgICBdLmpvaW4oXCJcXG5cIik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zdCB7IHByb3RvY29sRmFtaWx5IH0gPSB3YWxsZXRQcm92aWRlci5nZXROZXR3b3JrKCk7XG4gICAgICAgICAgICBjb25zdCB0ZXJtaW5vbG9neSA9IFBST1RPQ09MX0ZBTUlMWV9UT19URVJNSU5PTE9HWVtwcm90b2NvbEZhbWlseV0gfHwgREVGQVVMVF9URVJNSU5PTE9HWTtcbiAgICAgICAgICAgIHJldHVybiBgRXJyb3IgZHVyaW5nICR7dGVybWlub2xvZ3kudmVyYn06ICR7ZXJyb3J9YDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuV2FsbGV0QWN0aW9uUHJvdmlkZXIgPSBXYWxsZXRBY3Rpb25Qcm92aWRlcjtcbl9fZGVjb3JhdGUoW1xuICAgICgwLCBhY3Rpb25EZWNvcmF0b3JfMS5DcmVhdGVBY3Rpb24pKHtcbiAgICAgICAgbmFtZTogXCJnZXRfd2FsbGV0X2RldGFpbHNcIixcbiAgICAgICAgZGVzY3JpcHRpb246IGBcbiAgICBUaGlzIHRvb2wgd2lsbCByZXR1cm4gdGhlIGRldGFpbHMgb2YgdGhlIGNvbm5lY3RlZCB3YWxsZXQgaW5jbHVkaW5nOlxuICAgIC0gV2FsbGV0IGFkZHJlc3NcbiAgICAtIE5ldHdvcmsgaW5mb3JtYXRpb24gKHByb3RvY29sIGZhbWlseSwgbmV0d29yayBJRCwgY2hhaW4gSUQpXG4gICAgLSBOYXRpdmUgdG9rZW4gYmFsYW5jZSAoRVRIIGZvciBFVk0gbmV0d29ya3MsIFNPTCBmb3IgU29sYW5hIG5ldHdvcmtzKVxuICAgIC0gV2FsbGV0IHByb3ZpZGVyIG5hbWVcbiAgICBgLFxuICAgICAgICBzY2hlbWE6IHNjaGVtYXNfMS5HZXRXYWxsZXREZXRhaWxzU2NoZW1hLFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFt3YWxsZXRfcHJvdmlkZXJzXzEuV2FsbGV0UHJvdmlkZXIsIHZvaWQgMF0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCBQcm9taXNlKVxuXSwgV2FsbGV0QWN0aW9uUHJvdmlkZXIucHJvdG90eXBlLCBcImdldFdhbGxldERldGFpbHNcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICAoMCwgYWN0aW9uRGVjb3JhdG9yXzEuQ3JlYXRlQWN0aW9uKSh7XG4gICAgICAgIG5hbWU6IFwibmF0aXZlX3RyYW5zZmVyXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgXG5UaGlzIHRvb2wgd2lsbCB0cmFuc2ZlciBuYXRpdmUgdG9rZW5zIGZyb20gdGhlIHdhbGxldCB0byBhbm90aGVyIG9uY2hhaW4gYWRkcmVzcy5cblxuSXQgdGFrZXMgdGhlIGZvbGxvd2luZyBpbnB1dHM6XG4tIGFtb3VudDogVGhlIGFtb3VudCB0byB0cmFuc2ZlciBpbiB3aG9sZSB1bml0cyAoZS5nLiAxIEVUSCwgMC4xIFNPTClcbi0gZGVzdGluYXRpb246IFRoZSBhZGRyZXNzIHRvIHJlY2VpdmUgdGhlIGZ1bmRzXG5cbkltcG9ydGFudCBub3Rlczpcbi0gRW5zdXJlIHN1ZmZpY2llbnQgYmFsYW5jZSBvZiB0aGUgaW5wdXQgYXNzZXQgYmVmb3JlIHRyYW5zZmVycmluZ1xuLSBFbnN1cmUgdGhlcmUgaXMgc3VmZmljaWVudCBuYXRpdmUgdG9rZW4gYmFsYW5jZSBmb3IgZ2FzIGZlZXNcbmAsXG4gICAgICAgIHNjaGVtYTogc2NoZW1hc18xLk5hdGl2ZVRyYW5zZmVyU2NoZW1hLFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFt3YWxsZXRfcHJvdmlkZXJzXzEuV2FsbGV0UHJvdmlkZXIsIHZvaWQgMF0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCBQcm9taXNlKVxuXSwgV2FsbGV0QWN0aW9uUHJvdmlkZXIucHJvdG90eXBlLCBcIm5hdGl2ZVRyYW5zZmVyXCIsIG51bGwpO1xuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIHRvIGNyZWF0ZSBhIG5ldyBXYWxsZXRBY3Rpb25Qcm92aWRlciBpbnN0YW5jZS5cbiAqXG4gKiBAcmV0dXJucyBBIG5ldyBXYWxsZXRBY3Rpb25Qcm92aWRlciBpbnN0YW5jZS5cbiAqL1xuY29uc3Qgd2FsbGV0QWN0aW9uUHJvdmlkZXIgPSAoKSA9PiBuZXcgV2FsbGV0QWN0aW9uUHJvdmlkZXIoKTtcbmV4cG9ydHMud2FsbGV0QWN0aW9uUHJvdmlkZXIgPSB3YWxsZXRBY3Rpb25Qcm92aWRlcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/wallet/walletActionProvider.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/weth/constants.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/weth/constants.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.WETH_ABI = exports.WETH_ADDRESS = void 0;\nexports.WETH_ADDRESS = \"0x4200000000000000000000000000000000000006\";\nexports.WETH_ABI = [\n    {\n        inputs: [],\n        name: \"deposit\",\n        outputs: [],\n        stateMutability: \"payable\",\n        type: \"function\",\n    },\n    {\n        inputs: [\n            {\n                name: \"account\",\n                type: \"address\",\n            },\n        ],\n        name: \"balanceOf\",\n        outputs: [\n            {\n                type: \"uint256\",\n            },\n        ],\n        stateMutability: \"view\",\n        type: \"function\",\n    },\n];\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy93ZXRoL2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0IsR0FBRyxvQkFBb0I7QUFDdkMsb0JBQW9CO0FBQ3BCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cnZpdmFsLWZ1bi8uL25vZGVfbW9kdWxlcy9AY29pbmJhc2UvYWdlbnRraXQvZGlzdC9hY3Rpb24tcHJvdmlkZXJzL3dldGgvY29uc3RhbnRzLmpzP2VjYTQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLldFVEhfQUJJID0gZXhwb3J0cy5XRVRIX0FERFJFU1MgPSB2b2lkIDA7XG5leHBvcnRzLldFVEhfQUREUkVTUyA9IFwiMHg0MjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA2XCI7XG5leHBvcnRzLldFVEhfQUJJID0gW1xuICAgIHtcbiAgICAgICAgaW5wdXRzOiBbXSxcbiAgICAgICAgbmFtZTogXCJkZXBvc2l0XCIsXG4gICAgICAgIG91dHB1dHM6IFtdLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6IFwicGF5YWJsZVwiLFxuICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6IFwiYWNjb3VudFwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgbmFtZTogXCJiYWxhbmNlT2ZcIixcbiAgICAgICAgb3V0cHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIixcbiAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgIH0sXG5dO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/weth/constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/weth/index.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/weth/index.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./wethActionProvider */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/weth/wethActionProvider.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy93ZXRoL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWEsbUJBQU8sQ0FBQyxzSEFBc0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXJ2aXZhbC1mdW4vLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy93ZXRoL2luZGV4LmpzPzY0ZmIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi93ZXRoQWN0aW9uUHJvdmlkZXJcIiksIGV4cG9ydHMpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/weth/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/weth/schemas.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/weth/schemas.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.WrapEthSchema = void 0;\nconst zod_1 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/lib/index.js\");\nexports.WrapEthSchema = zod_1.z\n    .object({\n    amountToWrap: zod_1.z.string().describe(\"Amount of ETH to wrap in wei\"),\n})\n    .strip()\n    .describe(\"Instructions for wrapping ETH to WETH\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy93ZXRoL3NjaGVtYXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCO0FBQ3JCLGNBQWMsbUJBQU8sQ0FBQyxrREFBSztBQUMzQixxQkFBcUI7QUFDckI7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3Vydml2YWwtZnVuLy4vbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9hZ2VudGtpdC9kaXN0L2FjdGlvbi1wcm92aWRlcnMvd2V0aC9zY2hlbWFzLmpzP2FiYTIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLldyYXBFdGhTY2hlbWEgPSB2b2lkIDA7XG5jb25zdCB6b2RfMSA9IHJlcXVpcmUoXCJ6b2RcIik7XG5leHBvcnRzLldyYXBFdGhTY2hlbWEgPSB6b2RfMS56XG4gICAgLm9iamVjdCh7XG4gICAgYW1vdW50VG9XcmFwOiB6b2RfMS56LnN0cmluZygpLmRlc2NyaWJlKFwiQW1vdW50IG9mIEVUSCB0byB3cmFwIGluIHdlaVwiKSxcbn0pXG4gICAgLnN0cmlwKClcbiAgICAuZGVzY3JpYmUoXCJJbnN0cnVjdGlvbnMgZm9yIHdyYXBwaW5nIEVUSCB0byBXRVRIXCIpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/weth/schemas.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/weth/wethActionProvider.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/weth/wethActionProvider.js ***!
  \******************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.wethActionProvider = exports.WethActionProvider = void 0;\nconst zod_1 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/lib/index.js\");\nconst actionProvider_1 = __webpack_require__(/*! ../actionProvider */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/actionProvider.js\");\nconst actionDecorator_1 = __webpack_require__(/*! ../actionDecorator */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/actionDecorator.js\");\nconst schemas_1 = __webpack_require__(/*! ./schemas */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/weth/schemas.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/weth/constants.js\");\nconst viem_1 = __webpack_require__(/*! viem */ \"(rsc)/./node_modules/viem/_cjs/index.js\");\nconst wallet_providers_1 = __webpack_require__(/*! ../../wallet-providers */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/wallet-providers/index.js\");\n/**\n * WethActionProvider is an action provider for WETH.\n */\nclass WethActionProvider extends actionProvider_1.ActionProvider {\n    /**\n     * Constructor for the WethActionProvider.\n     */\n    constructor() {\n        super(\"weth\", []);\n        /**\n         * Checks if the Weth action provider supports the given network.\n         *\n         * @param network - The network to check.\n         * @returns True if the Weth action provider supports the network, false otherwise.\n         */\n        this.supportsNetwork = (network) => network.networkId === \"base-mainnet\" || network.networkId === \"base-sepolia\";\n    }\n    /**\n     * Wraps ETH to WETH.\n     *\n     * @param walletProvider - The wallet provider to use for the action.\n     * @param args - The input arguments for the action.\n     * @returns A message containing the transaction hash.\n     */\n    async wrapEth(walletProvider, args) {\n        try {\n            const hash = await walletProvider.sendTransaction({\n                to: constants_1.WETH_ADDRESS,\n                data: (0, viem_1.encodeFunctionData)({\n                    abi: constants_1.WETH_ABI,\n                    functionName: \"deposit\",\n                }),\n                value: BigInt(args.amountToWrap),\n            });\n            await walletProvider.waitForTransactionReceipt(hash);\n            return `Wrapped ETH with transaction hash: ${hash}`;\n        }\n        catch (error) {\n            return `Error wrapping ETH: ${error}`;\n        }\n    }\n}\nexports.WethActionProvider = WethActionProvider;\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"wrap_eth\",\n        description: `\n    This tool can only be used to wrap ETH to WETH.\nDo not use this tool for any other purpose, or trading other assets.\n\nInputs:\n- Amount of ETH to wrap.\n\nImportant notes:\n- The amount is a string and cannot have any decimal points, since the unit of measurement is wei.\n- Make sure to use the exact amount provided, and if there's any doubt, check by getting more information before continuing with the action.\n- 1 wei = 0.000000000000000001 WETH\n- Minimum purchase amount is 100000000000000 wei (0.0000001 WETH)\n- Only supported on the following networks:\n  - Base Sepolia (ie, 'base-sepolia')\n  - Base Mainnet (ie, 'base', 'base-mainnet')\n`,\n        schema: schemas_1.WrapEthSchema,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [wallet_providers_1.EvmWalletProvider, void 0]),\n    __metadata(\"design:returntype\", Promise)\n], WethActionProvider.prototype, \"wrapEth\", null);\nconst wethActionProvider = () => new WethActionProvider();\nexports.wethActionProvider = wethActionProvider;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy93ZXRoL3dldGhBY3Rpb25Qcm92aWRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxRQUFRO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMEJBQTBCLEdBQUcsMEJBQTBCO0FBQ3ZELGNBQWMsbUJBQU8sQ0FBQyxrREFBSztBQUMzQix5QkFBeUIsbUJBQU8sQ0FBQywwR0FBbUI7QUFDcEQsMEJBQTBCLG1CQUFPLENBQUMsNEdBQW9CO0FBQ3RELGtCQUFrQixtQkFBTyxDQUFDLGdHQUFXO0FBQ3JDLG9CQUFvQixtQkFBTyxDQUFDLG9HQUFhO0FBQ3pDLGVBQWUsbUJBQU8sQ0FBQyxxREFBTTtBQUM3QiwyQkFBMkIsbUJBQU8sQ0FBQyxzR0FBd0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2I7QUFDQSx5REFBeUQsS0FBSztBQUM5RDtBQUNBO0FBQ0EsMENBQTBDLE1BQU07QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXJ2aXZhbC1mdW4vLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy93ZXRoL3dldGhBY3Rpb25Qcm92aWRlci5qcz9kNjI5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMud2V0aEFjdGlvblByb3ZpZGVyID0gZXhwb3J0cy5XZXRoQWN0aW9uUHJvdmlkZXIgPSB2b2lkIDA7XG5jb25zdCB6b2RfMSA9IHJlcXVpcmUoXCJ6b2RcIik7XG5jb25zdCBhY3Rpb25Qcm92aWRlcl8xID0gcmVxdWlyZShcIi4uL2FjdGlvblByb3ZpZGVyXCIpO1xuY29uc3QgYWN0aW9uRGVjb3JhdG9yXzEgPSByZXF1aXJlKFwiLi4vYWN0aW9uRGVjb3JhdG9yXCIpO1xuY29uc3Qgc2NoZW1hc18xID0gcmVxdWlyZShcIi4vc2NoZW1hc1wiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgdmllbV8xID0gcmVxdWlyZShcInZpZW1cIik7XG5jb25zdCB3YWxsZXRfcHJvdmlkZXJzXzEgPSByZXF1aXJlKFwiLi4vLi4vd2FsbGV0LXByb3ZpZGVyc1wiKTtcbi8qKlxuICogV2V0aEFjdGlvblByb3ZpZGVyIGlzIGFuIGFjdGlvbiBwcm92aWRlciBmb3IgV0VUSC5cbiAqL1xuY2xhc3MgV2V0aEFjdGlvblByb3ZpZGVyIGV4dGVuZHMgYWN0aW9uUHJvdmlkZXJfMS5BY3Rpb25Qcm92aWRlciB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIHRoZSBXZXRoQWN0aW9uUHJvdmlkZXIuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKFwid2V0aFwiLCBbXSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVja3MgaWYgdGhlIFdldGggYWN0aW9uIHByb3ZpZGVyIHN1cHBvcnRzIHRoZSBnaXZlbiBuZXR3b3JrLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gbmV0d29yayAtIFRoZSBuZXR3b3JrIHRvIGNoZWNrLlxuICAgICAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBXZXRoIGFjdGlvbiBwcm92aWRlciBzdXBwb3J0cyB0aGUgbmV0d29yaywgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdXBwb3J0c05ldHdvcmsgPSAobmV0d29yaykgPT4gbmV0d29yay5uZXR3b3JrSWQgPT09IFwiYmFzZS1tYWlubmV0XCIgfHwgbmV0d29yay5uZXR3b3JrSWQgPT09IFwiYmFzZS1zZXBvbGlhXCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyYXBzIEVUSCB0byBXRVRILlxuICAgICAqXG4gICAgICogQHBhcmFtIHdhbGxldFByb3ZpZGVyIC0gVGhlIHdhbGxldCBwcm92aWRlciB0byB1c2UgZm9yIHRoZSBhY3Rpb24uXG4gICAgICogQHBhcmFtIGFyZ3MgLSBUaGUgaW5wdXQgYXJndW1lbnRzIGZvciB0aGUgYWN0aW9uLlxuICAgICAqIEByZXR1cm5zIEEgbWVzc2FnZSBjb250YWluaW5nIHRoZSB0cmFuc2FjdGlvbiBoYXNoLlxuICAgICAqL1xuICAgIGFzeW5jIHdyYXBFdGgod2FsbGV0UHJvdmlkZXIsIGFyZ3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGhhc2ggPSBhd2FpdCB3YWxsZXRQcm92aWRlci5zZW5kVHJhbnNhY3Rpb24oe1xuICAgICAgICAgICAgICAgIHRvOiBjb25zdGFudHNfMS5XRVRIX0FERFJFU1MsXG4gICAgICAgICAgICAgICAgZGF0YTogKDAsIHZpZW1fMS5lbmNvZGVGdW5jdGlvbkRhdGEpKHtcbiAgICAgICAgICAgICAgICAgICAgYWJpOiBjb25zdGFudHNfMS5XRVRIX0FCSSxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiBcImRlcG9zaXRcIixcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogQmlnSW50KGFyZ3MuYW1vdW50VG9XcmFwKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgd2FsbGV0UHJvdmlkZXIud2FpdEZvclRyYW5zYWN0aW9uUmVjZWlwdChoYXNoKTtcbiAgICAgICAgICAgIHJldHVybiBgV3JhcHBlZCBFVEggd2l0aCB0cmFuc2FjdGlvbiBoYXNoOiAke2hhc2h9YDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBgRXJyb3Igd3JhcHBpbmcgRVRIOiAke2Vycm9yfWA7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLldldGhBY3Rpb25Qcm92aWRlciA9IFdldGhBY3Rpb25Qcm92aWRlcjtcbl9fZGVjb3JhdGUoW1xuICAgICgwLCBhY3Rpb25EZWNvcmF0b3JfMS5DcmVhdGVBY3Rpb24pKHtcbiAgICAgICAgbmFtZTogXCJ3cmFwX2V0aFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogYFxuICAgIFRoaXMgdG9vbCBjYW4gb25seSBiZSB1c2VkIHRvIHdyYXAgRVRIIHRvIFdFVEguXG5EbyBub3QgdXNlIHRoaXMgdG9vbCBmb3IgYW55IG90aGVyIHB1cnBvc2UsIG9yIHRyYWRpbmcgb3RoZXIgYXNzZXRzLlxuXG5JbnB1dHM6XG4tIEFtb3VudCBvZiBFVEggdG8gd3JhcC5cblxuSW1wb3J0YW50IG5vdGVzOlxuLSBUaGUgYW1vdW50IGlzIGEgc3RyaW5nIGFuZCBjYW5ub3QgaGF2ZSBhbnkgZGVjaW1hbCBwb2ludHMsIHNpbmNlIHRoZSB1bml0IG9mIG1lYXN1cmVtZW50IGlzIHdlaS5cbi0gTWFrZSBzdXJlIHRvIHVzZSB0aGUgZXhhY3QgYW1vdW50IHByb3ZpZGVkLCBhbmQgaWYgdGhlcmUncyBhbnkgZG91YnQsIGNoZWNrIGJ5IGdldHRpbmcgbW9yZSBpbmZvcm1hdGlvbiBiZWZvcmUgY29udGludWluZyB3aXRoIHRoZSBhY3Rpb24uXG4tIDEgd2VpID0gMC4wMDAwMDAwMDAwMDAwMDAwMDEgV0VUSFxuLSBNaW5pbXVtIHB1cmNoYXNlIGFtb3VudCBpcyAxMDAwMDAwMDAwMDAwMDAgd2VpICgwLjAwMDAwMDEgV0VUSClcbi0gT25seSBzdXBwb3J0ZWQgb24gdGhlIGZvbGxvd2luZyBuZXR3b3JrczpcbiAgLSBCYXNlIFNlcG9saWEgKGllLCAnYmFzZS1zZXBvbGlhJylcbiAgLSBCYXNlIE1haW5uZXQgKGllLCAnYmFzZScsICdiYXNlLW1haW5uZXQnKVxuYCxcbiAgICAgICAgc2NoZW1hOiBzY2hlbWFzXzEuV3JhcEV0aFNjaGVtYSxcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbd2FsbGV0X3Byb3ZpZGVyc18xLkV2bVdhbGxldFByb3ZpZGVyLCB2b2lkIDBdKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgUHJvbWlzZSlcbl0sIFdldGhBY3Rpb25Qcm92aWRlci5wcm90b3R5cGUsIFwid3JhcEV0aFwiLCBudWxsKTtcbmNvbnN0IHdldGhBY3Rpb25Qcm92aWRlciA9ICgpID0+IG5ldyBXZXRoQWN0aW9uUHJvdmlkZXIoKTtcbmV4cG9ydHMud2V0aEFjdGlvblByb3ZpZGVyID0gd2V0aEFjdGlvblByb3ZpZGVyO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/weth/wethActionProvider.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/wow/constants.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/wow/constants.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GENERIC_TOKEN_METADATA_URI = exports.ADDRESSES = exports.WOW_FACTORY_CONTRACT_ADDRESSES = exports.WOW_ABI = exports.WOW_FACTORY_ABI = exports.SUPPORTED_NETWORKS = void 0;\nexports.getFactoryAddress = getFactoryAddress;\nexports.SUPPORTED_NETWORKS = [\"base-mainnet\", \"base-sepolia\"];\nexports.WOW_FACTORY_ABI = [\n    {\n        type: \"constructor\",\n        inputs: [\n            { name: \"_tokenImplementation\", type: \"address\", internalType: \"address\" },\n            { name: \"_bondingCurve\", type: \"address\", internalType: \"address\" },\n        ],\n        stateMutability: \"nonpayable\",\n    },\n    {\n        type: \"function\",\n        name: \"UPGRADE_INTERFACE_VERSION\",\n        inputs: [],\n        outputs: [{ name: \"\", type: \"string\", internalType: \"string\" }],\n        stateMutability: \"view\",\n    },\n    {\n        type: \"function\",\n        name: \"bondingCurve\",\n        inputs: [],\n        outputs: [{ name: \"\", type: \"address\", internalType: \"address\" }],\n        stateMutability: \"view\",\n    },\n    {\n        type: \"function\",\n        name: \"deploy\",\n        inputs: [\n            { name: \"_tokenCreator\", type: \"address\", internalType: \"address\" },\n            { name: \"_platformReferrer\", type: \"address\", internalType: \"address\" },\n            { name: \"_tokenURI\", type: \"string\", internalType: \"string\" },\n            { name: \"_name\", type: \"string\", internalType: \"string\" },\n            { name: \"_symbol\", type: \"string\", internalType: \"string\" },\n        ],\n        outputs: [{ name: \"\", type: \"address\", internalType: \"address\" }],\n        stateMutability: \"payable\",\n    },\n    {\n        type: \"function\",\n        name: \"implementation\",\n        inputs: [],\n        outputs: [{ name: \"\", type: \"address\", internalType: \"address\" }],\n        stateMutability: \"view\",\n    },\n    {\n        type: \"function\",\n        name: \"initialize\",\n        inputs: [{ name: \"_owner\", type: \"address\", internalType: \"address\" }],\n        outputs: [],\n        stateMutability: \"nonpayable\",\n    },\n    {\n        type: \"function\",\n        name: \"owner\",\n        inputs: [],\n        outputs: [{ name: \"\", type: \"address\", internalType: \"address\" }],\n        stateMutability: \"view\",\n    },\n    {\n        type: \"function\",\n        name: \"proxiableUUID\",\n        inputs: [],\n        outputs: [{ name: \"\", type: \"bytes32\", internalType: \"bytes32\" }],\n        stateMutability: \"view\",\n    },\n    {\n        type: \"function\",\n        name: \"renounceOwnership\",\n        inputs: [],\n        outputs: [],\n        stateMutability: \"nonpayable\",\n    },\n    {\n        type: \"function\",\n        name: \"tokenImplementation\",\n        inputs: [],\n        outputs: [{ name: \"\", type: \"address\", internalType: \"address\" }],\n        stateMutability: \"view\",\n    },\n    {\n        type: \"function\",\n        name: \"transferOwnership\",\n        inputs: [{ name: \"newOwner\", type: \"address\", internalType: \"address\" }],\n        outputs: [],\n        stateMutability: \"nonpayable\",\n    },\n    {\n        type: \"function\",\n        name: \"upgradeToAndCall\",\n        inputs: [\n            { name: \"newImplementation\", type: \"address\", internalType: \"address\" },\n            { name: \"data\", type: \"bytes\", internalType: \"bytes\" },\n        ],\n        outputs: [],\n        stateMutability: \"payable\",\n    },\n    {\n        type: \"event\",\n        name: \"Initialized\",\n        inputs: [{ name: \"version\", type: \"uint64\", indexed: false, internalType: \"uint64\" }],\n        anonymous: false,\n    },\n    {\n        type: \"event\",\n        name: \"OwnershipTransferred\",\n        inputs: [\n            { name: \"previousOwner\", type: \"address\", indexed: true, internalType: \"address\" },\n            { name: \"newOwner\", type: \"address\", indexed: true, internalType: \"address\" },\n        ],\n        anonymous: false,\n    },\n    {\n        type: \"event\",\n        name: \"Upgraded\",\n        inputs: [{ name: \"implementation\", type: \"address\", indexed: true, internalType: \"address\" }],\n        anonymous: false,\n    },\n    {\n        type: \"error\",\n        name: \"AddressEmptyCode\",\n        inputs: [{ name: \"target\", type: \"address\", internalType: \"address\" }],\n    },\n    { type: \"error\", name: \"ERC1167FailedCreateClone\", inputs: [] },\n    {\n        type: \"error\",\n        name: \"ERC1967InvalidImplementation\",\n        inputs: [{ name: \"implementation\", type: \"address\", internalType: \"address\" }],\n    },\n    { type: \"error\", name: \"ERC1967NonPayable\", inputs: [] },\n    { type: \"error\", name: \"FailedInnerCall\", inputs: [] },\n    { type: \"error\", name: \"InvalidInitialization\", inputs: [] },\n    { type: \"error\", name: \"NotInitializing\", inputs: [] },\n    {\n        type: \"error\",\n        name: \"OwnableInvalidOwner\",\n        inputs: [{ name: \"owner\", type: \"address\", internalType: \"address\" }],\n    },\n    {\n        type: \"error\",\n        name: \"OwnableUnauthorizedAccount\",\n        inputs: [{ name: \"account\", type: \"address\", internalType: \"address\" }],\n    },\n    { type: \"error\", name: \"ReentrancyGuardReentrantCall\", inputs: [] },\n    { type: \"error\", name: \"UUPSUnauthorizedCallContext\", inputs: [] },\n    {\n        type: \"error\",\n        name: \"UUPSUnsupportedProxiableUUID\",\n        inputs: [{ name: \"slot\", type: \"bytes32\", internalType: \"bytes32\" }],\n    },\n];\nexports.WOW_ABI = [\n    {\n        inputs: [\n            { internalType: \"address\", name: \"_protocolFeeRecipient\", type: \"address\" },\n            { internalType: \"address\", name: \"_protocolRewards\", type: \"address\" },\n            { internalType: \"address\", name: \"_weth\", type: \"address\" },\n            { internalType: \"address\", name: \"_nonfungiblePositionManager\", type: \"address\" },\n            { internalType: \"address\", name: \"_swapRouter\", type: \"address\" },\n        ],\n        stateMutability: \"nonpayable\",\n        type: \"constructor\",\n    },\n    {\n        inputs: [{ internalType: \"address\", name: \"target\", type: \"address\" }],\n        name: \"AddressEmptyCode\",\n        type: \"error\",\n    },\n    {\n        inputs: [{ internalType: \"address\", name: \"account\", type: \"address\" }],\n        name: \"AddressInsufficientBalance\",\n        type: \"error\",\n    },\n    { inputs: [], name: \"AddressZero\", type: \"error\" },\n    {\n        inputs: [\n            { internalType: \"address\", name: \"spender\", type: \"address\" },\n            { internalType: \"uint256\", name: \"allowance\", type: \"uint256\" },\n            { internalType: \"uint256\", name: \"needed\", type: \"uint256\" },\n        ],\n        name: \"ERC20InsufficientAllowance\",\n        type: \"error\",\n    },\n    {\n        inputs: [\n            { internalType: \"address\", name: \"sender\", type: \"address\" },\n            { internalType: \"uint256\", name: \"balance\", type: \"uint256\" },\n            { internalType: \"uint256\", name: \"needed\", type: \"uint256\" },\n        ],\n        name: \"ERC20InsufficientBalance\",\n        type: \"error\",\n    },\n    {\n        inputs: [{ internalType: \"address\", name: \"approver\", type: \"address\" }],\n        name: \"ERC20InvalidApprover\",\n        type: \"error\",\n    },\n    {\n        inputs: [{ internalType: \"address\", name: \"receiver\", type: \"address\" }],\n        name: \"ERC20InvalidReceiver\",\n        type: \"error\",\n    },\n    {\n        inputs: [{ internalType: \"address\", name: \"sender\", type: \"address\" }],\n        name: \"ERC20InvalidSender\",\n        type: \"error\",\n    },\n    {\n        inputs: [{ internalType: \"address\", name: \"spender\", type: \"address\" }],\n        name: \"ERC20InvalidSpender\",\n        type: \"error\",\n    },\n    { inputs: [], name: \"EthAmountTooSmall\", type: \"error\" },\n    { inputs: [], name: \"EthTransferFailed\", type: \"error\" },\n    { inputs: [], name: \"FailedInnerCall\", type: \"error\" },\n    { inputs: [], name: \"InitialOrderSizeTooLarge\", type: \"error\" },\n    { inputs: [], name: \"InsufficientFunds\", type: \"error\" },\n    { inputs: [], name: \"InsufficientLiquidity\", type: \"error\" },\n    { inputs: [], name: \"InvalidInitialization\", type: \"error\" },\n    { inputs: [], name: \"InvalidMarketType\", type: \"error\" },\n    { inputs: [], name: \"MarketAlreadyGraduated\", type: \"error\" },\n    { inputs: [], name: \"MarketNotGraduated\", type: \"error\" },\n    { inputs: [], name: \"NotInitializing\", type: \"error\" },\n    { inputs: [], name: \"OnlyPool\", type: \"error\" },\n    { inputs: [], name: \"OnlyWeth\", type: \"error\" },\n    { inputs: [], name: \"ReentrancyGuardReentrantCall\", type: \"error\" },\n    {\n        inputs: [{ internalType: \"address\", name: \"token\", type: \"address\" }],\n        name: \"SafeERC20FailedOperation\",\n        type: \"error\",\n    },\n    { inputs: [], name: \"SlippageBoundsExceeded\", type: \"error\" },\n    {\n        anonymous: false,\n        inputs: [\n            { indexed: true, internalType: \"address\", name: \"owner\", type: \"address\" },\n            { indexed: true, internalType: \"address\", name: \"spender\", type: \"address\" },\n            { indexed: false, internalType: \"uint256\", name: \"value\", type: \"uint256\" },\n        ],\n        name: \"Approval\",\n        type: \"event\",\n    },\n    {\n        anonymous: false,\n        inputs: [{ indexed: false, internalType: \"uint64\", name: \"version\", type: \"uint64\" }],\n        name: \"Initialized\",\n        type: \"event\",\n    },\n    {\n        anonymous: false,\n        inputs: [\n            { indexed: true, internalType: \"address\", name: \"from\", type: \"address\" },\n            { indexed: true, internalType: \"address\", name: \"to\", type: \"address\" },\n            { indexed: false, internalType: \"uint256\", name: \"value\", type: \"uint256\" },\n        ],\n        name: \"Transfer\",\n        type: \"event\",\n    },\n    {\n        anonymous: false,\n        inputs: [\n            { indexed: true, internalType: \"address\", name: \"tokenAddress\", type: \"address\" },\n            { indexed: true, internalType: \"address\", name: \"poolAddress\", type: \"address\" },\n            {\n                indexed: false,\n                internalType: \"uint256\",\n                name: \"totalEthLiquidity\",\n                type: \"uint256\",\n            },\n            {\n                indexed: false,\n                internalType: \"uint256\",\n                name: \"totalTokenLiquidity\",\n                type: \"uint256\",\n            },\n            {\n                indexed: false,\n                internalType: \"uint256\",\n                name: \"lpPositionId\",\n                type: \"uint256\",\n            },\n            {\n                indexed: false,\n                internalType: \"enum IWow.MarketType\",\n                name: \"marketType\",\n                type: \"uint8\",\n            },\n        ],\n        name: \"WowMarketGraduated\",\n        type: \"event\",\n    },\n    {\n        anonymous: false,\n        inputs: [\n            { indexed: true, internalType: \"address\", name: \"buyer\", type: \"address\" },\n            { indexed: true, internalType: \"address\", name: \"recipient\", type: \"address\" },\n            {\n                indexed: true,\n                internalType: \"address\",\n                name: \"orderReferrer\",\n                type: \"address\",\n            },\n            { indexed: false, internalType: \"uint256\", name: \"totalEth\", type: \"uint256\" },\n            { indexed: false, internalType: \"uint256\", name: \"ethFee\", type: \"uint256\" },\n            { indexed: false, internalType: \"uint256\", name: \"ethSold\", type: \"uint256\" },\n            {\n                indexed: false,\n                internalType: \"uint256\",\n                name: \"tokensBought\",\n                type: \"uint256\",\n            },\n            {\n                indexed: false,\n                internalType: \"uint256\",\n                name: \"buyerTokenBalance\",\n                type: \"uint256\",\n            },\n            { indexed: false, internalType: \"string\", name: \"comment\", type: \"string\" },\n            {\n                indexed: false,\n                internalType: \"enum IWow.MarketType\",\n                name: \"marketType\",\n                type: \"uint8\",\n            },\n        ],\n        name: \"WowTokenBuy\",\n        type: \"event\",\n    },\n    {\n        anonymous: false,\n        inputs: [\n            {\n                indexed: true,\n                internalType: \"address\",\n                name: \"factoryAddress\",\n                type: \"address\",\n            },\n            { indexed: true, internalType: \"address\", name: \"tokenCreator\", type: \"address\" },\n            {\n                indexed: false,\n                internalType: \"address\",\n                name: \"platformReferrer\",\n                type: \"address\",\n            },\n            {\n                indexed: false,\n                internalType: \"address\",\n                name: \"protocolFeeRecipient\",\n                type: \"address\",\n            },\n            {\n                indexed: false,\n                internalType: \"address\",\n                name: \"bondingCurve\",\n                type: \"address\",\n            },\n            { indexed: false, internalType: \"string\", name: \"tokenURI\", type: \"string\" },\n            { indexed: false, internalType: \"string\", name: \"name\", type: \"string\" },\n            { indexed: false, internalType: \"string\", name: \"symbol\", type: \"string\" },\n            {\n                indexed: false,\n                internalType: \"address\",\n                name: \"tokenAddress\",\n                type: \"address\",\n            },\n            { indexed: false, internalType: \"address\", name: \"poolAddress\", type: \"address\" },\n        ],\n        name: \"WowTokenCreated\",\n        type: \"event\",\n    },\n    {\n        anonymous: false,\n        inputs: [\n            { indexed: true, internalType: \"address\", name: \"tokenCreator\", type: \"address\" },\n            {\n                indexed: true,\n                internalType: \"address\",\n                name: \"platformReferrer\",\n                type: \"address\",\n            },\n            {\n                indexed: true,\n                internalType: \"address\",\n                name: \"orderReferrer\",\n                type: \"address\",\n            },\n            {\n                indexed: false,\n                internalType: \"address\",\n                name: \"protocolFeeRecipient\",\n                type: \"address\",\n            },\n            {\n                indexed: false,\n                internalType: \"uint256\",\n                name: \"tokenCreatorFee\",\n                type: \"uint256\",\n            },\n            {\n                indexed: false,\n                internalType: \"uint256\",\n                name: \"platformReferrerFee\",\n                type: \"uint256\",\n            },\n            {\n                indexed: false,\n                internalType: \"uint256\",\n                name: \"orderReferrerFee\",\n                type: \"uint256\",\n            },\n            { indexed: false, internalType: \"uint256\", name: \"protocolFee\", type: \"uint256\" },\n        ],\n        name: \"WowTokenFees\",\n        type: \"event\",\n    },\n    {\n        anonymous: false,\n        inputs: [\n            { indexed: true, internalType: \"address\", name: \"seller\", type: \"address\" },\n            { indexed: true, internalType: \"address\", name: \"recipient\", type: \"address\" },\n            {\n                indexed: true,\n                internalType: \"address\",\n                name: \"orderReferrer\",\n                type: \"address\",\n            },\n            { indexed: false, internalType: \"uint256\", name: \"totalEth\", type: \"uint256\" },\n            { indexed: false, internalType: \"uint256\", name: \"ethFee\", type: \"uint256\" },\n            { indexed: false, internalType: \"uint256\", name: \"ethBought\", type: \"uint256\" },\n            { indexed: false, internalType: \"uint256\", name: \"tokensSold\", type: \"uint256\" },\n            {\n                indexed: false,\n                internalType: \"uint256\",\n                name: \"sellerTokenBalance\",\n                type: \"uint256\",\n            },\n            { indexed: false, internalType: \"string\", name: \"comment\", type: \"string\" },\n            {\n                indexed: false,\n                internalType: \"enum IWow.MarketType\",\n                name: \"marketType\",\n                type: \"uint8\",\n            },\n        ],\n        name: \"WowTokenSell\",\n        type: \"event\",\n    },\n    {\n        anonymous: false,\n        inputs: [\n            { indexed: true, internalType: \"address\", name: \"from\", type: \"address\" },\n            { indexed: true, internalType: \"address\", name: \"to\", type: \"address\" },\n            { indexed: false, internalType: \"uint256\", name: \"amount\", type: \"uint256\" },\n            {\n                indexed: false,\n                internalType: \"uint256\",\n                name: \"fromTokenBalance\",\n                type: \"uint256\",\n            },\n            {\n                indexed: false,\n                internalType: \"uint256\",\n                name: \"toTokenBalance\",\n                type: \"uint256\",\n            },\n            { indexed: false, internalType: \"uint256\", name: \"totalSupply\", type: \"uint256\" },\n        ],\n        name: \"WowTokenTransfer\",\n        type: \"event\",\n    },\n    {\n        inputs: [],\n        name: \"MAX_TOTAL_SUPPLY\",\n        outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n        stateMutability: \"view\",\n        type: \"function\",\n    },\n    {\n        inputs: [],\n        name: \"MIN_ORDER_SIZE\",\n        outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n        stateMutability: \"view\",\n        type: \"function\",\n    },\n    {\n        inputs: [],\n        name: \"ORDER_REFERRER_FEE_BPS\",\n        outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n        stateMutability: \"view\",\n        type: \"function\",\n    },\n    {\n        inputs: [],\n        name: \"PLATFORM_REFERRER_FEE_BPS\",\n        outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n        stateMutability: \"view\",\n        type: \"function\",\n    },\n    {\n        inputs: [],\n        name: \"PROTOCOL_FEE_BPS\",\n        outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n        stateMutability: \"view\",\n        type: \"function\",\n    },\n    {\n        inputs: [],\n        name: \"TOKEN_CREATOR_FEE_BPS\",\n        outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n        stateMutability: \"view\",\n        type: \"function\",\n    },\n    {\n        inputs: [],\n        name: \"TOTAL_FEE_BPS\",\n        outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n        stateMutability: \"view\",\n        type: \"function\",\n    },\n    {\n        inputs: [],\n        name: \"WETH\",\n        outputs: [{ internalType: \"address\", name: \"\", type: \"address\" }],\n        stateMutability: \"view\",\n        type: \"function\",\n    },\n    {\n        inputs: [\n            { internalType: \"address\", name: \"owner\", type: \"address\" },\n            { internalType: \"address\", name: \"spender\", type: \"address\" },\n        ],\n        name: \"allowance\",\n        outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n        stateMutability: \"view\",\n        type: \"function\",\n    },\n    {\n        inputs: [\n            { internalType: \"address\", name: \"spender\", type: \"address\" },\n            { internalType: \"uint256\", name: \"value\", type: \"uint256\" },\n        ],\n        name: \"approve\",\n        outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n        stateMutability: \"nonpayable\",\n        type: \"function\",\n    },\n    {\n        inputs: [{ internalType: \"address\", name: \"account\", type: \"address\" }],\n        name: \"balanceOf\",\n        outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n        stateMutability: \"view\",\n        type: \"function\",\n    },\n    {\n        inputs: [],\n        name: \"bondingCurve\",\n        outputs: [{ internalType: \"contract BondingCurve\", name: \"\", type: \"address\" }],\n        stateMutability: \"view\",\n        type: \"function\",\n    },\n    {\n        inputs: [{ internalType: \"uint256\", name: \"tokensToBurn\", type: \"uint256\" }],\n        name: \"burn\",\n        outputs: [],\n        stateMutability: \"nonpayable\",\n        type: \"function\",\n    },\n    {\n        inputs: [\n            { internalType: \"address\", name: \"recipient\", type: \"address\" },\n            { internalType: \"address\", name: \"refundRecipient\", type: \"address\" },\n            { internalType: \"address\", name: \"orderReferrer\", type: \"address\" },\n            { internalType: \"string\", name: \"comment\", type: \"string\" },\n            { internalType: \"enum IWow.MarketType\", name: \"expectedMarketType\", type: \"uint8\" },\n            { internalType: \"uint256\", name: \"minOrderSize\", type: \"uint256\" },\n            { internalType: \"uint160\", name: \"sqrtPriceLimitX96\", type: \"uint160\" },\n        ],\n        name: \"buy\",\n        outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n        stateMutability: \"payable\",\n        type: \"function\",\n    },\n    {\n        inputs: [],\n        name: \"currentExchangeRate\",\n        outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n        stateMutability: \"view\",\n        type: \"function\",\n    },\n    {\n        inputs: [],\n        name: \"decimals\",\n        outputs: [{ internalType: \"uint8\", name: \"\", type: \"uint8\" }],\n        stateMutability: \"view\",\n        type: \"function\",\n    },\n    {\n        inputs: [{ internalType: \"uint256\", name: \"ethOrderSize\", type: \"uint256\" }],\n        name: \"getEthBuyQuote\",\n        outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n        stateMutability: \"view\",\n        type: \"function\",\n    },\n    {\n        inputs: [{ internalType: \"uint256\", name: \"ethOrderSize\", type: \"uint256\" }],\n        name: \"getEthSellQuote\",\n        outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n        stateMutability: \"view\",\n        type: \"function\",\n    },\n    {\n        inputs: [{ internalType: \"uint256\", name: \"tokenOrderSize\", type: \"uint256\" }],\n        name: \"getTokenBuyQuote\",\n        outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n        stateMutability: \"view\",\n        type: \"function\",\n    },\n    {\n        inputs: [{ internalType: \"uint256\", name: \"tokenOrderSize\", type: \"uint256\" }],\n        name: \"getTokenSellQuote\",\n        outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n        stateMutability: \"view\",\n        type: \"function\",\n    },\n    {\n        inputs: [\n            { internalType: \"address\", name: \"_tokenCreator\", type: \"address\" },\n            { internalType: \"address\", name: \"_platformReferrer\", type: \"address\" },\n            { internalType: \"address\", name: \"_bondingCurve\", type: \"address\" },\n            { internalType: \"string\", name: \"_tokenURI\", type: \"string\" },\n            { internalType: \"string\", name: \"_name\", type: \"string\" },\n            { internalType: \"string\", name: \"_symbol\", type: \"string\" },\n        ],\n        name: \"initialize\",\n        outputs: [],\n        stateMutability: \"payable\",\n        type: \"function\",\n    },\n    {\n        inputs: [],\n        name: \"marketType\",\n        outputs: [{ internalType: \"enum IWow.MarketType\", name: \"\", type: \"uint8\" }],\n        stateMutability: \"view\",\n        type: \"function\",\n    },\n    {\n        inputs: [],\n        name: \"name\",\n        outputs: [{ internalType: \"string\", name: \"\", type: \"string\" }],\n        stateMutability: \"view\",\n        type: \"function\",\n    },\n    {\n        inputs: [],\n        name: \"nonfungiblePositionManager\",\n        outputs: [{ internalType: \"address\", name: \"\", type: \"address\" }],\n        stateMutability: \"view\",\n        type: \"function\",\n    },\n    {\n        inputs: [\n            { internalType: \"address\", name: \"\", type: \"address\" },\n            { internalType: \"address\", name: \"\", type: \"address\" },\n            { internalType: \"uint256\", name: \"\", type: \"uint256\" },\n            { internalType: \"bytes\", name: \"\", type: \"bytes\" },\n        ],\n        name: \"onERC721Received\",\n        outputs: [{ internalType: \"bytes4\", name: \"\", type: \"bytes4\" }],\n        stateMutability: \"view\",\n        type: \"function\",\n    },\n    {\n        inputs: [],\n        name: \"platformReferrer\",\n        outputs: [{ internalType: \"address\", name: \"\", type: \"address\" }],\n        stateMutability: \"view\",\n        type: \"function\",\n    },\n    {\n        inputs: [],\n        name: \"poolAddress\",\n        outputs: [{ internalType: \"address\", name: \"\", type: \"address\" }],\n        stateMutability: \"view\",\n        type: \"function\",\n    },\n    {\n        inputs: [],\n        name: \"protocolFeeRecipient\",\n        outputs: [{ internalType: \"address\", name: \"\", type: \"address\" }],\n        stateMutability: \"view\",\n        type: \"function\",\n    },\n    {\n        inputs: [],\n        name: \"protocolRewards\",\n        outputs: [{ internalType: \"address\", name: \"\", type: \"address\" }],\n        stateMutability: \"view\",\n        type: \"function\",\n    },\n    {\n        inputs: [\n            { internalType: \"uint256\", name: \"tokensToSell\", type: \"uint256\" },\n            { internalType: \"address\", name: \"recipient\", type: \"address\" },\n            { internalType: \"address\", name: \"orderReferrer\", type: \"address\" },\n            { internalType: \"string\", name: \"comment\", type: \"string\" },\n            { internalType: \"enum IWow.MarketType\", name: \"expectedMarketType\", type: \"uint8\" },\n            { internalType: \"uint256\", name: \"minPayoutSize\", type: \"uint256\" },\n            { internalType: \"uint160\", name: \"sqrtPriceLimitX96\", type: \"uint160\" },\n        ],\n        name: \"sell\",\n        outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n        stateMutability: \"nonpayable\",\n        type: \"function\",\n    },\n    {\n        inputs: [],\n        name: \"state\",\n        outputs: [\n            {\n                components: [\n                    { internalType: \"enum IWow.MarketType\", name: \"marketType\", type: \"uint8\" },\n                    { internalType: \"address\", name: \"marketAddress\", type: \"address\" },\n                ],\n                internalType: \"struct IWow.MarketState\",\n                name: \"\",\n                type: \"tuple\",\n            },\n        ],\n        stateMutability: \"view\",\n        type: \"function\",\n    },\n    {\n        inputs: [],\n        name: \"swapRouter\",\n        outputs: [{ internalType: \"address\", name: \"\", type: \"address\" }],\n        stateMutability: \"view\",\n        type: \"function\",\n    },\n    {\n        inputs: [],\n        name: \"symbol\",\n        outputs: [{ internalType: \"string\", name: \"\", type: \"string\" }],\n        stateMutability: \"view\",\n        type: \"function\",\n    },\n    {\n        inputs: [],\n        name: \"tokenCreator\",\n        outputs: [{ internalType: \"address\", name: \"\", type: \"address\" }],\n        stateMutability: \"view\",\n        type: \"function\",\n    },\n    {\n        inputs: [],\n        name: \"tokenURI\",\n        outputs: [{ internalType: \"string\", name: \"\", type: \"string\" }],\n        stateMutability: \"view\",\n        type: \"function\",\n    },\n    {\n        inputs: [],\n        name: \"totalSupply\",\n        outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n        stateMutability: \"view\",\n        type: \"function\",\n    },\n    {\n        inputs: [\n            { internalType: \"address\", name: \"to\", type: \"address\" },\n            { internalType: \"uint256\", name: \"value\", type: \"uint256\" },\n        ],\n        name: \"transfer\",\n        outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n        stateMutability: \"nonpayable\",\n        type: \"function\",\n    },\n    {\n        inputs: [\n            { internalType: \"address\", name: \"from\", type: \"address\" },\n            { internalType: \"address\", name: \"to\", type: \"address\" },\n            { internalType: \"uint256\", name: \"value\", type: \"uint256\" },\n        ],\n        name: \"transferFrom\",\n        outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n        stateMutability: \"nonpayable\",\n        type: \"function\",\n    },\n    {\n        inputs: [\n            { internalType: \"int256\", name: \"amount0Delta\", type: \"int256\" },\n            { internalType: \"int256\", name: \"amount1Delta\", type: \"int256\" },\n            { internalType: \"bytes\", name: \"\", type: \"bytes\" },\n        ],\n        name: \"uniswapV3SwapCallback\",\n        outputs: [],\n        stateMutability: \"nonpayable\",\n        type: \"function\",\n    },\n    { stateMutability: \"payable\", type: \"receive\" },\n];\nexports.WOW_FACTORY_CONTRACT_ADDRESSES = {\n    \"base-sepolia\": \"0x04870e22fa217Cb16aa00501D7D5253B8838C1eA\",\n    \"base-mainnet\": \"0x997020E5F59cCB79C74D527Be492Cc610CB9fA2B\",\n};\nexports.ADDRESSES = {\n    \"base-sepolia\": {\n        WowFactory: \"0xB09c0b1b18369Ef62e896D5a49Af8d65EFa0A404\",\n        WowFactoryImpl: \"0xB522291f22FE7FA45D56797F7A685D5c637Edc32\",\n        Wow: \"0x15ba66e376856F3F6FE53dE9eeAb10dEF10E8C92\",\n        BondingCurve: \"0xCE00c75B9807A2aA87B2297cA7Dc1C0190137D6F\",\n        NonfungiblePositionManager: \"0x27F971cb582BF9E50F397e4d29a5C7A34f11faA2\",\n        SwapRouter02: \"0x94cC0AaC535CCDB3C01d6787D6413C739ae12bc4\",\n        WETH: \"0x4200000000000000000000000000000000000006\",\n        UniswapQuoter: \"0xC5290058841028F1614F3A6F0F5816cAd0df5E27\",\n    },\n    \"base-mainnet\": {\n        WowFactory: \"0xA06262157905913f855573f53AD48DE2D4ba1F4A\",\n        WowFactoryImpl: \"0xe4c17055048aEe01D0d122804816fEe5E6ac4A67\",\n        Wow: \"0x293997C6a1f2A1cA3aB971f548c4D95585E46282\",\n        BondingCurve: \"0x264ece5D58A576cc775B719bf182F2946076bE78\",\n        NonfungiblePositionManager: \"0x03a520b32C04BF3bEEf7BEb72E919cf822Ed34f1\",\n        SwapRouter02: \"0x2626664c2603336E57B271c5C0b26F421741e481\",\n        WETH: \"0x4200000000000000000000000000000000000006\",\n        UniswapQuoter: \"0x3d4e44Eb1374240CE5F1B871ab261CD16335B76a\",\n    },\n};\nexports.GENERIC_TOKEN_METADATA_URI = \"ipfs://QmY1GqprFYvojCcUEKgqHeDj9uhZD9jmYGrQTfA9vAE78J\";\n/**\n * Gets the Zora Wow ERC20 Factory contract address for the specified network.\n *\n * @param network - The network ID to get the contract address for\n * @returns The contract address for the specified network\n * @throws Error if the specified network is not supported\n */\nfunction getFactoryAddress(network) {\n    const normalizedNetwork = network.toLowerCase();\n    if (!(normalizedNetwork in exports.WOW_FACTORY_CONTRACT_ADDRESSES)) {\n        throw new Error(`Invalid network: ${network}. Valid networks are: ${Object.keys(exports.WOW_FACTORY_CONTRACT_ADDRESSES).join(\", \")}`);\n    }\n    return exports.WOW_FACTORY_CONTRACT_ADDRESSES[normalizedNetwork];\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy93b3cvY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtDQUFrQyxHQUFHLGlCQUFpQixHQUFHLHNDQUFzQyxHQUFHLGVBQWUsR0FBRyx1QkFBdUIsR0FBRywwQkFBMEI7QUFDeEsseUJBQXlCO0FBQ3pCLDBCQUEwQjtBQUMxQix1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsY0FBYyx3RUFBd0U7QUFDdEYsY0FBYyxpRUFBaUU7QUFDL0U7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrREFBa0Q7QUFDdEU7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0RBQW9EO0FBQ3hFO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxpRUFBaUU7QUFDL0UsY0FBYyxxRUFBcUU7QUFDbkYsY0FBYywyREFBMkQ7QUFDekUsY0FBYyx1REFBdUQ7QUFDckUsY0FBYyx5REFBeUQ7QUFDdkU7QUFDQSxvQkFBb0Isb0RBQW9EO0FBQ3hFO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9EQUFvRDtBQUN4RTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMERBQTBEO0FBQzdFO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0RBQW9EO0FBQ3hFO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9EQUFvRDtBQUN4RTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0RBQW9EO0FBQ3hFO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw0REFBNEQ7QUFDL0U7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMscUVBQXFFO0FBQ25GLGNBQWMsb0RBQW9EO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIseUVBQXlFO0FBQzVGO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxnRkFBZ0Y7QUFDOUYsY0FBYywyRUFBMkU7QUFDekY7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUZBQWlGO0FBQ3BHO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwwREFBMEQ7QUFDN0UsS0FBSztBQUNMLE1BQU0sNkRBQTZEO0FBQ25FO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrRUFBa0U7QUFDckYsS0FBSztBQUNMLE1BQU0sc0RBQXNEO0FBQzVELE1BQU0sb0RBQW9EO0FBQzFELE1BQU0sMERBQTBEO0FBQ2hFLE1BQU0sb0RBQW9EO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix5REFBeUQ7QUFDNUUsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwyREFBMkQ7QUFDOUUsS0FBSztBQUNMLE1BQU0saUVBQWlFO0FBQ3ZFLE1BQU0sZ0VBQWdFO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix3REFBd0Q7QUFDM0UsS0FBSztBQUNMO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxjQUFjLHlFQUF5RTtBQUN2RixjQUFjLG9FQUFvRTtBQUNsRixjQUFjLHlEQUF5RDtBQUN2RSxjQUFjLCtFQUErRTtBQUM3RixjQUFjLCtEQUErRDtBQUM3RTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxtQkFBbUIsMERBQTBEO0FBQzdFO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxtQkFBbUIsMkRBQTJEO0FBQzlFO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsTUFBTSxnREFBZ0Q7QUFDdEQ7QUFDQTtBQUNBLGNBQWMsMkRBQTJEO0FBQ3pFLGNBQWMsNkRBQTZEO0FBQzNFLGNBQWMsMERBQTBEO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsY0FBYywwREFBMEQ7QUFDeEUsY0FBYywyREFBMkQ7QUFDekUsY0FBYywwREFBMEQ7QUFDeEU7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsbUJBQW1CLDREQUE0RDtBQUMvRTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsbUJBQW1CLDREQUE0RDtBQUMvRTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsbUJBQW1CLDBEQUEwRDtBQUM3RTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsbUJBQW1CLDJEQUEyRDtBQUM5RTtBQUNBO0FBQ0EsS0FBSztBQUNMLE1BQU0sc0RBQXNEO0FBQzVELE1BQU0sc0RBQXNEO0FBQzVELE1BQU0sb0RBQW9EO0FBQzFELE1BQU0sNkRBQTZEO0FBQ25FLE1BQU0sc0RBQXNEO0FBQzVELE1BQU0sMERBQTBEO0FBQ2hFLE1BQU0sMERBQTBEO0FBQ2hFLE1BQU0sc0RBQXNEO0FBQzVELE1BQU0sMkRBQTJEO0FBQ2pFLE1BQU0sdURBQXVEO0FBQzdELE1BQU0sb0RBQW9EO0FBQzFELE1BQU0sNkNBQTZDO0FBQ25ELE1BQU0sNkNBQTZDO0FBQ25ELE1BQU0saUVBQWlFO0FBQ3ZFO0FBQ0EsbUJBQW1CLHlEQUF5RDtBQUM1RTtBQUNBO0FBQ0EsS0FBSztBQUNMLE1BQU0sMkRBQTJEO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBLGNBQWMsd0VBQXdFO0FBQ3RGLGNBQWMsMEVBQTBFO0FBQ3hGLGNBQWMseUVBQXlFO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsbUJBQW1CLHlFQUF5RTtBQUM1RjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGNBQWMsdUVBQXVFO0FBQ3JGLGNBQWMscUVBQXFFO0FBQ25GLGNBQWMseUVBQXlFO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxjQUFjLCtFQUErRTtBQUM3RixjQUFjLDhFQUE4RTtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxjQUFjLHdFQUF3RTtBQUN0RixjQUFjLDRFQUE0RTtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLGNBQWMsNEVBQTRFO0FBQzFGLGNBQWMsMEVBQTBFO0FBQ3hGLGNBQWMsMkVBQTJFO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixjQUFjLHlFQUF5RTtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLGNBQWMsK0VBQStFO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLGNBQWMsMEVBQTBFO0FBQ3hGLGNBQWMsc0VBQXNFO0FBQ3BGLGNBQWMsd0VBQXdFO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsY0FBYywrRUFBK0U7QUFDN0Y7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGNBQWMsK0VBQStFO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLGNBQWMsK0VBQStFO0FBQzdGO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxjQUFjLHlFQUF5RTtBQUN2RixjQUFjLDRFQUE0RTtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLGNBQWMsNEVBQTRFO0FBQzFGLGNBQWMsMEVBQTBFO0FBQ3hGLGNBQWMsNkVBQTZFO0FBQzNGLGNBQWMsOEVBQThFO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsY0FBYyx5RUFBeUU7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsY0FBYyx1RUFBdUU7QUFDckYsY0FBYyxxRUFBcUU7QUFDbkYsY0FBYywwRUFBMEU7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLGNBQWMsK0VBQStFO0FBQzdGO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0RBQW9EO0FBQ3hFO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9EQUFvRDtBQUN4RTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvREFBb0Q7QUFDeEU7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0RBQW9EO0FBQ3hFO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9EQUFvRDtBQUN4RTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvREFBb0Q7QUFDeEU7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0RBQW9EO0FBQ3hFO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9EQUFvRDtBQUN4RTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxjQUFjLHlEQUF5RDtBQUN2RSxjQUFjLDJEQUEyRDtBQUN6RTtBQUNBO0FBQ0Esb0JBQW9CLG9EQUFvRDtBQUN4RTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxjQUFjLDJEQUEyRDtBQUN6RSxjQUFjLHlEQUF5RDtBQUN2RTtBQUNBO0FBQ0Esb0JBQW9CLDhDQUE4QztBQUNsRTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsbUJBQW1CLDJEQUEyRDtBQUM5RTtBQUNBLG9CQUFvQixvREFBb0Q7QUFDeEU7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0VBQWtFO0FBQ3RGO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxtQkFBbUIsZ0VBQWdFO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxjQUFjLDZEQUE2RDtBQUMzRSxjQUFjLG1FQUFtRTtBQUNqRixjQUFjLGlFQUFpRTtBQUMvRSxjQUFjLHlEQUF5RDtBQUN2RSxjQUFjLGlGQUFpRjtBQUMvRixjQUFjLGdFQUFnRTtBQUM5RSxjQUFjLHFFQUFxRTtBQUNuRjtBQUNBO0FBQ0Esb0JBQW9CLG9EQUFvRDtBQUN4RTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvREFBb0Q7QUFDeEU7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0RBQWdEO0FBQ3BFO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxtQkFBbUIsZ0VBQWdFO0FBQ25GO0FBQ0Esb0JBQW9CLG9EQUFvRDtBQUN4RTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsbUJBQW1CLGdFQUFnRTtBQUNuRjtBQUNBLG9CQUFvQixvREFBb0Q7QUFDeEU7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLG1CQUFtQixrRUFBa0U7QUFDckY7QUFDQSxvQkFBb0Isb0RBQW9EO0FBQ3hFO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxtQkFBbUIsa0VBQWtFO0FBQ3JGO0FBQ0Esb0JBQW9CLG9EQUFvRDtBQUN4RTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxjQUFjLGlFQUFpRTtBQUMvRSxjQUFjLHFFQUFxRTtBQUNuRixjQUFjLGlFQUFpRTtBQUMvRSxjQUFjLDJEQUEyRDtBQUN6RSxjQUFjLHVEQUF1RDtBQUNyRSxjQUFjLHlEQUF5RDtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwrREFBK0Q7QUFDbkY7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0RBQWtEO0FBQ3RFO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9EQUFvRDtBQUN4RTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxjQUFjLG9EQUFvRDtBQUNsRSxjQUFjLG9EQUFvRDtBQUNsRSxjQUFjLG9EQUFvRDtBQUNsRSxjQUFjLGdEQUFnRDtBQUM5RDtBQUNBO0FBQ0Esb0JBQW9CLGtEQUFrRDtBQUN0RTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvREFBb0Q7QUFDeEU7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0RBQW9EO0FBQ3hFO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9EQUFvRDtBQUN4RTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvREFBb0Q7QUFDeEU7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsY0FBYyxnRUFBZ0U7QUFDOUUsY0FBYyw2REFBNkQ7QUFDM0UsY0FBYyxpRUFBaUU7QUFDL0UsY0FBYyx5REFBeUQ7QUFDdkUsY0FBYyxpRkFBaUY7QUFDL0YsY0FBYyxpRUFBaUU7QUFDL0UsY0FBYyxxRUFBcUU7QUFDbkY7QUFDQTtBQUNBLG9CQUFvQixvREFBb0Q7QUFDeEU7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IseUVBQXlFO0FBQy9GLHNCQUFzQixpRUFBaUU7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvREFBb0Q7QUFDeEU7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0RBQWtEO0FBQ3RFO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9EQUFvRDtBQUN4RTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrREFBa0Q7QUFDdEU7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0RBQW9EO0FBQ3hFO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGNBQWMsc0RBQXNEO0FBQ3BFLGNBQWMseURBQXlEO0FBQ3ZFO0FBQ0E7QUFDQSxvQkFBb0IsOENBQThDO0FBQ2xFO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGNBQWMsd0RBQXdEO0FBQ3RFLGNBQWMsc0RBQXNEO0FBQ3BFLGNBQWMseURBQXlEO0FBQ3ZFO0FBQ0E7QUFDQSxvQkFBb0IsOENBQThDO0FBQ2xFO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGNBQWMsOERBQThEO0FBQzVFLGNBQWMsOERBQThEO0FBQzVFLGNBQWMsZ0RBQWdEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsTUFBTSw2Q0FBNkM7QUFDbkQ7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUSx3QkFBd0IsK0RBQStEO0FBQzNJO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cnZpdmFsLWZ1bi8uL25vZGVfbW9kdWxlcy9AY29pbmJhc2UvYWdlbnRraXQvZGlzdC9hY3Rpb24tcHJvdmlkZXJzL3dvdy9jb25zdGFudHMuanM/ZmFmOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuR0VORVJJQ19UT0tFTl9NRVRBREFUQV9VUkkgPSBleHBvcnRzLkFERFJFU1NFUyA9IGV4cG9ydHMuV09XX0ZBQ1RPUllfQ09OVFJBQ1RfQUREUkVTU0VTID0gZXhwb3J0cy5XT1dfQUJJID0gZXhwb3J0cy5XT1dfRkFDVE9SWV9BQkkgPSBleHBvcnRzLlNVUFBPUlRFRF9ORVRXT1JLUyA9IHZvaWQgMDtcbmV4cG9ydHMuZ2V0RmFjdG9yeUFkZHJlc3MgPSBnZXRGYWN0b3J5QWRkcmVzcztcbmV4cG9ydHMuU1VQUE9SVEVEX05FVFdPUktTID0gW1wiYmFzZS1tYWlubmV0XCIsIFwiYmFzZS1zZXBvbGlhXCJdO1xuZXhwb3J0cy5XT1dfRkFDVE9SWV9BQkkgPSBbXG4gICAge1xuICAgICAgICB0eXBlOiBcImNvbnN0cnVjdG9yXCIsXG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAgeyBuYW1lOiBcIl90b2tlbkltcGxlbWVudGF0aW9uXCIsIHR5cGU6IFwiYWRkcmVzc1wiLCBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiIH0sXG4gICAgICAgICAgICB7IG5hbWU6IFwiX2JvbmRpbmdDdXJ2ZVwiLCB0eXBlOiBcImFkZHJlc3NcIiwgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIiB9LFxuICAgICAgICBdLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6IFwibm9ucGF5YWJsZVwiLFxuICAgIH0sXG4gICAge1xuICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgIG5hbWU6IFwiVVBHUkFERV9JTlRFUkZBQ0VfVkVSU0lPTlwiLFxuICAgICAgICBpbnB1dHM6IFtdLFxuICAgICAgICBvdXRwdXRzOiBbeyBuYW1lOiBcIlwiLCB0eXBlOiBcInN0cmluZ1wiLCBpbnRlcm5hbFR5cGU6IFwic3RyaW5nXCIgfV0sXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgbmFtZTogXCJib25kaW5nQ3VydmVcIixcbiAgICAgICAgaW5wdXRzOiBbXSxcbiAgICAgICAgb3V0cHV0czogW3sgbmFtZTogXCJcIiwgdHlwZTogXCJhZGRyZXNzXCIsIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIgfV0sXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgbmFtZTogXCJkZXBsb3lcIixcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7IG5hbWU6IFwiX3Rva2VuQ3JlYXRvclwiLCB0eXBlOiBcImFkZHJlc3NcIiwgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIiB9LFxuICAgICAgICAgICAgeyBuYW1lOiBcIl9wbGF0Zm9ybVJlZmVycmVyXCIsIHR5cGU6IFwiYWRkcmVzc1wiLCBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiIH0sXG4gICAgICAgICAgICB7IG5hbWU6IFwiX3Rva2VuVVJJXCIsIHR5cGU6IFwic3RyaW5nXCIsIGludGVybmFsVHlwZTogXCJzdHJpbmdcIiB9LFxuICAgICAgICAgICAgeyBuYW1lOiBcIl9uYW1lXCIsIHR5cGU6IFwic3RyaW5nXCIsIGludGVybmFsVHlwZTogXCJzdHJpbmdcIiB9LFxuICAgICAgICAgICAgeyBuYW1lOiBcIl9zeW1ib2xcIiwgdHlwZTogXCJzdHJpbmdcIiwgaW50ZXJuYWxUeXBlOiBcInN0cmluZ1wiIH0sXG4gICAgICAgIF0sXG4gICAgICAgIG91dHB1dHM6IFt7IG5hbWU6IFwiXCIsIHR5cGU6IFwiYWRkcmVzc1wiLCBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiIH1dLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6IFwicGF5YWJsZVwiLFxuICAgIH0sXG4gICAge1xuICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgIG5hbWU6IFwiaW1wbGVtZW50YXRpb25cIixcbiAgICAgICAgaW5wdXRzOiBbXSxcbiAgICAgICAgb3V0cHV0czogW3sgbmFtZTogXCJcIiwgdHlwZTogXCJhZGRyZXNzXCIsIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIgfV0sXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgbmFtZTogXCJpbml0aWFsaXplXCIsXG4gICAgICAgIGlucHV0czogW3sgbmFtZTogXCJfb3duZXJcIiwgdHlwZTogXCJhZGRyZXNzXCIsIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIgfV0sXG4gICAgICAgIG91dHB1dHM6IFtdLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6IFwibm9ucGF5YWJsZVwiLFxuICAgIH0sXG4gICAge1xuICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgIG5hbWU6IFwib3duZXJcIixcbiAgICAgICAgaW5wdXRzOiBbXSxcbiAgICAgICAgb3V0cHV0czogW3sgbmFtZTogXCJcIiwgdHlwZTogXCJhZGRyZXNzXCIsIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIgfV0sXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgbmFtZTogXCJwcm94aWFibGVVVUlEXCIsXG4gICAgICAgIGlucHV0czogW10sXG4gICAgICAgIG91dHB1dHM6IFt7IG5hbWU6IFwiXCIsIHR5cGU6IFwiYnl0ZXMzMlwiLCBpbnRlcm5hbFR5cGU6IFwiYnl0ZXMzMlwiIH1dLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6IFwidmlld1wiLFxuICAgIH0sXG4gICAge1xuICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgIG5hbWU6IFwicmVub3VuY2VPd25lcnNoaXBcIixcbiAgICAgICAgaW5wdXRzOiBbXSxcbiAgICAgICAgb3V0cHV0czogW10sXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogXCJub25wYXlhYmxlXCIsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgbmFtZTogXCJ0b2tlbkltcGxlbWVudGF0aW9uXCIsXG4gICAgICAgIGlucHV0czogW10sXG4gICAgICAgIG91dHB1dHM6IFt7IG5hbWU6IFwiXCIsIHR5cGU6IFwiYWRkcmVzc1wiLCBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiIH1dLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6IFwidmlld1wiLFxuICAgIH0sXG4gICAge1xuICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgIG5hbWU6IFwidHJhbnNmZXJPd25lcnNoaXBcIixcbiAgICAgICAgaW5wdXRzOiBbeyBuYW1lOiBcIm5ld093bmVyXCIsIHR5cGU6IFwiYWRkcmVzc1wiLCBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiIH1dLFxuICAgICAgICBvdXRwdXRzOiBbXSxcbiAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiBcIm5vbnBheWFibGVcIixcbiAgICB9LFxuICAgIHtcbiAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICBuYW1lOiBcInVwZ3JhZGVUb0FuZENhbGxcIixcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7IG5hbWU6IFwibmV3SW1wbGVtZW50YXRpb25cIiwgdHlwZTogXCJhZGRyZXNzXCIsIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIgfSxcbiAgICAgICAgICAgIHsgbmFtZTogXCJkYXRhXCIsIHR5cGU6IFwiYnl0ZXNcIiwgaW50ZXJuYWxUeXBlOiBcImJ5dGVzXCIgfSxcbiAgICAgICAgXSxcbiAgICAgICAgb3V0cHV0czogW10sXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogXCJwYXlhYmxlXCIsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHR5cGU6IFwiZXZlbnRcIixcbiAgICAgICAgbmFtZTogXCJJbml0aWFsaXplZFwiLFxuICAgICAgICBpbnB1dHM6IFt7IG5hbWU6IFwidmVyc2lvblwiLCB0eXBlOiBcInVpbnQ2NFwiLCBpbmRleGVkOiBmYWxzZSwgaW50ZXJuYWxUeXBlOiBcInVpbnQ2NFwiIH1dLFxuICAgICAgICBhbm9ueW1vdXM6IGZhbHNlLFxuICAgIH0sXG4gICAge1xuICAgICAgICB0eXBlOiBcImV2ZW50XCIsXG4gICAgICAgIG5hbWU6IFwiT3duZXJzaGlwVHJhbnNmZXJyZWRcIixcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7IG5hbWU6IFwicHJldmlvdXNPd25lclwiLCB0eXBlOiBcImFkZHJlc3NcIiwgaW5kZXhlZDogdHJ1ZSwgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIiB9LFxuICAgICAgICAgICAgeyBuYW1lOiBcIm5ld093bmVyXCIsIHR5cGU6IFwiYWRkcmVzc1wiLCBpbmRleGVkOiB0cnVlLCBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiIH0sXG4gICAgICAgIF0sXG4gICAgICAgIGFub255bW91czogZmFsc2UsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHR5cGU6IFwiZXZlbnRcIixcbiAgICAgICAgbmFtZTogXCJVcGdyYWRlZFwiLFxuICAgICAgICBpbnB1dHM6IFt7IG5hbWU6IFwiaW1wbGVtZW50YXRpb25cIiwgdHlwZTogXCJhZGRyZXNzXCIsIGluZGV4ZWQ6IHRydWUsIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIgfV0sXG4gICAgICAgIGFub255bW91czogZmFsc2UsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgbmFtZTogXCJBZGRyZXNzRW1wdHlDb2RlXCIsXG4gICAgICAgIGlucHV0czogW3sgbmFtZTogXCJ0YXJnZXRcIiwgdHlwZTogXCJhZGRyZXNzXCIsIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIgfV0sXG4gICAgfSxcbiAgICB7IHR5cGU6IFwiZXJyb3JcIiwgbmFtZTogXCJFUkMxMTY3RmFpbGVkQ3JlYXRlQ2xvbmVcIiwgaW5wdXRzOiBbXSB9LFxuICAgIHtcbiAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgICBuYW1lOiBcIkVSQzE5NjdJbnZhbGlkSW1wbGVtZW50YXRpb25cIixcbiAgICAgICAgaW5wdXRzOiBbeyBuYW1lOiBcImltcGxlbWVudGF0aW9uXCIsIHR5cGU6IFwiYWRkcmVzc1wiLCBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiIH1dLFxuICAgIH0sXG4gICAgeyB0eXBlOiBcImVycm9yXCIsIG5hbWU6IFwiRVJDMTk2N05vblBheWFibGVcIiwgaW5wdXRzOiBbXSB9LFxuICAgIHsgdHlwZTogXCJlcnJvclwiLCBuYW1lOiBcIkZhaWxlZElubmVyQ2FsbFwiLCBpbnB1dHM6IFtdIH0sXG4gICAgeyB0eXBlOiBcImVycm9yXCIsIG5hbWU6IFwiSW52YWxpZEluaXRpYWxpemF0aW9uXCIsIGlucHV0czogW10gfSxcbiAgICB7IHR5cGU6IFwiZXJyb3JcIiwgbmFtZTogXCJOb3RJbml0aWFsaXppbmdcIiwgaW5wdXRzOiBbXSB9LFxuICAgIHtcbiAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgICBuYW1lOiBcIk93bmFibGVJbnZhbGlkT3duZXJcIixcbiAgICAgICAgaW5wdXRzOiBbeyBuYW1lOiBcIm93bmVyXCIsIHR5cGU6IFwiYWRkcmVzc1wiLCBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiIH1dLFxuICAgIH0sXG4gICAge1xuICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICAgIG5hbWU6IFwiT3duYWJsZVVuYXV0aG9yaXplZEFjY291bnRcIixcbiAgICAgICAgaW5wdXRzOiBbeyBuYW1lOiBcImFjY291bnRcIiwgdHlwZTogXCJhZGRyZXNzXCIsIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIgfV0sXG4gICAgfSxcbiAgICB7IHR5cGU6IFwiZXJyb3JcIiwgbmFtZTogXCJSZWVudHJhbmN5R3VhcmRSZWVudHJhbnRDYWxsXCIsIGlucHV0czogW10gfSxcbiAgICB7IHR5cGU6IFwiZXJyb3JcIiwgbmFtZTogXCJVVVBTVW5hdXRob3JpemVkQ2FsbENvbnRleHRcIiwgaW5wdXRzOiBbXSB9LFxuICAgIHtcbiAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgICBuYW1lOiBcIlVVUFNVbnN1cHBvcnRlZFByb3hpYWJsZVVVSURcIixcbiAgICAgICAgaW5wdXRzOiBbeyBuYW1lOiBcInNsb3RcIiwgdHlwZTogXCJieXRlczMyXCIsIGludGVybmFsVHlwZTogXCJieXRlczMyXCIgfV0sXG4gICAgfSxcbl07XG5leHBvcnRzLldPV19BQkkgPSBbXG4gICAge1xuICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICAgIHsgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIiwgbmFtZTogXCJfcHJvdG9jb2xGZWVSZWNpcGllbnRcIiwgdHlwZTogXCJhZGRyZXNzXCIgfSxcbiAgICAgICAgICAgIHsgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIiwgbmFtZTogXCJfcHJvdG9jb2xSZXdhcmRzXCIsIHR5cGU6IFwiYWRkcmVzc1wiIH0sXG4gICAgICAgICAgICB7IGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsIG5hbWU6IFwiX3dldGhcIiwgdHlwZTogXCJhZGRyZXNzXCIgfSxcbiAgICAgICAgICAgIHsgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIiwgbmFtZTogXCJfbm9uZnVuZ2libGVQb3NpdGlvbk1hbmFnZXJcIiwgdHlwZTogXCJhZGRyZXNzXCIgfSxcbiAgICAgICAgICAgIHsgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIiwgbmFtZTogXCJfc3dhcFJvdXRlclwiLCB0eXBlOiBcImFkZHJlc3NcIiB9LFxuICAgICAgICBdLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6IFwibm9ucGF5YWJsZVwiLFxuICAgICAgICB0eXBlOiBcImNvbnN0cnVjdG9yXCIsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlucHV0czogW3sgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIiwgbmFtZTogXCJ0YXJnZXRcIiwgdHlwZTogXCJhZGRyZXNzXCIgfV0sXG4gICAgICAgIG5hbWU6IFwiQWRkcmVzc0VtcHR5Q29kZVwiLFxuICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlucHV0czogW3sgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIiwgbmFtZTogXCJhY2NvdW50XCIsIHR5cGU6IFwiYWRkcmVzc1wiIH1dLFxuICAgICAgICBuYW1lOiBcIkFkZHJlc3NJbnN1ZmZpY2llbnRCYWxhbmNlXCIsXG4gICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICB9LFxuICAgIHsgaW5wdXRzOiBbXSwgbmFtZTogXCJBZGRyZXNzWmVyb1wiLCB0eXBlOiBcImVycm9yXCIgfSxcbiAgICB7XG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAgeyBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLCBuYW1lOiBcInNwZW5kZXJcIiwgdHlwZTogXCJhZGRyZXNzXCIgfSxcbiAgICAgICAgICAgIHsgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIiwgbmFtZTogXCJhbGxvd2FuY2VcIiwgdHlwZTogXCJ1aW50MjU2XCIgfSxcbiAgICAgICAgICAgIHsgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIiwgbmFtZTogXCJuZWVkZWRcIiwgdHlwZTogXCJ1aW50MjU2XCIgfSxcbiAgICAgICAgXSxcbiAgICAgICAgbmFtZTogXCJFUkMyMEluc3VmZmljaWVudEFsbG93YW5jZVwiLFxuICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAgeyBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLCBuYW1lOiBcInNlbmRlclwiLCB0eXBlOiBcImFkZHJlc3NcIiB9LFxuICAgICAgICAgICAgeyBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLCBuYW1lOiBcImJhbGFuY2VcIiwgdHlwZTogXCJ1aW50MjU2XCIgfSxcbiAgICAgICAgICAgIHsgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIiwgbmFtZTogXCJuZWVkZWRcIiwgdHlwZTogXCJ1aW50MjU2XCIgfSxcbiAgICAgICAgXSxcbiAgICAgICAgbmFtZTogXCJFUkMyMEluc3VmZmljaWVudEJhbGFuY2VcIixcbiAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgIH0sXG4gICAge1xuICAgICAgICBpbnB1dHM6IFt7IGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsIG5hbWU6IFwiYXBwcm92ZXJcIiwgdHlwZTogXCJhZGRyZXNzXCIgfV0sXG4gICAgICAgIG5hbWU6IFwiRVJDMjBJbnZhbGlkQXBwcm92ZXJcIixcbiAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgIH0sXG4gICAge1xuICAgICAgICBpbnB1dHM6IFt7IGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsIG5hbWU6IFwicmVjZWl2ZXJcIiwgdHlwZTogXCJhZGRyZXNzXCIgfV0sXG4gICAgICAgIG5hbWU6IFwiRVJDMjBJbnZhbGlkUmVjZWl2ZXJcIixcbiAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgIH0sXG4gICAge1xuICAgICAgICBpbnB1dHM6IFt7IGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsIG5hbWU6IFwic2VuZGVyXCIsIHR5cGU6IFwiYWRkcmVzc1wiIH1dLFxuICAgICAgICBuYW1lOiBcIkVSQzIwSW52YWxpZFNlbmRlclwiLFxuICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlucHV0czogW3sgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIiwgbmFtZTogXCJzcGVuZGVyXCIsIHR5cGU6IFwiYWRkcmVzc1wiIH1dLFxuICAgICAgICBuYW1lOiBcIkVSQzIwSW52YWxpZFNwZW5kZXJcIixcbiAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgIH0sXG4gICAgeyBpbnB1dHM6IFtdLCBuYW1lOiBcIkV0aEFtb3VudFRvb1NtYWxsXCIsIHR5cGU6IFwiZXJyb3JcIiB9LFxuICAgIHsgaW5wdXRzOiBbXSwgbmFtZTogXCJFdGhUcmFuc2ZlckZhaWxlZFwiLCB0eXBlOiBcImVycm9yXCIgfSxcbiAgICB7IGlucHV0czogW10sIG5hbWU6IFwiRmFpbGVkSW5uZXJDYWxsXCIsIHR5cGU6IFwiZXJyb3JcIiB9LFxuICAgIHsgaW5wdXRzOiBbXSwgbmFtZTogXCJJbml0aWFsT3JkZXJTaXplVG9vTGFyZ2VcIiwgdHlwZTogXCJlcnJvclwiIH0sXG4gICAgeyBpbnB1dHM6IFtdLCBuYW1lOiBcIkluc3VmZmljaWVudEZ1bmRzXCIsIHR5cGU6IFwiZXJyb3JcIiB9LFxuICAgIHsgaW5wdXRzOiBbXSwgbmFtZTogXCJJbnN1ZmZpY2llbnRMaXF1aWRpdHlcIiwgdHlwZTogXCJlcnJvclwiIH0sXG4gICAgeyBpbnB1dHM6IFtdLCBuYW1lOiBcIkludmFsaWRJbml0aWFsaXphdGlvblwiLCB0eXBlOiBcImVycm9yXCIgfSxcbiAgICB7IGlucHV0czogW10sIG5hbWU6IFwiSW52YWxpZE1hcmtldFR5cGVcIiwgdHlwZTogXCJlcnJvclwiIH0sXG4gICAgeyBpbnB1dHM6IFtdLCBuYW1lOiBcIk1hcmtldEFscmVhZHlHcmFkdWF0ZWRcIiwgdHlwZTogXCJlcnJvclwiIH0sXG4gICAgeyBpbnB1dHM6IFtdLCBuYW1lOiBcIk1hcmtldE5vdEdyYWR1YXRlZFwiLCB0eXBlOiBcImVycm9yXCIgfSxcbiAgICB7IGlucHV0czogW10sIG5hbWU6IFwiTm90SW5pdGlhbGl6aW5nXCIsIHR5cGU6IFwiZXJyb3JcIiB9LFxuICAgIHsgaW5wdXRzOiBbXSwgbmFtZTogXCJPbmx5UG9vbFwiLCB0eXBlOiBcImVycm9yXCIgfSxcbiAgICB7IGlucHV0czogW10sIG5hbWU6IFwiT25seVdldGhcIiwgdHlwZTogXCJlcnJvclwiIH0sXG4gICAgeyBpbnB1dHM6IFtdLCBuYW1lOiBcIlJlZW50cmFuY3lHdWFyZFJlZW50cmFudENhbGxcIiwgdHlwZTogXCJlcnJvclwiIH0sXG4gICAge1xuICAgICAgICBpbnB1dHM6IFt7IGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsIG5hbWU6IFwidG9rZW5cIiwgdHlwZTogXCJhZGRyZXNzXCIgfV0sXG4gICAgICAgIG5hbWU6IFwiU2FmZUVSQzIwRmFpbGVkT3BlcmF0aW9uXCIsXG4gICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICB9LFxuICAgIHsgaW5wdXRzOiBbXSwgbmFtZTogXCJTbGlwcGFnZUJvdW5kc0V4Y2VlZGVkXCIsIHR5cGU6IFwiZXJyb3JcIiB9LFxuICAgIHtcbiAgICAgICAgYW5vbnltb3VzOiBmYWxzZSxcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7IGluZGV4ZWQ6IHRydWUsIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsIG5hbWU6IFwib3duZXJcIiwgdHlwZTogXCJhZGRyZXNzXCIgfSxcbiAgICAgICAgICAgIHsgaW5kZXhlZDogdHJ1ZSwgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIiwgbmFtZTogXCJzcGVuZGVyXCIsIHR5cGU6IFwiYWRkcmVzc1wiIH0sXG4gICAgICAgICAgICB7IGluZGV4ZWQ6IGZhbHNlLCBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLCBuYW1lOiBcInZhbHVlXCIsIHR5cGU6IFwidWludDI1NlwiIH0sXG4gICAgICAgIF0sXG4gICAgICAgIG5hbWU6IFwiQXBwcm92YWxcIixcbiAgICAgICAgdHlwZTogXCJldmVudFwiLFxuICAgIH0sXG4gICAge1xuICAgICAgICBhbm9ueW1vdXM6IGZhbHNlLFxuICAgICAgICBpbnB1dHM6IFt7IGluZGV4ZWQ6IGZhbHNlLCBpbnRlcm5hbFR5cGU6IFwidWludDY0XCIsIG5hbWU6IFwidmVyc2lvblwiLCB0eXBlOiBcInVpbnQ2NFwiIH1dLFxuICAgICAgICBuYW1lOiBcIkluaXRpYWxpemVkXCIsXG4gICAgICAgIHR5cGU6IFwiZXZlbnRcIixcbiAgICB9LFxuICAgIHtcbiAgICAgICAgYW5vbnltb3VzOiBmYWxzZSxcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7IGluZGV4ZWQ6IHRydWUsIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsIG5hbWU6IFwiZnJvbVwiLCB0eXBlOiBcImFkZHJlc3NcIiB9LFxuICAgICAgICAgICAgeyBpbmRleGVkOiB0cnVlLCBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLCBuYW1lOiBcInRvXCIsIHR5cGU6IFwiYWRkcmVzc1wiIH0sXG4gICAgICAgICAgICB7IGluZGV4ZWQ6IGZhbHNlLCBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLCBuYW1lOiBcInZhbHVlXCIsIHR5cGU6IFwidWludDI1NlwiIH0sXG4gICAgICAgIF0sXG4gICAgICAgIG5hbWU6IFwiVHJhbnNmZXJcIixcbiAgICAgICAgdHlwZTogXCJldmVudFwiLFxuICAgIH0sXG4gICAge1xuICAgICAgICBhbm9ueW1vdXM6IGZhbHNlLFxuICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICAgIHsgaW5kZXhlZDogdHJ1ZSwgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIiwgbmFtZTogXCJ0b2tlbkFkZHJlc3NcIiwgdHlwZTogXCJhZGRyZXNzXCIgfSxcbiAgICAgICAgICAgIHsgaW5kZXhlZDogdHJ1ZSwgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIiwgbmFtZTogXCJwb29sQWRkcmVzc1wiLCB0eXBlOiBcImFkZHJlc3NcIiB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGluZGV4ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJ0b3RhbEV0aExpcXVpZGl0eVwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbmRleGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICAgICAgICAgIG5hbWU6IFwidG90YWxUb2tlbkxpcXVpZGl0eVwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbmRleGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICAgICAgICAgIG5hbWU6IFwibHBQb3NpdGlvbklkXCIsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGluZGV4ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogXCJlbnVtIElXb3cuTWFya2V0VHlwZVwiLFxuICAgICAgICAgICAgICAgIG5hbWU6IFwibWFya2V0VHlwZVwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwidWludDhcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIG5hbWU6IFwiV293TWFya2V0R3JhZHVhdGVkXCIsXG4gICAgICAgIHR5cGU6IFwiZXZlbnRcIixcbiAgICB9LFxuICAgIHtcbiAgICAgICAgYW5vbnltb3VzOiBmYWxzZSxcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7IGluZGV4ZWQ6IHRydWUsIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsIG5hbWU6IFwiYnV5ZXJcIiwgdHlwZTogXCJhZGRyZXNzXCIgfSxcbiAgICAgICAgICAgIHsgaW5kZXhlZDogdHJ1ZSwgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIiwgbmFtZTogXCJyZWNpcGllbnRcIiwgdHlwZTogXCJhZGRyZXNzXCIgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbmRleGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJvcmRlclJlZmVycmVyXCIsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeyBpbmRleGVkOiBmYWxzZSwgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIiwgbmFtZTogXCJ0b3RhbEV0aFwiLCB0eXBlOiBcInVpbnQyNTZcIiB9LFxuICAgICAgICAgICAgeyBpbmRleGVkOiBmYWxzZSwgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIiwgbmFtZTogXCJldGhGZWVcIiwgdHlwZTogXCJ1aW50MjU2XCIgfSxcbiAgICAgICAgICAgIHsgaW5kZXhlZDogZmFsc2UsIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsIG5hbWU6IFwiZXRoU29sZFwiLCB0eXBlOiBcInVpbnQyNTZcIiB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGluZGV4ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJ0b2tlbnNCb3VnaHRcIixcbiAgICAgICAgICAgICAgICB0eXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW5kZXhlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgICAgICAgICBuYW1lOiBcImJ1eWVyVG9rZW5CYWxhbmNlXCIsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeyBpbmRleGVkOiBmYWxzZSwgaW50ZXJuYWxUeXBlOiBcInN0cmluZ1wiLCBuYW1lOiBcImNvbW1lbnRcIiwgdHlwZTogXCJzdHJpbmdcIiB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGluZGV4ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogXCJlbnVtIElXb3cuTWFya2V0VHlwZVwiLFxuICAgICAgICAgICAgICAgIG5hbWU6IFwibWFya2V0VHlwZVwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwidWludDhcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIG5hbWU6IFwiV293VG9rZW5CdXlcIixcbiAgICAgICAgdHlwZTogXCJldmVudFwiLFxuICAgIH0sXG4gICAge1xuICAgICAgICBhbm9ueW1vdXM6IGZhbHNlLFxuICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbmRleGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJmYWN0b3J5QWRkcmVzc1wiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHsgaW5kZXhlZDogdHJ1ZSwgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIiwgbmFtZTogXCJ0b2tlbkNyZWF0b3JcIiwgdHlwZTogXCJhZGRyZXNzXCIgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbmRleGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICAgICAgICAgIG5hbWU6IFwicGxhdGZvcm1SZWZlcnJlclwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbmRleGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICAgICAgICAgIG5hbWU6IFwicHJvdG9jb2xGZWVSZWNpcGllbnRcIixcbiAgICAgICAgICAgICAgICB0eXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW5kZXhlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgICAgICAgICBuYW1lOiBcImJvbmRpbmdDdXJ2ZVwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHsgaW5kZXhlZDogZmFsc2UsIGludGVybmFsVHlwZTogXCJzdHJpbmdcIiwgbmFtZTogXCJ0b2tlblVSSVwiLCB0eXBlOiBcInN0cmluZ1wiIH0sXG4gICAgICAgICAgICB7IGluZGV4ZWQ6IGZhbHNlLCBpbnRlcm5hbFR5cGU6IFwic3RyaW5nXCIsIG5hbWU6IFwibmFtZVwiLCB0eXBlOiBcInN0cmluZ1wiIH0sXG4gICAgICAgICAgICB7IGluZGV4ZWQ6IGZhbHNlLCBpbnRlcm5hbFR5cGU6IFwic3RyaW5nXCIsIG5hbWU6IFwic3ltYm9sXCIsIHR5cGU6IFwic3RyaW5nXCIgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbmRleGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICAgICAgICAgIG5hbWU6IFwidG9rZW5BZGRyZXNzXCIsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeyBpbmRleGVkOiBmYWxzZSwgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIiwgbmFtZTogXCJwb29sQWRkcmVzc1wiLCB0eXBlOiBcImFkZHJlc3NcIiB9LFxuICAgICAgICBdLFxuICAgICAgICBuYW1lOiBcIldvd1Rva2VuQ3JlYXRlZFwiLFxuICAgICAgICB0eXBlOiBcImV2ZW50XCIsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGFub255bW91czogZmFsc2UsXG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAgeyBpbmRleGVkOiB0cnVlLCBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLCBuYW1lOiBcInRva2VuQ3JlYXRvclwiLCB0eXBlOiBcImFkZHJlc3NcIiB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGluZGV4ZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgICAgICAgICBuYW1lOiBcInBsYXRmb3JtUmVmZXJyZXJcIixcbiAgICAgICAgICAgICAgICB0eXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW5kZXhlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICAgICAgICAgIG5hbWU6IFwib3JkZXJSZWZlcnJlclwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbmRleGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICAgICAgICAgIG5hbWU6IFwicHJvdG9jb2xGZWVSZWNpcGllbnRcIixcbiAgICAgICAgICAgICAgICB0eXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW5kZXhlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgICAgICAgICBuYW1lOiBcInRva2VuQ3JlYXRvckZlZVwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbmRleGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICAgICAgICAgIG5hbWU6IFwicGxhdGZvcm1SZWZlcnJlckZlZVwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbmRleGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICAgICAgICAgIG5hbWU6IFwib3JkZXJSZWZlcnJlckZlZVwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHsgaW5kZXhlZDogZmFsc2UsIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsIG5hbWU6IFwicHJvdG9jb2xGZWVcIiwgdHlwZTogXCJ1aW50MjU2XCIgfSxcbiAgICAgICAgXSxcbiAgICAgICAgbmFtZTogXCJXb3dUb2tlbkZlZXNcIixcbiAgICAgICAgdHlwZTogXCJldmVudFwiLFxuICAgIH0sXG4gICAge1xuICAgICAgICBhbm9ueW1vdXM6IGZhbHNlLFxuICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICAgIHsgaW5kZXhlZDogdHJ1ZSwgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIiwgbmFtZTogXCJzZWxsZXJcIiwgdHlwZTogXCJhZGRyZXNzXCIgfSxcbiAgICAgICAgICAgIHsgaW5kZXhlZDogdHJ1ZSwgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIiwgbmFtZTogXCJyZWNpcGllbnRcIiwgdHlwZTogXCJhZGRyZXNzXCIgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbmRleGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJvcmRlclJlZmVycmVyXCIsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeyBpbmRleGVkOiBmYWxzZSwgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIiwgbmFtZTogXCJ0b3RhbEV0aFwiLCB0eXBlOiBcInVpbnQyNTZcIiB9LFxuICAgICAgICAgICAgeyBpbmRleGVkOiBmYWxzZSwgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIiwgbmFtZTogXCJldGhGZWVcIiwgdHlwZTogXCJ1aW50MjU2XCIgfSxcbiAgICAgICAgICAgIHsgaW5kZXhlZDogZmFsc2UsIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsIG5hbWU6IFwiZXRoQm91Z2h0XCIsIHR5cGU6IFwidWludDI1NlwiIH0sXG4gICAgICAgICAgICB7IGluZGV4ZWQ6IGZhbHNlLCBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLCBuYW1lOiBcInRva2Vuc1NvbGRcIiwgdHlwZTogXCJ1aW50MjU2XCIgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbmRleGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICAgICAgICAgIG5hbWU6IFwic2VsbGVyVG9rZW5CYWxhbmNlXCIsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeyBpbmRleGVkOiBmYWxzZSwgaW50ZXJuYWxUeXBlOiBcInN0cmluZ1wiLCBuYW1lOiBcImNvbW1lbnRcIiwgdHlwZTogXCJzdHJpbmdcIiB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGluZGV4ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogXCJlbnVtIElXb3cuTWFya2V0VHlwZVwiLFxuICAgICAgICAgICAgICAgIG5hbWU6IFwibWFya2V0VHlwZVwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwidWludDhcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIG5hbWU6IFwiV293VG9rZW5TZWxsXCIsXG4gICAgICAgIHR5cGU6IFwiZXZlbnRcIixcbiAgICB9LFxuICAgIHtcbiAgICAgICAgYW5vbnltb3VzOiBmYWxzZSxcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7IGluZGV4ZWQ6IHRydWUsIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsIG5hbWU6IFwiZnJvbVwiLCB0eXBlOiBcImFkZHJlc3NcIiB9LFxuICAgICAgICAgICAgeyBpbmRleGVkOiB0cnVlLCBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLCBuYW1lOiBcInRvXCIsIHR5cGU6IFwiYWRkcmVzc1wiIH0sXG4gICAgICAgICAgICB7IGluZGV4ZWQ6IGZhbHNlLCBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLCBuYW1lOiBcImFtb3VudFwiLCB0eXBlOiBcInVpbnQyNTZcIiB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGluZGV4ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJmcm9tVG9rZW5CYWxhbmNlXCIsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGluZGV4ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJ0b1Rva2VuQmFsYW5jZVwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHsgaW5kZXhlZDogZmFsc2UsIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsIG5hbWU6IFwidG90YWxTdXBwbHlcIiwgdHlwZTogXCJ1aW50MjU2XCIgfSxcbiAgICAgICAgXSxcbiAgICAgICAgbmFtZTogXCJXb3dUb2tlblRyYW5zZmVyXCIsXG4gICAgICAgIHR5cGU6IFwiZXZlbnRcIixcbiAgICB9LFxuICAgIHtcbiAgICAgICAgaW5wdXRzOiBbXSxcbiAgICAgICAgbmFtZTogXCJNQVhfVE9UQUxfU1VQUExZXCIsXG4gICAgICAgIG91dHB1dHM6IFt7IGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsIG5hbWU6IFwiXCIsIHR5cGU6IFwidWludDI1NlwiIH1dLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6IFwidmlld1wiLFxuICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlucHV0czogW10sXG4gICAgICAgIG5hbWU6IFwiTUlOX09SREVSX1NJWkVcIixcbiAgICAgICAgb3V0cHV0czogW3sgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIiwgbmFtZTogXCJcIiwgdHlwZTogXCJ1aW50MjU2XCIgfV0sXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICB9LFxuICAgIHtcbiAgICAgICAgaW5wdXRzOiBbXSxcbiAgICAgICAgbmFtZTogXCJPUkRFUl9SRUZFUlJFUl9GRUVfQlBTXCIsXG4gICAgICAgIG91dHB1dHM6IFt7IGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsIG5hbWU6IFwiXCIsIHR5cGU6IFwidWludDI1NlwiIH1dLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6IFwidmlld1wiLFxuICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlucHV0czogW10sXG4gICAgICAgIG5hbWU6IFwiUExBVEZPUk1fUkVGRVJSRVJfRkVFX0JQU1wiLFxuICAgICAgICBvdXRwdXRzOiBbeyBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLCBuYW1lOiBcIlwiLCB0eXBlOiBcInVpbnQyNTZcIiB9XSxcbiAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIixcbiAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgIH0sXG4gICAge1xuICAgICAgICBpbnB1dHM6IFtdLFxuICAgICAgICBuYW1lOiBcIlBST1RPQ09MX0ZFRV9CUFNcIixcbiAgICAgICAgb3V0cHV0czogW3sgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIiwgbmFtZTogXCJcIiwgdHlwZTogXCJ1aW50MjU2XCIgfV0sXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICB9LFxuICAgIHtcbiAgICAgICAgaW5wdXRzOiBbXSxcbiAgICAgICAgbmFtZTogXCJUT0tFTl9DUkVBVE9SX0ZFRV9CUFNcIixcbiAgICAgICAgb3V0cHV0czogW3sgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIiwgbmFtZTogXCJcIiwgdHlwZTogXCJ1aW50MjU2XCIgfV0sXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICB9LFxuICAgIHtcbiAgICAgICAgaW5wdXRzOiBbXSxcbiAgICAgICAgbmFtZTogXCJUT1RBTF9GRUVfQlBTXCIsXG4gICAgICAgIG91dHB1dHM6IFt7IGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsIG5hbWU6IFwiXCIsIHR5cGU6IFwidWludDI1NlwiIH1dLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6IFwidmlld1wiLFxuICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlucHV0czogW10sXG4gICAgICAgIG5hbWU6IFwiV0VUSFwiLFxuICAgICAgICBvdXRwdXRzOiBbeyBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLCBuYW1lOiBcIlwiLCB0eXBlOiBcImFkZHJlc3NcIiB9XSxcbiAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIixcbiAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgIH0sXG4gICAge1xuICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICAgIHsgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIiwgbmFtZTogXCJvd25lclwiLCB0eXBlOiBcImFkZHJlc3NcIiB9LFxuICAgICAgICAgICAgeyBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLCBuYW1lOiBcInNwZW5kZXJcIiwgdHlwZTogXCJhZGRyZXNzXCIgfSxcbiAgICAgICAgXSxcbiAgICAgICAgbmFtZTogXCJhbGxvd2FuY2VcIixcbiAgICAgICAgb3V0cHV0czogW3sgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIiwgbmFtZTogXCJcIiwgdHlwZTogXCJ1aW50MjU2XCIgfV0sXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICB9LFxuICAgIHtcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7IGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsIG5hbWU6IFwic3BlbmRlclwiLCB0eXBlOiBcImFkZHJlc3NcIiB9LFxuICAgICAgICAgICAgeyBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLCBuYW1lOiBcInZhbHVlXCIsIHR5cGU6IFwidWludDI1NlwiIH0sXG4gICAgICAgIF0sXG4gICAgICAgIG5hbWU6IFwiYXBwcm92ZVwiLFxuICAgICAgICBvdXRwdXRzOiBbeyBpbnRlcm5hbFR5cGU6IFwiYm9vbFwiLCBuYW1lOiBcIlwiLCB0eXBlOiBcImJvb2xcIiB9XSxcbiAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiBcIm5vbnBheWFibGVcIixcbiAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgIH0sXG4gICAge1xuICAgICAgICBpbnB1dHM6IFt7IGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsIG5hbWU6IFwiYWNjb3VudFwiLCB0eXBlOiBcImFkZHJlc3NcIiB9XSxcbiAgICAgICAgbmFtZTogXCJiYWxhbmNlT2ZcIixcbiAgICAgICAgb3V0cHV0czogW3sgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIiwgbmFtZTogXCJcIiwgdHlwZTogXCJ1aW50MjU2XCIgfV0sXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICB9LFxuICAgIHtcbiAgICAgICAgaW5wdXRzOiBbXSxcbiAgICAgICAgbmFtZTogXCJib25kaW5nQ3VydmVcIixcbiAgICAgICAgb3V0cHV0czogW3sgaW50ZXJuYWxUeXBlOiBcImNvbnRyYWN0IEJvbmRpbmdDdXJ2ZVwiLCBuYW1lOiBcIlwiLCB0eXBlOiBcImFkZHJlc3NcIiB9XSxcbiAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIixcbiAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgIH0sXG4gICAge1xuICAgICAgICBpbnB1dHM6IFt7IGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsIG5hbWU6IFwidG9rZW5zVG9CdXJuXCIsIHR5cGU6IFwidWludDI1NlwiIH1dLFxuICAgICAgICBuYW1lOiBcImJ1cm5cIixcbiAgICAgICAgb3V0cHV0czogW10sXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogXCJub25wYXlhYmxlXCIsXG4gICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICB9LFxuICAgIHtcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7IGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsIG5hbWU6IFwicmVjaXBpZW50XCIsIHR5cGU6IFwiYWRkcmVzc1wiIH0sXG4gICAgICAgICAgICB7IGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsIG5hbWU6IFwicmVmdW5kUmVjaXBpZW50XCIsIHR5cGU6IFwiYWRkcmVzc1wiIH0sXG4gICAgICAgICAgICB7IGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsIG5hbWU6IFwib3JkZXJSZWZlcnJlclwiLCB0eXBlOiBcImFkZHJlc3NcIiB9LFxuICAgICAgICAgICAgeyBpbnRlcm5hbFR5cGU6IFwic3RyaW5nXCIsIG5hbWU6IFwiY29tbWVudFwiLCB0eXBlOiBcInN0cmluZ1wiIH0sXG4gICAgICAgICAgICB7IGludGVybmFsVHlwZTogXCJlbnVtIElXb3cuTWFya2V0VHlwZVwiLCBuYW1lOiBcImV4cGVjdGVkTWFya2V0VHlwZVwiLCB0eXBlOiBcInVpbnQ4XCIgfSxcbiAgICAgICAgICAgIHsgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIiwgbmFtZTogXCJtaW5PcmRlclNpemVcIiwgdHlwZTogXCJ1aW50MjU2XCIgfSxcbiAgICAgICAgICAgIHsgaW50ZXJuYWxUeXBlOiBcInVpbnQxNjBcIiwgbmFtZTogXCJzcXJ0UHJpY2VMaW1pdFg5NlwiLCB0eXBlOiBcInVpbnQxNjBcIiB9LFxuICAgICAgICBdLFxuICAgICAgICBuYW1lOiBcImJ1eVwiLFxuICAgICAgICBvdXRwdXRzOiBbeyBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLCBuYW1lOiBcIlwiLCB0eXBlOiBcInVpbnQyNTZcIiB9XSxcbiAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiBcInBheWFibGVcIixcbiAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgIH0sXG4gICAge1xuICAgICAgICBpbnB1dHM6IFtdLFxuICAgICAgICBuYW1lOiBcImN1cnJlbnRFeGNoYW5nZVJhdGVcIixcbiAgICAgICAgb3V0cHV0czogW3sgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIiwgbmFtZTogXCJcIiwgdHlwZTogXCJ1aW50MjU2XCIgfV0sXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICB9LFxuICAgIHtcbiAgICAgICAgaW5wdXRzOiBbXSxcbiAgICAgICAgbmFtZTogXCJkZWNpbWFsc1wiLFxuICAgICAgICBvdXRwdXRzOiBbeyBpbnRlcm5hbFR5cGU6IFwidWludDhcIiwgbmFtZTogXCJcIiwgdHlwZTogXCJ1aW50OFwiIH1dLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6IFwidmlld1wiLFxuICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlucHV0czogW3sgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIiwgbmFtZTogXCJldGhPcmRlclNpemVcIiwgdHlwZTogXCJ1aW50MjU2XCIgfV0sXG4gICAgICAgIG5hbWU6IFwiZ2V0RXRoQnV5UXVvdGVcIixcbiAgICAgICAgb3V0cHV0czogW3sgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIiwgbmFtZTogXCJcIiwgdHlwZTogXCJ1aW50MjU2XCIgfV0sXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICB9LFxuICAgIHtcbiAgICAgICAgaW5wdXRzOiBbeyBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLCBuYW1lOiBcImV0aE9yZGVyU2l6ZVwiLCB0eXBlOiBcInVpbnQyNTZcIiB9XSxcbiAgICAgICAgbmFtZTogXCJnZXRFdGhTZWxsUXVvdGVcIixcbiAgICAgICAgb3V0cHV0czogW3sgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIiwgbmFtZTogXCJcIiwgdHlwZTogXCJ1aW50MjU2XCIgfV0sXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICB9LFxuICAgIHtcbiAgICAgICAgaW5wdXRzOiBbeyBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLCBuYW1lOiBcInRva2VuT3JkZXJTaXplXCIsIHR5cGU6IFwidWludDI1NlwiIH1dLFxuICAgICAgICBuYW1lOiBcImdldFRva2VuQnV5UXVvdGVcIixcbiAgICAgICAgb3V0cHV0czogW3sgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIiwgbmFtZTogXCJcIiwgdHlwZTogXCJ1aW50MjU2XCIgfV0sXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICB9LFxuICAgIHtcbiAgICAgICAgaW5wdXRzOiBbeyBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLCBuYW1lOiBcInRva2VuT3JkZXJTaXplXCIsIHR5cGU6IFwidWludDI1NlwiIH1dLFxuICAgICAgICBuYW1lOiBcImdldFRva2VuU2VsbFF1b3RlXCIsXG4gICAgICAgIG91dHB1dHM6IFt7IGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsIG5hbWU6IFwiXCIsIHR5cGU6IFwidWludDI1NlwiIH1dLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6IFwidmlld1wiLFxuICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAgeyBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLCBuYW1lOiBcIl90b2tlbkNyZWF0b3JcIiwgdHlwZTogXCJhZGRyZXNzXCIgfSxcbiAgICAgICAgICAgIHsgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIiwgbmFtZTogXCJfcGxhdGZvcm1SZWZlcnJlclwiLCB0eXBlOiBcImFkZHJlc3NcIiB9LFxuICAgICAgICAgICAgeyBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLCBuYW1lOiBcIl9ib25kaW5nQ3VydmVcIiwgdHlwZTogXCJhZGRyZXNzXCIgfSxcbiAgICAgICAgICAgIHsgaW50ZXJuYWxUeXBlOiBcInN0cmluZ1wiLCBuYW1lOiBcIl90b2tlblVSSVwiLCB0eXBlOiBcInN0cmluZ1wiIH0sXG4gICAgICAgICAgICB7IGludGVybmFsVHlwZTogXCJzdHJpbmdcIiwgbmFtZTogXCJfbmFtZVwiLCB0eXBlOiBcInN0cmluZ1wiIH0sXG4gICAgICAgICAgICB7IGludGVybmFsVHlwZTogXCJzdHJpbmdcIiwgbmFtZTogXCJfc3ltYm9sXCIsIHR5cGU6IFwic3RyaW5nXCIgfSxcbiAgICAgICAgXSxcbiAgICAgICAgbmFtZTogXCJpbml0aWFsaXplXCIsXG4gICAgICAgIG91dHB1dHM6IFtdLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6IFwicGF5YWJsZVwiLFxuICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlucHV0czogW10sXG4gICAgICAgIG5hbWU6IFwibWFya2V0VHlwZVwiLFxuICAgICAgICBvdXRwdXRzOiBbeyBpbnRlcm5hbFR5cGU6IFwiZW51bSBJV293Lk1hcmtldFR5cGVcIiwgbmFtZTogXCJcIiwgdHlwZTogXCJ1aW50OFwiIH1dLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6IFwidmlld1wiLFxuICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlucHV0czogW10sXG4gICAgICAgIG5hbWU6IFwibmFtZVwiLFxuICAgICAgICBvdXRwdXRzOiBbeyBpbnRlcm5hbFR5cGU6IFwic3RyaW5nXCIsIG5hbWU6IFwiXCIsIHR5cGU6IFwic3RyaW5nXCIgfV0sXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICB9LFxuICAgIHtcbiAgICAgICAgaW5wdXRzOiBbXSxcbiAgICAgICAgbmFtZTogXCJub25mdW5naWJsZVBvc2l0aW9uTWFuYWdlclwiLFxuICAgICAgICBvdXRwdXRzOiBbeyBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLCBuYW1lOiBcIlwiLCB0eXBlOiBcImFkZHJlc3NcIiB9XSxcbiAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIixcbiAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgIH0sXG4gICAge1xuICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICAgIHsgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIiwgbmFtZTogXCJcIiwgdHlwZTogXCJhZGRyZXNzXCIgfSxcbiAgICAgICAgICAgIHsgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIiwgbmFtZTogXCJcIiwgdHlwZTogXCJhZGRyZXNzXCIgfSxcbiAgICAgICAgICAgIHsgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIiwgbmFtZTogXCJcIiwgdHlwZTogXCJ1aW50MjU2XCIgfSxcbiAgICAgICAgICAgIHsgaW50ZXJuYWxUeXBlOiBcImJ5dGVzXCIsIG5hbWU6IFwiXCIsIHR5cGU6IFwiYnl0ZXNcIiB9LFxuICAgICAgICBdLFxuICAgICAgICBuYW1lOiBcIm9uRVJDNzIxUmVjZWl2ZWRcIixcbiAgICAgICAgb3V0cHV0czogW3sgaW50ZXJuYWxUeXBlOiBcImJ5dGVzNFwiLCBuYW1lOiBcIlwiLCB0eXBlOiBcImJ5dGVzNFwiIH1dLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6IFwidmlld1wiLFxuICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlucHV0czogW10sXG4gICAgICAgIG5hbWU6IFwicGxhdGZvcm1SZWZlcnJlclwiLFxuICAgICAgICBvdXRwdXRzOiBbeyBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLCBuYW1lOiBcIlwiLCB0eXBlOiBcImFkZHJlc3NcIiB9XSxcbiAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIixcbiAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgIH0sXG4gICAge1xuICAgICAgICBpbnB1dHM6IFtdLFxuICAgICAgICBuYW1lOiBcInBvb2xBZGRyZXNzXCIsXG4gICAgICAgIG91dHB1dHM6IFt7IGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsIG5hbWU6IFwiXCIsIHR5cGU6IFwiYWRkcmVzc1wiIH1dLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6IFwidmlld1wiLFxuICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlucHV0czogW10sXG4gICAgICAgIG5hbWU6IFwicHJvdG9jb2xGZWVSZWNpcGllbnRcIixcbiAgICAgICAgb3V0cHV0czogW3sgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIiwgbmFtZTogXCJcIiwgdHlwZTogXCJhZGRyZXNzXCIgfV0sXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICB9LFxuICAgIHtcbiAgICAgICAgaW5wdXRzOiBbXSxcbiAgICAgICAgbmFtZTogXCJwcm90b2NvbFJld2FyZHNcIixcbiAgICAgICAgb3V0cHV0czogW3sgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIiwgbmFtZTogXCJcIiwgdHlwZTogXCJhZGRyZXNzXCIgfV0sXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICB9LFxuICAgIHtcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7IGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsIG5hbWU6IFwidG9rZW5zVG9TZWxsXCIsIHR5cGU6IFwidWludDI1NlwiIH0sXG4gICAgICAgICAgICB7IGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsIG5hbWU6IFwicmVjaXBpZW50XCIsIHR5cGU6IFwiYWRkcmVzc1wiIH0sXG4gICAgICAgICAgICB7IGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsIG5hbWU6IFwib3JkZXJSZWZlcnJlclwiLCB0eXBlOiBcImFkZHJlc3NcIiB9LFxuICAgICAgICAgICAgeyBpbnRlcm5hbFR5cGU6IFwic3RyaW5nXCIsIG5hbWU6IFwiY29tbWVudFwiLCB0eXBlOiBcInN0cmluZ1wiIH0sXG4gICAgICAgICAgICB7IGludGVybmFsVHlwZTogXCJlbnVtIElXb3cuTWFya2V0VHlwZVwiLCBuYW1lOiBcImV4cGVjdGVkTWFya2V0VHlwZVwiLCB0eXBlOiBcInVpbnQ4XCIgfSxcbiAgICAgICAgICAgIHsgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIiwgbmFtZTogXCJtaW5QYXlvdXRTaXplXCIsIHR5cGU6IFwidWludDI1NlwiIH0sXG4gICAgICAgICAgICB7IGludGVybmFsVHlwZTogXCJ1aW50MTYwXCIsIG5hbWU6IFwic3FydFByaWNlTGltaXRYOTZcIiwgdHlwZTogXCJ1aW50MTYwXCIgfSxcbiAgICAgICAgXSxcbiAgICAgICAgbmFtZTogXCJzZWxsXCIsXG4gICAgICAgIG91dHB1dHM6IFt7IGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsIG5hbWU6IFwiXCIsIHR5cGU6IFwidWludDI1NlwiIH1dLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6IFwibm9ucGF5YWJsZVwiLFxuICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlucHV0czogW10sXG4gICAgICAgIG5hbWU6IFwic3RhdGVcIixcbiAgICAgICAgb3V0cHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudHM6IFtcbiAgICAgICAgICAgICAgICAgICAgeyBpbnRlcm5hbFR5cGU6IFwiZW51bSBJV293Lk1hcmtldFR5cGVcIiwgbmFtZTogXCJtYXJrZXRUeXBlXCIsIHR5cGU6IFwidWludDhcIiB9LFxuICAgICAgICAgICAgICAgICAgICB7IGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsIG5hbWU6IFwibWFya2V0QWRkcmVzc1wiLCB0eXBlOiBcImFkZHJlc3NcIiB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiBcInN0cnVjdCBJV293Lk1hcmtldFN0YXRlXCIsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJcIixcbiAgICAgICAgICAgICAgICB0eXBlOiBcInR1cGxlXCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6IFwidmlld1wiLFxuICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlucHV0czogW10sXG4gICAgICAgIG5hbWU6IFwic3dhcFJvdXRlclwiLFxuICAgICAgICBvdXRwdXRzOiBbeyBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLCBuYW1lOiBcIlwiLCB0eXBlOiBcImFkZHJlc3NcIiB9XSxcbiAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIixcbiAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgIH0sXG4gICAge1xuICAgICAgICBpbnB1dHM6IFtdLFxuICAgICAgICBuYW1lOiBcInN5bWJvbFwiLFxuICAgICAgICBvdXRwdXRzOiBbeyBpbnRlcm5hbFR5cGU6IFwic3RyaW5nXCIsIG5hbWU6IFwiXCIsIHR5cGU6IFwic3RyaW5nXCIgfV0sXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICB9LFxuICAgIHtcbiAgICAgICAgaW5wdXRzOiBbXSxcbiAgICAgICAgbmFtZTogXCJ0b2tlbkNyZWF0b3JcIixcbiAgICAgICAgb3V0cHV0czogW3sgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIiwgbmFtZTogXCJcIiwgdHlwZTogXCJhZGRyZXNzXCIgfV0sXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICB9LFxuICAgIHtcbiAgICAgICAgaW5wdXRzOiBbXSxcbiAgICAgICAgbmFtZTogXCJ0b2tlblVSSVwiLFxuICAgICAgICBvdXRwdXRzOiBbeyBpbnRlcm5hbFR5cGU6IFwic3RyaW5nXCIsIG5hbWU6IFwiXCIsIHR5cGU6IFwic3RyaW5nXCIgfV0sXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICB9LFxuICAgIHtcbiAgICAgICAgaW5wdXRzOiBbXSxcbiAgICAgICAgbmFtZTogXCJ0b3RhbFN1cHBseVwiLFxuICAgICAgICBvdXRwdXRzOiBbeyBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLCBuYW1lOiBcIlwiLCB0eXBlOiBcInVpbnQyNTZcIiB9XSxcbiAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIixcbiAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgIH0sXG4gICAge1xuICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICAgIHsgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIiwgbmFtZTogXCJ0b1wiLCB0eXBlOiBcImFkZHJlc3NcIiB9LFxuICAgICAgICAgICAgeyBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLCBuYW1lOiBcInZhbHVlXCIsIHR5cGU6IFwidWludDI1NlwiIH0sXG4gICAgICAgIF0sXG4gICAgICAgIG5hbWU6IFwidHJhbnNmZXJcIixcbiAgICAgICAgb3V0cHV0czogW3sgaW50ZXJuYWxUeXBlOiBcImJvb2xcIiwgbmFtZTogXCJcIiwgdHlwZTogXCJib29sXCIgfV0sXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogXCJub25wYXlhYmxlXCIsXG4gICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICB9LFxuICAgIHtcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7IGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsIG5hbWU6IFwiZnJvbVwiLCB0eXBlOiBcImFkZHJlc3NcIiB9LFxuICAgICAgICAgICAgeyBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLCBuYW1lOiBcInRvXCIsIHR5cGU6IFwiYWRkcmVzc1wiIH0sXG4gICAgICAgICAgICB7IGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsIG5hbWU6IFwidmFsdWVcIiwgdHlwZTogXCJ1aW50MjU2XCIgfSxcbiAgICAgICAgXSxcbiAgICAgICAgbmFtZTogXCJ0cmFuc2ZlckZyb21cIixcbiAgICAgICAgb3V0cHV0czogW3sgaW50ZXJuYWxUeXBlOiBcImJvb2xcIiwgbmFtZTogXCJcIiwgdHlwZTogXCJib29sXCIgfV0sXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogXCJub25wYXlhYmxlXCIsXG4gICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICB9LFxuICAgIHtcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7IGludGVybmFsVHlwZTogXCJpbnQyNTZcIiwgbmFtZTogXCJhbW91bnQwRGVsdGFcIiwgdHlwZTogXCJpbnQyNTZcIiB9LFxuICAgICAgICAgICAgeyBpbnRlcm5hbFR5cGU6IFwiaW50MjU2XCIsIG5hbWU6IFwiYW1vdW50MURlbHRhXCIsIHR5cGU6IFwiaW50MjU2XCIgfSxcbiAgICAgICAgICAgIHsgaW50ZXJuYWxUeXBlOiBcImJ5dGVzXCIsIG5hbWU6IFwiXCIsIHR5cGU6IFwiYnl0ZXNcIiB9LFxuICAgICAgICBdLFxuICAgICAgICBuYW1lOiBcInVuaXN3YXBWM1N3YXBDYWxsYmFja1wiLFxuICAgICAgICBvdXRwdXRzOiBbXSxcbiAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiBcIm5vbnBheWFibGVcIixcbiAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgIH0sXG4gICAgeyBzdGF0ZU11dGFiaWxpdHk6IFwicGF5YWJsZVwiLCB0eXBlOiBcInJlY2VpdmVcIiB9LFxuXTtcbmV4cG9ydHMuV09XX0ZBQ1RPUllfQ09OVFJBQ1RfQUREUkVTU0VTID0ge1xuICAgIFwiYmFzZS1zZXBvbGlhXCI6IFwiMHgwNDg3MGUyMmZhMjE3Q2IxNmFhMDA1MDFEN0Q1MjUzQjg4MzhDMWVBXCIsXG4gICAgXCJiYXNlLW1haW5uZXRcIjogXCIweDk5NzAyMEU1RjU5Y0NCNzlDNzRENTI3QmU0OTJDYzYxMENCOWZBMkJcIixcbn07XG5leHBvcnRzLkFERFJFU1NFUyA9IHtcbiAgICBcImJhc2Utc2Vwb2xpYVwiOiB7XG4gICAgICAgIFdvd0ZhY3Rvcnk6IFwiMHhCMDljMGIxYjE4MzY5RWY2MmU4OTZENWE0OUFmOGQ2NUVGYTBBNDA0XCIsXG4gICAgICAgIFdvd0ZhY3RvcnlJbXBsOiBcIjB4QjUyMjI5MWYyMkZFN0ZBNDVENTY3OTdGN0E2ODVENWM2MzdFZGMzMlwiLFxuICAgICAgICBXb3c6IFwiMHgxNWJhNjZlMzc2ODU2RjNGNkZFNTNkRTllZUFiMTBkRUYxMEU4QzkyXCIsXG4gICAgICAgIEJvbmRpbmdDdXJ2ZTogXCIweENFMDBjNzVCOTgwN0EyYUE4N0IyMjk3Y0E3RGMxQzAxOTAxMzdENkZcIixcbiAgICAgICAgTm9uZnVuZ2libGVQb3NpdGlvbk1hbmFnZXI6IFwiMHgyN0Y5NzFjYjU4MkJGOUU1MEYzOTdlNGQyOWE1QzdBMzRmMTFmYUEyXCIsXG4gICAgICAgIFN3YXBSb3V0ZXIwMjogXCIweDk0Y0MwQWFDNTM1Q0NEQjNDMDFkNjc4N0Q2NDEzQzczOWFlMTJiYzRcIixcbiAgICAgICAgV0VUSDogXCIweDQyMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDZcIixcbiAgICAgICAgVW5pc3dhcFF1b3RlcjogXCIweEM1MjkwMDU4ODQxMDI4RjE2MTRGM0E2RjBGNTgxNmNBZDBkZjVFMjdcIixcbiAgICB9LFxuICAgIFwiYmFzZS1tYWlubmV0XCI6IHtcbiAgICAgICAgV293RmFjdG9yeTogXCIweEEwNjI2MjE1NzkwNTkxM2Y4NTU1NzNmNTNBRDQ4REUyRDRiYTFGNEFcIixcbiAgICAgICAgV293RmFjdG9yeUltcGw6IFwiMHhlNGMxNzA1NTA0OGFFZTAxRDBkMTIyODA0ODE2ZkVlNUU2YWM0QTY3XCIsXG4gICAgICAgIFdvdzogXCIweDI5Mzk5N0M2YTFmMkExY0EzYUI5NzFmNTQ4YzREOTU1ODVFNDYyODJcIixcbiAgICAgICAgQm9uZGluZ0N1cnZlOiBcIjB4MjY0ZWNlNUQ1OEE1NzZjYzc3NUI3MTliZjE4MkYyOTQ2MDc2YkU3OFwiLFxuICAgICAgICBOb25mdW5naWJsZVBvc2l0aW9uTWFuYWdlcjogXCIweDAzYTUyMGIzMkMwNEJGM2JFRWY3QkViNzJFOTE5Y2Y4MjJFZDM0ZjFcIixcbiAgICAgICAgU3dhcFJvdXRlcjAyOiBcIjB4MjYyNjY2NGMyNjAzMzM2RTU3QjI3MWM1QzBiMjZGNDIxNzQxZTQ4MVwiLFxuICAgICAgICBXRVRIOiBcIjB4NDIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwNlwiLFxuICAgICAgICBVbmlzd2FwUXVvdGVyOiBcIjB4M2Q0ZTQ0RWIxMzc0MjQwQ0U1RjFCODcxYWIyNjFDRDE2MzM1Qjc2YVwiLFxuICAgIH0sXG59O1xuZXhwb3J0cy5HRU5FUklDX1RPS0VOX01FVEFEQVRBX1VSSSA9IFwiaXBmczovL1FtWTFHcXByRll2b2pDY1VFS2dxSGVEajl1aFpEOWptWUdyUVRmQTl2QUU3OEpcIjtcbi8qKlxuICogR2V0cyB0aGUgWm9yYSBXb3cgRVJDMjAgRmFjdG9yeSBjb250cmFjdCBhZGRyZXNzIGZvciB0aGUgc3BlY2lmaWVkIG5ldHdvcmsuXG4gKlxuICogQHBhcmFtIG5ldHdvcmsgLSBUaGUgbmV0d29yayBJRCB0byBnZXQgdGhlIGNvbnRyYWN0IGFkZHJlc3MgZm9yXG4gKiBAcmV0dXJucyBUaGUgY29udHJhY3QgYWRkcmVzcyBmb3IgdGhlIHNwZWNpZmllZCBuZXR3b3JrXG4gKiBAdGhyb3dzIEVycm9yIGlmIHRoZSBzcGVjaWZpZWQgbmV0d29yayBpcyBub3Qgc3VwcG9ydGVkXG4gKi9cbmZ1bmN0aW9uIGdldEZhY3RvcnlBZGRyZXNzKG5ldHdvcmspIHtcbiAgICBjb25zdCBub3JtYWxpemVkTmV0d29yayA9IG5ldHdvcmsudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAoIShub3JtYWxpemVkTmV0d29yayBpbiBleHBvcnRzLldPV19GQUNUT1JZX0NPTlRSQUNUX0FERFJFU1NFUykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG5ldHdvcms6ICR7bmV0d29ya30uIFZhbGlkIG5ldHdvcmtzIGFyZTogJHtPYmplY3Qua2V5cyhleHBvcnRzLldPV19GQUNUT1JZX0NPTlRSQUNUX0FERFJFU1NFUykuam9pbihcIiwgXCIpfWApO1xuICAgIH1cbiAgICByZXR1cm4gZXhwb3J0cy5XT1dfRkFDVE9SWV9DT05UUkFDVF9BRERSRVNTRVNbbm9ybWFsaXplZE5ldHdvcmtdO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/wow/constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/wow/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/wow/index.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./schemas */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/wow/schemas.js\"), exports);\n__exportStar(__webpack_require__(/*! ./wowActionProvider */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/wow/wowActionProvider.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy93b3cvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYSxtQkFBTyxDQUFDLCtGQUFXO0FBQ2hDLGFBQWEsbUJBQU8sQ0FBQyxtSEFBcUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXJ2aXZhbC1mdW4vLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy93b3cvaW5kZXguanM/NzM5OCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3NjaGVtYXNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3dvd0FjdGlvblByb3ZpZGVyXCIpLCBleHBvcnRzKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/wow/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/wow/schemas.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/wow/schemas.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.WowSellTokenInput = exports.WowCreateTokenInput = exports.WowBuyTokenInput = void 0;\nconst zod_1 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/lib/index.js\");\nconst viem_1 = __webpack_require__(/*! viem */ \"(rsc)/./node_modules/viem/_cjs/index.js\");\nconst ethereumAddress = zod_1.z.custom(val => typeof val === \"string\" && (0, viem_1.isAddress)(val), \"Invalid address\");\n/**\n * Input schema for buying WOW tokens.\n */\nexports.WowBuyTokenInput = zod_1.z\n    .object({\n    contractAddress: ethereumAddress.describe(\"The WOW token contract address\"),\n    amountEthInWei: zod_1.z\n        .string()\n        .regex(/^\\d+$/, \"Must be a valid wei amount\")\n        .describe(\"Amount of ETH to spend (in wei)\"),\n})\n    .strip()\n    .describe(\"Instructions for buying WOW tokens\");\n/**\n * Input schema for creating WOW tokens.\n */\nexports.WowCreateTokenInput = zod_1.z\n    .object({\n    name: zod_1.z.string().min(1).describe(\"The name of the token to create, e.g. WowCoin\"),\n    symbol: zod_1.z.string().min(1).describe(\"The symbol of the token to create, e.g. WOW\"),\n    tokenUri: zod_1.z\n        .string()\n        .url()\n        .optional()\n        .describe(\"The URI of the token metadata to store on IPFS, e.g. ipfs://QmY1GqprFYvojCcUEKgqHeDj9uhZD9jmYGrQTfA9vAE78J\"),\n})\n    .strip()\n    .describe(\"Instructions for creating a WOW token\");\n/**\n * Input schema for selling WOW tokens.\n */\nexports.WowSellTokenInput = zod_1.z\n    .object({\n    contractAddress: ethereumAddress.describe(\"The WOW token contract address, such as `0x036CbD53842c5426634e7929541eC2318f3dCF7e`\"),\n    amountTokensInWei: zod_1.z\n        .string()\n        .regex(/^\\d+$/, \"Must be a valid wei amount\")\n        .describe(\"Amount of tokens to sell (in wei), meaning 1 is 1 wei or 0.000000000000000001 of the token\"),\n})\n    .strip()\n    .describe(\"Instructions for selling WOW tokens\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy93b3cvc2NoZW1hcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx5QkFBeUIsR0FBRywyQkFBMkIsR0FBRyx3QkFBd0I7QUFDbEYsY0FBYyxtQkFBTyxDQUFDLGtEQUFLO0FBQzNCLGVBQWUsbUJBQU8sQ0FBQyxxREFBTTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXJ2aXZhbC1mdW4vLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy93b3cvc2NoZW1hcy5qcz9hNjUzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Xb3dTZWxsVG9rZW5JbnB1dCA9IGV4cG9ydHMuV293Q3JlYXRlVG9rZW5JbnB1dCA9IGV4cG9ydHMuV293QnV5VG9rZW5JbnB1dCA9IHZvaWQgMDtcbmNvbnN0IHpvZF8xID0gcmVxdWlyZShcInpvZFwiKTtcbmNvbnN0IHZpZW1fMSA9IHJlcXVpcmUoXCJ2aWVtXCIpO1xuY29uc3QgZXRoZXJldW1BZGRyZXNzID0gem9kXzEuei5jdXN0b20odmFsID0+IHR5cGVvZiB2YWwgPT09IFwic3RyaW5nXCIgJiYgKDAsIHZpZW1fMS5pc0FkZHJlc3MpKHZhbCksIFwiSW52YWxpZCBhZGRyZXNzXCIpO1xuLyoqXG4gKiBJbnB1dCBzY2hlbWEgZm9yIGJ1eWluZyBXT1cgdG9rZW5zLlxuICovXG5leHBvcnRzLldvd0J1eVRva2VuSW5wdXQgPSB6b2RfMS56XG4gICAgLm9iamVjdCh7XG4gICAgY29udHJhY3RBZGRyZXNzOiBldGhlcmV1bUFkZHJlc3MuZGVzY3JpYmUoXCJUaGUgV09XIHRva2VuIGNvbnRyYWN0IGFkZHJlc3NcIiksXG4gICAgYW1vdW50RXRoSW5XZWk6IHpvZF8xLnpcbiAgICAgICAgLnN0cmluZygpXG4gICAgICAgIC5yZWdleCgvXlxcZCskLywgXCJNdXN0IGJlIGEgdmFsaWQgd2VpIGFtb3VudFwiKVxuICAgICAgICAuZGVzY3JpYmUoXCJBbW91bnQgb2YgRVRIIHRvIHNwZW5kIChpbiB3ZWkpXCIpLFxufSlcbiAgICAuc3RyaXAoKVxuICAgIC5kZXNjcmliZShcIkluc3RydWN0aW9ucyBmb3IgYnV5aW5nIFdPVyB0b2tlbnNcIik7XG4vKipcbiAqIElucHV0IHNjaGVtYSBmb3IgY3JlYXRpbmcgV09XIHRva2Vucy5cbiAqL1xuZXhwb3J0cy5Xb3dDcmVhdGVUb2tlbklucHV0ID0gem9kXzEuelxuICAgIC5vYmplY3Qoe1xuICAgIG5hbWU6IHpvZF8xLnouc3RyaW5nKCkubWluKDEpLmRlc2NyaWJlKFwiVGhlIG5hbWUgb2YgdGhlIHRva2VuIHRvIGNyZWF0ZSwgZS5nLiBXb3dDb2luXCIpLFxuICAgIHN5bWJvbDogem9kXzEuei5zdHJpbmcoKS5taW4oMSkuZGVzY3JpYmUoXCJUaGUgc3ltYm9sIG9mIHRoZSB0b2tlbiB0byBjcmVhdGUsIGUuZy4gV09XXCIpLFxuICAgIHRva2VuVXJpOiB6b2RfMS56XG4gICAgICAgIC5zdHJpbmcoKVxuICAgICAgICAudXJsKClcbiAgICAgICAgLm9wdGlvbmFsKClcbiAgICAgICAgLmRlc2NyaWJlKFwiVGhlIFVSSSBvZiB0aGUgdG9rZW4gbWV0YWRhdGEgdG8gc3RvcmUgb24gSVBGUywgZS5nLiBpcGZzOi8vUW1ZMUdxcHJGWXZvakNjVUVLZ3FIZURqOXVoWkQ5am1ZR3JRVGZBOXZBRTc4SlwiKSxcbn0pXG4gICAgLnN0cmlwKClcbiAgICAuZGVzY3JpYmUoXCJJbnN0cnVjdGlvbnMgZm9yIGNyZWF0aW5nIGEgV09XIHRva2VuXCIpO1xuLyoqXG4gKiBJbnB1dCBzY2hlbWEgZm9yIHNlbGxpbmcgV09XIHRva2Vucy5cbiAqL1xuZXhwb3J0cy5Xb3dTZWxsVG9rZW5JbnB1dCA9IHpvZF8xLnpcbiAgICAub2JqZWN0KHtcbiAgICBjb250cmFjdEFkZHJlc3M6IGV0aGVyZXVtQWRkcmVzcy5kZXNjcmliZShcIlRoZSBXT1cgdG9rZW4gY29udHJhY3QgYWRkcmVzcywgc3VjaCBhcyBgMHgwMzZDYkQ1Mzg0MmM1NDI2NjM0ZTc5Mjk1NDFlQzIzMThmM2RDRjdlYFwiKSxcbiAgICBhbW91bnRUb2tlbnNJbldlaTogem9kXzEuelxuICAgICAgICAuc3RyaW5nKClcbiAgICAgICAgLnJlZ2V4KC9eXFxkKyQvLCBcIk11c3QgYmUgYSB2YWxpZCB3ZWkgYW1vdW50XCIpXG4gICAgICAgIC5kZXNjcmliZShcIkFtb3VudCBvZiB0b2tlbnMgdG8gc2VsbCAoaW4gd2VpKSwgbWVhbmluZyAxIGlzIDEgd2VpIG9yIDAuMDAwMDAwMDAwMDAwMDAwMDAxIG9mIHRoZSB0b2tlblwiKSxcbn0pXG4gICAgLnN0cmlwKClcbiAgICAuZGVzY3JpYmUoXCJJbnN0cnVjdGlvbnMgZm9yIHNlbGxpbmcgV09XIHRva2Vuc1wiKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/wow/schemas.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/wow/uniswap/constants.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/wow/uniswap/constants.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.UNISWAP_V3_ABI = exports.UNISWAP_QUOTER_ABI = void 0;\nexports.UNISWAP_QUOTER_ABI = [\n    {\n        inputs: [\n            {\n                components: [\n                    { internalType: \"address\", name: \"tokenIn\", type: \"address\" },\n                    { internalType: \"address\", name: \"tokenOut\", type: \"address\" },\n                    { internalType: \"uint256\", name: \"amountIn\", type: \"uint256\" },\n                    { internalType: \"uint24\", name: \"fee\", type: \"uint24\" },\n                    { internalType: \"uint160\", name: \"sqrtPriceLimitX96\", type: \"uint160\" },\n                ],\n                internalType: \"struct IQuoterV2.QuoteExactInputSingleParams\",\n                name: \"params\",\n                type: \"tuple\",\n            },\n        ],\n        name: \"quoteExactInputSingle\",\n        outputs: [\n            { internalType: \"uint256\", name: \"amountOut\", type: \"uint256\" },\n            { internalType: \"uint160\", name: \"sqrtPriceX96After\", type: \"uint160\" },\n            { internalType: \"uint32\", name: \"initializedTicksCrossed\", type: \"uint32\" },\n            { internalType: \"uint256\", name: \"gasEstimate\", type: \"uint256\" },\n        ],\n        stateMutability: \"nonpayable\",\n        type: \"function\",\n    },\n    {\n        inputs: [\n            {\n                components: [\n                    { internalType: \"address\", name: \"tokenIn\", type: \"address\" },\n                    { internalType: \"address\", name: \"tokenOut\", type: \"address\" },\n                    { internalType: \"uint256\", name: \"amount\", type: \"uint256\" },\n                    { internalType: \"uint24\", name: \"fee\", type: \"uint24\" },\n                    { internalType: \"uint160\", name: \"sqrtPriceLimitX96\", type: \"uint160\" },\n                ],\n                internalType: \"struct IQuoterV2.QuoteExactOutputSingleParams\",\n                name: \"params\",\n                type: \"tuple\",\n            },\n        ],\n        name: \"quoteExactOutputSingle\",\n        outputs: [\n            { internalType: \"uint256\", name: \"amountIn\", type: \"uint256\" },\n            { internalType: \"uint160\", name: \"sqrtPriceX96After\", type: \"uint160\" },\n            { internalType: \"uint32\", name: \"initializedTicksCrossed\", type: \"uint32\" },\n            { internalType: \"uint256\", name: \"gasEstimate\", type: \"uint256\" },\n        ],\n        stateMutability: \"nonpayable\",\n        type: \"function\",\n    },\n];\nexports.UNISWAP_V3_ABI = [\n    {\n        inputs: [],\n        name: \"fee\",\n        outputs: [{ internalType: \"uint24\", name: \"\", type: \"uint24\" }],\n        stateMutability: \"view\",\n        type: \"function\",\n    },\n    {\n        inputs: [],\n        name: \"liquidity\",\n        outputs: [{ internalType: \"uint128\", name: \"\", type: \"uint128\" }],\n        stateMutability: \"view\",\n        type: \"function\",\n    },\n    {\n        inputs: [],\n        name: \"slot0\",\n        outputs: [\n            { internalType: \"uint160\", name: \"sqrtPriceX96\", type: \"uint160\" },\n            { internalType: \"int24\", name: \"tick\", type: \"int24\" },\n            { internalType: \"uint16\", name: \"observationIndex\", type: \"uint16\" },\n            { internalType: \"uint16\", name: \"observationCardinality\", type: \"uint16\" },\n            { internalType: \"uint16\", name: \"observationCardinalityNext\", type: \"uint16\" },\n            { internalType: \"uint8\", name: \"feeProtocol\", type: \"uint8\" },\n            { internalType: \"bool\", name: \"unlocked\", type: \"bool\" },\n        ],\n        stateMutability: \"view\",\n        type: \"function\",\n    },\n    {\n        inputs: [],\n        name: \"token0\",\n        outputs: [{ internalType: \"address\", name: \"\", type: \"address\" }],\n        stateMutability: \"view\",\n        type: \"function\",\n    },\n    {\n        inputs: [],\n        name: \"token1\",\n        outputs: [{ internalType: \"address\", name: \"\", type: \"address\" }],\n        stateMutability: \"view\",\n        type: \"function\",\n    },\n];\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy93b3cvdW5pc3dhcC9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsc0JBQXNCLEdBQUcsMEJBQTBCO0FBQ25ELDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwyREFBMkQ7QUFDakYsc0JBQXNCLDREQUE0RDtBQUNsRixzQkFBc0IsNERBQTREO0FBQ2xGLHNCQUFzQixxREFBcUQ7QUFDM0Usc0JBQXNCLHFFQUFxRTtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxjQUFjLDZEQUE2RDtBQUMzRSxjQUFjLHFFQUFxRTtBQUNuRixjQUFjLHlFQUF5RTtBQUN2RixjQUFjLCtEQUErRDtBQUM3RTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMkRBQTJEO0FBQ2pGLHNCQUFzQiw0REFBNEQ7QUFDbEYsc0JBQXNCLDBEQUEwRDtBQUNoRixzQkFBc0IscURBQXFEO0FBQzNFLHNCQUFzQixxRUFBcUU7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsY0FBYyw0REFBNEQ7QUFDMUUsY0FBYyxxRUFBcUU7QUFDbkYsY0FBYyx5RUFBeUU7QUFDdkYsY0FBYywrREFBK0Q7QUFDN0U7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrREFBa0Q7QUFDdEU7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0RBQW9EO0FBQ3hFO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGdFQUFnRTtBQUM5RSxjQUFjLG9EQUFvRDtBQUNsRSxjQUFjLGtFQUFrRTtBQUNoRixjQUFjLHdFQUF3RTtBQUN0RixjQUFjLDRFQUE0RTtBQUMxRixjQUFjLDJEQUEyRDtBQUN6RSxjQUFjLHNEQUFzRDtBQUNwRTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9EQUFvRDtBQUN4RTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvREFBb0Q7QUFDeEU7QUFDQTtBQUNBLEtBQUs7QUFDTCIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cnZpdmFsLWZ1bi8uL25vZGVfbW9kdWxlcy9AY29pbmJhc2UvYWdlbnRraXQvZGlzdC9hY3Rpb24tcHJvdmlkZXJzL3dvdy91bmlzd2FwL2NvbnN0YW50cy5qcz83YTgwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5VTklTV0FQX1YzX0FCSSA9IGV4cG9ydHMuVU5JU1dBUF9RVU9URVJfQUJJID0gdm9pZCAwO1xuZXhwb3J0cy5VTklTV0FQX1FVT1RFUl9BQkkgPSBbXG4gICAge1xuICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzOiBbXG4gICAgICAgICAgICAgICAgICAgIHsgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIiwgbmFtZTogXCJ0b2tlbkluXCIsIHR5cGU6IFwiYWRkcmVzc1wiIH0sXG4gICAgICAgICAgICAgICAgICAgIHsgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIiwgbmFtZTogXCJ0b2tlbk91dFwiLCB0eXBlOiBcImFkZHJlc3NcIiB9LFxuICAgICAgICAgICAgICAgICAgICB7IGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsIG5hbWU6IFwiYW1vdW50SW5cIiwgdHlwZTogXCJ1aW50MjU2XCIgfSxcbiAgICAgICAgICAgICAgICAgICAgeyBpbnRlcm5hbFR5cGU6IFwidWludDI0XCIsIG5hbWU6IFwiZmVlXCIsIHR5cGU6IFwidWludDI0XCIgfSxcbiAgICAgICAgICAgICAgICAgICAgeyBpbnRlcm5hbFR5cGU6IFwidWludDE2MFwiLCBuYW1lOiBcInNxcnRQcmljZUxpbWl0WDk2XCIsIHR5cGU6IFwidWludDE2MFwiIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFR5cGU6IFwic3RydWN0IElRdW90ZXJWMi5RdW90ZUV4YWN0SW5wdXRTaW5nbGVQYXJhbXNcIixcbiAgICAgICAgICAgICAgICBuYW1lOiBcInBhcmFtc1wiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwidHVwbGVcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIG5hbWU6IFwicXVvdGVFeGFjdElucHV0U2luZ2xlXCIsXG4gICAgICAgIG91dHB1dHM6IFtcbiAgICAgICAgICAgIHsgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIiwgbmFtZTogXCJhbW91bnRPdXRcIiwgdHlwZTogXCJ1aW50MjU2XCIgfSxcbiAgICAgICAgICAgIHsgaW50ZXJuYWxUeXBlOiBcInVpbnQxNjBcIiwgbmFtZTogXCJzcXJ0UHJpY2VYOTZBZnRlclwiLCB0eXBlOiBcInVpbnQxNjBcIiB9LFxuICAgICAgICAgICAgeyBpbnRlcm5hbFR5cGU6IFwidWludDMyXCIsIG5hbWU6IFwiaW5pdGlhbGl6ZWRUaWNrc0Nyb3NzZWRcIiwgdHlwZTogXCJ1aW50MzJcIiB9LFxuICAgICAgICAgICAgeyBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLCBuYW1lOiBcImdhc0VzdGltYXRlXCIsIHR5cGU6IFwidWludDI1NlwiIH0sXG4gICAgICAgIF0sXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogXCJub25wYXlhYmxlXCIsXG4gICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICB9LFxuICAgIHtcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50czogW1xuICAgICAgICAgICAgICAgICAgICB7IGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsIG5hbWU6IFwidG9rZW5JblwiLCB0eXBlOiBcImFkZHJlc3NcIiB9LFxuICAgICAgICAgICAgICAgICAgICB7IGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsIG5hbWU6IFwidG9rZW5PdXRcIiwgdHlwZTogXCJhZGRyZXNzXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgeyBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLCBuYW1lOiBcImFtb3VudFwiLCB0eXBlOiBcInVpbnQyNTZcIiB9LFxuICAgICAgICAgICAgICAgICAgICB7IGludGVybmFsVHlwZTogXCJ1aW50MjRcIiwgbmFtZTogXCJmZWVcIiwgdHlwZTogXCJ1aW50MjRcIiB9LFxuICAgICAgICAgICAgICAgICAgICB7IGludGVybmFsVHlwZTogXCJ1aW50MTYwXCIsIG5hbWU6IFwic3FydFByaWNlTGltaXRYOTZcIiwgdHlwZTogXCJ1aW50MTYwXCIgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGludGVybmFsVHlwZTogXCJzdHJ1Y3QgSVF1b3RlclYyLlF1b3RlRXhhY3RPdXRwdXRTaW5nbGVQYXJhbXNcIixcbiAgICAgICAgICAgICAgICBuYW1lOiBcInBhcmFtc1wiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwidHVwbGVcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIG5hbWU6IFwicXVvdGVFeGFjdE91dHB1dFNpbmdsZVwiLFxuICAgICAgICBvdXRwdXRzOiBbXG4gICAgICAgICAgICB7IGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsIG5hbWU6IFwiYW1vdW50SW5cIiwgdHlwZTogXCJ1aW50MjU2XCIgfSxcbiAgICAgICAgICAgIHsgaW50ZXJuYWxUeXBlOiBcInVpbnQxNjBcIiwgbmFtZTogXCJzcXJ0UHJpY2VYOTZBZnRlclwiLCB0eXBlOiBcInVpbnQxNjBcIiB9LFxuICAgICAgICAgICAgeyBpbnRlcm5hbFR5cGU6IFwidWludDMyXCIsIG5hbWU6IFwiaW5pdGlhbGl6ZWRUaWNrc0Nyb3NzZWRcIiwgdHlwZTogXCJ1aW50MzJcIiB9LFxuICAgICAgICAgICAgeyBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLCBuYW1lOiBcImdhc0VzdGltYXRlXCIsIHR5cGU6IFwidWludDI1NlwiIH0sXG4gICAgICAgIF0sXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogXCJub25wYXlhYmxlXCIsXG4gICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICB9LFxuXTtcbmV4cG9ydHMuVU5JU1dBUF9WM19BQkkgPSBbXG4gICAge1xuICAgICAgICBpbnB1dHM6IFtdLFxuICAgICAgICBuYW1lOiBcImZlZVwiLFxuICAgICAgICBvdXRwdXRzOiBbeyBpbnRlcm5hbFR5cGU6IFwidWludDI0XCIsIG5hbWU6IFwiXCIsIHR5cGU6IFwidWludDI0XCIgfV0sXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICB9LFxuICAgIHtcbiAgICAgICAgaW5wdXRzOiBbXSxcbiAgICAgICAgbmFtZTogXCJsaXF1aWRpdHlcIixcbiAgICAgICAgb3V0cHV0czogW3sgaW50ZXJuYWxUeXBlOiBcInVpbnQxMjhcIiwgbmFtZTogXCJcIiwgdHlwZTogXCJ1aW50MTI4XCIgfV0sXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICB9LFxuICAgIHtcbiAgICAgICAgaW5wdXRzOiBbXSxcbiAgICAgICAgbmFtZTogXCJzbG90MFwiLFxuICAgICAgICBvdXRwdXRzOiBbXG4gICAgICAgICAgICB7IGludGVybmFsVHlwZTogXCJ1aW50MTYwXCIsIG5hbWU6IFwic3FydFByaWNlWDk2XCIsIHR5cGU6IFwidWludDE2MFwiIH0sXG4gICAgICAgICAgICB7IGludGVybmFsVHlwZTogXCJpbnQyNFwiLCBuYW1lOiBcInRpY2tcIiwgdHlwZTogXCJpbnQyNFwiIH0sXG4gICAgICAgICAgICB7IGludGVybmFsVHlwZTogXCJ1aW50MTZcIiwgbmFtZTogXCJvYnNlcnZhdGlvbkluZGV4XCIsIHR5cGU6IFwidWludDE2XCIgfSxcbiAgICAgICAgICAgIHsgaW50ZXJuYWxUeXBlOiBcInVpbnQxNlwiLCBuYW1lOiBcIm9ic2VydmF0aW9uQ2FyZGluYWxpdHlcIiwgdHlwZTogXCJ1aW50MTZcIiB9LFxuICAgICAgICAgICAgeyBpbnRlcm5hbFR5cGU6IFwidWludDE2XCIsIG5hbWU6IFwib2JzZXJ2YXRpb25DYXJkaW5hbGl0eU5leHRcIiwgdHlwZTogXCJ1aW50MTZcIiB9LFxuICAgICAgICAgICAgeyBpbnRlcm5hbFR5cGU6IFwidWludDhcIiwgbmFtZTogXCJmZWVQcm90b2NvbFwiLCB0eXBlOiBcInVpbnQ4XCIgfSxcbiAgICAgICAgICAgIHsgaW50ZXJuYWxUeXBlOiBcImJvb2xcIiwgbmFtZTogXCJ1bmxvY2tlZFwiLCB0eXBlOiBcImJvb2xcIiB9LFxuICAgICAgICBdLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6IFwidmlld1wiLFxuICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlucHV0czogW10sXG4gICAgICAgIG5hbWU6IFwidG9rZW4wXCIsXG4gICAgICAgIG91dHB1dHM6IFt7IGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsIG5hbWU6IFwiXCIsIHR5cGU6IFwiYWRkcmVzc1wiIH1dLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6IFwidmlld1wiLFxuICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlucHV0czogW10sXG4gICAgICAgIG5hbWU6IFwidG9rZW4xXCIsXG4gICAgICAgIG91dHB1dHM6IFt7IGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsIG5hbWU6IFwiXCIsIHR5cGU6IFwiYWRkcmVzc1wiIH1dLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6IFwidmlld1wiLFxuICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgfSxcbl07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/wow/uniswap/constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/wow/uniswap/utils.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/wow/uniswap/utils.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createPriceInfo = createPriceInfo;\nexports.getPoolInfo = getPoolInfo;\nexports.exactInputSingle = exactInputSingle;\nexports.getUniswapQuote = getUniswapQuote;\nexports.getHasGraduated = getHasGraduated;\nexports.getPoolAddress = getPoolAddress;\nconst viem_1 = __webpack_require__(/*! viem */ \"(rsc)/./node_modules/viem/_cjs/index.js\");\nconst constants_1 = __webpack_require__(/*! ../constants */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/wow/constants.js\");\nconst constants_2 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/wow/uniswap/constants.js\");\n/**\n * Creates a PriceInfo object from wei amount and ETH price.\n *\n * @param weiAmount - Amount in wei\n * @param ethPriceInUsd - Current ETH price in USD\n * @returns A PriceInfo object containing the amount in ETH and USD\n */\nfunction createPriceInfo(weiAmount, ethPriceInUsd) {\n    const amountInEth = (0, viem_1.formatEther)(BigInt(weiAmount));\n    const usd = Number(amountInEth) * ethPriceInUsd;\n    return {\n        eth: weiAmount,\n        usd,\n    };\n}\n/**\n * Gets pool info for a given uniswap v3 pool address.\n *\n * @param wallet - The wallet provider to use for contract calls\n * @param poolAddress - Uniswap v3 pool address\n * @returns A PoolInfo object containing pool details\n */\nasync function getPoolInfo(wallet, poolAddress) {\n    try {\n        const results = await Promise.all([\n            wallet.readContract({\n                address: poolAddress,\n                functionName: \"token0\",\n                args: [],\n                abi: constants_2.UNISWAP_V3_ABI,\n            }),\n            wallet.readContract({\n                address: poolAddress,\n                functionName: \"token1\",\n                args: [],\n                abi: constants_2.UNISWAP_V3_ABI,\n            }),\n            wallet.readContract({\n                address: poolAddress,\n                functionName: \"fee\",\n                args: [],\n                abi: constants_2.UNISWAP_V3_ABI,\n            }),\n            wallet.readContract({\n                address: poolAddress,\n                functionName: \"liquidity\",\n                args: [],\n                abi: constants_2.UNISWAP_V3_ABI,\n            }),\n            wallet.readContract({\n                address: poolAddress,\n                functionName: \"slot0\",\n                args: [],\n                abi: constants_2.UNISWAP_V3_ABI,\n            }),\n        ]);\n        const [token0Result, token1Result, fee, liquidity, slot0] = results;\n        const [balance0, balance1] = await Promise.all([\n            wallet.readContract({\n                address: token0Result,\n                functionName: \"balanceOf\",\n                args: [poolAddress],\n                abi: constants_1.WOW_ABI,\n            }),\n            wallet.readContract({\n                address: token1Result,\n                functionName: \"balanceOf\",\n                args: [poolAddress],\n                abi: constants_1.WOW_ABI,\n            }),\n        ]);\n        return {\n            token0: token0Result,\n            balance0: Number(balance0),\n            token1: token1Result,\n            balance1: Number(balance1),\n            fee: Number(fee),\n            liquidity: Number(liquidity),\n            sqrtPriceX96: Number(slot0[0]),\n        };\n    }\n    catch (error) {\n        throw new Error(`Failed to fetch pool information: ${error}`);\n    }\n}\n/**\n * Gets exact input quote from Uniswap.\n *\n * @param wallet - The wallet provider to use for contract calls\n * @param tokenIn - Token address to swap from\n * @param tokenOut - Token address to swap to\n * @param amountIn - Amount of tokens to swap (in Wei)\n * @param fee - Fee for the swap\n * @returns Amount of tokens to receive (in Wei)\n */\nasync function exactInputSingle(wallet, tokenIn, tokenOut, amountIn, fee) {\n    try {\n        const networkId = wallet.getNetwork().networkId;\n        const amount = await wallet.readContract({\n            address: constants_1.ADDRESSES[networkId].UniswapQuoter,\n            functionName: \"quoteExactInputSingle\",\n            args: [\n                {\n                    tokenIn: (0, viem_1.getAddress)(tokenIn),\n                    tokenOut: (0, viem_1.getAddress)(tokenOut),\n                    fee,\n                    amountIn,\n                    sqrtPriceLimitX96: 0,\n                },\n            ],\n            abi: constants_2.UNISWAP_QUOTER_ABI,\n        });\n        return Number(amount);\n    }\n    catch (error) {\n        console.error(\"Quoter error:\", error);\n        return 0;\n    }\n}\n/**\n * Gets Uniswap quote for buying or selling tokens.\n *\n * @param wallet - The wallet provider to use for contract calls\n * @param tokenAddress - Token address\n * @param amount - Amount of tokens (in Wei)\n * @param quoteType - 'buy' or 'sell'\n * @returns A Quote object containing quote details\n */\nasync function getUniswapQuote(wallet, tokenAddress, amount, quoteType) {\n    let pool = null;\n    let tokens = null;\n    let balances = null;\n    let quoteResult = null;\n    const utilization = 0;\n    const networkId = wallet.getNetwork().networkId;\n    const poolAddress = await getPoolAddress(wallet, tokenAddress);\n    const invalidPoolError = !poolAddress ? \"Invalid pool address\" : null;\n    try {\n        pool = await getPoolInfo(wallet, poolAddress);\n        const { token0, token1, balance0, balance1, fee } = pool;\n        tokens = [token0, token1];\n        balances = [balance0, balance1];\n        const isToken0Weth = token0.toLowerCase() === constants_1.ADDRESSES[networkId].WETH.toLowerCase();\n        const tokenIn = (quoteType === \"buy\" && isToken0Weth) || (quoteType === \"sell\" && !isToken0Weth)\n            ? token0\n            : token1;\n        const [tokenOut, balanceOut] = tokenIn === token0 ? [token1, balance1] : [token0, balance0];\n        const isInsufficientLiquidity = quoteType === \"buy\" && amount > balanceOut;\n        if (!isInsufficientLiquidity) {\n            quoteResult = await exactInputSingle(wallet, tokenIn, tokenOut, String(amount), String(fee));\n        }\n    }\n    catch (error) {\n        console.error(\"Error fetching quote:\", error);\n    }\n    const insufficientLiquidity = (quoteType === \"sell\" && pool && !quoteResult) || false;\n    let errorMsg = null;\n    if (!pool) {\n        errorMsg = \"Failed fetching pool\";\n    }\n    else if (insufficientLiquidity) {\n        errorMsg = \"Insufficient liquidity\";\n    }\n    else if (!quoteResult && utilization >= 0.9) {\n        errorMsg = \"Price impact too high\";\n    }\n    else if (!quoteResult) {\n        errorMsg = \"Failed fetching quote\";\n    }\n    const balanceResult = tokens && balances\n        ? {\n            erc20z: String(balances[tokens[0].toLowerCase() === constants_1.ADDRESSES[networkId].WETH.toLowerCase() ? 1 : 0]),\n            weth: String(balances[tokens[0].toLowerCase() === constants_1.ADDRESSES[networkId].WETH.toLowerCase() ? 0 : 1]),\n        }\n        : null;\n    return {\n        amountIn: Number(amount),\n        amountOut: quoteResult || 0,\n        balance: balanceResult,\n        fee: pool?.fee ? pool.fee / 1000000 : null,\n        error: invalidPoolError || errorMsg,\n    };\n}\n/**\n * Checks if a token has graduated from the Zora Wow protocol.\n *\n * @param wallet - The wallet provider to use for contract calls\n * @param tokenAddress - Token address\n * @returns True if the token has graduated, false otherwise\n */\nasync function getHasGraduated(wallet, tokenAddress) {\n    const marketType = await wallet.readContract({\n        address: tokenAddress,\n        functionName: \"marketType\",\n        args: [],\n        abi: constants_1.WOW_ABI,\n    });\n    return marketType === 1;\n}\n/**\n * Fetches the uniswap v3 pool address for a given token.\n *\n * @param wallet - The wallet provider to use for contract calls\n * @param tokenAddress - The address of the token contract\n * @returns The uniswap v3 pool address associated with the token\n */\nasync function getPoolAddress(wallet, tokenAddress) {\n    const poolAddress = await wallet.readContract({\n        address: tokenAddress,\n        functionName: \"poolAddress\",\n        args: [],\n        abi: constants_1.WOW_ABI,\n    });\n    return poolAddress;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy93b3cvdW5pc3dhcC91dGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx1QkFBdUI7QUFDdkIsbUJBQW1CO0FBQ25CLHdCQUF3QjtBQUN4Qix1QkFBdUI7QUFDdkIsdUJBQXVCO0FBQ3ZCLHNCQUFzQjtBQUN0QixlQUFlLG1CQUFPLENBQUMscURBQU07QUFDN0Isb0JBQW9CLG1CQUFPLENBQUMsb0dBQWM7QUFDMUMsb0JBQW9CLG1CQUFPLENBQUMsMkdBQWE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxNQUFNO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDBDQUEwQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3Vydml2YWwtZnVuLy4vbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9hZ2VudGtpdC9kaXN0L2FjdGlvbi1wcm92aWRlcnMvd293L3VuaXN3YXAvdXRpbHMuanM/YWM3MCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlUHJpY2VJbmZvID0gY3JlYXRlUHJpY2VJbmZvO1xuZXhwb3J0cy5nZXRQb29sSW5mbyA9IGdldFBvb2xJbmZvO1xuZXhwb3J0cy5leGFjdElucHV0U2luZ2xlID0gZXhhY3RJbnB1dFNpbmdsZTtcbmV4cG9ydHMuZ2V0VW5pc3dhcFF1b3RlID0gZ2V0VW5pc3dhcFF1b3RlO1xuZXhwb3J0cy5nZXRIYXNHcmFkdWF0ZWQgPSBnZXRIYXNHcmFkdWF0ZWQ7XG5leHBvcnRzLmdldFBvb2xBZGRyZXNzID0gZ2V0UG9vbEFkZHJlc3M7XG5jb25zdCB2aWVtXzEgPSByZXF1aXJlKFwidmllbVwiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4uL2NvbnN0YW50c1wiKTtcbmNvbnN0IGNvbnN0YW50c18yID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuLyoqXG4gKiBDcmVhdGVzIGEgUHJpY2VJbmZvIG9iamVjdCBmcm9tIHdlaSBhbW91bnQgYW5kIEVUSCBwcmljZS5cbiAqXG4gKiBAcGFyYW0gd2VpQW1vdW50IC0gQW1vdW50IGluIHdlaVxuICogQHBhcmFtIGV0aFByaWNlSW5Vc2QgLSBDdXJyZW50IEVUSCBwcmljZSBpbiBVU0RcbiAqIEByZXR1cm5zIEEgUHJpY2VJbmZvIG9iamVjdCBjb250YWluaW5nIHRoZSBhbW91bnQgaW4gRVRIIGFuZCBVU0RcbiAqL1xuZnVuY3Rpb24gY3JlYXRlUHJpY2VJbmZvKHdlaUFtb3VudCwgZXRoUHJpY2VJblVzZCkge1xuICAgIGNvbnN0IGFtb3VudEluRXRoID0gKDAsIHZpZW1fMS5mb3JtYXRFdGhlcikoQmlnSW50KHdlaUFtb3VudCkpO1xuICAgIGNvbnN0IHVzZCA9IE51bWJlcihhbW91bnRJbkV0aCkgKiBldGhQcmljZUluVXNkO1xuICAgIHJldHVybiB7XG4gICAgICAgIGV0aDogd2VpQW1vdW50LFxuICAgICAgICB1c2QsXG4gICAgfTtcbn1cbi8qKlxuICogR2V0cyBwb29sIGluZm8gZm9yIGEgZ2l2ZW4gdW5pc3dhcCB2MyBwb29sIGFkZHJlc3MuXG4gKlxuICogQHBhcmFtIHdhbGxldCAtIFRoZSB3YWxsZXQgcHJvdmlkZXIgdG8gdXNlIGZvciBjb250cmFjdCBjYWxsc1xuICogQHBhcmFtIHBvb2xBZGRyZXNzIC0gVW5pc3dhcCB2MyBwb29sIGFkZHJlc3NcbiAqIEByZXR1cm5zIEEgUG9vbEluZm8gb2JqZWN0IGNvbnRhaW5pbmcgcG9vbCBkZXRhaWxzXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldFBvb2xJbmZvKHdhbGxldCwgcG9vbEFkZHJlc3MpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgd2FsbGV0LnJlYWRDb250cmFjdCh7XG4gICAgICAgICAgICAgICAgYWRkcmVzczogcG9vbEFkZHJlc3MsXG4gICAgICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiBcInRva2VuMFwiLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtdLFxuICAgICAgICAgICAgICAgIGFiaTogY29uc3RhbnRzXzIuVU5JU1dBUF9WM19BQkksXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHdhbGxldC5yZWFkQ29udHJhY3Qoe1xuICAgICAgICAgICAgICAgIGFkZHJlc3M6IHBvb2xBZGRyZXNzLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogXCJ0b2tlbjFcIixcbiAgICAgICAgICAgICAgICBhcmdzOiBbXSxcbiAgICAgICAgICAgICAgICBhYmk6IGNvbnN0YW50c18yLlVOSVNXQVBfVjNfQUJJLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB3YWxsZXQucmVhZENvbnRyYWN0KHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzOiBwb29sQWRkcmVzcyxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWU6IFwiZmVlXCIsXG4gICAgICAgICAgICAgICAgYXJnczogW10sXG4gICAgICAgICAgICAgICAgYWJpOiBjb25zdGFudHNfMi5VTklTV0FQX1YzX0FCSSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgd2FsbGV0LnJlYWRDb250cmFjdCh7XG4gICAgICAgICAgICAgICAgYWRkcmVzczogcG9vbEFkZHJlc3MsXG4gICAgICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiBcImxpcXVpZGl0eVwiLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtdLFxuICAgICAgICAgICAgICAgIGFiaTogY29uc3RhbnRzXzIuVU5JU1dBUF9WM19BQkksXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHdhbGxldC5yZWFkQ29udHJhY3Qoe1xuICAgICAgICAgICAgICAgIGFkZHJlc3M6IHBvb2xBZGRyZXNzLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogXCJzbG90MFwiLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtdLFxuICAgICAgICAgICAgICAgIGFiaTogY29uc3RhbnRzXzIuVU5JU1dBUF9WM19BQkksXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgXSk7XG4gICAgICAgIGNvbnN0IFt0b2tlbjBSZXN1bHQsIHRva2VuMVJlc3VsdCwgZmVlLCBsaXF1aWRpdHksIHNsb3QwXSA9IHJlc3VsdHM7XG4gICAgICAgIGNvbnN0IFtiYWxhbmNlMCwgYmFsYW5jZTFdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgd2FsbGV0LnJlYWRDb250cmFjdCh7XG4gICAgICAgICAgICAgICAgYWRkcmVzczogdG9rZW4wUmVzdWx0LFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogXCJiYWxhbmNlT2ZcIixcbiAgICAgICAgICAgICAgICBhcmdzOiBbcG9vbEFkZHJlc3NdLFxuICAgICAgICAgICAgICAgIGFiaTogY29uc3RhbnRzXzEuV09XX0FCSSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgd2FsbGV0LnJlYWRDb250cmFjdCh7XG4gICAgICAgICAgICAgICAgYWRkcmVzczogdG9rZW4xUmVzdWx0LFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogXCJiYWxhbmNlT2ZcIixcbiAgICAgICAgICAgICAgICBhcmdzOiBbcG9vbEFkZHJlc3NdLFxuICAgICAgICAgICAgICAgIGFiaTogY29uc3RhbnRzXzEuV09XX0FCSSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICBdKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRva2VuMDogdG9rZW4wUmVzdWx0LFxuICAgICAgICAgICAgYmFsYW5jZTA6IE51bWJlcihiYWxhbmNlMCksXG4gICAgICAgICAgICB0b2tlbjE6IHRva2VuMVJlc3VsdCxcbiAgICAgICAgICAgIGJhbGFuY2UxOiBOdW1iZXIoYmFsYW5jZTEpLFxuICAgICAgICAgICAgZmVlOiBOdW1iZXIoZmVlKSxcbiAgICAgICAgICAgIGxpcXVpZGl0eTogTnVtYmVyKGxpcXVpZGl0eSksXG4gICAgICAgICAgICBzcXJ0UHJpY2VYOTY6IE51bWJlcihzbG90MFswXSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCBwb29sIGluZm9ybWF0aW9uOiAke2Vycm9yfWApO1xuICAgIH1cbn1cbi8qKlxuICogR2V0cyBleGFjdCBpbnB1dCBxdW90ZSBmcm9tIFVuaXN3YXAuXG4gKlxuICogQHBhcmFtIHdhbGxldCAtIFRoZSB3YWxsZXQgcHJvdmlkZXIgdG8gdXNlIGZvciBjb250cmFjdCBjYWxsc1xuICogQHBhcmFtIHRva2VuSW4gLSBUb2tlbiBhZGRyZXNzIHRvIHN3YXAgZnJvbVxuICogQHBhcmFtIHRva2VuT3V0IC0gVG9rZW4gYWRkcmVzcyB0byBzd2FwIHRvXG4gKiBAcGFyYW0gYW1vdW50SW4gLSBBbW91bnQgb2YgdG9rZW5zIHRvIHN3YXAgKGluIFdlaSlcbiAqIEBwYXJhbSBmZWUgLSBGZWUgZm9yIHRoZSBzd2FwXG4gKiBAcmV0dXJucyBBbW91bnQgb2YgdG9rZW5zIHRvIHJlY2VpdmUgKGluIFdlaSlcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZXhhY3RJbnB1dFNpbmdsZSh3YWxsZXQsIHRva2VuSW4sIHRva2VuT3V0LCBhbW91bnRJbiwgZmVlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgbmV0d29ya0lkID0gd2FsbGV0LmdldE5ldHdvcmsoKS5uZXR3b3JrSWQ7XG4gICAgICAgIGNvbnN0IGFtb3VudCA9IGF3YWl0IHdhbGxldC5yZWFkQ29udHJhY3Qoe1xuICAgICAgICAgICAgYWRkcmVzczogY29uc3RhbnRzXzEuQUREUkVTU0VTW25ldHdvcmtJZF0uVW5pc3dhcFF1b3RlcixcbiAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogXCJxdW90ZUV4YWN0SW5wdXRTaW5nbGVcIixcbiAgICAgICAgICAgIGFyZ3M6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuSW46ICgwLCB2aWVtXzEuZ2V0QWRkcmVzcykodG9rZW5JbiksXG4gICAgICAgICAgICAgICAgICAgIHRva2VuT3V0OiAoMCwgdmllbV8xLmdldEFkZHJlc3MpKHRva2VuT3V0KSxcbiAgICAgICAgICAgICAgICAgICAgZmVlLFxuICAgICAgICAgICAgICAgICAgICBhbW91bnRJbixcbiAgICAgICAgICAgICAgICAgICAgc3FydFByaWNlTGltaXRYOTY6IDAsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBhYmk6IGNvbnN0YW50c18yLlVOSVNXQVBfUVVPVEVSX0FCSSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBOdW1iZXIoYW1vdW50KTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJRdW90ZXIgZXJyb3I6XCIsIGVycm9yKTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxufVxuLyoqXG4gKiBHZXRzIFVuaXN3YXAgcXVvdGUgZm9yIGJ1eWluZyBvciBzZWxsaW5nIHRva2Vucy5cbiAqXG4gKiBAcGFyYW0gd2FsbGV0IC0gVGhlIHdhbGxldCBwcm92aWRlciB0byB1c2UgZm9yIGNvbnRyYWN0IGNhbGxzXG4gKiBAcGFyYW0gdG9rZW5BZGRyZXNzIC0gVG9rZW4gYWRkcmVzc1xuICogQHBhcmFtIGFtb3VudCAtIEFtb3VudCBvZiB0b2tlbnMgKGluIFdlaSlcbiAqIEBwYXJhbSBxdW90ZVR5cGUgLSAnYnV5JyBvciAnc2VsbCdcbiAqIEByZXR1cm5zIEEgUXVvdGUgb2JqZWN0IGNvbnRhaW5pbmcgcXVvdGUgZGV0YWlsc1xuICovXG5hc3luYyBmdW5jdGlvbiBnZXRVbmlzd2FwUXVvdGUod2FsbGV0LCB0b2tlbkFkZHJlc3MsIGFtb3VudCwgcXVvdGVUeXBlKSB7XG4gICAgbGV0IHBvb2wgPSBudWxsO1xuICAgIGxldCB0b2tlbnMgPSBudWxsO1xuICAgIGxldCBiYWxhbmNlcyA9IG51bGw7XG4gICAgbGV0IHF1b3RlUmVzdWx0ID0gbnVsbDtcbiAgICBjb25zdCB1dGlsaXphdGlvbiA9IDA7XG4gICAgY29uc3QgbmV0d29ya0lkID0gd2FsbGV0LmdldE5ldHdvcmsoKS5uZXR3b3JrSWQ7XG4gICAgY29uc3QgcG9vbEFkZHJlc3MgPSBhd2FpdCBnZXRQb29sQWRkcmVzcyh3YWxsZXQsIHRva2VuQWRkcmVzcyk7XG4gICAgY29uc3QgaW52YWxpZFBvb2xFcnJvciA9ICFwb29sQWRkcmVzcyA/IFwiSW52YWxpZCBwb29sIGFkZHJlc3NcIiA6IG51bGw7XG4gICAgdHJ5IHtcbiAgICAgICAgcG9vbCA9IGF3YWl0IGdldFBvb2xJbmZvKHdhbGxldCwgcG9vbEFkZHJlc3MpO1xuICAgICAgICBjb25zdCB7IHRva2VuMCwgdG9rZW4xLCBiYWxhbmNlMCwgYmFsYW5jZTEsIGZlZSB9ID0gcG9vbDtcbiAgICAgICAgdG9rZW5zID0gW3Rva2VuMCwgdG9rZW4xXTtcbiAgICAgICAgYmFsYW5jZXMgPSBbYmFsYW5jZTAsIGJhbGFuY2UxXTtcbiAgICAgICAgY29uc3QgaXNUb2tlbjBXZXRoID0gdG9rZW4wLnRvTG93ZXJDYXNlKCkgPT09IGNvbnN0YW50c18xLkFERFJFU1NFU1tuZXR3b3JrSWRdLldFVEgudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgY29uc3QgdG9rZW5JbiA9IChxdW90ZVR5cGUgPT09IFwiYnV5XCIgJiYgaXNUb2tlbjBXZXRoKSB8fCAocXVvdGVUeXBlID09PSBcInNlbGxcIiAmJiAhaXNUb2tlbjBXZXRoKVxuICAgICAgICAgICAgPyB0b2tlbjBcbiAgICAgICAgICAgIDogdG9rZW4xO1xuICAgICAgICBjb25zdCBbdG9rZW5PdXQsIGJhbGFuY2VPdXRdID0gdG9rZW5JbiA9PT0gdG9rZW4wID8gW3Rva2VuMSwgYmFsYW5jZTFdIDogW3Rva2VuMCwgYmFsYW5jZTBdO1xuICAgICAgICBjb25zdCBpc0luc3VmZmljaWVudExpcXVpZGl0eSA9IHF1b3RlVHlwZSA9PT0gXCJidXlcIiAmJiBhbW91bnQgPiBiYWxhbmNlT3V0O1xuICAgICAgICBpZiAoIWlzSW5zdWZmaWNpZW50TGlxdWlkaXR5KSB7XG4gICAgICAgICAgICBxdW90ZVJlc3VsdCA9IGF3YWl0IGV4YWN0SW5wdXRTaW5nbGUod2FsbGV0LCB0b2tlbkluLCB0b2tlbk91dCwgU3RyaW5nKGFtb3VudCksIFN0cmluZyhmZWUpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGZldGNoaW5nIHF1b3RlOlwiLCBlcnJvcik7XG4gICAgfVxuICAgIGNvbnN0IGluc3VmZmljaWVudExpcXVpZGl0eSA9IChxdW90ZVR5cGUgPT09IFwic2VsbFwiICYmIHBvb2wgJiYgIXF1b3RlUmVzdWx0KSB8fCBmYWxzZTtcbiAgICBsZXQgZXJyb3JNc2cgPSBudWxsO1xuICAgIGlmICghcG9vbCkge1xuICAgICAgICBlcnJvck1zZyA9IFwiRmFpbGVkIGZldGNoaW5nIHBvb2xcIjtcbiAgICB9XG4gICAgZWxzZSBpZiAoaW5zdWZmaWNpZW50TGlxdWlkaXR5KSB7XG4gICAgICAgIGVycm9yTXNnID0gXCJJbnN1ZmZpY2llbnQgbGlxdWlkaXR5XCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFxdW90ZVJlc3VsdCAmJiB1dGlsaXphdGlvbiA+PSAwLjkpIHtcbiAgICAgICAgZXJyb3JNc2cgPSBcIlByaWNlIGltcGFjdCB0b28gaGlnaFwiO1xuICAgIH1cbiAgICBlbHNlIGlmICghcXVvdGVSZXN1bHQpIHtcbiAgICAgICAgZXJyb3JNc2cgPSBcIkZhaWxlZCBmZXRjaGluZyBxdW90ZVwiO1xuICAgIH1cbiAgICBjb25zdCBiYWxhbmNlUmVzdWx0ID0gdG9rZW5zICYmIGJhbGFuY2VzXG4gICAgICAgID8ge1xuICAgICAgICAgICAgZXJjMjB6OiBTdHJpbmcoYmFsYW5jZXNbdG9rZW5zWzBdLnRvTG93ZXJDYXNlKCkgPT09IGNvbnN0YW50c18xLkFERFJFU1NFU1tuZXR3b3JrSWRdLldFVEgudG9Mb3dlckNhc2UoKSA/IDEgOiAwXSksXG4gICAgICAgICAgICB3ZXRoOiBTdHJpbmcoYmFsYW5jZXNbdG9rZW5zWzBdLnRvTG93ZXJDYXNlKCkgPT09IGNvbnN0YW50c18xLkFERFJFU1NFU1tuZXR3b3JrSWRdLldFVEgudG9Mb3dlckNhc2UoKSA/IDAgOiAxXSksXG4gICAgICAgIH1cbiAgICAgICAgOiBudWxsO1xuICAgIHJldHVybiB7XG4gICAgICAgIGFtb3VudEluOiBOdW1iZXIoYW1vdW50KSxcbiAgICAgICAgYW1vdW50T3V0OiBxdW90ZVJlc3VsdCB8fCAwLFxuICAgICAgICBiYWxhbmNlOiBiYWxhbmNlUmVzdWx0LFxuICAgICAgICBmZWU6IHBvb2w/LmZlZSA/IHBvb2wuZmVlIC8gMTAwMDAwMCA6IG51bGwsXG4gICAgICAgIGVycm9yOiBpbnZhbGlkUG9vbEVycm9yIHx8IGVycm9yTXNnLFxuICAgIH07XG59XG4vKipcbiAqIENoZWNrcyBpZiBhIHRva2VuIGhhcyBncmFkdWF0ZWQgZnJvbSB0aGUgWm9yYSBXb3cgcHJvdG9jb2wuXG4gKlxuICogQHBhcmFtIHdhbGxldCAtIFRoZSB3YWxsZXQgcHJvdmlkZXIgdG8gdXNlIGZvciBjb250cmFjdCBjYWxsc1xuICogQHBhcmFtIHRva2VuQWRkcmVzcyAtIFRva2VuIGFkZHJlc3NcbiAqIEByZXR1cm5zIFRydWUgaWYgdGhlIHRva2VuIGhhcyBncmFkdWF0ZWQsIGZhbHNlIG90aGVyd2lzZVxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRIYXNHcmFkdWF0ZWQod2FsbGV0LCB0b2tlbkFkZHJlc3MpIHtcbiAgICBjb25zdCBtYXJrZXRUeXBlID0gYXdhaXQgd2FsbGV0LnJlYWRDb250cmFjdCh7XG4gICAgICAgIGFkZHJlc3M6IHRva2VuQWRkcmVzcyxcbiAgICAgICAgZnVuY3Rpb25OYW1lOiBcIm1hcmtldFR5cGVcIixcbiAgICAgICAgYXJnczogW10sXG4gICAgICAgIGFiaTogY29uc3RhbnRzXzEuV09XX0FCSSxcbiAgICB9KTtcbiAgICByZXR1cm4gbWFya2V0VHlwZSA9PT0gMTtcbn1cbi8qKlxuICogRmV0Y2hlcyB0aGUgdW5pc3dhcCB2MyBwb29sIGFkZHJlc3MgZm9yIGEgZ2l2ZW4gdG9rZW4uXG4gKlxuICogQHBhcmFtIHdhbGxldCAtIFRoZSB3YWxsZXQgcHJvdmlkZXIgdG8gdXNlIGZvciBjb250cmFjdCBjYWxsc1xuICogQHBhcmFtIHRva2VuQWRkcmVzcyAtIFRoZSBhZGRyZXNzIG9mIHRoZSB0b2tlbiBjb250cmFjdFxuICogQHJldHVybnMgVGhlIHVuaXN3YXAgdjMgcG9vbCBhZGRyZXNzIGFzc29jaWF0ZWQgd2l0aCB0aGUgdG9rZW5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0UG9vbEFkZHJlc3Mod2FsbGV0LCB0b2tlbkFkZHJlc3MpIHtcbiAgICBjb25zdCBwb29sQWRkcmVzcyA9IGF3YWl0IHdhbGxldC5yZWFkQ29udHJhY3Qoe1xuICAgICAgICBhZGRyZXNzOiB0b2tlbkFkZHJlc3MsXG4gICAgICAgIGZ1bmN0aW9uTmFtZTogXCJwb29sQWRkcmVzc1wiLFxuICAgICAgICBhcmdzOiBbXSxcbiAgICAgICAgYWJpOiBjb25zdGFudHNfMS5XT1dfQUJJLFxuICAgIH0pO1xuICAgIHJldHVybiBwb29sQWRkcmVzcztcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/wow/uniswap/utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/wow/utils.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/wow/utils.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getCurrentSupply = getCurrentSupply;\nexports.getBuyQuote = getBuyQuote;\nexports.getSellQuote = getSellQuote;\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/wow/constants.js\");\nconst utils_1 = __webpack_require__(/*! ./uniswap/utils */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/wow/uniswap/utils.js\");\n/**\n * Gets the current supply of a token.\n *\n * @param wallet - The wallet provider to use for contract calls\n * @param tokenAddress - Address of the token contract\n * @returns The current token supply\n */\nasync function getCurrentSupply(wallet, tokenAddress) {\n    const supply = await wallet.readContract({\n        address: tokenAddress,\n        abi: constants_1.WOW_ABI,\n        functionName: \"totalSupply\",\n        args: [],\n    });\n    return supply;\n}\n/**\n * Gets quote for buying tokens.\n *\n * @param wallet - The wallet provider to use for contract calls\n * @param tokenAddress - Address of the token contract\n * @param amountEthInWei - Amount of ETH to buy (in wei)\n * @returns The buy quote amount\n */\nasync function getBuyQuote(wallet, tokenAddress, amountEthInWei) {\n    const hasGraduated = await (0, utils_1.getHasGraduated)(wallet, tokenAddress);\n    const tokenQuote = (hasGraduated\n        ? (await (0, utils_1.getUniswapQuote)(wallet, tokenAddress, Number(amountEthInWei), \"buy\")).amountOut\n        : await wallet.readContract({\n            address: tokenAddress,\n            abi: constants_1.WOW_ABI,\n            functionName: \"getEthBuyQuote\",\n            args: [amountEthInWei],\n        }));\n    return tokenQuote.toString();\n}\n/**\n * Gets quote for selling tokens.\n *\n * @param wallet - The wallet provider to use for contract calls\n * @param tokenAddress - Address of the token contract\n * @param amountTokensInWei - Amount of tokens to sell (in wei)\n * @returns The sell quote amount\n */\nasync function getSellQuote(wallet, tokenAddress, amountTokensInWei) {\n    const hasGraduated = await (0, utils_1.getHasGraduated)(wallet, tokenAddress);\n    const tokenQuote = (hasGraduated\n        ? (await (0, utils_1.getUniswapQuote)(wallet, tokenAddress, Number(amountTokensInWei), \"sell\")).amountOut\n        : await wallet.readContract({\n            address: tokenAddress,\n            abi: constants_1.WOW_ABI,\n            functionName: \"getTokenSellQuote\",\n            args: [amountTokensInWei],\n        }));\n    return tokenQuote.toString();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy93b3cvdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsd0JBQXdCO0FBQ3hCLG1CQUFtQjtBQUNuQixvQkFBb0I7QUFDcEIsb0JBQW9CLG1CQUFPLENBQUMsbUdBQWE7QUFDekMsZ0JBQWdCLG1CQUFPLENBQUMsMkdBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXJ2aXZhbC1mdW4vLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy93b3cvdXRpbHMuanM/NjU5ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0Q3VycmVudFN1cHBseSA9IGdldEN1cnJlbnRTdXBwbHk7XG5leHBvcnRzLmdldEJ1eVF1b3RlID0gZ2V0QnV5UXVvdGU7XG5leHBvcnRzLmdldFNlbGxRdW90ZSA9IGdldFNlbGxRdW90ZTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3VuaXN3YXAvdXRpbHNcIik7XG4vKipcbiAqIEdldHMgdGhlIGN1cnJlbnQgc3VwcGx5IG9mIGEgdG9rZW4uXG4gKlxuICogQHBhcmFtIHdhbGxldCAtIFRoZSB3YWxsZXQgcHJvdmlkZXIgdG8gdXNlIGZvciBjb250cmFjdCBjYWxsc1xuICogQHBhcmFtIHRva2VuQWRkcmVzcyAtIEFkZHJlc3Mgb2YgdGhlIHRva2VuIGNvbnRyYWN0XG4gKiBAcmV0dXJucyBUaGUgY3VycmVudCB0b2tlbiBzdXBwbHlcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0Q3VycmVudFN1cHBseSh3YWxsZXQsIHRva2VuQWRkcmVzcykge1xuICAgIGNvbnN0IHN1cHBseSA9IGF3YWl0IHdhbGxldC5yZWFkQ29udHJhY3Qoe1xuICAgICAgICBhZGRyZXNzOiB0b2tlbkFkZHJlc3MsXG4gICAgICAgIGFiaTogY29uc3RhbnRzXzEuV09XX0FCSSxcbiAgICAgICAgZnVuY3Rpb25OYW1lOiBcInRvdGFsU3VwcGx5XCIsXG4gICAgICAgIGFyZ3M6IFtdLFxuICAgIH0pO1xuICAgIHJldHVybiBzdXBwbHk7XG59XG4vKipcbiAqIEdldHMgcXVvdGUgZm9yIGJ1eWluZyB0b2tlbnMuXG4gKlxuICogQHBhcmFtIHdhbGxldCAtIFRoZSB3YWxsZXQgcHJvdmlkZXIgdG8gdXNlIGZvciBjb250cmFjdCBjYWxsc1xuICogQHBhcmFtIHRva2VuQWRkcmVzcyAtIEFkZHJlc3Mgb2YgdGhlIHRva2VuIGNvbnRyYWN0XG4gKiBAcGFyYW0gYW1vdW50RXRoSW5XZWkgLSBBbW91bnQgb2YgRVRIIHRvIGJ1eSAoaW4gd2VpKVxuICogQHJldHVybnMgVGhlIGJ1eSBxdW90ZSBhbW91bnRcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0QnV5UXVvdGUod2FsbGV0LCB0b2tlbkFkZHJlc3MsIGFtb3VudEV0aEluV2VpKSB7XG4gICAgY29uc3QgaGFzR3JhZHVhdGVkID0gYXdhaXQgKDAsIHV0aWxzXzEuZ2V0SGFzR3JhZHVhdGVkKSh3YWxsZXQsIHRva2VuQWRkcmVzcyk7XG4gICAgY29uc3QgdG9rZW5RdW90ZSA9IChoYXNHcmFkdWF0ZWRcbiAgICAgICAgPyAoYXdhaXQgKDAsIHV0aWxzXzEuZ2V0VW5pc3dhcFF1b3RlKSh3YWxsZXQsIHRva2VuQWRkcmVzcywgTnVtYmVyKGFtb3VudEV0aEluV2VpKSwgXCJidXlcIikpLmFtb3VudE91dFxuICAgICAgICA6IGF3YWl0IHdhbGxldC5yZWFkQ29udHJhY3Qoe1xuICAgICAgICAgICAgYWRkcmVzczogdG9rZW5BZGRyZXNzLFxuICAgICAgICAgICAgYWJpOiBjb25zdGFudHNfMS5XT1dfQUJJLFxuICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiBcImdldEV0aEJ1eVF1b3RlXCIsXG4gICAgICAgICAgICBhcmdzOiBbYW1vdW50RXRoSW5XZWldLFxuICAgICAgICB9KSk7XG4gICAgcmV0dXJuIHRva2VuUXVvdGUudG9TdHJpbmcoKTtcbn1cbi8qKlxuICogR2V0cyBxdW90ZSBmb3Igc2VsbGluZyB0b2tlbnMuXG4gKlxuICogQHBhcmFtIHdhbGxldCAtIFRoZSB3YWxsZXQgcHJvdmlkZXIgdG8gdXNlIGZvciBjb250cmFjdCBjYWxsc1xuICogQHBhcmFtIHRva2VuQWRkcmVzcyAtIEFkZHJlc3Mgb2YgdGhlIHRva2VuIGNvbnRyYWN0XG4gKiBAcGFyYW0gYW1vdW50VG9rZW5zSW5XZWkgLSBBbW91bnQgb2YgdG9rZW5zIHRvIHNlbGwgKGluIHdlaSlcbiAqIEByZXR1cm5zIFRoZSBzZWxsIHF1b3RlIGFtb3VudFxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRTZWxsUXVvdGUod2FsbGV0LCB0b2tlbkFkZHJlc3MsIGFtb3VudFRva2Vuc0luV2VpKSB7XG4gICAgY29uc3QgaGFzR3JhZHVhdGVkID0gYXdhaXQgKDAsIHV0aWxzXzEuZ2V0SGFzR3JhZHVhdGVkKSh3YWxsZXQsIHRva2VuQWRkcmVzcyk7XG4gICAgY29uc3QgdG9rZW5RdW90ZSA9IChoYXNHcmFkdWF0ZWRcbiAgICAgICAgPyAoYXdhaXQgKDAsIHV0aWxzXzEuZ2V0VW5pc3dhcFF1b3RlKSh3YWxsZXQsIHRva2VuQWRkcmVzcywgTnVtYmVyKGFtb3VudFRva2Vuc0luV2VpKSwgXCJzZWxsXCIpKS5hbW91bnRPdXRcbiAgICAgICAgOiBhd2FpdCB3YWxsZXQucmVhZENvbnRyYWN0KHtcbiAgICAgICAgICAgIGFkZHJlc3M6IHRva2VuQWRkcmVzcyxcbiAgICAgICAgICAgIGFiaTogY29uc3RhbnRzXzEuV09XX0FCSSxcbiAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogXCJnZXRUb2tlblNlbGxRdW90ZVwiLFxuICAgICAgICAgICAgYXJnczogW2Ftb3VudFRva2Vuc0luV2VpXSxcbiAgICAgICAgfSkpO1xuICAgIHJldHVybiB0b2tlblF1b3RlLnRvU3RyaW5nKCk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/wow/utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/wow/wowActionProvider.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/action-providers/wow/wowActionProvider.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.wowActionProvider = exports.WowActionProvider = void 0;\nconst zod_1 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/lib/index.js\");\nconst actionProvider_1 = __webpack_require__(/*! ../actionProvider */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/actionProvider.js\");\nconst wallet_providers_1 = __webpack_require__(/*! ../../wallet-providers */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/wallet-providers/index.js\");\nconst actionDecorator_1 = __webpack_require__(/*! ../actionDecorator */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/actionDecorator.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/wow/constants.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/wow/utils.js\");\nconst utils_2 = __webpack_require__(/*! ./uniswap/utils */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/wow/uniswap/utils.js\");\nconst viem_1 = __webpack_require__(/*! viem */ \"(rsc)/./node_modules/viem/_cjs/index.js\");\nconst schemas_1 = __webpack_require__(/*! ./schemas */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/wow/schemas.js\");\n/**\n * WowActionProvider is an action provider for Wow protocol interactions.\n */\nclass WowActionProvider extends actionProvider_1.ActionProvider {\n    /**\n     * Constructor for the WowActionProvider class.\n     */\n    constructor() {\n        super(\"wow\", []);\n        /**\n         * Checks if the Wow action provider supports the given network.\n         *\n         * @param network - The network to check.\n         * @returns True if the Wow action provider supports the network, false otherwise.\n         */\n        this.supportsNetwork = (network) => network.protocolFamily === \"evm\" && constants_1.SUPPORTED_NETWORKS.includes(network.networkId);\n    }\n    /**\n     * Buys a Zora Wow ERC20 memecoin with ETH.\n     *\n     * @param walletProvider - The wallet to create the token from.\n     * @param args - The input arguments for the action.\n     * @returns A message containing the token purchase details.\n     */\n    async buyToken(walletProvider, args) {\n        try {\n            const tokenQuote = await (0, utils_1.getBuyQuote)(walletProvider, args.contractAddress, args.amountEthInWei);\n            // Multiply by 99/100 and floor to get 99% of quote as minimum\n            const minTokens = BigInt(Math.floor(Number(tokenQuote) * 99)) / BigInt(100);\n            const hasGraduated = await (0, utils_2.getHasGraduated)(walletProvider, args.contractAddress);\n            const data = (0, viem_1.encodeFunctionData)({\n                abi: constants_1.WOW_ABI,\n                functionName: \"buy\",\n                args: [\n                    walletProvider.getAddress(),\n                    walletProvider.getAddress(),\n                    \"0x0000000000000000000000000000000000000000\",\n                    \"\",\n                    hasGraduated ? 1n : 0n,\n                    minTokens,\n                    0n,\n                ],\n            });\n            const txHash = await walletProvider.sendTransaction({\n                to: args.contractAddress,\n                data,\n                value: BigInt(args.amountEthInWei),\n            });\n            await walletProvider.waitForTransactionReceipt(txHash);\n            return `Purchased WoW ERC20 memecoin with transaction hash: ${txHash}`;\n        }\n        catch (error) {\n            return `Error buying Zora Wow ERC20 memecoin: ${error}`;\n        }\n    }\n    /**\n     * Creates a Zora Wow ERC20 memecoin.\n     *\n     * @param wallet - The wallet to create the token from.\n     * @param args - The input arguments for the action.\n     * @returns A message containing the token creation details.\n     */\n    async createToken(wallet, args) {\n        const factoryAddress = (0, constants_1.getFactoryAddress)(wallet.getNetwork().networkId);\n        try {\n            const data = (0, viem_1.encodeFunctionData)({\n                abi: constants_1.WOW_FACTORY_ABI,\n                functionName: \"deploy\",\n                args: [\n                    wallet.getAddress(),\n                    \"0x0000000000000000000000000000000000000000\",\n                    args.tokenUri || constants_1.GENERIC_TOKEN_METADATA_URI,\n                    args.name,\n                    args.symbol,\n                ],\n            });\n            const txHash = await wallet.sendTransaction({\n                to: factoryAddress,\n                data,\n            });\n            await wallet.waitForTransactionReceipt(txHash);\n            return `Created WoW ERC20 memecoin ${args.name} with symbol ${args.symbol} on network ${wallet.getNetwork().networkId}.\\nTransaction hash: ${txHash}`;\n        }\n        catch (error) {\n            return `Error creating Zora Wow ERC20 memecoin: ${error}`;\n        }\n    }\n    /**\n     * Sells WOW tokens for ETH.\n     *\n     * @param walletProvider - The wallet to sell the tokens from.\n     * @param args - The input arguments for the action.\n     * @returns A message confirming the sale with the transaction hash.\n     */\n    async sellToken(walletProvider, args) {\n        try {\n            const ethQuote = await (0, utils_1.getSellQuote)(walletProvider, args.contractAddress, args.amountTokensInWei);\n            const hasGraduated = await (0, utils_2.getHasGraduated)(walletProvider, args.contractAddress);\n            // Multiply by 98/100 and floor to get 98% of quote as minimum\n            const minEth = BigInt(Math.floor(Number(ethQuote) * 98)) / BigInt(100);\n            const data = (0, viem_1.encodeFunctionData)({\n                abi: constants_1.WOW_ABI,\n                functionName: \"sell\",\n                args: [\n                    BigInt(args.amountTokensInWei),\n                    walletProvider.getAddress(),\n                    \"0x0000000000000000000000000000000000000000\",\n                    \"\",\n                    hasGraduated ? 1n : 0n,\n                    minEth,\n                    0n,\n                ],\n            });\n            const txHash = await walletProvider.sendTransaction({\n                to: args.contractAddress,\n                data,\n            });\n            await walletProvider.waitForTransactionReceipt(txHash);\n            return `Sold WoW ERC20 memecoin with transaction hash: ${txHash}`;\n        }\n        catch (error) {\n            return `Error selling Zora Wow ERC20 memecoin: ${error}`;\n        }\n    }\n}\nexports.WowActionProvider = WowActionProvider;\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"buy_token\",\n        description: `\nThis tool can only be used to buy a Zora Wow ERC20 memecoin (also can be referred to as a bonding curve token) with ETH.\nDo not use this tool for any other purpose, or trading other assets.\n\nInputs:\n- WOW token contract address\n- Address to receive the tokens  \n- Amount of ETH to spend (in wei)\n\nImportant notes:\n- The amount is a string and cannot have any decimal points, since the unit of measurement is wei.\n- Make sure to use the exact amount provided, and if there's any doubt, check by getting more information before continuing with the action. \n- 1 wei = 0.000000000000000001 ETH\n- Minimum purchase amount is 100000000000000 wei (0.0000001 ETH)\n- Only supported on the following networks:\n  - Base Sepolia (ie, 'base-sepolia')\n  - Base Mainnet (ie, 'base', 'base-mainnet')`,\n        schema: schemas_1.WowBuyTokenInput,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [wallet_providers_1.EvmWalletProvider, void 0]),\n    __metadata(\"design:returntype\", Promise)\n], WowActionProvider.prototype, \"buyToken\", null);\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"create_token\",\n        description: `\nThis tool can only be used to create a Zora Wow ERC20 memecoin (also can be referred to as a bonding curve token) using the WoW factory.\nDo not use this tool for any other purpose, or for creating other types of tokens.\n\nInputs:\n- Token name (e.g. WowCoin)\n- Token symbol (e.g. WOW) \n- Token URI (optional) - Contains metadata about the token\n\nImportant notes:\n- Uses a bonding curve - no upfront liquidity needed\n- Only supported on the following networks:\n  - Base Sepolia (ie, 'base-sepolia')\n  - Base Mainnet (ie, 'base', 'base-mainnet')`,\n        schema: schemas_1.WowCreateTokenInput,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [wallet_providers_1.EvmWalletProvider, void 0]),\n    __metadata(\"design:returntype\", Promise)\n], WowActionProvider.prototype, \"createToken\", null);\n__decorate([\n    (0, actionDecorator_1.CreateAction)({\n        name: \"sell_token\",\n        description: `\nThis tool can only be used to sell a Zora Wow ERC20 memecoin (also can be referred to as a bonding curve token) for ETH.\nDo not use this tool for any other purpose, or trading other assets.\n\nInputs:\n- WOW token contract address\n- Amount of tokens to sell (in wei)\n\nImportant notes:\n- The amount is a string and cannot have any decimal points, since the unit of measurement is wei.\n- Make sure to use the exact amount provided, and if there's any doubt, check by getting more information before continuing with the action. \n- 1 wei = 0.000000000000000001 ETH\n- Minimum purchase amount is 100000000000000 wei (0.0000001 ETH)\n- Only supported on the following networks:\n  - Base Sepolia (ie, 'base-sepolia')\n  - Base Mainnet (ie, 'base', 'base-mainnet')`,\n        schema: schemas_1.WowSellTokenInput,\n    }),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [wallet_providers_1.EvmWalletProvider, void 0]),\n    __metadata(\"design:returntype\", Promise)\n], WowActionProvider.prototype, \"sellToken\", null);\nconst wowActionProvider = () => new WowActionProvider();\nexports.wowActionProvider = wowActionProvider;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy93b3cvd293QWN0aW9uUHJvdmlkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsUUFBUTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHlCQUF5QixHQUFHLHlCQUF5QjtBQUNyRCxjQUFjLG1CQUFPLENBQUMsa0RBQUs7QUFDM0IseUJBQXlCLG1CQUFPLENBQUMsMEdBQW1CO0FBQ3BELDJCQUEyQixtQkFBTyxDQUFDLHNHQUF3QjtBQUMzRCwwQkFBMEIsbUJBQU8sQ0FBQyw0R0FBb0I7QUFDdEQsb0JBQW9CLG1CQUFPLENBQUMsbUdBQWE7QUFDekMsZ0JBQWdCLG1CQUFPLENBQUMsMkZBQVM7QUFDakMsZ0JBQWdCLG1CQUFPLENBQUMsMkdBQWlCO0FBQ3pDLGVBQWUsbUJBQU8sQ0FBQyxxREFBTTtBQUM3QixrQkFBa0IsbUJBQU8sQ0FBQywrRkFBVztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSwwRUFBMEUsT0FBTztBQUNqRjtBQUNBO0FBQ0EsNERBQTRELE1BQU07QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsaURBQWlELFdBQVcsY0FBYyxhQUFhLGFBQWEsOEJBQThCLHVCQUF1QixPQUFPO0FBQ2hLO0FBQ0E7QUFDQSw4REFBOEQsTUFBTTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EscUVBQXFFLE9BQU87QUFDNUU7QUFDQTtBQUNBLDZEQUE2RCxNQUFNO0FBQ25FO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXJ2aXZhbC1mdW4vLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWN0aW9uLXByb3ZpZGVycy93b3cvd293QWN0aW9uUHJvdmlkZXIuanM/Y2QxNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLndvd0FjdGlvblByb3ZpZGVyID0gZXhwb3J0cy5Xb3dBY3Rpb25Qcm92aWRlciA9IHZvaWQgMDtcbmNvbnN0IHpvZF8xID0gcmVxdWlyZShcInpvZFwiKTtcbmNvbnN0IGFjdGlvblByb3ZpZGVyXzEgPSByZXF1aXJlKFwiLi4vYWN0aW9uUHJvdmlkZXJcIik7XG5jb25zdCB3YWxsZXRfcHJvdmlkZXJzXzEgPSByZXF1aXJlKFwiLi4vLi4vd2FsbGV0LXByb3ZpZGVyc1wiKTtcbmNvbnN0IGFjdGlvbkRlY29yYXRvcl8xID0gcmVxdWlyZShcIi4uL2FjdGlvbkRlY29yYXRvclwiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuY29uc3QgdXRpbHNfMiA9IHJlcXVpcmUoXCIuL3VuaXN3YXAvdXRpbHNcIik7XG5jb25zdCB2aWVtXzEgPSByZXF1aXJlKFwidmllbVwiKTtcbmNvbnN0IHNjaGVtYXNfMSA9IHJlcXVpcmUoXCIuL3NjaGVtYXNcIik7XG4vKipcbiAqIFdvd0FjdGlvblByb3ZpZGVyIGlzIGFuIGFjdGlvbiBwcm92aWRlciBmb3IgV293IHByb3RvY29sIGludGVyYWN0aW9ucy5cbiAqL1xuY2xhc3MgV293QWN0aW9uUHJvdmlkZXIgZXh0ZW5kcyBhY3Rpb25Qcm92aWRlcl8xLkFjdGlvblByb3ZpZGVyIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgdGhlIFdvd0FjdGlvblByb3ZpZGVyIGNsYXNzLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihcIndvd1wiLCBbXSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVja3MgaWYgdGhlIFdvdyBhY3Rpb24gcHJvdmlkZXIgc3VwcG9ydHMgdGhlIGdpdmVuIG5ldHdvcmsuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBuZXR3b3JrIC0gVGhlIG5ldHdvcmsgdG8gY2hlY2suXG4gICAgICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIFdvdyBhY3Rpb24gcHJvdmlkZXIgc3VwcG9ydHMgdGhlIG5ldHdvcmssIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3VwcG9ydHNOZXR3b3JrID0gKG5ldHdvcmspID0+IG5ldHdvcmsucHJvdG9jb2xGYW1pbHkgPT09IFwiZXZtXCIgJiYgY29uc3RhbnRzXzEuU1VQUE9SVEVEX05FVFdPUktTLmluY2x1ZGVzKG5ldHdvcmsubmV0d29ya0lkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQnV5cyBhIFpvcmEgV293IEVSQzIwIG1lbWVjb2luIHdpdGggRVRILlxuICAgICAqXG4gICAgICogQHBhcmFtIHdhbGxldFByb3ZpZGVyIC0gVGhlIHdhbGxldCB0byBjcmVhdGUgdGhlIHRva2VuIGZyb20uXG4gICAgICogQHBhcmFtIGFyZ3MgLSBUaGUgaW5wdXQgYXJndW1lbnRzIGZvciB0aGUgYWN0aW9uLlxuICAgICAqIEByZXR1cm5zIEEgbWVzc2FnZSBjb250YWluaW5nIHRoZSB0b2tlbiBwdXJjaGFzZSBkZXRhaWxzLlxuICAgICAqL1xuICAgIGFzeW5jIGJ1eVRva2VuKHdhbGxldFByb3ZpZGVyLCBhcmdzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB0b2tlblF1b3RlID0gYXdhaXQgKDAsIHV0aWxzXzEuZ2V0QnV5UXVvdGUpKHdhbGxldFByb3ZpZGVyLCBhcmdzLmNvbnRyYWN0QWRkcmVzcywgYXJncy5hbW91bnRFdGhJbldlaSk7XG4gICAgICAgICAgICAvLyBNdWx0aXBseSBieSA5OS8xMDAgYW5kIGZsb29yIHRvIGdldCA5OSUgb2YgcXVvdGUgYXMgbWluaW11bVxuICAgICAgICAgICAgY29uc3QgbWluVG9rZW5zID0gQmlnSW50KE1hdGguZmxvb3IoTnVtYmVyKHRva2VuUXVvdGUpICogOTkpKSAvIEJpZ0ludCgxMDApO1xuICAgICAgICAgICAgY29uc3QgaGFzR3JhZHVhdGVkID0gYXdhaXQgKDAsIHV0aWxzXzIuZ2V0SGFzR3JhZHVhdGVkKSh3YWxsZXRQcm92aWRlciwgYXJncy5jb250cmFjdEFkZHJlc3MpO1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9ICgwLCB2aWVtXzEuZW5jb2RlRnVuY3Rpb25EYXRhKSh7XG4gICAgICAgICAgICAgICAgYWJpOiBjb25zdGFudHNfMS5XT1dfQUJJLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogXCJidXlcIixcbiAgICAgICAgICAgICAgICBhcmdzOiBbXG4gICAgICAgICAgICAgICAgICAgIHdhbGxldFByb3ZpZGVyLmdldEFkZHJlc3MoKSxcbiAgICAgICAgICAgICAgICAgICAgd2FsbGV0UHJvdmlkZXIuZ2V0QWRkcmVzcygpLFxuICAgICAgICAgICAgICAgICAgICBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiLFxuICAgICAgICAgICAgICAgICAgICBcIlwiLFxuICAgICAgICAgICAgICAgICAgICBoYXNHcmFkdWF0ZWQgPyAxbiA6IDBuLFxuICAgICAgICAgICAgICAgICAgICBtaW5Ub2tlbnMsXG4gICAgICAgICAgICAgICAgICAgIDBuLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHR4SGFzaCA9IGF3YWl0IHdhbGxldFByb3ZpZGVyLnNlbmRUcmFuc2FjdGlvbih7XG4gICAgICAgICAgICAgICAgdG86IGFyZ3MuY29udHJhY3RBZGRyZXNzLFxuICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICAgdmFsdWU6IEJpZ0ludChhcmdzLmFtb3VudEV0aEluV2VpKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgd2FsbGV0UHJvdmlkZXIud2FpdEZvclRyYW5zYWN0aW9uUmVjZWlwdCh0eEhhc2gpO1xuICAgICAgICAgICAgcmV0dXJuIGBQdXJjaGFzZWQgV29XIEVSQzIwIG1lbWVjb2luIHdpdGggdHJhbnNhY3Rpb24gaGFzaDogJHt0eEhhc2h9YDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBgRXJyb3IgYnV5aW5nIFpvcmEgV293IEVSQzIwIG1lbWVjb2luOiAke2Vycm9yfWA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIFpvcmEgV293IEVSQzIwIG1lbWVjb2luLlxuICAgICAqXG4gICAgICogQHBhcmFtIHdhbGxldCAtIFRoZSB3YWxsZXQgdG8gY3JlYXRlIHRoZSB0b2tlbiBmcm9tLlxuICAgICAqIEBwYXJhbSBhcmdzIC0gVGhlIGlucHV0IGFyZ3VtZW50cyBmb3IgdGhlIGFjdGlvbi5cbiAgICAgKiBAcmV0dXJucyBBIG1lc3NhZ2UgY29udGFpbmluZyB0aGUgdG9rZW4gY3JlYXRpb24gZGV0YWlscy5cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVUb2tlbih3YWxsZXQsIGFyZ3MpIHtcbiAgICAgICAgY29uc3QgZmFjdG9yeUFkZHJlc3MgPSAoMCwgY29uc3RhbnRzXzEuZ2V0RmFjdG9yeUFkZHJlc3MpKHdhbGxldC5nZXROZXR3b3JrKCkubmV0d29ya0lkKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSAoMCwgdmllbV8xLmVuY29kZUZ1bmN0aW9uRGF0YSkoe1xuICAgICAgICAgICAgICAgIGFiaTogY29uc3RhbnRzXzEuV09XX0ZBQ1RPUllfQUJJLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogXCJkZXBsb3lcIixcbiAgICAgICAgICAgICAgICBhcmdzOiBbXG4gICAgICAgICAgICAgICAgICAgIHdhbGxldC5nZXRBZGRyZXNzKCksXG4gICAgICAgICAgICAgICAgICAgIFwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCIsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3MudG9rZW5VcmkgfHwgY29uc3RhbnRzXzEuR0VORVJJQ19UT0tFTl9NRVRBREFUQV9VUkksXG4gICAgICAgICAgICAgICAgICAgIGFyZ3MubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgYXJncy5zeW1ib2wsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgdHhIYXNoID0gYXdhaXQgd2FsbGV0LnNlbmRUcmFuc2FjdGlvbih7XG4gICAgICAgICAgICAgICAgdG86IGZhY3RvcnlBZGRyZXNzLFxuICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IHdhbGxldC53YWl0Rm9yVHJhbnNhY3Rpb25SZWNlaXB0KHR4SGFzaCk7XG4gICAgICAgICAgICByZXR1cm4gYENyZWF0ZWQgV29XIEVSQzIwIG1lbWVjb2luICR7YXJncy5uYW1lfSB3aXRoIHN5bWJvbCAke2FyZ3Muc3ltYm9sfSBvbiBuZXR3b3JrICR7d2FsbGV0LmdldE5ldHdvcmsoKS5uZXR3b3JrSWR9LlxcblRyYW5zYWN0aW9uIGhhc2g6ICR7dHhIYXNofWA7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gYEVycm9yIGNyZWF0aW5nIFpvcmEgV293IEVSQzIwIG1lbWVjb2luOiAke2Vycm9yfWA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VsbHMgV09XIHRva2VucyBmb3IgRVRILlxuICAgICAqXG4gICAgICogQHBhcmFtIHdhbGxldFByb3ZpZGVyIC0gVGhlIHdhbGxldCB0byBzZWxsIHRoZSB0b2tlbnMgZnJvbS5cbiAgICAgKiBAcGFyYW0gYXJncyAtIFRoZSBpbnB1dCBhcmd1bWVudHMgZm9yIHRoZSBhY3Rpb24uXG4gICAgICogQHJldHVybnMgQSBtZXNzYWdlIGNvbmZpcm1pbmcgdGhlIHNhbGUgd2l0aCB0aGUgdHJhbnNhY3Rpb24gaGFzaC5cbiAgICAgKi9cbiAgICBhc3luYyBzZWxsVG9rZW4od2FsbGV0UHJvdmlkZXIsIGFyZ3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGV0aFF1b3RlID0gYXdhaXQgKDAsIHV0aWxzXzEuZ2V0U2VsbFF1b3RlKSh3YWxsZXRQcm92aWRlciwgYXJncy5jb250cmFjdEFkZHJlc3MsIGFyZ3MuYW1vdW50VG9rZW5zSW5XZWkpO1xuICAgICAgICAgICAgY29uc3QgaGFzR3JhZHVhdGVkID0gYXdhaXQgKDAsIHV0aWxzXzIuZ2V0SGFzR3JhZHVhdGVkKSh3YWxsZXRQcm92aWRlciwgYXJncy5jb250cmFjdEFkZHJlc3MpO1xuICAgICAgICAgICAgLy8gTXVsdGlwbHkgYnkgOTgvMTAwIGFuZCBmbG9vciB0byBnZXQgOTglIG9mIHF1b3RlIGFzIG1pbmltdW1cbiAgICAgICAgICAgIGNvbnN0IG1pbkV0aCA9IEJpZ0ludChNYXRoLmZsb29yKE51bWJlcihldGhRdW90ZSkgKiA5OCkpIC8gQmlnSW50KDEwMCk7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gKDAsIHZpZW1fMS5lbmNvZGVGdW5jdGlvbkRhdGEpKHtcbiAgICAgICAgICAgICAgICBhYmk6IGNvbnN0YW50c18xLldPV19BQkksXG4gICAgICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiBcInNlbGxcIixcbiAgICAgICAgICAgICAgICBhcmdzOiBbXG4gICAgICAgICAgICAgICAgICAgIEJpZ0ludChhcmdzLmFtb3VudFRva2Vuc0luV2VpKSxcbiAgICAgICAgICAgICAgICAgICAgd2FsbGV0UHJvdmlkZXIuZ2V0QWRkcmVzcygpLFxuICAgICAgICAgICAgICAgICAgICBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiLFxuICAgICAgICAgICAgICAgICAgICBcIlwiLFxuICAgICAgICAgICAgICAgICAgICBoYXNHcmFkdWF0ZWQgPyAxbiA6IDBuLFxuICAgICAgICAgICAgICAgICAgICBtaW5FdGgsXG4gICAgICAgICAgICAgICAgICAgIDBuLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHR4SGFzaCA9IGF3YWl0IHdhbGxldFByb3ZpZGVyLnNlbmRUcmFuc2FjdGlvbih7XG4gICAgICAgICAgICAgICAgdG86IGFyZ3MuY29udHJhY3RBZGRyZXNzLFxuICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IHdhbGxldFByb3ZpZGVyLndhaXRGb3JUcmFuc2FjdGlvblJlY2VpcHQodHhIYXNoKTtcbiAgICAgICAgICAgIHJldHVybiBgU29sZCBXb1cgRVJDMjAgbWVtZWNvaW4gd2l0aCB0cmFuc2FjdGlvbiBoYXNoOiAke3R4SGFzaH1gO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGBFcnJvciBzZWxsaW5nIFpvcmEgV293IEVSQzIwIG1lbWVjb2luOiAke2Vycm9yfWA7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLldvd0FjdGlvblByb3ZpZGVyID0gV293QWN0aW9uUHJvdmlkZXI7XG5fX2RlY29yYXRlKFtcbiAgICAoMCwgYWN0aW9uRGVjb3JhdG9yXzEuQ3JlYXRlQWN0aW9uKSh7XG4gICAgICAgIG5hbWU6IFwiYnV5X3Rva2VuXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgXG5UaGlzIHRvb2wgY2FuIG9ubHkgYmUgdXNlZCB0byBidXkgYSBab3JhIFdvdyBFUkMyMCBtZW1lY29pbiAoYWxzbyBjYW4gYmUgcmVmZXJyZWQgdG8gYXMgYSBib25kaW5nIGN1cnZlIHRva2VuKSB3aXRoIEVUSC5cbkRvIG5vdCB1c2UgdGhpcyB0b29sIGZvciBhbnkgb3RoZXIgcHVycG9zZSwgb3IgdHJhZGluZyBvdGhlciBhc3NldHMuXG5cbklucHV0czpcbi0gV09XIHRva2VuIGNvbnRyYWN0IGFkZHJlc3Ncbi0gQWRkcmVzcyB0byByZWNlaXZlIHRoZSB0b2tlbnMgIFxuLSBBbW91bnQgb2YgRVRIIHRvIHNwZW5kIChpbiB3ZWkpXG5cbkltcG9ydGFudCBub3Rlczpcbi0gVGhlIGFtb3VudCBpcyBhIHN0cmluZyBhbmQgY2Fubm90IGhhdmUgYW55IGRlY2ltYWwgcG9pbnRzLCBzaW5jZSB0aGUgdW5pdCBvZiBtZWFzdXJlbWVudCBpcyB3ZWkuXG4tIE1ha2Ugc3VyZSB0byB1c2UgdGhlIGV4YWN0IGFtb3VudCBwcm92aWRlZCwgYW5kIGlmIHRoZXJlJ3MgYW55IGRvdWJ0LCBjaGVjayBieSBnZXR0aW5nIG1vcmUgaW5mb3JtYXRpb24gYmVmb3JlIGNvbnRpbnVpbmcgd2l0aCB0aGUgYWN0aW9uLiBcbi0gMSB3ZWkgPSAwLjAwMDAwMDAwMDAwMDAwMDAwMSBFVEhcbi0gTWluaW11bSBwdXJjaGFzZSBhbW91bnQgaXMgMTAwMDAwMDAwMDAwMDAwIHdlaSAoMC4wMDAwMDAxIEVUSClcbi0gT25seSBzdXBwb3J0ZWQgb24gdGhlIGZvbGxvd2luZyBuZXR3b3JrczpcbiAgLSBCYXNlIFNlcG9saWEgKGllLCAnYmFzZS1zZXBvbGlhJylcbiAgLSBCYXNlIE1haW5uZXQgKGllLCAnYmFzZScsICdiYXNlLW1haW5uZXQnKWAsXG4gICAgICAgIHNjaGVtYTogc2NoZW1hc18xLldvd0J1eVRva2VuSW5wdXQsXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW3dhbGxldF9wcm92aWRlcnNfMS5Fdm1XYWxsZXRQcm92aWRlciwgdm9pZCAwXSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIFByb21pc2UpXG5dLCBXb3dBY3Rpb25Qcm92aWRlci5wcm90b3R5cGUsIFwiYnV5VG9rZW5cIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICAoMCwgYWN0aW9uRGVjb3JhdG9yXzEuQ3JlYXRlQWN0aW9uKSh7XG4gICAgICAgIG5hbWU6IFwiY3JlYXRlX3Rva2VuXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgXG5UaGlzIHRvb2wgY2FuIG9ubHkgYmUgdXNlZCB0byBjcmVhdGUgYSBab3JhIFdvdyBFUkMyMCBtZW1lY29pbiAoYWxzbyBjYW4gYmUgcmVmZXJyZWQgdG8gYXMgYSBib25kaW5nIGN1cnZlIHRva2VuKSB1c2luZyB0aGUgV29XIGZhY3RvcnkuXG5EbyBub3QgdXNlIHRoaXMgdG9vbCBmb3IgYW55IG90aGVyIHB1cnBvc2UsIG9yIGZvciBjcmVhdGluZyBvdGhlciB0eXBlcyBvZiB0b2tlbnMuXG5cbklucHV0czpcbi0gVG9rZW4gbmFtZSAoZS5nLiBXb3dDb2luKVxuLSBUb2tlbiBzeW1ib2wgKGUuZy4gV09XKSBcbi0gVG9rZW4gVVJJIChvcHRpb25hbCkgLSBDb250YWlucyBtZXRhZGF0YSBhYm91dCB0aGUgdG9rZW5cblxuSW1wb3J0YW50IG5vdGVzOlxuLSBVc2VzIGEgYm9uZGluZyBjdXJ2ZSAtIG5vIHVwZnJvbnQgbGlxdWlkaXR5IG5lZWRlZFxuLSBPbmx5IHN1cHBvcnRlZCBvbiB0aGUgZm9sbG93aW5nIG5ldHdvcmtzOlxuICAtIEJhc2UgU2Vwb2xpYSAoaWUsICdiYXNlLXNlcG9saWEnKVxuICAtIEJhc2UgTWFpbm5ldCAoaWUsICdiYXNlJywgJ2Jhc2UtbWFpbm5ldCcpYCxcbiAgICAgICAgc2NoZW1hOiBzY2hlbWFzXzEuV293Q3JlYXRlVG9rZW5JbnB1dCxcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbd2FsbGV0X3Byb3ZpZGVyc18xLkV2bVdhbGxldFByb3ZpZGVyLCB2b2lkIDBdKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgUHJvbWlzZSlcbl0sIFdvd0FjdGlvblByb3ZpZGVyLnByb3RvdHlwZSwgXCJjcmVhdGVUb2tlblwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgICgwLCBhY3Rpb25EZWNvcmF0b3JfMS5DcmVhdGVBY3Rpb24pKHtcbiAgICAgICAgbmFtZTogXCJzZWxsX3Rva2VuXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgXG5UaGlzIHRvb2wgY2FuIG9ubHkgYmUgdXNlZCB0byBzZWxsIGEgWm9yYSBXb3cgRVJDMjAgbWVtZWNvaW4gKGFsc28gY2FuIGJlIHJlZmVycmVkIHRvIGFzIGEgYm9uZGluZyBjdXJ2ZSB0b2tlbikgZm9yIEVUSC5cbkRvIG5vdCB1c2UgdGhpcyB0b29sIGZvciBhbnkgb3RoZXIgcHVycG9zZSwgb3IgdHJhZGluZyBvdGhlciBhc3NldHMuXG5cbklucHV0czpcbi0gV09XIHRva2VuIGNvbnRyYWN0IGFkZHJlc3Ncbi0gQW1vdW50IG9mIHRva2VucyB0byBzZWxsIChpbiB3ZWkpXG5cbkltcG9ydGFudCBub3Rlczpcbi0gVGhlIGFtb3VudCBpcyBhIHN0cmluZyBhbmQgY2Fubm90IGhhdmUgYW55IGRlY2ltYWwgcG9pbnRzLCBzaW5jZSB0aGUgdW5pdCBvZiBtZWFzdXJlbWVudCBpcyB3ZWkuXG4tIE1ha2Ugc3VyZSB0byB1c2UgdGhlIGV4YWN0IGFtb3VudCBwcm92aWRlZCwgYW5kIGlmIHRoZXJlJ3MgYW55IGRvdWJ0LCBjaGVjayBieSBnZXR0aW5nIG1vcmUgaW5mb3JtYXRpb24gYmVmb3JlIGNvbnRpbnVpbmcgd2l0aCB0aGUgYWN0aW9uLiBcbi0gMSB3ZWkgPSAwLjAwMDAwMDAwMDAwMDAwMDAwMSBFVEhcbi0gTWluaW11bSBwdXJjaGFzZSBhbW91bnQgaXMgMTAwMDAwMDAwMDAwMDAwIHdlaSAoMC4wMDAwMDAxIEVUSClcbi0gT25seSBzdXBwb3J0ZWQgb24gdGhlIGZvbGxvd2luZyBuZXR3b3JrczpcbiAgLSBCYXNlIFNlcG9saWEgKGllLCAnYmFzZS1zZXBvbGlhJylcbiAgLSBCYXNlIE1haW5uZXQgKGllLCAnYmFzZScsICdiYXNlLW1haW5uZXQnKWAsXG4gICAgICAgIHNjaGVtYTogc2NoZW1hc18xLldvd1NlbGxUb2tlbklucHV0LFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFt3YWxsZXRfcHJvdmlkZXJzXzEuRXZtV2FsbGV0UHJvdmlkZXIsIHZvaWQgMF0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCBQcm9taXNlKVxuXSwgV293QWN0aW9uUHJvdmlkZXIucHJvdG90eXBlLCBcInNlbGxUb2tlblwiLCBudWxsKTtcbmNvbnN0IHdvd0FjdGlvblByb3ZpZGVyID0gKCkgPT4gbmV3IFdvd0FjdGlvblByb3ZpZGVyKCk7XG5leHBvcnRzLndvd0FjdGlvblByb3ZpZGVyID0gd293QWN0aW9uUHJvdmlkZXI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/wow/wowActionProvider.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/agentkit.js":
/*!**********************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/agentkit.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AgentKit = void 0;\nconst wallet_providers_1 = __webpack_require__(/*! ./wallet-providers */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/wallet-providers/index.js\");\nconst action_providers_1 = __webpack_require__(/*! ./action-providers */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/index.js\");\n/**\n * AgentKit\n */\nclass AgentKit {\n    /**\n     * Initializes a new AgentKit instance\n     *\n     * @param config - Configuration options for the AgentKit\n     * @param config.walletProvider - The wallet provider to use\n     * @param config.actionProviders - The action providers to use\n     * @param config.actions - The actions to use\n     */\n    constructor(config) {\n        this.walletProvider = config.walletProvider;\n        this.actionProviders = config.actionProviders || [(0, action_providers_1.walletActionProvider)()];\n    }\n    /**\n     * Initializes a new AgentKit instance\n     *\n     * @param config - Configuration options for the AgentKit\n     * @param config.walletProvider - The wallet provider to use\n     * @param config.actionProviders - The action providers to use\n     * @param config.actions - The actions to use\n     *\n     * @returns A new AgentKit instance\n     */\n    static async from(config = { actionProviders: [(0, action_providers_1.walletActionProvider)()] }) {\n        let walletProvider = config.walletProvider;\n        if (!config.walletProvider) {\n            if (!config.cdpApiKeyName || !config.cdpApiKeyPrivateKey) {\n                throw new Error(\"cdpApiKeyName and cdpApiKeyPrivateKey are required if not providing a walletProvider\");\n            }\n            walletProvider = await wallet_providers_1.CdpWalletProvider.configureWithWallet({\n                apiKeyName: config.cdpApiKeyName,\n                apiKeyPrivateKey: config.cdpApiKeyPrivateKey,\n            });\n        }\n        return new AgentKit({ ...config, walletProvider: walletProvider });\n    }\n    /**\n     * Returns the actions available to the AgentKit.\n     *\n     * @returns An array of actions\n     */\n    getActions() {\n        const actions = [];\n        const unsupported = [];\n        for (const actionProvider of this.actionProviders) {\n            if (actionProvider.supportsNetwork(this.walletProvider.getNetwork())) {\n                actions.push(...actionProvider.getActions(this.walletProvider));\n            }\n            else {\n                unsupported.push(actionProvider.name);\n            }\n        }\n        if (unsupported.length > 0) {\n            console.log(`Warning: The following action providers are not supported on the current network and will be unavailable: ${unsupported.join(\", \")}`);\n            console.log(\"Current network:\", this.walletProvider.getNetwork());\n        }\n        return actions;\n    }\n}\nexports.AgentKit = AgentKit;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYWdlbnRraXQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0JBQWdCO0FBQ2hCLDJCQUEyQixtQkFBTyxDQUFDLGtHQUFvQjtBQUN2RCwyQkFBMkIsbUJBQU8sQ0FBQyxrR0FBb0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxtRUFBbUU7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLDhCQUE4QiwyQ0FBMkM7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUlBQXFJLHVCQUF1QjtBQUM1SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3Vydml2YWwtZnVuLy4vbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9hZ2VudGtpdC9kaXN0L2FnZW50a2l0LmpzP2QzMjEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFnZW50S2l0ID0gdm9pZCAwO1xuY29uc3Qgd2FsbGV0X3Byb3ZpZGVyc18xID0gcmVxdWlyZShcIi4vd2FsbGV0LXByb3ZpZGVyc1wiKTtcbmNvbnN0IGFjdGlvbl9wcm92aWRlcnNfMSA9IHJlcXVpcmUoXCIuL2FjdGlvbi1wcm92aWRlcnNcIik7XG4vKipcbiAqIEFnZW50S2l0XG4gKi9cbmNsYXNzIEFnZW50S2l0IHtcbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhIG5ldyBBZ2VudEtpdCBpbnN0YW5jZVxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbmZpZyAtIENvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIEFnZW50S2l0XG4gICAgICogQHBhcmFtIGNvbmZpZy53YWxsZXRQcm92aWRlciAtIFRoZSB3YWxsZXQgcHJvdmlkZXIgdG8gdXNlXG4gICAgICogQHBhcmFtIGNvbmZpZy5hY3Rpb25Qcm92aWRlcnMgLSBUaGUgYWN0aW9uIHByb3ZpZGVycyB0byB1c2VcbiAgICAgKiBAcGFyYW0gY29uZmlnLmFjdGlvbnMgLSBUaGUgYWN0aW9ucyB0byB1c2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgdGhpcy53YWxsZXRQcm92aWRlciA9IGNvbmZpZy53YWxsZXRQcm92aWRlcjtcbiAgICAgICAgdGhpcy5hY3Rpb25Qcm92aWRlcnMgPSBjb25maWcuYWN0aW9uUHJvdmlkZXJzIHx8IFsoMCwgYWN0aW9uX3Byb3ZpZGVyc18xLndhbGxldEFjdGlvblByb3ZpZGVyKSgpXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYSBuZXcgQWdlbnRLaXQgaW5zdGFuY2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb25maWcgLSBDb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBBZ2VudEtpdFxuICAgICAqIEBwYXJhbSBjb25maWcud2FsbGV0UHJvdmlkZXIgLSBUaGUgd2FsbGV0IHByb3ZpZGVyIHRvIHVzZVxuICAgICAqIEBwYXJhbSBjb25maWcuYWN0aW9uUHJvdmlkZXJzIC0gVGhlIGFjdGlvbiBwcm92aWRlcnMgdG8gdXNlXG4gICAgICogQHBhcmFtIGNvbmZpZy5hY3Rpb25zIC0gVGhlIGFjdGlvbnMgdG8gdXNlXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIG5ldyBBZ2VudEtpdCBpbnN0YW5jZVxuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyBmcm9tKGNvbmZpZyA9IHsgYWN0aW9uUHJvdmlkZXJzOiBbKDAsIGFjdGlvbl9wcm92aWRlcnNfMS53YWxsZXRBY3Rpb25Qcm92aWRlcikoKV0gfSkge1xuICAgICAgICBsZXQgd2FsbGV0UHJvdmlkZXIgPSBjb25maWcud2FsbGV0UHJvdmlkZXI7XG4gICAgICAgIGlmICghY29uZmlnLndhbGxldFByb3ZpZGVyKSB7XG4gICAgICAgICAgICBpZiAoIWNvbmZpZy5jZHBBcGlLZXlOYW1lIHx8ICFjb25maWcuY2RwQXBpS2V5UHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNkcEFwaUtleU5hbWUgYW5kIGNkcEFwaUtleVByaXZhdGVLZXkgYXJlIHJlcXVpcmVkIGlmIG5vdCBwcm92aWRpbmcgYSB3YWxsZXRQcm92aWRlclwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdhbGxldFByb3ZpZGVyID0gYXdhaXQgd2FsbGV0X3Byb3ZpZGVyc18xLkNkcFdhbGxldFByb3ZpZGVyLmNvbmZpZ3VyZVdpdGhXYWxsZXQoe1xuICAgICAgICAgICAgICAgIGFwaUtleU5hbWU6IGNvbmZpZy5jZHBBcGlLZXlOYW1lLFxuICAgICAgICAgICAgICAgIGFwaUtleVByaXZhdGVLZXk6IGNvbmZpZy5jZHBBcGlLZXlQcml2YXRlS2V5LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBBZ2VudEtpdCh7IC4uLmNvbmZpZywgd2FsbGV0UHJvdmlkZXI6IHdhbGxldFByb3ZpZGVyIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBhY3Rpb25zIGF2YWlsYWJsZSB0byB0aGUgQWdlbnRLaXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBbiBhcnJheSBvZiBhY3Rpb25zXG4gICAgICovXG4gICAgZ2V0QWN0aW9ucygpIHtcbiAgICAgICAgY29uc3QgYWN0aW9ucyA9IFtdO1xuICAgICAgICBjb25zdCB1bnN1cHBvcnRlZCA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGFjdGlvblByb3ZpZGVyIG9mIHRoaXMuYWN0aW9uUHJvdmlkZXJzKSB7XG4gICAgICAgICAgICBpZiAoYWN0aW9uUHJvdmlkZXIuc3VwcG9ydHNOZXR3b3JrKHRoaXMud2FsbGV0UHJvdmlkZXIuZ2V0TmV0d29yaygpKSkge1xuICAgICAgICAgICAgICAgIGFjdGlvbnMucHVzaCguLi5hY3Rpb25Qcm92aWRlci5nZXRBY3Rpb25zKHRoaXMud2FsbGV0UHJvdmlkZXIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHVuc3VwcG9ydGVkLnB1c2goYWN0aW9uUHJvdmlkZXIubmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVuc3VwcG9ydGVkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBXYXJuaW5nOiBUaGUgZm9sbG93aW5nIGFjdGlvbiBwcm92aWRlcnMgYXJlIG5vdCBzdXBwb3J0ZWQgb24gdGhlIGN1cnJlbnQgbmV0d29yayBhbmQgd2lsbCBiZSB1bmF2YWlsYWJsZTogJHt1bnN1cHBvcnRlZC5qb2luKFwiLCBcIil9YCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkN1cnJlbnQgbmV0d29yazpcIiwgdGhpcy53YWxsZXRQcm92aWRlci5nZXROZXR3b3JrKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY3Rpb25zO1xuICAgIH1cbn1cbmV4cG9ydHMuQWdlbnRLaXQgPSBBZ2VudEtpdDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/agentkit.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/analytics/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/analytics/index.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./sendAnalyticsEvent */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/analytics/sendAnalyticsEvent.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYW5hbHl0aWNzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWEsbUJBQU8sQ0FBQywwR0FBc0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXJ2aXZhbC1mdW4vLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYW5hbHl0aWNzL2luZGV4LmpzP2RiOWYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9zZW5kQW5hbHl0aWNzRXZlbnRcIiksIGV4cG9ydHMpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/analytics/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/analytics/sendAnalyticsEvent.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/analytics/sendAnalyticsEvent.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.sendAnalyticsEvent = sendAnalyticsEvent;\nconst md5_1 = __importDefault(__webpack_require__(/*! md5 */ \"(rsc)/./node_modules/md5/md5.js\"));\n/**\n * Sends an analytics event to the default endpoint\n *\n * @param event - The event data containing required action, component and name fields\n * @returns Promise that resolves when the event is sent\n */\nasync function sendAnalyticsEvent(event) {\n    const timestamp = event.timestamp || Date.now();\n    // Prepare the event with required fields\n    const enhancedEvent = {\n        event_type: event.name,\n        platform: \"server\",\n        event_properties: {\n            component_type: event.component,\n            platform: \"server\",\n            project_name: \"agentkit\",\n            time_start: timestamp,\n            agentkit_language: \"typescript\",\n            ...event,\n        },\n    };\n    const events = [enhancedEvent];\n    const stringifiedEventData = JSON.stringify(events);\n    const uploadTime = timestamp.toString();\n    // Calculate checksum inline\n    const checksum = (0, md5_1.default)(stringifiedEventData + uploadTime);\n    const analyticsServiceData = {\n        e: stringifiedEventData,\n        checksum,\n    };\n    const apiEndpoint = \"https://cca-lite.coinbase.com\";\n    const eventPath = \"/amp\";\n    const eventEndPoint = `${apiEndpoint}${eventPath}`;\n    const response = await fetch(eventEndPoint, {\n        method: \"POST\",\n        mode: \"no-cors\",\n        headers: {\n            \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify(analyticsServiceData),\n    });\n    if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvYW5hbHl0aWNzL3NlbmRBbmFseXRpY3NFdmVudC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDBCQUEwQjtBQUMxQiw4QkFBOEIsbUJBQU8sQ0FBQyw0Q0FBSztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsWUFBWSxFQUFFLFVBQVU7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBLCtDQUErQyxnQkFBZ0I7QUFDL0Q7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cnZpdmFsLWZ1bi8uL25vZGVfbW9kdWxlcy9AY29pbmJhc2UvYWdlbnRraXQvZGlzdC9hbmFseXRpY3Mvc2VuZEFuYWx5dGljc0V2ZW50LmpzP2RmMjciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNlbmRBbmFseXRpY3NFdmVudCA9IHNlbmRBbmFseXRpY3NFdmVudDtcbmNvbnN0IG1kNV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJtZDVcIikpO1xuLyoqXG4gKiBTZW5kcyBhbiBhbmFseXRpY3MgZXZlbnQgdG8gdGhlIGRlZmF1bHQgZW5kcG9pbnRcbiAqXG4gKiBAcGFyYW0gZXZlbnQgLSBUaGUgZXZlbnQgZGF0YSBjb250YWluaW5nIHJlcXVpcmVkIGFjdGlvbiwgY29tcG9uZW50IGFuZCBuYW1lIGZpZWxkc1xuICogQHJldHVybnMgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIGV2ZW50IGlzIHNlbnRcbiAqL1xuYXN5bmMgZnVuY3Rpb24gc2VuZEFuYWx5dGljc0V2ZW50KGV2ZW50KSB7XG4gICAgY29uc3QgdGltZXN0YW1wID0gZXZlbnQudGltZXN0YW1wIHx8IERhdGUubm93KCk7XG4gICAgLy8gUHJlcGFyZSB0aGUgZXZlbnQgd2l0aCByZXF1aXJlZCBmaWVsZHNcbiAgICBjb25zdCBlbmhhbmNlZEV2ZW50ID0ge1xuICAgICAgICBldmVudF90eXBlOiBldmVudC5uYW1lLFxuICAgICAgICBwbGF0Zm9ybTogXCJzZXJ2ZXJcIixcbiAgICAgICAgZXZlbnRfcHJvcGVydGllczoge1xuICAgICAgICAgICAgY29tcG9uZW50X3R5cGU6IGV2ZW50LmNvbXBvbmVudCxcbiAgICAgICAgICAgIHBsYXRmb3JtOiBcInNlcnZlclwiLFxuICAgICAgICAgICAgcHJvamVjdF9uYW1lOiBcImFnZW50a2l0XCIsXG4gICAgICAgICAgICB0aW1lX3N0YXJ0OiB0aW1lc3RhbXAsXG4gICAgICAgICAgICBhZ2VudGtpdF9sYW5ndWFnZTogXCJ0eXBlc2NyaXB0XCIsXG4gICAgICAgICAgICAuLi5ldmVudCxcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIGNvbnN0IGV2ZW50cyA9IFtlbmhhbmNlZEV2ZW50XTtcbiAgICBjb25zdCBzdHJpbmdpZmllZEV2ZW50RGF0YSA9IEpTT04uc3RyaW5naWZ5KGV2ZW50cyk7XG4gICAgY29uc3QgdXBsb2FkVGltZSA9IHRpbWVzdGFtcC50b1N0cmluZygpO1xuICAgIC8vIENhbGN1bGF0ZSBjaGVja3N1bSBpbmxpbmVcbiAgICBjb25zdCBjaGVja3N1bSA9ICgwLCBtZDVfMS5kZWZhdWx0KShzdHJpbmdpZmllZEV2ZW50RGF0YSArIHVwbG9hZFRpbWUpO1xuICAgIGNvbnN0IGFuYWx5dGljc1NlcnZpY2VEYXRhID0ge1xuICAgICAgICBlOiBzdHJpbmdpZmllZEV2ZW50RGF0YSxcbiAgICAgICAgY2hlY2tzdW0sXG4gICAgfTtcbiAgICBjb25zdCBhcGlFbmRwb2ludCA9IFwiaHR0cHM6Ly9jY2EtbGl0ZS5jb2luYmFzZS5jb21cIjtcbiAgICBjb25zdCBldmVudFBhdGggPSBcIi9hbXBcIjtcbiAgICBjb25zdCBldmVudEVuZFBvaW50ID0gYCR7YXBpRW5kcG9pbnR9JHtldmVudFBhdGh9YDtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGV2ZW50RW5kUG9pbnQsIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgbW9kZTogXCJuby1jb3JzXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShhbmFseXRpY3NTZXJ2aWNlRGF0YSksXG4gICAgfSk7XG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEhUVFAgZXJyb3IhIHN0YXR1czogJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/analytics/sendAnalyticsEvent.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/index.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./agentkit */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/agentkit.js\"), exports);\n__exportStar(__webpack_require__(/*! ./wallet-providers */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/wallet-providers/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./action-providers */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/action-providers/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./network */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/network/index.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYSxtQkFBTyxDQUFDLDRFQUFZO0FBQ2pDLGFBQWEsbUJBQU8sQ0FBQyxrR0FBb0I7QUFDekMsYUFBYSxtQkFBTyxDQUFDLGtHQUFvQjtBQUN6QyxhQUFhLG1CQUFPLENBQUMsZ0ZBQVciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXJ2aXZhbC1mdW4vLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvaW5kZXguanM/MWIxZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2FnZW50a2l0XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi93YWxsZXQtcHJvdmlkZXJzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9hY3Rpb24tcHJvdmlkZXJzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9uZXR3b3JrXCIpLCBleHBvcnRzKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/network/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/network/index.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./network */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/network/network.js\"), exports);\n__exportStar(__webpack_require__(/*! ./svm */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/network/svm.js\"), exports);\n__exportStar(__webpack_require__(/*! ./types */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/network/types.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvbmV0d29yay9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxhQUFhLG1CQUFPLENBQUMsa0ZBQVc7QUFDaEMsYUFBYSxtQkFBTyxDQUFDLDBFQUFPO0FBQzVCLGFBQWEsbUJBQU8sQ0FBQyw4RUFBUyIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cnZpdmFsLWZ1bi8uL25vZGVfbW9kdWxlcy9AY29pbmJhc2UvYWdlbnRraXQvZGlzdC9uZXR3b3JrL2luZGV4LmpzPzIyOTYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9uZXR3b3JrXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9zdm1cIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3R5cGVzXCIpLCBleHBvcnRzKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/network/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/network/network.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/network/network.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getChain = exports.NETWORK_ID_TO_VIEM_CHAIN = exports.NETWORK_ID_TO_CHAIN_ID = exports.CHAIN_ID_TO_NETWORK_ID = void 0;\nconst chains_1 = __webpack_require__(/*! viem/chains */ \"(rsc)/./node_modules/viem/_cjs/chains/index.js\");\nconst chains = __importStar(__webpack_require__(/*! viem/chains */ \"(rsc)/./node_modules/viem/_cjs/chains/index.js\"));\n/**\n * Maps EVM chain IDs to Coinbase network IDs\n */\nexports.CHAIN_ID_TO_NETWORK_ID = {\n    1: \"ethereum-mainnet\",\n    11155111: \"ethereum-sepolia\",\n    137: \"polygon-mainnet\",\n    80001: \"polygon-mumbai\",\n    8453: \"base-mainnet\",\n    84532: \"base-sepolia\",\n    42161: \"arbitrum-mainnet\",\n    421614: \"arbitrum-sepolia\",\n    10: \"optimism-mainnet\",\n    11155420: \"optimism-sepolia\",\n};\n/**\n * Maps Coinbase network IDs to EVM chain IDs\n */\nexports.NETWORK_ID_TO_CHAIN_ID = Object.entries(exports.CHAIN_ID_TO_NETWORK_ID).reduce((acc, [chainId, networkId]) => {\n    acc[networkId] = String(chainId);\n    return acc;\n}, {});\n/**\n * Maps Coinbase network IDs to Viem chain objects\n */\nexports.NETWORK_ID_TO_VIEM_CHAIN = {\n    \"ethereum-mainnet\": chains_1.mainnet,\n    \"ethereum-sepolia\": chains_1.sepolia,\n    \"polygon-mainnet\": chains_1.polygon,\n    \"polygon-mumbai\": chains_1.polygonMumbai,\n    \"base-mainnet\": chains_1.base,\n    \"base-sepolia\": chains_1.baseSepolia,\n    \"arbitrum-mainnet\": chains_1.arbitrum,\n    \"arbitrum-sepolia\": chains_1.arbitrumSepolia,\n    \"optimism-mainnet\": chains_1.optimism,\n    \"optimism-sepolia\": chains_1.optimismSepolia,\n};\n/**\n * Get a chain from the viem chains object\n *\n * @param id - The chain ID\n * @returns The chain\n */\nconst getChain = (id) => {\n    const chainList = Object.values(chains);\n    return chainList.find(chain => chain.id === parseInt(id));\n};\nexports.getChain = getChain;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvbmV0d29yay9uZXR3b3JrLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsY0FBYztBQUN6RTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQixHQUFHLGdDQUFnQyxHQUFHLDhCQUE4QixHQUFHLDhCQUE4QjtBQUNySCxpQkFBaUIsbUJBQU8sQ0FBQyxtRUFBYTtBQUN0Qyw0QkFBNEIsbUJBQU8sQ0FBQyxtRUFBYTtBQUNqRDtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0EsQ0FBQyxJQUFJO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cnZpdmFsLWZ1bi8uL25vZGVfbW9kdWxlcy9AY29pbmJhc2UvYWdlbnRraXQvZGlzdC9uZXR3b3JrL25ldHdvcmsuanM/NmMxOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3duS2V5cyA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgb3duS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICB2YXIgYXIgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGsgaW4gbykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBrKSkgYXJbYXIubGVuZ3RoXSA9IGs7XG4gICAgICAgICAgICByZXR1cm4gYXI7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBvd25LZXlzKG8pO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtb2QpIHtcbiAgICAgICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgPSBvd25LZXlzKG1vZCksIGkgPSAwOyBpIDwgay5sZW5ndGg7IGkrKykgaWYgKGtbaV0gIT09IFwiZGVmYXVsdFwiKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGtbaV0pO1xuICAgICAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRDaGFpbiA9IGV4cG9ydHMuTkVUV09SS19JRF9UT19WSUVNX0NIQUlOID0gZXhwb3J0cy5ORVRXT1JLX0lEX1RPX0NIQUlOX0lEID0gZXhwb3J0cy5DSEFJTl9JRF9UT19ORVRXT1JLX0lEID0gdm9pZCAwO1xuY29uc3QgY2hhaW5zXzEgPSByZXF1aXJlKFwidmllbS9jaGFpbnNcIik7XG5jb25zdCBjaGFpbnMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcInZpZW0vY2hhaW5zXCIpKTtcbi8qKlxuICogTWFwcyBFVk0gY2hhaW4gSURzIHRvIENvaW5iYXNlIG5ldHdvcmsgSURzXG4gKi9cbmV4cG9ydHMuQ0hBSU5fSURfVE9fTkVUV09SS19JRCA9IHtcbiAgICAxOiBcImV0aGVyZXVtLW1haW5uZXRcIixcbiAgICAxMTE1NTExMTogXCJldGhlcmV1bS1zZXBvbGlhXCIsXG4gICAgMTM3OiBcInBvbHlnb24tbWFpbm5ldFwiLFxuICAgIDgwMDAxOiBcInBvbHlnb24tbXVtYmFpXCIsXG4gICAgODQ1MzogXCJiYXNlLW1haW5uZXRcIixcbiAgICA4NDUzMjogXCJiYXNlLXNlcG9saWFcIixcbiAgICA0MjE2MTogXCJhcmJpdHJ1bS1tYWlubmV0XCIsXG4gICAgNDIxNjE0OiBcImFyYml0cnVtLXNlcG9saWFcIixcbiAgICAxMDogXCJvcHRpbWlzbS1tYWlubmV0XCIsXG4gICAgMTExNTU0MjA6IFwib3B0aW1pc20tc2Vwb2xpYVwiLFxufTtcbi8qKlxuICogTWFwcyBDb2luYmFzZSBuZXR3b3JrIElEcyB0byBFVk0gY2hhaW4gSURzXG4gKi9cbmV4cG9ydHMuTkVUV09SS19JRF9UT19DSEFJTl9JRCA9IE9iamVjdC5lbnRyaWVzKGV4cG9ydHMuQ0hBSU5fSURfVE9fTkVUV09SS19JRCkucmVkdWNlKChhY2MsIFtjaGFpbklkLCBuZXR3b3JrSWRdKSA9PiB7XG4gICAgYWNjW25ldHdvcmtJZF0gPSBTdHJpbmcoY2hhaW5JZCk7XG4gICAgcmV0dXJuIGFjYztcbn0sIHt9KTtcbi8qKlxuICogTWFwcyBDb2luYmFzZSBuZXR3b3JrIElEcyB0byBWaWVtIGNoYWluIG9iamVjdHNcbiAqL1xuZXhwb3J0cy5ORVRXT1JLX0lEX1RPX1ZJRU1fQ0hBSU4gPSB7XG4gICAgXCJldGhlcmV1bS1tYWlubmV0XCI6IGNoYWluc18xLm1haW5uZXQsXG4gICAgXCJldGhlcmV1bS1zZXBvbGlhXCI6IGNoYWluc18xLnNlcG9saWEsXG4gICAgXCJwb2x5Z29uLW1haW5uZXRcIjogY2hhaW5zXzEucG9seWdvbixcbiAgICBcInBvbHlnb24tbXVtYmFpXCI6IGNoYWluc18xLnBvbHlnb25NdW1iYWksXG4gICAgXCJiYXNlLW1haW5uZXRcIjogY2hhaW5zXzEuYmFzZSxcbiAgICBcImJhc2Utc2Vwb2xpYVwiOiBjaGFpbnNfMS5iYXNlU2Vwb2xpYSxcbiAgICBcImFyYml0cnVtLW1haW5uZXRcIjogY2hhaW5zXzEuYXJiaXRydW0sXG4gICAgXCJhcmJpdHJ1bS1zZXBvbGlhXCI6IGNoYWluc18xLmFyYml0cnVtU2Vwb2xpYSxcbiAgICBcIm9wdGltaXNtLW1haW5uZXRcIjogY2hhaW5zXzEub3B0aW1pc20sXG4gICAgXCJvcHRpbWlzbS1zZXBvbGlhXCI6IGNoYWluc18xLm9wdGltaXNtU2Vwb2xpYSxcbn07XG4vKipcbiAqIEdldCBhIGNoYWluIGZyb20gdGhlIHZpZW0gY2hhaW5zIG9iamVjdFxuICpcbiAqIEBwYXJhbSBpZCAtIFRoZSBjaGFpbiBJRFxuICogQHJldHVybnMgVGhlIGNoYWluXG4gKi9cbmNvbnN0IGdldENoYWluID0gKGlkKSA9PiB7XG4gICAgY29uc3QgY2hhaW5MaXN0ID0gT2JqZWN0LnZhbHVlcyhjaGFpbnMpO1xuICAgIHJldHVybiBjaGFpbkxpc3QuZmluZChjaGFpbiA9PiBjaGFpbi5pZCA9PT0gcGFyc2VJbnQoaWQpKTtcbn07XG5leHBvcnRzLmdldENoYWluID0gZ2V0Q2hhaW47XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/network/network.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/network/svm.js":
/*!*************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/network/svm.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SOLANA_CLUSTER_ID_BY_NETWORK_ID = exports.SOLANA_NETWORKS = exports.SOLANA_DEVNET_NETWORK = exports.SOLANA_TESTNET_NETWORK = exports.SOLANA_MAINNET_NETWORK = exports.SOLANA_DEVNET_GENESIS_BLOCK_HASH = exports.SOLANA_TESTNET_GENESIS_BLOCK_HASH = exports.SOLANA_MAINNET_GENESIS_BLOCK_HASH = exports.SOLANA_PROTOCOL_FAMILY = exports.SOLANA_DEVNET_NETWORK_ID = exports.SOLANA_TESTNET_NETWORK_ID = exports.SOLANA_MAINNET_NETWORK_ID = void 0;\n// CDP Network IDs\nexports.SOLANA_MAINNET_NETWORK_ID = \"solana-mainnet\";\nexports.SOLANA_TESTNET_NETWORK_ID = \"solana-testnet\";\nexports.SOLANA_DEVNET_NETWORK_ID = \"solana-devnet\";\n// AgentKit Protocol Family\nexports.SOLANA_PROTOCOL_FAMILY = \"svm\";\n// Chain IDs - Genesis Block Hashes\nexports.SOLANA_MAINNET_GENESIS_BLOCK_HASH = \"5eykt4UsFv8P8NJdTREpY1vzqKqZKvdpKuc147dw2N9d\";\nexports.SOLANA_TESTNET_GENESIS_BLOCK_HASH = \"4uhcVJyU9pJkvQyS88uRDiswHXSCkY3zQawwpjk2NsNY\";\nexports.SOLANA_DEVNET_GENESIS_BLOCK_HASH = \"EtWTRABZaYq6iMfeYKouRu166VU2xqa1wcaWoxPkrZBG\";\nexports.SOLANA_MAINNET_NETWORK = {\n    protocolFamily: exports.SOLANA_PROTOCOL_FAMILY,\n    chainId: exports.SOLANA_MAINNET_GENESIS_BLOCK_HASH,\n    networkId: exports.SOLANA_MAINNET_NETWORK_ID,\n};\nexports.SOLANA_TESTNET_NETWORK = {\n    protocolFamily: exports.SOLANA_PROTOCOL_FAMILY,\n    chainId: exports.SOLANA_TESTNET_GENESIS_BLOCK_HASH,\n    networkId: exports.SOLANA_TESTNET_NETWORK_ID,\n};\nexports.SOLANA_DEVNET_NETWORK = {\n    protocolFamily: exports.SOLANA_PROTOCOL_FAMILY,\n    chainId: exports.SOLANA_DEVNET_GENESIS_BLOCK_HASH,\n    networkId: exports.SOLANA_DEVNET_NETWORK_ID,\n};\nexports.SOLANA_NETWORKS = {\n    [exports.SOLANA_MAINNET_GENESIS_BLOCK_HASH]: exports.SOLANA_MAINNET_NETWORK,\n    [exports.SOLANA_TESTNET_GENESIS_BLOCK_HASH]: exports.SOLANA_TESTNET_NETWORK,\n    [exports.SOLANA_DEVNET_GENESIS_BLOCK_HASH]: exports.SOLANA_DEVNET_NETWORK,\n};\nexports.SOLANA_CLUSTER_ID_BY_NETWORK_ID = {\n    [exports.SOLANA_MAINNET_NETWORK_ID]: \"mainnet-beta\",\n    [exports.SOLANA_TESTNET_NETWORK_ID]: \"testnet\",\n    [exports.SOLANA_DEVNET_NETWORK_ID]: \"devnet\",\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvbmV0d29yay9zdm0uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsdUNBQXVDLEdBQUcsdUJBQXVCLEdBQUcsNkJBQTZCLEdBQUcsOEJBQThCLEdBQUcsOEJBQThCLEdBQUcsd0NBQXdDLEdBQUcseUNBQXlDLEdBQUcseUNBQXlDLEdBQUcsOEJBQThCLEdBQUcsZ0NBQWdDLEdBQUcsaUNBQWlDLEdBQUcsaUNBQWlDO0FBQ2xiO0FBQ0EsaUNBQWlDO0FBQ2pDLGlDQUFpQztBQUNqQyxnQ0FBZ0M7QUFDaEM7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSx5Q0FBeUM7QUFDekMseUNBQXlDO0FBQ3pDLHdDQUF3QztBQUN4Qyw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXJ2aXZhbC1mdW4vLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvbmV0d29yay9zdm0uanM/MTY2MCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU09MQU5BX0NMVVNURVJfSURfQllfTkVUV09SS19JRCA9IGV4cG9ydHMuU09MQU5BX05FVFdPUktTID0gZXhwb3J0cy5TT0xBTkFfREVWTkVUX05FVFdPUksgPSBleHBvcnRzLlNPTEFOQV9URVNUTkVUX05FVFdPUksgPSBleHBvcnRzLlNPTEFOQV9NQUlOTkVUX05FVFdPUksgPSBleHBvcnRzLlNPTEFOQV9ERVZORVRfR0VORVNJU19CTE9DS19IQVNIID0gZXhwb3J0cy5TT0xBTkFfVEVTVE5FVF9HRU5FU0lTX0JMT0NLX0hBU0ggPSBleHBvcnRzLlNPTEFOQV9NQUlOTkVUX0dFTkVTSVNfQkxPQ0tfSEFTSCA9IGV4cG9ydHMuU09MQU5BX1BST1RPQ09MX0ZBTUlMWSA9IGV4cG9ydHMuU09MQU5BX0RFVk5FVF9ORVRXT1JLX0lEID0gZXhwb3J0cy5TT0xBTkFfVEVTVE5FVF9ORVRXT1JLX0lEID0gZXhwb3J0cy5TT0xBTkFfTUFJTk5FVF9ORVRXT1JLX0lEID0gdm9pZCAwO1xuLy8gQ0RQIE5ldHdvcmsgSURzXG5leHBvcnRzLlNPTEFOQV9NQUlOTkVUX05FVFdPUktfSUQgPSBcInNvbGFuYS1tYWlubmV0XCI7XG5leHBvcnRzLlNPTEFOQV9URVNUTkVUX05FVFdPUktfSUQgPSBcInNvbGFuYS10ZXN0bmV0XCI7XG5leHBvcnRzLlNPTEFOQV9ERVZORVRfTkVUV09SS19JRCA9IFwic29sYW5hLWRldm5ldFwiO1xuLy8gQWdlbnRLaXQgUHJvdG9jb2wgRmFtaWx5XG5leHBvcnRzLlNPTEFOQV9QUk9UT0NPTF9GQU1JTFkgPSBcInN2bVwiO1xuLy8gQ2hhaW4gSURzIC0gR2VuZXNpcyBCbG9jayBIYXNoZXNcbmV4cG9ydHMuU09MQU5BX01BSU5ORVRfR0VORVNJU19CTE9DS19IQVNIID0gXCI1ZXlrdDRVc0Z2OFA4TkpkVFJFcFkxdnpxS3FaS3ZkcEt1YzE0N2R3Mk45ZFwiO1xuZXhwb3J0cy5TT0xBTkFfVEVTVE5FVF9HRU5FU0lTX0JMT0NLX0hBU0ggPSBcIjR1aGNWSnlVOXBKa3ZReVM4OHVSRGlzd0hYU0NrWTN6UWF3d3BqazJOc05ZXCI7XG5leHBvcnRzLlNPTEFOQV9ERVZORVRfR0VORVNJU19CTE9DS19IQVNIID0gXCJFdFdUUkFCWmFZcTZpTWZlWUtvdVJ1MTY2VlUyeHFhMXdjYVdveFBrclpCR1wiO1xuZXhwb3J0cy5TT0xBTkFfTUFJTk5FVF9ORVRXT1JLID0ge1xuICAgIHByb3RvY29sRmFtaWx5OiBleHBvcnRzLlNPTEFOQV9QUk9UT0NPTF9GQU1JTFksXG4gICAgY2hhaW5JZDogZXhwb3J0cy5TT0xBTkFfTUFJTk5FVF9HRU5FU0lTX0JMT0NLX0hBU0gsXG4gICAgbmV0d29ya0lkOiBleHBvcnRzLlNPTEFOQV9NQUlOTkVUX05FVFdPUktfSUQsXG59O1xuZXhwb3J0cy5TT0xBTkFfVEVTVE5FVF9ORVRXT1JLID0ge1xuICAgIHByb3RvY29sRmFtaWx5OiBleHBvcnRzLlNPTEFOQV9QUk9UT0NPTF9GQU1JTFksXG4gICAgY2hhaW5JZDogZXhwb3J0cy5TT0xBTkFfVEVTVE5FVF9HRU5FU0lTX0JMT0NLX0hBU0gsXG4gICAgbmV0d29ya0lkOiBleHBvcnRzLlNPTEFOQV9URVNUTkVUX05FVFdPUktfSUQsXG59O1xuZXhwb3J0cy5TT0xBTkFfREVWTkVUX05FVFdPUksgPSB7XG4gICAgcHJvdG9jb2xGYW1pbHk6IGV4cG9ydHMuU09MQU5BX1BST1RPQ09MX0ZBTUlMWSxcbiAgICBjaGFpbklkOiBleHBvcnRzLlNPTEFOQV9ERVZORVRfR0VORVNJU19CTE9DS19IQVNILFxuICAgIG5ldHdvcmtJZDogZXhwb3J0cy5TT0xBTkFfREVWTkVUX05FVFdPUktfSUQsXG59O1xuZXhwb3J0cy5TT0xBTkFfTkVUV09SS1MgPSB7XG4gICAgW2V4cG9ydHMuU09MQU5BX01BSU5ORVRfR0VORVNJU19CTE9DS19IQVNIXTogZXhwb3J0cy5TT0xBTkFfTUFJTk5FVF9ORVRXT1JLLFxuICAgIFtleHBvcnRzLlNPTEFOQV9URVNUTkVUX0dFTkVTSVNfQkxPQ0tfSEFTSF06IGV4cG9ydHMuU09MQU5BX1RFU1RORVRfTkVUV09SSyxcbiAgICBbZXhwb3J0cy5TT0xBTkFfREVWTkVUX0dFTkVTSVNfQkxPQ0tfSEFTSF06IGV4cG9ydHMuU09MQU5BX0RFVk5FVF9ORVRXT1JLLFxufTtcbmV4cG9ydHMuU09MQU5BX0NMVVNURVJfSURfQllfTkVUV09SS19JRCA9IHtcbiAgICBbZXhwb3J0cy5TT0xBTkFfTUFJTk5FVF9ORVRXT1JLX0lEXTogXCJtYWlubmV0LWJldGFcIixcbiAgICBbZXhwb3J0cy5TT0xBTkFfVEVTVE5FVF9ORVRXT1JLX0lEXTogXCJ0ZXN0bmV0XCIsXG4gICAgW2V4cG9ydHMuU09MQU5BX0RFVk5FVF9ORVRXT1JLX0lEXTogXCJkZXZuZXRcIixcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/network/svm.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/network/types.js":
/*!***************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/network/types.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvbmV0d29yay90eXBlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cnZpdmFsLWZ1bi8uL25vZGVfbW9kdWxlcy9AY29pbmJhc2UvYWdlbnRraXQvZGlzdC9uZXR3b3JrL3R5cGVzLmpzPzhlMTEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/network/types.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/utils.js":
/*!*******************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/utils.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.approve = approve;\nexports.applyGasMultiplier = applyGasMultiplier;\nconst viem_1 = __webpack_require__(/*! viem */ \"(rsc)/./node_modules/viem/_cjs/index.js\");\nconst ERC20_ABI = [\n    {\n        inputs: [\n            { name: \"spender\", type: \"address\" },\n            { name: \"amount\", type: \"uint256\" },\n        ],\n        name: \"approve\",\n        outputs: [{ name: \"\", type: \"bool\" }],\n        stateMutability: \"nonpayable\",\n        type: \"function\",\n    },\n];\n/**\n * Approves a spender to spend tokens on behalf of the owner\n *\n * @param wallet - The wallet provider\n * @param tokenAddress - The address of the token contract\n * @param spenderAddress - The address of the spender\n * @param amount - The amount to approve in atomic units (wei)\n * @returns A success message or error message\n */\nasync function approve(wallet, tokenAddress, spenderAddress, amount) {\n    try {\n        const data = (0, viem_1.encodeFunctionData)({\n            abi: ERC20_ABI,\n            functionName: \"approve\",\n            args: [spenderAddress, amount],\n        });\n        const txHash = await wallet.sendTransaction({\n            to: tokenAddress,\n            data,\n        });\n        await wallet.waitForTransactionReceipt(txHash);\n        return `Successfully approved ${spenderAddress} to spend ${amount} tokens`;\n    }\n    catch (error) {\n        return `Error approving tokens: ${error}`;\n    }\n}\n/**\n * Scales a gas estimate by a given multiplier.\n *\n * This function converts the gas estimate to a number, applies the multiplier,\n * rounds the result to the nearest integer, and returns it as a bigint.\n *\n * @param gas - The original gas estimate (bigint).\n * @param multiplier - The factor by which to scale the estimate.\n * @returns The adjusted gas estimate as a bigint.\n */\nfunction applyGasMultiplier(gas, multiplier) {\n    return BigInt(Math.round(Number(gas) * multiplier));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3QvdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZUFBZTtBQUNmLDBCQUEwQjtBQUMxQixlQUFlLG1CQUFPLENBQUMscURBQU07QUFDN0I7QUFDQTtBQUNBO0FBQ0EsY0FBYyxrQ0FBa0M7QUFDaEQsY0FBYyxpQ0FBaUM7QUFDL0M7QUFDQTtBQUNBLG9CQUFvQix3QkFBd0I7QUFDNUM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSx3Q0FBd0MsZ0JBQWdCLFdBQVcsUUFBUTtBQUMzRTtBQUNBO0FBQ0EsMENBQTBDLE1BQU07QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3Vydml2YWwtZnVuLy4vbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9hZ2VudGtpdC9kaXN0L3V0aWxzLmpzPzk1MWYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmFwcHJvdmUgPSBhcHByb3ZlO1xuZXhwb3J0cy5hcHBseUdhc011bHRpcGxpZXIgPSBhcHBseUdhc011bHRpcGxpZXI7XG5jb25zdCB2aWVtXzEgPSByZXF1aXJlKFwidmllbVwiKTtcbmNvbnN0IEVSQzIwX0FCSSA9IFtcbiAgICB7XG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAgeyBuYW1lOiBcInNwZW5kZXJcIiwgdHlwZTogXCJhZGRyZXNzXCIgfSxcbiAgICAgICAgICAgIHsgbmFtZTogXCJhbW91bnRcIiwgdHlwZTogXCJ1aW50MjU2XCIgfSxcbiAgICAgICAgXSxcbiAgICAgICAgbmFtZTogXCJhcHByb3ZlXCIsXG4gICAgICAgIG91dHB1dHM6IFt7IG5hbWU6IFwiXCIsIHR5cGU6IFwiYm9vbFwiIH1dLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6IFwibm9ucGF5YWJsZVwiLFxuICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgfSxcbl07XG4vKipcbiAqIEFwcHJvdmVzIGEgc3BlbmRlciB0byBzcGVuZCB0b2tlbnMgb24gYmVoYWxmIG9mIHRoZSBvd25lclxuICpcbiAqIEBwYXJhbSB3YWxsZXQgLSBUaGUgd2FsbGV0IHByb3ZpZGVyXG4gKiBAcGFyYW0gdG9rZW5BZGRyZXNzIC0gVGhlIGFkZHJlc3Mgb2YgdGhlIHRva2VuIGNvbnRyYWN0XG4gKiBAcGFyYW0gc3BlbmRlckFkZHJlc3MgLSBUaGUgYWRkcmVzcyBvZiB0aGUgc3BlbmRlclxuICogQHBhcmFtIGFtb3VudCAtIFRoZSBhbW91bnQgdG8gYXBwcm92ZSBpbiBhdG9taWMgdW5pdHMgKHdlaSlcbiAqIEByZXR1cm5zIEEgc3VjY2VzcyBtZXNzYWdlIG9yIGVycm9yIG1lc3NhZ2VcbiAqL1xuYXN5bmMgZnVuY3Rpb24gYXBwcm92ZSh3YWxsZXQsIHRva2VuQWRkcmVzcywgc3BlbmRlckFkZHJlc3MsIGFtb3VudCkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSAoMCwgdmllbV8xLmVuY29kZUZ1bmN0aW9uRGF0YSkoe1xuICAgICAgICAgICAgYWJpOiBFUkMyMF9BQkksXG4gICAgICAgICAgICBmdW5jdGlvbk5hbWU6IFwiYXBwcm92ZVwiLFxuICAgICAgICAgICAgYXJnczogW3NwZW5kZXJBZGRyZXNzLCBhbW91bnRdLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgdHhIYXNoID0gYXdhaXQgd2FsbGV0LnNlbmRUcmFuc2FjdGlvbih7XG4gICAgICAgICAgICB0bzogdG9rZW5BZGRyZXNzLFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHdhbGxldC53YWl0Rm9yVHJhbnNhY3Rpb25SZWNlaXB0KHR4SGFzaCk7XG4gICAgICAgIHJldHVybiBgU3VjY2Vzc2Z1bGx5IGFwcHJvdmVkICR7c3BlbmRlckFkZHJlc3N9IHRvIHNwZW5kICR7YW1vdW50fSB0b2tlbnNgO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGBFcnJvciBhcHByb3ZpbmcgdG9rZW5zOiAke2Vycm9yfWA7XG4gICAgfVxufVxuLyoqXG4gKiBTY2FsZXMgYSBnYXMgZXN0aW1hdGUgYnkgYSBnaXZlbiBtdWx0aXBsaWVyLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gY29udmVydHMgdGhlIGdhcyBlc3RpbWF0ZSB0byBhIG51bWJlciwgYXBwbGllcyB0aGUgbXVsdGlwbGllcixcbiAqIHJvdW5kcyB0aGUgcmVzdWx0IHRvIHRoZSBuZWFyZXN0IGludGVnZXIsIGFuZCByZXR1cm5zIGl0IGFzIGEgYmlnaW50LlxuICpcbiAqIEBwYXJhbSBnYXMgLSBUaGUgb3JpZ2luYWwgZ2FzIGVzdGltYXRlIChiaWdpbnQpLlxuICogQHBhcmFtIG11bHRpcGxpZXIgLSBUaGUgZmFjdG9yIGJ5IHdoaWNoIHRvIHNjYWxlIHRoZSBlc3RpbWF0ZS5cbiAqIEByZXR1cm5zIFRoZSBhZGp1c3RlZCBnYXMgZXN0aW1hdGUgYXMgYSBiaWdpbnQuXG4gKi9cbmZ1bmN0aW9uIGFwcGx5R2FzTXVsdGlwbGllcihnYXMsIG11bHRpcGxpZXIpIHtcbiAgICByZXR1cm4gQmlnSW50KE1hdGgucm91bmQoTnVtYmVyKGdhcykgKiBtdWx0aXBsaWVyKSk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/wallet-providers/cdpWalletProvider.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/wallet-providers/cdpWalletProvider.js ***!
  \************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _CdpWalletProvider_cdpWallet, _CdpWalletProvider_address, _CdpWalletProvider_network, _CdpWalletProvider_publicClient, _CdpWalletProvider_gasLimitMultiplier, _CdpWalletProvider_feePerGasMultiplier, _CdpWalletProvider_transactionQueue;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CdpWalletProvider = void 0;\nconst package_json_1 = __webpack_require__(/*! ../../package.json */ \"(rsc)/./node_modules/@coinbase/agentkit/package.json\");\nconst decimal_js_1 = __webpack_require__(/*! decimal.js */ \"(rsc)/./node_modules/decimal.js/decimal.js\");\nconst viem_1 = __webpack_require__(/*! viem */ \"(rsc)/./node_modules/viem/_cjs/index.js\");\nconst evmWalletProvider_1 = __webpack_require__(/*! ./evmWalletProvider */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/wallet-providers/evmWalletProvider.js\");\nconst coinbase_sdk_1 = __webpack_require__(/*! @coinbase/coinbase-sdk */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/index.js\");\nconst network_1 = __webpack_require__(/*! ../network/network */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/network/network.js\");\nconst utils_1 = __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/utils.js\");\n/**\n * A wallet provider that uses the Coinbase SDK.\n */\nclass CdpWalletProvider extends evmWalletProvider_1.EvmWalletProvider {\n    /**\n     * Constructs a new CdpWalletProvider.\n     *\n     * @param config - The configuration options for the CdpWalletProvider.\n     */\n    constructor(config) {\n        super();\n        _CdpWalletProvider_cdpWallet.set(this, void 0);\n        _CdpWalletProvider_address.set(this, void 0);\n        _CdpWalletProvider_network.set(this, void 0);\n        _CdpWalletProvider_publicClient.set(this, void 0);\n        _CdpWalletProvider_gasLimitMultiplier.set(this, void 0);\n        _CdpWalletProvider_feePerGasMultiplier.set(this, void 0);\n        _CdpWalletProvider_transactionQueue.set(this, void 0);\n        __classPrivateFieldSet(this, _CdpWalletProvider_cdpWallet, config.wallet, \"f\");\n        __classPrivateFieldSet(this, _CdpWalletProvider_address, config.address, \"f\");\n        __classPrivateFieldSet(this, _CdpWalletProvider_network, config.network, \"f\");\n        __classPrivateFieldSet(this, _CdpWalletProvider_publicClient, (0, viem_1.createPublicClient)({\n            chain: network_1.NETWORK_ID_TO_VIEM_CHAIN[config.network.networkId],\n            transport: (0, viem_1.http)(),\n        }), \"f\");\n        __classPrivateFieldSet(this, _CdpWalletProvider_gasLimitMultiplier, Math.max(config.gas?.gasLimitMultiplier ?? 1.2, 1), \"f\");\n        __classPrivateFieldSet(this, _CdpWalletProvider_feePerGasMultiplier, Math.max(config.gas?.feePerGasMultiplier ?? 1, 1), \"f\");\n    }\n    /**\n     * Configures a new CdpWalletProvider with a wallet.\n     *\n     * @param config - Optional configuration parameters\n     * @returns A Promise that resolves to a new CdpWalletProvider instance\n     * @throws Error if required environment variables are missing or wallet initialization fails\n     */\n    static async configureWithWallet(config = {}) {\n        if (config.apiKeyName && config.apiKeyPrivateKey) {\n            coinbase_sdk_1.Coinbase.configure({\n                apiKeyName: config.apiKeyName,\n                privateKey: config.apiKeyPrivateKey?.replace(/\\\\n/g, \"\\n\"),\n                source: \"agentkit\",\n                sourceVersion: package_json_1.version,\n            });\n        }\n        else {\n            coinbase_sdk_1.Coinbase.configureFromJson({ source: \"agentkit\", sourceVersion: package_json_1.version });\n        }\n        let wallet;\n        const mnemonicPhrase = config.mnemonicPhrase || process.env.MNEMONIC_PHRASE;\n        let networkId = config.networkId || process.env.NETWORK_ID || coinbase_sdk_1.Coinbase.networks.BaseSepolia;\n        try {\n            if (config.wallet) {\n                wallet = config.wallet;\n            }\n            else if (config.cdpWalletData) {\n                const walletData = JSON.parse(config.cdpWalletData);\n                wallet = await coinbase_sdk_1.Wallet.import(walletData);\n                networkId = wallet.getNetworkId();\n            }\n            else if (mnemonicPhrase) {\n                wallet = await coinbase_sdk_1.Wallet.import({ mnemonicPhrase: mnemonicPhrase }, networkId);\n            }\n            else {\n                wallet = await coinbase_sdk_1.Wallet.create({ networkId: networkId });\n            }\n        }\n        catch (error) {\n            throw new Error(`Failed to initialize wallet: ${error}`);\n        }\n        const address = (await wallet.getDefaultAddress())?.getId();\n        const network = {\n            protocolFamily: \"evm\",\n            chainId: network_1.NETWORK_ID_TO_CHAIN_ID[networkId],\n            networkId: networkId,\n        };\n        const cdpWalletProvider = new CdpWalletProvider({\n            wallet,\n            address,\n            network,\n            gas: config.gas,\n        });\n        return cdpWalletProvider;\n    }\n    /**\n     * Signs a message.\n     *\n     * @param message - The message to sign.\n     * @returns The signed message.\n     */\n    async signMessage(message) {\n        if (!__classPrivateFieldGet(this, _CdpWalletProvider_cdpWallet, \"f\")) {\n            throw new Error(\"Wallet not initialized\");\n        }\n        const messageHash = (0, coinbase_sdk_1.hashMessage)(message);\n        const payload = await __classPrivateFieldGet(this, _CdpWalletProvider_cdpWallet, \"f\").createPayloadSignature(messageHash);\n        if (payload.getStatus() === \"pending\" && payload?.wait) {\n            await payload.wait(); // needed for Server-Signers\n        }\n        return payload.getSignature();\n    }\n    /**\n     * Signs a typed data object.\n     *\n     * @param typedData - The typed data object to sign.\n     * @returns The signed typed data object.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    async signTypedData(typedData) {\n        if (!__classPrivateFieldGet(this, _CdpWalletProvider_cdpWallet, \"f\")) {\n            throw new Error(\"Wallet not initialized\");\n        }\n        const messageHash = (0, coinbase_sdk_1.hashTypedDataMessage)(typedData.domain, typedData.types, typedData.message);\n        const payload = await __classPrivateFieldGet(this, _CdpWalletProvider_cdpWallet, \"f\").createPayloadSignature(messageHash);\n        if (payload.getStatus() === \"pending\" && payload?.wait) {\n            await payload.wait(); // needed for Server-Signers\n        }\n        return payload.getSignature();\n    }\n    /**\n     * Signs a transaction.\n     *\n     * @param transaction - The transaction to sign.\n     * @returns The signed transaction.\n     */\n    async signTransaction(transaction) {\n        if (!__classPrivateFieldGet(this, _CdpWalletProvider_cdpWallet, \"f\")) {\n            throw new Error(\"Wallet not initialized\");\n        }\n        const serializedTx = (0, viem_1.serializeTransaction)(transaction);\n        const transactionHash = (0, viem_1.keccak256)(serializedTx);\n        const payload = await __classPrivateFieldGet(this, _CdpWalletProvider_cdpWallet, \"f\").createPayloadSignature(transactionHash);\n        if (payload.getStatus() === \"pending\" && payload?.wait) {\n            await payload.wait(); // needed for Server-Signers\n        }\n        return payload.getSignature();\n    }\n    /**\n     * Sends a transaction.\n     *\n     * @param transaction - The transaction to send.\n     * @returns The hash of the transaction.\n     */\n    async sendTransaction(transaction) {\n        if (!__classPrivateFieldGet(this, _CdpWalletProvider_cdpWallet, \"f\")) {\n            throw new Error(\"Wallet not initialized\");\n        }\n        const sendPromise = (async () => {\n            if (__classPrivateFieldGet(this, _CdpWalletProvider_transactionQueue, \"f\"))\n                await __classPrivateFieldGet(this, _CdpWalletProvider_transactionQueue, \"f\");\n            const preparedTransaction = await this.prepareTransaction(transaction.to, transaction.value, transaction.data);\n            const signature = await this.signTransaction({\n                ...preparedTransaction,\n            });\n            const signedPayload = await this.addSignatureAndSerialize(preparedTransaction, signature);\n            const externalAddress = new coinbase_sdk_1.ExternalAddress(__classPrivateFieldGet(this, _CdpWalletProvider_cdpWallet, \"f\").getNetworkId(), __classPrivateFieldGet(this, _CdpWalletProvider_address, \"f\"));\n            const tx = await externalAddress.broadcastExternalTransaction(signedPayload.slice(2));\n            return tx.transactionHash;\n        })();\n        __classPrivateFieldSet(this, _CdpWalletProvider_transactionQueue, sendPromise\n            .then(txHash => this.waitForTransactionReceipt(txHash))\n            .catch(() => { }), \"f\");\n        return await sendPromise;\n    }\n    /**\n     * Prepares a transaction.\n     *\n     * @param to - The address to send the transaction to.\n     * @param value - The value of the transaction.\n     * @param data - The data of the transaction.\n     * @returns The prepared transaction.\n     */\n    async prepareTransaction(to, value, data) {\n        if (!__classPrivateFieldGet(this, _CdpWalletProvider_cdpWallet, \"f\")) {\n            throw new Error(\"Wallet not initialized\");\n        }\n        const nonce = await __classPrivateFieldGet(this, _CdpWalletProvider_publicClient, \"f\").getTransactionCount({\n            address: __classPrivateFieldGet(this, _CdpWalletProvider_address, \"f\"),\n            blockTag: \"pending\",\n        });\n        const feeData = await __classPrivateFieldGet(this, _CdpWalletProvider_publicClient, \"f\").estimateFeesPerGas();\n        const maxFeePerGas = (0, utils_1.applyGasMultiplier)(feeData.maxFeePerGas, __classPrivateFieldGet(this, _CdpWalletProvider_feePerGasMultiplier, \"f\"));\n        const maxPriorityFeePerGas = (0, utils_1.applyGasMultiplier)(feeData.maxPriorityFeePerGas, __classPrivateFieldGet(this, _CdpWalletProvider_feePerGasMultiplier, \"f\"));\n        const gasLimit = await __classPrivateFieldGet(this, _CdpWalletProvider_publicClient, \"f\").estimateGas({\n            account: __classPrivateFieldGet(this, _CdpWalletProvider_address, \"f\"),\n            to,\n            value,\n            data,\n        });\n        const gas = BigInt(Math.round(Number(gasLimit) * __classPrivateFieldGet(this, _CdpWalletProvider_gasLimitMultiplier, \"f\")));\n        const chainId = parseInt(__classPrivateFieldGet(this, _CdpWalletProvider_network, \"f\").chainId, 10);\n        return {\n            to,\n            value,\n            data,\n            nonce,\n            maxFeePerGas,\n            maxPriorityFeePerGas,\n            gas,\n            chainId,\n            type: \"eip1559\",\n        };\n    }\n    /**\n     * Adds signature to a transaction and serializes it for broadcast.\n     *\n     * @param transaction - The transaction to sign.\n     * @param signature - The signature to add to the transaction.\n     * @returns A serialized transaction.\n     */\n    async addSignatureAndSerialize(transaction, signature) {\n        // Decode the signature into its components\n        const r = `0x${signature.slice(2, 66)}`; // First 32 bytes\n        const s = `0x${signature.slice(66, 130)}`; // Next 32 bytes\n        const v = BigInt(parseInt(signature.slice(130, 132), 16)); // Last byte\n        return (0, viem_1.serializeTransaction)(transaction, { r, s, v });\n    }\n    /**\n     * Gets the address of the wallet.\n     *\n     * @returns The address of the wallet.\n     */\n    getAddress() {\n        if (!__classPrivateFieldGet(this, _CdpWalletProvider_address, \"f\")) {\n            throw new Error(\"Address not initialized\");\n        }\n        return __classPrivateFieldGet(this, _CdpWalletProvider_address, \"f\");\n    }\n    /**\n     * Gets the network of the wallet.\n     *\n     * @returns The network of the wallet.\n     */\n    getNetwork() {\n        if (!__classPrivateFieldGet(this, _CdpWalletProvider_network, \"f\")) {\n            throw new Error(\"Network not initialized\");\n        }\n        return __classPrivateFieldGet(this, _CdpWalletProvider_network, \"f\");\n    }\n    /**\n     * Gets the name of the wallet provider.\n     *\n     * @returns The name of the wallet provider.\n     */\n    getName() {\n        return \"cdp_wallet_provider\";\n    }\n    /**\n     * Gets the balance of the wallet.\n     *\n     * @returns The balance of the wallet in wei\n     */\n    async getBalance() {\n        if (!__classPrivateFieldGet(this, _CdpWalletProvider_cdpWallet, \"f\")) {\n            throw new Error(\"Wallet not initialized\");\n        }\n        const balance = await __classPrivateFieldGet(this, _CdpWalletProvider_cdpWallet, \"f\").getBalance(\"eth\");\n        return BigInt(balance.mul(10 ** 18).toString());\n    }\n    /**\n     * Waits for a transaction receipt.\n     *\n     * @param txHash - The hash of the transaction to wait for.\n     * @returns The transaction receipt.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    async waitForTransactionReceipt(txHash) {\n        return await __classPrivateFieldGet(this, _CdpWalletProvider_publicClient, \"f\").waitForTransactionReceipt({ hash: txHash });\n    }\n    /**\n     * Reads a contract.\n     *\n     * @param params - The parameters to read the contract.\n     * @returns The response from the contract.\n     */\n    async readContract(params) {\n        return __classPrivateFieldGet(this, _CdpWalletProvider_publicClient, \"f\").readContract(params);\n    }\n    /**\n     * Creates a trade.\n     *\n     * @param options - The options for the trade.\n     * @returns The trade.\n     */\n    async createTrade(options) {\n        if (!__classPrivateFieldGet(this, _CdpWalletProvider_cdpWallet, \"f\")) {\n            throw new Error(\"Wallet not initialized\");\n        }\n        return __classPrivateFieldGet(this, _CdpWalletProvider_cdpWallet, \"f\").createTrade(options);\n    }\n    /**\n     * Deploys a token.\n     *\n     * @param options - The options for the token deployment.\n     * @returns The deployed token.\n     */\n    async deployToken(options) {\n        if (!__classPrivateFieldGet(this, _CdpWalletProvider_cdpWallet, \"f\")) {\n            throw new Error(\"Wallet not initialized\");\n        }\n        return __classPrivateFieldGet(this, _CdpWalletProvider_cdpWallet, \"f\").deployToken(options);\n    }\n    /**\n     * Deploys a contract.\n     *\n     * @param options - The options for contract deployment\n     * @param options.solidityVersion - The version of the Solidity compiler to use (e.g. \"0.8.0+commit.c7dfd78e\")\n     * @param options.solidityInputJson - The JSON input for the Solidity compiler containing contract source and settings\n     * @param options.contractName - The name of the contract to deploy\n     * @param options.constructorArgs - Key-value map of constructor args\n     *\n     * @returns A Promise that resolves to the deployed contract instance\n     * @throws Error if wallet is not initialized\n     */\n    async deployContract(options) {\n        if (!__classPrivateFieldGet(this, _CdpWalletProvider_cdpWallet, \"f\")) {\n            throw new Error(\"Wallet not initialized\");\n        }\n        return __classPrivateFieldGet(this, _CdpWalletProvider_cdpWallet, \"f\").deployContract(options);\n    }\n    /**\n     * Deploys a new NFT (ERC-721) smart contract.\n     *\n     * @param options - Configuration options for the NFT contract deployment\n     * @param options.name - The name of the collection\n     * @param options.symbol - The token symbol for the collection\n     * @param options.baseURI - The base URI for token metadata.\n     *\n     * @returns A Promise that resolves to the deployed SmartContract instance\n     * @throws Error if the wallet is not properly initialized\n     * @throws Error if the deployment fails for any reason (network issues, insufficient funds, etc.)\n     */\n    async deployNFT(options) {\n        if (!__classPrivateFieldGet(this, _CdpWalletProvider_cdpWallet, \"f\")) {\n            throw new Error(\"Wallet not initialized\");\n        }\n        return __classPrivateFieldGet(this, _CdpWalletProvider_cdpWallet, \"f\").deployNFT(options);\n    }\n    /**\n     * Transfer the native asset of the network.\n     *\n     * @param to - The destination address.\n     * @param value - The amount to transfer in Wei.\n     * @returns The transaction hash.\n     */\n    async nativeTransfer(to, value) {\n        if (!__classPrivateFieldGet(this, _CdpWalletProvider_cdpWallet, \"f\")) {\n            throw new Error(\"Wallet not initialized\");\n        }\n        const transferResult = await __classPrivateFieldGet(this, _CdpWalletProvider_cdpWallet, \"f\").createTransfer({\n            amount: new decimal_js_1.Decimal(value),\n            assetId: coinbase_sdk_1.Coinbase.assets.Eth,\n            destination: to,\n            gasless: false,\n        });\n        const result = await transferResult.wait();\n        if (!result.getTransactionHash()) {\n            throw new Error(\"Transaction hash not found\");\n        }\n        return result.getTransactionHash();\n    }\n    /**\n     * Exports the wallet.\n     *\n     * @returns The wallet's data.\n     */\n    async exportWallet() {\n        if (!__classPrivateFieldGet(this, _CdpWalletProvider_cdpWallet, \"f\")) {\n            throw new Error(\"Wallet not initialized\");\n        }\n        return __classPrivateFieldGet(this, _CdpWalletProvider_cdpWallet, \"f\").export();\n    }\n    /**\n     * Gets the wallet.\n     *\n     * @returns The wallet.\n     */\n    getWallet() {\n        if (!__classPrivateFieldGet(this, _CdpWalletProvider_cdpWallet, \"f\")) {\n            throw new Error(\"Wallet not initialized\");\n        }\n        return __classPrivateFieldGet(this, _CdpWalletProvider_cdpWallet, \"f\");\n    }\n    /**\n     * ERC20 transfer method\n     *\n     * @param assetId - The asset ID to transfer. Either USDC, CBBTC or EURC\n     * @param destination - The destination address\n     * @param amount - The amount to transfer\n     * @returns The transaction hash\n     */\n    async gaslessERC20Transfer(assetId, destination, amount) {\n        if (!__classPrivateFieldGet(this, _CdpWalletProvider_cdpWallet, \"f\")) {\n            throw new Error(\"Wallet not initialized\");\n        }\n        const transferResult = await __classPrivateFieldGet(this, _CdpWalletProvider_cdpWallet, \"f\").createTransfer({\n            amount,\n            assetId,\n            destination,\n            gasless: true,\n        });\n        const result = await transferResult.wait();\n        if (!result.getTransactionHash()) {\n            throw new Error(\"Transaction hash not found\");\n        }\n        return result.getTransactionHash();\n    }\n}\nexports.CdpWalletProvider = CdpWalletProvider;\n_CdpWalletProvider_cdpWallet = new WeakMap(), _CdpWalletProvider_address = new WeakMap(), _CdpWalletProvider_network = new WeakMap(), _CdpWalletProvider_publicClient = new WeakMap(), _CdpWalletProvider_gasLimitMultiplier = new WeakMap(), _CdpWalletProvider_feePerGasMultiplier = new WeakMap(), _CdpWalletProvider_transactionQueue = new WeakMap();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3Qvd2FsbGV0LXByb3ZpZGVycy9jZHBXYWxsZXRQcm92aWRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx5QkFBeUI7QUFDekIsdUJBQXVCLG1CQUFPLENBQUMsZ0ZBQW9CO0FBQ25ELHFCQUFxQixtQkFBTyxDQUFDLDhEQUFZO0FBQ3pDLGVBQWUsbUJBQU8sQ0FBQyxxREFBTTtBQUM3Qiw0QkFBNEIsbUJBQU8sQ0FBQywrR0FBcUI7QUFDekQsdUJBQXVCLG1CQUFPLENBQUMseUZBQXdCO0FBQ3ZELGtCQUFrQixtQkFBTyxDQUFDLDJGQUFvQjtBQUM5QyxnQkFBZ0IsbUJBQU8sQ0FBQyx1RUFBVTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSx3REFBd0QsMkRBQTJEO0FBQ25IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsZ0NBQWdDO0FBQzlGO0FBQ0E7QUFDQSw4REFBOEQsc0JBQXNCO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxNQUFNO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsdUJBQXVCLEdBQUc7QUFDakQsdUJBQXVCLHlCQUF5QixHQUFHO0FBQ25ELG1FQUFtRTtBQUNuRSwrREFBK0QsU0FBUztBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvSEFBb0gsY0FBYztBQUNsSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QiIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cnZpdmFsLWZ1bi8uL25vZGVfbW9kdWxlcy9AY29pbmJhc2UvYWdlbnRraXQvZGlzdC93YWxsZXQtcHJvdmlkZXJzL2NkcFdhbGxldFByb3ZpZGVyLmpzP2I0ZWQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZFNldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZFNldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwgdmFsdWUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XG59O1xudmFyIF9fY2xhc3NQcml2YXRlRmllbGRHZXQgPSAodGhpcyAmJiB0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRHZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcbn07XG52YXIgX0NkcFdhbGxldFByb3ZpZGVyX2NkcFdhbGxldCwgX0NkcFdhbGxldFByb3ZpZGVyX2FkZHJlc3MsIF9DZHBXYWxsZXRQcm92aWRlcl9uZXR3b3JrLCBfQ2RwV2FsbGV0UHJvdmlkZXJfcHVibGljQ2xpZW50LCBfQ2RwV2FsbGV0UHJvdmlkZXJfZ2FzTGltaXRNdWx0aXBsaWVyLCBfQ2RwV2FsbGV0UHJvdmlkZXJfZmVlUGVyR2FzTXVsdGlwbGllciwgX0NkcFdhbGxldFByb3ZpZGVyX3RyYW5zYWN0aW9uUXVldWU7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNkcFdhbGxldFByb3ZpZGVyID0gdm9pZCAwO1xuY29uc3QgcGFja2FnZV9qc29uXzEgPSByZXF1aXJlKFwiLi4vLi4vcGFja2FnZS5qc29uXCIpO1xuY29uc3QgZGVjaW1hbF9qc18xID0gcmVxdWlyZShcImRlY2ltYWwuanNcIik7XG5jb25zdCB2aWVtXzEgPSByZXF1aXJlKFwidmllbVwiKTtcbmNvbnN0IGV2bVdhbGxldFByb3ZpZGVyXzEgPSByZXF1aXJlKFwiLi9ldm1XYWxsZXRQcm92aWRlclwiKTtcbmNvbnN0IGNvaW5iYXNlX3Nka18xID0gcmVxdWlyZShcIkBjb2luYmFzZS9jb2luYmFzZS1zZGtcIik7XG5jb25zdCBuZXR3b3JrXzEgPSByZXF1aXJlKFwiLi4vbmV0d29yay9uZXR3b3JrXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcbi8qKlxuICogQSB3YWxsZXQgcHJvdmlkZXIgdGhhdCB1c2VzIHRoZSBDb2luYmFzZSBTREsuXG4gKi9cbmNsYXNzIENkcFdhbGxldFByb3ZpZGVyIGV4dGVuZHMgZXZtV2FsbGV0UHJvdmlkZXJfMS5Fdm1XYWxsZXRQcm92aWRlciB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyBhIG5ldyBDZHBXYWxsZXRQcm92aWRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb25maWcgLSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgQ2RwV2FsbGV0UHJvdmlkZXIuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIF9DZHBXYWxsZXRQcm92aWRlcl9jZHBXYWxsZXQuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9DZHBXYWxsZXRQcm92aWRlcl9hZGRyZXNzLnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICBfQ2RwV2FsbGV0UHJvdmlkZXJfbmV0d29yay5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX0NkcFdhbGxldFByb3ZpZGVyX3B1YmxpY0NsaWVudC5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX0NkcFdhbGxldFByb3ZpZGVyX2dhc0xpbWl0TXVsdGlwbGllci5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX0NkcFdhbGxldFByb3ZpZGVyX2ZlZVBlckdhc011bHRpcGxpZXIuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9DZHBXYWxsZXRQcm92aWRlcl90cmFuc2FjdGlvblF1ZXVlLnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9DZHBXYWxsZXRQcm92aWRlcl9jZHBXYWxsZXQsIGNvbmZpZy53YWxsZXQsIFwiZlwiKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQ2RwV2FsbGV0UHJvdmlkZXJfYWRkcmVzcywgY29uZmlnLmFkZHJlc3MsIFwiZlwiKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQ2RwV2FsbGV0UHJvdmlkZXJfbmV0d29yaywgY29uZmlnLm5ldHdvcmssIFwiZlwiKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQ2RwV2FsbGV0UHJvdmlkZXJfcHVibGljQ2xpZW50LCAoMCwgdmllbV8xLmNyZWF0ZVB1YmxpY0NsaWVudCkoe1xuICAgICAgICAgICAgY2hhaW46IG5ldHdvcmtfMS5ORVRXT1JLX0lEX1RPX1ZJRU1fQ0hBSU5bY29uZmlnLm5ldHdvcmsubmV0d29ya0lkXSxcbiAgICAgICAgICAgIHRyYW5zcG9ydDogKDAsIHZpZW1fMS5odHRwKSgpLFxuICAgICAgICB9KSwgXCJmXCIpO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9DZHBXYWxsZXRQcm92aWRlcl9nYXNMaW1pdE11bHRpcGxpZXIsIE1hdGgubWF4KGNvbmZpZy5nYXM/Lmdhc0xpbWl0TXVsdGlwbGllciA/PyAxLjIsIDEpLCBcImZcIik7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0NkcFdhbGxldFByb3ZpZGVyX2ZlZVBlckdhc011bHRpcGxpZXIsIE1hdGgubWF4KGNvbmZpZy5nYXM/LmZlZVBlckdhc011bHRpcGxpZXIgPz8gMSwgMSksIFwiZlwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uZmlndXJlcyBhIG5ldyBDZHBXYWxsZXRQcm92aWRlciB3aXRoIGEgd2FsbGV0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbmZpZyAtIE9wdGlvbmFsIGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVyc1xuICAgICAqIEByZXR1cm5zIEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgbmV3IENkcFdhbGxldFByb3ZpZGVyIGluc3RhbmNlXG4gICAgICogQHRocm93cyBFcnJvciBpZiByZXF1aXJlZCBlbnZpcm9ubWVudCB2YXJpYWJsZXMgYXJlIG1pc3Npbmcgb3Igd2FsbGV0IGluaXRpYWxpemF0aW9uIGZhaWxzXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIGNvbmZpZ3VyZVdpdGhXYWxsZXQoY29uZmlnID0ge30pIHtcbiAgICAgICAgaWYgKGNvbmZpZy5hcGlLZXlOYW1lICYmIGNvbmZpZy5hcGlLZXlQcml2YXRlS2V5KSB7XG4gICAgICAgICAgICBjb2luYmFzZV9zZGtfMS5Db2luYmFzZS5jb25maWd1cmUoe1xuICAgICAgICAgICAgICAgIGFwaUtleU5hbWU6IGNvbmZpZy5hcGlLZXlOYW1lLFxuICAgICAgICAgICAgICAgIHByaXZhdGVLZXk6IGNvbmZpZy5hcGlLZXlQcml2YXRlS2V5Py5yZXBsYWNlKC9cXFxcbi9nLCBcIlxcblwiKSxcbiAgICAgICAgICAgICAgICBzb3VyY2U6IFwiYWdlbnRraXRcIixcbiAgICAgICAgICAgICAgICBzb3VyY2VWZXJzaW9uOiBwYWNrYWdlX2pzb25fMS52ZXJzaW9uLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb2luYmFzZV9zZGtfMS5Db2luYmFzZS5jb25maWd1cmVGcm9tSnNvbih7IHNvdXJjZTogXCJhZ2VudGtpdFwiLCBzb3VyY2VWZXJzaW9uOiBwYWNrYWdlX2pzb25fMS52ZXJzaW9uIH0pO1xuICAgICAgICB9XG4gICAgICAgIGxldCB3YWxsZXQ7XG4gICAgICAgIGNvbnN0IG1uZW1vbmljUGhyYXNlID0gY29uZmlnLm1uZW1vbmljUGhyYXNlIHx8IHByb2Nlc3MuZW52Lk1ORU1PTklDX1BIUkFTRTtcbiAgICAgICAgbGV0IG5ldHdvcmtJZCA9IGNvbmZpZy5uZXR3b3JrSWQgfHwgcHJvY2Vzcy5lbnYuTkVUV09SS19JRCB8fCBjb2luYmFzZV9zZGtfMS5Db2luYmFzZS5uZXR3b3Jrcy5CYXNlU2Vwb2xpYTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChjb25maWcud2FsbGV0KSB7XG4gICAgICAgICAgICAgICAgd2FsbGV0ID0gY29uZmlnLndhbGxldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbmZpZy5jZHBXYWxsZXREYXRhKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgd2FsbGV0RGF0YSA9IEpTT04ucGFyc2UoY29uZmlnLmNkcFdhbGxldERhdGEpO1xuICAgICAgICAgICAgICAgIHdhbGxldCA9IGF3YWl0IGNvaW5iYXNlX3Nka18xLldhbGxldC5pbXBvcnQod2FsbGV0RGF0YSk7XG4gICAgICAgICAgICAgICAgbmV0d29ya0lkID0gd2FsbGV0LmdldE5ldHdvcmtJZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobW5lbW9uaWNQaHJhc2UpIHtcbiAgICAgICAgICAgICAgICB3YWxsZXQgPSBhd2FpdCBjb2luYmFzZV9zZGtfMS5XYWxsZXQuaW1wb3J0KHsgbW5lbW9uaWNQaHJhc2U6IG1uZW1vbmljUGhyYXNlIH0sIG5ldHdvcmtJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB3YWxsZXQgPSBhd2FpdCBjb2luYmFzZV9zZGtfMS5XYWxsZXQuY3JlYXRlKHsgbmV0d29ya0lkOiBuZXR3b3JrSWQgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBpbml0aWFsaXplIHdhbGxldDogJHtlcnJvcn1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhZGRyZXNzID0gKGF3YWl0IHdhbGxldC5nZXREZWZhdWx0QWRkcmVzcygpKT8uZ2V0SWQoKTtcbiAgICAgICAgY29uc3QgbmV0d29yayA9IHtcbiAgICAgICAgICAgIHByb3RvY29sRmFtaWx5OiBcImV2bVwiLFxuICAgICAgICAgICAgY2hhaW5JZDogbmV0d29ya18xLk5FVFdPUktfSURfVE9fQ0hBSU5fSURbbmV0d29ya0lkXSxcbiAgICAgICAgICAgIG5ldHdvcmtJZDogbmV0d29ya0lkLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjZHBXYWxsZXRQcm92aWRlciA9IG5ldyBDZHBXYWxsZXRQcm92aWRlcih7XG4gICAgICAgICAgICB3YWxsZXQsXG4gICAgICAgICAgICBhZGRyZXNzLFxuICAgICAgICAgICAgbmV0d29yayxcbiAgICAgICAgICAgIGdhczogY29uZmlnLmdhcyxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjZHBXYWxsZXRQcm92aWRlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2lnbnMgYSBtZXNzYWdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgLSBUaGUgbWVzc2FnZSB0byBzaWduLlxuICAgICAqIEByZXR1cm5zIFRoZSBzaWduZWQgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBhc3luYyBzaWduTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIGlmICghX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ2RwV2FsbGV0UHJvdmlkZXJfY2RwV2FsbGV0LCBcImZcIikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIldhbGxldCBub3QgaW5pdGlhbGl6ZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWVzc2FnZUhhc2ggPSAoMCwgY29pbmJhc2Vfc2RrXzEuaGFzaE1lc3NhZ2UpKG1lc3NhZ2UpO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0gYXdhaXQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ2RwV2FsbGV0UHJvdmlkZXJfY2RwV2FsbGV0LCBcImZcIikuY3JlYXRlUGF5bG9hZFNpZ25hdHVyZShtZXNzYWdlSGFzaCk7XG4gICAgICAgIGlmIChwYXlsb2FkLmdldFN0YXR1cygpID09PSBcInBlbmRpbmdcIiAmJiBwYXlsb2FkPy53YWl0KSB7XG4gICAgICAgICAgICBhd2FpdCBwYXlsb2FkLndhaXQoKTsgLy8gbmVlZGVkIGZvciBTZXJ2ZXItU2lnbmVyc1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXlsb2FkLmdldFNpZ25hdHVyZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaWducyBhIHR5cGVkIGRhdGEgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHR5cGVkRGF0YSAtIFRoZSB0eXBlZCBkYXRhIG9iamVjdCB0byBzaWduLlxuICAgICAqIEByZXR1cm5zIFRoZSBzaWduZWQgdHlwZWQgZGF0YSBvYmplY3QuXG4gICAgICovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBhc3luYyBzaWduVHlwZWREYXRhKHR5cGVkRGF0YSkge1xuICAgICAgICBpZiAoIV9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NkcFdhbGxldFByb3ZpZGVyX2NkcFdhbGxldCwgXCJmXCIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXYWxsZXQgbm90IGluaXRpYWxpemVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VIYXNoID0gKDAsIGNvaW5iYXNlX3Nka18xLmhhc2hUeXBlZERhdGFNZXNzYWdlKSh0eXBlZERhdGEuZG9tYWluLCB0eXBlZERhdGEudHlwZXMsIHR5cGVkRGF0YS5tZXNzYWdlKTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IGF3YWl0IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NkcFdhbGxldFByb3ZpZGVyX2NkcFdhbGxldCwgXCJmXCIpLmNyZWF0ZVBheWxvYWRTaWduYXR1cmUobWVzc2FnZUhhc2gpO1xuICAgICAgICBpZiAocGF5bG9hZC5nZXRTdGF0dXMoKSA9PT0gXCJwZW5kaW5nXCIgJiYgcGF5bG9hZD8ud2FpdCkge1xuICAgICAgICAgICAgYXdhaXQgcGF5bG9hZC53YWl0KCk7IC8vIG5lZWRlZCBmb3IgU2VydmVyLVNpZ25lcnNcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF5bG9hZC5nZXRTaWduYXR1cmUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2lnbnMgYSB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0cmFuc2FjdGlvbiAtIFRoZSB0cmFuc2FjdGlvbiB0byBzaWduLlxuICAgICAqIEByZXR1cm5zIFRoZSBzaWduZWQgdHJhbnNhY3Rpb24uXG4gICAgICovXG4gICAgYXN5bmMgc2lnblRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIGlmICghX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ2RwV2FsbGV0UHJvdmlkZXJfY2RwV2FsbGV0LCBcImZcIikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIldhbGxldCBub3QgaW5pdGlhbGl6ZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VyaWFsaXplZFR4ID0gKDAsIHZpZW1fMS5zZXJpYWxpemVUcmFuc2FjdGlvbikodHJhbnNhY3Rpb24pO1xuICAgICAgICBjb25zdCB0cmFuc2FjdGlvbkhhc2ggPSAoMCwgdmllbV8xLmtlY2NhazI1Nikoc2VyaWFsaXplZFR4KTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IGF3YWl0IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NkcFdhbGxldFByb3ZpZGVyX2NkcFdhbGxldCwgXCJmXCIpLmNyZWF0ZVBheWxvYWRTaWduYXR1cmUodHJhbnNhY3Rpb25IYXNoKTtcbiAgICAgICAgaWYgKHBheWxvYWQuZ2V0U3RhdHVzKCkgPT09IFwicGVuZGluZ1wiICYmIHBheWxvYWQ/LndhaXQpIHtcbiAgICAgICAgICAgIGF3YWl0IHBheWxvYWQud2FpdCgpOyAvLyBuZWVkZWQgZm9yIFNlcnZlci1TaWduZXJzXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBheWxvYWQuZ2V0U2lnbmF0dXJlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgdHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdHJhbnNhY3Rpb24gLSBUaGUgdHJhbnNhY3Rpb24gdG8gc2VuZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgaGFzaCBvZiB0aGUgdHJhbnNhY3Rpb24uXG4gICAgICovXG4gICAgYXN5bmMgc2VuZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIGlmICghX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ2RwV2FsbGV0UHJvdmlkZXJfY2RwV2FsbGV0LCBcImZcIikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIldhbGxldCBub3QgaW5pdGlhbGl6ZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VuZFByb21pc2UgPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NkcFdhbGxldFByb3ZpZGVyX3RyYW5zYWN0aW9uUXVldWUsIFwiZlwiKSlcbiAgICAgICAgICAgICAgICBhd2FpdCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DZHBXYWxsZXRQcm92aWRlcl90cmFuc2FjdGlvblF1ZXVlLCBcImZcIik7XG4gICAgICAgICAgICBjb25zdCBwcmVwYXJlZFRyYW5zYWN0aW9uID0gYXdhaXQgdGhpcy5wcmVwYXJlVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24udG8sIHRyYW5zYWN0aW9uLnZhbHVlLCB0cmFuc2FjdGlvbi5kYXRhKTtcbiAgICAgICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IHRoaXMuc2lnblRyYW5zYWN0aW9uKHtcbiAgICAgICAgICAgICAgICAuLi5wcmVwYXJlZFRyYW5zYWN0aW9uLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBzaWduZWRQYXlsb2FkID0gYXdhaXQgdGhpcy5hZGRTaWduYXR1cmVBbmRTZXJpYWxpemUocHJlcGFyZWRUcmFuc2FjdGlvbiwgc2lnbmF0dXJlKTtcbiAgICAgICAgICAgIGNvbnN0IGV4dGVybmFsQWRkcmVzcyA9IG5ldyBjb2luYmFzZV9zZGtfMS5FeHRlcm5hbEFkZHJlc3MoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ2RwV2FsbGV0UHJvdmlkZXJfY2RwV2FsbGV0LCBcImZcIikuZ2V0TmV0d29ya0lkKCksIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NkcFdhbGxldFByb3ZpZGVyX2FkZHJlc3MsIFwiZlwiKSk7XG4gICAgICAgICAgICBjb25zdCB0eCA9IGF3YWl0IGV4dGVybmFsQWRkcmVzcy5icm9hZGNhc3RFeHRlcm5hbFRyYW5zYWN0aW9uKHNpZ25lZFBheWxvYWQuc2xpY2UoMikpO1xuICAgICAgICAgICAgcmV0dXJuIHR4LnRyYW5zYWN0aW9uSGFzaDtcbiAgICAgICAgfSkoKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQ2RwV2FsbGV0UHJvdmlkZXJfdHJhbnNhY3Rpb25RdWV1ZSwgc2VuZFByb21pc2VcbiAgICAgICAgICAgIC50aGVuKHR4SGFzaCA9PiB0aGlzLndhaXRGb3JUcmFuc2FjdGlvblJlY2VpcHQodHhIYXNoKSlcbiAgICAgICAgICAgIC5jYXRjaCgoKSA9PiB7IH0pLCBcImZcIik7XG4gICAgICAgIHJldHVybiBhd2FpdCBzZW5kUHJvbWlzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJlcGFyZXMgYSB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0byAtIFRoZSBhZGRyZXNzIHRvIHNlbmQgdGhlIHRyYW5zYWN0aW9uIHRvLlxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSBvZiB0aGUgdHJhbnNhY3Rpb24uXG4gICAgICogQHBhcmFtIGRhdGEgLSBUaGUgZGF0YSBvZiB0aGUgdHJhbnNhY3Rpb24uXG4gICAgICogQHJldHVybnMgVGhlIHByZXBhcmVkIHRyYW5zYWN0aW9uLlxuICAgICAqL1xuICAgIGFzeW5jIHByZXBhcmVUcmFuc2FjdGlvbih0bywgdmFsdWUsIGRhdGEpIHtcbiAgICAgICAgaWYgKCFfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DZHBXYWxsZXRQcm92aWRlcl9jZHBXYWxsZXQsIFwiZlwiKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV2FsbGV0IG5vdCBpbml0aWFsaXplZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBub25jZSA9IGF3YWl0IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NkcFdhbGxldFByb3ZpZGVyX3B1YmxpY0NsaWVudCwgXCJmXCIpLmdldFRyYW5zYWN0aW9uQ291bnQoe1xuICAgICAgICAgICAgYWRkcmVzczogX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ2RwV2FsbGV0UHJvdmlkZXJfYWRkcmVzcywgXCJmXCIpLFxuICAgICAgICAgICAgYmxvY2tUYWc6IFwicGVuZGluZ1wiLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZmVlRGF0YSA9IGF3YWl0IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NkcFdhbGxldFByb3ZpZGVyX3B1YmxpY0NsaWVudCwgXCJmXCIpLmVzdGltYXRlRmVlc1BlckdhcygpO1xuICAgICAgICBjb25zdCBtYXhGZWVQZXJHYXMgPSAoMCwgdXRpbHNfMS5hcHBseUdhc011bHRpcGxpZXIpKGZlZURhdGEubWF4RmVlUGVyR2FzLCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DZHBXYWxsZXRQcm92aWRlcl9mZWVQZXJHYXNNdWx0aXBsaWVyLCBcImZcIikpO1xuICAgICAgICBjb25zdCBtYXhQcmlvcml0eUZlZVBlckdhcyA9ICgwLCB1dGlsc18xLmFwcGx5R2FzTXVsdGlwbGllcikoZmVlRGF0YS5tYXhQcmlvcml0eUZlZVBlckdhcywgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ2RwV2FsbGV0UHJvdmlkZXJfZmVlUGVyR2FzTXVsdGlwbGllciwgXCJmXCIpKTtcbiAgICAgICAgY29uc3QgZ2FzTGltaXQgPSBhd2FpdCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DZHBXYWxsZXRQcm92aWRlcl9wdWJsaWNDbGllbnQsIFwiZlwiKS5lc3RpbWF0ZUdhcyh7XG4gICAgICAgICAgICBhY2NvdW50OiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DZHBXYWxsZXRQcm92aWRlcl9hZGRyZXNzLCBcImZcIiksXG4gICAgICAgICAgICB0byxcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGdhcyA9IEJpZ0ludChNYXRoLnJvdW5kKE51bWJlcihnYXNMaW1pdCkgKiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DZHBXYWxsZXRQcm92aWRlcl9nYXNMaW1pdE11bHRpcGxpZXIsIFwiZlwiKSkpO1xuICAgICAgICBjb25zdCBjaGFpbklkID0gcGFyc2VJbnQoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ2RwV2FsbGV0UHJvdmlkZXJfbmV0d29yaywgXCJmXCIpLmNoYWluSWQsIDEwKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRvLFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgbm9uY2UsXG4gICAgICAgICAgICBtYXhGZWVQZXJHYXMsXG4gICAgICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhcyxcbiAgICAgICAgICAgIGdhcyxcbiAgICAgICAgICAgIGNoYWluSWQsXG4gICAgICAgICAgICB0eXBlOiBcImVpcDE1NTlcIixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBzaWduYXR1cmUgdG8gYSB0cmFuc2FjdGlvbiBhbmQgc2VyaWFsaXplcyBpdCBmb3IgYnJvYWRjYXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHRyYW5zYWN0aW9uIC0gVGhlIHRyYW5zYWN0aW9uIHRvIHNpZ24uXG4gICAgICogQHBhcmFtIHNpZ25hdHVyZSAtIFRoZSBzaWduYXR1cmUgdG8gYWRkIHRvIHRoZSB0cmFuc2FjdGlvbi5cbiAgICAgKiBAcmV0dXJucyBBIHNlcmlhbGl6ZWQgdHJhbnNhY3Rpb24uXG4gICAgICovXG4gICAgYXN5bmMgYWRkU2lnbmF0dXJlQW5kU2VyaWFsaXplKHRyYW5zYWN0aW9uLCBzaWduYXR1cmUpIHtcbiAgICAgICAgLy8gRGVjb2RlIHRoZSBzaWduYXR1cmUgaW50byBpdHMgY29tcG9uZW50c1xuICAgICAgICBjb25zdCByID0gYDB4JHtzaWduYXR1cmUuc2xpY2UoMiwgNjYpfWA7IC8vIEZpcnN0IDMyIGJ5dGVzXG4gICAgICAgIGNvbnN0IHMgPSBgMHgke3NpZ25hdHVyZS5zbGljZSg2NiwgMTMwKX1gOyAvLyBOZXh0IDMyIGJ5dGVzXG4gICAgICAgIGNvbnN0IHYgPSBCaWdJbnQocGFyc2VJbnQoc2lnbmF0dXJlLnNsaWNlKDEzMCwgMTMyKSwgMTYpKTsgLy8gTGFzdCBieXRlXG4gICAgICAgIHJldHVybiAoMCwgdmllbV8xLnNlcmlhbGl6ZVRyYW5zYWN0aW9uKSh0cmFuc2FjdGlvbiwgeyByLCBzLCB2IH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBhZGRyZXNzIG9mIHRoZSB3YWxsZXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgYWRkcmVzcyBvZiB0aGUgd2FsbGV0LlxuICAgICAqL1xuICAgIGdldEFkZHJlc3MoKSB7XG4gICAgICAgIGlmICghX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ2RwV2FsbGV0UHJvdmlkZXJfYWRkcmVzcywgXCJmXCIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBZGRyZXNzIG5vdCBpbml0aWFsaXplZFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ2RwV2FsbGV0UHJvdmlkZXJfYWRkcmVzcywgXCJmXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBuZXR3b3JrIG9mIHRoZSB3YWxsZXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgbmV0d29yayBvZiB0aGUgd2FsbGV0LlxuICAgICAqL1xuICAgIGdldE5ldHdvcmsoKSB7XG4gICAgICAgIGlmICghX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ2RwV2FsbGV0UHJvdmlkZXJfbmV0d29yaywgXCJmXCIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOZXR3b3JrIG5vdCBpbml0aWFsaXplZFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ2RwV2FsbGV0UHJvdmlkZXJfbmV0d29yaywgXCJmXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBuYW1lIG9mIHRoZSB3YWxsZXQgcHJvdmlkZXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgbmFtZSBvZiB0aGUgd2FsbGV0IHByb3ZpZGVyLlxuICAgICAqL1xuICAgIGdldE5hbWUoKSB7XG4gICAgICAgIHJldHVybiBcImNkcF93YWxsZXRfcHJvdmlkZXJcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgYmFsYW5jZSBvZiB0aGUgd2FsbGV0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGJhbGFuY2Ugb2YgdGhlIHdhbGxldCBpbiB3ZWlcbiAgICAgKi9cbiAgICBhc3luYyBnZXRCYWxhbmNlKCkge1xuICAgICAgICBpZiAoIV9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NkcFdhbGxldFByb3ZpZGVyX2NkcFdhbGxldCwgXCJmXCIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXYWxsZXQgbm90IGluaXRpYWxpemVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJhbGFuY2UgPSBhd2FpdCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DZHBXYWxsZXRQcm92aWRlcl9jZHBXYWxsZXQsIFwiZlwiKS5nZXRCYWxhbmNlKFwiZXRoXCIpO1xuICAgICAgICByZXR1cm4gQmlnSW50KGJhbGFuY2UubXVsKDEwICoqIDE4KS50b1N0cmluZygpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2FpdHMgZm9yIGEgdHJhbnNhY3Rpb24gcmVjZWlwdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0eEhhc2ggLSBUaGUgaGFzaCBvZiB0aGUgdHJhbnNhY3Rpb24gdG8gd2FpdCBmb3IuXG4gICAgICogQHJldHVybnMgVGhlIHRyYW5zYWN0aW9uIHJlY2VpcHQuXG4gICAgICovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBhc3luYyB3YWl0Rm9yVHJhbnNhY3Rpb25SZWNlaXB0KHR4SGFzaCkge1xuICAgICAgICByZXR1cm4gYXdhaXQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ2RwV2FsbGV0UHJvdmlkZXJfcHVibGljQ2xpZW50LCBcImZcIikud2FpdEZvclRyYW5zYWN0aW9uUmVjZWlwdCh7IGhhc2g6IHR4SGFzaCB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZHMgYSBjb250cmFjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyB0byByZWFkIHRoZSBjb250cmFjdC5cbiAgICAgKiBAcmV0dXJucyBUaGUgcmVzcG9uc2UgZnJvbSB0aGUgY29udHJhY3QuXG4gICAgICovXG4gICAgYXN5bmMgcmVhZENvbnRyYWN0KHBhcmFtcykge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ2RwV2FsbGV0UHJvdmlkZXJfcHVibGljQ2xpZW50LCBcImZcIikucmVhZENvbnRyYWN0KHBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSB0cmFkZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIHRoZSB0cmFkZS5cbiAgICAgKiBAcmV0dXJucyBUaGUgdHJhZGUuXG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlVHJhZGUob3B0aW9ucykge1xuICAgICAgICBpZiAoIV9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NkcFdhbGxldFByb3ZpZGVyX2NkcFdhbGxldCwgXCJmXCIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXYWxsZXQgbm90IGluaXRpYWxpemVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DZHBXYWxsZXRQcm92aWRlcl9jZHBXYWxsZXQsIFwiZlwiKS5jcmVhdGVUcmFkZShvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVwbG95cyBhIHRva2VuLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBmb3IgdGhlIHRva2VuIGRlcGxveW1lbnQuXG4gICAgICogQHJldHVybnMgVGhlIGRlcGxveWVkIHRva2VuLlxuICAgICAqL1xuICAgIGFzeW5jIGRlcGxveVRva2VuKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DZHBXYWxsZXRQcm92aWRlcl9jZHBXYWxsZXQsIFwiZlwiKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV2FsbGV0IG5vdCBpbml0aWFsaXplZFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ2RwV2FsbGV0UHJvdmlkZXJfY2RwV2FsbGV0LCBcImZcIikuZGVwbG95VG9rZW4ob3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlcGxveXMgYSBjb250cmFjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIGNvbnRyYWN0IGRlcGxveW1lbnRcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5zb2xpZGl0eVZlcnNpb24gLSBUaGUgdmVyc2lvbiBvZiB0aGUgU29saWRpdHkgY29tcGlsZXIgdG8gdXNlIChlLmcuIFwiMC44LjArY29tbWl0LmM3ZGZkNzhlXCIpXG4gICAgICogQHBhcmFtIG9wdGlvbnMuc29saWRpdHlJbnB1dEpzb24gLSBUaGUgSlNPTiBpbnB1dCBmb3IgdGhlIFNvbGlkaXR5IGNvbXBpbGVyIGNvbnRhaW5pbmcgY29udHJhY3Qgc291cmNlIGFuZCBzZXR0aW5nc1xuICAgICAqIEBwYXJhbSBvcHRpb25zLmNvbnRyYWN0TmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBjb250cmFjdCB0byBkZXBsb3lcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5jb25zdHJ1Y3RvckFyZ3MgLSBLZXktdmFsdWUgbWFwIG9mIGNvbnN0cnVjdG9yIGFyZ3NcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBkZXBsb3llZCBjb250cmFjdCBpbnN0YW5jZVxuICAgICAqIEB0aHJvd3MgRXJyb3IgaWYgd2FsbGV0IGlzIG5vdCBpbml0aWFsaXplZFxuICAgICAqL1xuICAgIGFzeW5jIGRlcGxveUNvbnRyYWN0KG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DZHBXYWxsZXRQcm92aWRlcl9jZHBXYWxsZXQsIFwiZlwiKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV2FsbGV0IG5vdCBpbml0aWFsaXplZFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ2RwV2FsbGV0UHJvdmlkZXJfY2RwV2FsbGV0LCBcImZcIikuZGVwbG95Q29udHJhY3Qob3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlcGxveXMgYSBuZXcgTkZUIChFUkMtNzIxKSBzbWFydCBjb250cmFjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gQ29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgTkZUIGNvbnRyYWN0IGRlcGxveW1lbnRcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5uYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGNvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5zeW1ib2wgLSBUaGUgdG9rZW4gc3ltYm9sIGZvciB0aGUgY29sbGVjdGlvblxuICAgICAqIEBwYXJhbSBvcHRpb25zLmJhc2VVUkkgLSBUaGUgYmFzZSBVUkkgZm9yIHRva2VuIG1ldGFkYXRhLlxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGRlcGxveWVkIFNtYXJ0Q29udHJhY3QgaW5zdGFuY2VcbiAgICAgKiBAdGhyb3dzIEVycm9yIGlmIHRoZSB3YWxsZXQgaXMgbm90IHByb3Blcmx5IGluaXRpYWxpemVkXG4gICAgICogQHRocm93cyBFcnJvciBpZiB0aGUgZGVwbG95bWVudCBmYWlscyBmb3IgYW55IHJlYXNvbiAobmV0d29yayBpc3N1ZXMsIGluc3VmZmljaWVudCBmdW5kcywgZXRjLilcbiAgICAgKi9cbiAgICBhc3luYyBkZXBsb3lORlQob3B0aW9ucykge1xuICAgICAgICBpZiAoIV9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NkcFdhbGxldFByb3ZpZGVyX2NkcFdhbGxldCwgXCJmXCIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXYWxsZXQgbm90IGluaXRpYWxpemVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DZHBXYWxsZXRQcm92aWRlcl9jZHBXYWxsZXQsIFwiZlwiKS5kZXBsb3lORlQob3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyYW5zZmVyIHRoZSBuYXRpdmUgYXNzZXQgb2YgdGhlIG5ldHdvcmsuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdG8gLSBUaGUgZGVzdGluYXRpb24gYWRkcmVzcy5cbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgYW1vdW50IHRvIHRyYW5zZmVyIGluIFdlaS5cbiAgICAgKiBAcmV0dXJucyBUaGUgdHJhbnNhY3Rpb24gaGFzaC5cbiAgICAgKi9cbiAgICBhc3luYyBuYXRpdmVUcmFuc2Zlcih0bywgdmFsdWUpIHtcbiAgICAgICAgaWYgKCFfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DZHBXYWxsZXRQcm92aWRlcl9jZHBXYWxsZXQsIFwiZlwiKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV2FsbGV0IG5vdCBpbml0aWFsaXplZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0cmFuc2ZlclJlc3VsdCA9IGF3YWl0IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NkcFdhbGxldFByb3ZpZGVyX2NkcFdhbGxldCwgXCJmXCIpLmNyZWF0ZVRyYW5zZmVyKHtcbiAgICAgICAgICAgIGFtb3VudDogbmV3IGRlY2ltYWxfanNfMS5EZWNpbWFsKHZhbHVlKSxcbiAgICAgICAgICAgIGFzc2V0SWQ6IGNvaW5iYXNlX3Nka18xLkNvaW5iYXNlLmFzc2V0cy5FdGgsXG4gICAgICAgICAgICBkZXN0aW5hdGlvbjogdG8sXG4gICAgICAgICAgICBnYXNsZXNzOiBmYWxzZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRyYW5zZmVyUmVzdWx0LndhaXQoKTtcbiAgICAgICAgaWYgKCFyZXN1bHQuZ2V0VHJhbnNhY3Rpb25IYXNoKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRyYW5zYWN0aW9uIGhhc2ggbm90IGZvdW5kXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQuZ2V0VHJhbnNhY3Rpb25IYXNoKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4cG9ydHMgdGhlIHdhbGxldC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSB3YWxsZXQncyBkYXRhLlxuICAgICAqL1xuICAgIGFzeW5jIGV4cG9ydFdhbGxldCgpIHtcbiAgICAgICAgaWYgKCFfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DZHBXYWxsZXRQcm92aWRlcl9jZHBXYWxsZXQsIFwiZlwiKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV2FsbGV0IG5vdCBpbml0aWFsaXplZFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ2RwV2FsbGV0UHJvdmlkZXJfY2RwV2FsbGV0LCBcImZcIikuZXhwb3J0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHdhbGxldC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSB3YWxsZXQuXG4gICAgICovXG4gICAgZ2V0V2FsbGV0KCkge1xuICAgICAgICBpZiAoIV9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NkcFdhbGxldFByb3ZpZGVyX2NkcFdhbGxldCwgXCJmXCIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXYWxsZXQgbm90IGluaXRpYWxpemVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DZHBXYWxsZXRQcm92aWRlcl9jZHBXYWxsZXQsIFwiZlwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRVJDMjAgdHJhbnNmZXIgbWV0aG9kXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXNzZXRJZCAtIFRoZSBhc3NldCBJRCB0byB0cmFuc2Zlci4gRWl0aGVyIFVTREMsIENCQlRDIG9yIEVVUkNcbiAgICAgKiBAcGFyYW0gZGVzdGluYXRpb24gLSBUaGUgZGVzdGluYXRpb24gYWRkcmVzc1xuICAgICAqIEBwYXJhbSBhbW91bnQgLSBUaGUgYW1vdW50IHRvIHRyYW5zZmVyXG4gICAgICogQHJldHVybnMgVGhlIHRyYW5zYWN0aW9uIGhhc2hcbiAgICAgKi9cbiAgICBhc3luYyBnYXNsZXNzRVJDMjBUcmFuc2Zlcihhc3NldElkLCBkZXN0aW5hdGlvbiwgYW1vdW50KSB7XG4gICAgICAgIGlmICghX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ2RwV2FsbGV0UHJvdmlkZXJfY2RwV2FsbGV0LCBcImZcIikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIldhbGxldCBub3QgaW5pdGlhbGl6ZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHJhbnNmZXJSZXN1bHQgPSBhd2FpdCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9DZHBXYWxsZXRQcm92aWRlcl9jZHBXYWxsZXQsIFwiZlwiKS5jcmVhdGVUcmFuc2Zlcih7XG4gICAgICAgICAgICBhbW91bnQsXG4gICAgICAgICAgICBhc3NldElkLFxuICAgICAgICAgICAgZGVzdGluYXRpb24sXG4gICAgICAgICAgICBnYXNsZXNzOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdHJhbnNmZXJSZXN1bHQud2FpdCgpO1xuICAgICAgICBpZiAoIXJlc3VsdC5nZXRUcmFuc2FjdGlvbkhhc2goKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVHJhbnNhY3Rpb24gaGFzaCBub3QgZm91bmRcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdC5nZXRUcmFuc2FjdGlvbkhhc2goKTtcbiAgICB9XG59XG5leHBvcnRzLkNkcFdhbGxldFByb3ZpZGVyID0gQ2RwV2FsbGV0UHJvdmlkZXI7XG5fQ2RwV2FsbGV0UHJvdmlkZXJfY2RwV2FsbGV0ID0gbmV3IFdlYWtNYXAoKSwgX0NkcFdhbGxldFByb3ZpZGVyX2FkZHJlc3MgPSBuZXcgV2Vha01hcCgpLCBfQ2RwV2FsbGV0UHJvdmlkZXJfbmV0d29yayA9IG5ldyBXZWFrTWFwKCksIF9DZHBXYWxsZXRQcm92aWRlcl9wdWJsaWNDbGllbnQgPSBuZXcgV2Vha01hcCgpLCBfQ2RwV2FsbGV0UHJvdmlkZXJfZ2FzTGltaXRNdWx0aXBsaWVyID0gbmV3IFdlYWtNYXAoKSwgX0NkcFdhbGxldFByb3ZpZGVyX2ZlZVBlckdhc011bHRpcGxpZXIgPSBuZXcgV2Vha01hcCgpLCBfQ2RwV2FsbGV0UHJvdmlkZXJfdHJhbnNhY3Rpb25RdWV1ZSA9IG5ldyBXZWFrTWFwKCk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/wallet-providers/cdpWalletProvider.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/wallet-providers/evmWalletProvider.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/wallet-providers/evmWalletProvider.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n// TODO: Improve type safety\n/* eslint-disable @typescript-eslint/no-explicit-any */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EvmWalletProvider = void 0;\nconst walletProvider_1 = __webpack_require__(/*! ./walletProvider */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/wallet-providers/walletProvider.js\");\n/**\n * EvmWalletProvider is the abstract base class for all EVM wallet providers.\n *\n * @abstract\n */\nclass EvmWalletProvider extends walletProvider_1.WalletProvider {\n}\nexports.EvmWalletProvider = EvmWalletProvider;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3Qvd2FsbGV0LXByb3ZpZGVycy9ldm1XYWxsZXRQcm92aWRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QseUJBQXlCO0FBQ3pCLHlCQUF5QixtQkFBTyxDQUFDLHlHQUFrQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QiIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cnZpdmFsLWZ1bi8uL25vZGVfbW9kdWxlcy9AY29pbmJhc2UvYWdlbnRraXQvZGlzdC93YWxsZXQtcHJvdmlkZXJzL2V2bVdhbGxldFByb3ZpZGVyLmpzP2M0ZGEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBUT0RPOiBJbXByb3ZlIHR5cGUgc2FmZXR5XG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkV2bVdhbGxldFByb3ZpZGVyID0gdm9pZCAwO1xuY29uc3Qgd2FsbGV0UHJvdmlkZXJfMSA9IHJlcXVpcmUoXCIuL3dhbGxldFByb3ZpZGVyXCIpO1xuLyoqXG4gKiBFdm1XYWxsZXRQcm92aWRlciBpcyB0aGUgYWJzdHJhY3QgYmFzZSBjbGFzcyBmb3IgYWxsIEVWTSB3YWxsZXQgcHJvdmlkZXJzLlxuICpcbiAqIEBhYnN0cmFjdFxuICovXG5jbGFzcyBFdm1XYWxsZXRQcm92aWRlciBleHRlbmRzIHdhbGxldFByb3ZpZGVyXzEuV2FsbGV0UHJvdmlkZXIge1xufVxuZXhwb3J0cy5Fdm1XYWxsZXRQcm92aWRlciA9IEV2bVdhbGxldFByb3ZpZGVyO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/wallet-providers/evmWalletProvider.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/wallet-providers/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/wallet-providers/index.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./walletProvider */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/wallet-providers/walletProvider.js\"), exports);\n__exportStar(__webpack_require__(/*! ./evmWalletProvider */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/wallet-providers/evmWalletProvider.js\"), exports);\n__exportStar(__webpack_require__(/*! ./viemWalletProvider */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/wallet-providers/viemWalletProvider.js\"), exports);\n__exportStar(__webpack_require__(/*! ./cdpWalletProvider */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/wallet-providers/cdpWalletProvider.js\"), exports);\n__exportStar(__webpack_require__(/*! ./svmWalletProvider */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/wallet-providers/svmWalletProvider.js\"), exports);\n__exportStar(__webpack_require__(/*! ./smartWalletProvider */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/wallet-providers/smartWalletProvider.js\"), exports);\n__exportStar(__webpack_require__(/*! ./solanaKeypairWalletProvider */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/wallet-providers/solanaKeypairWalletProvider.js\"), exports);\n__exportStar(__webpack_require__(/*! ./privyWalletProvider */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/wallet-providers/privyWalletProvider.js\"), exports);\n__exportStar(__webpack_require__(/*! ./privyEvmWalletProvider */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/wallet-providers/privyEvmWalletProvider.js\"), exports);\n__exportStar(__webpack_require__(/*! ./privySvmWalletProvider */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/wallet-providers/privySvmWalletProvider.js\"), exports);\n__exportStar(__webpack_require__(/*! ./privyEvmDelegatedEmbeddedWalletProvider */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/wallet-providers/privyEvmDelegatedEmbeddedWalletProvider.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3Qvd2FsbGV0LXByb3ZpZGVycy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxhQUFhLG1CQUFPLENBQUMseUdBQWtCO0FBQ3ZDLGFBQWEsbUJBQU8sQ0FBQywrR0FBcUI7QUFDMUMsYUFBYSxtQkFBTyxDQUFDLGlIQUFzQjtBQUMzQyxhQUFhLG1CQUFPLENBQUMsK0dBQXFCO0FBQzFDLGFBQWEsbUJBQU8sQ0FBQywrR0FBcUI7QUFDMUMsYUFBYSxtQkFBTyxDQUFDLG1IQUF1QjtBQUM1QyxhQUFhLG1CQUFPLENBQUMsbUlBQStCO0FBQ3BELGFBQWEsbUJBQU8sQ0FBQyxtSEFBdUI7QUFDNUMsYUFBYSxtQkFBTyxDQUFDLHlIQUEwQjtBQUMvQyxhQUFhLG1CQUFPLENBQUMseUhBQTBCO0FBQy9DLGFBQWEsbUJBQU8sQ0FBQywySkFBMkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXJ2aXZhbC1mdW4vLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3Qvd2FsbGV0LXByb3ZpZGVycy9pbmRleC5qcz83YzAzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vd2FsbGV0UHJvdmlkZXJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2V2bVdhbGxldFByb3ZpZGVyXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi92aWVtV2FsbGV0UHJvdmlkZXJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NkcFdhbGxldFByb3ZpZGVyXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9zdm1XYWxsZXRQcm92aWRlclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc21hcnRXYWxsZXRQcm92aWRlclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc29sYW5hS2V5cGFpcldhbGxldFByb3ZpZGVyXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9wcml2eVdhbGxldFByb3ZpZGVyXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9wcml2eUV2bVdhbGxldFByb3ZpZGVyXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9wcml2eVN2bVdhbGxldFByb3ZpZGVyXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9wcml2eUV2bURlbGVnYXRlZEVtYmVkZGVkV2FsbGV0UHJvdmlkZXJcIiksIGV4cG9ydHMpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/wallet-providers/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/wallet-providers/privyEvmDelegatedEmbeddedWalletProvider.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/wallet-providers/privyEvmDelegatedEmbeddedWalletProvider.js ***!
  \**********************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nvar _PrivyEvmDelegatedEmbeddedWalletProvider_walletId, _PrivyEvmDelegatedEmbeddedWalletProvider_address, _PrivyEvmDelegatedEmbeddedWalletProvider_appId, _PrivyEvmDelegatedEmbeddedWalletProvider_appSecret, _PrivyEvmDelegatedEmbeddedWalletProvider_authKey, _PrivyEvmDelegatedEmbeddedWalletProvider_network, _PrivyEvmDelegatedEmbeddedWalletProvider_publicClient;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PrivyEvmDelegatedEmbeddedWalletProvider = void 0;\nconst canonicalize_1 = __importDefault(__webpack_require__(/*! canonicalize */ \"(rsc)/./node_modules/canonicalize/lib/canonicalize.js\"));\nconst crypto_1 = __importDefault(__webpack_require__(/*! crypto */ \"crypto\"));\nconst viem_1 = __webpack_require__(/*! viem */ \"(rsc)/./node_modules/viem/_cjs/index.js\");\nconst network_1 = __webpack_require__(/*! ../network/network */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/network/network.js\");\nconst privyShared_1 = __webpack_require__(/*! ./privyShared */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/wallet-providers/privyShared.js\");\nconst walletProvider_1 = __webpack_require__(/*! ./walletProvider */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/wallet-providers/walletProvider.js\");\n/**\n * A wallet provider that uses Privy's embedded wallets with delegation.\n * This provider extends the EvmWalletProvider to provide Privy-specific wallet functionality\n * while maintaining compatibility with the base wallet provider interface.\n */\nclass PrivyEvmDelegatedEmbeddedWalletProvider extends walletProvider_1.WalletProvider {\n    /**\n     * Private constructor to enforce use of factory method.\n     *\n     * @param config - The configuration options for the wallet provider\n     */\n    constructor(config) {\n        super();\n        _PrivyEvmDelegatedEmbeddedWalletProvider_walletId.set(this, void 0);\n        _PrivyEvmDelegatedEmbeddedWalletProvider_address.set(this, void 0);\n        _PrivyEvmDelegatedEmbeddedWalletProvider_appId.set(this, void 0);\n        _PrivyEvmDelegatedEmbeddedWalletProvider_appSecret.set(this, void 0);\n        _PrivyEvmDelegatedEmbeddedWalletProvider_authKey.set(this, void 0);\n        _PrivyEvmDelegatedEmbeddedWalletProvider_network.set(this, void 0);\n        _PrivyEvmDelegatedEmbeddedWalletProvider_publicClient.set(this, void 0);\n        __classPrivateFieldSet(this, _PrivyEvmDelegatedEmbeddedWalletProvider_walletId, config.walletId, \"f\");\n        __classPrivateFieldSet(this, _PrivyEvmDelegatedEmbeddedWalletProvider_address, config.address, \"f\");\n        __classPrivateFieldSet(this, _PrivyEvmDelegatedEmbeddedWalletProvider_appId, config.appId, \"f\");\n        __classPrivateFieldSet(this, _PrivyEvmDelegatedEmbeddedWalletProvider_appSecret, config.appSecret, \"f\");\n        __classPrivateFieldSet(this, _PrivyEvmDelegatedEmbeddedWalletProvider_authKey, config.authorizationPrivateKey || \"\", \"f\");\n        const networkId = config.networkId || \"base-sepolia\";\n        const chainId = config.chainId || network_1.NETWORK_ID_TO_CHAIN_ID[networkId];\n        __classPrivateFieldSet(this, _PrivyEvmDelegatedEmbeddedWalletProvider_network, {\n            protocolFamily: \"evm\",\n            networkId: networkId,\n            chainId: chainId,\n        }, \"f\");\n        // Create a public client for read operations\n        const chain = (0, network_1.getChain)(chainId);\n        if (!chain) {\n            throw new Error(`Chain with ID ${chainId} not found`);\n        }\n        __classPrivateFieldSet(this, _PrivyEvmDelegatedEmbeddedWalletProvider_publicClient, (0, viem_1.createPublicClient)({\n            chain,\n            transport: (0, viem_1.http)(),\n        }), \"f\");\n    }\n    /**\n     * Creates and configures a new PrivyEvmDelegatedEmbeddedWalletProvider instance.\n     *\n     * @param config - The configuration options for the Privy wallet\n     * @returns A configured PrivyEvmDelegatedEmbeddedWalletProvider instance\n     *\n     * @example\n     * ```typescript\n     * const provider = await PrivyEvmDelegatedEmbeddedWalletProvider.configureWithWallet({\n     *   appId: \"your-app-id\",\n     *   appSecret: \"your-app-secret\",\n     *   authorizationPrivateKey: \"your-auth-key\",\n     *   walletId: \"privy-wallet-id\",\n     *   networkId: \"base-mainnet\"\n     * });\n     * ```\n     */\n    static async configureWithWallet(config) {\n        try {\n            if (!config.walletId) {\n                throw new Error(\"walletId is required for PrivyEvmDelegatedEmbeddedWalletProvider\");\n            }\n            if (!config.appId || !config.appSecret) {\n                throw new Error(\"appId and appSecret are required for PrivyEvmDelegatedEmbeddedWalletProvider\");\n            }\n            if (!config.authorizationPrivateKey) {\n                throw new Error(\"authorizationPrivateKey is required for PrivyEvmDelegatedEmbeddedWalletProvider\");\n            }\n            const privyClient = (0, privyShared_1.createPrivyClient)(config);\n            const user = await privyClient.getUser(config.walletId);\n            const embeddedWallets = user.linkedAccounts.filter((account) => account.type === \"wallet\" && account.walletClientType === \"privy\");\n            if (embeddedWallets.length === 0) {\n                throw new Error(`Could not find wallet address for wallet ID ${config.walletId}`);\n            }\n            const walletAddress = embeddedWallets[0].address;\n            // Verify the network/chain ID if provided\n            if (config.chainId) {\n                const chain = (0, network_1.getChain)(config.chainId);\n                if (!chain) {\n                    throw new Error(`Chain with ID ${config.chainId} not found`);\n                }\n            }\n            return new PrivyEvmDelegatedEmbeddedWalletProvider({\n                ...config,\n                address: walletAddress,\n            });\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                throw new Error(`Failed to configure Privy embedded wallet provider: ${error.message}`);\n            }\n            throw new Error(\"Failed to configure Privy embedded wallet provider\");\n        }\n    }\n    /**\n     * Gets the address of the wallet.\n     *\n     * @returns The address of the wallet.\n     */\n    getAddress() {\n        return __classPrivateFieldGet(this, _PrivyEvmDelegatedEmbeddedWalletProvider_address, \"f\");\n    }\n    /**\n     * Gets the network of the wallet.\n     *\n     * @returns The network of the wallet.\n     */\n    getNetwork() {\n        return __classPrivateFieldGet(this, _PrivyEvmDelegatedEmbeddedWalletProvider_network, \"f\");\n    }\n    /**\n     * Gets the name of the wallet provider.\n     *\n     * @returns The name of the wallet provider.\n     */\n    getName() {\n        return \"privy_evm_embedded_wallet_provider\";\n    }\n    /**\n     * Gets the balance of the wallet.\n     *\n     * @returns The balance of the wallet in wei\n     */\n    async getBalance() {\n        try {\n            const balance = await __classPrivateFieldGet(this, _PrivyEvmDelegatedEmbeddedWalletProvider_publicClient, \"f\").getBalance({\n                address: __classPrivateFieldGet(this, _PrivyEvmDelegatedEmbeddedWalletProvider_address, \"f\"),\n            });\n            return balance;\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                throw new Error(`Error getting balance: ${error.message}`);\n            }\n            throw new Error(\"Error getting balance\");\n        }\n    }\n    /**\n     * Signs a message.\n     *\n     * @param message - The message to sign.\n     * @returns The signed message.\n     */\n    async signMessage(message) {\n        const body = {\n            address: __classPrivateFieldGet(this, _PrivyEvmDelegatedEmbeddedWalletProvider_address, \"f\"),\n            chain_type: \"ethereum\",\n            method: \"personal_sign\",\n            params: {\n                message,\n                encoding: \"utf-8\",\n            },\n        };\n        try {\n            const response = await this.executePrivyRequest(body);\n            return response.data?.signature;\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                throw new Error(`Message signing failed: ${error.message}`);\n            }\n            throw new Error(\"Message signing failed\");\n        }\n    }\n    /**\n     * Signs typed data according to EIP-712.\n     *\n     * @param typedData - The typed data object to sign\n     * @param typedData.domain - The domain object containing contract and chain information\n     * @param typedData.types - The type definitions for the structured data\n     * @param typedData.primaryType - The primary type being signed\n     * @param typedData.message - The actual data to sign\n     * @returns A Address that resolves to the signed typed data as a hex string\n     */\n    async signTypedData(typedData) {\n        const body = {\n            address: __classPrivateFieldGet(this, _PrivyEvmDelegatedEmbeddedWalletProvider_address, \"f\"),\n            chain_type: \"ethereum\",\n            chain_id: __classPrivateFieldGet(this, _PrivyEvmDelegatedEmbeddedWalletProvider_network, \"f\").chainId,\n            ...typedData,\n        };\n        try {\n            const response = await this.executePrivyRequest({\n                method: \"eth_signTypedData_v4\",\n                params: body,\n            });\n            return response.signature;\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                throw new Error(\"Typed data signing failed: \" + error.message);\n            }\n            throw new Error(\"Typed data signing failed with unknown error\");\n        }\n    }\n    /**\n     * Signs a transaction.\n     *\n     * @param transaction - The transaction to sign.\n     * @returns The signed transaction.\n     */\n    async signTransaction(transaction) {\n        const body = {\n            address: __classPrivateFieldGet(this, _PrivyEvmDelegatedEmbeddedWalletProvider_address, \"f\"),\n            chain_type: \"ethereum\",\n            method: \"eth_signTransaction\",\n            params: {\n                transaction: {\n                    ...transaction,\n                    from: __classPrivateFieldGet(this, _PrivyEvmDelegatedEmbeddedWalletProvider_address, \"f\"),\n                },\n            },\n        };\n        try {\n            const response = await this.executePrivyRequest(body);\n            return response.data?.signed_transaction;\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                throw new Error(`Transaction signing failed: ${error.message}`);\n            }\n            throw new Error(\"Transaction signing failed\");\n        }\n    }\n    /**\n     * Sends a transaction.\n     *\n     * @param transaction - The transaction to send.\n     * @returns The hash of the transaction.\n     */\n    async sendTransaction(transaction) {\n        const body = {\n            address: __classPrivateFieldGet(this, _PrivyEvmDelegatedEmbeddedWalletProvider_address, \"f\"),\n            chain_type: \"ethereum\",\n            method: \"eth_sendTransaction\",\n            caip2: `eip155:${__classPrivateFieldGet(this, _PrivyEvmDelegatedEmbeddedWalletProvider_network, \"f\").chainId}`,\n            params: {\n                transaction: {\n                    ...transaction,\n                    from: __classPrivateFieldGet(this, _PrivyEvmDelegatedEmbeddedWalletProvider_address, \"f\"),\n                },\n            },\n        };\n        try {\n            const response = await this.executePrivyRequest(body);\n            return response.data?.hash;\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                throw new Error(`Transaction sending failed: ${error.message}`);\n            }\n            throw new Error(\"Transaction sending failed\");\n        }\n    }\n    /**\n     * Waits for a transaction receipt.\n     *\n     * @param txHash - The hash of the transaction to wait for.\n     * @returns The transaction receipt.\n     */\n    async waitForTransactionReceipt(txHash) {\n        return await __classPrivateFieldGet(this, _PrivyEvmDelegatedEmbeddedWalletProvider_publicClient, \"f\").waitForTransactionReceipt({\n            hash: txHash,\n        });\n    }\n    /**\n     * Reads data from a smart contract.\n     *\n     * @param params - Parameters for reading the contract\n     * @param params.address - The address of the contract\n     * @param params.abi - The ABI of the contract\n     * @param params.functionName - The name of the function to call\n     * @param params.args - The arguments to pass to the function\n     * @returns A Address that resolves to the contract function's return value\n     */\n    async readContract(params) {\n        return __classPrivateFieldGet(this, _PrivyEvmDelegatedEmbeddedWalletProvider_publicClient, \"f\").readContract(params);\n    }\n    /**\n     * Transfer the native asset of the network.\n     *\n     * @param to - The destination address.\n     * @param value - The amount to transfer in Wei.\n     * @returns The transaction hash.\n     */\n    async nativeTransfer(to, value) {\n        const valueInWei = (0, viem_1.parseEther)(value);\n        const valueHex = `0x${valueInWei.toString(16)}`;\n        const body = {\n            address: __classPrivateFieldGet(this, _PrivyEvmDelegatedEmbeddedWalletProvider_address, \"f\"),\n            chain_type: \"ethereum\",\n            method: \"eth_sendTransaction\",\n            caip2: `eip155:${__classPrivateFieldGet(this, _PrivyEvmDelegatedEmbeddedWalletProvider_network, \"f\").chainId}`,\n            params: {\n                transaction: {\n                    to,\n                    value: valueHex,\n                },\n            },\n        };\n        try {\n            const response = await this.executePrivyRequest(body);\n            const receipt = await this.waitForTransactionReceipt(response.data.hash);\n            if (!receipt) {\n                throw new Error(\"Transaction failed\");\n            }\n            return receipt.transactionHash;\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                throw new Error(`Native transfer failed: ${error.message}`);\n            }\n            throw new Error(\"Native transfer failed\");\n        }\n    }\n    /**\n     * Exports the wallet information.\n     *\n     * @returns The wallet data\n     */\n    exportWallet() {\n        return {\n            walletId: __classPrivateFieldGet(this, _PrivyEvmDelegatedEmbeddedWalletProvider_walletId, \"f\"),\n            authorizationPrivateKey: __classPrivateFieldGet(this, _PrivyEvmDelegatedEmbeddedWalletProvider_authKey, \"f\"),\n            networkId: __classPrivateFieldGet(this, _PrivyEvmDelegatedEmbeddedWalletProvider_network, \"f\").networkId,\n            chainId: __classPrivateFieldGet(this, _PrivyEvmDelegatedEmbeddedWalletProvider_network, \"f\").chainId,\n        };\n    }\n    /**\n     * Generate Privy authorization signature for API requests\n     *\n     * @param url - The URL for the request\n     * @param body - The request body\n     * @returns The generated signature\n     */\n    generatePrivySignature(url, body) {\n        try {\n            const payload = {\n                version: 1,\n                method: \"POST\",\n                url,\n                body,\n                headers: {\n                    \"privy-app-id\": __classPrivateFieldGet(this, _PrivyEvmDelegatedEmbeddedWalletProvider_appId, \"f\"),\n                },\n            };\n            const serializedPayload = (0, canonicalize_1.default)(payload);\n            if (!serializedPayload)\n                throw new Error(\"Failed to canonicalize payload\");\n            const serializedPayloadBuffer = Buffer.from(serializedPayload);\n            const privateKeyAsString = __classPrivateFieldGet(this, _PrivyEvmDelegatedEmbeddedWalletProvider_authKey, \"f\").replace(\"wallet-auth:\", \"\");\n            const privateKeyAsPem = `-----BEGIN PRIVATE KEY-----\\n${privateKeyAsString}\\n-----END PRIVATE KEY-----`;\n            const privateKey = crypto_1.default.createPrivateKey({\n                key: privateKeyAsPem,\n                format: \"pem\",\n            });\n            const signatureBuffer = crypto_1.default.sign(\"sha256\", serializedPayloadBuffer, privateKey);\n            return signatureBuffer.toString(\"base64\");\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                throw new Error(`Error generating Privy authorization signature: ${error.message}`);\n            }\n            throw new Error(\"Error generating Privy authorization signature\");\n        }\n    }\n    /**\n     * Get Privy headers for API requests\n     *\n     * @param url - The URL for the request\n     * @param body - The request body\n     * @returns The headers for the request\n     */\n    getPrivyHeaders(url, body) {\n        return {\n            \"Content-Type\": \"application/json\",\n            Authorization: `Basic ${Buffer.from(`${__classPrivateFieldGet(this, _PrivyEvmDelegatedEmbeddedWalletProvider_appId, \"f\")}:${__classPrivateFieldGet(this, _PrivyEvmDelegatedEmbeddedWalletProvider_appSecret, \"f\")}`).toString(\"base64\")}`,\n            \"privy-app-id\": __classPrivateFieldGet(this, _PrivyEvmDelegatedEmbeddedWalletProvider_appId, \"f\"),\n            \"privy-authorization-signature\": this.generatePrivySignature(url, body),\n        };\n    }\n    /**\n     * Execute a Privy API request.\n     *\n     * @param body - The request body to send to the Privy API\n     * @returns A promise that resolves to the response data\n     * @throws Error if the request fails\n     */\n    async executePrivyRequest(body) {\n        const url = `https://api.privy.io/v1/wallets/rpc`;\n        const headers = this.getPrivyHeaders(url, body);\n        try {\n            const response = await fetch(url, {\n                method: \"POST\",\n                headers,\n                body: JSON.stringify(body, (_key, value) => typeof value === \"bigint\" ? value.toString() : value),\n            });\n            if (!response.ok) {\n                throw new Error(`HTTP error! status: ${response.status}`);\n            }\n            return await response.json();\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                throw new Error(\"Privy request failed: \" + error.message);\n            }\n            throw new Error(\"Privy request failed with unknown error\");\n        }\n    }\n}\nexports.PrivyEvmDelegatedEmbeddedWalletProvider = PrivyEvmDelegatedEmbeddedWalletProvider;\n_PrivyEvmDelegatedEmbeddedWalletProvider_walletId = new WeakMap(), _PrivyEvmDelegatedEmbeddedWalletProvider_address = new WeakMap(), _PrivyEvmDelegatedEmbeddedWalletProvider_appId = new WeakMap(), _PrivyEvmDelegatedEmbeddedWalletProvider_appSecret = new WeakMap(), _PrivyEvmDelegatedEmbeddedWalletProvider_authKey = new WeakMap(), _PrivyEvmDelegatedEmbeddedWalletProvider_network = new WeakMap(), _PrivyEvmDelegatedEmbeddedWalletProvider_publicClient = new WeakMap();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3Qvd2FsbGV0LXByb3ZpZGVycy9wcml2eUV2bURlbGVnYXRlZEVtYmVkZGVkV2FsbGV0UHJvdmlkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwrQ0FBK0M7QUFDL0MsdUNBQXVDLG1CQUFPLENBQUMsMkVBQWM7QUFDN0QsaUNBQWlDLG1CQUFPLENBQUMsc0JBQVE7QUFDakQsZUFBZSxtQkFBTyxDQUFDLHFEQUFNO0FBQzdCLGtCQUFrQixtQkFBTyxDQUFDLDJGQUFvQjtBQUM5QyxzQkFBc0IsbUJBQU8sQ0FBQyxtR0FBZTtBQUM3Qyx5QkFBeUIsbUJBQU8sQ0FBQyx5R0FBa0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFNBQVM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0UsZ0JBQWdCO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxnQkFBZ0I7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSx1RkFBdUYsY0FBYztBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxjQUFjO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxjQUFjO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsY0FBYztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNEZBQTRGO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxjQUFjO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsd0JBQXdCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDRGQUE0RjtBQUN6SDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxjQUFjO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsbUJBQW1CO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GLGNBQWM7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxlQUFlLGtGQUFrRixHQUFHLHNGQUFzRixzQkFBc0I7QUFDcFA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSx1REFBdUQsZ0JBQWdCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXJ2aXZhbC1mdW4vLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3Qvd2FsbGV0LXByb3ZpZGVycy9wcml2eUV2bURlbGVnYXRlZEVtYmVkZGVkV2FsbGV0UHJvdmlkZXIuanM/YTlhNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcbn07XG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZEdldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZEdldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbnZhciBfUHJpdnlFdm1EZWxlZ2F0ZWRFbWJlZGRlZFdhbGxldFByb3ZpZGVyX3dhbGxldElkLCBfUHJpdnlFdm1EZWxlZ2F0ZWRFbWJlZGRlZFdhbGxldFByb3ZpZGVyX2FkZHJlc3MsIF9Qcml2eUV2bURlbGVnYXRlZEVtYmVkZGVkV2FsbGV0UHJvdmlkZXJfYXBwSWQsIF9Qcml2eUV2bURlbGVnYXRlZEVtYmVkZGVkV2FsbGV0UHJvdmlkZXJfYXBwU2VjcmV0LCBfUHJpdnlFdm1EZWxlZ2F0ZWRFbWJlZGRlZFdhbGxldFByb3ZpZGVyX2F1dGhLZXksIF9Qcml2eUV2bURlbGVnYXRlZEVtYmVkZGVkV2FsbGV0UHJvdmlkZXJfbmV0d29yaywgX1ByaXZ5RXZtRGVsZWdhdGVkRW1iZWRkZWRXYWxsZXRQcm92aWRlcl9wdWJsaWNDbGllbnQ7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlByaXZ5RXZtRGVsZWdhdGVkRW1iZWRkZWRXYWxsZXRQcm92aWRlciA9IHZvaWQgMDtcbmNvbnN0IGNhbm9uaWNhbGl6ZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJjYW5vbmljYWxpemVcIikpO1xuY29uc3QgY3J5cHRvXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImNyeXB0b1wiKSk7XG5jb25zdCB2aWVtXzEgPSByZXF1aXJlKFwidmllbVwiKTtcbmNvbnN0IG5ldHdvcmtfMSA9IHJlcXVpcmUoXCIuLi9uZXR3b3JrL25ldHdvcmtcIik7XG5jb25zdCBwcml2eVNoYXJlZF8xID0gcmVxdWlyZShcIi4vcHJpdnlTaGFyZWRcIik7XG5jb25zdCB3YWxsZXRQcm92aWRlcl8xID0gcmVxdWlyZShcIi4vd2FsbGV0UHJvdmlkZXJcIik7XG4vKipcbiAqIEEgd2FsbGV0IHByb3ZpZGVyIHRoYXQgdXNlcyBQcml2eSdzIGVtYmVkZGVkIHdhbGxldHMgd2l0aCBkZWxlZ2F0aW9uLlxuICogVGhpcyBwcm92aWRlciBleHRlbmRzIHRoZSBFdm1XYWxsZXRQcm92aWRlciB0byBwcm92aWRlIFByaXZ5LXNwZWNpZmljIHdhbGxldCBmdW5jdGlvbmFsaXR5XG4gKiB3aGlsZSBtYWludGFpbmluZyBjb21wYXRpYmlsaXR5IHdpdGggdGhlIGJhc2Ugd2FsbGV0IHByb3ZpZGVyIGludGVyZmFjZS5cbiAqL1xuY2xhc3MgUHJpdnlFdm1EZWxlZ2F0ZWRFbWJlZGRlZFdhbGxldFByb3ZpZGVyIGV4dGVuZHMgd2FsbGV0UHJvdmlkZXJfMS5XYWxsZXRQcm92aWRlciB7XG4gICAgLyoqXG4gICAgICogUHJpdmF0ZSBjb25zdHJ1Y3RvciB0byBlbmZvcmNlIHVzZSBvZiBmYWN0b3J5IG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb25maWcgLSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgd2FsbGV0IHByb3ZpZGVyXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIF9Qcml2eUV2bURlbGVnYXRlZEVtYmVkZGVkV2FsbGV0UHJvdmlkZXJfd2FsbGV0SWQuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9Qcml2eUV2bURlbGVnYXRlZEVtYmVkZGVkV2FsbGV0UHJvdmlkZXJfYWRkcmVzcy5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX1ByaXZ5RXZtRGVsZWdhdGVkRW1iZWRkZWRXYWxsZXRQcm92aWRlcl9hcHBJZC5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX1ByaXZ5RXZtRGVsZWdhdGVkRW1iZWRkZWRXYWxsZXRQcm92aWRlcl9hcHBTZWNyZXQuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9Qcml2eUV2bURlbGVnYXRlZEVtYmVkZGVkV2FsbGV0UHJvdmlkZXJfYXV0aEtleS5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX1ByaXZ5RXZtRGVsZWdhdGVkRW1iZWRkZWRXYWxsZXRQcm92aWRlcl9uZXR3b3JrLnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICBfUHJpdnlFdm1EZWxlZ2F0ZWRFbWJlZGRlZFdhbGxldFByb3ZpZGVyX3B1YmxpY0NsaWVudC5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfUHJpdnlFdm1EZWxlZ2F0ZWRFbWJlZGRlZFdhbGxldFByb3ZpZGVyX3dhbGxldElkLCBjb25maWcud2FsbGV0SWQsIFwiZlwiKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfUHJpdnlFdm1EZWxlZ2F0ZWRFbWJlZGRlZFdhbGxldFByb3ZpZGVyX2FkZHJlc3MsIGNvbmZpZy5hZGRyZXNzLCBcImZcIik7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX1ByaXZ5RXZtRGVsZWdhdGVkRW1iZWRkZWRXYWxsZXRQcm92aWRlcl9hcHBJZCwgY29uZmlnLmFwcElkLCBcImZcIik7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX1ByaXZ5RXZtRGVsZWdhdGVkRW1iZWRkZWRXYWxsZXRQcm92aWRlcl9hcHBTZWNyZXQsIGNvbmZpZy5hcHBTZWNyZXQsIFwiZlwiKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfUHJpdnlFdm1EZWxlZ2F0ZWRFbWJlZGRlZFdhbGxldFByb3ZpZGVyX2F1dGhLZXksIGNvbmZpZy5hdXRob3JpemF0aW9uUHJpdmF0ZUtleSB8fCBcIlwiLCBcImZcIik7XG4gICAgICAgIGNvbnN0IG5ldHdvcmtJZCA9IGNvbmZpZy5uZXR3b3JrSWQgfHwgXCJiYXNlLXNlcG9saWFcIjtcbiAgICAgICAgY29uc3QgY2hhaW5JZCA9IGNvbmZpZy5jaGFpbklkIHx8IG5ldHdvcmtfMS5ORVRXT1JLX0lEX1RPX0NIQUlOX0lEW25ldHdvcmtJZF07XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX1ByaXZ5RXZtRGVsZWdhdGVkRW1iZWRkZWRXYWxsZXRQcm92aWRlcl9uZXR3b3JrLCB7XG4gICAgICAgICAgICBwcm90b2NvbEZhbWlseTogXCJldm1cIixcbiAgICAgICAgICAgIG5ldHdvcmtJZDogbmV0d29ya0lkLFxuICAgICAgICAgICAgY2hhaW5JZDogY2hhaW5JZCxcbiAgICAgICAgfSwgXCJmXCIpO1xuICAgICAgICAvLyBDcmVhdGUgYSBwdWJsaWMgY2xpZW50IGZvciByZWFkIG9wZXJhdGlvbnNcbiAgICAgICAgY29uc3QgY2hhaW4gPSAoMCwgbmV0d29ya18xLmdldENoYWluKShjaGFpbklkKTtcbiAgICAgICAgaWYgKCFjaGFpbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDaGFpbiB3aXRoIElEICR7Y2hhaW5JZH0gbm90IGZvdW5kYCk7XG4gICAgICAgIH1cbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfUHJpdnlFdm1EZWxlZ2F0ZWRFbWJlZGRlZFdhbGxldFByb3ZpZGVyX3B1YmxpY0NsaWVudCwgKDAsIHZpZW1fMS5jcmVhdGVQdWJsaWNDbGllbnQpKHtcbiAgICAgICAgICAgIGNoYWluLFxuICAgICAgICAgICAgdHJhbnNwb3J0OiAoMCwgdmllbV8xLmh0dHApKCksXG4gICAgICAgIH0pLCBcImZcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW5kIGNvbmZpZ3VyZXMgYSBuZXcgUHJpdnlFdm1EZWxlZ2F0ZWRFbWJlZGRlZFdhbGxldFByb3ZpZGVyIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbmZpZyAtIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBQcml2eSB3YWxsZXRcbiAgICAgKiBAcmV0dXJucyBBIGNvbmZpZ3VyZWQgUHJpdnlFdm1EZWxlZ2F0ZWRFbWJlZGRlZFdhbGxldFByb3ZpZGVyIGluc3RhbmNlXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCBwcm92aWRlciA9IGF3YWl0IFByaXZ5RXZtRGVsZWdhdGVkRW1iZWRkZWRXYWxsZXRQcm92aWRlci5jb25maWd1cmVXaXRoV2FsbGV0KHtcbiAgICAgKiAgIGFwcElkOiBcInlvdXItYXBwLWlkXCIsXG4gICAgICogICBhcHBTZWNyZXQ6IFwieW91ci1hcHAtc2VjcmV0XCIsXG4gICAgICogICBhdXRob3JpemF0aW9uUHJpdmF0ZUtleTogXCJ5b3VyLWF1dGgta2V5XCIsXG4gICAgICogICB3YWxsZXRJZDogXCJwcml2eS13YWxsZXQtaWRcIixcbiAgICAgKiAgIG5ldHdvcmtJZDogXCJiYXNlLW1haW5uZXRcIlxuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyBjb25maWd1cmVXaXRoV2FsbGV0KGNvbmZpZykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCFjb25maWcud2FsbGV0SWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ3YWxsZXRJZCBpcyByZXF1aXJlZCBmb3IgUHJpdnlFdm1EZWxlZ2F0ZWRFbWJlZGRlZFdhbGxldFByb3ZpZGVyXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjb25maWcuYXBwSWQgfHwgIWNvbmZpZy5hcHBTZWNyZXQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhcHBJZCBhbmQgYXBwU2VjcmV0IGFyZSByZXF1aXJlZCBmb3IgUHJpdnlFdm1EZWxlZ2F0ZWRFbWJlZGRlZFdhbGxldFByb3ZpZGVyXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjb25maWcuYXV0aG9yaXphdGlvblByaXZhdGVLZXkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhdXRob3JpemF0aW9uUHJpdmF0ZUtleSBpcyByZXF1aXJlZCBmb3IgUHJpdnlFdm1EZWxlZ2F0ZWRFbWJlZGRlZFdhbGxldFByb3ZpZGVyXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcHJpdnlDbGllbnQgPSAoMCwgcHJpdnlTaGFyZWRfMS5jcmVhdGVQcml2eUNsaWVudCkoY29uZmlnKTtcbiAgICAgICAgICAgIGNvbnN0IHVzZXIgPSBhd2FpdCBwcml2eUNsaWVudC5nZXRVc2VyKGNvbmZpZy53YWxsZXRJZCk7XG4gICAgICAgICAgICBjb25zdCBlbWJlZGRlZFdhbGxldHMgPSB1c2VyLmxpbmtlZEFjY291bnRzLmZpbHRlcigoYWNjb3VudCkgPT4gYWNjb3VudC50eXBlID09PSBcIndhbGxldFwiICYmIGFjY291bnQud2FsbGV0Q2xpZW50VHlwZSA9PT0gXCJwcml2eVwiKTtcbiAgICAgICAgICAgIGlmIChlbWJlZGRlZFdhbGxldHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZmluZCB3YWxsZXQgYWRkcmVzcyBmb3Igd2FsbGV0IElEICR7Y29uZmlnLndhbGxldElkfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgd2FsbGV0QWRkcmVzcyA9IGVtYmVkZGVkV2FsbGV0c1swXS5hZGRyZXNzO1xuICAgICAgICAgICAgLy8gVmVyaWZ5IHRoZSBuZXR3b3JrL2NoYWluIElEIGlmIHByb3ZpZGVkXG4gICAgICAgICAgICBpZiAoY29uZmlnLmNoYWluSWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGFpbiA9ICgwLCBuZXR3b3JrXzEuZ2V0Q2hhaW4pKGNvbmZpZy5jaGFpbklkKTtcbiAgICAgICAgICAgICAgICBpZiAoIWNoYWluKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2hhaW4gd2l0aCBJRCAke2NvbmZpZy5jaGFpbklkfSBub3QgZm91bmRgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByaXZ5RXZtRGVsZWdhdGVkRW1iZWRkZWRXYWxsZXRQcm92aWRlcih7XG4gICAgICAgICAgICAgICAgLi4uY29uZmlnLFxuICAgICAgICAgICAgICAgIGFkZHJlc3M6IHdhbGxldEFkZHJlc3MsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gY29uZmlndXJlIFByaXZ5IGVtYmVkZGVkIHdhbGxldCBwcm92aWRlcjogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGNvbmZpZ3VyZSBQcml2eSBlbWJlZGRlZCB3YWxsZXQgcHJvdmlkZXJcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgYWRkcmVzcyBvZiB0aGUgd2FsbGV0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGFkZHJlc3Mgb2YgdGhlIHdhbGxldC5cbiAgICAgKi9cbiAgICBnZXRBZGRyZXNzKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfUHJpdnlFdm1EZWxlZ2F0ZWRFbWJlZGRlZFdhbGxldFByb3ZpZGVyX2FkZHJlc3MsIFwiZlwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbmV0d29yayBvZiB0aGUgd2FsbGV0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIG5ldHdvcmsgb2YgdGhlIHdhbGxldC5cbiAgICAgKi9cbiAgICBnZXROZXR3b3JrKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfUHJpdnlFdm1EZWxlZ2F0ZWRFbWJlZGRlZFdhbGxldFByb3ZpZGVyX25ldHdvcmssIFwiZlwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbmFtZSBvZiB0aGUgd2FsbGV0IHByb3ZpZGVyLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIG5hbWUgb2YgdGhlIHdhbGxldCBwcm92aWRlci5cbiAgICAgKi9cbiAgICBnZXROYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJwcml2eV9ldm1fZW1iZWRkZWRfd2FsbGV0X3Byb3ZpZGVyXCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGJhbGFuY2Ugb2YgdGhlIHdhbGxldC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBiYWxhbmNlIG9mIHRoZSB3YWxsZXQgaW4gd2VpXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QmFsYW5jZSgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGJhbGFuY2UgPSBhd2FpdCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Qcml2eUV2bURlbGVnYXRlZEVtYmVkZGVkV2FsbGV0UHJvdmlkZXJfcHVibGljQ2xpZW50LCBcImZcIikuZ2V0QmFsYW5jZSh7XG4gICAgICAgICAgICAgICAgYWRkcmVzczogX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfUHJpdnlFdm1EZWxlZ2F0ZWRFbWJlZGRlZFdhbGxldFByb3ZpZGVyX2FkZHJlc3MsIFwiZlwiKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGJhbGFuY2U7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgZ2V0dGluZyBiYWxhbmNlOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBnZXR0aW5nIGJhbGFuY2VcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2lnbnMgYSBtZXNzYWdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgLSBUaGUgbWVzc2FnZSB0byBzaWduLlxuICAgICAqIEByZXR1cm5zIFRoZSBzaWduZWQgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBhc3luYyBzaWduTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IGJvZHkgPSB7XG4gICAgICAgICAgICBhZGRyZXNzOiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Qcml2eUV2bURlbGVnYXRlZEVtYmVkZGVkV2FsbGV0UHJvdmlkZXJfYWRkcmVzcywgXCJmXCIpLFxuICAgICAgICAgICAgY2hhaW5fdHlwZTogXCJldGhlcmV1bVwiLFxuICAgICAgICAgICAgbWV0aG9kOiBcInBlcnNvbmFsX3NpZ25cIixcbiAgICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgZW5jb2Rpbmc6IFwidXRmLThcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZXhlY3V0ZVByaXZ5UmVxdWVzdChib2R5KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhPy5zaWduYXR1cmU7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTWVzc2FnZSBzaWduaW5nIGZhaWxlZDogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWVzc2FnZSBzaWduaW5nIGZhaWxlZFwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaWducyB0eXBlZCBkYXRhIGFjY29yZGluZyB0byBFSVAtNzEyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHR5cGVkRGF0YSAtIFRoZSB0eXBlZCBkYXRhIG9iamVjdCB0byBzaWduXG4gICAgICogQHBhcmFtIHR5cGVkRGF0YS5kb21haW4gLSBUaGUgZG9tYWluIG9iamVjdCBjb250YWluaW5nIGNvbnRyYWN0IGFuZCBjaGFpbiBpbmZvcm1hdGlvblxuICAgICAqIEBwYXJhbSB0eXBlZERhdGEudHlwZXMgLSBUaGUgdHlwZSBkZWZpbml0aW9ucyBmb3IgdGhlIHN0cnVjdHVyZWQgZGF0YVxuICAgICAqIEBwYXJhbSB0eXBlZERhdGEucHJpbWFyeVR5cGUgLSBUaGUgcHJpbWFyeSB0eXBlIGJlaW5nIHNpZ25lZFxuICAgICAqIEBwYXJhbSB0eXBlZERhdGEubWVzc2FnZSAtIFRoZSBhY3R1YWwgZGF0YSB0byBzaWduXG4gICAgICogQHJldHVybnMgQSBBZGRyZXNzIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHNpZ25lZCB0eXBlZCBkYXRhIGFzIGEgaGV4IHN0cmluZ1xuICAgICAqL1xuICAgIGFzeW5jIHNpZ25UeXBlZERhdGEodHlwZWREYXRhKSB7XG4gICAgICAgIGNvbnN0IGJvZHkgPSB7XG4gICAgICAgICAgICBhZGRyZXNzOiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Qcml2eUV2bURlbGVnYXRlZEVtYmVkZGVkV2FsbGV0UHJvdmlkZXJfYWRkcmVzcywgXCJmXCIpLFxuICAgICAgICAgICAgY2hhaW5fdHlwZTogXCJldGhlcmV1bVwiLFxuICAgICAgICAgICAgY2hhaW5faWQ6IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1ByaXZ5RXZtRGVsZWdhdGVkRW1iZWRkZWRXYWxsZXRQcm92aWRlcl9uZXR3b3JrLCBcImZcIikuY2hhaW5JZCxcbiAgICAgICAgICAgIC4uLnR5cGVkRGF0YSxcbiAgICAgICAgfTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5leGVjdXRlUHJpdnlSZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiZXRoX3NpZ25UeXBlZERhdGFfdjRcIixcbiAgICAgICAgICAgICAgICBwYXJhbXM6IGJvZHksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5zaWduYXR1cmU7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlR5cGVkIGRhdGEgc2lnbmluZyBmYWlsZWQ6IFwiICsgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUeXBlZCBkYXRhIHNpZ25pbmcgZmFpbGVkIHdpdGggdW5rbm93biBlcnJvclwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaWducyBhIHRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRyYW5zYWN0aW9uIC0gVGhlIHRyYW5zYWN0aW9uIHRvIHNpZ24uXG4gICAgICogQHJldHVybnMgVGhlIHNpZ25lZCB0cmFuc2FjdGlvbi5cbiAgICAgKi9cbiAgICBhc3luYyBzaWduVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pIHtcbiAgICAgICAgY29uc3QgYm9keSA9IHtcbiAgICAgICAgICAgIGFkZHJlc3M6IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1ByaXZ5RXZtRGVsZWdhdGVkRW1iZWRkZWRXYWxsZXRQcm92aWRlcl9hZGRyZXNzLCBcImZcIiksXG4gICAgICAgICAgICBjaGFpbl90eXBlOiBcImV0aGVyZXVtXCIsXG4gICAgICAgICAgICBtZXRob2Q6IFwiZXRoX3NpZ25UcmFuc2FjdGlvblwiLFxuICAgICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb246IHtcbiAgICAgICAgICAgICAgICAgICAgLi4udHJhbnNhY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgIGZyb206IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1ByaXZ5RXZtRGVsZWdhdGVkRW1iZWRkZWRXYWxsZXRQcm92aWRlcl9hZGRyZXNzLCBcImZcIiksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZXhlY3V0ZVByaXZ5UmVxdWVzdChib2R5KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhPy5zaWduZWRfdHJhbnNhY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVHJhbnNhY3Rpb24gc2lnbmluZyBmYWlsZWQ6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRyYW5zYWN0aW9uIHNpZ25pbmcgZmFpbGVkXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgdHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdHJhbnNhY3Rpb24gLSBUaGUgdHJhbnNhY3Rpb24gdG8gc2VuZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgaGFzaCBvZiB0aGUgdHJhbnNhY3Rpb24uXG4gICAgICovXG4gICAgYXN5bmMgc2VuZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IGJvZHkgPSB7XG4gICAgICAgICAgICBhZGRyZXNzOiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Qcml2eUV2bURlbGVnYXRlZEVtYmVkZGVkV2FsbGV0UHJvdmlkZXJfYWRkcmVzcywgXCJmXCIpLFxuICAgICAgICAgICAgY2hhaW5fdHlwZTogXCJldGhlcmV1bVwiLFxuICAgICAgICAgICAgbWV0aG9kOiBcImV0aF9zZW5kVHJhbnNhY3Rpb25cIixcbiAgICAgICAgICAgIGNhaXAyOiBgZWlwMTU1OiR7X19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfUHJpdnlFdm1EZWxlZ2F0ZWRFbWJlZGRlZFdhbGxldFByb3ZpZGVyX25ldHdvcmssIFwiZlwiKS5jaGFpbklkfWAsXG4gICAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICAuLi50cmFuc2FjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgZnJvbTogX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfUHJpdnlFdm1EZWxlZ2F0ZWRFbWJlZGRlZFdhbGxldFByb3ZpZGVyX2FkZHJlc3MsIFwiZlwiKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5leGVjdXRlUHJpdnlSZXF1ZXN0KGJvZHkpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE/Lmhhc2g7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVHJhbnNhY3Rpb24gc2VuZGluZyBmYWlsZWQ6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRyYW5zYWN0aW9uIHNlbmRpbmcgZmFpbGVkXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdhaXRzIGZvciBhIHRyYW5zYWN0aW9uIHJlY2VpcHQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdHhIYXNoIC0gVGhlIGhhc2ggb2YgdGhlIHRyYW5zYWN0aW9uIHRvIHdhaXQgZm9yLlxuICAgICAqIEByZXR1cm5zIFRoZSB0cmFuc2FjdGlvbiByZWNlaXB0LlxuICAgICAqL1xuICAgIGFzeW5jIHdhaXRGb3JUcmFuc2FjdGlvblJlY2VpcHQodHhIYXNoKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Qcml2eUV2bURlbGVnYXRlZEVtYmVkZGVkV2FsbGV0UHJvdmlkZXJfcHVibGljQ2xpZW50LCBcImZcIikud2FpdEZvclRyYW5zYWN0aW9uUmVjZWlwdCh7XG4gICAgICAgICAgICBoYXNoOiB0eEhhc2gsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkcyBkYXRhIGZyb20gYSBzbWFydCBjb250cmFjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBQYXJhbWV0ZXJzIGZvciByZWFkaW5nIHRoZSBjb250cmFjdFxuICAgICAqIEBwYXJhbSBwYXJhbXMuYWRkcmVzcyAtIFRoZSBhZGRyZXNzIG9mIHRoZSBjb250cmFjdFxuICAgICAqIEBwYXJhbSBwYXJhbXMuYWJpIC0gVGhlIEFCSSBvZiB0aGUgY29udHJhY3RcbiAgICAgKiBAcGFyYW0gcGFyYW1zLmZ1bmN0aW9uTmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvbiB0byBjYWxsXG4gICAgICogQHBhcmFtIHBhcmFtcy5hcmdzIC0gVGhlIGFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIEEgQWRkcmVzcyB0aGF0IHJlc29sdmVzIHRvIHRoZSBjb250cmFjdCBmdW5jdGlvbidzIHJldHVybiB2YWx1ZVxuICAgICAqL1xuICAgIGFzeW5jIHJlYWRDb250cmFjdChwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1ByaXZ5RXZtRGVsZWdhdGVkRW1iZWRkZWRXYWxsZXRQcm92aWRlcl9wdWJsaWNDbGllbnQsIFwiZlwiKS5yZWFkQ29udHJhY3QocGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhbnNmZXIgdGhlIG5hdGl2ZSBhc3NldCBvZiB0aGUgbmV0d29yay5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0byAtIFRoZSBkZXN0aW5hdGlvbiBhZGRyZXNzLlxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBhbW91bnQgdG8gdHJhbnNmZXIgaW4gV2VpLlxuICAgICAqIEByZXR1cm5zIFRoZSB0cmFuc2FjdGlvbiBoYXNoLlxuICAgICAqL1xuICAgIGFzeW5jIG5hdGl2ZVRyYW5zZmVyKHRvLCB2YWx1ZSkge1xuICAgICAgICBjb25zdCB2YWx1ZUluV2VpID0gKDAsIHZpZW1fMS5wYXJzZUV0aGVyKSh2YWx1ZSk7XG4gICAgICAgIGNvbnN0IHZhbHVlSGV4ID0gYDB4JHt2YWx1ZUluV2VpLnRvU3RyaW5nKDE2KX1gO1xuICAgICAgICBjb25zdCBib2R5ID0ge1xuICAgICAgICAgICAgYWRkcmVzczogX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfUHJpdnlFdm1EZWxlZ2F0ZWRFbWJlZGRlZFdhbGxldFByb3ZpZGVyX2FkZHJlc3MsIFwiZlwiKSxcbiAgICAgICAgICAgIGNoYWluX3R5cGU6IFwiZXRoZXJldW1cIixcbiAgICAgICAgICAgIG1ldGhvZDogXCJldGhfc2VuZFRyYW5zYWN0aW9uXCIsXG4gICAgICAgICAgICBjYWlwMjogYGVpcDE1NToke19fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1ByaXZ5RXZtRGVsZWdhdGVkRW1iZWRkZWRXYWxsZXRQcm92aWRlcl9uZXR3b3JrLCBcImZcIikuY2hhaW5JZH1gLFxuICAgICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb246IHtcbiAgICAgICAgICAgICAgICAgICAgdG8sXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZUhleCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5leGVjdXRlUHJpdnlSZXF1ZXN0KGJvZHkpO1xuICAgICAgICAgICAgY29uc3QgcmVjZWlwdCA9IGF3YWl0IHRoaXMud2FpdEZvclRyYW5zYWN0aW9uUmVjZWlwdChyZXNwb25zZS5kYXRhLmhhc2gpO1xuICAgICAgICAgICAgaWYgKCFyZWNlaXB0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVHJhbnNhY3Rpb24gZmFpbGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlY2VpcHQudHJhbnNhY3Rpb25IYXNoO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5hdGl2ZSB0cmFuc2ZlciBmYWlsZWQ6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5hdGl2ZSB0cmFuc2ZlciBmYWlsZWRcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhwb3J0cyB0aGUgd2FsbGV0IGluZm9ybWF0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHdhbGxldCBkYXRhXG4gICAgICovXG4gICAgZXhwb3J0V2FsbGV0KCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2FsbGV0SWQ6IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1ByaXZ5RXZtRGVsZWdhdGVkRW1iZWRkZWRXYWxsZXRQcm92aWRlcl93YWxsZXRJZCwgXCJmXCIpLFxuICAgICAgICAgICAgYXV0aG9yaXphdGlvblByaXZhdGVLZXk6IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1ByaXZ5RXZtRGVsZWdhdGVkRW1iZWRkZWRXYWxsZXRQcm92aWRlcl9hdXRoS2V5LCBcImZcIiksXG4gICAgICAgICAgICBuZXR3b3JrSWQ6IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1ByaXZ5RXZtRGVsZWdhdGVkRW1iZWRkZWRXYWxsZXRQcm92aWRlcl9uZXR3b3JrLCBcImZcIikubmV0d29ya0lkLFxuICAgICAgICAgICAgY2hhaW5JZDogX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfUHJpdnlFdm1EZWxlZ2F0ZWRFbWJlZGRlZFdhbGxldFByb3ZpZGVyX25ldHdvcmssIFwiZlwiKS5jaGFpbklkLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBQcml2eSBhdXRob3JpemF0aW9uIHNpZ25hdHVyZSBmb3IgQVBJIHJlcXVlc3RzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXJsIC0gVGhlIFVSTCBmb3IgdGhlIHJlcXVlc3RcbiAgICAgKiBAcGFyYW0gYm9keSAtIFRoZSByZXF1ZXN0IGJvZHlcbiAgICAgKiBAcmV0dXJucyBUaGUgZ2VuZXJhdGVkIHNpZ25hdHVyZVxuICAgICAqL1xuICAgIGdlbmVyYXRlUHJpdnlTaWduYXR1cmUodXJsLCBib2R5KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgIHZlcnNpb246IDEsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgIFwicHJpdnktYXBwLWlkXCI6IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1ByaXZ5RXZtRGVsZWdhdGVkRW1iZWRkZWRXYWxsZXRQcm92aWRlcl9hcHBJZCwgXCJmXCIpLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3Qgc2VyaWFsaXplZFBheWxvYWQgPSAoMCwgY2Fub25pY2FsaXplXzEuZGVmYXVsdCkocGF5bG9hZCk7XG4gICAgICAgICAgICBpZiAoIXNlcmlhbGl6ZWRQYXlsb2FkKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBjYW5vbmljYWxpemUgcGF5bG9hZFwiKTtcbiAgICAgICAgICAgIGNvbnN0IHNlcmlhbGl6ZWRQYXlsb2FkQnVmZmVyID0gQnVmZmVyLmZyb20oc2VyaWFsaXplZFBheWxvYWQpO1xuICAgICAgICAgICAgY29uc3QgcHJpdmF0ZUtleUFzU3RyaW5nID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfUHJpdnlFdm1EZWxlZ2F0ZWRFbWJlZGRlZFdhbGxldFByb3ZpZGVyX2F1dGhLZXksIFwiZlwiKS5yZXBsYWNlKFwid2FsbGV0LWF1dGg6XCIsIFwiXCIpO1xuICAgICAgICAgICAgY29uc3QgcHJpdmF0ZUtleUFzUGVtID0gYC0tLS0tQkVHSU4gUFJJVkFURSBLRVktLS0tLVxcbiR7cHJpdmF0ZUtleUFzU3RyaW5nfVxcbi0tLS0tRU5EIFBSSVZBVEUgS0VZLS0tLS1gO1xuICAgICAgICAgICAgY29uc3QgcHJpdmF0ZUtleSA9IGNyeXB0b18xLmRlZmF1bHQuY3JlYXRlUHJpdmF0ZUtleSh7XG4gICAgICAgICAgICAgICAga2V5OiBwcml2YXRlS2V5QXNQZW0sXG4gICAgICAgICAgICAgICAgZm9ybWF0OiBcInBlbVwiLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBzaWduYXR1cmVCdWZmZXIgPSBjcnlwdG9fMS5kZWZhdWx0LnNpZ24oXCJzaGEyNTZcIiwgc2VyaWFsaXplZFBheWxvYWRCdWZmZXIsIHByaXZhdGVLZXkpO1xuICAgICAgICAgICAgcmV0dXJuIHNpZ25hdHVyZUJ1ZmZlci50b1N0cmluZyhcImJhc2U2NFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBnZW5lcmF0aW5nIFByaXZ5IGF1dGhvcml6YXRpb24gc2lnbmF0dXJlOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBnZW5lcmF0aW5nIFByaXZ5IGF1dGhvcml6YXRpb24gc2lnbmF0dXJlXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBQcml2eSBoZWFkZXJzIGZvciBBUEkgcmVxdWVzdHNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB1cmwgLSBUaGUgVVJMIGZvciB0aGUgcmVxdWVzdFxuICAgICAqIEBwYXJhbSBib2R5IC0gVGhlIHJlcXVlc3QgYm9keVxuICAgICAqIEByZXR1cm5zIFRoZSBoZWFkZXJzIGZvciB0aGUgcmVxdWVzdFxuICAgICAqL1xuICAgIGdldFByaXZ5SGVhZGVycyh1cmwsIGJvZHkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgQXV0aG9yaXphdGlvbjogYEJhc2ljICR7QnVmZmVyLmZyb20oYCR7X19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfUHJpdnlFdm1EZWxlZ2F0ZWRFbWJlZGRlZFdhbGxldFByb3ZpZGVyX2FwcElkLCBcImZcIil9OiR7X19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfUHJpdnlFdm1EZWxlZ2F0ZWRFbWJlZGRlZFdhbGxldFByb3ZpZGVyX2FwcFNlY3JldCwgXCJmXCIpfWApLnRvU3RyaW5nKFwiYmFzZTY0XCIpfWAsXG4gICAgICAgICAgICBcInByaXZ5LWFwcC1pZFwiOiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Qcml2eUV2bURlbGVnYXRlZEVtYmVkZGVkV2FsbGV0UHJvdmlkZXJfYXBwSWQsIFwiZlwiKSxcbiAgICAgICAgICAgIFwicHJpdnktYXV0aG9yaXphdGlvbi1zaWduYXR1cmVcIjogdGhpcy5nZW5lcmF0ZVByaXZ5U2lnbmF0dXJlKHVybCwgYm9keSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGUgYSBQcml2eSBBUEkgcmVxdWVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBib2R5IC0gVGhlIHJlcXVlc3QgYm9keSB0byBzZW5kIHRvIHRoZSBQcml2eSBBUElcbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgcmVzcG9uc2UgZGF0YVxuICAgICAqIEB0aHJvd3MgRXJyb3IgaWYgdGhlIHJlcXVlc3QgZmFpbHNcbiAgICAgKi9cbiAgICBhc3luYyBleGVjdXRlUHJpdnlSZXF1ZXN0KGJvZHkpIHtcbiAgICAgICAgY29uc3QgdXJsID0gYGh0dHBzOi8vYXBpLnByaXZ5LmlvL3YxL3dhbGxldHMvcnBjYDtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHRoaXMuZ2V0UHJpdnlIZWFkZXJzKHVybCwgYm9keSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5LCAoX2tleSwgdmFsdWUpID0+IHR5cGVvZiB2YWx1ZSA9PT0gXCJiaWdpbnRcIiA/IHZhbHVlLnRvU3RyaW5nKCkgOiB2YWx1ZSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEhUVFAgZXJyb3IhIHN0YXR1czogJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQcml2eSByZXF1ZXN0IGZhaWxlZDogXCIgKyBlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlByaXZ5IHJlcXVlc3QgZmFpbGVkIHdpdGggdW5rbm93biBlcnJvclwiKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuUHJpdnlFdm1EZWxlZ2F0ZWRFbWJlZGRlZFdhbGxldFByb3ZpZGVyID0gUHJpdnlFdm1EZWxlZ2F0ZWRFbWJlZGRlZFdhbGxldFByb3ZpZGVyO1xuX1ByaXZ5RXZtRGVsZWdhdGVkRW1iZWRkZWRXYWxsZXRQcm92aWRlcl93YWxsZXRJZCA9IG5ldyBXZWFrTWFwKCksIF9Qcml2eUV2bURlbGVnYXRlZEVtYmVkZGVkV2FsbGV0UHJvdmlkZXJfYWRkcmVzcyA9IG5ldyBXZWFrTWFwKCksIF9Qcml2eUV2bURlbGVnYXRlZEVtYmVkZGVkV2FsbGV0UHJvdmlkZXJfYXBwSWQgPSBuZXcgV2Vha01hcCgpLCBfUHJpdnlFdm1EZWxlZ2F0ZWRFbWJlZGRlZFdhbGxldFByb3ZpZGVyX2FwcFNlY3JldCA9IG5ldyBXZWFrTWFwKCksIF9Qcml2eUV2bURlbGVnYXRlZEVtYmVkZGVkV2FsbGV0UHJvdmlkZXJfYXV0aEtleSA9IG5ldyBXZWFrTWFwKCksIF9Qcml2eUV2bURlbGVnYXRlZEVtYmVkZGVkV2FsbGV0UHJvdmlkZXJfbmV0d29yayA9IG5ldyBXZWFrTWFwKCksIF9Qcml2eUV2bURlbGVnYXRlZEVtYmVkZGVkV2FsbGV0UHJvdmlkZXJfcHVibGljQ2xpZW50ID0gbmV3IFdlYWtNYXAoKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/wallet-providers/privyEvmDelegatedEmbeddedWalletProvider.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/wallet-providers/privyEvmWalletProvider.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/wallet-providers/privyEvmWalletProvider.js ***!
  \*****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _PrivyEvmWalletProvider_walletId, _PrivyEvmWalletProvider_authorizationPrivateKey;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PrivyEvmWalletProvider = void 0;\nconst server_auth_1 = __webpack_require__(/*! @privy-io/server-auth */ \"(rsc)/./node_modules/@privy-io/server-auth/dist/cjs/index.js\");\nconst viem_1 = __webpack_require__(/*! @privy-io/server-auth/viem */ \"(rsc)/./node_modules/@privy-io/server-auth/dist/cjs/viem.js\");\nconst viemWalletProvider_1 = __webpack_require__(/*! ./viemWalletProvider */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/wallet-providers/viemWalletProvider.js\");\nconst viem_2 = __webpack_require__(/*! viem */ \"(rsc)/./node_modules/viem/_cjs/index.js\");\nconst network_1 = __webpack_require__(/*! ../network/network */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/network/network.js\");\n/**\n * A wallet provider that uses Privy's server wallet API.\n * This provider extends the ViemWalletProvider to provide Privy-specific wallet functionality\n * while maintaining compatibility with the base wallet provider interface.\n */\nclass PrivyEvmWalletProvider extends viemWalletProvider_1.ViemWalletProvider {\n    /**\n     * Private constructor to enforce use of factory method.\n     *\n     * @param walletClient - The Viem wallet client instance\n     * @param config - The configuration options for the Privy wallet\n     */\n    constructor(walletClient, config) {\n        super(walletClient);\n        _PrivyEvmWalletProvider_walletId.set(this, void 0);\n        _PrivyEvmWalletProvider_authorizationPrivateKey.set(this, void 0);\n        __classPrivateFieldSet(this, _PrivyEvmWalletProvider_walletId, config.walletId, \"f\"); // Now guaranteed to exist\n        __classPrivateFieldSet(this, _PrivyEvmWalletProvider_authorizationPrivateKey, config.authorizationPrivateKey, \"f\");\n    }\n    /**\n     * Creates and configures a new PrivyWalletProvider instance.\n     *\n     * @param config - The configuration options for the Privy wallet\n     * @returns A configured PrivyWalletProvider instance\n     *\n     * @example\n     * ```typescript\n     * const provider = await PrivyWalletProvider.configureWithWallet({\n     *   appId: \"your-app-id\",\n     *   appSecret: \"your-app-secret\",\n     *   walletId: \"wallet-id\",\n     *   chainId: \"84532\"\n     * });\n     * ```\n     */\n    static async configureWithWallet(config) {\n        const privy = new server_auth_1.PrivyClient(config.appId, config.appSecret, {\n            walletApi: config.authorizationPrivateKey\n                ? {\n                    authorizationPrivateKey: config.authorizationPrivateKey,\n                }\n                : undefined,\n        });\n        let walletId;\n        let address;\n        if (!config.walletId) {\n            if (config.authorizationPrivateKey && !config.authorizationKeyId) {\n                throw new Error(\"authorizationKeyId is required when creating a new wallet with an authorization key, this can be found in your Privy Dashboard\");\n            }\n            if (config.authorizationKeyId && !config.authorizationPrivateKey) {\n                throw new Error(\"authorizationPrivateKey is required when creating a new wallet with an authorizationKeyId. \" +\n                    \"If you don't have it, you can create a new one in your Privy Dashboard, or delete the authorization key.\");\n            }\n            try {\n                const wallet = await privy.walletApi.create({\n                    chainType: \"ethereum\",\n                    authorizationKeyIds: config.authorizationKeyId ? [config.authorizationKeyId] : undefined,\n                });\n                walletId = wallet.id;\n                address = wallet.address;\n            }\n            catch (error) {\n                console.error(error);\n                if (error instanceof Error &&\n                    error.message.includes(\"Missing `privy-authorization-signature` header\")) {\n                    // Providing a more informative error message, see context: https://github.com/coinbase/agentkit/pull/242#discussion_r1956428617\n                    throw new Error(\"Privy error: you have an authorization key on your account which can create and modify wallets, please delete this key or pass it to the PrivyWalletProvider to create a new wallet\");\n                }\n                throw new Error(\"Failed to create wallet\");\n            }\n        }\n        else {\n            walletId = config.walletId;\n            const wallet = await privy.walletApi.getWallet({ id: walletId });\n            if (!wallet) {\n                throw new Error(`Wallet with ID ${walletId} not found`);\n            }\n            address = wallet.address;\n        }\n        const account = await (0, viem_1.createViemAccount)({\n            walletId,\n            address,\n            privy,\n        });\n        const chainId = config.chainId || \"84532\";\n        const chain = (0, network_1.getChain)(chainId);\n        if (!chain) {\n            throw new Error(`Chain with ID ${chainId} not found`);\n        }\n        const walletClient = (0, viem_2.createWalletClient)({\n            account,\n            chain,\n            transport: (0, viem_2.http)(),\n        });\n        return new PrivyEvmWalletProvider(walletClient, { ...config, walletId });\n    }\n    /**\n     * Gets the name of the wallet provider.\n     *\n     * @returns The string identifier for this wallet provider\n     */\n    getName() {\n        return \"privy_evm_wallet_provider\";\n    }\n    /**\n     * Exports the wallet data.\n     *\n     * @returns The wallet data\n     */\n    exportWallet() {\n        return {\n            walletId: __classPrivateFieldGet(this, _PrivyEvmWalletProvider_walletId, \"f\"),\n            authorizationPrivateKey: __classPrivateFieldGet(this, _PrivyEvmWalletProvider_authorizationPrivateKey, \"f\"),\n            chainId: this.getNetwork().chainId,\n            networkId: this.getNetwork().networkId,\n        };\n    }\n}\nexports.PrivyEvmWalletProvider = PrivyEvmWalletProvider;\n_PrivyEvmWalletProvider_walletId = new WeakMap(), _PrivyEvmWalletProvider_authorizationPrivateKey = new WeakMap();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3Qvd2FsbGV0LXByb3ZpZGVycy9wcml2eUV2bVdhbGxldFByb3ZpZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDhCQUE4QjtBQUM5QixzQkFBc0IsbUJBQU8sQ0FBQywyRkFBdUI7QUFDckQsZUFBZSxtQkFBTyxDQUFDLCtGQUE0QjtBQUNuRCw2QkFBNkIsbUJBQU8sQ0FBQyxpSEFBc0I7QUFDM0QsZUFBZSxtQkFBTyxDQUFDLHFEQUFNO0FBQzdCLGtCQUFrQixtQkFBTyxDQUFDLDJGQUFvQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhGQUE4RjtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELGNBQWM7QUFDM0U7QUFDQSxrREFBa0QsVUFBVTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsU0FBUztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULDBEQUEwRCxxQkFBcUI7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QiIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cnZpdmFsLWZ1bi8uL25vZGVfbW9kdWxlcy9AY29pbmJhc2UvYWdlbnRraXQvZGlzdC93YWxsZXQtcHJvdmlkZXJzL3ByaXZ5RXZtV2FsbGV0UHJvdmlkZXIuanM/ODJhMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcbn07XG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZEdldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZEdldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xufTtcbnZhciBfUHJpdnlFdm1XYWxsZXRQcm92aWRlcl93YWxsZXRJZCwgX1ByaXZ5RXZtV2FsbGV0UHJvdmlkZXJfYXV0aG9yaXphdGlvblByaXZhdGVLZXk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlByaXZ5RXZtV2FsbGV0UHJvdmlkZXIgPSB2b2lkIDA7XG5jb25zdCBzZXJ2ZXJfYXV0aF8xID0gcmVxdWlyZShcIkBwcml2eS1pby9zZXJ2ZXItYXV0aFwiKTtcbmNvbnN0IHZpZW1fMSA9IHJlcXVpcmUoXCJAcHJpdnktaW8vc2VydmVyLWF1dGgvdmllbVwiKTtcbmNvbnN0IHZpZW1XYWxsZXRQcm92aWRlcl8xID0gcmVxdWlyZShcIi4vdmllbVdhbGxldFByb3ZpZGVyXCIpO1xuY29uc3QgdmllbV8yID0gcmVxdWlyZShcInZpZW1cIik7XG5jb25zdCBuZXR3b3JrXzEgPSByZXF1aXJlKFwiLi4vbmV0d29yay9uZXR3b3JrXCIpO1xuLyoqXG4gKiBBIHdhbGxldCBwcm92aWRlciB0aGF0IHVzZXMgUHJpdnkncyBzZXJ2ZXIgd2FsbGV0IEFQSS5cbiAqIFRoaXMgcHJvdmlkZXIgZXh0ZW5kcyB0aGUgVmllbVdhbGxldFByb3ZpZGVyIHRvIHByb3ZpZGUgUHJpdnktc3BlY2lmaWMgd2FsbGV0IGZ1bmN0aW9uYWxpdHlcbiAqIHdoaWxlIG1haW50YWluaW5nIGNvbXBhdGliaWxpdHkgd2l0aCB0aGUgYmFzZSB3YWxsZXQgcHJvdmlkZXIgaW50ZXJmYWNlLlxuICovXG5jbGFzcyBQcml2eUV2bVdhbGxldFByb3ZpZGVyIGV4dGVuZHMgdmllbVdhbGxldFByb3ZpZGVyXzEuVmllbVdhbGxldFByb3ZpZGVyIHtcbiAgICAvKipcbiAgICAgKiBQcml2YXRlIGNvbnN0cnVjdG9yIHRvIGVuZm9yY2UgdXNlIG9mIGZhY3RvcnkgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHBhcmFtIHdhbGxldENsaWVudCAtIFRoZSBWaWVtIHdhbGxldCBjbGllbnQgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0gY29uZmlnIC0gVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIFByaXZ5IHdhbGxldFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHdhbGxldENsaWVudCwgY29uZmlnKSB7XG4gICAgICAgIHN1cGVyKHdhbGxldENsaWVudCk7XG4gICAgICAgIF9Qcml2eUV2bVdhbGxldFByb3ZpZGVyX3dhbGxldElkLnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICBfUHJpdnlFdm1XYWxsZXRQcm92aWRlcl9hdXRob3JpemF0aW9uUHJpdmF0ZUtleS5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfUHJpdnlFdm1XYWxsZXRQcm92aWRlcl93YWxsZXRJZCwgY29uZmlnLndhbGxldElkLCBcImZcIik7IC8vIE5vdyBndWFyYW50ZWVkIHRvIGV4aXN0XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX1ByaXZ5RXZtV2FsbGV0UHJvdmlkZXJfYXV0aG9yaXphdGlvblByaXZhdGVLZXksIGNvbmZpZy5hdXRob3JpemF0aW9uUHJpdmF0ZUtleSwgXCJmXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuZCBjb25maWd1cmVzIGEgbmV3IFByaXZ5V2FsbGV0UHJvdmlkZXIgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29uZmlnIC0gVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIFByaXZ5IHdhbGxldFxuICAgICAqIEByZXR1cm5zIEEgY29uZmlndXJlZCBQcml2eVdhbGxldFByb3ZpZGVyIGluc3RhbmNlXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCBwcm92aWRlciA9IGF3YWl0IFByaXZ5V2FsbGV0UHJvdmlkZXIuY29uZmlndXJlV2l0aFdhbGxldCh7XG4gICAgICogICBhcHBJZDogXCJ5b3VyLWFwcC1pZFwiLFxuICAgICAqICAgYXBwU2VjcmV0OiBcInlvdXItYXBwLXNlY3JldFwiLFxuICAgICAqICAgd2FsbGV0SWQ6IFwid2FsbGV0LWlkXCIsXG4gICAgICogICBjaGFpbklkOiBcIjg0NTMyXCJcbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgY29uZmlndXJlV2l0aFdhbGxldChjb25maWcpIHtcbiAgICAgICAgY29uc3QgcHJpdnkgPSBuZXcgc2VydmVyX2F1dGhfMS5Qcml2eUNsaWVudChjb25maWcuYXBwSWQsIGNvbmZpZy5hcHBTZWNyZXQsIHtcbiAgICAgICAgICAgIHdhbGxldEFwaTogY29uZmlnLmF1dGhvcml6YXRpb25Qcml2YXRlS2V5XG4gICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgIGF1dGhvcml6YXRpb25Qcml2YXRlS2V5OiBjb25maWcuYXV0aG9yaXphdGlvblByaXZhdGVLZXksXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICB9KTtcbiAgICAgICAgbGV0IHdhbGxldElkO1xuICAgICAgICBsZXQgYWRkcmVzcztcbiAgICAgICAgaWYgKCFjb25maWcud2FsbGV0SWQpIHtcbiAgICAgICAgICAgIGlmIChjb25maWcuYXV0aG9yaXphdGlvblByaXZhdGVLZXkgJiYgIWNvbmZpZy5hdXRob3JpemF0aW9uS2V5SWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhdXRob3JpemF0aW9uS2V5SWQgaXMgcmVxdWlyZWQgd2hlbiBjcmVhdGluZyBhIG5ldyB3YWxsZXQgd2l0aCBhbiBhdXRob3JpemF0aW9uIGtleSwgdGhpcyBjYW4gYmUgZm91bmQgaW4geW91ciBQcml2eSBEYXNoYm9hcmRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29uZmlnLmF1dGhvcml6YXRpb25LZXlJZCAmJiAhY29uZmlnLmF1dGhvcml6YXRpb25Qcml2YXRlS2V5KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXV0aG9yaXphdGlvblByaXZhdGVLZXkgaXMgcmVxdWlyZWQgd2hlbiBjcmVhdGluZyBhIG5ldyB3YWxsZXQgd2l0aCBhbiBhdXRob3JpemF0aW9uS2V5SWQuIFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJJZiB5b3UgZG9uJ3QgaGF2ZSBpdCwgeW91IGNhbiBjcmVhdGUgYSBuZXcgb25lIGluIHlvdXIgUHJpdnkgRGFzaGJvYXJkLCBvciBkZWxldGUgdGhlIGF1dGhvcml6YXRpb24ga2V5LlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgd2FsbGV0ID0gYXdhaXQgcHJpdnkud2FsbGV0QXBpLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIGNoYWluVHlwZTogXCJldGhlcmV1bVwiLFxuICAgICAgICAgICAgICAgICAgICBhdXRob3JpemF0aW9uS2V5SWRzOiBjb25maWcuYXV0aG9yaXphdGlvbktleUlkID8gW2NvbmZpZy5hdXRob3JpemF0aW9uS2V5SWRdIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHdhbGxldElkID0gd2FsbGV0LmlkO1xuICAgICAgICAgICAgICAgIGFkZHJlc3MgPSB3YWxsZXQuYWRkcmVzcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmXG4gICAgICAgICAgICAgICAgICAgIGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoXCJNaXNzaW5nIGBwcml2eS1hdXRob3JpemF0aW9uLXNpZ25hdHVyZWAgaGVhZGVyXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFByb3ZpZGluZyBhIG1vcmUgaW5mb3JtYXRpdmUgZXJyb3IgbWVzc2FnZSwgc2VlIGNvbnRleHQ6IGh0dHBzOi8vZ2l0aHViLmNvbS9jb2luYmFzZS9hZ2VudGtpdC9wdWxsLzI0MiNkaXNjdXNzaW9uX3IxOTU2NDI4NjE3XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlByaXZ5IGVycm9yOiB5b3UgaGF2ZSBhbiBhdXRob3JpemF0aW9uIGtleSBvbiB5b3VyIGFjY291bnQgd2hpY2ggY2FuIGNyZWF0ZSBhbmQgbW9kaWZ5IHdhbGxldHMsIHBsZWFzZSBkZWxldGUgdGhpcyBrZXkgb3IgcGFzcyBpdCB0byB0aGUgUHJpdnlXYWxsZXRQcm92aWRlciB0byBjcmVhdGUgYSBuZXcgd2FsbGV0XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gY3JlYXRlIHdhbGxldFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdhbGxldElkID0gY29uZmlnLndhbGxldElkO1xuICAgICAgICAgICAgY29uc3Qgd2FsbGV0ID0gYXdhaXQgcHJpdnkud2FsbGV0QXBpLmdldFdhbGxldCh7IGlkOiB3YWxsZXRJZCB9KTtcbiAgICAgICAgICAgIGlmICghd2FsbGV0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBXYWxsZXQgd2l0aCBJRCAke3dhbGxldElkfSBub3QgZm91bmRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkZHJlc3MgPSB3YWxsZXQuYWRkcmVzcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhY2NvdW50ID0gYXdhaXQgKDAsIHZpZW1fMS5jcmVhdGVWaWVtQWNjb3VudCkoe1xuICAgICAgICAgICAgd2FsbGV0SWQsXG4gICAgICAgICAgICBhZGRyZXNzLFxuICAgICAgICAgICAgcHJpdnksXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBjaGFpbklkID0gY29uZmlnLmNoYWluSWQgfHwgXCI4NDUzMlwiO1xuICAgICAgICBjb25zdCBjaGFpbiA9ICgwLCBuZXR3b3JrXzEuZ2V0Q2hhaW4pKGNoYWluSWQpO1xuICAgICAgICBpZiAoIWNoYWluKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENoYWluIHdpdGggSUQgJHtjaGFpbklkfSBub3QgZm91bmRgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB3YWxsZXRDbGllbnQgPSAoMCwgdmllbV8yLmNyZWF0ZVdhbGxldENsaWVudCkoe1xuICAgICAgICAgICAgYWNjb3VudCxcbiAgICAgICAgICAgIGNoYWluLFxuICAgICAgICAgICAgdHJhbnNwb3J0OiAoMCwgdmllbV8yLmh0dHApKCksXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IFByaXZ5RXZtV2FsbGV0UHJvdmlkZXIod2FsbGV0Q2xpZW50LCB7IC4uLmNvbmZpZywgd2FsbGV0SWQgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG5hbWUgb2YgdGhlIHdhbGxldCBwcm92aWRlci5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBzdHJpbmcgaWRlbnRpZmllciBmb3IgdGhpcyB3YWxsZXQgcHJvdmlkZXJcbiAgICAgKi9cbiAgICBnZXROYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJwcml2eV9ldm1fd2FsbGV0X3Byb3ZpZGVyXCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4cG9ydHMgdGhlIHdhbGxldCBkYXRhLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHdhbGxldCBkYXRhXG4gICAgICovXG4gICAgZXhwb3J0V2FsbGV0KCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2FsbGV0SWQ6IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1ByaXZ5RXZtV2FsbGV0UHJvdmlkZXJfd2FsbGV0SWQsIFwiZlwiKSxcbiAgICAgICAgICAgIGF1dGhvcml6YXRpb25Qcml2YXRlS2V5OiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Qcml2eUV2bVdhbGxldFByb3ZpZGVyX2F1dGhvcml6YXRpb25Qcml2YXRlS2V5LCBcImZcIiksXG4gICAgICAgICAgICBjaGFpbklkOiB0aGlzLmdldE5ldHdvcmsoKS5jaGFpbklkLFxuICAgICAgICAgICAgbmV0d29ya0lkOiB0aGlzLmdldE5ldHdvcmsoKS5uZXR3b3JrSWQsXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5Qcml2eUV2bVdhbGxldFByb3ZpZGVyID0gUHJpdnlFdm1XYWxsZXRQcm92aWRlcjtcbl9Qcml2eUV2bVdhbGxldFByb3ZpZGVyX3dhbGxldElkID0gbmV3IFdlYWtNYXAoKSwgX1ByaXZ5RXZtV2FsbGV0UHJvdmlkZXJfYXV0aG9yaXphdGlvblByaXZhdGVLZXkgPSBuZXcgV2Vha01hcCgpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/wallet-providers/privyEvmWalletProvider.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/wallet-providers/privyShared.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/wallet-providers/privyShared.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createPrivyClient = void 0;\nexports.createPrivyWallet = createPrivyWallet;\nconst server_auth_1 = __webpack_require__(/*! @privy-io/server-auth */ \"(rsc)/./node_modules/@privy-io/server-auth/dist/cjs/index.js\");\n/**\n * Create a Privy client\n *\n * @param config - The configuration options for the Privy client\n * @returns The created Privy client\n */\nconst createPrivyClient = (config) => {\n    return new server_auth_1.PrivyClient(config.appId, config.appSecret, {\n        walletApi: config.authorizationPrivateKey\n            ? {\n                authorizationPrivateKey: config.authorizationPrivateKey,\n            }\n            : undefined,\n    });\n};\nexports.createPrivyClient = createPrivyClient;\n/**\n * Create a Privy wallet\n *\n * @param config - The configuration options for the Privy wallet\n * @returns The created Privy wallet\n */\nasync function createPrivyWallet(config) {\n    const privy = (0, exports.createPrivyClient)(config);\n    if (config.walletId) {\n        const wallet = await privy.walletApi.getWallet({ id: config.walletId });\n        if (!wallet) {\n            throw new Error(`Wallet with ID ${config.walletId} not found`);\n        }\n        return { wallet, privy };\n    }\n    if (config.authorizationPrivateKey && !config.authorizationKeyId) {\n        throw new Error(\"authorizationKeyId is required when creating a new wallet with an authorization key, this can be found in your Privy Dashboard\");\n    }\n    if (config.authorizationKeyId && !config.authorizationPrivateKey) {\n        throw new Error(\"authorizationPrivateKey is required when creating a new wallet with an authorizationKeyId. \" +\n            \"If you don't have it, you can create a new one in your Privy Dashboard, or delete the authorization key.\");\n    }\n    try {\n        const wallet = await privy.walletApi.create({\n            chainType: config.chainType,\n            authorizationKeyIds: config.authorizationKeyId ? [config.authorizationKeyId] : undefined,\n        });\n        return { wallet, privy };\n    }\n    catch (error) {\n        console.error(error);\n        if (error instanceof Error &&\n            error.message.includes(\"Missing `privy-authorization-signature` header\")) {\n            // Providing a more informative error message, see context: https://github.com/coinbase/agentkit/pull/242#discussion_r1956428617\n            throw new Error(\"Privy error: you have an authorization key on your account which can create and modify wallets, please delete this key or pass it to the PrivyWalletProvider to create a new wallet\");\n        }\n        throw new Error(\"Failed to create wallet\");\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3Qvd2FsbGV0LXByb3ZpZGVycy9wcml2eVNoYXJlZC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx5QkFBeUI7QUFDekIseUJBQXlCO0FBQ3pCLHNCQUFzQixtQkFBTyxDQUFDLDJGQUF1QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQscUJBQXFCO0FBQzlFO0FBQ0EsOENBQThDLGlCQUFpQjtBQUMvRDtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXJ2aXZhbC1mdW4vLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3Qvd2FsbGV0LXByb3ZpZGVycy9wcml2eVNoYXJlZC5qcz8yMzdlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcmVhdGVQcml2eUNsaWVudCA9IHZvaWQgMDtcbmV4cG9ydHMuY3JlYXRlUHJpdnlXYWxsZXQgPSBjcmVhdGVQcml2eVdhbGxldDtcbmNvbnN0IHNlcnZlcl9hdXRoXzEgPSByZXF1aXJlKFwiQHByaXZ5LWlvL3NlcnZlci1hdXRoXCIpO1xuLyoqXG4gKiBDcmVhdGUgYSBQcml2eSBjbGllbnRcbiAqXG4gKiBAcGFyYW0gY29uZmlnIC0gVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIFByaXZ5IGNsaWVudFxuICogQHJldHVybnMgVGhlIGNyZWF0ZWQgUHJpdnkgY2xpZW50XG4gKi9cbmNvbnN0IGNyZWF0ZVByaXZ5Q2xpZW50ID0gKGNvbmZpZykgPT4ge1xuICAgIHJldHVybiBuZXcgc2VydmVyX2F1dGhfMS5Qcml2eUNsaWVudChjb25maWcuYXBwSWQsIGNvbmZpZy5hcHBTZWNyZXQsIHtcbiAgICAgICAgd2FsbGV0QXBpOiBjb25maWcuYXV0aG9yaXphdGlvblByaXZhdGVLZXlcbiAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgIGF1dGhvcml6YXRpb25Qcml2YXRlS2V5OiBjb25maWcuYXV0aG9yaXphdGlvblByaXZhdGVLZXksXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICB9KTtcbn07XG5leHBvcnRzLmNyZWF0ZVByaXZ5Q2xpZW50ID0gY3JlYXRlUHJpdnlDbGllbnQ7XG4vKipcbiAqIENyZWF0ZSBhIFByaXZ5IHdhbGxldFxuICpcbiAqIEBwYXJhbSBjb25maWcgLSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgUHJpdnkgd2FsbGV0XG4gKiBAcmV0dXJucyBUaGUgY3JlYXRlZCBQcml2eSB3YWxsZXRcbiAqL1xuYXN5bmMgZnVuY3Rpb24gY3JlYXRlUHJpdnlXYWxsZXQoY29uZmlnKSB7XG4gICAgY29uc3QgcHJpdnkgPSAoMCwgZXhwb3J0cy5jcmVhdGVQcml2eUNsaWVudCkoY29uZmlnKTtcbiAgICBpZiAoY29uZmlnLndhbGxldElkKSB7XG4gICAgICAgIGNvbnN0IHdhbGxldCA9IGF3YWl0IHByaXZ5LndhbGxldEFwaS5nZXRXYWxsZXQoeyBpZDogY29uZmlnLndhbGxldElkIH0pO1xuICAgICAgICBpZiAoIXdhbGxldCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBXYWxsZXQgd2l0aCBJRCAke2NvbmZpZy53YWxsZXRJZH0gbm90IGZvdW5kYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgd2FsbGV0LCBwcml2eSB9O1xuICAgIH1cbiAgICBpZiAoY29uZmlnLmF1dGhvcml6YXRpb25Qcml2YXRlS2V5ICYmICFjb25maWcuYXV0aG9yaXphdGlvbktleUlkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImF1dGhvcml6YXRpb25LZXlJZCBpcyByZXF1aXJlZCB3aGVuIGNyZWF0aW5nIGEgbmV3IHdhbGxldCB3aXRoIGFuIGF1dGhvcml6YXRpb24ga2V5LCB0aGlzIGNhbiBiZSBmb3VuZCBpbiB5b3VyIFByaXZ5IERhc2hib2FyZFwiKTtcbiAgICB9XG4gICAgaWYgKGNvbmZpZy5hdXRob3JpemF0aW9uS2V5SWQgJiYgIWNvbmZpZy5hdXRob3JpemF0aW9uUHJpdmF0ZUtleSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhdXRob3JpemF0aW9uUHJpdmF0ZUtleSBpcyByZXF1aXJlZCB3aGVuIGNyZWF0aW5nIGEgbmV3IHdhbGxldCB3aXRoIGFuIGF1dGhvcml6YXRpb25LZXlJZC4gXCIgK1xuICAgICAgICAgICAgXCJJZiB5b3UgZG9uJ3QgaGF2ZSBpdCwgeW91IGNhbiBjcmVhdGUgYSBuZXcgb25lIGluIHlvdXIgUHJpdnkgRGFzaGJvYXJkLCBvciBkZWxldGUgdGhlIGF1dGhvcml6YXRpb24ga2V5LlwiKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgd2FsbGV0ID0gYXdhaXQgcHJpdnkud2FsbGV0QXBpLmNyZWF0ZSh7XG4gICAgICAgICAgICBjaGFpblR5cGU6IGNvbmZpZy5jaGFpblR5cGUsXG4gICAgICAgICAgICBhdXRob3JpemF0aW9uS2V5SWRzOiBjb25maWcuYXV0aG9yaXphdGlvbktleUlkID8gW2NvbmZpZy5hdXRob3JpemF0aW9uS2V5SWRdIDogdW5kZWZpbmVkLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHsgd2FsbGV0LCBwcml2eSB9O1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmXG4gICAgICAgICAgICBlcnJvci5tZXNzYWdlLmluY2x1ZGVzKFwiTWlzc2luZyBgcHJpdnktYXV0aG9yaXphdGlvbi1zaWduYXR1cmVgIGhlYWRlclwiKSkge1xuICAgICAgICAgICAgLy8gUHJvdmlkaW5nIGEgbW9yZSBpbmZvcm1hdGl2ZSBlcnJvciBtZXNzYWdlLCBzZWUgY29udGV4dDogaHR0cHM6Ly9naXRodWIuY29tL2NvaW5iYXNlL2FnZW50a2l0L3B1bGwvMjQyI2Rpc2N1c3Npb25fcjE5NTY0Mjg2MTdcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlByaXZ5IGVycm9yOiB5b3UgaGF2ZSBhbiBhdXRob3JpemF0aW9uIGtleSBvbiB5b3VyIGFjY291bnQgd2hpY2ggY2FuIGNyZWF0ZSBhbmQgbW9kaWZ5IHdhbGxldHMsIHBsZWFzZSBkZWxldGUgdGhpcyBrZXkgb3IgcGFzcyBpdCB0byB0aGUgUHJpdnlXYWxsZXRQcm92aWRlciB0byBjcmVhdGUgYSBuZXcgd2FsbGV0XCIpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBjcmVhdGUgd2FsbGV0XCIpO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/wallet-providers/privyShared.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/wallet-providers/privySvmWalletProvider.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/wallet-providers/privySvmWalletProvider.js ***!
  \*****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _PrivySvmWalletProvider_walletId, _PrivySvmWalletProvider_address, _PrivySvmWalletProvider_authorizationPrivateKey, _PrivySvmWalletProvider_privyClient, _PrivySvmWalletProvider_connection, _PrivySvmWalletProvider_genesisHash;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PrivySvmWalletProvider = void 0;\nconst svmWalletProvider_1 = __webpack_require__(/*! ./svmWalletProvider */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/wallet-providers/svmWalletProvider.js\");\nconst web3_js_1 = __webpack_require__(/*! @solana/web3.js */ \"(rsc)/./node_modules/@solana/web3.js/lib/index.esm.js\");\nconst svm_1 = __webpack_require__(/*! ../network/svm */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/network/svm.js\");\nconst privyShared_1 = __webpack_require__(/*! ./privyShared */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/wallet-providers/privyShared.js\");\n/**\n * A wallet provider that uses Privy's server wallet API.\n * This provider extends the SvmWalletProvider to provide Privy-specific wallet functionality\n * while maintaining compatibility with the base wallet provider interface.\n */\nclass PrivySvmWalletProvider extends svmWalletProvider_1.SvmWalletProvider {\n    /**\n     * Private constructor to enforce use of factory method.\n     *\n     * @param config - The configuration options for the Privy wallet\n     */\n    constructor(config) {\n        super();\n        _PrivySvmWalletProvider_walletId.set(this, void 0);\n        _PrivySvmWalletProvider_address.set(this, void 0);\n        _PrivySvmWalletProvider_authorizationPrivateKey.set(this, void 0);\n        _PrivySvmWalletProvider_privyClient.set(this, void 0);\n        _PrivySvmWalletProvider_connection.set(this, void 0);\n        _PrivySvmWalletProvider_genesisHash.set(this, void 0);\n        __classPrivateFieldSet(this, _PrivySvmWalletProvider_walletId, config.walletId, \"f\");\n        __classPrivateFieldSet(this, _PrivySvmWalletProvider_address, config.address, \"f\");\n        __classPrivateFieldSet(this, _PrivySvmWalletProvider_authorizationPrivateKey, config.authorizationPrivateKey, \"f\");\n        __classPrivateFieldSet(this, _PrivySvmWalletProvider_privyClient, config.privyClient, \"f\");\n        __classPrivateFieldSet(this, _PrivySvmWalletProvider_connection, config.connection, \"f\");\n        __classPrivateFieldSet(this, _PrivySvmWalletProvider_genesisHash, config.genesisHash, \"f\");\n    }\n    /**\n     * Creates and configures a new PrivySolanaWalletProvider instance.\n     *\n     * @param config - The configuration options for the Privy wallet\n     * @returns A configured PrivySolanaWalletProvider instance\n     *\n     * @example\n     * ```typescript\n     * const provider = await PrivySolanaWalletProvider.configureWithWallet({\n     *   appId: \"your-app-id\",\n     *   appSecret: \"your-app-secret\",\n     *   walletId: \"wallet-id\",\n     * });\n     * ```\n     */\n    static async configureWithWallet(config) {\n        const { wallet, privy } = await (0, privyShared_1.createPrivyWallet)({\n            ...config,\n            chainType: \"solana\",\n        });\n        const connection = config.connection ??\n            new web3_js_1.Connection((0, web3_js_1.clusterApiUrl)(svm_1.SOLANA_CLUSTER_ID_BY_NETWORK_ID[config.networkId ?? \"\"]));\n        return new PrivySvmWalletProvider({\n            ...config,\n            walletId: wallet.id,\n            address: wallet.address,\n            privyClient: privy,\n            connection,\n            genesisHash: await connection.getGenesisHash(),\n        });\n    }\n    /**\n     * Sign a transaction.\n     *\n     * @param transaction - The transaction to sign.\n     * @returns The signed transaction.\n     */\n    async signTransaction(transaction) {\n        const { signedTransaction } = await __classPrivateFieldGet(this, _PrivySvmWalletProvider_privyClient, \"f\").walletApi.solana.signTransaction({\n            walletId: __classPrivateFieldGet(this, _PrivySvmWalletProvider_walletId, \"f\"),\n            transaction,\n        });\n        return signedTransaction;\n    }\n    /**\n     * Sign and send a transaction.\n     *\n     * @param transaction - The transaction to send.\n     * @returns The transaction hash.\n     */\n    async signAndSendTransaction(transaction) {\n        try {\n            const { hash } = await __classPrivateFieldGet(this, _PrivySvmWalletProvider_privyClient, \"f\").walletApi.solana.signAndSendTransaction({\n                walletId: __classPrivateFieldGet(this, _PrivySvmWalletProvider_walletId, \"f\"),\n                caip2: `solana:${__classPrivateFieldGet(this, _PrivySvmWalletProvider_genesisHash, \"f\").substring(0, 32)}`,\n                transaction,\n            });\n            return hash;\n        }\n        catch (error) {\n            console.error(\"Failed to send transaction\", error);\n            throw new Error(\"Failed to send transaction\");\n        }\n    }\n    /**\n     * Send a transaction.\n     *\n     * @param _ - The transaction to send.\n     * @returns The transaction hash.\n     */\n    async sendTransaction(_) {\n        throw new Error(\"Method not implemented.\");\n    }\n    /**\n     * Exports the wallet data.\n     *\n     * @returns The wallet data\n     */\n    exportWallet() {\n        return {\n            walletId: __classPrivateFieldGet(this, _PrivySvmWalletProvider_walletId, \"f\"),\n            authorizationPrivateKey: __classPrivateFieldGet(this, _PrivySvmWalletProvider_authorizationPrivateKey, \"f\"),\n            chainId: this.getNetwork().chainId,\n            networkId: this.getNetwork().networkId,\n        };\n    }\n    /**\n     * Gets the name of the wallet provider.\n     *\n     * @returns The string identifier for this wallet provider\n     */\n    getName() {\n        return \"privy_svm_wallet_provider\";\n    }\n    /**\n     * Get the address of the wallet.\n     *\n     * @returns The address of the wallet.\n     */\n    getAddress() {\n        return __classPrivateFieldGet(this, _PrivySvmWalletProvider_address, \"f\");\n    }\n    /**\n     * Get the network of the wallet.\n     *\n     * @returns The network of the wallet.\n     */\n    getNetwork() {\n        return svm_1.SOLANA_NETWORKS[__classPrivateFieldGet(this, _PrivySvmWalletProvider_genesisHash, \"f\")];\n    }\n    /**\n     * Get the balance of the wallet.\n     *\n     * @returns The balance of the wallet.\n     */\n    async getBalance() {\n        const balance = await __classPrivateFieldGet(this, _PrivySvmWalletProvider_connection, \"f\").getBalance(new web3_js_1.PublicKey(__classPrivateFieldGet(this, _PrivySvmWalletProvider_address, \"f\")));\n        return BigInt(balance);\n    }\n    /**\n     * Transfer a native token.\n     *\n     * @param _ - The address to transfer the token to.\n     * @param arg2 - The value to transfer.\n     * @returns The transaction hash.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async nativeTransfer(_, arg2) {\n        throw new Error(\"Method not implemented.\");\n    }\n    /**\n     * Get the status of a transaction.\n     *\n     * @param signature - The transaction signature.\n     * @returns The transaction status.\n     */\n    async getSignatureStatus(signature) {\n        return __classPrivateFieldGet(this, _PrivySvmWalletProvider_connection, \"f\").getSignatureStatus(signature);\n    }\n    /**\n     * Wait for a signature result.\n     *\n     * @param signature - The signature to wait for.\n     * @returns The signature result.\n     */\n    waitForSignatureResult(signature) {\n        return __classPrivateFieldGet(this, _PrivySvmWalletProvider_connection, \"f\").confirmTransaction({\n            signature,\n            ...svm_1.SOLANA_NETWORKS[__classPrivateFieldGet(this, _PrivySvmWalletProvider_genesisHash, \"f\")],\n        });\n    }\n    /**\n     * Get the connection.\n     *\n     * @returns The connection.\n     */\n    getConnection() {\n        return __classPrivateFieldGet(this, _PrivySvmWalletProvider_connection, \"f\");\n    }\n    /**\n     * Get the public key.\n     *\n     * @returns The public key.\n     */\n    getPublicKey() {\n        return new web3_js_1.PublicKey(__classPrivateFieldGet(this, _PrivySvmWalletProvider_address, \"f\"));\n    }\n}\nexports.PrivySvmWalletProvider = PrivySvmWalletProvider;\n_PrivySvmWalletProvider_walletId = new WeakMap(), _PrivySvmWalletProvider_address = new WeakMap(), _PrivySvmWalletProvider_authorizationPrivateKey = new WeakMap(), _PrivySvmWalletProvider_privyClient = new WeakMap(), _PrivySvmWalletProvider_connection = new WeakMap(), _PrivySvmWalletProvider_genesisHash = new WeakMap();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3Qvd2FsbGV0LXByb3ZpZGVycy9wcml2eVN2bVdhbGxldFByb3ZpZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDhCQUE4QjtBQUM5Qiw0QkFBNEIsbUJBQU8sQ0FBQywrR0FBcUI7QUFDekQsa0JBQWtCLG1CQUFPLENBQUMsOEVBQWlCO0FBQzNDLGNBQWMsbUJBQU8sQ0FBQyxtRkFBZ0I7QUFDdEMsc0JBQXNCLG1CQUFPLENBQUMsbUdBQWU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0JBQWdCO0FBQ2hDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBLGlDQUFpQyx3RkFBd0Y7QUFDekg7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXJ2aXZhbC1mdW4vLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3Qvd2FsbGV0LXByb3ZpZGVycy9wcml2eVN2bVdhbGxldFByb3ZpZGVyLmpzPzI3MmEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZFNldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZFNldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwgdmFsdWUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XG59O1xudmFyIF9fY2xhc3NQcml2YXRlRmllbGRHZXQgPSAodGhpcyAmJiB0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRHZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcbn07XG52YXIgX1ByaXZ5U3ZtV2FsbGV0UHJvdmlkZXJfd2FsbGV0SWQsIF9Qcml2eVN2bVdhbGxldFByb3ZpZGVyX2FkZHJlc3MsIF9Qcml2eVN2bVdhbGxldFByb3ZpZGVyX2F1dGhvcml6YXRpb25Qcml2YXRlS2V5LCBfUHJpdnlTdm1XYWxsZXRQcm92aWRlcl9wcml2eUNsaWVudCwgX1ByaXZ5U3ZtV2FsbGV0UHJvdmlkZXJfY29ubmVjdGlvbiwgX1ByaXZ5U3ZtV2FsbGV0UHJvdmlkZXJfZ2VuZXNpc0hhc2g7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlByaXZ5U3ZtV2FsbGV0UHJvdmlkZXIgPSB2b2lkIDA7XG5jb25zdCBzdm1XYWxsZXRQcm92aWRlcl8xID0gcmVxdWlyZShcIi4vc3ZtV2FsbGV0UHJvdmlkZXJcIik7XG5jb25zdCB3ZWIzX2pzXzEgPSByZXF1aXJlKFwiQHNvbGFuYS93ZWIzLmpzXCIpO1xuY29uc3Qgc3ZtXzEgPSByZXF1aXJlKFwiLi4vbmV0d29yay9zdm1cIik7XG5jb25zdCBwcml2eVNoYXJlZF8xID0gcmVxdWlyZShcIi4vcHJpdnlTaGFyZWRcIik7XG4vKipcbiAqIEEgd2FsbGV0IHByb3ZpZGVyIHRoYXQgdXNlcyBQcml2eSdzIHNlcnZlciB3YWxsZXQgQVBJLlxuICogVGhpcyBwcm92aWRlciBleHRlbmRzIHRoZSBTdm1XYWxsZXRQcm92aWRlciB0byBwcm92aWRlIFByaXZ5LXNwZWNpZmljIHdhbGxldCBmdW5jdGlvbmFsaXR5XG4gKiB3aGlsZSBtYWludGFpbmluZyBjb21wYXRpYmlsaXR5IHdpdGggdGhlIGJhc2Ugd2FsbGV0IHByb3ZpZGVyIGludGVyZmFjZS5cbiAqL1xuY2xhc3MgUHJpdnlTdm1XYWxsZXRQcm92aWRlciBleHRlbmRzIHN2bVdhbGxldFByb3ZpZGVyXzEuU3ZtV2FsbGV0UHJvdmlkZXIge1xuICAgIC8qKlxuICAgICAqIFByaXZhdGUgY29uc3RydWN0b3IgdG8gZW5mb3JjZSB1c2Ugb2YgZmFjdG9yeSBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29uZmlnIC0gVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIFByaXZ5IHdhbGxldFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBfUHJpdnlTdm1XYWxsZXRQcm92aWRlcl93YWxsZXRJZC5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX1ByaXZ5U3ZtV2FsbGV0UHJvdmlkZXJfYWRkcmVzcy5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX1ByaXZ5U3ZtV2FsbGV0UHJvdmlkZXJfYXV0aG9yaXphdGlvblByaXZhdGVLZXkuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9Qcml2eVN2bVdhbGxldFByb3ZpZGVyX3ByaXZ5Q2xpZW50LnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICBfUHJpdnlTdm1XYWxsZXRQcm92aWRlcl9jb25uZWN0aW9uLnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICBfUHJpdnlTdm1XYWxsZXRQcm92aWRlcl9nZW5lc2lzSGFzaC5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfUHJpdnlTdm1XYWxsZXRQcm92aWRlcl93YWxsZXRJZCwgY29uZmlnLndhbGxldElkLCBcImZcIik7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX1ByaXZ5U3ZtV2FsbGV0UHJvdmlkZXJfYWRkcmVzcywgY29uZmlnLmFkZHJlc3MsIFwiZlwiKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfUHJpdnlTdm1XYWxsZXRQcm92aWRlcl9hdXRob3JpemF0aW9uUHJpdmF0ZUtleSwgY29uZmlnLmF1dGhvcml6YXRpb25Qcml2YXRlS2V5LCBcImZcIik7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX1ByaXZ5U3ZtV2FsbGV0UHJvdmlkZXJfcHJpdnlDbGllbnQsIGNvbmZpZy5wcml2eUNsaWVudCwgXCJmXCIpO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9Qcml2eVN2bVdhbGxldFByb3ZpZGVyX2Nvbm5lY3Rpb24sIGNvbmZpZy5jb25uZWN0aW9uLCBcImZcIik7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX1ByaXZ5U3ZtV2FsbGV0UHJvdmlkZXJfZ2VuZXNpc0hhc2gsIGNvbmZpZy5nZW5lc2lzSGFzaCwgXCJmXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuZCBjb25maWd1cmVzIGEgbmV3IFByaXZ5U29sYW5hV2FsbGV0UHJvdmlkZXIgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29uZmlnIC0gVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIFByaXZ5IHdhbGxldFxuICAgICAqIEByZXR1cm5zIEEgY29uZmlndXJlZCBQcml2eVNvbGFuYVdhbGxldFByb3ZpZGVyIGluc3RhbmNlXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCBwcm92aWRlciA9IGF3YWl0IFByaXZ5U29sYW5hV2FsbGV0UHJvdmlkZXIuY29uZmlndXJlV2l0aFdhbGxldCh7XG4gICAgICogICBhcHBJZDogXCJ5b3VyLWFwcC1pZFwiLFxuICAgICAqICAgYXBwU2VjcmV0OiBcInlvdXItYXBwLXNlY3JldFwiLFxuICAgICAqICAgd2FsbGV0SWQ6IFwid2FsbGV0LWlkXCIsXG4gICAgICogfSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIGNvbmZpZ3VyZVdpdGhXYWxsZXQoY29uZmlnKSB7XG4gICAgICAgIGNvbnN0IHsgd2FsbGV0LCBwcml2eSB9ID0gYXdhaXQgKDAsIHByaXZ5U2hhcmVkXzEuY3JlYXRlUHJpdnlXYWxsZXQpKHtcbiAgICAgICAgICAgIC4uLmNvbmZpZyxcbiAgICAgICAgICAgIGNoYWluVHlwZTogXCJzb2xhbmFcIixcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBjb25maWcuY29ubmVjdGlvbiA/P1xuICAgICAgICAgICAgbmV3IHdlYjNfanNfMS5Db25uZWN0aW9uKCgwLCB3ZWIzX2pzXzEuY2x1c3RlckFwaVVybCkoc3ZtXzEuU09MQU5BX0NMVVNURVJfSURfQllfTkVUV09SS19JRFtjb25maWcubmV0d29ya0lkID8/IFwiXCJdKSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJpdnlTdm1XYWxsZXRQcm92aWRlcih7XG4gICAgICAgICAgICAuLi5jb25maWcsXG4gICAgICAgICAgICB3YWxsZXRJZDogd2FsbGV0LmlkLFxuICAgICAgICAgICAgYWRkcmVzczogd2FsbGV0LmFkZHJlc3MsXG4gICAgICAgICAgICBwcml2eUNsaWVudDogcHJpdnksXG4gICAgICAgICAgICBjb25uZWN0aW9uLFxuICAgICAgICAgICAgZ2VuZXNpc0hhc2g6IGF3YWl0IGNvbm5lY3Rpb24uZ2V0R2VuZXNpc0hhc2goKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNpZ24gYSB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0cmFuc2FjdGlvbiAtIFRoZSB0cmFuc2FjdGlvbiB0byBzaWduLlxuICAgICAqIEByZXR1cm5zIFRoZSBzaWduZWQgdHJhbnNhY3Rpb24uXG4gICAgICovXG4gICAgYXN5bmMgc2lnblRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IHsgc2lnbmVkVHJhbnNhY3Rpb24gfSA9IGF3YWl0IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1ByaXZ5U3ZtV2FsbGV0UHJvdmlkZXJfcHJpdnlDbGllbnQsIFwiZlwiKS53YWxsZXRBcGkuc29sYW5hLnNpZ25UcmFuc2FjdGlvbih7XG4gICAgICAgICAgICB3YWxsZXRJZDogX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfUHJpdnlTdm1XYWxsZXRQcm92aWRlcl93YWxsZXRJZCwgXCJmXCIpLFxuICAgICAgICAgICAgdHJhbnNhY3Rpb24sXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc2lnbmVkVHJhbnNhY3Rpb247XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNpZ24gYW5kIHNlbmQgYSB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0cmFuc2FjdGlvbiAtIFRoZSB0cmFuc2FjdGlvbiB0byBzZW5kLlxuICAgICAqIEByZXR1cm5zIFRoZSB0cmFuc2FjdGlvbiBoYXNoLlxuICAgICAqL1xuICAgIGFzeW5jIHNpZ25BbmRTZW5kVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHsgaGFzaCB9ID0gYXdhaXQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfUHJpdnlTdm1XYWxsZXRQcm92aWRlcl9wcml2eUNsaWVudCwgXCJmXCIpLndhbGxldEFwaS5zb2xhbmEuc2lnbkFuZFNlbmRUcmFuc2FjdGlvbih7XG4gICAgICAgICAgICAgICAgd2FsbGV0SWQ6IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1ByaXZ5U3ZtV2FsbGV0UHJvdmlkZXJfd2FsbGV0SWQsIFwiZlwiKSxcbiAgICAgICAgICAgICAgICBjYWlwMjogYHNvbGFuYToke19fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1ByaXZ5U3ZtV2FsbGV0UHJvdmlkZXJfZ2VuZXNpc0hhc2gsIFwiZlwiKS5zdWJzdHJpbmcoMCwgMzIpfWAsXG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBoYXNoO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBzZW5kIHRyYW5zYWN0aW9uXCIsIGVycm9yKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBzZW5kIHRyYW5zYWN0aW9uXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmQgYSB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBfIC0gVGhlIHRyYW5zYWN0aW9uIHRvIHNlbmQuXG4gICAgICogQHJldHVybnMgVGhlIHRyYW5zYWN0aW9uIGhhc2guXG4gICAgICovXG4gICAgYXN5bmMgc2VuZFRyYW5zYWN0aW9uKF8pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC5cIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4cG9ydHMgdGhlIHdhbGxldCBkYXRhLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHdhbGxldCBkYXRhXG4gICAgICovXG4gICAgZXhwb3J0V2FsbGV0KCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2FsbGV0SWQ6IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1ByaXZ5U3ZtV2FsbGV0UHJvdmlkZXJfd2FsbGV0SWQsIFwiZlwiKSxcbiAgICAgICAgICAgIGF1dGhvcml6YXRpb25Qcml2YXRlS2V5OiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Qcml2eVN2bVdhbGxldFByb3ZpZGVyX2F1dGhvcml6YXRpb25Qcml2YXRlS2V5LCBcImZcIiksXG4gICAgICAgICAgICBjaGFpbklkOiB0aGlzLmdldE5ldHdvcmsoKS5jaGFpbklkLFxuICAgICAgICAgICAgbmV0d29ya0lkOiB0aGlzLmdldE5ldHdvcmsoKS5uZXR3b3JrSWQsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG5hbWUgb2YgdGhlIHdhbGxldCBwcm92aWRlci5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBzdHJpbmcgaWRlbnRpZmllciBmb3IgdGhpcyB3YWxsZXQgcHJvdmlkZXJcbiAgICAgKi9cbiAgICBnZXROYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJwcml2eV9zdm1fd2FsbGV0X3Byb3ZpZGVyXCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgYWRkcmVzcyBvZiB0aGUgd2FsbGV0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGFkZHJlc3Mgb2YgdGhlIHdhbGxldC5cbiAgICAgKi9cbiAgICBnZXRBZGRyZXNzKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfUHJpdnlTdm1XYWxsZXRQcm92aWRlcl9hZGRyZXNzLCBcImZcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbmV0d29yayBvZiB0aGUgd2FsbGV0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIG5ldHdvcmsgb2YgdGhlIHdhbGxldC5cbiAgICAgKi9cbiAgICBnZXROZXR3b3JrKCkge1xuICAgICAgICByZXR1cm4gc3ZtXzEuU09MQU5BX05FVFdPUktTW19fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1ByaXZ5U3ZtV2FsbGV0UHJvdmlkZXJfZ2VuZXNpc0hhc2gsIFwiZlwiKV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgYmFsYW5jZSBvZiB0aGUgd2FsbGV0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGJhbGFuY2Ugb2YgdGhlIHdhbGxldC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRCYWxhbmNlKCkge1xuICAgICAgICBjb25zdCBiYWxhbmNlID0gYXdhaXQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfUHJpdnlTdm1XYWxsZXRQcm92aWRlcl9jb25uZWN0aW9uLCBcImZcIikuZ2V0QmFsYW5jZShuZXcgd2ViM19qc18xLlB1YmxpY0tleShfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Qcml2eVN2bVdhbGxldFByb3ZpZGVyX2FkZHJlc3MsIFwiZlwiKSkpO1xuICAgICAgICByZXR1cm4gQmlnSW50KGJhbGFuY2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmFuc2ZlciBhIG5hdGl2ZSB0b2tlbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBfIC0gVGhlIGFkZHJlc3MgdG8gdHJhbnNmZXIgdGhlIHRva2VuIHRvLlxuICAgICAqIEBwYXJhbSBhcmcyIC0gVGhlIHZhbHVlIHRvIHRyYW5zZmVyLlxuICAgICAqIEByZXR1cm5zIFRoZSB0cmFuc2FjdGlvbiBoYXNoLlxuICAgICAqL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBhc3luYyBuYXRpdmVUcmFuc2ZlcihfLCBhcmcyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1ldGhvZCBub3QgaW1wbGVtZW50ZWQuXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHN0YXR1cyBvZiBhIHRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNpZ25hdHVyZSAtIFRoZSB0cmFuc2FjdGlvbiBzaWduYXR1cmUuXG4gICAgICogQHJldHVybnMgVGhlIHRyYW5zYWN0aW9uIHN0YXR1cy5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRTaWduYXR1cmVTdGF0dXMoc2lnbmF0dXJlKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Qcml2eVN2bVdhbGxldFByb3ZpZGVyX2Nvbm5lY3Rpb24sIFwiZlwiKS5nZXRTaWduYXR1cmVTdGF0dXMoc2lnbmF0dXJlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2FpdCBmb3IgYSBzaWduYXR1cmUgcmVzdWx0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHNpZ25hdHVyZSAtIFRoZSBzaWduYXR1cmUgdG8gd2FpdCBmb3IuXG4gICAgICogQHJldHVybnMgVGhlIHNpZ25hdHVyZSByZXN1bHQuXG4gICAgICovXG4gICAgd2FpdEZvclNpZ25hdHVyZVJlc3VsdChzaWduYXR1cmUpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1ByaXZ5U3ZtV2FsbGV0UHJvdmlkZXJfY29ubmVjdGlvbiwgXCJmXCIpLmNvbmZpcm1UcmFuc2FjdGlvbih7XG4gICAgICAgICAgICBzaWduYXR1cmUsXG4gICAgICAgICAgICAuLi5zdm1fMS5TT0xBTkFfTkVUV09SS1NbX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfUHJpdnlTdm1XYWxsZXRQcm92aWRlcl9nZW5lc2lzSGFzaCwgXCJmXCIpXSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY29ubmVjdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBjb25uZWN0aW9uLlxuICAgICAqL1xuICAgIGdldENvbm5lY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Qcml2eVN2bVdhbGxldFByb3ZpZGVyX2Nvbm5lY3Rpb24sIFwiZlwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBwdWJsaWMga2V5LlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHB1YmxpYyBrZXkuXG4gICAgICovXG4gICAgZ2V0UHVibGljS2V5KCkge1xuICAgICAgICByZXR1cm4gbmV3IHdlYjNfanNfMS5QdWJsaWNLZXkoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfUHJpdnlTdm1XYWxsZXRQcm92aWRlcl9hZGRyZXNzLCBcImZcIikpO1xuICAgIH1cbn1cbmV4cG9ydHMuUHJpdnlTdm1XYWxsZXRQcm92aWRlciA9IFByaXZ5U3ZtV2FsbGV0UHJvdmlkZXI7XG5fUHJpdnlTdm1XYWxsZXRQcm92aWRlcl93YWxsZXRJZCA9IG5ldyBXZWFrTWFwKCksIF9Qcml2eVN2bVdhbGxldFByb3ZpZGVyX2FkZHJlc3MgPSBuZXcgV2Vha01hcCgpLCBfUHJpdnlTdm1XYWxsZXRQcm92aWRlcl9hdXRob3JpemF0aW9uUHJpdmF0ZUtleSA9IG5ldyBXZWFrTWFwKCksIF9Qcml2eVN2bVdhbGxldFByb3ZpZGVyX3ByaXZ5Q2xpZW50ID0gbmV3IFdlYWtNYXAoKSwgX1ByaXZ5U3ZtV2FsbGV0UHJvdmlkZXJfY29ubmVjdGlvbiA9IG5ldyBXZWFrTWFwKCksIF9Qcml2eVN2bVdhbGxldFByb3ZpZGVyX2dlbmVzaXNIYXNoID0gbmV3IFdlYWtNYXAoKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/wallet-providers/privySvmWalletProvider.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/wallet-providers/privyWalletProvider.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/wallet-providers/privyWalletProvider.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PrivyWalletProvider = void 0;\nconst privyEvmWalletProvider_1 = __webpack_require__(/*! ./privyEvmWalletProvider */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/wallet-providers/privyEvmWalletProvider.js\");\nconst privySvmWalletProvider_1 = __webpack_require__(/*! ./privySvmWalletProvider */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/wallet-providers/privySvmWalletProvider.js\");\nconst privyEvmDelegatedEmbeddedWalletProvider_1 = __webpack_require__(/*! ./privyEvmDelegatedEmbeddedWalletProvider */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/wallet-providers/privyEvmDelegatedEmbeddedWalletProvider.js\");\n/**\n * Factory class for creating chain-specific Privy wallet providers\n */\nclass PrivyWalletProvider {\n    /**\n     * Creates and configures a new wallet provider instance based on the chain type and wallet type.\n     *\n     * @param config - The configuration options for the Privy wallet\n     * @returns A configured WalletProvider instance for the specified chain and wallet type\n     *\n     * @example\n     * ```typescript\n     * // For EVM server wallets (default)\n     * const evmWallet = await PrivyWalletProvider.configureWithWallet({\n     *   appId: \"your-app-id\",\n     *   appSecret: \"your-app-secret\"\n     * });\n     *\n     * // For Solana server wallets\n     * const solanaWallet = await PrivyWalletProvider.configureWithWallet({\n     *   appId: \"your-app-id\",\n     *   appSecret: \"your-app-secret\",\n     *   chainType: \"solana\"\n     * });\n     *\n     * // For Ethereum embedded wallets\n     * const embeddedWallet = await PrivyWalletProvider.configureWithWallet({\n     *   appId: \"your-app-id\",\n     *   appSecret: \"your-app-secret\",\n     *   walletId: \"delegated-wallet-id\",\n     *   walletType: \"embedded\"\n     * });\n     * ```\n     */\n    static async configureWithWallet(config) {\n        const chainType = config.chainType || \"ethereum\";\n        const walletType = config.walletType || \"server\";\n        switch (chainType) {\n            case \"ethereum\": {\n                switch (walletType) {\n                    case \"server\":\n                        return (await privyEvmWalletProvider_1.PrivyEvmWalletProvider.configureWithWallet(config));\n                    case \"embedded\":\n                        return (await privyEvmDelegatedEmbeddedWalletProvider_1.PrivyEvmDelegatedEmbeddedWalletProvider.configureWithWallet(config));\n                    default:\n                        throw new Error(\"Invalid wallet type\");\n                }\n            }\n            case \"solana\": {\n                switch (walletType) {\n                    case \"server\":\n                        return (await privySvmWalletProvider_1.PrivySvmWalletProvider.configureWithWallet(config));\n                    case \"embedded\":\n                        throw new Error(\"Embedded wallets are not supported for Solana\");\n                    default:\n                        throw new Error(\"Invalid wallet type\");\n                }\n            }\n            default: {\n                throw new Error(\"Invalid chain type\");\n            }\n        }\n    }\n}\nexports.PrivyWalletProvider = PrivyWalletProvider;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3Qvd2FsbGV0LXByb3ZpZGVycy9wcml2eVdhbGxldFByb3ZpZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDJCQUEyQjtBQUMzQixpQ0FBaUMsbUJBQU8sQ0FBQyx5SEFBMEI7QUFDbkUsaUNBQWlDLG1CQUFPLENBQUMseUhBQTBCO0FBQ25FLGtEQUFrRCxtQkFBTyxDQUFDLDJKQUEyQztBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cnZpdmFsLWZ1bi8uL25vZGVfbW9kdWxlcy9AY29pbmJhc2UvYWdlbnRraXQvZGlzdC93YWxsZXQtcHJvdmlkZXJzL3ByaXZ5V2FsbGV0UHJvdmlkZXIuanM/OWFjYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUHJpdnlXYWxsZXRQcm92aWRlciA9IHZvaWQgMDtcbmNvbnN0IHByaXZ5RXZtV2FsbGV0UHJvdmlkZXJfMSA9IHJlcXVpcmUoXCIuL3ByaXZ5RXZtV2FsbGV0UHJvdmlkZXJcIik7XG5jb25zdCBwcml2eVN2bVdhbGxldFByb3ZpZGVyXzEgPSByZXF1aXJlKFwiLi9wcml2eVN2bVdhbGxldFByb3ZpZGVyXCIpO1xuY29uc3QgcHJpdnlFdm1EZWxlZ2F0ZWRFbWJlZGRlZFdhbGxldFByb3ZpZGVyXzEgPSByZXF1aXJlKFwiLi9wcml2eUV2bURlbGVnYXRlZEVtYmVkZGVkV2FsbGV0UHJvdmlkZXJcIik7XG4vKipcbiAqIEZhY3RvcnkgY2xhc3MgZm9yIGNyZWF0aW5nIGNoYWluLXNwZWNpZmljIFByaXZ5IHdhbGxldCBwcm92aWRlcnNcbiAqL1xuY2xhc3MgUHJpdnlXYWxsZXRQcm92aWRlciB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbmQgY29uZmlndXJlcyBhIG5ldyB3YWxsZXQgcHJvdmlkZXIgaW5zdGFuY2UgYmFzZWQgb24gdGhlIGNoYWluIHR5cGUgYW5kIHdhbGxldCB0eXBlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbmZpZyAtIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBQcml2eSB3YWxsZXRcbiAgICAgKiBAcmV0dXJucyBBIGNvbmZpZ3VyZWQgV2FsbGV0UHJvdmlkZXIgaW5zdGFuY2UgZm9yIHRoZSBzcGVjaWZpZWQgY2hhaW4gYW5kIHdhbGxldCB0eXBlXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiAvLyBGb3IgRVZNIHNlcnZlciB3YWxsZXRzIChkZWZhdWx0KVxuICAgICAqIGNvbnN0IGV2bVdhbGxldCA9IGF3YWl0IFByaXZ5V2FsbGV0UHJvdmlkZXIuY29uZmlndXJlV2l0aFdhbGxldCh7XG4gICAgICogICBhcHBJZDogXCJ5b3VyLWFwcC1pZFwiLFxuICAgICAqICAgYXBwU2VjcmV0OiBcInlvdXItYXBwLXNlY3JldFwiXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiAvLyBGb3IgU29sYW5hIHNlcnZlciB3YWxsZXRzXG4gICAgICogY29uc3Qgc29sYW5hV2FsbGV0ID0gYXdhaXQgUHJpdnlXYWxsZXRQcm92aWRlci5jb25maWd1cmVXaXRoV2FsbGV0KHtcbiAgICAgKiAgIGFwcElkOiBcInlvdXItYXBwLWlkXCIsXG4gICAgICogICBhcHBTZWNyZXQ6IFwieW91ci1hcHAtc2VjcmV0XCIsXG4gICAgICogICBjaGFpblR5cGU6IFwic29sYW5hXCJcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIC8vIEZvciBFdGhlcmV1bSBlbWJlZGRlZCB3YWxsZXRzXG4gICAgICogY29uc3QgZW1iZWRkZWRXYWxsZXQgPSBhd2FpdCBQcml2eVdhbGxldFByb3ZpZGVyLmNvbmZpZ3VyZVdpdGhXYWxsZXQoe1xuICAgICAqICAgYXBwSWQ6IFwieW91ci1hcHAtaWRcIixcbiAgICAgKiAgIGFwcFNlY3JldDogXCJ5b3VyLWFwcC1zZWNyZXRcIixcbiAgICAgKiAgIHdhbGxldElkOiBcImRlbGVnYXRlZC13YWxsZXQtaWRcIixcbiAgICAgKiAgIHdhbGxldFR5cGU6IFwiZW1iZWRkZWRcIlxuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyBjb25maWd1cmVXaXRoV2FsbGV0KGNvbmZpZykge1xuICAgICAgICBjb25zdCBjaGFpblR5cGUgPSBjb25maWcuY2hhaW5UeXBlIHx8IFwiZXRoZXJldW1cIjtcbiAgICAgICAgY29uc3Qgd2FsbGV0VHlwZSA9IGNvbmZpZy53YWxsZXRUeXBlIHx8IFwic2VydmVyXCI7XG4gICAgICAgIHN3aXRjaCAoY2hhaW5UeXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwiZXRoZXJldW1cIjoge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAod2FsbGV0VHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwic2VydmVyXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGF3YWl0IHByaXZ5RXZtV2FsbGV0UHJvdmlkZXJfMS5Qcml2eUV2bVdhbGxldFByb3ZpZGVyLmNvbmZpZ3VyZVdpdGhXYWxsZXQoY29uZmlnKSk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbWJlZGRlZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChhd2FpdCBwcml2eUV2bURlbGVnYXRlZEVtYmVkZGVkV2FsbGV0UHJvdmlkZXJfMS5Qcml2eUV2bURlbGVnYXRlZEVtYmVkZGVkV2FsbGV0UHJvdmlkZXIuY29uZmlndXJlV2l0aFdhbGxldChjb25maWcpKTtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgd2FsbGV0IHR5cGVcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInNvbGFuYVwiOiB7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh3YWxsZXRUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzZXJ2ZXJcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoYXdhaXQgcHJpdnlTdm1XYWxsZXRQcm92aWRlcl8xLlByaXZ5U3ZtV2FsbGV0UHJvdmlkZXIuY29uZmlndXJlV2l0aFdhbGxldChjb25maWcpKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVtYmVkZGVkXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFbWJlZGRlZCB3YWxsZXRzIGFyZSBub3Qgc3VwcG9ydGVkIGZvciBTb2xhbmFcIik7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHdhbGxldCB0eXBlXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGNoYWluIHR5cGVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLlByaXZ5V2FsbGV0UHJvdmlkZXIgPSBQcml2eVdhbGxldFByb3ZpZGVyO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/wallet-providers/privyWalletProvider.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/wallet-providers/smartWalletProvider.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/wallet-providers/smartWalletProvider.js ***!
  \**************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _SmartWalletProvider_smartWallet, _SmartWalletProvider_network, _SmartWalletProvider_publicClient;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SmartWalletProvider = void 0;\nconst coinbase_sdk_1 = __webpack_require__(/*! @coinbase/coinbase-sdk */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/index.js\");\nconst viem_1 = __webpack_require__(/*! viem */ \"(rsc)/./node_modules/viem/_cjs/index.js\");\nconst network_1 = __webpack_require__(/*! ../network */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/network/index.js\");\nconst evmWalletProvider_1 = __webpack_require__(/*! ./evmWalletProvider */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/wallet-providers/evmWalletProvider.js\");\nconst package_json_1 = __webpack_require__(/*! ../../package.json */ \"(rsc)/./node_modules/@coinbase/agentkit/package.json\");\n/**\n * A wallet provider that uses Smart Wallets from the Coinbase SDK.\n */\nclass SmartWalletProvider extends evmWalletProvider_1.EvmWalletProvider {\n    /**\n     * Constructs a new CdpWalletProvider.\n     *\n     * @param config - The configuration options for the CdpWalletProvider.\n     */\n    constructor(config) {\n        super();\n        _SmartWalletProvider_smartWallet.set(this, void 0);\n        _SmartWalletProvider_network.set(this, void 0);\n        _SmartWalletProvider_publicClient.set(this, void 0);\n        __classPrivateFieldSet(this, _SmartWalletProvider_network, config.network, \"f\");\n        __classPrivateFieldSet(this, _SmartWalletProvider_smartWallet, config.smartWallet, \"f\");\n        __classPrivateFieldSet(this, _SmartWalletProvider_publicClient, (0, viem_1.createPublicClient)({\n            chain: network_1.NETWORK_ID_TO_VIEM_CHAIN[config.network.networkId],\n            transport: (0, viem_1.http)(),\n        }), \"f\");\n    }\n    /**\n     * Configures and returns a `SmartWalletProvider` instance using the provided configuration options.\n     * This method initializes a smart wallet based on the given network and credentials.\n     *\n     * @param {ConfigureSmartWalletOptions} config\n     *   - Configuration parameters for setting up the smart wallet.\n     *\n     * @returns {Promise<SmartWalletProvider>}\n     *   - A promise that resolves to an instance of `SmartWalletProvider` configured with the provided settings.\n     *\n     * @throws {Error}\n     *   - If networkId is not a supported network.\n     *\n     * @example\n     * ```typescript\n     * const smartWalletProvider = await SmartWalletProvider.configureWithWallet({\n     *   networkId: \"base-sepolia\",\n     *   signer: privateKeyToAccount(\"0xethprivatekey\"),\n     *   cdpApiKeyName: \"my-api-key\",\n     *   cdpApiKeyPrivateKey: \"my-private-key\",\n     *   smartWalletAddress: \"0x123456...\",\n     * });\n     * ```\n     */\n    static async configureWithWallet(config) {\n        const networkId = config.networkId || process.env.NETWORK_ID || coinbase_sdk_1.Coinbase.networks.BaseSepolia;\n        const network = {\n            protocolFamily: \"evm\",\n            chainId: network_1.NETWORK_ID_TO_CHAIN_ID[networkId],\n            networkId,\n        };\n        if (!network.chainId) {\n            throw new Error(`Unable to determine chainId for network ${networkId}`);\n        }\n        const supportedChainIds = Object.keys(coinbase_sdk_1.CHAIN_ID_TO_NETWORK_ID);\n        if (!supportedChainIds.includes(network.chainId)) {\n            throw new Error(`Invalid chain id ${network.chainId}. Chain id must be one of ${supportedChainIds.join(\", \")}`);\n        }\n        const cdpApiKeyName = config.cdpApiKeyName || process.env.CDP_API_KEY_NAME;\n        const cdpApiKeyPrivateKey = config.cdpApiKeyPrivateKey || process.env.CDP_API_KEY_PRIVATE_KEY;\n        if (cdpApiKeyName && cdpApiKeyPrivateKey) {\n            coinbase_sdk_1.Coinbase.configure({\n                apiKeyName: cdpApiKeyName,\n                privateKey: cdpApiKeyPrivateKey?.replace(/\\\\n/g, \"\\n\"),\n                source: \"agentkit\",\n                sourceVersion: package_json_1.version,\n            });\n        }\n        else {\n            coinbase_sdk_1.Coinbase.configureFromJson({ source: \"agentkit\", sourceVersion: package_json_1.version });\n        }\n        const smartWallet = config.smartWalletAddress\n            ? (0, coinbase_sdk_1.toSmartWallet)({\n                signer: config.signer,\n                smartWalletAddress: config.smartWalletAddress,\n            })\n            : await (0, coinbase_sdk_1.createSmartWallet)({\n                signer: config.signer,\n            });\n        const networkScopedSmartWallet = smartWallet.useNetwork({\n            chainId: Number(network.chainId),\n            paymasterUrl: config.paymasterUrl,\n        });\n        const smartWalletProvider = new SmartWalletProvider({\n            smartWallet: networkScopedSmartWallet,\n            network,\n            chainId: network.chainId,\n        });\n        return smartWalletProvider;\n    }\n    /**\n     * Stub for message signing\n     *\n     * @throws as signing messages is not implemented for SmartWallets.\n     *\n     * @param _ - The message to sign.\n     * @returns The signed message.\n     */\n    async signMessage(_) {\n        throw new Error(\"Not implemented\");\n    }\n    /**\n     * Stub for typed data signing\n     *\n     * @throws as signing typed data is not implemented for SmartWallets.\n     *\n     * @param _ - The typed data object to sign.\n     * @returns The signed typed data object.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    async signTypedData(_) {\n        throw new Error(\"Not implemented\");\n    }\n    /**\n     * Stub for transaction signing\n     *\n     * @throws as signing transactions is not implemented for SmartWallets.\n     *\n     * @param _ - The transaction to sign.\n     * @returns The signed transaction.\n     */\n    async signTransaction(_) {\n        throw new Error(\"Not implemented\");\n    }\n    /**\n     * Sends a transaction using the smart wallet.\n     *\n     * Unlike traditional Ethereum transactions, this method submits a **User Operation**\n     * instead of directly broadcasting a transaction. The smart wallet handles execution,\n     * but a standard transaction hash is still returned upon completion.\n     *\n     * @param {TransactionRequest} transaction - The transaction details, including:\n     *   - `to`: The recipient address.\n     *   - `value`: The amount of ETH (or native token) to send.\n     *   - `data`: Optional calldata for contract interactions.\n     *\n     * @returns A promise resolving to the transaction hash (`0x...`).\n     *\n     * @throws {Error} If the transaction does not complete successfully.\n     *\n     * @example\n     * ```typescript\n     * const txHash = await smartWallet.sendTransaction({\n     *   to: \"0x123...\",\n     *   value: parseEther(\"0.1\"),\n     *   data: \"0x\",\n     * });\n     * console.log(`Transaction sent: ${txHash}`);\n     * ```\n     */\n    sendTransaction(transaction) {\n        const { to, value, data } = transaction;\n        return this.sendUserOperation({\n            calls: [\n                {\n                    to: to,\n                    value,\n                    data,\n                },\n            ],\n        });\n    }\n    /**\n     * Sends a **User Operation** to the smart wallet.\n     *\n     * This method directly exposes the **sendUserOperation** functionality, allowing\n     * **SmartWallet-aware tools** to fully leverage its capabilities, including batching multiple calls.\n     * Unlike `sendTransaction`, which wraps calls in a single operation, this method allows\n     * direct execution of arbitrary operations within a **User Operation**.\n     *\n     * @param {Omit<SendUserOperationOptions<T>, \"chainId\" | \"paymasterUrl\">} operation\n     *   - The user operation configuration, omitting `chainId` and `paymasterUrl`,\n     *     which are managed internally by the smart wallet.\n     *\n     * @returns A promise resolving to the transaction hash (`0x...`) if the operation completes successfully.\n     *\n     * @throws {Error} If the operation does not complete successfully.\n     *\n     * @example\n     * ```typescript\n     * const txHash = await smartWallet.sendUserOperation({\n     *   calls: [\n     *     { to: \"0x123...\", value: parseEther(\"0.1\"), data: \"0x\" },\n     *     { to: \"0x456...\", value: parseEther(\"0.05\"), data: \"0x\" }\n     *   ],\n     * });\n     * console.log(`User Operation sent: ${txHash}`);\n     * ```\n     */\n    async sendUserOperation(operation) {\n        const sendUserOperationResult = await __classPrivateFieldGet(this, _SmartWalletProvider_smartWallet, \"f\").sendUserOperation(operation);\n        const result = await (0, coinbase_sdk_1.waitForUserOperation)(sendUserOperationResult);\n        if (result.status === \"complete\") {\n            return result.transactionHash;\n        }\n        else {\n            throw new Error(`Transaction failed with status ${result.status}`);\n        }\n    }\n    /**\n     * Gets the address of the smart wallet.\n     *\n     * @returns The address of the smart wallet.\n     */\n    getAddress() {\n        return __classPrivateFieldGet(this, _SmartWalletProvider_smartWallet, \"f\").address;\n    }\n    /**\n     * Gets the network of the wallet.\n     *\n     * @returns The network of the wallet.\n     */\n    getNetwork() {\n        return __classPrivateFieldGet(this, _SmartWalletProvider_network, \"f\");\n    }\n    /**\n     * Gets the name of the wallet provider.\n     *\n     * @returns The name of the wallet provider.\n     */\n    getName() {\n        return \"cdp_smart_wallet_provider\";\n    }\n    /**\n     * Gets the balance of the wallet.\n     *\n     * @returns The balance of the wallet in wei\n     */\n    async getBalance() {\n        const balance = await __classPrivateFieldGet(this, _SmartWalletProvider_publicClient, \"f\").getBalance({\n            address: this.getAddress(),\n        });\n        return balance;\n    }\n    /**\n     * Waits for a transaction receipt.\n     *\n     * @param txHash - The hash of the transaction to wait for.\n     * @returns The transaction receipt.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    waitForTransactionReceipt(txHash) {\n        return __classPrivateFieldGet(this, _SmartWalletProvider_publicClient, \"f\").waitForTransactionReceipt({\n            hash: txHash,\n        });\n    }\n    /**\n     * Reads a contract.\n     *\n     * @param params - The parameters to read the contract.\n     * @returns The response from the contract.\n     */\n    async readContract(params) {\n        return __classPrivateFieldGet(this, _SmartWalletProvider_publicClient, \"f\").readContract(params);\n    }\n    /**\n     * Transfer the native asset of the network.\n     *\n     * @param to - The destination address.\n     * @param value - The amount to transfer in Wei.\n     * @returns The transaction hash.\n     */\n    async nativeTransfer(to, value) {\n        const sendUserOperationResult = await __classPrivateFieldGet(this, _SmartWalletProvider_smartWallet, \"f\").sendUserOperation({\n            calls: [\n                {\n                    to,\n                    value: BigInt(value),\n                },\n            ],\n        });\n        const result = await (0, coinbase_sdk_1.waitForUserOperation)(sendUserOperationResult);\n        if (result.status === \"complete\") {\n            return result.transactionHash;\n        }\n        else {\n            throw new Error(`Transfer failed with status ${result.status}`);\n        }\n    }\n}\nexports.SmartWalletProvider = SmartWalletProvider;\n_SmartWalletProvider_smartWallet = new WeakMap(), _SmartWalletProvider_network = new WeakMap(), _SmartWalletProvider_publicClient = new WeakMap();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3Qvd2FsbGV0LXByb3ZpZGVycy9zbWFydFdhbGxldFByb3ZpZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDJCQUEyQjtBQUMzQix1QkFBdUIsbUJBQU8sQ0FBQyx5RkFBd0I7QUFDdkQsZUFBZSxtQkFBTyxDQUFDLHFEQUFNO0FBQzdCLGtCQUFrQixtQkFBTyxDQUFDLGlGQUFZO0FBQ3RDLDRCQUE0QixtQkFBTyxDQUFDLCtHQUFxQjtBQUN6RCx1QkFBdUIsbUJBQU8sQ0FBQyxnRkFBb0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNkJBQTZCO0FBQzVDO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxVQUFVO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxnQkFBZ0IsNEJBQTRCLDZCQUE2QjtBQUN6SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLHdEQUF3RCwyREFBMkQ7QUFDbkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0JBQW9CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsK0RBQStEO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxzREFBc0Q7QUFDbkUsYUFBYTtBQUNiO0FBQ0EsUUFBUTtBQUNSLDJDQUEyQyxPQUFPO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxjQUFjO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsY0FBYztBQUN6RTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXJ2aXZhbC1mdW4vLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3Qvd2FsbGV0LXByb3ZpZGVycy9zbWFydFdhbGxldFByb3ZpZGVyLmpzP2M1OTEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZFNldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZFNldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwgdmFsdWUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XG59O1xudmFyIF9fY2xhc3NQcml2YXRlRmllbGRHZXQgPSAodGhpcyAmJiB0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRHZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcbn07XG52YXIgX1NtYXJ0V2FsbGV0UHJvdmlkZXJfc21hcnRXYWxsZXQsIF9TbWFydFdhbGxldFByb3ZpZGVyX25ldHdvcmssIF9TbWFydFdhbGxldFByb3ZpZGVyX3B1YmxpY0NsaWVudDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU21hcnRXYWxsZXRQcm92aWRlciA9IHZvaWQgMDtcbmNvbnN0IGNvaW5iYXNlX3Nka18xID0gcmVxdWlyZShcIkBjb2luYmFzZS9jb2luYmFzZS1zZGtcIik7XG5jb25zdCB2aWVtXzEgPSByZXF1aXJlKFwidmllbVwiKTtcbmNvbnN0IG5ldHdvcmtfMSA9IHJlcXVpcmUoXCIuLi9uZXR3b3JrXCIpO1xuY29uc3QgZXZtV2FsbGV0UHJvdmlkZXJfMSA9IHJlcXVpcmUoXCIuL2V2bVdhbGxldFByb3ZpZGVyXCIpO1xuY29uc3QgcGFja2FnZV9qc29uXzEgPSByZXF1aXJlKFwiLi4vLi4vcGFja2FnZS5qc29uXCIpO1xuLyoqXG4gKiBBIHdhbGxldCBwcm92aWRlciB0aGF0IHVzZXMgU21hcnQgV2FsbGV0cyBmcm9tIHRoZSBDb2luYmFzZSBTREsuXG4gKi9cbmNsYXNzIFNtYXJ0V2FsbGV0UHJvdmlkZXIgZXh0ZW5kcyBldm1XYWxsZXRQcm92aWRlcl8xLkV2bVdhbGxldFByb3ZpZGVyIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IENkcFdhbGxldFByb3ZpZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbmZpZyAtIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBDZHBXYWxsZXRQcm92aWRlci5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgX1NtYXJ0V2FsbGV0UHJvdmlkZXJfc21hcnRXYWxsZXQuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9TbWFydFdhbGxldFByb3ZpZGVyX25ldHdvcmsuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9TbWFydFdhbGxldFByb3ZpZGVyX3B1YmxpY0NsaWVudC5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfU21hcnRXYWxsZXRQcm92aWRlcl9uZXR3b3JrLCBjb25maWcubmV0d29yaywgXCJmXCIpO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9TbWFydFdhbGxldFByb3ZpZGVyX3NtYXJ0V2FsbGV0LCBjb25maWcuc21hcnRXYWxsZXQsIFwiZlwiKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfU21hcnRXYWxsZXRQcm92aWRlcl9wdWJsaWNDbGllbnQsICgwLCB2aWVtXzEuY3JlYXRlUHVibGljQ2xpZW50KSh7XG4gICAgICAgICAgICBjaGFpbjogbmV0d29ya18xLk5FVFdPUktfSURfVE9fVklFTV9DSEFJTltjb25maWcubmV0d29yay5uZXR3b3JrSWRdLFxuICAgICAgICAgICAgdHJhbnNwb3J0OiAoMCwgdmllbV8xLmh0dHApKCksXG4gICAgICAgIH0pLCBcImZcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbmZpZ3VyZXMgYW5kIHJldHVybnMgYSBgU21hcnRXYWxsZXRQcm92aWRlcmAgaW5zdGFuY2UgdXNpbmcgdGhlIHByb3ZpZGVkIGNvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiAgICAgKiBUaGlzIG1ldGhvZCBpbml0aWFsaXplcyBhIHNtYXJ0IHdhbGxldCBiYXNlZCBvbiB0aGUgZ2l2ZW4gbmV0d29yayBhbmQgY3JlZGVudGlhbHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NvbmZpZ3VyZVNtYXJ0V2FsbGV0T3B0aW9uc30gY29uZmlnXG4gICAgICogICAtIENvbmZpZ3VyYXRpb24gcGFyYW1ldGVycyBmb3Igc2V0dGluZyB1cCB0aGUgc21hcnQgd2FsbGV0LlxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8U21hcnRXYWxsZXRQcm92aWRlcj59XG4gICAgICogICAtIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGFuIGluc3RhbmNlIG9mIGBTbWFydFdhbGxldFByb3ZpZGVyYCBjb25maWd1cmVkIHdpdGggdGhlIHByb3ZpZGVkIHNldHRpbmdzLlxuICAgICAqXG4gICAgICogQHRocm93cyB7RXJyb3J9XG4gICAgICogICAtIElmIG5ldHdvcmtJZCBpcyBub3QgYSBzdXBwb3J0ZWQgbmV0d29yay5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IHNtYXJ0V2FsbGV0UHJvdmlkZXIgPSBhd2FpdCBTbWFydFdhbGxldFByb3ZpZGVyLmNvbmZpZ3VyZVdpdGhXYWxsZXQoe1xuICAgICAqICAgbmV0d29ya0lkOiBcImJhc2Utc2Vwb2xpYVwiLFxuICAgICAqICAgc2lnbmVyOiBwcml2YXRlS2V5VG9BY2NvdW50KFwiMHhldGhwcml2YXRla2V5XCIpLFxuICAgICAqICAgY2RwQXBpS2V5TmFtZTogXCJteS1hcGkta2V5XCIsXG4gICAgICogICBjZHBBcGlLZXlQcml2YXRlS2V5OiBcIm15LXByaXZhdGUta2V5XCIsXG4gICAgICogICBzbWFydFdhbGxldEFkZHJlc3M6IFwiMHgxMjM0NTYuLi5cIixcbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgY29uZmlndXJlV2l0aFdhbGxldChjb25maWcpIHtcbiAgICAgICAgY29uc3QgbmV0d29ya0lkID0gY29uZmlnLm5ldHdvcmtJZCB8fCBwcm9jZXNzLmVudi5ORVRXT1JLX0lEIHx8IGNvaW5iYXNlX3Nka18xLkNvaW5iYXNlLm5ldHdvcmtzLkJhc2VTZXBvbGlhO1xuICAgICAgICBjb25zdCBuZXR3b3JrID0ge1xuICAgICAgICAgICAgcHJvdG9jb2xGYW1pbHk6IFwiZXZtXCIsXG4gICAgICAgICAgICBjaGFpbklkOiBuZXR3b3JrXzEuTkVUV09SS19JRF9UT19DSEFJTl9JRFtuZXR3b3JrSWRdLFxuICAgICAgICAgICAgbmV0d29ya0lkLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoIW5ldHdvcmsuY2hhaW5JZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gZGV0ZXJtaW5lIGNoYWluSWQgZm9yIG5ldHdvcmsgJHtuZXR3b3JrSWR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3VwcG9ydGVkQ2hhaW5JZHMgPSBPYmplY3Qua2V5cyhjb2luYmFzZV9zZGtfMS5DSEFJTl9JRF9UT19ORVRXT1JLX0lEKTtcbiAgICAgICAgaWYgKCFzdXBwb3J0ZWRDaGFpbklkcy5pbmNsdWRlcyhuZXR3b3JrLmNoYWluSWQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgY2hhaW4gaWQgJHtuZXR3b3JrLmNoYWluSWR9LiBDaGFpbiBpZCBtdXN0IGJlIG9uZSBvZiAke3N1cHBvcnRlZENoYWluSWRzLmpvaW4oXCIsIFwiKX1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjZHBBcGlLZXlOYW1lID0gY29uZmlnLmNkcEFwaUtleU5hbWUgfHwgcHJvY2Vzcy5lbnYuQ0RQX0FQSV9LRVlfTkFNRTtcbiAgICAgICAgY29uc3QgY2RwQXBpS2V5UHJpdmF0ZUtleSA9IGNvbmZpZy5jZHBBcGlLZXlQcml2YXRlS2V5IHx8IHByb2Nlc3MuZW52LkNEUF9BUElfS0VZX1BSSVZBVEVfS0VZO1xuICAgICAgICBpZiAoY2RwQXBpS2V5TmFtZSAmJiBjZHBBcGlLZXlQcml2YXRlS2V5KSB7XG4gICAgICAgICAgICBjb2luYmFzZV9zZGtfMS5Db2luYmFzZS5jb25maWd1cmUoe1xuICAgICAgICAgICAgICAgIGFwaUtleU5hbWU6IGNkcEFwaUtleU5hbWUsXG4gICAgICAgICAgICAgICAgcHJpdmF0ZUtleTogY2RwQXBpS2V5UHJpdmF0ZUtleT8ucmVwbGFjZSgvXFxcXG4vZywgXCJcXG5cIiksXG4gICAgICAgICAgICAgICAgc291cmNlOiBcImFnZW50a2l0XCIsXG4gICAgICAgICAgICAgICAgc291cmNlVmVyc2lvbjogcGFja2FnZV9qc29uXzEudmVyc2lvbixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29pbmJhc2Vfc2RrXzEuQ29pbmJhc2UuY29uZmlndXJlRnJvbUpzb24oeyBzb3VyY2U6IFwiYWdlbnRraXRcIiwgc291cmNlVmVyc2lvbjogcGFja2FnZV9qc29uXzEudmVyc2lvbiB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzbWFydFdhbGxldCA9IGNvbmZpZy5zbWFydFdhbGxldEFkZHJlc3NcbiAgICAgICAgICAgID8gKDAsIGNvaW5iYXNlX3Nka18xLnRvU21hcnRXYWxsZXQpKHtcbiAgICAgICAgICAgICAgICBzaWduZXI6IGNvbmZpZy5zaWduZXIsXG4gICAgICAgICAgICAgICAgc21hcnRXYWxsZXRBZGRyZXNzOiBjb25maWcuc21hcnRXYWxsZXRBZGRyZXNzLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIDogYXdhaXQgKDAsIGNvaW5iYXNlX3Nka18xLmNyZWF0ZVNtYXJ0V2FsbGV0KSh7XG4gICAgICAgICAgICAgICAgc2lnbmVyOiBjb25maWcuc2lnbmVyLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IG5ldHdvcmtTY29wZWRTbWFydFdhbGxldCA9IHNtYXJ0V2FsbGV0LnVzZU5ldHdvcmsoe1xuICAgICAgICAgICAgY2hhaW5JZDogTnVtYmVyKG5ldHdvcmsuY2hhaW5JZCksXG4gICAgICAgICAgICBwYXltYXN0ZXJVcmw6IGNvbmZpZy5wYXltYXN0ZXJVcmwsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBzbWFydFdhbGxldFByb3ZpZGVyID0gbmV3IFNtYXJ0V2FsbGV0UHJvdmlkZXIoe1xuICAgICAgICAgICAgc21hcnRXYWxsZXQ6IG5ldHdvcmtTY29wZWRTbWFydFdhbGxldCxcbiAgICAgICAgICAgIG5ldHdvcmssXG4gICAgICAgICAgICBjaGFpbklkOiBuZXR3b3JrLmNoYWluSWQsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc21hcnRXYWxsZXRQcm92aWRlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3R1YiBmb3IgbWVzc2FnZSBzaWduaW5nXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIGFzIHNpZ25pbmcgbWVzc2FnZXMgaXMgbm90IGltcGxlbWVudGVkIGZvciBTbWFydFdhbGxldHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gXyAtIFRoZSBtZXNzYWdlIHRvIHNpZ24uXG4gICAgICogQHJldHVybnMgVGhlIHNpZ25lZCBtZXNzYWdlLlxuICAgICAqL1xuICAgIGFzeW5jIHNpZ25NZXNzYWdlKF8pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdHViIGZvciB0eXBlZCBkYXRhIHNpZ25pbmdcbiAgICAgKlxuICAgICAqIEB0aHJvd3MgYXMgc2lnbmluZyB0eXBlZCBkYXRhIGlzIG5vdCBpbXBsZW1lbnRlZCBmb3IgU21hcnRXYWxsZXRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIF8gLSBUaGUgdHlwZWQgZGF0YSBvYmplY3QgdG8gc2lnbi5cbiAgICAgKiBAcmV0dXJucyBUaGUgc2lnbmVkIHR5cGVkIGRhdGEgb2JqZWN0LlxuICAgICAqL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgYXN5bmMgc2lnblR5cGVkRGF0YShfKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3R1YiBmb3IgdHJhbnNhY3Rpb24gc2lnbmluZ1xuICAgICAqXG4gICAgICogQHRocm93cyBhcyBzaWduaW5nIHRyYW5zYWN0aW9ucyBpcyBub3QgaW1wbGVtZW50ZWQgZm9yIFNtYXJ0V2FsbGV0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBfIC0gVGhlIHRyYW5zYWN0aW9uIHRvIHNpZ24uXG4gICAgICogQHJldHVybnMgVGhlIHNpZ25lZCB0cmFuc2FjdGlvbi5cbiAgICAgKi9cbiAgICBhc3luYyBzaWduVHJhbnNhY3Rpb24oXykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWRcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgdHJhbnNhY3Rpb24gdXNpbmcgdGhlIHNtYXJ0IHdhbGxldC5cbiAgICAgKlxuICAgICAqIFVubGlrZSB0cmFkaXRpb25hbCBFdGhlcmV1bSB0cmFuc2FjdGlvbnMsIHRoaXMgbWV0aG9kIHN1Ym1pdHMgYSAqKlVzZXIgT3BlcmF0aW9uKipcbiAgICAgKiBpbnN0ZWFkIG9mIGRpcmVjdGx5IGJyb2FkY2FzdGluZyBhIHRyYW5zYWN0aW9uLiBUaGUgc21hcnQgd2FsbGV0IGhhbmRsZXMgZXhlY3V0aW9uLFxuICAgICAqIGJ1dCBhIHN0YW5kYXJkIHRyYW5zYWN0aW9uIGhhc2ggaXMgc3RpbGwgcmV0dXJuZWQgdXBvbiBjb21wbGV0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtUcmFuc2FjdGlvblJlcXVlc3R9IHRyYW5zYWN0aW9uIC0gVGhlIHRyYW5zYWN0aW9uIGRldGFpbHMsIGluY2x1ZGluZzpcbiAgICAgKiAgIC0gYHRvYDogVGhlIHJlY2lwaWVudCBhZGRyZXNzLlxuICAgICAqICAgLSBgdmFsdWVgOiBUaGUgYW1vdW50IG9mIEVUSCAob3IgbmF0aXZlIHRva2VuKSB0byBzZW5kLlxuICAgICAqICAgLSBgZGF0YWA6IE9wdGlvbmFsIGNhbGxkYXRhIGZvciBjb250cmFjdCBpbnRlcmFjdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSB0cmFuc2FjdGlvbiBoYXNoIChgMHguLi5gKS5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgdHJhbnNhY3Rpb24gZG9lcyBub3QgY29tcGxldGUgc3VjY2Vzc2Z1bGx5LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3QgdHhIYXNoID0gYXdhaXQgc21hcnRXYWxsZXQuc2VuZFRyYW5zYWN0aW9uKHtcbiAgICAgKiAgIHRvOiBcIjB4MTIzLi4uXCIsXG4gICAgICogICB2YWx1ZTogcGFyc2VFdGhlcihcIjAuMVwiKSxcbiAgICAgKiAgIGRhdGE6IFwiMHhcIixcbiAgICAgKiB9KTtcbiAgICAgKiBjb25zb2xlLmxvZyhgVHJhbnNhY3Rpb24gc2VudDogJHt0eEhhc2h9YCk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgc2VuZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IHsgdG8sIHZhbHVlLCBkYXRhIH0gPSB0cmFuc2FjdGlvbjtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZFVzZXJPcGVyYXRpb24oe1xuICAgICAgICAgICAgY2FsbHM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRvOiB0byxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhICoqVXNlciBPcGVyYXRpb24qKiB0byB0aGUgc21hcnQgd2FsbGV0LlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgZGlyZWN0bHkgZXhwb3NlcyB0aGUgKipzZW5kVXNlck9wZXJhdGlvbioqIGZ1bmN0aW9uYWxpdHksIGFsbG93aW5nXG4gICAgICogKipTbWFydFdhbGxldC1hd2FyZSB0b29scyoqIHRvIGZ1bGx5IGxldmVyYWdlIGl0cyBjYXBhYmlsaXRpZXMsIGluY2x1ZGluZyBiYXRjaGluZyBtdWx0aXBsZSBjYWxscy5cbiAgICAgKiBVbmxpa2UgYHNlbmRUcmFuc2FjdGlvbmAsIHdoaWNoIHdyYXBzIGNhbGxzIGluIGEgc2luZ2xlIG9wZXJhdGlvbiwgdGhpcyBtZXRob2QgYWxsb3dzXG4gICAgICogZGlyZWN0IGV4ZWN1dGlvbiBvZiBhcmJpdHJhcnkgb3BlcmF0aW9ucyB3aXRoaW4gYSAqKlVzZXIgT3BlcmF0aW9uKiouXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09taXQ8U2VuZFVzZXJPcGVyYXRpb25PcHRpb25zPFQ+LCBcImNoYWluSWRcIiB8IFwicGF5bWFzdGVyVXJsXCI+fSBvcGVyYXRpb25cbiAgICAgKiAgIC0gVGhlIHVzZXIgb3BlcmF0aW9uIGNvbmZpZ3VyYXRpb24sIG9taXR0aW5nIGBjaGFpbklkYCBhbmQgYHBheW1hc3RlclVybGAsXG4gICAgICogICAgIHdoaWNoIGFyZSBtYW5hZ2VkIGludGVybmFsbHkgYnkgdGhlIHNtYXJ0IHdhbGxldC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIHRyYW5zYWN0aW9uIGhhc2ggKGAweC4uLmApIGlmIHRoZSBvcGVyYXRpb24gY29tcGxldGVzIHN1Y2Nlc3NmdWxseS5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgb3BlcmF0aW9uIGRvZXMgbm90IGNvbXBsZXRlIHN1Y2Nlc3NmdWxseS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IHR4SGFzaCA9IGF3YWl0IHNtYXJ0V2FsbGV0LnNlbmRVc2VyT3BlcmF0aW9uKHtcbiAgICAgKiAgIGNhbGxzOiBbXG4gICAgICogICAgIHsgdG86IFwiMHgxMjMuLi5cIiwgdmFsdWU6IHBhcnNlRXRoZXIoXCIwLjFcIiksIGRhdGE6IFwiMHhcIiB9LFxuICAgICAqICAgICB7IHRvOiBcIjB4NDU2Li4uXCIsIHZhbHVlOiBwYXJzZUV0aGVyKFwiMC4wNVwiKSwgZGF0YTogXCIweFwiIH1cbiAgICAgKiAgIF0sXG4gICAgICogfSk7XG4gICAgICogY29uc29sZS5sb2coYFVzZXIgT3BlcmF0aW9uIHNlbnQ6ICR7dHhIYXNofWApO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIHNlbmRVc2VyT3BlcmF0aW9uKG9wZXJhdGlvbikge1xuICAgICAgICBjb25zdCBzZW5kVXNlck9wZXJhdGlvblJlc3VsdCA9IGF3YWl0IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1NtYXJ0V2FsbGV0UHJvdmlkZXJfc21hcnRXYWxsZXQsIFwiZlwiKS5zZW5kVXNlck9wZXJhdGlvbihvcGVyYXRpb24pO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCAoMCwgY29pbmJhc2Vfc2RrXzEud2FpdEZvclVzZXJPcGVyYXRpb24pKHNlbmRVc2VyT3BlcmF0aW9uUmVzdWx0KTtcbiAgICAgICAgaWYgKHJlc3VsdC5zdGF0dXMgPT09IFwiY29tcGxldGVcIikge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC50cmFuc2FjdGlvbkhhc2g7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRyYW5zYWN0aW9uIGZhaWxlZCB3aXRoIHN0YXR1cyAke3Jlc3VsdC5zdGF0dXN9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgYWRkcmVzcyBvZiB0aGUgc21hcnQgd2FsbGV0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGFkZHJlc3Mgb2YgdGhlIHNtYXJ0IHdhbGxldC5cbiAgICAgKi9cbiAgICBnZXRBZGRyZXNzKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU21hcnRXYWxsZXRQcm92aWRlcl9zbWFydFdhbGxldCwgXCJmXCIpLmFkZHJlc3M7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG5ldHdvcmsgb2YgdGhlIHdhbGxldC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBuZXR3b3JrIG9mIHRoZSB3YWxsZXQuXG4gICAgICovXG4gICAgZ2V0TmV0d29yaygpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1NtYXJ0V2FsbGV0UHJvdmlkZXJfbmV0d29yaywgXCJmXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBuYW1lIG9mIHRoZSB3YWxsZXQgcHJvdmlkZXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgbmFtZSBvZiB0aGUgd2FsbGV0IHByb3ZpZGVyLlxuICAgICAqL1xuICAgIGdldE5hbWUoKSB7XG4gICAgICAgIHJldHVybiBcImNkcF9zbWFydF93YWxsZXRfcHJvdmlkZXJcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgYmFsYW5jZSBvZiB0aGUgd2FsbGV0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGJhbGFuY2Ugb2YgdGhlIHdhbGxldCBpbiB3ZWlcbiAgICAgKi9cbiAgICBhc3luYyBnZXRCYWxhbmNlKCkge1xuICAgICAgICBjb25zdCBiYWxhbmNlID0gYXdhaXQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU21hcnRXYWxsZXRQcm92aWRlcl9wdWJsaWNDbGllbnQsIFwiZlwiKS5nZXRCYWxhbmNlKHtcbiAgICAgICAgICAgIGFkZHJlc3M6IHRoaXMuZ2V0QWRkcmVzcygpLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGJhbGFuY2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdhaXRzIGZvciBhIHRyYW5zYWN0aW9uIHJlY2VpcHQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdHhIYXNoIC0gVGhlIGhhc2ggb2YgdGhlIHRyYW5zYWN0aW9uIHRvIHdhaXQgZm9yLlxuICAgICAqIEByZXR1cm5zIFRoZSB0cmFuc2FjdGlvbiByZWNlaXB0LlxuICAgICAqL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgd2FpdEZvclRyYW5zYWN0aW9uUmVjZWlwdCh0eEhhc2gpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1NtYXJ0V2FsbGV0UHJvdmlkZXJfcHVibGljQ2xpZW50LCBcImZcIikud2FpdEZvclRyYW5zYWN0aW9uUmVjZWlwdCh7XG4gICAgICAgICAgICBoYXNoOiB0eEhhc2gsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkcyBhIGNvbnRyYWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIHRvIHJlYWQgdGhlIGNvbnRyYWN0LlxuICAgICAqIEByZXR1cm5zIFRoZSByZXNwb25zZSBmcm9tIHRoZSBjb250cmFjdC5cbiAgICAgKi9cbiAgICBhc3luYyByZWFkQ29udHJhY3QocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TbWFydFdhbGxldFByb3ZpZGVyX3B1YmxpY0NsaWVudCwgXCJmXCIpLnJlYWRDb250cmFjdChwYXJhbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmFuc2ZlciB0aGUgbmF0aXZlIGFzc2V0IG9mIHRoZSBuZXR3b3JrLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRvIC0gVGhlIGRlc3RpbmF0aW9uIGFkZHJlc3MuXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIGFtb3VudCB0byB0cmFuc2ZlciBpbiBXZWkuXG4gICAgICogQHJldHVybnMgVGhlIHRyYW5zYWN0aW9uIGhhc2guXG4gICAgICovXG4gICAgYXN5bmMgbmF0aXZlVHJhbnNmZXIodG8sIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHNlbmRVc2VyT3BlcmF0aW9uUmVzdWx0ID0gYXdhaXQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU21hcnRXYWxsZXRQcm92aWRlcl9zbWFydFdhbGxldCwgXCJmXCIpLnNlbmRVc2VyT3BlcmF0aW9uKHtcbiAgICAgICAgICAgIGNhbGxzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0byxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IEJpZ0ludCh2YWx1ZSksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCAoMCwgY29pbmJhc2Vfc2RrXzEud2FpdEZvclVzZXJPcGVyYXRpb24pKHNlbmRVc2VyT3BlcmF0aW9uUmVzdWx0KTtcbiAgICAgICAgaWYgKHJlc3VsdC5zdGF0dXMgPT09IFwiY29tcGxldGVcIikge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC50cmFuc2FjdGlvbkhhc2g7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRyYW5zZmVyIGZhaWxlZCB3aXRoIHN0YXR1cyAke3Jlc3VsdC5zdGF0dXN9YCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLlNtYXJ0V2FsbGV0UHJvdmlkZXIgPSBTbWFydFdhbGxldFByb3ZpZGVyO1xuX1NtYXJ0V2FsbGV0UHJvdmlkZXJfc21hcnRXYWxsZXQgPSBuZXcgV2Vha01hcCgpLCBfU21hcnRXYWxsZXRQcm92aWRlcl9uZXR3b3JrID0gbmV3IFdlYWtNYXAoKSwgX1NtYXJ0V2FsbGV0UHJvdmlkZXJfcHVibGljQ2xpZW50ID0gbmV3IFdlYWtNYXAoKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/wallet-providers/smartWalletProvider.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/wallet-providers/solanaKeypairWalletProvider.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/wallet-providers/solanaKeypairWalletProvider.js ***!
  \**********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nvar _SolanaKeypairWalletProvider_keypair, _SolanaKeypairWalletProvider_connection, _SolanaKeypairWalletProvider_genesisHash;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SolanaKeypairWalletProvider = void 0;\nconst svmWalletProvider_1 = __webpack_require__(/*! ./svmWalletProvider */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/wallet-providers/svmWalletProvider.js\");\nconst web3_js_1 = __webpack_require__(/*! @solana/web3.js */ \"(rsc)/./node_modules/@solana/web3.js/lib/index.esm.js\");\nconst bs58_1 = __importDefault(__webpack_require__(/*! bs58 */ \"(rsc)/./node_modules/@coinbase/agentkit/node_modules/bs58/index.js\"));\nconst svm_1 = __webpack_require__(/*! ../network/svm */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/network/svm.js\");\n/**\n * SolanaKeypairWalletProvider is a wallet provider that uses a local Solana keypair.\n *\n * @augments SvmWalletProvider\n */\nclass SolanaKeypairWalletProvider extends svmWalletProvider_1.SvmWalletProvider {\n    /**\n     * Creates a new SolanaKeypairWalletProvider\n     *\n     * @param args - Configuration arguments\n     * @param args.keypair - Either a Uint8Array or a base58 encoded string representing a 32-byte secret key\n     * @param args.rpcUrl - URL of the Solana RPC endpoint\n     * @param args.genesisHash - The genesis hash of the network\n     */\n    constructor({ keypair, rpcUrl, genesisHash, }) {\n        super();\n        _SolanaKeypairWalletProvider_keypair.set(this, void 0);\n        _SolanaKeypairWalletProvider_connection.set(this, void 0);\n        _SolanaKeypairWalletProvider_genesisHash.set(this, void 0);\n        __classPrivateFieldSet(this, _SolanaKeypairWalletProvider_keypair, typeof keypair === \"string\"\n            ? web3_js_1.Keypair.fromSecretKey(bs58_1.default.decode(keypair))\n            : web3_js_1.Keypair.fromSecretKey(keypair), \"f\");\n        __classPrivateFieldSet(this, _SolanaKeypairWalletProvider_connection, new web3_js_1.Connection(rpcUrl), \"f\");\n        if (genesisHash in svm_1.SOLANA_NETWORKS) {\n            __classPrivateFieldSet(this, _SolanaKeypairWalletProvider_genesisHash, genesisHash, \"f\");\n        }\n        else {\n            throw new Error(`Unknown network with genesis hash: ${genesisHash}`);\n        }\n    }\n    /**\n     * Get the default RPC URL for a Solana cluster\n     *\n     * @param cluster - The cluster to get the RPC URL for\n     * @returns The RPC URL for the cluster\n     */\n    static urlForCluster(cluster) {\n        if (cluster in svm_1.SOLANA_NETWORKS) {\n            switch (cluster) {\n                case svm_1.SOLANA_MAINNET_GENESIS_BLOCK_HASH:\n                    return (0, web3_js_1.clusterApiUrl)(\"mainnet-beta\");\n                case svm_1.SOLANA_TESTNET_GENESIS_BLOCK_HASH:\n                    return (0, web3_js_1.clusterApiUrl)(\"testnet\");\n                case svm_1.SOLANA_DEVNET_GENESIS_BLOCK_HASH:\n                    return (0, web3_js_1.clusterApiUrl)(\"devnet\");\n                default:\n                    throw new Error(`Unknown cluster: ${cluster}`);\n            }\n        }\n        else {\n            throw new Error(`Unknown cluster: ${cluster}`);\n        }\n    }\n    /**\n     * Create a new SolanaKeypairWalletProvider from an SVM networkId and a keypair\n     *\n     * @param networkId - The SVM networkId\n     * @param keypair - Either a Uint8Array or a base58 encoded string representing a 32-byte secret key\n     * @returns The new SolanaKeypairWalletProvider\n     */\n    static async fromNetwork(networkId, keypair) {\n        let genesisHash;\n        switch (networkId) {\n            case svm_1.SOLANA_MAINNET_NETWORK_ID:\n                genesisHash = svm_1.SOLANA_MAINNET_GENESIS_BLOCK_HASH;\n                break;\n            case svm_1.SOLANA_DEVNET_NETWORK_ID:\n                genesisHash = svm_1.SOLANA_DEVNET_GENESIS_BLOCK_HASH;\n                break;\n            case svm_1.SOLANA_TESTNET_NETWORK_ID:\n                genesisHash = svm_1.SOLANA_TESTNET_GENESIS_BLOCK_HASH;\n                break;\n            default:\n                throw new Error(`${networkId} is not a valid SVM networkId`);\n        }\n        const rpcUrl = this.urlForCluster(genesisHash);\n        return await this.fromRpcUrl(rpcUrl, keypair);\n    }\n    /**\n     * Create a new SolanaKeypairWalletProvider from an RPC URL and a keypair\n     *\n     * @param rpcUrl - The URL of the Solana RPC endpoint\n     * @param keypair - Either a Uint8Array or a base58 encoded string representing a 32-byte secret key\n     * @returns The new SolanaKeypairWalletProvider\n     */\n    static async fromRpcUrl(rpcUrl, keypair) {\n        const connection = new web3_js_1.Connection(rpcUrl);\n        return await this.fromConnection(connection, keypair);\n    }\n    /**\n     * Create a new SolanaKeypairWalletProvider from a Connection and a keypair\n     *\n     * @param connection - The Connection to use\n     * @param keypair - Either a Uint8Array or a base58 encoded string representing a 32-byte secret key\n     * @returns The new SolanaKeypairWalletProvider\n     */\n    static async fromConnection(connection, keypair) {\n        const genesisHash = await connection.getGenesisHash();\n        return new SolanaKeypairWalletProvider({\n            keypair,\n            rpcUrl: connection.rpcEndpoint,\n            genesisHash: genesisHash,\n        });\n    }\n    /**\n     * Get the connection instance\n     *\n     * @returns The Solana connection instance\n     */\n    getConnection() {\n        return __classPrivateFieldGet(this, _SolanaKeypairWalletProvider_connection, \"f\");\n    }\n    /**\n     * Get the public key of the wallet\n     *\n     * @returns The wallet's public key\n     */\n    getPublicKey() {\n        return __classPrivateFieldGet(this, _SolanaKeypairWalletProvider_keypair, \"f\").publicKey;\n    }\n    /**\n     * Get the address of the wallet\n     *\n     * @returns The base58 encoded address of the wallet\n     */\n    getAddress() {\n        return __classPrivateFieldGet(this, _SolanaKeypairWalletProvider_keypair, \"f\").publicKey.toBase58();\n    }\n    /**\n     * Get the network\n     *\n     * @returns The network\n     */\n    getNetwork() {\n        return svm_1.SOLANA_NETWORKS[__classPrivateFieldGet(this, _SolanaKeypairWalletProvider_genesisHash, \"f\")];\n    }\n    /**\n     * Sign a transaction\n     *\n     * @param transaction - The transaction to sign\n     * @returns The signed transaction\n     */\n    async signTransaction(transaction) {\n        transaction.sign([__classPrivateFieldGet(this, _SolanaKeypairWalletProvider_keypair, \"f\")]);\n        return transaction;\n    }\n    /**\n     * Send a transaction\n     *\n     * @param transaction - The transaction to send\n     * @returns The signature\n     */\n    async sendTransaction(transaction) {\n        const signature = await __classPrivateFieldGet(this, _SolanaKeypairWalletProvider_connection, \"f\").sendTransaction(transaction);\n        await this.waitForSignatureResult(signature);\n        return signature;\n    }\n    /**\n     * Sign and send a transaction\n     *\n     * @param transaction - The transaction to sign and send\n     * @returns The signature\n     */\n    async signAndSendTransaction(transaction) {\n        const signedTransaction = await this.signTransaction(transaction);\n        return this.sendTransaction(signedTransaction);\n    }\n    /**\n     * Get the status of a transaction\n     *\n     * @param signature - The signature\n     * @param options - The options for the status\n     * @returns The status\n     */\n    async getSignatureStatus(signature, options) {\n        return __classPrivateFieldGet(this, _SolanaKeypairWalletProvider_connection, \"f\").getSignatureStatus(signature, options);\n    }\n    /**\n     * Wait for signature receipt\n     *\n     * @param signature - The signature\n     * @returns The confirmation response\n     */\n    async waitForSignatureResult(signature) {\n        const { blockhash, lastValidBlockHeight } = await __classPrivateFieldGet(this, _SolanaKeypairWalletProvider_connection, \"f\").getLatestBlockhash();\n        return __classPrivateFieldGet(this, _SolanaKeypairWalletProvider_connection, \"f\").confirmTransaction({\n            signature: signature,\n            lastValidBlockHeight,\n            blockhash,\n        });\n    }\n    /**\n     * Get the name of the wallet provider\n     *\n     * @returns The name of the wallet provider\n     */\n    getName() {\n        return \"solana_keypair_wallet_provider\";\n    }\n    /**\n     * Get the balance of the wallet\n     *\n     * @returns The balance of the wallet\n     */\n    getBalance() {\n        return __classPrivateFieldGet(this, _SolanaKeypairWalletProvider_connection, \"f\").getBalance(__classPrivateFieldGet(this, _SolanaKeypairWalletProvider_keypair, \"f\").publicKey).then(balance => BigInt(balance));\n    }\n    /**\n     * Transfer SOL from the wallet to another address\n     *\n     * @param to - The base58 encoded address to transfer the SOL to\n     * @param value - The amount of SOL to transfer (as a decimal string, e.g. \"0.0001\")\n     * @returns The signature\n     */\n    async nativeTransfer(to, value) {\n        const initialBalance = await this.getBalance();\n        const solAmount = parseFloat(value);\n        const lamports = BigInt(Math.floor(solAmount * web3_js_1.LAMPORTS_PER_SOL));\n        // Check if we have enough balance (including estimated fees)\n        if (initialBalance < lamports + BigInt(5000)) {\n            throw new Error(`Insufficient balance. Have ${Number(initialBalance) / web3_js_1.LAMPORTS_PER_SOL} SOL, need ${solAmount + 0.000005} SOL (including fees)`);\n        }\n        const toPubkey = new web3_js_1.PublicKey(to);\n        const instructions = [\n            web3_js_1.ComputeBudgetProgram.setComputeUnitPrice({\n                microLamports: 10000,\n            }),\n            web3_js_1.ComputeBudgetProgram.setComputeUnitLimit({\n                units: 2000,\n            }),\n            web3_js_1.SystemProgram.transfer({\n                fromPubkey: __classPrivateFieldGet(this, _SolanaKeypairWalletProvider_keypair, \"f\").publicKey,\n                toPubkey: toPubkey,\n                lamports: lamports,\n            }),\n        ];\n        const tx = new web3_js_1.VersionedTransaction(web3_js_1.MessageV0.compile({\n            payerKey: __classPrivateFieldGet(this, _SolanaKeypairWalletProvider_keypair, \"f\").publicKey,\n            instructions: instructions,\n            recentBlockhash: (await __classPrivateFieldGet(this, _SolanaKeypairWalletProvider_connection, \"f\").getLatestBlockhash()).blockhash,\n        }));\n        tx.sign([__classPrivateFieldGet(this, _SolanaKeypairWalletProvider_keypair, \"f\")]);\n        const signature = await __classPrivateFieldGet(this, _SolanaKeypairWalletProvider_connection, \"f\").sendTransaction(tx);\n        await this.waitForSignatureResult(signature);\n        return signature;\n    }\n    /**\n     * Request SOL tokens from the Solana faucet. This method only works on devnet and testnet networks.\n     *\n     * @param lamports - The amount of lamports (1 SOL = 1,000,000,000 lamports) to request from the faucet\n     * @returns A Promise that resolves to the signature of the airdrop\n     */\n    async requestAirdrop(lamports) {\n        return await __classPrivateFieldGet(this, _SolanaKeypairWalletProvider_connection, \"f\").requestAirdrop(__classPrivateFieldGet(this, _SolanaKeypairWalletProvider_keypair, \"f\").publicKey, lamports);\n    }\n}\nexports.SolanaKeypairWalletProvider = SolanaKeypairWalletProvider;\n_SolanaKeypairWalletProvider_keypair = new WeakMap(), _SolanaKeypairWalletProvider_connection = new WeakMap(), _SolanaKeypairWalletProvider_genesisHash = new WeakMap();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3Qvd2FsbGV0LXByb3ZpZGVycy9zb2xhbmFLZXlwYWlyV2FsbGV0UHJvdmlkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQ0FBbUM7QUFDbkMsNEJBQTRCLG1CQUFPLENBQUMsK0dBQXFCO0FBQ3pELGtCQUFrQixtQkFBTyxDQUFDLDhFQUFpQjtBQUMzQywrQkFBK0IsbUJBQU8sQ0FBQyxnRkFBTTtBQUM3QyxjQUFjLG1CQUFPLENBQUMsbUZBQWdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsK0JBQStCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxZQUFZO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxRQUFRO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxRQUFRO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFdBQVc7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtDQUFrQztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQscURBQXFELFlBQVksc0JBQXNCO0FBQ2pKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cnZpdmFsLWZ1bi8uL25vZGVfbW9kdWxlcy9AY29pbmJhc2UvYWdlbnRraXQvZGlzdC93YWxsZXQtcHJvdmlkZXJzL3NvbGFuYUtleXBhaXJXYWxsZXRQcm92aWRlci5qcz8yMjA2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY2xhc3NQcml2YXRlRmllbGRTZXQgPSAodGhpcyAmJiB0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRTZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XG4gICAgaWYgKGtpbmQgPT09IFwibVwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBtZXRob2QgaXMgbm90IHdyaXRhYmxlXCIpO1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIHNldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICAgIHJldHVybiAoa2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIsIHZhbHVlKSA6IGYgPyBmLnZhbHVlID0gdmFsdWUgOiBzdGF0ZS5zZXQocmVjZWl2ZXIsIHZhbHVlKSksIHZhbHVlO1xufTtcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCBraW5kLCBmKSB7XG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICAgIHJldHVybiBraW5kID09PSBcIm1cIiA/IGYgOiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlcikgOiBmID8gZi52YWx1ZSA6IHN0YXRlLmdldChyZWNlaXZlcik7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xudmFyIF9Tb2xhbmFLZXlwYWlyV2FsbGV0UHJvdmlkZXJfa2V5cGFpciwgX1NvbGFuYUtleXBhaXJXYWxsZXRQcm92aWRlcl9jb25uZWN0aW9uLCBfU29sYW5hS2V5cGFpcldhbGxldFByb3ZpZGVyX2dlbmVzaXNIYXNoO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Tb2xhbmFLZXlwYWlyV2FsbGV0UHJvdmlkZXIgPSB2b2lkIDA7XG5jb25zdCBzdm1XYWxsZXRQcm92aWRlcl8xID0gcmVxdWlyZShcIi4vc3ZtV2FsbGV0UHJvdmlkZXJcIik7XG5jb25zdCB3ZWIzX2pzXzEgPSByZXF1aXJlKFwiQHNvbGFuYS93ZWIzLmpzXCIpO1xuY29uc3QgYnM1OF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJiczU4XCIpKTtcbmNvbnN0IHN2bV8xID0gcmVxdWlyZShcIi4uL25ldHdvcmsvc3ZtXCIpO1xuLyoqXG4gKiBTb2xhbmFLZXlwYWlyV2FsbGV0UHJvdmlkZXIgaXMgYSB3YWxsZXQgcHJvdmlkZXIgdGhhdCB1c2VzIGEgbG9jYWwgU29sYW5hIGtleXBhaXIuXG4gKlxuICogQGF1Z21lbnRzIFN2bVdhbGxldFByb3ZpZGVyXG4gKi9cbmNsYXNzIFNvbGFuYUtleXBhaXJXYWxsZXRQcm92aWRlciBleHRlbmRzIHN2bVdhbGxldFByb3ZpZGVyXzEuU3ZtV2FsbGV0UHJvdmlkZXIge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgU29sYW5hS2V5cGFpcldhbGxldFByb3ZpZGVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXJncyAtIENvbmZpZ3VyYXRpb24gYXJndW1lbnRzXG4gICAgICogQHBhcmFtIGFyZ3Mua2V5cGFpciAtIEVpdGhlciBhIFVpbnQ4QXJyYXkgb3IgYSBiYXNlNTggZW5jb2RlZCBzdHJpbmcgcmVwcmVzZW50aW5nIGEgMzItYnl0ZSBzZWNyZXQga2V5XG4gICAgICogQHBhcmFtIGFyZ3MucnBjVXJsIC0gVVJMIG9mIHRoZSBTb2xhbmEgUlBDIGVuZHBvaW50XG4gICAgICogQHBhcmFtIGFyZ3MuZ2VuZXNpc0hhc2ggLSBUaGUgZ2VuZXNpcyBoYXNoIG9mIHRoZSBuZXR3b3JrXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoeyBrZXlwYWlyLCBycGNVcmwsIGdlbmVzaXNIYXNoLCB9KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIF9Tb2xhbmFLZXlwYWlyV2FsbGV0UHJvdmlkZXJfa2V5cGFpci5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX1NvbGFuYUtleXBhaXJXYWxsZXRQcm92aWRlcl9jb25uZWN0aW9uLnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICBfU29sYW5hS2V5cGFpcldhbGxldFByb3ZpZGVyX2dlbmVzaXNIYXNoLnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9Tb2xhbmFLZXlwYWlyV2FsbGV0UHJvdmlkZXJfa2V5cGFpciwgdHlwZW9mIGtleXBhaXIgPT09IFwic3RyaW5nXCJcbiAgICAgICAgICAgID8gd2ViM19qc18xLktleXBhaXIuZnJvbVNlY3JldEtleShiczU4XzEuZGVmYXVsdC5kZWNvZGUoa2V5cGFpcikpXG4gICAgICAgICAgICA6IHdlYjNfanNfMS5LZXlwYWlyLmZyb21TZWNyZXRLZXkoa2V5cGFpciksIFwiZlwiKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfU29sYW5hS2V5cGFpcldhbGxldFByb3ZpZGVyX2Nvbm5lY3Rpb24sIG5ldyB3ZWIzX2pzXzEuQ29ubmVjdGlvbihycGNVcmwpLCBcImZcIik7XG4gICAgICAgIGlmIChnZW5lc2lzSGFzaCBpbiBzdm1fMS5TT0xBTkFfTkVUV09SS1MpIHtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX1NvbGFuYUtleXBhaXJXYWxsZXRQcm92aWRlcl9nZW5lc2lzSGFzaCwgZ2VuZXNpc0hhc2gsIFwiZlwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBuZXR3b3JrIHdpdGggZ2VuZXNpcyBoYXNoOiAke2dlbmVzaXNIYXNofWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZGVmYXVsdCBSUEMgVVJMIGZvciBhIFNvbGFuYSBjbHVzdGVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2x1c3RlciAtIFRoZSBjbHVzdGVyIHRvIGdldCB0aGUgUlBDIFVSTCBmb3JcbiAgICAgKiBAcmV0dXJucyBUaGUgUlBDIFVSTCBmb3IgdGhlIGNsdXN0ZXJcbiAgICAgKi9cbiAgICBzdGF0aWMgdXJsRm9yQ2x1c3RlcihjbHVzdGVyKSB7XG4gICAgICAgIGlmIChjbHVzdGVyIGluIHN2bV8xLlNPTEFOQV9ORVRXT1JLUykge1xuICAgICAgICAgICAgc3dpdGNoIChjbHVzdGVyKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBzdm1fMS5TT0xBTkFfTUFJTk5FVF9HRU5FU0lTX0JMT0NLX0hBU0g6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoMCwgd2ViM19qc18xLmNsdXN0ZXJBcGlVcmwpKFwibWFpbm5ldC1iZXRhXCIpO1xuICAgICAgICAgICAgICAgIGNhc2Ugc3ZtXzEuU09MQU5BX1RFU1RORVRfR0VORVNJU19CTE9DS19IQVNIOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKDAsIHdlYjNfanNfMS5jbHVzdGVyQXBpVXJsKShcInRlc3RuZXRcIik7XG4gICAgICAgICAgICAgICAgY2FzZSBzdm1fMS5TT0xBTkFfREVWTkVUX0dFTkVTSVNfQkxPQ0tfSEFTSDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgwLCB3ZWIzX2pzXzEuY2x1c3RlckFwaVVybCkoXCJkZXZuZXRcIik7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGNsdXN0ZXI6ICR7Y2x1c3Rlcn1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBjbHVzdGVyOiAke2NsdXN0ZXJ9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IFNvbGFuYUtleXBhaXJXYWxsZXRQcm92aWRlciBmcm9tIGFuIFNWTSBuZXR3b3JrSWQgYW5kIGEga2V5cGFpclxuICAgICAqXG4gICAgICogQHBhcmFtIG5ldHdvcmtJZCAtIFRoZSBTVk0gbmV0d29ya0lkXG4gICAgICogQHBhcmFtIGtleXBhaXIgLSBFaXRoZXIgYSBVaW50OEFycmF5IG9yIGEgYmFzZTU4IGVuY29kZWQgc3RyaW5nIHJlcHJlc2VudGluZyBhIDMyLWJ5dGUgc2VjcmV0IGtleVxuICAgICAqIEByZXR1cm5zIFRoZSBuZXcgU29sYW5hS2V5cGFpcldhbGxldFByb3ZpZGVyXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIGZyb21OZXR3b3JrKG5ldHdvcmtJZCwga2V5cGFpcikge1xuICAgICAgICBsZXQgZ2VuZXNpc0hhc2g7XG4gICAgICAgIHN3aXRjaCAobmV0d29ya0lkKSB7XG4gICAgICAgICAgICBjYXNlIHN2bV8xLlNPTEFOQV9NQUlOTkVUX05FVFdPUktfSUQ6XG4gICAgICAgICAgICAgICAgZ2VuZXNpc0hhc2ggPSBzdm1fMS5TT0xBTkFfTUFJTk5FVF9HRU5FU0lTX0JMT0NLX0hBU0g7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHN2bV8xLlNPTEFOQV9ERVZORVRfTkVUV09SS19JRDpcbiAgICAgICAgICAgICAgICBnZW5lc2lzSGFzaCA9IHN2bV8xLlNPTEFOQV9ERVZORVRfR0VORVNJU19CTE9DS19IQVNIO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBzdm1fMS5TT0xBTkFfVEVTVE5FVF9ORVRXT1JLX0lEOlxuICAgICAgICAgICAgICAgIGdlbmVzaXNIYXNoID0gc3ZtXzEuU09MQU5BX1RFU1RORVRfR0VORVNJU19CTE9DS19IQVNIO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7bmV0d29ya0lkfSBpcyBub3QgYSB2YWxpZCBTVk0gbmV0d29ya0lkYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcnBjVXJsID0gdGhpcy51cmxGb3JDbHVzdGVyKGdlbmVzaXNIYXNoKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZnJvbVJwY1VybChycGNVcmwsIGtleXBhaXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgU29sYW5hS2V5cGFpcldhbGxldFByb3ZpZGVyIGZyb20gYW4gUlBDIFVSTCBhbmQgYSBrZXlwYWlyXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcnBjVXJsIC0gVGhlIFVSTCBvZiB0aGUgU29sYW5hIFJQQyBlbmRwb2ludFxuICAgICAqIEBwYXJhbSBrZXlwYWlyIC0gRWl0aGVyIGEgVWludDhBcnJheSBvciBhIGJhc2U1OCBlbmNvZGVkIHN0cmluZyByZXByZXNlbnRpbmcgYSAzMi1ieXRlIHNlY3JldCBrZXlcbiAgICAgKiBAcmV0dXJucyBUaGUgbmV3IFNvbGFuYUtleXBhaXJXYWxsZXRQcm92aWRlclxuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyBmcm9tUnBjVXJsKHJwY1VybCwga2V5cGFpcikge1xuICAgICAgICBjb25zdCBjb25uZWN0aW9uID0gbmV3IHdlYjNfanNfMS5Db25uZWN0aW9uKHJwY1VybCk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmZyb21Db25uZWN0aW9uKGNvbm5lY3Rpb24sIGtleXBhaXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgU29sYW5hS2V5cGFpcldhbGxldFByb3ZpZGVyIGZyb20gYSBDb25uZWN0aW9uIGFuZCBhIGtleXBhaXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb25uZWN0aW9uIC0gVGhlIENvbm5lY3Rpb24gdG8gdXNlXG4gICAgICogQHBhcmFtIGtleXBhaXIgLSBFaXRoZXIgYSBVaW50OEFycmF5IG9yIGEgYmFzZTU4IGVuY29kZWQgc3RyaW5nIHJlcHJlc2VudGluZyBhIDMyLWJ5dGUgc2VjcmV0IGtleVxuICAgICAqIEByZXR1cm5zIFRoZSBuZXcgU29sYW5hS2V5cGFpcldhbGxldFByb3ZpZGVyXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIGZyb21Db25uZWN0aW9uKGNvbm5lY3Rpb24sIGtleXBhaXIpIHtcbiAgICAgICAgY29uc3QgZ2VuZXNpc0hhc2ggPSBhd2FpdCBjb25uZWN0aW9uLmdldEdlbmVzaXNIYXNoKCk7XG4gICAgICAgIHJldHVybiBuZXcgU29sYW5hS2V5cGFpcldhbGxldFByb3ZpZGVyKHtcbiAgICAgICAgICAgIGtleXBhaXIsXG4gICAgICAgICAgICBycGNVcmw6IGNvbm5lY3Rpb24ucnBjRW5kcG9pbnQsXG4gICAgICAgICAgICBnZW5lc2lzSGFzaDogZ2VuZXNpc0hhc2gsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGNvbm5lY3Rpb24gaW5zdGFuY2VcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBTb2xhbmEgY29ubmVjdGlvbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIGdldENvbm5lY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Tb2xhbmFLZXlwYWlyV2FsbGV0UHJvdmlkZXJfY29ubmVjdGlvbiwgXCJmXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHB1YmxpYyBrZXkgb2YgdGhlIHdhbGxldFxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHdhbGxldCdzIHB1YmxpYyBrZXlcbiAgICAgKi9cbiAgICBnZXRQdWJsaWNLZXkoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Tb2xhbmFLZXlwYWlyV2FsbGV0UHJvdmlkZXJfa2V5cGFpciwgXCJmXCIpLnB1YmxpY0tleTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBhZGRyZXNzIG9mIHRoZSB3YWxsZXRcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBiYXNlNTggZW5jb2RlZCBhZGRyZXNzIG9mIHRoZSB3YWxsZXRcbiAgICAgKi9cbiAgICBnZXRBZGRyZXNzKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU29sYW5hS2V5cGFpcldhbGxldFByb3ZpZGVyX2tleXBhaXIsIFwiZlwiKS5wdWJsaWNLZXkudG9CYXNlNTgoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBuZXR3b3JrXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgbmV0d29ya1xuICAgICAqL1xuICAgIGdldE5ldHdvcmsoKSB7XG4gICAgICAgIHJldHVybiBzdm1fMS5TT0xBTkFfTkVUV09SS1NbX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU29sYW5hS2V5cGFpcldhbGxldFByb3ZpZGVyX2dlbmVzaXNIYXNoLCBcImZcIildO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaWduIGEgdHJhbnNhY3Rpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0cmFuc2FjdGlvbiAtIFRoZSB0cmFuc2FjdGlvbiB0byBzaWduXG4gICAgICogQHJldHVybnMgVGhlIHNpZ25lZCB0cmFuc2FjdGlvblxuICAgICAqL1xuICAgIGFzeW5jIHNpZ25UcmFuc2FjdGlvbih0cmFuc2FjdGlvbikge1xuICAgICAgICB0cmFuc2FjdGlvbi5zaWduKFtfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Tb2xhbmFLZXlwYWlyV2FsbGV0UHJvdmlkZXJfa2V5cGFpciwgXCJmXCIpXSk7XG4gICAgICAgIHJldHVybiB0cmFuc2FjdGlvbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZCBhIHRyYW5zYWN0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdHJhbnNhY3Rpb24gLSBUaGUgdHJhbnNhY3Rpb24gdG8gc2VuZFxuICAgICAqIEByZXR1cm5zIFRoZSBzaWduYXR1cmVcbiAgICAgKi9cbiAgICBhc3luYyBzZW5kVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pIHtcbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU29sYW5hS2V5cGFpcldhbGxldFByb3ZpZGVyX2Nvbm5lY3Rpb24sIFwiZlwiKS5zZW5kVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pO1xuICAgICAgICBhd2FpdCB0aGlzLndhaXRGb3JTaWduYXR1cmVSZXN1bHQoc2lnbmF0dXJlKTtcbiAgICAgICAgcmV0dXJuIHNpZ25hdHVyZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2lnbiBhbmQgc2VuZCBhIHRyYW5zYWN0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdHJhbnNhY3Rpb24gLSBUaGUgdHJhbnNhY3Rpb24gdG8gc2lnbiBhbmQgc2VuZFxuICAgICAqIEByZXR1cm5zIFRoZSBzaWduYXR1cmVcbiAgICAgKi9cbiAgICBhc3luYyBzaWduQW5kU2VuZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IHNpZ25lZFRyYW5zYWN0aW9uID0gYXdhaXQgdGhpcy5zaWduVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pO1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kVHJhbnNhY3Rpb24oc2lnbmVkVHJhbnNhY3Rpb24pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHN0YXR1cyBvZiBhIHRyYW5zYWN0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2lnbmF0dXJlIC0gVGhlIHNpZ25hdHVyZVxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIHRoZSBzdGF0dXNcbiAgICAgKiBAcmV0dXJucyBUaGUgc3RhdHVzXG4gICAgICovXG4gICAgYXN5bmMgZ2V0U2lnbmF0dXJlU3RhdHVzKHNpZ25hdHVyZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU29sYW5hS2V5cGFpcldhbGxldFByb3ZpZGVyX2Nvbm5lY3Rpb24sIFwiZlwiKS5nZXRTaWduYXR1cmVTdGF0dXMoc2lnbmF0dXJlLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2FpdCBmb3Igc2lnbmF0dXJlIHJlY2VpcHRcbiAgICAgKlxuICAgICAqIEBwYXJhbSBzaWduYXR1cmUgLSBUaGUgc2lnbmF0dXJlXG4gICAgICogQHJldHVybnMgVGhlIGNvbmZpcm1hdGlvbiByZXNwb25zZVxuICAgICAqL1xuICAgIGFzeW5jIHdhaXRGb3JTaWduYXR1cmVSZXN1bHQoc2lnbmF0dXJlKSB7XG4gICAgICAgIGNvbnN0IHsgYmxvY2toYXNoLCBsYXN0VmFsaWRCbG9ja0hlaWdodCB9ID0gYXdhaXQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU29sYW5hS2V5cGFpcldhbGxldFByb3ZpZGVyX2Nvbm5lY3Rpb24sIFwiZlwiKS5nZXRMYXRlc3RCbG9ja2hhc2goKTtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1NvbGFuYUtleXBhaXJXYWxsZXRQcm92aWRlcl9jb25uZWN0aW9uLCBcImZcIikuY29uZmlybVRyYW5zYWN0aW9uKHtcbiAgICAgICAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlLFxuICAgICAgICAgICAgbGFzdFZhbGlkQmxvY2tIZWlnaHQsXG4gICAgICAgICAgICBibG9ja2hhc2gsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG5hbWUgb2YgdGhlIHdhbGxldCBwcm92aWRlclxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIG5hbWUgb2YgdGhlIHdhbGxldCBwcm92aWRlclxuICAgICAqL1xuICAgIGdldE5hbWUoKSB7XG4gICAgICAgIHJldHVybiBcInNvbGFuYV9rZXlwYWlyX3dhbGxldF9wcm92aWRlclwiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGJhbGFuY2Ugb2YgdGhlIHdhbGxldFxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGJhbGFuY2Ugb2YgdGhlIHdhbGxldFxuICAgICAqL1xuICAgIGdldEJhbGFuY2UoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Tb2xhbmFLZXlwYWlyV2FsbGV0UHJvdmlkZXJfY29ubmVjdGlvbiwgXCJmXCIpLmdldEJhbGFuY2UoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU29sYW5hS2V5cGFpcldhbGxldFByb3ZpZGVyX2tleXBhaXIsIFwiZlwiKS5wdWJsaWNLZXkpLnRoZW4oYmFsYW5jZSA9PiBCaWdJbnQoYmFsYW5jZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmFuc2ZlciBTT0wgZnJvbSB0aGUgd2FsbGV0IHRvIGFub3RoZXIgYWRkcmVzc1xuICAgICAqXG4gICAgICogQHBhcmFtIHRvIC0gVGhlIGJhc2U1OCBlbmNvZGVkIGFkZHJlc3MgdG8gdHJhbnNmZXIgdGhlIFNPTCB0b1xuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBhbW91bnQgb2YgU09MIHRvIHRyYW5zZmVyIChhcyBhIGRlY2ltYWwgc3RyaW5nLCBlLmcuIFwiMC4wMDAxXCIpXG4gICAgICogQHJldHVybnMgVGhlIHNpZ25hdHVyZVxuICAgICAqL1xuICAgIGFzeW5jIG5hdGl2ZVRyYW5zZmVyKHRvLCB2YWx1ZSkge1xuICAgICAgICBjb25zdCBpbml0aWFsQmFsYW5jZSA9IGF3YWl0IHRoaXMuZ2V0QmFsYW5jZSgpO1xuICAgICAgICBjb25zdCBzb2xBbW91bnQgPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICAgICAgY29uc3QgbGFtcG9ydHMgPSBCaWdJbnQoTWF0aC5mbG9vcihzb2xBbW91bnQgKiB3ZWIzX2pzXzEuTEFNUE9SVFNfUEVSX1NPTCkpO1xuICAgICAgICAvLyBDaGVjayBpZiB3ZSBoYXZlIGVub3VnaCBiYWxhbmNlIChpbmNsdWRpbmcgZXN0aW1hdGVkIGZlZXMpXG4gICAgICAgIGlmIChpbml0aWFsQmFsYW5jZSA8IGxhbXBvcnRzICsgQmlnSW50KDUwMDApKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEluc3VmZmljaWVudCBiYWxhbmNlLiBIYXZlICR7TnVtYmVyKGluaXRpYWxCYWxhbmNlKSAvIHdlYjNfanNfMS5MQU1QT1JUU19QRVJfU09MfSBTT0wsIG5lZWQgJHtzb2xBbW91bnQgKyAwLjAwMDAwNX0gU09MIChpbmNsdWRpbmcgZmVlcylgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0b1B1YmtleSA9IG5ldyB3ZWIzX2pzXzEuUHVibGljS2V5KHRvKTtcbiAgICAgICAgY29uc3QgaW5zdHJ1Y3Rpb25zID0gW1xuICAgICAgICAgICAgd2ViM19qc18xLkNvbXB1dGVCdWRnZXRQcm9ncmFtLnNldENvbXB1dGVVbml0UHJpY2Uoe1xuICAgICAgICAgICAgICAgIG1pY3JvTGFtcG9ydHM6IDEwMDAwLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB3ZWIzX2pzXzEuQ29tcHV0ZUJ1ZGdldFByb2dyYW0uc2V0Q29tcHV0ZVVuaXRMaW1pdCh7XG4gICAgICAgICAgICAgICAgdW5pdHM6IDIwMDAsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHdlYjNfanNfMS5TeXN0ZW1Qcm9ncmFtLnRyYW5zZmVyKHtcbiAgICAgICAgICAgICAgICBmcm9tUHVia2V5OiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Tb2xhbmFLZXlwYWlyV2FsbGV0UHJvdmlkZXJfa2V5cGFpciwgXCJmXCIpLnB1YmxpY0tleSxcbiAgICAgICAgICAgICAgICB0b1B1YmtleTogdG9QdWJrZXksXG4gICAgICAgICAgICAgICAgbGFtcG9ydHM6IGxhbXBvcnRzLFxuICAgICAgICAgICAgfSksXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IHR4ID0gbmV3IHdlYjNfanNfMS5WZXJzaW9uZWRUcmFuc2FjdGlvbih3ZWIzX2pzXzEuTWVzc2FnZVYwLmNvbXBpbGUoe1xuICAgICAgICAgICAgcGF5ZXJLZXk6IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1NvbGFuYUtleXBhaXJXYWxsZXRQcm92aWRlcl9rZXlwYWlyLCBcImZcIikucHVibGljS2V5LFxuICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zOiBpbnN0cnVjdGlvbnMsXG4gICAgICAgICAgICByZWNlbnRCbG9ja2hhc2g6IChhd2FpdCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Tb2xhbmFLZXlwYWlyV2FsbGV0UHJvdmlkZXJfY29ubmVjdGlvbiwgXCJmXCIpLmdldExhdGVzdEJsb2NraGFzaCgpKS5ibG9ja2hhc2gsXG4gICAgICAgIH0pKTtcbiAgICAgICAgdHguc2lnbihbX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU29sYW5hS2V5cGFpcldhbGxldFByb3ZpZGVyX2tleXBhaXIsIFwiZlwiKV0pO1xuICAgICAgICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Tb2xhbmFLZXlwYWlyV2FsbGV0UHJvdmlkZXJfY29ubmVjdGlvbiwgXCJmXCIpLnNlbmRUcmFuc2FjdGlvbih0eCk7XG4gICAgICAgIGF3YWl0IHRoaXMud2FpdEZvclNpZ25hdHVyZVJlc3VsdChzaWduYXR1cmUpO1xuICAgICAgICByZXR1cm4gc2lnbmF0dXJlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXF1ZXN0IFNPTCB0b2tlbnMgZnJvbSB0aGUgU29sYW5hIGZhdWNldC4gVGhpcyBtZXRob2Qgb25seSB3b3JrcyBvbiBkZXZuZXQgYW5kIHRlc3RuZXQgbmV0d29ya3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGFtcG9ydHMgLSBUaGUgYW1vdW50IG9mIGxhbXBvcnRzICgxIFNPTCA9IDEsMDAwLDAwMCwwMDAgbGFtcG9ydHMpIHRvIHJlcXVlc3QgZnJvbSB0aGUgZmF1Y2V0XG4gICAgICogQHJldHVybnMgQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHNpZ25hdHVyZSBvZiB0aGUgYWlyZHJvcFxuICAgICAqL1xuICAgIGFzeW5jIHJlcXVlc3RBaXJkcm9wKGxhbXBvcnRzKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Tb2xhbmFLZXlwYWlyV2FsbGV0UHJvdmlkZXJfY29ubmVjdGlvbiwgXCJmXCIpLnJlcXVlc3RBaXJkcm9wKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1NvbGFuYUtleXBhaXJXYWxsZXRQcm92aWRlcl9rZXlwYWlyLCBcImZcIikucHVibGljS2V5LCBsYW1wb3J0cyk7XG4gICAgfVxufVxuZXhwb3J0cy5Tb2xhbmFLZXlwYWlyV2FsbGV0UHJvdmlkZXIgPSBTb2xhbmFLZXlwYWlyV2FsbGV0UHJvdmlkZXI7XG5fU29sYW5hS2V5cGFpcldhbGxldFByb3ZpZGVyX2tleXBhaXIgPSBuZXcgV2Vha01hcCgpLCBfU29sYW5hS2V5cGFpcldhbGxldFByb3ZpZGVyX2Nvbm5lY3Rpb24gPSBuZXcgV2Vha01hcCgpLCBfU29sYW5hS2V5cGFpcldhbGxldFByb3ZpZGVyX2dlbmVzaXNIYXNoID0gbmV3IFdlYWtNYXAoKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/wallet-providers/solanaKeypairWalletProvider.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/wallet-providers/svmWalletProvider.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/wallet-providers/svmWalletProvider.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/* eslint-disable @typescript-eslint/no-explicit-any */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SvmWalletProvider = void 0;\nconst walletProvider_1 = __webpack_require__(/*! ./walletProvider */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/wallet-providers/walletProvider.js\");\n/**\n * SvmWalletProvider is the abstract base class for all Solana wallet providers (non browsers).\n *\n * @abstract\n */\nclass SvmWalletProvider extends walletProvider_1.WalletProvider {\n}\nexports.SvmWalletProvider = SvmWalletProvider;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3Qvd2FsbGV0LXByb3ZpZGVycy9zdm1XYWxsZXRQcm92aWRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHlCQUF5QjtBQUN6Qix5QkFBeUIsbUJBQU8sQ0FBQyx5R0FBa0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXJ2aXZhbC1mdW4vLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3Qvd2FsbGV0LXByb3ZpZGVycy9zdm1XYWxsZXRQcm92aWRlci5qcz82N2FkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Tdm1XYWxsZXRQcm92aWRlciA9IHZvaWQgMDtcbmNvbnN0IHdhbGxldFByb3ZpZGVyXzEgPSByZXF1aXJlKFwiLi93YWxsZXRQcm92aWRlclwiKTtcbi8qKlxuICogU3ZtV2FsbGV0UHJvdmlkZXIgaXMgdGhlIGFic3RyYWN0IGJhc2UgY2xhc3MgZm9yIGFsbCBTb2xhbmEgd2FsbGV0IHByb3ZpZGVycyAobm9uIGJyb3dzZXJzKS5cbiAqXG4gKiBAYWJzdHJhY3RcbiAqL1xuY2xhc3MgU3ZtV2FsbGV0UHJvdmlkZXIgZXh0ZW5kcyB3YWxsZXRQcm92aWRlcl8xLldhbGxldFByb3ZpZGVyIHtcbn1cbmV4cG9ydHMuU3ZtV2FsbGV0UHJvdmlkZXIgPSBTdm1XYWxsZXRQcm92aWRlcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/wallet-providers/svmWalletProvider.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/wallet-providers/viemWalletProvider.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/wallet-providers/viemWalletProvider.js ***!
  \*************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n// TODO: Improve type safety\n/* eslint-disable @typescript-eslint/no-explicit-any */\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _ViemWalletProvider_walletClient, _ViemWalletProvider_publicClient, _ViemWalletProvider_gasLimitMultiplier, _ViemWalletProvider_feePerGasMultiplier;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ViemWalletProvider = void 0;\nconst viem_1 = __webpack_require__(/*! viem */ \"(rsc)/./node_modules/viem/_cjs/index.js\");\nconst evmWalletProvider_1 = __webpack_require__(/*! ./evmWalletProvider */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/wallet-providers/evmWalletProvider.js\");\nconst network_1 = __webpack_require__(/*! ../network/network */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/network/network.js\");\nconst utils_1 = __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/utils.js\");\n/**\n * A wallet provider that uses the Viem library.\n */\nclass ViemWalletProvider extends evmWalletProvider_1.EvmWalletProvider {\n    /**\n     * Constructs a new ViemWalletProvider.\n     *\n     * @param walletClient - The wallet client.\n     * @param gasConfig - Configuration for gas multipliers.\n     */\n    constructor(walletClient, gasConfig) {\n        super();\n        _ViemWalletProvider_walletClient.set(this, void 0);\n        _ViemWalletProvider_publicClient.set(this, void 0);\n        _ViemWalletProvider_gasLimitMultiplier.set(this, void 0);\n        _ViemWalletProvider_feePerGasMultiplier.set(this, void 0);\n        __classPrivateFieldSet(this, _ViemWalletProvider_walletClient, walletClient, \"f\");\n        __classPrivateFieldSet(this, _ViemWalletProvider_publicClient, (0, viem_1.createPublicClient)({\n            chain: walletClient.chain,\n            transport: (0, viem_1.http)(),\n        }), \"f\");\n        __classPrivateFieldSet(this, _ViemWalletProvider_gasLimitMultiplier, Math.max(gasConfig?.gasLimitMultiplier ?? 1.2, 1), \"f\");\n        __classPrivateFieldSet(this, _ViemWalletProvider_feePerGasMultiplier, Math.max(gasConfig?.feePerGasMultiplier ?? 1, 1), \"f\");\n    }\n    /**\n     * Signs a message.\n     *\n     * @param message - The message to sign.\n     * @returns The signed message.\n     */\n    async signMessage(message) {\n        const account = __classPrivateFieldGet(this, _ViemWalletProvider_walletClient, \"f\").account;\n        if (!account) {\n            throw new Error(\"Account not found\");\n        }\n        return __classPrivateFieldGet(this, _ViemWalletProvider_walletClient, \"f\").signMessage({ account, message });\n    }\n    /**\n     * Signs a typed data object.\n     *\n     * @param typedData - The typed data object to sign.\n     * @returns The signed typed data object.\n     */\n    async signTypedData(typedData) {\n        return __classPrivateFieldGet(this, _ViemWalletProvider_walletClient, \"f\").signTypedData({\n            account: __classPrivateFieldGet(this, _ViemWalletProvider_walletClient, \"f\").account,\n            domain: typedData.domain,\n            types: typedData.types,\n            primaryType: typedData.primaryType,\n            message: typedData.message,\n        });\n    }\n    /**\n     * Signs a transaction.\n     *\n     * @param transaction - The transaction to sign.\n     * @returns The signed transaction.\n     */\n    async signTransaction(transaction) {\n        const txParams = {\n            account: __classPrivateFieldGet(this, _ViemWalletProvider_walletClient, \"f\").account,\n            to: transaction.to,\n            value: transaction.value,\n            data: transaction.data,\n            chain: __classPrivateFieldGet(this, _ViemWalletProvider_walletClient, \"f\").chain,\n        };\n        return __classPrivateFieldGet(this, _ViemWalletProvider_walletClient, \"f\").signTransaction(txParams);\n    }\n    /**\n     * Sends a transaction.\n     *\n     * @param transaction - The transaction to send.\n     * @returns The hash of the transaction.\n     */\n    async sendTransaction(transaction) {\n        const account = __classPrivateFieldGet(this, _ViemWalletProvider_walletClient, \"f\").account;\n        if (!account) {\n            throw new Error(\"Account not found\");\n        }\n        const chain = __classPrivateFieldGet(this, _ViemWalletProvider_walletClient, \"f\").chain;\n        if (!chain) {\n            throw new Error(\"Chain not found\");\n        }\n        const feeData = await __classPrivateFieldGet(this, _ViemWalletProvider_publicClient, \"f\").estimateFeesPerGas();\n        const maxFeePerGas = (0, utils_1.applyGasMultiplier)(feeData.maxFeePerGas, __classPrivateFieldGet(this, _ViemWalletProvider_feePerGasMultiplier, \"f\"));\n        const maxPriorityFeePerGas = (0, utils_1.applyGasMultiplier)(feeData.maxPriorityFeePerGas, __classPrivateFieldGet(this, _ViemWalletProvider_feePerGasMultiplier, \"f\"));\n        const gasLimit = await __classPrivateFieldGet(this, _ViemWalletProvider_publicClient, \"f\").estimateGas({\n            account,\n            to: transaction.to,\n            value: transaction.value,\n            data: transaction.data,\n        });\n        const gas = BigInt(Math.round(Number(gasLimit) * __classPrivateFieldGet(this, _ViemWalletProvider_gasLimitMultiplier, \"f\")));\n        const txParams = {\n            account: account,\n            chain: chain,\n            data: transaction.data,\n            to: transaction.to,\n            value: transaction.value,\n            gas,\n            maxFeePerGas,\n            maxPriorityFeePerGas,\n        };\n        return __classPrivateFieldGet(this, _ViemWalletProvider_walletClient, \"f\").sendTransaction(txParams);\n    }\n    /**\n     * Gets the address of the wallet.\n     *\n     * @returns The address of the wallet.\n     */\n    getAddress() {\n        return __classPrivateFieldGet(this, _ViemWalletProvider_walletClient, \"f\").account?.address ?? \"\";\n    }\n    /**\n     * Gets the network of the wallet.\n     *\n     * @returns The network of the wallet.\n     */\n    getNetwork() {\n        return {\n            protocolFamily: \"evm\",\n            chainId: String(__classPrivateFieldGet(this, _ViemWalletProvider_walletClient, \"f\").chain.id),\n            networkId: network_1.CHAIN_ID_TO_NETWORK_ID[__classPrivateFieldGet(this, _ViemWalletProvider_walletClient, \"f\").chain.id],\n        };\n    }\n    /**\n     * Gets the name of the wallet provider.\n     *\n     * @returns The name of the wallet provider.\n     */\n    getName() {\n        return \"viem_wallet_provider\";\n    }\n    /**\n     * Gets the balance of the wallet.\n     *\n     * @returns The balance of the wallet.\n     */\n    async getBalance() {\n        const account = __classPrivateFieldGet(this, _ViemWalletProvider_walletClient, \"f\").account;\n        if (!account) {\n            throw new Error(\"Account not found\");\n        }\n        return __classPrivateFieldGet(this, _ViemWalletProvider_publicClient, \"f\").getBalance({ address: account.address });\n    }\n    /**\n     * Waits for a transaction receipt.\n     *\n     * @param txHash - The hash of the transaction to wait for.\n     * @returns The transaction receipt.\n     */\n    async waitForTransactionReceipt(txHash) {\n        return await __classPrivateFieldGet(this, _ViemWalletProvider_publicClient, \"f\").waitForTransactionReceipt({ hash: txHash });\n    }\n    /**\n     * Reads a contract.\n     *\n     * @param params - The parameters to read the contract.\n     * @returns The response from the contract.\n     */\n    async readContract(params) {\n        return __classPrivateFieldGet(this, _ViemWalletProvider_publicClient, \"f\").readContract(params);\n    }\n    /**\n     * Transfer the native asset of the network.\n     *\n     * @param to - The destination address.\n     * @param value - The amount to transfer in whole units (e.g. ETH)\n     * @returns The transaction hash.\n     */\n    async nativeTransfer(to, value) {\n        const atomicAmount = (0, viem_1.parseEther)(value);\n        const tx = await this.sendTransaction({\n            to: to,\n            value: atomicAmount,\n        });\n        const receipt = await this.waitForTransactionReceipt(tx);\n        if (!receipt) {\n            throw new Error(\"Transaction failed\");\n        }\n        return receipt.transactionHash;\n    }\n}\nexports.ViemWalletProvider = ViemWalletProvider;\n_ViemWalletProvider_walletClient = new WeakMap(), _ViemWalletProvider_publicClient = new WeakMap(), _ViemWalletProvider_gasLimitMultiplier = new WeakMap(), _ViemWalletProvider_feePerGasMultiplier = new WeakMap();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3Qvd2FsbGV0LXByb3ZpZGVycy92aWVtV2FsbGV0UHJvdmlkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDBCQUEwQjtBQUMxQixlQUFlLG1CQUFPLENBQUMscURBQU07QUFDN0IsNEJBQTRCLG1CQUFPLENBQUMsK0dBQXFCO0FBQ3pELGtCQUFrQixtQkFBTyxDQUFDLDJGQUFvQjtBQUM5QyxnQkFBZ0IsbUJBQU8sQ0FBQyx1RUFBVTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpR0FBaUcsa0JBQWtCO0FBQ25IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0dBQWdHLDBCQUEwQjtBQUMxSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUhBQXFILGNBQWM7QUFDbkk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXJ2aXZhbC1mdW4vLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3Qvd2FsbGV0LXByb3ZpZGVycy92aWVtV2FsbGV0UHJvdmlkZXIuanM/NjdiNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIFRPRE86IEltcHJvdmUgdHlwZSBzYWZldHlcbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcbn07XG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZEdldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZEdldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xufTtcbnZhciBfVmllbVdhbGxldFByb3ZpZGVyX3dhbGxldENsaWVudCwgX1ZpZW1XYWxsZXRQcm92aWRlcl9wdWJsaWNDbGllbnQsIF9WaWVtV2FsbGV0UHJvdmlkZXJfZ2FzTGltaXRNdWx0aXBsaWVyLCBfVmllbVdhbGxldFByb3ZpZGVyX2ZlZVBlckdhc011bHRpcGxpZXI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlZpZW1XYWxsZXRQcm92aWRlciA9IHZvaWQgMDtcbmNvbnN0IHZpZW1fMSA9IHJlcXVpcmUoXCJ2aWVtXCIpO1xuY29uc3QgZXZtV2FsbGV0UHJvdmlkZXJfMSA9IHJlcXVpcmUoXCIuL2V2bVdhbGxldFByb3ZpZGVyXCIpO1xuY29uc3QgbmV0d29ya18xID0gcmVxdWlyZShcIi4uL25ldHdvcmsvbmV0d29ya1wiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG4vKipcbiAqIEEgd2FsbGV0IHByb3ZpZGVyIHRoYXQgdXNlcyB0aGUgVmllbSBsaWJyYXJ5LlxuICovXG5jbGFzcyBWaWVtV2FsbGV0UHJvdmlkZXIgZXh0ZW5kcyBldm1XYWxsZXRQcm92aWRlcl8xLkV2bVdhbGxldFByb3ZpZGVyIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IFZpZW1XYWxsZXRQcm92aWRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB3YWxsZXRDbGllbnQgLSBUaGUgd2FsbGV0IGNsaWVudC5cbiAgICAgKiBAcGFyYW0gZ2FzQ29uZmlnIC0gQ29uZmlndXJhdGlvbiBmb3IgZ2FzIG11bHRpcGxpZXJzLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHdhbGxldENsaWVudCwgZ2FzQ29uZmlnKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIF9WaWVtV2FsbGV0UHJvdmlkZXJfd2FsbGV0Q2xpZW50LnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICBfVmllbVdhbGxldFByb3ZpZGVyX3B1YmxpY0NsaWVudC5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX1ZpZW1XYWxsZXRQcm92aWRlcl9nYXNMaW1pdE11bHRpcGxpZXIuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9WaWVtV2FsbGV0UHJvdmlkZXJfZmVlUGVyR2FzTXVsdGlwbGllci5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfVmllbVdhbGxldFByb3ZpZGVyX3dhbGxldENsaWVudCwgd2FsbGV0Q2xpZW50LCBcImZcIik7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX1ZpZW1XYWxsZXRQcm92aWRlcl9wdWJsaWNDbGllbnQsICgwLCB2aWVtXzEuY3JlYXRlUHVibGljQ2xpZW50KSh7XG4gICAgICAgICAgICBjaGFpbjogd2FsbGV0Q2xpZW50LmNoYWluLFxuICAgICAgICAgICAgdHJhbnNwb3J0OiAoMCwgdmllbV8xLmh0dHApKCksXG4gICAgICAgIH0pLCBcImZcIik7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX1ZpZW1XYWxsZXRQcm92aWRlcl9nYXNMaW1pdE11bHRpcGxpZXIsIE1hdGgubWF4KGdhc0NvbmZpZz8uZ2FzTGltaXRNdWx0aXBsaWVyID8/IDEuMiwgMSksIFwiZlwiKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfVmllbVdhbGxldFByb3ZpZGVyX2ZlZVBlckdhc011bHRpcGxpZXIsIE1hdGgubWF4KGdhc0NvbmZpZz8uZmVlUGVyR2FzTXVsdGlwbGllciA/PyAxLCAxKSwgXCJmXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaWducyBhIG1lc3NhZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWVzc2FnZSAtIFRoZSBtZXNzYWdlIHRvIHNpZ24uXG4gICAgICogQHJldHVybnMgVGhlIHNpZ25lZCBtZXNzYWdlLlxuICAgICAqL1xuICAgIGFzeW5jIHNpZ25NZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgYWNjb3VudCA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1ZpZW1XYWxsZXRQcm92aWRlcl93YWxsZXRDbGllbnQsIFwiZlwiKS5hY2NvdW50O1xuICAgICAgICBpZiAoIWFjY291bnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFjY291bnQgbm90IGZvdW5kXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9WaWVtV2FsbGV0UHJvdmlkZXJfd2FsbGV0Q2xpZW50LCBcImZcIikuc2lnbk1lc3NhZ2UoeyBhY2NvdW50LCBtZXNzYWdlIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaWducyBhIHR5cGVkIGRhdGEgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHR5cGVkRGF0YSAtIFRoZSB0eXBlZCBkYXRhIG9iamVjdCB0byBzaWduLlxuICAgICAqIEByZXR1cm5zIFRoZSBzaWduZWQgdHlwZWQgZGF0YSBvYmplY3QuXG4gICAgICovXG4gICAgYXN5bmMgc2lnblR5cGVkRGF0YSh0eXBlZERhdGEpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1ZpZW1XYWxsZXRQcm92aWRlcl93YWxsZXRDbGllbnQsIFwiZlwiKS5zaWduVHlwZWREYXRhKHtcbiAgICAgICAgICAgIGFjY291bnQ6IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1ZpZW1XYWxsZXRQcm92aWRlcl93YWxsZXRDbGllbnQsIFwiZlwiKS5hY2NvdW50LFxuICAgICAgICAgICAgZG9tYWluOiB0eXBlZERhdGEuZG9tYWluLFxuICAgICAgICAgICAgdHlwZXM6IHR5cGVkRGF0YS50eXBlcyxcbiAgICAgICAgICAgIHByaW1hcnlUeXBlOiB0eXBlZERhdGEucHJpbWFyeVR5cGUsXG4gICAgICAgICAgICBtZXNzYWdlOiB0eXBlZERhdGEubWVzc2FnZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNpZ25zIGEgdHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdHJhbnNhY3Rpb24gLSBUaGUgdHJhbnNhY3Rpb24gdG8gc2lnbi5cbiAgICAgKiBAcmV0dXJucyBUaGUgc2lnbmVkIHRyYW5zYWN0aW9uLlxuICAgICAqL1xuICAgIGFzeW5jIHNpZ25UcmFuc2FjdGlvbih0cmFuc2FjdGlvbikge1xuICAgICAgICBjb25zdCB0eFBhcmFtcyA9IHtcbiAgICAgICAgICAgIGFjY291bnQ6IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1ZpZW1XYWxsZXRQcm92aWRlcl93YWxsZXRDbGllbnQsIFwiZlwiKS5hY2NvdW50LFxuICAgICAgICAgICAgdG86IHRyYW5zYWN0aW9uLnRvLFxuICAgICAgICAgICAgdmFsdWU6IHRyYW5zYWN0aW9uLnZhbHVlLFxuICAgICAgICAgICAgZGF0YTogdHJhbnNhY3Rpb24uZGF0YSxcbiAgICAgICAgICAgIGNoYWluOiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9WaWVtV2FsbGV0UHJvdmlkZXJfd2FsbGV0Q2xpZW50LCBcImZcIikuY2hhaW4sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9WaWVtV2FsbGV0UHJvdmlkZXJfd2FsbGV0Q2xpZW50LCBcImZcIikuc2lnblRyYW5zYWN0aW9uKHR4UGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0cmFuc2FjdGlvbiAtIFRoZSB0cmFuc2FjdGlvbiB0byBzZW5kLlxuICAgICAqIEByZXR1cm5zIFRoZSBoYXNoIG9mIHRoZSB0cmFuc2FjdGlvbi5cbiAgICAgKi9cbiAgICBhc3luYyBzZW5kVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pIHtcbiAgICAgICAgY29uc3QgYWNjb3VudCA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1ZpZW1XYWxsZXRQcm92aWRlcl93YWxsZXRDbGllbnQsIFwiZlwiKS5hY2NvdW50O1xuICAgICAgICBpZiAoIWFjY291bnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFjY291bnQgbm90IGZvdW5kXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNoYWluID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfVmllbVdhbGxldFByb3ZpZGVyX3dhbGxldENsaWVudCwgXCJmXCIpLmNoYWluO1xuICAgICAgICBpZiAoIWNoYWluKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDaGFpbiBub3QgZm91bmRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmVlRGF0YSA9IGF3YWl0IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1ZpZW1XYWxsZXRQcm92aWRlcl9wdWJsaWNDbGllbnQsIFwiZlwiKS5lc3RpbWF0ZUZlZXNQZXJHYXMoKTtcbiAgICAgICAgY29uc3QgbWF4RmVlUGVyR2FzID0gKDAsIHV0aWxzXzEuYXBwbHlHYXNNdWx0aXBsaWVyKShmZWVEYXRhLm1heEZlZVBlckdhcywgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfVmllbVdhbGxldFByb3ZpZGVyX2ZlZVBlckdhc011bHRpcGxpZXIsIFwiZlwiKSk7XG4gICAgICAgIGNvbnN0IG1heFByaW9yaXR5RmVlUGVyR2FzID0gKDAsIHV0aWxzXzEuYXBwbHlHYXNNdWx0aXBsaWVyKShmZWVEYXRhLm1heFByaW9yaXR5RmVlUGVyR2FzLCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9WaWVtV2FsbGV0UHJvdmlkZXJfZmVlUGVyR2FzTXVsdGlwbGllciwgXCJmXCIpKTtcbiAgICAgICAgY29uc3QgZ2FzTGltaXQgPSBhd2FpdCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9WaWVtV2FsbGV0UHJvdmlkZXJfcHVibGljQ2xpZW50LCBcImZcIikuZXN0aW1hdGVHYXMoe1xuICAgICAgICAgICAgYWNjb3VudCxcbiAgICAgICAgICAgIHRvOiB0cmFuc2FjdGlvbi50byxcbiAgICAgICAgICAgIHZhbHVlOiB0cmFuc2FjdGlvbi52YWx1ZSxcbiAgICAgICAgICAgIGRhdGE6IHRyYW5zYWN0aW9uLmRhdGEsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBnYXMgPSBCaWdJbnQoTWF0aC5yb3VuZChOdW1iZXIoZ2FzTGltaXQpICogX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfVmllbVdhbGxldFByb3ZpZGVyX2dhc0xpbWl0TXVsdGlwbGllciwgXCJmXCIpKSk7XG4gICAgICAgIGNvbnN0IHR4UGFyYW1zID0ge1xuICAgICAgICAgICAgYWNjb3VudDogYWNjb3VudCxcbiAgICAgICAgICAgIGNoYWluOiBjaGFpbixcbiAgICAgICAgICAgIGRhdGE6IHRyYW5zYWN0aW9uLmRhdGEsXG4gICAgICAgICAgICB0bzogdHJhbnNhY3Rpb24udG8sXG4gICAgICAgICAgICB2YWx1ZTogdHJhbnNhY3Rpb24udmFsdWUsXG4gICAgICAgICAgICBnYXMsXG4gICAgICAgICAgICBtYXhGZWVQZXJHYXMsXG4gICAgICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhcyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1ZpZW1XYWxsZXRQcm92aWRlcl93YWxsZXRDbGllbnQsIFwiZlwiKS5zZW5kVHJhbnNhY3Rpb24odHhQYXJhbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBhZGRyZXNzIG9mIHRoZSB3YWxsZXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgYWRkcmVzcyBvZiB0aGUgd2FsbGV0LlxuICAgICAqL1xuICAgIGdldEFkZHJlc3MoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9WaWVtV2FsbGV0UHJvdmlkZXJfd2FsbGV0Q2xpZW50LCBcImZcIikuYWNjb3VudD8uYWRkcmVzcyA/PyBcIlwiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBuZXR3b3JrIG9mIHRoZSB3YWxsZXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgbmV0d29yayBvZiB0aGUgd2FsbGV0LlxuICAgICAqL1xuICAgIGdldE5ldHdvcmsoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwcm90b2NvbEZhbWlseTogXCJldm1cIixcbiAgICAgICAgICAgIGNoYWluSWQ6IFN0cmluZyhfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9WaWVtV2FsbGV0UHJvdmlkZXJfd2FsbGV0Q2xpZW50LCBcImZcIikuY2hhaW4uaWQpLFxuICAgICAgICAgICAgbmV0d29ya0lkOiBuZXR3b3JrXzEuQ0hBSU5fSURfVE9fTkVUV09SS19JRFtfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9WaWVtV2FsbGV0UHJvdmlkZXJfd2FsbGV0Q2xpZW50LCBcImZcIikuY2hhaW4uaWRdLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBuYW1lIG9mIHRoZSB3YWxsZXQgcHJvdmlkZXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgbmFtZSBvZiB0aGUgd2FsbGV0IHByb3ZpZGVyLlxuICAgICAqL1xuICAgIGdldE5hbWUoKSB7XG4gICAgICAgIHJldHVybiBcInZpZW1fd2FsbGV0X3Byb3ZpZGVyXCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGJhbGFuY2Ugb2YgdGhlIHdhbGxldC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBiYWxhbmNlIG9mIHRoZSB3YWxsZXQuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QmFsYW5jZSgpIHtcbiAgICAgICAgY29uc3QgYWNjb3VudCA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1ZpZW1XYWxsZXRQcm92aWRlcl93YWxsZXRDbGllbnQsIFwiZlwiKS5hY2NvdW50O1xuICAgICAgICBpZiAoIWFjY291bnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFjY291bnQgbm90IGZvdW5kXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9WaWVtV2FsbGV0UHJvdmlkZXJfcHVibGljQ2xpZW50LCBcImZcIikuZ2V0QmFsYW5jZSh7IGFkZHJlc3M6IGFjY291bnQuYWRkcmVzcyB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2FpdHMgZm9yIGEgdHJhbnNhY3Rpb24gcmVjZWlwdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0eEhhc2ggLSBUaGUgaGFzaCBvZiB0aGUgdHJhbnNhY3Rpb24gdG8gd2FpdCBmb3IuXG4gICAgICogQHJldHVybnMgVGhlIHRyYW5zYWN0aW9uIHJlY2VpcHQuXG4gICAgICovXG4gICAgYXN5bmMgd2FpdEZvclRyYW5zYWN0aW9uUmVjZWlwdCh0eEhhc2gpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1ZpZW1XYWxsZXRQcm92aWRlcl9wdWJsaWNDbGllbnQsIFwiZlwiKS53YWl0Rm9yVHJhbnNhY3Rpb25SZWNlaXB0KHsgaGFzaDogdHhIYXNoIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkcyBhIGNvbnRyYWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIHRvIHJlYWQgdGhlIGNvbnRyYWN0LlxuICAgICAqIEByZXR1cm5zIFRoZSByZXNwb25zZSBmcm9tIHRoZSBjb250cmFjdC5cbiAgICAgKi9cbiAgICBhc3luYyByZWFkQ29udHJhY3QocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9WaWVtV2FsbGV0UHJvdmlkZXJfcHVibGljQ2xpZW50LCBcImZcIikucmVhZENvbnRyYWN0KHBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyYW5zZmVyIHRoZSBuYXRpdmUgYXNzZXQgb2YgdGhlIG5ldHdvcmsuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdG8gLSBUaGUgZGVzdGluYXRpb24gYWRkcmVzcy5cbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgYW1vdW50IHRvIHRyYW5zZmVyIGluIHdob2xlIHVuaXRzIChlLmcuIEVUSClcbiAgICAgKiBAcmV0dXJucyBUaGUgdHJhbnNhY3Rpb24gaGFzaC5cbiAgICAgKi9cbiAgICBhc3luYyBuYXRpdmVUcmFuc2Zlcih0bywgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgYXRvbWljQW1vdW50ID0gKDAsIHZpZW1fMS5wYXJzZUV0aGVyKSh2YWx1ZSk7XG4gICAgICAgIGNvbnN0IHR4ID0gYXdhaXQgdGhpcy5zZW5kVHJhbnNhY3Rpb24oe1xuICAgICAgICAgICAgdG86IHRvLFxuICAgICAgICAgICAgdmFsdWU6IGF0b21pY0Ftb3VudCxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCB0aGlzLndhaXRGb3JUcmFuc2FjdGlvblJlY2VpcHQodHgpO1xuICAgICAgICBpZiAoIXJlY2VpcHQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRyYW5zYWN0aW9uIGZhaWxlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVjZWlwdC50cmFuc2FjdGlvbkhhc2g7XG4gICAgfVxufVxuZXhwb3J0cy5WaWVtV2FsbGV0UHJvdmlkZXIgPSBWaWVtV2FsbGV0UHJvdmlkZXI7XG5fVmllbVdhbGxldFByb3ZpZGVyX3dhbGxldENsaWVudCA9IG5ldyBXZWFrTWFwKCksIF9WaWVtV2FsbGV0UHJvdmlkZXJfcHVibGljQ2xpZW50ID0gbmV3IFdlYWtNYXAoKSwgX1ZpZW1XYWxsZXRQcm92aWRlcl9nYXNMaW1pdE11bHRpcGxpZXIgPSBuZXcgV2Vha01hcCgpLCBfVmllbVdhbGxldFByb3ZpZGVyX2ZlZVBlckdhc011bHRpcGxpZXIgPSBuZXcgV2Vha01hcCgpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/wallet-providers/viemWalletProvider.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/dist/wallet-providers/walletProvider.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/dist/wallet-providers/walletProvider.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.WalletProvider = void 0;\nconst analytics_1 = __webpack_require__(/*! ../analytics */ \"(rsc)/./node_modules/@coinbase/agentkit/dist/analytics/index.js\");\n/**\n * WalletProvider is the abstract base class for all wallet providers.\n *\n * @abstract\n */\nclass WalletProvider {\n    /**\n     * Initializes the wallet provider.\n     */\n    constructor() {\n        // Wait for the next tick to ensure child class is initialized\n        Promise.resolve().then(() => {\n            this.trackInitialization();\n        });\n    }\n    /**\n     * Tracks the initialization of the wallet provider.\n     */\n    trackInitialization() {\n        try {\n            (0, analytics_1.sendAnalyticsEvent)({\n                name: \"agent_initialization\",\n                action: \"initialize_wallet_provider\",\n                component: \"wallet_provider\",\n                wallet_provider: this.getName(),\n                wallet_address: this.getAddress(),\n                network_id: this.getNetwork().networkId,\n                chain_id: this.getNetwork().chainId,\n                protocol_family: this.getNetwork().protocolFamily,\n            });\n        }\n        catch (error) {\n            console.warn(\"Failed to track wallet provider initialization:\", error);\n        }\n    }\n}\nexports.WalletProvider = WalletProvider;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L2Rpc3Qvd2FsbGV0LXByb3ZpZGVycy93YWxsZXRQcm92aWRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQkFBc0I7QUFDdEIsb0JBQW9CLG1CQUFPLENBQUMscUZBQWM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cnZpdmFsLWZ1bi8uL25vZGVfbW9kdWxlcy9AY29pbmJhc2UvYWdlbnRraXQvZGlzdC93YWxsZXQtcHJvdmlkZXJzL3dhbGxldFByb3ZpZGVyLmpzP2ZmZjUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLldhbGxldFByb3ZpZGVyID0gdm9pZCAwO1xuY29uc3QgYW5hbHl0aWNzXzEgPSByZXF1aXJlKFwiLi4vYW5hbHl0aWNzXCIpO1xuLyoqXG4gKiBXYWxsZXRQcm92aWRlciBpcyB0aGUgYWJzdHJhY3QgYmFzZSBjbGFzcyBmb3IgYWxsIHdhbGxldCBwcm92aWRlcnMuXG4gKlxuICogQGFic3RyYWN0XG4gKi9cbmNsYXNzIFdhbGxldFByb3ZpZGVyIHtcbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgd2FsbGV0IHByb3ZpZGVyLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvLyBXYWl0IGZvciB0aGUgbmV4dCB0aWNrIHRvIGVuc3VyZSBjaGlsZCBjbGFzcyBpcyBpbml0aWFsaXplZFxuICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMudHJhY2tJbml0aWFsaXphdGlvbigpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhY2tzIHRoZSBpbml0aWFsaXphdGlvbiBvZiB0aGUgd2FsbGV0IHByb3ZpZGVyLlxuICAgICAqL1xuICAgIHRyYWNrSW5pdGlhbGl6YXRpb24oKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAoMCwgYW5hbHl0aWNzXzEuc2VuZEFuYWx5dGljc0V2ZW50KSh7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJhZ2VudF9pbml0aWFsaXphdGlvblwiLFxuICAgICAgICAgICAgICAgIGFjdGlvbjogXCJpbml0aWFsaXplX3dhbGxldF9wcm92aWRlclwiLFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudDogXCJ3YWxsZXRfcHJvdmlkZXJcIixcbiAgICAgICAgICAgICAgICB3YWxsZXRfcHJvdmlkZXI6IHRoaXMuZ2V0TmFtZSgpLFxuICAgICAgICAgICAgICAgIHdhbGxldF9hZGRyZXNzOiB0aGlzLmdldEFkZHJlc3MoKSxcbiAgICAgICAgICAgICAgICBuZXR3b3JrX2lkOiB0aGlzLmdldE5ldHdvcmsoKS5uZXR3b3JrSWQsXG4gICAgICAgICAgICAgICAgY2hhaW5faWQ6IHRoaXMuZ2V0TmV0d29yaygpLmNoYWluSWQsXG4gICAgICAgICAgICAgICAgcHJvdG9jb2xfZmFtaWx5OiB0aGlzLmdldE5ldHdvcmsoKS5wcm90b2NvbEZhbWlseSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiRmFpbGVkIHRvIHRyYWNrIHdhbGxldCBwcm92aWRlciBpbml0aWFsaXphdGlvbjpcIiwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5XYWxsZXRQcm92aWRlciA9IFdhbGxldFByb3ZpZGVyO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/dist/wallet-providers/walletProvider.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/node_modules/base-x/src/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/node_modules/base-x/src/index.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\n// @ts-ignore\nvar _Buffer = (__webpack_require__(/*! safe-buffer */ \"(rsc)/./node_modules/safe-buffer/index.js\").Buffer)\nfunction base (ALPHABET) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  var BASE_MAP = new Uint8Array(256)\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i)\n    var xc = x.charCodeAt(0)\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i\n  }\n  var BASE = ALPHABET.length\n  var LEADER = ALPHABET.charAt(0)\n  var FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up\n  var iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up\n  function encode (source) {\n    if (Array.isArray(source) || source instanceof Uint8Array) { source = _Buffer.from(source) }\n    if (!_Buffer.isBuffer(source)) { throw new TypeError('Expected Buffer') }\n    if (source.length === 0) { return '' }\n        // Skip & count leading zeroes.\n    var zeroes = 0\n    var length = 0\n    var pbegin = 0\n    var pend = source.length\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++\n      zeroes++\n    }\n        // Allocate enough space in big-endian base58 representation.\n    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0\n    var b58 = new Uint8Array(size)\n        // Process the bytes.\n    while (pbegin !== pend) {\n      var carry = source[pbegin]\n            // Apply \"b58 = b58 * 256 + ch\".\n      var i = 0\n      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0\n        b58[it1] = (carry % BASE) >>> 0\n        carry = (carry / BASE) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      pbegin++\n    }\n        // Skip leading zeroes in base58 result.\n    var it2 = size - length\n    while (it2 !== size && b58[it2] === 0) {\n      it2++\n    }\n        // Translate the result into a string.\n    var str = LEADER.repeat(zeroes)\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]) }\n    return str\n  }\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return _Buffer.alloc(0) }\n    var psz = 0\n        // Skip and count leading '1's.\n    var zeroes = 0\n    var length = 0\n    while (source[psz] === LEADER) {\n      zeroes++\n      psz++\n    }\n        // Allocate enough space in big-endian base256 representation.\n    var size = (((source.length - psz) * FACTOR) + 1) >>> 0 // log(58) / log(256), rounded up.\n    var b256 = new Uint8Array(size)\n        // Process the characters.\n    while (psz < source.length) {\n            // Find code of next character\n      var charCode = source.charCodeAt(psz)\n            // Base map can not be indexed using char code\n      if (charCode > 255) { return }\n            // Decode character\n      var carry = BASE_MAP[charCode]\n            // Invalid character\n      if (carry === 255) { return }\n      var i = 0\n      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0\n        b256[it3] = (carry % 256) >>> 0\n        carry = (carry / 256) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      psz++\n    }\n        // Skip leading zeroes in b256.\n    var it4 = size - length\n    while (it4 !== size && b256[it4] === 0) {\n      it4++\n    }\n    var vch = _Buffer.allocUnsafe(zeroes + (size - it4))\n    vch.fill(0x00, 0, zeroes)\n    var j = zeroes\n    while (it4 !== size) {\n      vch[j++] = b256[it4++]\n    }\n    return vch\n  }\n  function decode (string) {\n    var buffer = decodeUnsafe(string)\n    if (buffer) { return buffer }\n    throw new Error('Non-base' + BASE + ' character')\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  }\n}\nmodule.exports = base\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L25vZGVfbW9kdWxlcy9iYXNlLXgvc3JjL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyw0RkFBNkI7QUFDM0M7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakUscUNBQXFDO0FBQ3JDLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDZDQUE2QztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWSxTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QywrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0EsK0JBQStCLDZDQUE2QztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3Vydml2YWwtZnVuLy4vbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9hZ2VudGtpdC9ub2RlX21vZHVsZXMvYmFzZS14L3NyYy9pbmRleC5qcz9iMDE3Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuLy8gYmFzZS14IGVuY29kaW5nIC8gZGVjb2Rpbmdcbi8vIENvcHlyaWdodCAoYykgMjAxOCBiYXNlLXggY29udHJpYnV0b3JzXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxOCBUaGUgQml0Y29pbiBDb3JlIGRldmVsb3BlcnMgKGJhc2U1OC5jcHApXG4vLyBEaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIHNvZnR3YXJlIGxpY2Vuc2UsIHNlZSB0aGUgYWNjb21wYW55aW5nXG4vLyBmaWxlIExJQ0VOU0Ugb3IgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHAuXG4vLyBAdHMtaWdub3JlXG52YXIgX0J1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG5mdW5jdGlvbiBiYXNlIChBTFBIQUJFVCkge1xuICBpZiAoQUxQSEFCRVQubGVuZ3RoID49IDI1NSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdBbHBoYWJldCB0b28gbG9uZycpIH1cbiAgdmFyIEJBU0VfTUFQID0gbmV3IFVpbnQ4QXJyYXkoMjU2KVxuICBmb3IgKHZhciBqID0gMDsgaiA8IEJBU0VfTUFQLmxlbmd0aDsgaisrKSB7XG4gICAgQkFTRV9NQVBbal0gPSAyNTVcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IEFMUEhBQkVULmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHggPSBBTFBIQUJFVC5jaGFyQXQoaSlcbiAgICB2YXIgeGMgPSB4LmNoYXJDb2RlQXQoMClcbiAgICBpZiAoQkFTRV9NQVBbeGNdICE9PSAyNTUpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcih4ICsgJyBpcyBhbWJpZ3VvdXMnKSB9XG4gICAgQkFTRV9NQVBbeGNdID0gaVxuICB9XG4gIHZhciBCQVNFID0gQUxQSEFCRVQubGVuZ3RoXG4gIHZhciBMRUFERVIgPSBBTFBIQUJFVC5jaGFyQXQoMClcbiAgdmFyIEZBQ1RPUiA9IE1hdGgubG9nKEJBU0UpIC8gTWF0aC5sb2coMjU2KSAvLyBsb2coQkFTRSkgLyBsb2coMjU2KSwgcm91bmRlZCB1cFxuICB2YXIgaUZBQ1RPUiA9IE1hdGgubG9nKDI1NikgLyBNYXRoLmxvZyhCQVNFKSAvLyBsb2coMjU2KSAvIGxvZyhCQVNFKSwgcm91bmRlZCB1cFxuICBmdW5jdGlvbiBlbmNvZGUgKHNvdXJjZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHNvdXJjZSkgfHwgc291cmNlIGluc3RhbmNlb2YgVWludDhBcnJheSkgeyBzb3VyY2UgPSBfQnVmZmVyLmZyb20oc291cmNlKSB9XG4gICAgaWYgKCFfQnVmZmVyLmlzQnVmZmVyKHNvdXJjZSkpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgQnVmZmVyJykgfVxuICAgIGlmIChzb3VyY2UubGVuZ3RoID09PSAwKSB7IHJldHVybiAnJyB9XG4gICAgICAgIC8vIFNraXAgJiBjb3VudCBsZWFkaW5nIHplcm9lcy5cbiAgICB2YXIgemVyb2VzID0gMFxuICAgIHZhciBsZW5ndGggPSAwXG4gICAgdmFyIHBiZWdpbiA9IDBcbiAgICB2YXIgcGVuZCA9IHNvdXJjZS5sZW5ndGhcbiAgICB3aGlsZSAocGJlZ2luICE9PSBwZW5kICYmIHNvdXJjZVtwYmVnaW5dID09PSAwKSB7XG4gICAgICBwYmVnaW4rK1xuICAgICAgemVyb2VzKytcbiAgICB9XG4gICAgICAgIC8vIEFsbG9jYXRlIGVub3VnaCBzcGFjZSBpbiBiaWctZW5kaWFuIGJhc2U1OCByZXByZXNlbnRhdGlvbi5cbiAgICB2YXIgc2l6ZSA9ICgocGVuZCAtIHBiZWdpbikgKiBpRkFDVE9SICsgMSkgPj4+IDBcbiAgICB2YXIgYjU4ID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSlcbiAgICAgICAgLy8gUHJvY2VzcyB0aGUgYnl0ZXMuXG4gICAgd2hpbGUgKHBiZWdpbiAhPT0gcGVuZCkge1xuICAgICAgdmFyIGNhcnJ5ID0gc291cmNlW3BiZWdpbl1cbiAgICAgICAgICAgIC8vIEFwcGx5IFwiYjU4ID0gYjU4ICogMjU2ICsgY2hcIi5cbiAgICAgIHZhciBpID0gMFxuICAgICAgZm9yICh2YXIgaXQxID0gc2l6ZSAtIDE7IChjYXJyeSAhPT0gMCB8fCBpIDwgbGVuZ3RoKSAmJiAoaXQxICE9PSAtMSk7IGl0MS0tLCBpKyspIHtcbiAgICAgICAgY2FycnkgKz0gKDI1NiAqIGI1OFtpdDFdKSA+Pj4gMFxuICAgICAgICBiNThbaXQxXSA9IChjYXJyeSAlIEJBU0UpID4+PiAwXG4gICAgICAgIGNhcnJ5ID0gKGNhcnJ5IC8gQkFTRSkgPj4+IDBcbiAgICAgIH1cbiAgICAgIGlmIChjYXJyeSAhPT0gMCkgeyB0aHJvdyBuZXcgRXJyb3IoJ05vbi16ZXJvIGNhcnJ5JykgfVxuICAgICAgbGVuZ3RoID0gaVxuICAgICAgcGJlZ2luKytcbiAgICB9XG4gICAgICAgIC8vIFNraXAgbGVhZGluZyB6ZXJvZXMgaW4gYmFzZTU4IHJlc3VsdC5cbiAgICB2YXIgaXQyID0gc2l6ZSAtIGxlbmd0aFxuICAgIHdoaWxlIChpdDIgIT09IHNpemUgJiYgYjU4W2l0Ml0gPT09IDApIHtcbiAgICAgIGl0MisrXG4gICAgfVxuICAgICAgICAvLyBUcmFuc2xhdGUgdGhlIHJlc3VsdCBpbnRvIGEgc3RyaW5nLlxuICAgIHZhciBzdHIgPSBMRUFERVIucmVwZWF0KHplcm9lcylcbiAgICBmb3IgKDsgaXQyIDwgc2l6ZTsgKytpdDIpIHsgc3RyICs9IEFMUEhBQkVULmNoYXJBdChiNThbaXQyXSkgfVxuICAgIHJldHVybiBzdHJcbiAgfVxuICBmdW5jdGlvbiBkZWNvZGVVbnNhZmUgKHNvdXJjZSkge1xuICAgIGlmICh0eXBlb2Ygc291cmNlICE9PSAnc3RyaW5nJykgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBTdHJpbmcnKSB9XG4gICAgaWYgKHNvdXJjZS5sZW5ndGggPT09IDApIHsgcmV0dXJuIF9CdWZmZXIuYWxsb2MoMCkgfVxuICAgIHZhciBwc3ogPSAwXG4gICAgICAgIC8vIFNraXAgYW5kIGNvdW50IGxlYWRpbmcgJzEncy5cbiAgICB2YXIgemVyb2VzID0gMFxuICAgIHZhciBsZW5ndGggPSAwXG4gICAgd2hpbGUgKHNvdXJjZVtwc3pdID09PSBMRUFERVIpIHtcbiAgICAgIHplcm9lcysrXG4gICAgICBwc3orK1xuICAgIH1cbiAgICAgICAgLy8gQWxsb2NhdGUgZW5vdWdoIHNwYWNlIGluIGJpZy1lbmRpYW4gYmFzZTI1NiByZXByZXNlbnRhdGlvbi5cbiAgICB2YXIgc2l6ZSA9ICgoKHNvdXJjZS5sZW5ndGggLSBwc3opICogRkFDVE9SKSArIDEpID4+PiAwIC8vIGxvZyg1OCkgLyBsb2coMjU2KSwgcm91bmRlZCB1cC5cbiAgICB2YXIgYjI1NiA9IG5ldyBVaW50OEFycmF5KHNpemUpXG4gICAgICAgIC8vIFByb2Nlc3MgdGhlIGNoYXJhY3RlcnMuXG4gICAgd2hpbGUgKHBzeiA8IHNvdXJjZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIEZpbmQgY29kZSBvZiBuZXh0IGNoYXJhY3RlclxuICAgICAgdmFyIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQocHN6KVxuICAgICAgICAgICAgLy8gQmFzZSBtYXAgY2FuIG5vdCBiZSBpbmRleGVkIHVzaW5nIGNoYXIgY29kZVxuICAgICAgaWYgKGNoYXJDb2RlID4gMjU1KSB7IHJldHVybiB9XG4gICAgICAgICAgICAvLyBEZWNvZGUgY2hhcmFjdGVyXG4gICAgICB2YXIgY2FycnkgPSBCQVNFX01BUFtjaGFyQ29kZV1cbiAgICAgICAgICAgIC8vIEludmFsaWQgY2hhcmFjdGVyXG4gICAgICBpZiAoY2FycnkgPT09IDI1NSkgeyByZXR1cm4gfVxuICAgICAgdmFyIGkgPSAwXG4gICAgICBmb3IgKHZhciBpdDMgPSBzaXplIC0gMTsgKGNhcnJ5ICE9PSAwIHx8IGkgPCBsZW5ndGgpICYmIChpdDMgIT09IC0xKTsgaXQzLS0sIGkrKykge1xuICAgICAgICBjYXJyeSArPSAoQkFTRSAqIGIyNTZbaXQzXSkgPj4+IDBcbiAgICAgICAgYjI1NltpdDNdID0gKGNhcnJ5ICUgMjU2KSA+Pj4gMFxuICAgICAgICBjYXJyeSA9IChjYXJyeSAvIDI1NikgPj4+IDBcbiAgICAgIH1cbiAgICAgIGlmIChjYXJyeSAhPT0gMCkgeyB0aHJvdyBuZXcgRXJyb3IoJ05vbi16ZXJvIGNhcnJ5JykgfVxuICAgICAgbGVuZ3RoID0gaVxuICAgICAgcHN6KytcbiAgICB9XG4gICAgICAgIC8vIFNraXAgbGVhZGluZyB6ZXJvZXMgaW4gYjI1Ni5cbiAgICB2YXIgaXQ0ID0gc2l6ZSAtIGxlbmd0aFxuICAgIHdoaWxlIChpdDQgIT09IHNpemUgJiYgYjI1NltpdDRdID09PSAwKSB7XG4gICAgICBpdDQrK1xuICAgIH1cbiAgICB2YXIgdmNoID0gX0J1ZmZlci5hbGxvY1Vuc2FmZSh6ZXJvZXMgKyAoc2l6ZSAtIGl0NCkpXG4gICAgdmNoLmZpbGwoMHgwMCwgMCwgemVyb2VzKVxuICAgIHZhciBqID0gemVyb2VzXG4gICAgd2hpbGUgKGl0NCAhPT0gc2l6ZSkge1xuICAgICAgdmNoW2orK10gPSBiMjU2W2l0NCsrXVxuICAgIH1cbiAgICByZXR1cm4gdmNoXG4gIH1cbiAgZnVuY3Rpb24gZGVjb2RlIChzdHJpbmcpIHtcbiAgICB2YXIgYnVmZmVyID0gZGVjb2RlVW5zYWZlKHN0cmluZylcbiAgICBpZiAoYnVmZmVyKSB7IHJldHVybiBidWZmZXIgfVxuICAgIHRocm93IG5ldyBFcnJvcignTm9uLWJhc2UnICsgQkFTRSArICcgY2hhcmFjdGVyJylcbiAgfVxuICByZXR1cm4ge1xuICAgIGVuY29kZTogZW5jb2RlLFxuICAgIGRlY29kZVVuc2FmZTogZGVjb2RlVW5zYWZlLFxuICAgIGRlY29kZTogZGVjb2RlXG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gYmFzZVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/node_modules/base-x/src/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/node_modules/bs58/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/node_modules/bs58/index.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var basex = __webpack_require__(/*! base-x */ \"(rsc)/./node_modules/@coinbase/agentkit/node_modules/base-x/src/index.js\")\nvar ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n\nmodule.exports = basex(ALPHABET)\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2FnZW50a2l0L25vZGVfbW9kdWxlcy9iczU4L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBLFlBQVksbUJBQU8sQ0FBQyx3RkFBUTtBQUM1Qjs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cnZpdmFsLWZ1bi8uL25vZGVfbW9kdWxlcy9AY29pbmJhc2UvYWdlbnRraXQvbm9kZV9tb2R1bGVzL2JzNTgvaW5kZXguanM/YWZlNiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYmFzZXggPSByZXF1aXJlKCdiYXNlLXgnKVxudmFyIEFMUEhBQkVUID0gJzEyMzQ1Njc4OUFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWmFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXonXG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZXgoQUxQSEFCRVQpXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/agentkit/node_modules/bs58/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/actions/sendUserOperation.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/actions/sendUserOperation.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.sendUserOperation = void 0;\nconst chain_1 = __webpack_require__(/*! ../types/chain */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/types/chain.js\");\nconst viem_1 = __webpack_require__(/*! viem */ \"(rsc)/./node_modules/viem/_cjs/index.js\");\nconst coinbase_1 = __webpack_require__(/*! ../coinbase/coinbase */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/coinbase.js\");\n/**\n * Sends a user operation to the network\n *\n * @example\n * ```ts\n * import { sendUserOperation } from \"@coinbase/coinbase-sdk\";\n * import { parseEther } from \"viem\";\n *\n * const result = await sendUserOperation(wallet, {\n *   calls: [\n *     {\n *       abi: erc20Abi,\n *       functionName: \"transfer\",\n *       args: [to, amount],\n *     },\n *     {\n *       to: \"0x1234567890123456789012345678901234567890\",\n *       data: \"0x\",\n *       value: parseEther(\"0.0000005\"),\n *     },\n *   ],\n *   chainId: 1,\n *   paymasterUrl: \"https://api.developer.coinbase.com/rpc/v1/base/someapikey\",\n * });\n * ```\n *\n * @param {SmartWallet} wallet - The smart wallet to send the user operation from\n * @param {SendUserOperationOptions<T>} options - The options for the user operation\n * @returns {Promise<SendUserOperationReturnType>} The result of the user operation\n */\nasync function sendUserOperation(wallet, options) {\n    const { calls, chainId, paymasterUrl } = options;\n    const network = chain_1.CHAIN_ID_TO_NETWORK_ID[chainId];\n    if (calls.length === 0) {\n        throw new Error(\"Calls array is empty\");\n    }\n    const encodedCalls = calls.map(call => {\n        const value = (call.value ?? BigInt(0)).toString();\n        if (\"abi\" in call && call.abi && \"functionName\" in call) {\n            return {\n                to: call.to,\n                data: (0, viem_1.encodeFunctionData)({\n                    abi: call.abi,\n                    functionName: call.functionName,\n                    args: call.args,\n                }),\n                value,\n            };\n        }\n        return {\n            to: call.to,\n            data: call.data ?? \"0x\",\n            value,\n        };\n    });\n    const createOpResponse = await coinbase_1.Coinbase.apiClients.smartWallet.createUserOperation(wallet.address, network, {\n        calls: encodedCalls,\n        paymaster_url: paymasterUrl,\n    });\n    const owner = wallet.owners[0];\n    const signature = await owner.sign({\n        hash: createOpResponse.data.user_op_hash,\n    });\n    const broadcastResponse = await coinbase_1.Coinbase.apiClients.smartWallet.broadcastUserOperation(wallet.address, createOpResponse.data.user_op_hash, {\n        signature,\n    });\n    return {\n        smartWalletAddress: wallet.address,\n        status: broadcastResponse.data.status,\n        userOpHash: createOpResponse.data.user_op_hash,\n    };\n}\nexports.sendUserOperation = sendUserOperation;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2FjdGlvbnMvc2VuZFVzZXJPcGVyYXRpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QseUJBQXlCO0FBQ3pCLGdCQUFnQixtQkFBTyxDQUFDLHVGQUFnQjtBQUN4QyxlQUFlLG1CQUFPLENBQUMscURBQU07QUFDN0IsbUJBQW1CLG1CQUFPLENBQUMsbUdBQXNCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9CQUFvQjtBQUNoQyxZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsV0FBVyw2QkFBNkI7QUFDeEMsYUFBYSxzQ0FBc0M7QUFDbkQ7QUFDQTtBQUNBLFlBQVksK0JBQStCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QiIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cnZpdmFsLWZ1bi8uL25vZGVfbW9kdWxlcy9AY29pbmJhc2UvY29pbmJhc2Utc2RrL2Rpc3QvYWN0aW9ucy9zZW5kVXNlck9wZXJhdGlvbi5qcz9lNjBmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zZW5kVXNlck9wZXJhdGlvbiA9IHZvaWQgMDtcbmNvbnN0IGNoYWluXzEgPSByZXF1aXJlKFwiLi4vdHlwZXMvY2hhaW5cIik7XG5jb25zdCB2aWVtXzEgPSByZXF1aXJlKFwidmllbVwiKTtcbmNvbnN0IGNvaW5iYXNlXzEgPSByZXF1aXJlKFwiLi4vY29pbmJhc2UvY29pbmJhc2VcIik7XG4vKipcbiAqIFNlbmRzIGEgdXNlciBvcGVyYXRpb24gdG8gdGhlIG5ldHdvcmtcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IHNlbmRVc2VyT3BlcmF0aW9uIH0gZnJvbSBcIkBjb2luYmFzZS9jb2luYmFzZS1zZGtcIjtcbiAqIGltcG9ydCB7IHBhcnNlRXRoZXIgfSBmcm9tIFwidmllbVwiO1xuICpcbiAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNlbmRVc2VyT3BlcmF0aW9uKHdhbGxldCwge1xuICogICBjYWxsczogW1xuICogICAgIHtcbiAqICAgICAgIGFiaTogZXJjMjBBYmksXG4gKiAgICAgICBmdW5jdGlvbk5hbWU6IFwidHJhbnNmZXJcIixcbiAqICAgICAgIGFyZ3M6IFt0bywgYW1vdW50XSxcbiAqICAgICB9LFxuICogICAgIHtcbiAqICAgICAgIHRvOiBcIjB4MTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MFwiLFxuICogICAgICAgZGF0YTogXCIweFwiLFxuICogICAgICAgdmFsdWU6IHBhcnNlRXRoZXIoXCIwLjAwMDAwMDVcIiksXG4gKiAgICAgfSxcbiAqICAgXSxcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgcGF5bWFzdGVyVXJsOiBcImh0dHBzOi8vYXBpLmRldmVsb3Blci5jb2luYmFzZS5jb20vcnBjL3YxL2Jhc2Uvc29tZWFwaWtleVwiLFxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge1NtYXJ0V2FsbGV0fSB3YWxsZXQgLSBUaGUgc21hcnQgd2FsbGV0IHRvIHNlbmQgdGhlIHVzZXIgb3BlcmF0aW9uIGZyb21cbiAqIEBwYXJhbSB7U2VuZFVzZXJPcGVyYXRpb25PcHRpb25zPFQ+fSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIHRoZSB1c2VyIG9wZXJhdGlvblxuICogQHJldHVybnMge1Byb21pc2U8U2VuZFVzZXJPcGVyYXRpb25SZXR1cm5UeXBlPn0gVGhlIHJlc3VsdCBvZiB0aGUgdXNlciBvcGVyYXRpb25cbiAqL1xuYXN5bmMgZnVuY3Rpb24gc2VuZFVzZXJPcGVyYXRpb24od2FsbGV0LCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBjYWxscywgY2hhaW5JZCwgcGF5bWFzdGVyVXJsIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IG5ldHdvcmsgPSBjaGFpbl8xLkNIQUlOX0lEX1RPX05FVFdPUktfSURbY2hhaW5JZF07XG4gICAgaWYgKGNhbGxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYWxscyBhcnJheSBpcyBlbXB0eVwiKTtcbiAgICB9XG4gICAgY29uc3QgZW5jb2RlZENhbGxzID0gY2FsbHMubWFwKGNhbGwgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IChjYWxsLnZhbHVlID8/IEJpZ0ludCgwKSkudG9TdHJpbmcoKTtcbiAgICAgICAgaWYgKFwiYWJpXCIgaW4gY2FsbCAmJiBjYWxsLmFiaSAmJiBcImZ1bmN0aW9uTmFtZVwiIGluIGNhbGwpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdG86IGNhbGwudG8sXG4gICAgICAgICAgICAgICAgZGF0YTogKDAsIHZpZW1fMS5lbmNvZGVGdW5jdGlvbkRhdGEpKHtcbiAgICAgICAgICAgICAgICAgICAgYWJpOiBjYWxsLmFiaSxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiBjYWxsLmZ1bmN0aW9uTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgYXJnczogY2FsbC5hcmdzLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG86IGNhbGwudG8sXG4gICAgICAgICAgICBkYXRhOiBjYWxsLmRhdGEgPz8gXCIweFwiLFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgY29uc3QgY3JlYXRlT3BSZXNwb25zZSA9IGF3YWl0IGNvaW5iYXNlXzEuQ29pbmJhc2UuYXBpQ2xpZW50cy5zbWFydFdhbGxldC5jcmVhdGVVc2VyT3BlcmF0aW9uKHdhbGxldC5hZGRyZXNzLCBuZXR3b3JrLCB7XG4gICAgICAgIGNhbGxzOiBlbmNvZGVkQ2FsbHMsXG4gICAgICAgIHBheW1hc3Rlcl91cmw6IHBheW1hc3RlclVybCxcbiAgICB9KTtcbiAgICBjb25zdCBvd25lciA9IHdhbGxldC5vd25lcnNbMF07XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgb3duZXIuc2lnbih7XG4gICAgICAgIGhhc2g6IGNyZWF0ZU9wUmVzcG9uc2UuZGF0YS51c2VyX29wX2hhc2gsXG4gICAgfSk7XG4gICAgY29uc3QgYnJvYWRjYXN0UmVzcG9uc2UgPSBhd2FpdCBjb2luYmFzZV8xLkNvaW5iYXNlLmFwaUNsaWVudHMuc21hcnRXYWxsZXQuYnJvYWRjYXN0VXNlck9wZXJhdGlvbih3YWxsZXQuYWRkcmVzcywgY3JlYXRlT3BSZXNwb25zZS5kYXRhLnVzZXJfb3BfaGFzaCwge1xuICAgICAgICBzaWduYXR1cmUsXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc21hcnRXYWxsZXRBZGRyZXNzOiB3YWxsZXQuYWRkcmVzcyxcbiAgICAgICAgc3RhdHVzOiBicm9hZGNhc3RSZXNwb25zZS5kYXRhLnN0YXR1cyxcbiAgICAgICAgdXNlck9wSGFzaDogY3JlYXRlT3BSZXNwb25zZS5kYXRhLnVzZXJfb3BfaGFzaCxcbiAgICB9O1xufVxuZXhwb3J0cy5zZW5kVXNlck9wZXJhdGlvbiA9IHNlbmRVc2VyT3BlcmF0aW9uO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/actions/sendUserOperation.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/actions/waitForUserOperation.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/actions/waitForUserOperation.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.waitForUserOperation = void 0;\nconst coinbase_1 = __webpack_require__(/*! ../coinbase/coinbase */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/coinbase.js\");\nconst wait_1 = __webpack_require__(/*! ../utils/wait */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/utils/wait.js\");\nconst client_1 = __webpack_require__(/*! ../client */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/client/index.js\");\n/**\n * Waits for a user operation to complete or fail\n *\n * @example\n * ```ts\n * import { waitForUserOperation } from \"@coinbase/coinbase-sdk\";\n *\n * const result = await waitForUserOperation({\n *   id: \"123\",\n *   smartWalletAddress: \"0x1234567890123456789012345678901234567890\",\n *   waitOptions: {\n *     timeoutSeconds: 30,\n *   },\n * });\n * ```\n *\n * @param {WaitForUserOperationOptions} options - The options for the wait operation\n * @returns {Promise<WaitForUserOperationReturnType>} The result of the user operation\n */\nasync function waitForUserOperation(options) {\n    const { userOpHash, smartWalletAddress } = options;\n    const reload = async () => {\n        const response = await coinbase_1.Coinbase.apiClients.smartWallet.getUserOperation(smartWalletAddress, userOpHash);\n        return response.data;\n    };\n    const transform = (operation) => {\n        if (operation.status === client_1.UserOperationStatusEnum.Failed) {\n            return {\n                smartWalletAddress: smartWalletAddress,\n                status: client_1.UserOperationStatusEnum.Failed,\n                userOpHash: operation.user_op_hash,\n            };\n        }\n        else if (operation.status === client_1.UserOperationStatusEnum.Complete) {\n            return {\n                smartWalletAddress: smartWalletAddress,\n                transactionHash: operation.transaction_hash,\n                status: client_1.UserOperationStatusEnum.Complete,\n                userOpHash: operation.user_op_hash,\n            };\n        }\n        else {\n            throw new Error(\"User operation is not terminal\");\n        }\n    };\n    const waitOptions = options.waitOptions || {\n        timeoutSeconds: 30,\n    };\n    return await (0, wait_1.wait)(reload, isTerminal, transform, waitOptions);\n}\nexports.waitForUserOperation = waitForUserOperation;\nconst isTerminal = (operation) => {\n    return (operation.status === client_1.UserOperationStatusEnum.Complete ||\n        operation.status === client_1.UserOperationStatusEnum.Failed);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2FjdGlvbnMvd2FpdEZvclVzZXJPcGVyYXRpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNEJBQTRCO0FBQzVCLG1CQUFtQixtQkFBTyxDQUFDLG1HQUFzQjtBQUNqRCxlQUFlLG1CQUFPLENBQUMscUZBQWU7QUFDdEMsaUJBQWlCLG1CQUFPLENBQUMsbUZBQVc7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksdUJBQXVCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixJQUFJO0FBQ0o7QUFDQTtBQUNBLFdBQVcsNkJBQTZCO0FBQ3hDLGFBQWEseUNBQXlDO0FBQ3REO0FBQ0E7QUFDQSxZQUFZLGlDQUFpQztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3Vydml2YWwtZnVuLy4vbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9jb2luYmFzZS1zZGsvZGlzdC9hY3Rpb25zL3dhaXRGb3JVc2VyT3BlcmF0aW9uLmpzP2NiY2YiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLndhaXRGb3JVc2VyT3BlcmF0aW9uID0gdm9pZCAwO1xuY29uc3QgY29pbmJhc2VfMSA9IHJlcXVpcmUoXCIuLi9jb2luYmFzZS9jb2luYmFzZVwiKTtcbmNvbnN0IHdhaXRfMSA9IHJlcXVpcmUoXCIuLi91dGlscy93YWl0XCIpO1xuY29uc3QgY2xpZW50XzEgPSByZXF1aXJlKFwiLi4vY2xpZW50XCIpO1xuLyoqXG4gKiBXYWl0cyBmb3IgYSB1c2VyIG9wZXJhdGlvbiB0byBjb21wbGV0ZSBvciBmYWlsXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyB3YWl0Rm9yVXNlck9wZXJhdGlvbiB9IGZyb20gXCJAY29pbmJhc2UvY29pbmJhc2Utc2RrXCI7XG4gKlxuICogY29uc3QgcmVzdWx0ID0gYXdhaXQgd2FpdEZvclVzZXJPcGVyYXRpb24oe1xuICogICBpZDogXCIxMjNcIixcbiAqICAgc21hcnRXYWxsZXRBZGRyZXNzOiBcIjB4MTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MFwiLFxuICogICB3YWl0T3B0aW9uczoge1xuICogICAgIHRpbWVvdXRTZWNvbmRzOiAzMCxcbiAqICAgfSxcbiAqIH0pO1xuICogYGBgXG4gKlxuICogQHBhcmFtIHtXYWl0Rm9yVXNlck9wZXJhdGlvbk9wdGlvbnN9IG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBmb3IgdGhlIHdhaXQgb3BlcmF0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxXYWl0Rm9yVXNlck9wZXJhdGlvblJldHVyblR5cGU+fSBUaGUgcmVzdWx0IG9mIHRoZSB1c2VyIG9wZXJhdGlvblxuICovXG5hc3luYyBmdW5jdGlvbiB3YWl0Rm9yVXNlck9wZXJhdGlvbihvcHRpb25zKSB7XG4gICAgY29uc3QgeyB1c2VyT3BIYXNoLCBzbWFydFdhbGxldEFkZHJlc3MgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgcmVsb2FkID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNvaW5iYXNlXzEuQ29pbmJhc2UuYXBpQ2xpZW50cy5zbWFydFdhbGxldC5nZXRVc2VyT3BlcmF0aW9uKHNtYXJ0V2FsbGV0QWRkcmVzcywgdXNlck9wSGFzaCk7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH07XG4gICAgY29uc3QgdHJhbnNmb3JtID0gKG9wZXJhdGlvbikgPT4ge1xuICAgICAgICBpZiAob3BlcmF0aW9uLnN0YXR1cyA9PT0gY2xpZW50XzEuVXNlck9wZXJhdGlvblN0YXR1c0VudW0uRmFpbGVkKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHNtYXJ0V2FsbGV0QWRkcmVzczogc21hcnRXYWxsZXRBZGRyZXNzLFxuICAgICAgICAgICAgICAgIHN0YXR1czogY2xpZW50XzEuVXNlck9wZXJhdGlvblN0YXR1c0VudW0uRmFpbGVkLFxuICAgICAgICAgICAgICAgIHVzZXJPcEhhc2g6IG9wZXJhdGlvbi51c2VyX29wX2hhc2gsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wZXJhdGlvbi5zdGF0dXMgPT09IGNsaWVudF8xLlVzZXJPcGVyYXRpb25TdGF0dXNFbnVtLkNvbXBsZXRlKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHNtYXJ0V2FsbGV0QWRkcmVzczogc21hcnRXYWxsZXRBZGRyZXNzLFxuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uSGFzaDogb3BlcmF0aW9uLnRyYW5zYWN0aW9uX2hhc2gsXG4gICAgICAgICAgICAgICAgc3RhdHVzOiBjbGllbnRfMS5Vc2VyT3BlcmF0aW9uU3RhdHVzRW51bS5Db21wbGV0ZSxcbiAgICAgICAgICAgICAgICB1c2VyT3BIYXNoOiBvcGVyYXRpb24udXNlcl9vcF9oYXNoLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVzZXIgb3BlcmF0aW9uIGlzIG5vdCB0ZXJtaW5hbFwiKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgd2FpdE9wdGlvbnMgPSBvcHRpb25zLndhaXRPcHRpb25zIHx8IHtcbiAgICAgICAgdGltZW91dFNlY29uZHM6IDMwLFxuICAgIH07XG4gICAgcmV0dXJuIGF3YWl0ICgwLCB3YWl0XzEud2FpdCkocmVsb2FkLCBpc1Rlcm1pbmFsLCB0cmFuc2Zvcm0sIHdhaXRPcHRpb25zKTtcbn1cbmV4cG9ydHMud2FpdEZvclVzZXJPcGVyYXRpb24gPSB3YWl0Rm9yVXNlck9wZXJhdGlvbjtcbmNvbnN0IGlzVGVybWluYWwgPSAob3BlcmF0aW9uKSA9PiB7XG4gICAgcmV0dXJuIChvcGVyYXRpb24uc3RhdHVzID09PSBjbGllbnRfMS5Vc2VyT3BlcmF0aW9uU3RhdHVzRW51bS5Db21wbGV0ZSB8fFxuICAgICAgICBvcGVyYXRpb24uc3RhdHVzID09PSBjbGllbnRfMS5Vc2VyT3BlcmF0aW9uU3RhdHVzRW51bS5GYWlsZWQpO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/actions/waitForUserOperation.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/client/api.js":
/*!****************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/client/api.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Coinbase Platform API\n * This is the OpenAPI 3.0 specification for the Coinbase Platform APIs, used in conjunction with the Coinbase Platform SDKs.\n *\n * The version of the OpenAPI document: 0.0.1-alpha\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MPCWalletStakeApi = exports.MPCWalletStakeApiFactory = exports.MPCWalletStakeApiFp = exports.MPCWalletStakeApiAxiosParamCreator = exports.FundApi = exports.FundApiFactory = exports.FundApiFp = exports.FundApiAxiosParamCreator = exports.ExternalAddressesApi = exports.ExternalAddressesApiFactory = exports.ExternalAddressesApiFp = exports.ExternalAddressesApiAxiosParamCreator = exports.ContractInvocationsApi = exports.ContractInvocationsApiFactory = exports.ContractInvocationsApiFp = exports.ContractInvocationsApiAxiosParamCreator = exports.ContractEventsApi = exports.ContractEventsApiFactory = exports.ContractEventsApiFp = exports.ContractEventsApiAxiosParamCreator = exports.BalanceHistoryApi = exports.BalanceHistoryApiFactory = exports.BalanceHistoryApiFp = exports.BalanceHistoryApiAxiosParamCreator = exports.AssetsApi = exports.AssetsApiFactory = exports.AssetsApiFp = exports.AssetsApiAxiosParamCreator = exports.AddressesApi = exports.AddressesApiFactory = exports.AddressesApiFp = exports.AddressesApiAxiosParamCreator = exports.WebhookStatus = exports.WebhookEventType = exports.WalletServerSignerStatusEnum = exports.ValidatorStatus = exports.UserOperationStatusEnum = exports.TransactionType = exports.TransactionStatusEnum = exports.TokenTransferType = exports.StakingRewardFormat = exports.StakingRewardStateEnum = exports.StakingOperationStatusEnum = exports.SponsoredSendStatusEnum = exports.SolidityValueTypeEnum = exports.SmartContractType = exports.PayloadSignatureStatusEnum = exports.NetworkIdentifier = exports.NetworkProtocolFamilyEnum = exports.FundOperationStatusEnum = void 0;\nexports.WebhooksApiAxiosParamCreator = exports.WalletsApi = exports.WalletsApiFactory = exports.WalletsApiFp = exports.WalletsApiAxiosParamCreator = exports.UsersApi = exports.UsersApiFactory = exports.UsersApiFp = exports.UsersApiAxiosParamCreator = exports.TransfersApi = exports.TransfersApiFactory = exports.TransfersApiFp = exports.TransfersApiAxiosParamCreator = exports.TransactionHistoryApi = exports.TransactionHistoryApiFactory = exports.TransactionHistoryApiFp = exports.TransactionHistoryApiAxiosParamCreator = exports.TradesApi = exports.TradesApiFactory = exports.TradesApiFp = exports.TradesApiAxiosParamCreator = exports.StakeApi = exports.StakeApiFactory = exports.StakeApiFp = exports.StakeApiAxiosParamCreator = exports.SmartWalletsApi = exports.SmartWalletsApiFactory = exports.SmartWalletsApiFp = exports.SmartWalletsApiAxiosParamCreator = exports.SmartContractsApi = exports.SmartContractsApiFactory = exports.SmartContractsApiFp = exports.SmartContractsApiAxiosParamCreator = exports.ServerSignersApi = exports.ServerSignersApiFactory = exports.ServerSignersApiFp = exports.ServerSignersApiAxiosParamCreator = exports.ReputationApi = exports.ReputationApiFactory = exports.ReputationApiFp = exports.ReputationApiAxiosParamCreator = exports.ResolveIdentityByAddressRolesEnum = exports.OnchainIdentityApi = exports.OnchainIdentityApiFactory = exports.OnchainIdentityApiFp = exports.OnchainIdentityApiAxiosParamCreator = exports.NetworksApi = exports.NetworksApiFactory = exports.NetworksApiFp = exports.NetworksApiAxiosParamCreator = void 0;\nexports.WebhooksApi = exports.WebhooksApiFactory = exports.WebhooksApiFp = void 0;\nconst axios_1 = __importDefault(__webpack_require__(/*! axios */ \"(rsc)/./node_modules/axios/dist/node/axios.cjs\"));\n// Some imports not used depending on template conditions\n// @ts-ignore\nconst common_1 = __webpack_require__(/*! ./common */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/client/common.js\");\n// @ts-ignore\nconst base_1 = __webpack_require__(/*! ./base */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/client/base.js\");\nexports.FundOperationStatusEnum = {\n    Pending: 'pending',\n    Complete: 'complete',\n    Failed: 'failed'\n};\nexports.NetworkProtocolFamilyEnum = {\n    Evm: 'evm',\n    Solana: 'solana'\n};\n/**\n * The ID of the blockchain network. This is unique across all networks, and takes the form of `<blockchain>-<network>`.\n * @export\n * @enum {string}\n */\nexports.NetworkIdentifier = {\n    BaseSepolia: 'base-sepolia',\n    BaseMainnet: 'base-mainnet',\n    EthereumHolesky: 'ethereum-holesky',\n    EthereumSepolia: 'ethereum-sepolia',\n    EthereumMainnet: 'ethereum-mainnet',\n    PolygonMainnet: 'polygon-mainnet',\n    SolanaDevnet: 'solana-devnet',\n    SolanaMainnet: 'solana-mainnet',\n    ArbitrumMainnet: 'arbitrum-mainnet',\n    ArbitrumSepolia: 'arbitrum-sepolia',\n    BitcoinMainnet: 'bitcoin-mainnet',\n    NearTestnet: 'near-testnet',\n    NearMainnet: 'near-mainnet'\n};\nexports.PayloadSignatureStatusEnum = {\n    Pending: 'pending',\n    Signed: 'signed',\n    Failed: 'failed'\n};\n/**\n * The type of the smart contract.\n * @export\n * @enum {string}\n */\nexports.SmartContractType = {\n    Erc20: 'erc20',\n    Erc721: 'erc721',\n    Erc1155: 'erc1155',\n    Custom: 'custom'\n};\nexports.SolidityValueTypeEnum = {\n    Uint8: 'uint8',\n    Uint16: 'uint16',\n    Uint32: 'uint32',\n    Uint64: 'uint64',\n    Uint128: 'uint128',\n    Uint160: 'uint160',\n    Uint256: 'uint256',\n    Int8: 'int8',\n    Int16: 'int16',\n    Int24: 'int24',\n    Int32: 'int32',\n    Int56: 'int56',\n    Int64: 'int64',\n    Int128: 'int128',\n    Int256: 'int256',\n    Address: 'address',\n    Bool: 'bool',\n    String: 'string',\n    Bytes: 'bytes',\n    Bytes1: 'bytes1',\n    Bytes2: 'bytes2',\n    Bytes3: 'bytes3',\n    Bytes4: 'bytes4',\n    Bytes5: 'bytes5',\n    Bytes6: 'bytes6',\n    Bytes7: 'bytes7',\n    Bytes8: 'bytes8',\n    Bytes9: 'bytes9',\n    Bytes10: 'bytes10',\n    Bytes11: 'bytes11',\n    Bytes12: 'bytes12',\n    Bytes13: 'bytes13',\n    Bytes14: 'bytes14',\n    Bytes15: 'bytes15',\n    Bytes16: 'bytes16',\n    Bytes17: 'bytes17',\n    Bytes18: 'bytes18',\n    Bytes19: 'bytes19',\n    Bytes20: 'bytes20',\n    Bytes21: 'bytes21',\n    Bytes22: 'bytes22',\n    Bytes23: 'bytes23',\n    Bytes24: 'bytes24',\n    Bytes25: 'bytes25',\n    Bytes26: 'bytes26',\n    Bytes27: 'bytes27',\n    Bytes28: 'bytes28',\n    Bytes29: 'bytes29',\n    Bytes30: 'bytes30',\n    Bytes31: 'bytes31',\n    Bytes32: 'bytes32',\n    Array: 'array',\n    Tuple: 'tuple'\n};\nexports.SponsoredSendStatusEnum = {\n    Pending: 'pending',\n    Signed: 'signed',\n    Submitted: 'submitted',\n    Complete: 'complete',\n    Failed: 'failed'\n};\nexports.StakingOperationStatusEnum = {\n    Initialized: 'initialized',\n    Complete: 'complete',\n    Failed: 'failed',\n    Unspecified: 'unspecified'\n};\nexports.StakingRewardStateEnum = {\n    Pending: 'pending',\n    Distributed: 'distributed'\n};\n/**\n * The format in which the rewards are to be fetched i.e native or in equivalent USD\n * @export\n * @enum {string}\n */\nexports.StakingRewardFormat = {\n    Usd: 'usd',\n    Native: 'native'\n};\n/**\n * The type of the token transfer.\n * @export\n * @enum {string}\n */\nexports.TokenTransferType = {\n    Erc20: 'erc20',\n    Erc721: 'erc721',\n    Erc1155: 'erc1155',\n    Unknown: 'unknown'\n};\nexports.TransactionStatusEnum = {\n    Pending: 'pending',\n    Signed: 'signed',\n    Broadcast: 'broadcast',\n    Complete: 'complete',\n    Failed: 'failed',\n    Unspecified: 'unspecified'\n};\n/**\n *\n * @export\n * @enum {string}\n */\nexports.TransactionType = {\n    Transfer: 'transfer'\n};\nexports.UserOperationStatusEnum = {\n    Pending: 'pending',\n    Signed: 'signed',\n    Broadcast: 'broadcast',\n    Complete: 'complete',\n    Failed: 'failed'\n};\n/**\n * The status of the validator.\n * @export\n * @enum {string}\n */\nexports.ValidatorStatus = {\n    Unknown: 'unknown',\n    Provisioning: 'provisioning',\n    Provisioned: 'provisioned',\n    Deposited: 'deposited',\n    PendingActivation: 'pending_activation',\n    Active: 'active',\n    Exiting: 'exiting',\n    Exited: 'exited',\n    WithdrawalAvailable: 'withdrawal_available',\n    WithdrawalComplete: 'withdrawal_complete',\n    ActiveSlashed: 'active_slashed',\n    ExitedSlashed: 'exited_slashed',\n    Reaped: 'reaped'\n};\nexports.WalletServerSignerStatusEnum = {\n    PendingSeedCreation: 'pending_seed_creation',\n    ActiveSeed: 'active_seed'\n};\n/**\n *\n * @export\n * @enum {string}\n */\nexports.WebhookEventType = {\n    Unspecified: 'unspecified',\n    Erc20Transfer: 'erc20_transfer',\n    Erc721Transfer: 'erc721_transfer',\n    WalletActivity: 'wallet_activity',\n    SmartContractEventActivity: 'smart_contract_event_activity'\n};\n/**\n * The status of the webhook.\n * @export\n * @enum {string}\n */\nexports.WebhookStatus = {\n    Active: 'active',\n    Inactive: 'inactive'\n};\n/**\n * AddressesApi - axios parameter creator\n * @export\n */\nconst AddressesApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Create a new address scoped to the wallet.\n         * @summary Create a new address\n         * @param {string} walletId The ID of the wallet to create the address in.\n         * @param {CreateAddressRequest} [createAddressRequest]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createAddress: async (walletId, createAddressRequest, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('createAddress', 'walletId', walletId);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createAddressRequest, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Create a new payload signature with an address.\n         * @summary Create a new payload signature.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address of the address to sign the payload with.\n         * @param {CreatePayloadSignatureRequest} [createPayloadSignatureRequest]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createPayloadSignature: async (walletId, addressId, createPayloadSignatureRequest, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('createPayloadSignature', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('createPayloadSignature', 'addressId', addressId);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/payload_signatures`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createPayloadSignatureRequest, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Get address\n         * @summary Get address by onchain address\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address of the address that is being fetched.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getAddress: async (walletId, addressId, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('getAddress', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('getAddress', 'addressId', addressId);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Get address balance\n         * @summary Get address balance for asset\n         * @param {string} walletId The ID of the wallet to fetch the balance for\n         * @param {string} addressId The onchain address of the address that is being fetched.\n         * @param {string} assetId The symbol of the asset to fetch the balance for\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getAddressBalance: async (walletId, addressId, assetId, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('getAddressBalance', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('getAddressBalance', 'addressId', addressId);\n            // verify required parameter 'assetId' is not null or undefined\n            (0, common_1.assertParamExists)('getAddressBalance', 'assetId', assetId);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/balances/{asset_id}`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)))\n                .replace(`{${\"asset_id\"}}`, encodeURIComponent(String(assetId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Get payload signature.\n         * @summary Get payload signature.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address of the address that signed the payload.\n         * @param {string} payloadSignatureId The ID of the payload signature to fetch.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getPayloadSignature: async (walletId, addressId, payloadSignatureId, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('getPayloadSignature', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('getPayloadSignature', 'addressId', addressId);\n            // verify required parameter 'payloadSignatureId' is not null or undefined\n            (0, common_1.assertParamExists)('getPayloadSignature', 'payloadSignatureId', payloadSignatureId);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/payload_signatures/{payload_signature_id}`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)))\n                .replace(`{${\"payload_signature_id\"}}`, encodeURIComponent(String(payloadSignatureId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Get address balances\n         * @summary Get all balances for address\n         * @param {string} walletId The ID of the wallet to fetch the balances for\n         * @param {string} addressId The onchain address of the address that is being fetched.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listAddressBalances: async (walletId, addressId, page, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('listAddressBalances', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('listAddressBalances', 'addressId', addressId);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/balances`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            if (page !== undefined) {\n                localVarQueryParameter['page'] = page;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * List addresses in the wallet.\n         * @summary List addresses in a wallet.\n         * @param {string} walletId The ID of the wallet whose addresses to fetch\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listAddresses: async (walletId, limit, page, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('listAddresses', 'walletId', walletId);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (page !== undefined) {\n                localVarQueryParameter['page'] = page;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * List payload signatures for an address.\n         * @summary List payload signatures for an address.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address of the address whose payload signatures to fetch.\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listPayloadSignatures: async (walletId, addressId, limit, page, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('listPayloadSignatures', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('listPayloadSignatures', 'addressId', addressId);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/payload_signatures`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (page !== undefined) {\n                localVarQueryParameter['page'] = page;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Request faucet funds to be sent to onchain address.\n         * @summary Request faucet funds for onchain address.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address of the address that is being fetched.\n         * @param {string} [assetId] The ID of the asset to transfer from the faucet.\n         * @param {*} [options] Override http request option.\n         * @deprecated\n         * @throws {RequiredError}\n         */\n        requestFaucetFunds: async (walletId, addressId, assetId, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('requestFaucetFunds', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('requestFaucetFunds', 'addressId', addressId);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/faucet`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            if (assetId !== undefined) {\n                localVarQueryParameter['asset_id'] = assetId;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.AddressesApiAxiosParamCreator = AddressesApiAxiosParamCreator;\n/**\n * AddressesApi - functional programming interface\n * @export\n */\nconst AddressesApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.AddressesApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * Create a new address scoped to the wallet.\n         * @summary Create a new address\n         * @param {string} walletId The ID of the wallet to create the address in.\n         * @param {CreateAddressRequest} [createAddressRequest]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async createAddress(walletId, createAddressRequest, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.createAddress(walletId, createAddressRequest, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['AddressesApi.createAddress']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Create a new payload signature with an address.\n         * @summary Create a new payload signature.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address of the address to sign the payload with.\n         * @param {CreatePayloadSignatureRequest} [createPayloadSignatureRequest]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async createPayloadSignature(walletId, addressId, createPayloadSignatureRequest, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.createPayloadSignature(walletId, addressId, createPayloadSignatureRequest, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['AddressesApi.createPayloadSignature']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Get address\n         * @summary Get address by onchain address\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address of the address that is being fetched.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async getAddress(walletId, addressId, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getAddress(walletId, addressId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['AddressesApi.getAddress']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Get address balance\n         * @summary Get address balance for asset\n         * @param {string} walletId The ID of the wallet to fetch the balance for\n         * @param {string} addressId The onchain address of the address that is being fetched.\n         * @param {string} assetId The symbol of the asset to fetch the balance for\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async getAddressBalance(walletId, addressId, assetId, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getAddressBalance(walletId, addressId, assetId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['AddressesApi.getAddressBalance']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Get payload signature.\n         * @summary Get payload signature.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address of the address that signed the payload.\n         * @param {string} payloadSignatureId The ID of the payload signature to fetch.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async getPayloadSignature(walletId, addressId, payloadSignatureId, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getPayloadSignature(walletId, addressId, payloadSignatureId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['AddressesApi.getPayloadSignature']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Get address balances\n         * @summary Get all balances for address\n         * @param {string} walletId The ID of the wallet to fetch the balances for\n         * @param {string} addressId The onchain address of the address that is being fetched.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async listAddressBalances(walletId, addressId, page, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.listAddressBalances(walletId, addressId, page, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['AddressesApi.listAddressBalances']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * List addresses in the wallet.\n         * @summary List addresses in a wallet.\n         * @param {string} walletId The ID of the wallet whose addresses to fetch\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async listAddresses(walletId, limit, page, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.listAddresses(walletId, limit, page, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['AddressesApi.listAddresses']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * List payload signatures for an address.\n         * @summary List payload signatures for an address.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address of the address whose payload signatures to fetch.\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async listPayloadSignatures(walletId, addressId, limit, page, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.listPayloadSignatures(walletId, addressId, limit, page, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['AddressesApi.listPayloadSignatures']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Request faucet funds to be sent to onchain address.\n         * @summary Request faucet funds for onchain address.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address of the address that is being fetched.\n         * @param {string} [assetId] The ID of the asset to transfer from the faucet.\n         * @param {*} [options] Override http request option.\n         * @deprecated\n         * @throws {RequiredError}\n         */\n        async requestFaucetFunds(walletId, addressId, assetId, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.requestFaucetFunds(walletId, addressId, assetId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['AddressesApi.requestFaucetFunds']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.AddressesApiFp = AddressesApiFp;\n/**\n * AddressesApi - factory interface\n * @export\n */\nconst AddressesApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.AddressesApiFp)(configuration);\n    return {\n        /**\n         * Create a new address scoped to the wallet.\n         * @summary Create a new address\n         * @param {string} walletId The ID of the wallet to create the address in.\n         * @param {CreateAddressRequest} [createAddressRequest]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createAddress(walletId, createAddressRequest, options) {\n            return localVarFp.createAddress(walletId, createAddressRequest, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Create a new payload signature with an address.\n         * @summary Create a new payload signature.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address of the address to sign the payload with.\n         * @param {CreatePayloadSignatureRequest} [createPayloadSignatureRequest]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createPayloadSignature(walletId, addressId, createPayloadSignatureRequest, options) {\n            return localVarFp.createPayloadSignature(walletId, addressId, createPayloadSignatureRequest, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Get address\n         * @summary Get address by onchain address\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address of the address that is being fetched.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getAddress(walletId, addressId, options) {\n            return localVarFp.getAddress(walletId, addressId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Get address balance\n         * @summary Get address balance for asset\n         * @param {string} walletId The ID of the wallet to fetch the balance for\n         * @param {string} addressId The onchain address of the address that is being fetched.\n         * @param {string} assetId The symbol of the asset to fetch the balance for\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getAddressBalance(walletId, addressId, assetId, options) {\n            return localVarFp.getAddressBalance(walletId, addressId, assetId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Get payload signature.\n         * @summary Get payload signature.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address of the address that signed the payload.\n         * @param {string} payloadSignatureId The ID of the payload signature to fetch.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getPayloadSignature(walletId, addressId, payloadSignatureId, options) {\n            return localVarFp.getPayloadSignature(walletId, addressId, payloadSignatureId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Get address balances\n         * @summary Get all balances for address\n         * @param {string} walletId The ID of the wallet to fetch the balances for\n         * @param {string} addressId The onchain address of the address that is being fetched.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listAddressBalances(walletId, addressId, page, options) {\n            return localVarFp.listAddressBalances(walletId, addressId, page, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * List addresses in the wallet.\n         * @summary List addresses in a wallet.\n         * @param {string} walletId The ID of the wallet whose addresses to fetch\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listAddresses(walletId, limit, page, options) {\n            return localVarFp.listAddresses(walletId, limit, page, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * List payload signatures for an address.\n         * @summary List payload signatures for an address.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address of the address whose payload signatures to fetch.\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listPayloadSignatures(walletId, addressId, limit, page, options) {\n            return localVarFp.listPayloadSignatures(walletId, addressId, limit, page, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Request faucet funds to be sent to onchain address.\n         * @summary Request faucet funds for onchain address.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address of the address that is being fetched.\n         * @param {string} [assetId] The ID of the asset to transfer from the faucet.\n         * @param {*} [options] Override http request option.\n         * @deprecated\n         * @throws {RequiredError}\n         */\n        requestFaucetFunds(walletId, addressId, assetId, options) {\n            return localVarFp.requestFaucetFunds(walletId, addressId, assetId, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.AddressesApiFactory = AddressesApiFactory;\n/**\n * AddressesApi - object-oriented interface\n * @export\n * @class AddressesApi\n * @extends {BaseAPI}\n */\nclass AddressesApi extends base_1.BaseAPI {\n    /**\n     * Create a new address scoped to the wallet.\n     * @summary Create a new address\n     * @param {string} walletId The ID of the wallet to create the address in.\n     * @param {CreateAddressRequest} [createAddressRequest]\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof AddressesApi\n     */\n    createAddress(walletId, createAddressRequest, options) {\n        return (0, exports.AddressesApiFp)(this.configuration).createAddress(walletId, createAddressRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Create a new payload signature with an address.\n     * @summary Create a new payload signature.\n     * @param {string} walletId The ID of the wallet the address belongs to.\n     * @param {string} addressId The onchain address of the address to sign the payload with.\n     * @param {CreatePayloadSignatureRequest} [createPayloadSignatureRequest]\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof AddressesApi\n     */\n    createPayloadSignature(walletId, addressId, createPayloadSignatureRequest, options) {\n        return (0, exports.AddressesApiFp)(this.configuration).createPayloadSignature(walletId, addressId, createPayloadSignatureRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Get address\n     * @summary Get address by onchain address\n     * @param {string} walletId The ID of the wallet the address belongs to.\n     * @param {string} addressId The onchain address of the address that is being fetched.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof AddressesApi\n     */\n    getAddress(walletId, addressId, options) {\n        return (0, exports.AddressesApiFp)(this.configuration).getAddress(walletId, addressId, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Get address balance\n     * @summary Get address balance for asset\n     * @param {string} walletId The ID of the wallet to fetch the balance for\n     * @param {string} addressId The onchain address of the address that is being fetched.\n     * @param {string} assetId The symbol of the asset to fetch the balance for\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof AddressesApi\n     */\n    getAddressBalance(walletId, addressId, assetId, options) {\n        return (0, exports.AddressesApiFp)(this.configuration).getAddressBalance(walletId, addressId, assetId, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Get payload signature.\n     * @summary Get payload signature.\n     * @param {string} walletId The ID of the wallet the address belongs to.\n     * @param {string} addressId The onchain address of the address that signed the payload.\n     * @param {string} payloadSignatureId The ID of the payload signature to fetch.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof AddressesApi\n     */\n    getPayloadSignature(walletId, addressId, payloadSignatureId, options) {\n        return (0, exports.AddressesApiFp)(this.configuration).getPayloadSignature(walletId, addressId, payloadSignatureId, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Get address balances\n     * @summary Get all balances for address\n     * @param {string} walletId The ID of the wallet to fetch the balances for\n     * @param {string} addressId The onchain address of the address that is being fetched.\n     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof AddressesApi\n     */\n    listAddressBalances(walletId, addressId, page, options) {\n        return (0, exports.AddressesApiFp)(this.configuration).listAddressBalances(walletId, addressId, page, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * List addresses in the wallet.\n     * @summary List addresses in a wallet.\n     * @param {string} walletId The ID of the wallet whose addresses to fetch\n     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof AddressesApi\n     */\n    listAddresses(walletId, limit, page, options) {\n        return (0, exports.AddressesApiFp)(this.configuration).listAddresses(walletId, limit, page, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * List payload signatures for an address.\n     * @summary List payload signatures for an address.\n     * @param {string} walletId The ID of the wallet the address belongs to.\n     * @param {string} addressId The onchain address of the address whose payload signatures to fetch.\n     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof AddressesApi\n     */\n    listPayloadSignatures(walletId, addressId, limit, page, options) {\n        return (0, exports.AddressesApiFp)(this.configuration).listPayloadSignatures(walletId, addressId, limit, page, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Request faucet funds to be sent to onchain address.\n     * @summary Request faucet funds for onchain address.\n     * @param {string} walletId The ID of the wallet the address belongs to.\n     * @param {string} addressId The onchain address of the address that is being fetched.\n     * @param {string} [assetId] The ID of the asset to transfer from the faucet.\n     * @param {*} [options] Override http request option.\n     * @deprecated\n     * @throws {RequiredError}\n     * @memberof AddressesApi\n     */\n    requestFaucetFunds(walletId, addressId, assetId, options) {\n        return (0, exports.AddressesApiFp)(this.configuration).requestFaucetFunds(walletId, addressId, assetId, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.AddressesApi = AddressesApi;\n/**\n * AssetsApi - axios parameter creator\n * @export\n */\nconst AssetsApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Get the asset for the specified asset ID.\n         * @summary Get the asset for the specified asset ID.\n         * @param {string} networkId The ID of the blockchain network\n         * @param {string} assetId The ID of the asset to fetch. This could be a symbol or an ERC20 contract address.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getAsset: async (networkId, assetId, options = {}) => {\n            // verify required parameter 'networkId' is not null or undefined\n            (0, common_1.assertParamExists)('getAsset', 'networkId', networkId);\n            // verify required parameter 'assetId' is not null or undefined\n            (0, common_1.assertParamExists)('getAsset', 'assetId', assetId);\n            const localVarPath = `/v1/networks/{network_id}/assets/{asset_id}`\n                .replace(`{${\"network_id\"}}`, encodeURIComponent(String(networkId)))\n                .replace(`{${\"asset_id\"}}`, encodeURIComponent(String(assetId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.AssetsApiAxiosParamCreator = AssetsApiAxiosParamCreator;\n/**\n * AssetsApi - functional programming interface\n * @export\n */\nconst AssetsApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.AssetsApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * Get the asset for the specified asset ID.\n         * @summary Get the asset for the specified asset ID.\n         * @param {string} networkId The ID of the blockchain network\n         * @param {string} assetId The ID of the asset to fetch. This could be a symbol or an ERC20 contract address.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async getAsset(networkId, assetId, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getAsset(networkId, assetId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['AssetsApi.getAsset']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.AssetsApiFp = AssetsApiFp;\n/**\n * AssetsApi - factory interface\n * @export\n */\nconst AssetsApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.AssetsApiFp)(configuration);\n    return {\n        /**\n         * Get the asset for the specified asset ID.\n         * @summary Get the asset for the specified asset ID.\n         * @param {string} networkId The ID of the blockchain network\n         * @param {string} assetId The ID of the asset to fetch. This could be a symbol or an ERC20 contract address.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getAsset(networkId, assetId, options) {\n            return localVarFp.getAsset(networkId, assetId, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.AssetsApiFactory = AssetsApiFactory;\n/**\n * AssetsApi - object-oriented interface\n * @export\n * @class AssetsApi\n * @extends {BaseAPI}\n */\nclass AssetsApi extends base_1.BaseAPI {\n    /**\n     * Get the asset for the specified asset ID.\n     * @summary Get the asset for the specified asset ID.\n     * @param {string} networkId The ID of the blockchain network\n     * @param {string} assetId The ID of the asset to fetch. This could be a symbol or an ERC20 contract address.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof AssetsApi\n     */\n    getAsset(networkId, assetId, options) {\n        return (0, exports.AssetsApiFp)(this.configuration).getAsset(networkId, assetId, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.AssetsApi = AssetsApi;\n/**\n * BalanceHistoryApi - axios parameter creator\n * @export\n */\nconst BalanceHistoryApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * List the historical balance of an asset in a specific address.\n         * @summary Get address balance history for asset\n         * @param {string} networkId The ID of the blockchain network\n         * @param {string} addressId The ID of the address to fetch the historical balance for.\n         * @param {string} assetId The symbol of the asset to fetch the historical balance for.\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listAddressHistoricalBalance: async (networkId, addressId, assetId, limit, page, options = {}) => {\n            // verify required parameter 'networkId' is not null or undefined\n            (0, common_1.assertParamExists)('listAddressHistoricalBalance', 'networkId', networkId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('listAddressHistoricalBalance', 'addressId', addressId);\n            // verify required parameter 'assetId' is not null or undefined\n            (0, common_1.assertParamExists)('listAddressHistoricalBalance', 'assetId', assetId);\n            const localVarPath = `/v1/networks/{network_id}/addresses/{address_id}/balance_history/{asset_id}`\n                .replace(`{${\"network_id\"}}`, encodeURIComponent(String(networkId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)))\n                .replace(`{${\"asset_id\"}}`, encodeURIComponent(String(assetId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (page !== undefined) {\n                localVarQueryParameter['page'] = page;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.BalanceHistoryApiAxiosParamCreator = BalanceHistoryApiAxiosParamCreator;\n/**\n * BalanceHistoryApi - functional programming interface\n * @export\n */\nconst BalanceHistoryApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.BalanceHistoryApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * List the historical balance of an asset in a specific address.\n         * @summary Get address balance history for asset\n         * @param {string} networkId The ID of the blockchain network\n         * @param {string} addressId The ID of the address to fetch the historical balance for.\n         * @param {string} assetId The symbol of the asset to fetch the historical balance for.\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async listAddressHistoricalBalance(networkId, addressId, assetId, limit, page, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.listAddressHistoricalBalance(networkId, addressId, assetId, limit, page, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['BalanceHistoryApi.listAddressHistoricalBalance']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.BalanceHistoryApiFp = BalanceHistoryApiFp;\n/**\n * BalanceHistoryApi - factory interface\n * @export\n */\nconst BalanceHistoryApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.BalanceHistoryApiFp)(configuration);\n    return {\n        /**\n         * List the historical balance of an asset in a specific address.\n         * @summary Get address balance history for asset\n         * @param {string} networkId The ID of the blockchain network\n         * @param {string} addressId The ID of the address to fetch the historical balance for.\n         * @param {string} assetId The symbol of the asset to fetch the historical balance for.\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listAddressHistoricalBalance(networkId, addressId, assetId, limit, page, options) {\n            return localVarFp.listAddressHistoricalBalance(networkId, addressId, assetId, limit, page, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.BalanceHistoryApiFactory = BalanceHistoryApiFactory;\n/**\n * BalanceHistoryApi - object-oriented interface\n * @export\n * @class BalanceHistoryApi\n * @extends {BaseAPI}\n */\nclass BalanceHistoryApi extends base_1.BaseAPI {\n    /**\n     * List the historical balance of an asset in a specific address.\n     * @summary Get address balance history for asset\n     * @param {string} networkId The ID of the blockchain network\n     * @param {string} addressId The ID of the address to fetch the historical balance for.\n     * @param {string} assetId The symbol of the asset to fetch the historical balance for.\n     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof BalanceHistoryApi\n     */\n    listAddressHistoricalBalance(networkId, addressId, assetId, limit, page, options) {\n        return (0, exports.BalanceHistoryApiFp)(this.configuration).listAddressHistoricalBalance(networkId, addressId, assetId, limit, page, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.BalanceHistoryApi = BalanceHistoryApi;\n/**\n * ContractEventsApi - axios parameter creator\n * @export\n */\nconst ContractEventsApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Retrieve events for a specific contract\n         * @summary List contract events\n         * @param {string} networkId Unique identifier for the blockchain network\n         * @param {string} protocolName Case-sensitive name of the blockchain protocol\n         * @param {string} contractAddress EVM address of the smart contract (42 characters, including \\&#39;0x\\&#39;, in lowercase)\n         * @param {string} contractName Case-sensitive name of the specific contract within the project\n         * @param {string} eventName Case-sensitive name of the event to filter for in the contract\\&#39;s logs\n         * @param {number} fromBlockHeight Lower bound of the block range to query (inclusive)\n         * @param {number} toBlockHeight Upper bound of the block range to query (inclusive)\n         * @param {string} [nextPage] Pagination token for retrieving the next set of results\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listContractEvents: async (networkId, protocolName, contractAddress, contractName, eventName, fromBlockHeight, toBlockHeight, nextPage, options = {}) => {\n            // verify required parameter 'networkId' is not null or undefined\n            (0, common_1.assertParamExists)('listContractEvents', 'networkId', networkId);\n            // verify required parameter 'protocolName' is not null or undefined\n            (0, common_1.assertParamExists)('listContractEvents', 'protocolName', protocolName);\n            // verify required parameter 'contractAddress' is not null or undefined\n            (0, common_1.assertParamExists)('listContractEvents', 'contractAddress', contractAddress);\n            // verify required parameter 'contractName' is not null or undefined\n            (0, common_1.assertParamExists)('listContractEvents', 'contractName', contractName);\n            // verify required parameter 'eventName' is not null or undefined\n            (0, common_1.assertParamExists)('listContractEvents', 'eventName', eventName);\n            // verify required parameter 'fromBlockHeight' is not null or undefined\n            (0, common_1.assertParamExists)('listContractEvents', 'fromBlockHeight', fromBlockHeight);\n            // verify required parameter 'toBlockHeight' is not null or undefined\n            (0, common_1.assertParamExists)('listContractEvents', 'toBlockHeight', toBlockHeight);\n            const localVarPath = `/v1/networks/{network_id}/smart_contracts/{contract_address}/events`\n                .replace(`{${\"network_id\"}}`, encodeURIComponent(String(networkId)))\n                .replace(`{${\"contract_address\"}}`, encodeURIComponent(String(contractAddress)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            if (protocolName !== undefined) {\n                localVarQueryParameter['protocol_name'] = protocolName;\n            }\n            if (contractName !== undefined) {\n                localVarQueryParameter['contract_name'] = contractName;\n            }\n            if (eventName !== undefined) {\n                localVarQueryParameter['event_name'] = eventName;\n            }\n            if (fromBlockHeight !== undefined) {\n                localVarQueryParameter['from_block_height'] = fromBlockHeight;\n            }\n            if (toBlockHeight !== undefined) {\n                localVarQueryParameter['to_block_height'] = toBlockHeight;\n            }\n            if (nextPage !== undefined) {\n                localVarQueryParameter['next_page'] = nextPage;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.ContractEventsApiAxiosParamCreator = ContractEventsApiAxiosParamCreator;\n/**\n * ContractEventsApi - functional programming interface\n * @export\n */\nconst ContractEventsApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.ContractEventsApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * Retrieve events for a specific contract\n         * @summary List contract events\n         * @param {string} networkId Unique identifier for the blockchain network\n         * @param {string} protocolName Case-sensitive name of the blockchain protocol\n         * @param {string} contractAddress EVM address of the smart contract (42 characters, including \\&#39;0x\\&#39;, in lowercase)\n         * @param {string} contractName Case-sensitive name of the specific contract within the project\n         * @param {string} eventName Case-sensitive name of the event to filter for in the contract\\&#39;s logs\n         * @param {number} fromBlockHeight Lower bound of the block range to query (inclusive)\n         * @param {number} toBlockHeight Upper bound of the block range to query (inclusive)\n         * @param {string} [nextPage] Pagination token for retrieving the next set of results\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async listContractEvents(networkId, protocolName, contractAddress, contractName, eventName, fromBlockHeight, toBlockHeight, nextPage, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.listContractEvents(networkId, protocolName, contractAddress, contractName, eventName, fromBlockHeight, toBlockHeight, nextPage, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['ContractEventsApi.listContractEvents']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.ContractEventsApiFp = ContractEventsApiFp;\n/**\n * ContractEventsApi - factory interface\n * @export\n */\nconst ContractEventsApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.ContractEventsApiFp)(configuration);\n    return {\n        /**\n         * Retrieve events for a specific contract\n         * @summary List contract events\n         * @param {string} networkId Unique identifier for the blockchain network\n         * @param {string} protocolName Case-sensitive name of the blockchain protocol\n         * @param {string} contractAddress EVM address of the smart contract (42 characters, including \\&#39;0x\\&#39;, in lowercase)\n         * @param {string} contractName Case-sensitive name of the specific contract within the project\n         * @param {string} eventName Case-sensitive name of the event to filter for in the contract\\&#39;s logs\n         * @param {number} fromBlockHeight Lower bound of the block range to query (inclusive)\n         * @param {number} toBlockHeight Upper bound of the block range to query (inclusive)\n         * @param {string} [nextPage] Pagination token for retrieving the next set of results\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listContractEvents(networkId, protocolName, contractAddress, contractName, eventName, fromBlockHeight, toBlockHeight, nextPage, options) {\n            return localVarFp.listContractEvents(networkId, protocolName, contractAddress, contractName, eventName, fromBlockHeight, toBlockHeight, nextPage, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.ContractEventsApiFactory = ContractEventsApiFactory;\n/**\n * ContractEventsApi - object-oriented interface\n * @export\n * @class ContractEventsApi\n * @extends {BaseAPI}\n */\nclass ContractEventsApi extends base_1.BaseAPI {\n    /**\n     * Retrieve events for a specific contract\n     * @summary List contract events\n     * @param {string} networkId Unique identifier for the blockchain network\n     * @param {string} protocolName Case-sensitive name of the blockchain protocol\n     * @param {string} contractAddress EVM address of the smart contract (42 characters, including \\&#39;0x\\&#39;, in lowercase)\n     * @param {string} contractName Case-sensitive name of the specific contract within the project\n     * @param {string} eventName Case-sensitive name of the event to filter for in the contract\\&#39;s logs\n     * @param {number} fromBlockHeight Lower bound of the block range to query (inclusive)\n     * @param {number} toBlockHeight Upper bound of the block range to query (inclusive)\n     * @param {string} [nextPage] Pagination token for retrieving the next set of results\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ContractEventsApi\n     */\n    listContractEvents(networkId, protocolName, contractAddress, contractName, eventName, fromBlockHeight, toBlockHeight, nextPage, options) {\n        return (0, exports.ContractEventsApiFp)(this.configuration).listContractEvents(networkId, protocolName, contractAddress, contractName, eventName, fromBlockHeight, toBlockHeight, nextPage, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.ContractEventsApi = ContractEventsApi;\n/**\n * ContractInvocationsApi - axios parameter creator\n * @export\n */\nconst ContractInvocationsApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Broadcast a contract invocation.\n         * @summary Broadcast a contract invocation.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The ID of the address the contract invocation belongs to.\n         * @param {string} contractInvocationId The ID of the contract invocation to broadcast.\n         * @param {BroadcastContractInvocationRequest} broadcastContractInvocationRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        broadcastContractInvocation: async (walletId, addressId, contractInvocationId, broadcastContractInvocationRequest, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('broadcastContractInvocation', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('broadcastContractInvocation', 'addressId', addressId);\n            // verify required parameter 'contractInvocationId' is not null or undefined\n            (0, common_1.assertParamExists)('broadcastContractInvocation', 'contractInvocationId', contractInvocationId);\n            // verify required parameter 'broadcastContractInvocationRequest' is not null or undefined\n            (0, common_1.assertParamExists)('broadcastContractInvocation', 'broadcastContractInvocationRequest', broadcastContractInvocationRequest);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/contract_invocations/{contract_invocation_id}/broadcast`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)))\n                .replace(`{${\"contract_invocation_id\"}}`, encodeURIComponent(String(contractInvocationId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(broadcastContractInvocationRequest, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Create a new contract invocation.\n         * @summary Create a new contract invocation for an address.\n         * @param {string} walletId The ID of the wallet the source address belongs to.\n         * @param {string} addressId The ID of the address to invoke the contract from.\n         * @param {CreateContractInvocationRequest} createContractInvocationRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createContractInvocation: async (walletId, addressId, createContractInvocationRequest, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('createContractInvocation', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('createContractInvocation', 'addressId', addressId);\n            // verify required parameter 'createContractInvocationRequest' is not null or undefined\n            (0, common_1.assertParamExists)('createContractInvocation', 'createContractInvocationRequest', createContractInvocationRequest);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/contract_invocations`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createContractInvocationRequest, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Get a contract invocation by ID.\n         * @summary Get a contract invocation by ID.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The ID of the address the contract invocation belongs to.\n         * @param {string} contractInvocationId The ID of the contract invocation to fetch.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getContractInvocation: async (walletId, addressId, contractInvocationId, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('getContractInvocation', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('getContractInvocation', 'addressId', addressId);\n            // verify required parameter 'contractInvocationId' is not null or undefined\n            (0, common_1.assertParamExists)('getContractInvocation', 'contractInvocationId', contractInvocationId);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/contract_invocations/{contract_invocation_id}`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)))\n                .replace(`{${\"contract_invocation_id\"}}`, encodeURIComponent(String(contractInvocationId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * List contract invocations for an address.\n         * @summary List contract invocations for an address.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The ID of the address to list contract invocations for.\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listContractInvocations: async (walletId, addressId, limit, page, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('listContractInvocations', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('listContractInvocations', 'addressId', addressId);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/contract_invocations`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (page !== undefined) {\n                localVarQueryParameter['page'] = page;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.ContractInvocationsApiAxiosParamCreator = ContractInvocationsApiAxiosParamCreator;\n/**\n * ContractInvocationsApi - functional programming interface\n * @export\n */\nconst ContractInvocationsApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.ContractInvocationsApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * Broadcast a contract invocation.\n         * @summary Broadcast a contract invocation.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The ID of the address the contract invocation belongs to.\n         * @param {string} contractInvocationId The ID of the contract invocation to broadcast.\n         * @param {BroadcastContractInvocationRequest} broadcastContractInvocationRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async broadcastContractInvocation(walletId, addressId, contractInvocationId, broadcastContractInvocationRequest, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.broadcastContractInvocation(walletId, addressId, contractInvocationId, broadcastContractInvocationRequest, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['ContractInvocationsApi.broadcastContractInvocation']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Create a new contract invocation.\n         * @summary Create a new contract invocation for an address.\n         * @param {string} walletId The ID of the wallet the source address belongs to.\n         * @param {string} addressId The ID of the address to invoke the contract from.\n         * @param {CreateContractInvocationRequest} createContractInvocationRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async createContractInvocation(walletId, addressId, createContractInvocationRequest, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.createContractInvocation(walletId, addressId, createContractInvocationRequest, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['ContractInvocationsApi.createContractInvocation']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Get a contract invocation by ID.\n         * @summary Get a contract invocation by ID.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The ID of the address the contract invocation belongs to.\n         * @param {string} contractInvocationId The ID of the contract invocation to fetch.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async getContractInvocation(walletId, addressId, contractInvocationId, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getContractInvocation(walletId, addressId, contractInvocationId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['ContractInvocationsApi.getContractInvocation']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * List contract invocations for an address.\n         * @summary List contract invocations for an address.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The ID of the address to list contract invocations for.\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async listContractInvocations(walletId, addressId, limit, page, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.listContractInvocations(walletId, addressId, limit, page, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['ContractInvocationsApi.listContractInvocations']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.ContractInvocationsApiFp = ContractInvocationsApiFp;\n/**\n * ContractInvocationsApi - factory interface\n * @export\n */\nconst ContractInvocationsApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.ContractInvocationsApiFp)(configuration);\n    return {\n        /**\n         * Broadcast a contract invocation.\n         * @summary Broadcast a contract invocation.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The ID of the address the contract invocation belongs to.\n         * @param {string} contractInvocationId The ID of the contract invocation to broadcast.\n         * @param {BroadcastContractInvocationRequest} broadcastContractInvocationRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        broadcastContractInvocation(walletId, addressId, contractInvocationId, broadcastContractInvocationRequest, options) {\n            return localVarFp.broadcastContractInvocation(walletId, addressId, contractInvocationId, broadcastContractInvocationRequest, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Create a new contract invocation.\n         * @summary Create a new contract invocation for an address.\n         * @param {string} walletId The ID of the wallet the source address belongs to.\n         * @param {string} addressId The ID of the address to invoke the contract from.\n         * @param {CreateContractInvocationRequest} createContractInvocationRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createContractInvocation(walletId, addressId, createContractInvocationRequest, options) {\n            return localVarFp.createContractInvocation(walletId, addressId, createContractInvocationRequest, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Get a contract invocation by ID.\n         * @summary Get a contract invocation by ID.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The ID of the address the contract invocation belongs to.\n         * @param {string} contractInvocationId The ID of the contract invocation to fetch.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getContractInvocation(walletId, addressId, contractInvocationId, options) {\n            return localVarFp.getContractInvocation(walletId, addressId, contractInvocationId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * List contract invocations for an address.\n         * @summary List contract invocations for an address.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The ID of the address to list contract invocations for.\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listContractInvocations(walletId, addressId, limit, page, options) {\n            return localVarFp.listContractInvocations(walletId, addressId, limit, page, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.ContractInvocationsApiFactory = ContractInvocationsApiFactory;\n/**\n * ContractInvocationsApi - object-oriented interface\n * @export\n * @class ContractInvocationsApi\n * @extends {BaseAPI}\n */\nclass ContractInvocationsApi extends base_1.BaseAPI {\n    /**\n     * Broadcast a contract invocation.\n     * @summary Broadcast a contract invocation.\n     * @param {string} walletId The ID of the wallet the address belongs to.\n     * @param {string} addressId The ID of the address the contract invocation belongs to.\n     * @param {string} contractInvocationId The ID of the contract invocation to broadcast.\n     * @param {BroadcastContractInvocationRequest} broadcastContractInvocationRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ContractInvocationsApi\n     */\n    broadcastContractInvocation(walletId, addressId, contractInvocationId, broadcastContractInvocationRequest, options) {\n        return (0, exports.ContractInvocationsApiFp)(this.configuration).broadcastContractInvocation(walletId, addressId, contractInvocationId, broadcastContractInvocationRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Create a new contract invocation.\n     * @summary Create a new contract invocation for an address.\n     * @param {string} walletId The ID of the wallet the source address belongs to.\n     * @param {string} addressId The ID of the address to invoke the contract from.\n     * @param {CreateContractInvocationRequest} createContractInvocationRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ContractInvocationsApi\n     */\n    createContractInvocation(walletId, addressId, createContractInvocationRequest, options) {\n        return (0, exports.ContractInvocationsApiFp)(this.configuration).createContractInvocation(walletId, addressId, createContractInvocationRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Get a contract invocation by ID.\n     * @summary Get a contract invocation by ID.\n     * @param {string} walletId The ID of the wallet the address belongs to.\n     * @param {string} addressId The ID of the address the contract invocation belongs to.\n     * @param {string} contractInvocationId The ID of the contract invocation to fetch.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ContractInvocationsApi\n     */\n    getContractInvocation(walletId, addressId, contractInvocationId, options) {\n        return (0, exports.ContractInvocationsApiFp)(this.configuration).getContractInvocation(walletId, addressId, contractInvocationId, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * List contract invocations for an address.\n     * @summary List contract invocations for an address.\n     * @param {string} walletId The ID of the wallet the address belongs to.\n     * @param {string} addressId The ID of the address to list contract invocations for.\n     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ContractInvocationsApi\n     */\n    listContractInvocations(walletId, addressId, limit, page, options) {\n        return (0, exports.ContractInvocationsApiFp)(this.configuration).listContractInvocations(walletId, addressId, limit, page, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.ContractInvocationsApi = ContractInvocationsApi;\n/**\n * ExternalAddressesApi - axios parameter creator\n * @export\n */\nconst ExternalAddressesApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Broadcast an arbitrary transaction to the node constructed and signed by an external address.\n         * @summary Broadcast an arbitrary transaction.\n         * @param {string} networkId The ID of the network the external address belongs to.\n         * @param {string} addressId The onchain address of the transaction sender.\n         * @param {BroadcastExternalTransactionRequest} broadcastExternalTransactionRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        broadcastExternalTransaction: async (networkId, addressId, broadcastExternalTransactionRequest, options = {}) => {\n            // verify required parameter 'networkId' is not null or undefined\n            (0, common_1.assertParamExists)('broadcastExternalTransaction', 'networkId', networkId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('broadcastExternalTransaction', 'addressId', addressId);\n            // verify required parameter 'broadcastExternalTransactionRequest' is not null or undefined\n            (0, common_1.assertParamExists)('broadcastExternalTransaction', 'broadcastExternalTransactionRequest', broadcastExternalTransactionRequest);\n            const localVarPath = `/v1/networks/{network_id}/addresses/{address_id}/transactions`\n                .replace(`{${\"network_id\"}}`, encodeURIComponent(String(networkId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(broadcastExternalTransactionRequest, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Broadcast an external address\\'s transfer with a signed payload\n         * @summary Broadcast an external address\\' transfer\n         * @param {string} networkId The ID of the network the address belongs to\n         * @param {string} addressId The ID of the address the transfer belongs to\n         * @param {string} transferId The ID of the transfer to broadcast\n         * @param {BroadcastExternalTransferRequest} broadcastExternalTransferRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        broadcastExternalTransfer: async (networkId, addressId, transferId, broadcastExternalTransferRequest, options = {}) => {\n            // verify required parameter 'networkId' is not null or undefined\n            (0, common_1.assertParamExists)('broadcastExternalTransfer', 'networkId', networkId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('broadcastExternalTransfer', 'addressId', addressId);\n            // verify required parameter 'transferId' is not null or undefined\n            (0, common_1.assertParamExists)('broadcastExternalTransfer', 'transferId', transferId);\n            // verify required parameter 'broadcastExternalTransferRequest' is not null or undefined\n            (0, common_1.assertParamExists)('broadcastExternalTransfer', 'broadcastExternalTransferRequest', broadcastExternalTransferRequest);\n            const localVarPath = `/v1/networks/{network_id}/addresses/{address_id}/transfers/{transfer_id}/broadcast`\n                .replace(`{${\"network_id\"}}`, encodeURIComponent(String(networkId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)))\n                .replace(`{${\"transfer_id\"}}`, encodeURIComponent(String(transferId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(broadcastExternalTransferRequest, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Create a new transfer between addresses.\n         * @summary Create a new transfer\n         * @param {string} networkId The ID of the network the address is on\n         * @param {string} addressId The ID of the address to transfer from\n         * @param {CreateExternalTransferRequest} createExternalTransferRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createExternalTransfer: async (networkId, addressId, createExternalTransferRequest, options = {}) => {\n            // verify required parameter 'networkId' is not null or undefined\n            (0, common_1.assertParamExists)('createExternalTransfer', 'networkId', networkId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('createExternalTransfer', 'addressId', addressId);\n            // verify required parameter 'createExternalTransferRequest' is not null or undefined\n            (0, common_1.assertParamExists)('createExternalTransfer', 'createExternalTransferRequest', createExternalTransferRequest);\n            const localVarPath = `/v1/networks/{network_id}/addresses/{address_id}/transfers`\n                .replace(`{${\"network_id\"}}`, encodeURIComponent(String(networkId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createExternalTransferRequest, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Get the balance of an asset in an external address\n         * @summary Get the balance of an asset in an external address\n         * @param {string} networkId The ID of the blockchain network\n         * @param {string} addressId The ID of the address to fetch the balance for\n         * @param {string} assetId The ID of the asset to fetch the balance for\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getExternalAddressBalance: async (networkId, addressId, assetId, options = {}) => {\n            // verify required parameter 'networkId' is not null or undefined\n            (0, common_1.assertParamExists)('getExternalAddressBalance', 'networkId', networkId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('getExternalAddressBalance', 'addressId', addressId);\n            // verify required parameter 'assetId' is not null or undefined\n            (0, common_1.assertParamExists)('getExternalAddressBalance', 'assetId', assetId);\n            const localVarPath = `/v1/networks/{network_id}/addresses/{address_id}/balances/{asset_id}`\n                .replace(`{${\"network_id\"}}`, encodeURIComponent(String(networkId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)))\n                .replace(`{${\"asset_id\"}}`, encodeURIComponent(String(assetId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Get an external address\\' transfer by ID\n         * @summary Get a external address\\' transfer\n         * @param {string} networkId The ID of the network the address is on\n         * @param {string} addressId The ID of the address the transfer belongs to\n         * @param {string} transferId The ID of the transfer to fetch\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getExternalTransfer: async (networkId, addressId, transferId, options = {}) => {\n            // verify required parameter 'networkId' is not null or undefined\n            (0, common_1.assertParamExists)('getExternalTransfer', 'networkId', networkId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('getExternalTransfer', 'addressId', addressId);\n            // verify required parameter 'transferId' is not null or undefined\n            (0, common_1.assertParamExists)('getExternalTransfer', 'transferId', transferId);\n            const localVarPath = `/v1/networks/{network_id}/addresses/{address_id}/transfers/{transfer_id}`\n                .replace(`{${\"network_id\"}}`, encodeURIComponent(String(networkId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)))\n                .replace(`{${\"transfer_id\"}}`, encodeURIComponent(String(transferId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Get the status of a faucet transaction\n         * @summary Get the status of a faucet transaction\n         * @param {string} networkId The ID of the blockchain network\n         * @param {string} addressId The ID of the address to fetch the faucet transaction for\n         * @param {string} txHash The hash of the faucet transaction\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getFaucetTransaction: async (networkId, addressId, txHash, options = {}) => {\n            // verify required parameter 'networkId' is not null or undefined\n            (0, common_1.assertParamExists)('getFaucetTransaction', 'networkId', networkId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('getFaucetTransaction', 'addressId', addressId);\n            // verify required parameter 'txHash' is not null or undefined\n            (0, common_1.assertParamExists)('getFaucetTransaction', 'txHash', txHash);\n            const localVarPath = `/v1/networks/{network_id}/addresses/{address_id}/faucet/{tx_hash}`\n                .replace(`{${\"network_id\"}}`, encodeURIComponent(String(networkId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)))\n                .replace(`{${\"tx_hash\"}}`, encodeURIComponent(String(txHash)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * List all of the balances of an external address\n         * @summary Get the balances of an external address\n         * @param {string} networkId The ID of the blockchain network\n         * @param {string} addressId The ID of the address to fetch the balance for\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listExternalAddressBalances: async (networkId, addressId, page, options = {}) => {\n            // verify required parameter 'networkId' is not null or undefined\n            (0, common_1.assertParamExists)('listExternalAddressBalances', 'networkId', networkId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('listExternalAddressBalances', 'addressId', addressId);\n            const localVarPath = `/v1/networks/{network_id}/addresses/{address_id}/balances`\n                .replace(`{${\"network_id\"}}`, encodeURIComponent(String(networkId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            if (page !== undefined) {\n                localVarQueryParameter['page'] = page;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Request faucet funds to be sent to external address.\n         * @summary Request faucet funds for external address.\n         * @param {string} networkId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address of the address that is being fetched.\n         * @param {string} [assetId] The ID of the asset to transfer from the faucet.\n         * @param {boolean} [skipWait] Whether to skip waiting for the transaction to be mined. This will become the default behavior in the future.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        requestExternalFaucetFunds: async (networkId, addressId, assetId, skipWait, options = {}) => {\n            // verify required parameter 'networkId' is not null or undefined\n            (0, common_1.assertParamExists)('requestExternalFaucetFunds', 'networkId', networkId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('requestExternalFaucetFunds', 'addressId', addressId);\n            const localVarPath = `/v1/networks/{network_id}/addresses/{address_id}/faucet`\n                .replace(`{${\"network_id\"}}`, encodeURIComponent(String(networkId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            if (assetId !== undefined) {\n                localVarQueryParameter['asset_id'] = assetId;\n            }\n            if (skipWait !== undefined) {\n                localVarQueryParameter['skip_wait'] = skipWait;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.ExternalAddressesApiAxiosParamCreator = ExternalAddressesApiAxiosParamCreator;\n/**\n * ExternalAddressesApi - functional programming interface\n * @export\n */\nconst ExternalAddressesApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.ExternalAddressesApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * Broadcast an arbitrary transaction to the node constructed and signed by an external address.\n         * @summary Broadcast an arbitrary transaction.\n         * @param {string} networkId The ID of the network the external address belongs to.\n         * @param {string} addressId The onchain address of the transaction sender.\n         * @param {BroadcastExternalTransactionRequest} broadcastExternalTransactionRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async broadcastExternalTransaction(networkId, addressId, broadcastExternalTransactionRequest, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.broadcastExternalTransaction(networkId, addressId, broadcastExternalTransactionRequest, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['ExternalAddressesApi.broadcastExternalTransaction']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Broadcast an external address\\'s transfer with a signed payload\n         * @summary Broadcast an external address\\' transfer\n         * @param {string} networkId The ID of the network the address belongs to\n         * @param {string} addressId The ID of the address the transfer belongs to\n         * @param {string} transferId The ID of the transfer to broadcast\n         * @param {BroadcastExternalTransferRequest} broadcastExternalTransferRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async broadcastExternalTransfer(networkId, addressId, transferId, broadcastExternalTransferRequest, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.broadcastExternalTransfer(networkId, addressId, transferId, broadcastExternalTransferRequest, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['ExternalAddressesApi.broadcastExternalTransfer']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Create a new transfer between addresses.\n         * @summary Create a new transfer\n         * @param {string} networkId The ID of the network the address is on\n         * @param {string} addressId The ID of the address to transfer from\n         * @param {CreateExternalTransferRequest} createExternalTransferRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async createExternalTransfer(networkId, addressId, createExternalTransferRequest, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.createExternalTransfer(networkId, addressId, createExternalTransferRequest, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['ExternalAddressesApi.createExternalTransfer']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Get the balance of an asset in an external address\n         * @summary Get the balance of an asset in an external address\n         * @param {string} networkId The ID of the blockchain network\n         * @param {string} addressId The ID of the address to fetch the balance for\n         * @param {string} assetId The ID of the asset to fetch the balance for\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async getExternalAddressBalance(networkId, addressId, assetId, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getExternalAddressBalance(networkId, addressId, assetId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['ExternalAddressesApi.getExternalAddressBalance']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Get an external address\\' transfer by ID\n         * @summary Get a external address\\' transfer\n         * @param {string} networkId The ID of the network the address is on\n         * @param {string} addressId The ID of the address the transfer belongs to\n         * @param {string} transferId The ID of the transfer to fetch\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async getExternalTransfer(networkId, addressId, transferId, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getExternalTransfer(networkId, addressId, transferId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['ExternalAddressesApi.getExternalTransfer']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Get the status of a faucet transaction\n         * @summary Get the status of a faucet transaction\n         * @param {string} networkId The ID of the blockchain network\n         * @param {string} addressId The ID of the address to fetch the faucet transaction for\n         * @param {string} txHash The hash of the faucet transaction\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async getFaucetTransaction(networkId, addressId, txHash, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getFaucetTransaction(networkId, addressId, txHash, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['ExternalAddressesApi.getFaucetTransaction']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * List all of the balances of an external address\n         * @summary Get the balances of an external address\n         * @param {string} networkId The ID of the blockchain network\n         * @param {string} addressId The ID of the address to fetch the balance for\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async listExternalAddressBalances(networkId, addressId, page, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.listExternalAddressBalances(networkId, addressId, page, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['ExternalAddressesApi.listExternalAddressBalances']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Request faucet funds to be sent to external address.\n         * @summary Request faucet funds for external address.\n         * @param {string} networkId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address of the address that is being fetched.\n         * @param {string} [assetId] The ID of the asset to transfer from the faucet.\n         * @param {boolean} [skipWait] Whether to skip waiting for the transaction to be mined. This will become the default behavior in the future.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async requestExternalFaucetFunds(networkId, addressId, assetId, skipWait, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.requestExternalFaucetFunds(networkId, addressId, assetId, skipWait, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['ExternalAddressesApi.requestExternalFaucetFunds']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.ExternalAddressesApiFp = ExternalAddressesApiFp;\n/**\n * ExternalAddressesApi - factory interface\n * @export\n */\nconst ExternalAddressesApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.ExternalAddressesApiFp)(configuration);\n    return {\n        /**\n         * Broadcast an arbitrary transaction to the node constructed and signed by an external address.\n         * @summary Broadcast an arbitrary transaction.\n         * @param {string} networkId The ID of the network the external address belongs to.\n         * @param {string} addressId The onchain address of the transaction sender.\n         * @param {BroadcastExternalTransactionRequest} broadcastExternalTransactionRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        broadcastExternalTransaction(networkId, addressId, broadcastExternalTransactionRequest, options) {\n            return localVarFp.broadcastExternalTransaction(networkId, addressId, broadcastExternalTransactionRequest, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Broadcast an external address\\'s transfer with a signed payload\n         * @summary Broadcast an external address\\' transfer\n         * @param {string} networkId The ID of the network the address belongs to\n         * @param {string} addressId The ID of the address the transfer belongs to\n         * @param {string} transferId The ID of the transfer to broadcast\n         * @param {BroadcastExternalTransferRequest} broadcastExternalTransferRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        broadcastExternalTransfer(networkId, addressId, transferId, broadcastExternalTransferRequest, options) {\n            return localVarFp.broadcastExternalTransfer(networkId, addressId, transferId, broadcastExternalTransferRequest, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Create a new transfer between addresses.\n         * @summary Create a new transfer\n         * @param {string} networkId The ID of the network the address is on\n         * @param {string} addressId The ID of the address to transfer from\n         * @param {CreateExternalTransferRequest} createExternalTransferRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createExternalTransfer(networkId, addressId, createExternalTransferRequest, options) {\n            return localVarFp.createExternalTransfer(networkId, addressId, createExternalTransferRequest, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Get the balance of an asset in an external address\n         * @summary Get the balance of an asset in an external address\n         * @param {string} networkId The ID of the blockchain network\n         * @param {string} addressId The ID of the address to fetch the balance for\n         * @param {string} assetId The ID of the asset to fetch the balance for\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getExternalAddressBalance(networkId, addressId, assetId, options) {\n            return localVarFp.getExternalAddressBalance(networkId, addressId, assetId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Get an external address\\' transfer by ID\n         * @summary Get a external address\\' transfer\n         * @param {string} networkId The ID of the network the address is on\n         * @param {string} addressId The ID of the address the transfer belongs to\n         * @param {string} transferId The ID of the transfer to fetch\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getExternalTransfer(networkId, addressId, transferId, options) {\n            return localVarFp.getExternalTransfer(networkId, addressId, transferId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Get the status of a faucet transaction\n         * @summary Get the status of a faucet transaction\n         * @param {string} networkId The ID of the blockchain network\n         * @param {string} addressId The ID of the address to fetch the faucet transaction for\n         * @param {string} txHash The hash of the faucet transaction\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getFaucetTransaction(networkId, addressId, txHash, options) {\n            return localVarFp.getFaucetTransaction(networkId, addressId, txHash, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * List all of the balances of an external address\n         * @summary Get the balances of an external address\n         * @param {string} networkId The ID of the blockchain network\n         * @param {string} addressId The ID of the address to fetch the balance for\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listExternalAddressBalances(networkId, addressId, page, options) {\n            return localVarFp.listExternalAddressBalances(networkId, addressId, page, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Request faucet funds to be sent to external address.\n         * @summary Request faucet funds for external address.\n         * @param {string} networkId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address of the address that is being fetched.\n         * @param {string} [assetId] The ID of the asset to transfer from the faucet.\n         * @param {boolean} [skipWait] Whether to skip waiting for the transaction to be mined. This will become the default behavior in the future.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        requestExternalFaucetFunds(networkId, addressId, assetId, skipWait, options) {\n            return localVarFp.requestExternalFaucetFunds(networkId, addressId, assetId, skipWait, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.ExternalAddressesApiFactory = ExternalAddressesApiFactory;\n/**\n * ExternalAddressesApi - object-oriented interface\n * @export\n * @class ExternalAddressesApi\n * @extends {BaseAPI}\n */\nclass ExternalAddressesApi extends base_1.BaseAPI {\n    /**\n     * Broadcast an arbitrary transaction to the node constructed and signed by an external address.\n     * @summary Broadcast an arbitrary transaction.\n     * @param {string} networkId The ID of the network the external address belongs to.\n     * @param {string} addressId The onchain address of the transaction sender.\n     * @param {BroadcastExternalTransactionRequest} broadcastExternalTransactionRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ExternalAddressesApi\n     */\n    broadcastExternalTransaction(networkId, addressId, broadcastExternalTransactionRequest, options) {\n        return (0, exports.ExternalAddressesApiFp)(this.configuration).broadcastExternalTransaction(networkId, addressId, broadcastExternalTransactionRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Broadcast an external address\\'s transfer with a signed payload\n     * @summary Broadcast an external address\\' transfer\n     * @param {string} networkId The ID of the network the address belongs to\n     * @param {string} addressId The ID of the address the transfer belongs to\n     * @param {string} transferId The ID of the transfer to broadcast\n     * @param {BroadcastExternalTransferRequest} broadcastExternalTransferRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ExternalAddressesApi\n     */\n    broadcastExternalTransfer(networkId, addressId, transferId, broadcastExternalTransferRequest, options) {\n        return (0, exports.ExternalAddressesApiFp)(this.configuration).broadcastExternalTransfer(networkId, addressId, transferId, broadcastExternalTransferRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Create a new transfer between addresses.\n     * @summary Create a new transfer\n     * @param {string} networkId The ID of the network the address is on\n     * @param {string} addressId The ID of the address to transfer from\n     * @param {CreateExternalTransferRequest} createExternalTransferRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ExternalAddressesApi\n     */\n    createExternalTransfer(networkId, addressId, createExternalTransferRequest, options) {\n        return (0, exports.ExternalAddressesApiFp)(this.configuration).createExternalTransfer(networkId, addressId, createExternalTransferRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Get the balance of an asset in an external address\n     * @summary Get the balance of an asset in an external address\n     * @param {string} networkId The ID of the blockchain network\n     * @param {string} addressId The ID of the address to fetch the balance for\n     * @param {string} assetId The ID of the asset to fetch the balance for\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ExternalAddressesApi\n     */\n    getExternalAddressBalance(networkId, addressId, assetId, options) {\n        return (0, exports.ExternalAddressesApiFp)(this.configuration).getExternalAddressBalance(networkId, addressId, assetId, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Get an external address\\' transfer by ID\n     * @summary Get a external address\\' transfer\n     * @param {string} networkId The ID of the network the address is on\n     * @param {string} addressId The ID of the address the transfer belongs to\n     * @param {string} transferId The ID of the transfer to fetch\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ExternalAddressesApi\n     */\n    getExternalTransfer(networkId, addressId, transferId, options) {\n        return (0, exports.ExternalAddressesApiFp)(this.configuration).getExternalTransfer(networkId, addressId, transferId, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Get the status of a faucet transaction\n     * @summary Get the status of a faucet transaction\n     * @param {string} networkId The ID of the blockchain network\n     * @param {string} addressId The ID of the address to fetch the faucet transaction for\n     * @param {string} txHash The hash of the faucet transaction\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ExternalAddressesApi\n     */\n    getFaucetTransaction(networkId, addressId, txHash, options) {\n        return (0, exports.ExternalAddressesApiFp)(this.configuration).getFaucetTransaction(networkId, addressId, txHash, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * List all of the balances of an external address\n     * @summary Get the balances of an external address\n     * @param {string} networkId The ID of the blockchain network\n     * @param {string} addressId The ID of the address to fetch the balance for\n     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ExternalAddressesApi\n     */\n    listExternalAddressBalances(networkId, addressId, page, options) {\n        return (0, exports.ExternalAddressesApiFp)(this.configuration).listExternalAddressBalances(networkId, addressId, page, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Request faucet funds to be sent to external address.\n     * @summary Request faucet funds for external address.\n     * @param {string} networkId The ID of the wallet the address belongs to.\n     * @param {string} addressId The onchain address of the address that is being fetched.\n     * @param {string} [assetId] The ID of the asset to transfer from the faucet.\n     * @param {boolean} [skipWait] Whether to skip waiting for the transaction to be mined. This will become the default behavior in the future.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ExternalAddressesApi\n     */\n    requestExternalFaucetFunds(networkId, addressId, assetId, skipWait, options) {\n        return (0, exports.ExternalAddressesApiFp)(this.configuration).requestExternalFaucetFunds(networkId, addressId, assetId, skipWait, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.ExternalAddressesApi = ExternalAddressesApi;\n/**\n * FundApi - axios parameter creator\n * @export\n */\nconst FundApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Create a new fund operation with an address.\n         * @summary Create a new fund operation.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address to be funded.\n         * @param {CreateFundOperationRequest} createFundOperationRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createFundOperation: async (walletId, addressId, createFundOperationRequest, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('createFundOperation', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('createFundOperation', 'addressId', addressId);\n            // verify required parameter 'createFundOperationRequest' is not null or undefined\n            (0, common_1.assertParamExists)('createFundOperation', 'createFundOperationRequest', createFundOperationRequest);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/fund_operations`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createFundOperationRequest, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Create a new fund operation with an address.\n         * @summary Create a Fund Operation quote.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address to be funded.\n         * @param {CreateFundQuoteRequest} createFundQuoteRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createFundQuote: async (walletId, addressId, createFundQuoteRequest, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('createFundQuote', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('createFundQuote', 'addressId', addressId);\n            // verify required parameter 'createFundQuoteRequest' is not null or undefined\n            (0, common_1.assertParamExists)('createFundQuote', 'createFundQuoteRequest', createFundQuoteRequest);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/fund_operations/quote`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createFundQuoteRequest, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Get fund operation.\n         * @summary Get fund operation.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address of the address that created the fund operation.\n         * @param {string} fundOperationId The ID of the fund operation to fetch.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getFundOperation: async (walletId, addressId, fundOperationId, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('getFundOperation', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('getFundOperation', 'addressId', addressId);\n            // verify required parameter 'fundOperationId' is not null or undefined\n            (0, common_1.assertParamExists)('getFundOperation', 'fundOperationId', fundOperationId);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/fund_operations/{fund_operation_id}`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)))\n                .replace(`{${\"fund_operation_id\"}}`, encodeURIComponent(String(fundOperationId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * List fund operations for an address.\n         * @summary List fund operations for an address.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address of the address to list fund operations for.\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listFundOperations: async (walletId, addressId, limit, page, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('listFundOperations', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('listFundOperations', 'addressId', addressId);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/fund_operations`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (page !== undefined) {\n                localVarQueryParameter['page'] = page;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.FundApiAxiosParamCreator = FundApiAxiosParamCreator;\n/**\n * FundApi - functional programming interface\n * @export\n */\nconst FundApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.FundApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * Create a new fund operation with an address.\n         * @summary Create a new fund operation.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address to be funded.\n         * @param {CreateFundOperationRequest} createFundOperationRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async createFundOperation(walletId, addressId, createFundOperationRequest, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.createFundOperation(walletId, addressId, createFundOperationRequest, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['FundApi.createFundOperation']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Create a new fund operation with an address.\n         * @summary Create a Fund Operation quote.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address to be funded.\n         * @param {CreateFundQuoteRequest} createFundQuoteRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async createFundQuote(walletId, addressId, createFundQuoteRequest, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.createFundQuote(walletId, addressId, createFundQuoteRequest, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['FundApi.createFundQuote']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Get fund operation.\n         * @summary Get fund operation.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address of the address that created the fund operation.\n         * @param {string} fundOperationId The ID of the fund operation to fetch.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async getFundOperation(walletId, addressId, fundOperationId, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getFundOperation(walletId, addressId, fundOperationId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['FundApi.getFundOperation']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * List fund operations for an address.\n         * @summary List fund operations for an address.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address of the address to list fund operations for.\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async listFundOperations(walletId, addressId, limit, page, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.listFundOperations(walletId, addressId, limit, page, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['FundApi.listFundOperations']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.FundApiFp = FundApiFp;\n/**\n * FundApi - factory interface\n * @export\n */\nconst FundApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.FundApiFp)(configuration);\n    return {\n        /**\n         * Create a new fund operation with an address.\n         * @summary Create a new fund operation.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address to be funded.\n         * @param {CreateFundOperationRequest} createFundOperationRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createFundOperation(walletId, addressId, createFundOperationRequest, options) {\n            return localVarFp.createFundOperation(walletId, addressId, createFundOperationRequest, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Create a new fund operation with an address.\n         * @summary Create a Fund Operation quote.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address to be funded.\n         * @param {CreateFundQuoteRequest} createFundQuoteRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createFundQuote(walletId, addressId, createFundQuoteRequest, options) {\n            return localVarFp.createFundQuote(walletId, addressId, createFundQuoteRequest, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Get fund operation.\n         * @summary Get fund operation.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address of the address that created the fund operation.\n         * @param {string} fundOperationId The ID of the fund operation to fetch.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getFundOperation(walletId, addressId, fundOperationId, options) {\n            return localVarFp.getFundOperation(walletId, addressId, fundOperationId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * List fund operations for an address.\n         * @summary List fund operations for an address.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address of the address to list fund operations for.\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listFundOperations(walletId, addressId, limit, page, options) {\n            return localVarFp.listFundOperations(walletId, addressId, limit, page, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.FundApiFactory = FundApiFactory;\n/**\n * FundApi - object-oriented interface\n * @export\n * @class FundApi\n * @extends {BaseAPI}\n */\nclass FundApi extends base_1.BaseAPI {\n    /**\n     * Create a new fund operation with an address.\n     * @summary Create a new fund operation.\n     * @param {string} walletId The ID of the wallet the address belongs to.\n     * @param {string} addressId The onchain address to be funded.\n     * @param {CreateFundOperationRequest} createFundOperationRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof FundApi\n     */\n    createFundOperation(walletId, addressId, createFundOperationRequest, options) {\n        return (0, exports.FundApiFp)(this.configuration).createFundOperation(walletId, addressId, createFundOperationRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Create a new fund operation with an address.\n     * @summary Create a Fund Operation quote.\n     * @param {string} walletId The ID of the wallet the address belongs to.\n     * @param {string} addressId The onchain address to be funded.\n     * @param {CreateFundQuoteRequest} createFundQuoteRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof FundApi\n     */\n    createFundQuote(walletId, addressId, createFundQuoteRequest, options) {\n        return (0, exports.FundApiFp)(this.configuration).createFundQuote(walletId, addressId, createFundQuoteRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Get fund operation.\n     * @summary Get fund operation.\n     * @param {string} walletId The ID of the wallet the address belongs to.\n     * @param {string} addressId The onchain address of the address that created the fund operation.\n     * @param {string} fundOperationId The ID of the fund operation to fetch.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof FundApi\n     */\n    getFundOperation(walletId, addressId, fundOperationId, options) {\n        return (0, exports.FundApiFp)(this.configuration).getFundOperation(walletId, addressId, fundOperationId, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * List fund operations for an address.\n     * @summary List fund operations for an address.\n     * @param {string} walletId The ID of the wallet the address belongs to.\n     * @param {string} addressId The onchain address of the address to list fund operations for.\n     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof FundApi\n     */\n    listFundOperations(walletId, addressId, limit, page, options) {\n        return (0, exports.FundApiFp)(this.configuration).listFundOperations(walletId, addressId, limit, page, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.FundApi = FundApi;\n/**\n * MPCWalletStakeApi - axios parameter creator\n * @export\n */\nconst MPCWalletStakeApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Broadcast a staking operation.\n         * @summary Broadcast a staking operation\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The ID of the address the staking operation belongs to.\n         * @param {string} stakingOperationId The ID of the staking operation to broadcast.\n         * @param {BroadcastStakingOperationRequest} broadcastStakingOperationRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        broadcastStakingOperation: async (walletId, addressId, stakingOperationId, broadcastStakingOperationRequest, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('broadcastStakingOperation', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('broadcastStakingOperation', 'addressId', addressId);\n            // verify required parameter 'stakingOperationId' is not null or undefined\n            (0, common_1.assertParamExists)('broadcastStakingOperation', 'stakingOperationId', stakingOperationId);\n            // verify required parameter 'broadcastStakingOperationRequest' is not null or undefined\n            (0, common_1.assertParamExists)('broadcastStakingOperation', 'broadcastStakingOperationRequest', broadcastStakingOperationRequest);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/staking_operations/{staking_operation_id}/broadcast`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)))\n                .replace(`{${\"staking_operation_id\"}}`, encodeURIComponent(String(stakingOperationId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(broadcastStakingOperationRequest, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Create a new staking operation.\n         * @summary Create a new staking operation for an address\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The ID of the address to create the staking operation for.\n         * @param {CreateStakingOperationRequest} createStakingOperationRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createStakingOperation: async (walletId, addressId, createStakingOperationRequest, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('createStakingOperation', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('createStakingOperation', 'addressId', addressId);\n            // verify required parameter 'createStakingOperationRequest' is not null or undefined\n            (0, common_1.assertParamExists)('createStakingOperation', 'createStakingOperationRequest', createStakingOperationRequest);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/staking_operations`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createStakingOperationRequest, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Get the latest state of a staking operation.\n         * @summary Get the latest state of a staking operation\n         * @param {string} walletId The ID of the wallet the address belongs to\n         * @param {string} addressId The ID of the address to fetch the staking operation for.\n         * @param {string} stakingOperationId The ID of the staking operation.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getStakingOperation: async (walletId, addressId, stakingOperationId, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('getStakingOperation', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('getStakingOperation', 'addressId', addressId);\n            // verify required parameter 'stakingOperationId' is not null or undefined\n            (0, common_1.assertParamExists)('getStakingOperation', 'stakingOperationId', stakingOperationId);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/staking_operations/{staking_operation_id}`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)))\n                .replace(`{${\"staking_operation_id\"}}`, encodeURIComponent(String(stakingOperationId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.MPCWalletStakeApiAxiosParamCreator = MPCWalletStakeApiAxiosParamCreator;\n/**\n * MPCWalletStakeApi - functional programming interface\n * @export\n */\nconst MPCWalletStakeApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.MPCWalletStakeApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * Broadcast a staking operation.\n         * @summary Broadcast a staking operation\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The ID of the address the staking operation belongs to.\n         * @param {string} stakingOperationId The ID of the staking operation to broadcast.\n         * @param {BroadcastStakingOperationRequest} broadcastStakingOperationRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async broadcastStakingOperation(walletId, addressId, stakingOperationId, broadcastStakingOperationRequest, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.broadcastStakingOperation(walletId, addressId, stakingOperationId, broadcastStakingOperationRequest, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['MPCWalletStakeApi.broadcastStakingOperation']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Create a new staking operation.\n         * @summary Create a new staking operation for an address\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The ID of the address to create the staking operation for.\n         * @param {CreateStakingOperationRequest} createStakingOperationRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async createStakingOperation(walletId, addressId, createStakingOperationRequest, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.createStakingOperation(walletId, addressId, createStakingOperationRequest, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['MPCWalletStakeApi.createStakingOperation']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Get the latest state of a staking operation.\n         * @summary Get the latest state of a staking operation\n         * @param {string} walletId The ID of the wallet the address belongs to\n         * @param {string} addressId The ID of the address to fetch the staking operation for.\n         * @param {string} stakingOperationId The ID of the staking operation.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async getStakingOperation(walletId, addressId, stakingOperationId, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getStakingOperation(walletId, addressId, stakingOperationId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['MPCWalletStakeApi.getStakingOperation']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.MPCWalletStakeApiFp = MPCWalletStakeApiFp;\n/**\n * MPCWalletStakeApi - factory interface\n * @export\n */\nconst MPCWalletStakeApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.MPCWalletStakeApiFp)(configuration);\n    return {\n        /**\n         * Broadcast a staking operation.\n         * @summary Broadcast a staking operation\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The ID of the address the staking operation belongs to.\n         * @param {string} stakingOperationId The ID of the staking operation to broadcast.\n         * @param {BroadcastStakingOperationRequest} broadcastStakingOperationRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        broadcastStakingOperation(walletId, addressId, stakingOperationId, broadcastStakingOperationRequest, options) {\n            return localVarFp.broadcastStakingOperation(walletId, addressId, stakingOperationId, broadcastStakingOperationRequest, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Create a new staking operation.\n         * @summary Create a new staking operation for an address\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The ID of the address to create the staking operation for.\n         * @param {CreateStakingOperationRequest} createStakingOperationRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createStakingOperation(walletId, addressId, createStakingOperationRequest, options) {\n            return localVarFp.createStakingOperation(walletId, addressId, createStakingOperationRequest, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Get the latest state of a staking operation.\n         * @summary Get the latest state of a staking operation\n         * @param {string} walletId The ID of the wallet the address belongs to\n         * @param {string} addressId The ID of the address to fetch the staking operation for.\n         * @param {string} stakingOperationId The ID of the staking operation.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getStakingOperation(walletId, addressId, stakingOperationId, options) {\n            return localVarFp.getStakingOperation(walletId, addressId, stakingOperationId, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.MPCWalletStakeApiFactory = MPCWalletStakeApiFactory;\n/**\n * MPCWalletStakeApi - object-oriented interface\n * @export\n * @class MPCWalletStakeApi\n * @extends {BaseAPI}\n */\nclass MPCWalletStakeApi extends base_1.BaseAPI {\n    /**\n     * Broadcast a staking operation.\n     * @summary Broadcast a staking operation\n     * @param {string} walletId The ID of the wallet the address belongs to.\n     * @param {string} addressId The ID of the address the staking operation belongs to.\n     * @param {string} stakingOperationId The ID of the staking operation to broadcast.\n     * @param {BroadcastStakingOperationRequest} broadcastStakingOperationRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof MPCWalletStakeApi\n     */\n    broadcastStakingOperation(walletId, addressId, stakingOperationId, broadcastStakingOperationRequest, options) {\n        return (0, exports.MPCWalletStakeApiFp)(this.configuration).broadcastStakingOperation(walletId, addressId, stakingOperationId, broadcastStakingOperationRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Create a new staking operation.\n     * @summary Create a new staking operation for an address\n     * @param {string} walletId The ID of the wallet the address belongs to.\n     * @param {string} addressId The ID of the address to create the staking operation for.\n     * @param {CreateStakingOperationRequest} createStakingOperationRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof MPCWalletStakeApi\n     */\n    createStakingOperation(walletId, addressId, createStakingOperationRequest, options) {\n        return (0, exports.MPCWalletStakeApiFp)(this.configuration).createStakingOperation(walletId, addressId, createStakingOperationRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Get the latest state of a staking operation.\n     * @summary Get the latest state of a staking operation\n     * @param {string} walletId The ID of the wallet the address belongs to\n     * @param {string} addressId The ID of the address to fetch the staking operation for.\n     * @param {string} stakingOperationId The ID of the staking operation.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof MPCWalletStakeApi\n     */\n    getStakingOperation(walletId, addressId, stakingOperationId, options) {\n        return (0, exports.MPCWalletStakeApiFp)(this.configuration).getStakingOperation(walletId, addressId, stakingOperationId, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.MPCWalletStakeApi = MPCWalletStakeApi;\n/**\n * NetworksApi - axios parameter creator\n * @export\n */\nconst NetworksApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Get network\n         * @summary Get network by ID\n         * @param {string} networkId The ID of the network to fetch.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getNetwork: async (networkId, options = {}) => {\n            // verify required parameter 'networkId' is not null or undefined\n            (0, common_1.assertParamExists)('getNetwork', 'networkId', networkId);\n            const localVarPath = `/v1/networks/{network_id}`\n                .replace(`{${\"network_id\"}}`, encodeURIComponent(String(networkId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.NetworksApiAxiosParamCreator = NetworksApiAxiosParamCreator;\n/**\n * NetworksApi - functional programming interface\n * @export\n */\nconst NetworksApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.NetworksApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * Get network\n         * @summary Get network by ID\n         * @param {string} networkId The ID of the network to fetch.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async getNetwork(networkId, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getNetwork(networkId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['NetworksApi.getNetwork']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.NetworksApiFp = NetworksApiFp;\n/**\n * NetworksApi - factory interface\n * @export\n */\nconst NetworksApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.NetworksApiFp)(configuration);\n    return {\n        /**\n         * Get network\n         * @summary Get network by ID\n         * @param {string} networkId The ID of the network to fetch.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getNetwork(networkId, options) {\n            return localVarFp.getNetwork(networkId, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.NetworksApiFactory = NetworksApiFactory;\n/**\n * NetworksApi - object-oriented interface\n * @export\n * @class NetworksApi\n * @extends {BaseAPI}\n */\nclass NetworksApi extends base_1.BaseAPI {\n    /**\n     * Get network\n     * @summary Get network by ID\n     * @param {string} networkId The ID of the network to fetch.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof NetworksApi\n     */\n    getNetwork(networkId, options) {\n        return (0, exports.NetworksApiFp)(this.configuration).getNetwork(networkId, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.NetworksApi = NetworksApi;\n/**\n * OnchainIdentityApi - axios parameter creator\n * @export\n */\nconst OnchainIdentityApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Obtains onchain identity for an address on a specific network\n         * @summary Obtains onchain identity for an address on a specific network\n         * @param {string} networkId The ID of the blockchain network\n         * @param {string} addressId The ID of the address to fetch the identity for\n         * @param {Array<ResolveIdentityByAddressRolesEnum>} [roles] A filter by role of the names related to this address (managed or owned)\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        resolveIdentityByAddress: async (networkId, addressId, roles, limit, page, options = {}) => {\n            // verify required parameter 'networkId' is not null or undefined\n            (0, common_1.assertParamExists)('resolveIdentityByAddress', 'networkId', networkId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('resolveIdentityByAddress', 'addressId', addressId);\n            const localVarPath = `/v1/networks/{network_id}/addresses/{address_id}/identity`\n                .replace(`{${\"network_id\"}}`, encodeURIComponent(String(networkId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            if (roles) {\n                localVarQueryParameter['roles'] = roles.join(base_1.COLLECTION_FORMATS.csv);\n            }\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (page !== undefined) {\n                localVarQueryParameter['page'] = page;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.OnchainIdentityApiAxiosParamCreator = OnchainIdentityApiAxiosParamCreator;\n/**\n * OnchainIdentityApi - functional programming interface\n * @export\n */\nconst OnchainIdentityApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.OnchainIdentityApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * Obtains onchain identity for an address on a specific network\n         * @summary Obtains onchain identity for an address on a specific network\n         * @param {string} networkId The ID of the blockchain network\n         * @param {string} addressId The ID of the address to fetch the identity for\n         * @param {Array<ResolveIdentityByAddressRolesEnum>} [roles] A filter by role of the names related to this address (managed or owned)\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async resolveIdentityByAddress(networkId, addressId, roles, limit, page, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.resolveIdentityByAddress(networkId, addressId, roles, limit, page, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['OnchainIdentityApi.resolveIdentityByAddress']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.OnchainIdentityApiFp = OnchainIdentityApiFp;\n/**\n * OnchainIdentityApi - factory interface\n * @export\n */\nconst OnchainIdentityApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.OnchainIdentityApiFp)(configuration);\n    return {\n        /**\n         * Obtains onchain identity for an address on a specific network\n         * @summary Obtains onchain identity for an address on a specific network\n         * @param {string} networkId The ID of the blockchain network\n         * @param {string} addressId The ID of the address to fetch the identity for\n         * @param {Array<ResolveIdentityByAddressRolesEnum>} [roles] A filter by role of the names related to this address (managed or owned)\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        resolveIdentityByAddress(networkId, addressId, roles, limit, page, options) {\n            return localVarFp.resolveIdentityByAddress(networkId, addressId, roles, limit, page, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.OnchainIdentityApiFactory = OnchainIdentityApiFactory;\n/**\n * OnchainIdentityApi - object-oriented interface\n * @export\n * @class OnchainIdentityApi\n * @extends {BaseAPI}\n */\nclass OnchainIdentityApi extends base_1.BaseAPI {\n    /**\n     * Obtains onchain identity for an address on a specific network\n     * @summary Obtains onchain identity for an address on a specific network\n     * @param {string} networkId The ID of the blockchain network\n     * @param {string} addressId The ID of the address to fetch the identity for\n     * @param {Array<ResolveIdentityByAddressRolesEnum>} [roles] A filter by role of the names related to this address (managed or owned)\n     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof OnchainIdentityApi\n     */\n    resolveIdentityByAddress(networkId, addressId, roles, limit, page, options) {\n        return (0, exports.OnchainIdentityApiFp)(this.configuration).resolveIdentityByAddress(networkId, addressId, roles, limit, page, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.OnchainIdentityApi = OnchainIdentityApi;\n/**\n * @export\n */\nexports.ResolveIdentityByAddressRolesEnum = {\n    Managed: 'managed',\n    Owned: 'owned'\n};\n/**\n * ReputationApi - axios parameter creator\n * @export\n */\nconst ReputationApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Get the onchain reputation of an external address\n         * @summary Get the onchain reputation of an external address\n         * @param {string} networkId The ID of the blockchain network.\n         * @param {string} addressId The ID of the address to fetch the reputation for.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getAddressReputation: async (networkId, addressId, options = {}) => {\n            // verify required parameter 'networkId' is not null or undefined\n            (0, common_1.assertParamExists)('getAddressReputation', 'networkId', networkId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('getAddressReputation', 'addressId', addressId);\n            const localVarPath = `/v1/networks/{network_id}/addresses/{address_id}/reputation`\n                .replace(`{${\"network_id\"}}`, encodeURIComponent(String(networkId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.ReputationApiAxiosParamCreator = ReputationApiAxiosParamCreator;\n/**\n * ReputationApi - functional programming interface\n * @export\n */\nconst ReputationApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.ReputationApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * Get the onchain reputation of an external address\n         * @summary Get the onchain reputation of an external address\n         * @param {string} networkId The ID of the blockchain network.\n         * @param {string} addressId The ID of the address to fetch the reputation for.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async getAddressReputation(networkId, addressId, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getAddressReputation(networkId, addressId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['ReputationApi.getAddressReputation']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.ReputationApiFp = ReputationApiFp;\n/**\n * ReputationApi - factory interface\n * @export\n */\nconst ReputationApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.ReputationApiFp)(configuration);\n    return {\n        /**\n         * Get the onchain reputation of an external address\n         * @summary Get the onchain reputation of an external address\n         * @param {string} networkId The ID of the blockchain network.\n         * @param {string} addressId The ID of the address to fetch the reputation for.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getAddressReputation(networkId, addressId, options) {\n            return localVarFp.getAddressReputation(networkId, addressId, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.ReputationApiFactory = ReputationApiFactory;\n/**\n * ReputationApi - object-oriented interface\n * @export\n * @class ReputationApi\n * @extends {BaseAPI}\n */\nclass ReputationApi extends base_1.BaseAPI {\n    /**\n     * Get the onchain reputation of an external address\n     * @summary Get the onchain reputation of an external address\n     * @param {string} networkId The ID of the blockchain network.\n     * @param {string} addressId The ID of the address to fetch the reputation for.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ReputationApi\n     */\n    getAddressReputation(networkId, addressId, options) {\n        return (0, exports.ReputationApiFp)(this.configuration).getAddressReputation(networkId, addressId, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.ReputationApi = ReputationApi;\n/**\n * ServerSignersApi - axios parameter creator\n * @export\n */\nconst ServerSignersApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Create a new Server-Signer\n         * @summary Create a new Server-Signer\n         * @param {CreateServerSignerRequest} [createServerSignerRequest]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createServerSigner: async (createServerSignerRequest, options = {}) => {\n            const localVarPath = `/v1/server_signers`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createServerSignerRequest, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Get a server signer by ID\n         * @summary Get a server signer by ID\n         * @param {string} serverSignerId The ID of the server signer to fetch\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getServerSigner: async (serverSignerId, options = {}) => {\n            // verify required parameter 'serverSignerId' is not null or undefined\n            (0, common_1.assertParamExists)('getServerSigner', 'serverSignerId', serverSignerId);\n            const localVarPath = `/v1/server_signers/{server_signer_id}`\n                .replace(`{${\"server_signer_id\"}}`, encodeURIComponent(String(serverSignerId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * List events for a server signer\n         * @summary List events for a server signer\n         * @param {string} serverSignerId The ID of the server signer to fetch events for\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @deprecated\n         * @throws {RequiredError}\n         */\n        listServerSignerEvents: async (serverSignerId, limit, page, options = {}) => {\n            // verify required parameter 'serverSignerId' is not null or undefined\n            (0, common_1.assertParamExists)('listServerSignerEvents', 'serverSignerId', serverSignerId);\n            const localVarPath = `/v1/server_signers/{server_signer_id}/events`\n                .replace(`{${\"server_signer_id\"}}`, encodeURIComponent(String(serverSignerId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (page !== undefined) {\n                localVarQueryParameter['page'] = page;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * List server signers for the current project\n         * @summary List server signers for the current project\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listServerSigners: async (limit, page, options = {}) => {\n            const localVarPath = `/v1/server_signers`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (page !== undefined) {\n                localVarQueryParameter['page'] = page;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Submit the result of a server signer event\n         * @summary Submit the result of a server signer event\n         * @param {string} serverSignerId The ID of the server signer to submit the event result for\n         * @param {SeedCreationEventResult} [seedCreationEventResult]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        submitServerSignerSeedEventResult: async (serverSignerId, seedCreationEventResult, options = {}) => {\n            // verify required parameter 'serverSignerId' is not null or undefined\n            (0, common_1.assertParamExists)('submitServerSignerSeedEventResult', 'serverSignerId', serverSignerId);\n            const localVarPath = `/v1/server_signers/{server_signer_id}/seed_event_result`\n                .replace(`{${\"server_signer_id\"}}`, encodeURIComponent(String(serverSignerId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(seedCreationEventResult, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Submit the result of a server signer event\n         * @summary Submit the result of a server signer event\n         * @param {string} serverSignerId The ID of the server signer to submit the event result for\n         * @param {SignatureCreationEventResult} [signatureCreationEventResult]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        submitServerSignerSignatureEventResult: async (serverSignerId, signatureCreationEventResult, options = {}) => {\n            // verify required parameter 'serverSignerId' is not null or undefined\n            (0, common_1.assertParamExists)('submitServerSignerSignatureEventResult', 'serverSignerId', serverSignerId);\n            const localVarPath = `/v1/server_signers/{server_signer_id}/signature_event_result`\n                .replace(`{${\"server_signer_id\"}}`, encodeURIComponent(String(serverSignerId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(signatureCreationEventResult, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.ServerSignersApiAxiosParamCreator = ServerSignersApiAxiosParamCreator;\n/**\n * ServerSignersApi - functional programming interface\n * @export\n */\nconst ServerSignersApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.ServerSignersApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * Create a new Server-Signer\n         * @summary Create a new Server-Signer\n         * @param {CreateServerSignerRequest} [createServerSignerRequest]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async createServerSigner(createServerSignerRequest, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.createServerSigner(createServerSignerRequest, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['ServerSignersApi.createServerSigner']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Get a server signer by ID\n         * @summary Get a server signer by ID\n         * @param {string} serverSignerId The ID of the server signer to fetch\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async getServerSigner(serverSignerId, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getServerSigner(serverSignerId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['ServerSignersApi.getServerSigner']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * List events for a server signer\n         * @summary List events for a server signer\n         * @param {string} serverSignerId The ID of the server signer to fetch events for\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @deprecated\n         * @throws {RequiredError}\n         */\n        async listServerSignerEvents(serverSignerId, limit, page, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.listServerSignerEvents(serverSignerId, limit, page, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['ServerSignersApi.listServerSignerEvents']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * List server signers for the current project\n         * @summary List server signers for the current project\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async listServerSigners(limit, page, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.listServerSigners(limit, page, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['ServerSignersApi.listServerSigners']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Submit the result of a server signer event\n         * @summary Submit the result of a server signer event\n         * @param {string} serverSignerId The ID of the server signer to submit the event result for\n         * @param {SeedCreationEventResult} [seedCreationEventResult]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async submitServerSignerSeedEventResult(serverSignerId, seedCreationEventResult, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.submitServerSignerSeedEventResult(serverSignerId, seedCreationEventResult, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['ServerSignersApi.submitServerSignerSeedEventResult']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Submit the result of a server signer event\n         * @summary Submit the result of a server signer event\n         * @param {string} serverSignerId The ID of the server signer to submit the event result for\n         * @param {SignatureCreationEventResult} [signatureCreationEventResult]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async submitServerSignerSignatureEventResult(serverSignerId, signatureCreationEventResult, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.submitServerSignerSignatureEventResult(serverSignerId, signatureCreationEventResult, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['ServerSignersApi.submitServerSignerSignatureEventResult']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.ServerSignersApiFp = ServerSignersApiFp;\n/**\n * ServerSignersApi - factory interface\n * @export\n */\nconst ServerSignersApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.ServerSignersApiFp)(configuration);\n    return {\n        /**\n         * Create a new Server-Signer\n         * @summary Create a new Server-Signer\n         * @param {CreateServerSignerRequest} [createServerSignerRequest]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createServerSigner(createServerSignerRequest, options) {\n            return localVarFp.createServerSigner(createServerSignerRequest, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Get a server signer by ID\n         * @summary Get a server signer by ID\n         * @param {string} serverSignerId The ID of the server signer to fetch\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getServerSigner(serverSignerId, options) {\n            return localVarFp.getServerSigner(serverSignerId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * List events for a server signer\n         * @summary List events for a server signer\n         * @param {string} serverSignerId The ID of the server signer to fetch events for\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @deprecated\n         * @throws {RequiredError}\n         */\n        listServerSignerEvents(serverSignerId, limit, page, options) {\n            return localVarFp.listServerSignerEvents(serverSignerId, limit, page, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * List server signers for the current project\n         * @summary List server signers for the current project\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listServerSigners(limit, page, options) {\n            return localVarFp.listServerSigners(limit, page, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Submit the result of a server signer event\n         * @summary Submit the result of a server signer event\n         * @param {string} serverSignerId The ID of the server signer to submit the event result for\n         * @param {SeedCreationEventResult} [seedCreationEventResult]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        submitServerSignerSeedEventResult(serverSignerId, seedCreationEventResult, options) {\n            return localVarFp.submitServerSignerSeedEventResult(serverSignerId, seedCreationEventResult, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Submit the result of a server signer event\n         * @summary Submit the result of a server signer event\n         * @param {string} serverSignerId The ID of the server signer to submit the event result for\n         * @param {SignatureCreationEventResult} [signatureCreationEventResult]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        submitServerSignerSignatureEventResult(serverSignerId, signatureCreationEventResult, options) {\n            return localVarFp.submitServerSignerSignatureEventResult(serverSignerId, signatureCreationEventResult, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.ServerSignersApiFactory = ServerSignersApiFactory;\n/**\n * ServerSignersApi - object-oriented interface\n * @export\n * @class ServerSignersApi\n * @extends {BaseAPI}\n */\nclass ServerSignersApi extends base_1.BaseAPI {\n    /**\n     * Create a new Server-Signer\n     * @summary Create a new Server-Signer\n     * @param {CreateServerSignerRequest} [createServerSignerRequest]\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ServerSignersApi\n     */\n    createServerSigner(createServerSignerRequest, options) {\n        return (0, exports.ServerSignersApiFp)(this.configuration).createServerSigner(createServerSignerRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Get a server signer by ID\n     * @summary Get a server signer by ID\n     * @param {string} serverSignerId The ID of the server signer to fetch\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ServerSignersApi\n     */\n    getServerSigner(serverSignerId, options) {\n        return (0, exports.ServerSignersApiFp)(this.configuration).getServerSigner(serverSignerId, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * List events for a server signer\n     * @summary List events for a server signer\n     * @param {string} serverSignerId The ID of the server signer to fetch events for\n     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n     * @param {*} [options] Override http request option.\n     * @deprecated\n     * @throws {RequiredError}\n     * @memberof ServerSignersApi\n     */\n    listServerSignerEvents(serverSignerId, limit, page, options) {\n        return (0, exports.ServerSignersApiFp)(this.configuration).listServerSignerEvents(serverSignerId, limit, page, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * List server signers for the current project\n     * @summary List server signers for the current project\n     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ServerSignersApi\n     */\n    listServerSigners(limit, page, options) {\n        return (0, exports.ServerSignersApiFp)(this.configuration).listServerSigners(limit, page, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Submit the result of a server signer event\n     * @summary Submit the result of a server signer event\n     * @param {string} serverSignerId The ID of the server signer to submit the event result for\n     * @param {SeedCreationEventResult} [seedCreationEventResult]\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ServerSignersApi\n     */\n    submitServerSignerSeedEventResult(serverSignerId, seedCreationEventResult, options) {\n        return (0, exports.ServerSignersApiFp)(this.configuration).submitServerSignerSeedEventResult(serverSignerId, seedCreationEventResult, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Submit the result of a server signer event\n     * @summary Submit the result of a server signer event\n     * @param {string} serverSignerId The ID of the server signer to submit the event result for\n     * @param {SignatureCreationEventResult} [signatureCreationEventResult]\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ServerSignersApi\n     */\n    submitServerSignerSignatureEventResult(serverSignerId, signatureCreationEventResult, options) {\n        return (0, exports.ServerSignersApiFp)(this.configuration).submitServerSignerSignatureEventResult(serverSignerId, signatureCreationEventResult, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.ServerSignersApi = ServerSignersApi;\n/**\n * SmartContractsApi - axios parameter creator\n * @export\n */\nconst SmartContractsApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Compile a smart contract\n         * @summary Compile a smart contract\n         * @param {CompileSmartContractRequest} compileSmartContractRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        compileSmartContract: async (compileSmartContractRequest, options = {}) => {\n            // verify required parameter 'compileSmartContractRequest' is not null or undefined\n            (0, common_1.assertParamExists)('compileSmartContract', 'compileSmartContractRequest', compileSmartContractRequest);\n            const localVarPath = `/v1/smart_contracts/compile`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(compileSmartContractRequest, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Create a new smart contract\n         * @summary Create a new smart contract\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The ID of the address to deploy the smart contract from.\n         * @param {CreateSmartContractRequest} createSmartContractRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createSmartContract: async (walletId, addressId, createSmartContractRequest, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('createSmartContract', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('createSmartContract', 'addressId', addressId);\n            // verify required parameter 'createSmartContractRequest' is not null or undefined\n            (0, common_1.assertParamExists)('createSmartContract', 'createSmartContractRequest', createSmartContractRequest);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/smart_contracts`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createSmartContractRequest, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Deploys a smart contract, by broadcasting the transaction to the network.\n         * @summary Deploy a smart contract\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The ID of the address to broadcast the transaction from.\n         * @param {string} smartContractId The UUID of the smart contract to broadcast the transaction to.\n         * @param {DeploySmartContractRequest} deploySmartContractRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        deploySmartContract: async (walletId, addressId, smartContractId, deploySmartContractRequest, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('deploySmartContract', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('deploySmartContract', 'addressId', addressId);\n            // verify required parameter 'smartContractId' is not null or undefined\n            (0, common_1.assertParamExists)('deploySmartContract', 'smartContractId', smartContractId);\n            // verify required parameter 'deploySmartContractRequest' is not null or undefined\n            (0, common_1.assertParamExists)('deploySmartContract', 'deploySmartContractRequest', deploySmartContractRequest);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/smart_contracts/{smart_contract_id}/deploy`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)))\n                .replace(`{${\"smart_contract_id\"}}`, encodeURIComponent(String(smartContractId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(deploySmartContractRequest, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Get a specific smart contract deployed by address.\n         * @summary Get a specific smart contract deployed by address\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The ID of the address to fetch the smart contract for.\n         * @param {string} smartContractId The UUID of the smart contract to fetch.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getSmartContract: async (walletId, addressId, smartContractId, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('getSmartContract', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('getSmartContract', 'addressId', addressId);\n            // verify required parameter 'smartContractId' is not null or undefined\n            (0, common_1.assertParamExists)('getSmartContract', 'smartContractId', smartContractId);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/smart_contracts/{smart_contract_id}`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)))\n                .replace(`{${\"smart_contract_id\"}}`, encodeURIComponent(String(smartContractId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * List smart contracts\n         * @summary List smart contracts\n         * @param {string} [page] Pagination token for retrieving the next set of results\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listSmartContracts: async (page, options = {}) => {\n            const localVarPath = `/v1/smart_contracts`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            if (page !== undefined) {\n                localVarQueryParameter['page'] = page;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Perform a read operation on a smart contract without creating a transaction\n         * @summary Read data from a smart contract\n         * @param {string} networkId\n         * @param {string} contractAddress\n         * @param {ReadContractRequest} readContractRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        readContract: async (networkId, contractAddress, readContractRequest, options = {}) => {\n            // verify required parameter 'networkId' is not null or undefined\n            (0, common_1.assertParamExists)('readContract', 'networkId', networkId);\n            // verify required parameter 'contractAddress' is not null or undefined\n            (0, common_1.assertParamExists)('readContract', 'contractAddress', contractAddress);\n            // verify required parameter 'readContractRequest' is not null or undefined\n            (0, common_1.assertParamExists)('readContract', 'readContractRequest', readContractRequest);\n            const localVarPath = `/v1/networks/{network_id}/smart_contracts/{contract_address}/read`\n                .replace(`{${\"network_id\"}}`, encodeURIComponent(String(networkId)))\n                .replace(`{${\"contract_address\"}}`, encodeURIComponent(String(contractAddress)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(readContractRequest, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Register a smart contract\n         * @summary Register a smart contract\n         * @param {string} networkId The ID of the network to fetch.\n         * @param {string} contractAddress EVM address of the smart contract (42 characters, including \\&#39;0x\\&#39;, in lowercase)\n         * @param {RegisterSmartContractRequest} [registerSmartContractRequest]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        registerSmartContract: async (networkId, contractAddress, registerSmartContractRequest, options = {}) => {\n            // verify required parameter 'networkId' is not null or undefined\n            (0, common_1.assertParamExists)('registerSmartContract', 'networkId', networkId);\n            // verify required parameter 'contractAddress' is not null or undefined\n            (0, common_1.assertParamExists)('registerSmartContract', 'contractAddress', contractAddress);\n            const localVarPath = `/v1/networks/{network_id}/smart_contracts/{contract_address}/register`\n                .replace(`{${\"network_id\"}}`, encodeURIComponent(String(networkId)))\n                .replace(`{${\"contract_address\"}}`, encodeURIComponent(String(contractAddress)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(registerSmartContractRequest, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Update a smart contract\n         * @summary Update a smart contract\n         * @param {string} networkId The ID of the network to fetch.\n         * @param {string} contractAddress EVM address of the smart contract (42 characters, including \\&#39;0x\\&#39;, in lowercase)\n         * @param {UpdateSmartContractRequest} [updateSmartContractRequest]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        updateSmartContract: async (networkId, contractAddress, updateSmartContractRequest, options = {}) => {\n            // verify required parameter 'networkId' is not null or undefined\n            (0, common_1.assertParamExists)('updateSmartContract', 'networkId', networkId);\n            // verify required parameter 'contractAddress' is not null or undefined\n            (0, common_1.assertParamExists)('updateSmartContract', 'contractAddress', contractAddress);\n            const localVarPath = `/v1/networks/{network_id}/smart_contracts/{contract_address}`\n                .replace(`{${\"network_id\"}}`, encodeURIComponent(String(networkId)))\n                .replace(`{${\"contract_address\"}}`, encodeURIComponent(String(contractAddress)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updateSmartContractRequest, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.SmartContractsApiAxiosParamCreator = SmartContractsApiAxiosParamCreator;\n/**\n * SmartContractsApi - functional programming interface\n * @export\n */\nconst SmartContractsApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.SmartContractsApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * Compile a smart contract\n         * @summary Compile a smart contract\n         * @param {CompileSmartContractRequest} compileSmartContractRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async compileSmartContract(compileSmartContractRequest, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.compileSmartContract(compileSmartContractRequest, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['SmartContractsApi.compileSmartContract']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Create a new smart contract\n         * @summary Create a new smart contract\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The ID of the address to deploy the smart contract from.\n         * @param {CreateSmartContractRequest} createSmartContractRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async createSmartContract(walletId, addressId, createSmartContractRequest, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.createSmartContract(walletId, addressId, createSmartContractRequest, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['SmartContractsApi.createSmartContract']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Deploys a smart contract, by broadcasting the transaction to the network.\n         * @summary Deploy a smart contract\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The ID of the address to broadcast the transaction from.\n         * @param {string} smartContractId The UUID of the smart contract to broadcast the transaction to.\n         * @param {DeploySmartContractRequest} deploySmartContractRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async deploySmartContract(walletId, addressId, smartContractId, deploySmartContractRequest, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.deploySmartContract(walletId, addressId, smartContractId, deploySmartContractRequest, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['SmartContractsApi.deploySmartContract']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Get a specific smart contract deployed by address.\n         * @summary Get a specific smart contract deployed by address\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The ID of the address to fetch the smart contract for.\n         * @param {string} smartContractId The UUID of the smart contract to fetch.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async getSmartContract(walletId, addressId, smartContractId, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getSmartContract(walletId, addressId, smartContractId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['SmartContractsApi.getSmartContract']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * List smart contracts\n         * @summary List smart contracts\n         * @param {string} [page] Pagination token for retrieving the next set of results\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async listSmartContracts(page, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.listSmartContracts(page, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['SmartContractsApi.listSmartContracts']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Perform a read operation on a smart contract without creating a transaction\n         * @summary Read data from a smart contract\n         * @param {string} networkId\n         * @param {string} contractAddress\n         * @param {ReadContractRequest} readContractRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async readContract(networkId, contractAddress, readContractRequest, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.readContract(networkId, contractAddress, readContractRequest, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['SmartContractsApi.readContract']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Register a smart contract\n         * @summary Register a smart contract\n         * @param {string} networkId The ID of the network to fetch.\n         * @param {string} contractAddress EVM address of the smart contract (42 characters, including \\&#39;0x\\&#39;, in lowercase)\n         * @param {RegisterSmartContractRequest} [registerSmartContractRequest]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async registerSmartContract(networkId, contractAddress, registerSmartContractRequest, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.registerSmartContract(networkId, contractAddress, registerSmartContractRequest, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['SmartContractsApi.registerSmartContract']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Update a smart contract\n         * @summary Update a smart contract\n         * @param {string} networkId The ID of the network to fetch.\n         * @param {string} contractAddress EVM address of the smart contract (42 characters, including \\&#39;0x\\&#39;, in lowercase)\n         * @param {UpdateSmartContractRequest} [updateSmartContractRequest]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async updateSmartContract(networkId, contractAddress, updateSmartContractRequest, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSmartContract(networkId, contractAddress, updateSmartContractRequest, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['SmartContractsApi.updateSmartContract']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.SmartContractsApiFp = SmartContractsApiFp;\n/**\n * SmartContractsApi - factory interface\n * @export\n */\nconst SmartContractsApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.SmartContractsApiFp)(configuration);\n    return {\n        /**\n         * Compile a smart contract\n         * @summary Compile a smart contract\n         * @param {CompileSmartContractRequest} compileSmartContractRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        compileSmartContract(compileSmartContractRequest, options) {\n            return localVarFp.compileSmartContract(compileSmartContractRequest, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Create a new smart contract\n         * @summary Create a new smart contract\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The ID of the address to deploy the smart contract from.\n         * @param {CreateSmartContractRequest} createSmartContractRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createSmartContract(walletId, addressId, createSmartContractRequest, options) {\n            return localVarFp.createSmartContract(walletId, addressId, createSmartContractRequest, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Deploys a smart contract, by broadcasting the transaction to the network.\n         * @summary Deploy a smart contract\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The ID of the address to broadcast the transaction from.\n         * @param {string} smartContractId The UUID of the smart contract to broadcast the transaction to.\n         * @param {DeploySmartContractRequest} deploySmartContractRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        deploySmartContract(walletId, addressId, smartContractId, deploySmartContractRequest, options) {\n            return localVarFp.deploySmartContract(walletId, addressId, smartContractId, deploySmartContractRequest, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Get a specific smart contract deployed by address.\n         * @summary Get a specific smart contract deployed by address\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The ID of the address to fetch the smart contract for.\n         * @param {string} smartContractId The UUID of the smart contract to fetch.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getSmartContract(walletId, addressId, smartContractId, options) {\n            return localVarFp.getSmartContract(walletId, addressId, smartContractId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * List smart contracts\n         * @summary List smart contracts\n         * @param {string} [page] Pagination token for retrieving the next set of results\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listSmartContracts(page, options) {\n            return localVarFp.listSmartContracts(page, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Perform a read operation on a smart contract without creating a transaction\n         * @summary Read data from a smart contract\n         * @param {string} networkId\n         * @param {string} contractAddress\n         * @param {ReadContractRequest} readContractRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        readContract(networkId, contractAddress, readContractRequest, options) {\n            return localVarFp.readContract(networkId, contractAddress, readContractRequest, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Register a smart contract\n         * @summary Register a smart contract\n         * @param {string} networkId The ID of the network to fetch.\n         * @param {string} contractAddress EVM address of the smart contract (42 characters, including \\&#39;0x\\&#39;, in lowercase)\n         * @param {RegisterSmartContractRequest} [registerSmartContractRequest]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        registerSmartContract(networkId, contractAddress, registerSmartContractRequest, options) {\n            return localVarFp.registerSmartContract(networkId, contractAddress, registerSmartContractRequest, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Update a smart contract\n         * @summary Update a smart contract\n         * @param {string} networkId The ID of the network to fetch.\n         * @param {string} contractAddress EVM address of the smart contract (42 characters, including \\&#39;0x\\&#39;, in lowercase)\n         * @param {UpdateSmartContractRequest} [updateSmartContractRequest]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        updateSmartContract(networkId, contractAddress, updateSmartContractRequest, options) {\n            return localVarFp.updateSmartContract(networkId, contractAddress, updateSmartContractRequest, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.SmartContractsApiFactory = SmartContractsApiFactory;\n/**\n * SmartContractsApi - object-oriented interface\n * @export\n * @class SmartContractsApi\n * @extends {BaseAPI}\n */\nclass SmartContractsApi extends base_1.BaseAPI {\n    /**\n     * Compile a smart contract\n     * @summary Compile a smart contract\n     * @param {CompileSmartContractRequest} compileSmartContractRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof SmartContractsApi\n     */\n    compileSmartContract(compileSmartContractRequest, options) {\n        return (0, exports.SmartContractsApiFp)(this.configuration).compileSmartContract(compileSmartContractRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Create a new smart contract\n     * @summary Create a new smart contract\n     * @param {string} walletId The ID of the wallet the address belongs to.\n     * @param {string} addressId The ID of the address to deploy the smart contract from.\n     * @param {CreateSmartContractRequest} createSmartContractRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof SmartContractsApi\n     */\n    createSmartContract(walletId, addressId, createSmartContractRequest, options) {\n        return (0, exports.SmartContractsApiFp)(this.configuration).createSmartContract(walletId, addressId, createSmartContractRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Deploys a smart contract, by broadcasting the transaction to the network.\n     * @summary Deploy a smart contract\n     * @param {string} walletId The ID of the wallet the address belongs to.\n     * @param {string} addressId The ID of the address to broadcast the transaction from.\n     * @param {string} smartContractId The UUID of the smart contract to broadcast the transaction to.\n     * @param {DeploySmartContractRequest} deploySmartContractRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof SmartContractsApi\n     */\n    deploySmartContract(walletId, addressId, smartContractId, deploySmartContractRequest, options) {\n        return (0, exports.SmartContractsApiFp)(this.configuration).deploySmartContract(walletId, addressId, smartContractId, deploySmartContractRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Get a specific smart contract deployed by address.\n     * @summary Get a specific smart contract deployed by address\n     * @param {string} walletId The ID of the wallet the address belongs to.\n     * @param {string} addressId The ID of the address to fetch the smart contract for.\n     * @param {string} smartContractId The UUID of the smart contract to fetch.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof SmartContractsApi\n     */\n    getSmartContract(walletId, addressId, smartContractId, options) {\n        return (0, exports.SmartContractsApiFp)(this.configuration).getSmartContract(walletId, addressId, smartContractId, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * List smart contracts\n     * @summary List smart contracts\n     * @param {string} [page] Pagination token for retrieving the next set of results\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof SmartContractsApi\n     */\n    listSmartContracts(page, options) {\n        return (0, exports.SmartContractsApiFp)(this.configuration).listSmartContracts(page, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Perform a read operation on a smart contract without creating a transaction\n     * @summary Read data from a smart contract\n     * @param {string} networkId\n     * @param {string} contractAddress\n     * @param {ReadContractRequest} readContractRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof SmartContractsApi\n     */\n    readContract(networkId, contractAddress, readContractRequest, options) {\n        return (0, exports.SmartContractsApiFp)(this.configuration).readContract(networkId, contractAddress, readContractRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Register a smart contract\n     * @summary Register a smart contract\n     * @param {string} networkId The ID of the network to fetch.\n     * @param {string} contractAddress EVM address of the smart contract (42 characters, including \\&#39;0x\\&#39;, in lowercase)\n     * @param {RegisterSmartContractRequest} [registerSmartContractRequest]\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof SmartContractsApi\n     */\n    registerSmartContract(networkId, contractAddress, registerSmartContractRequest, options) {\n        return (0, exports.SmartContractsApiFp)(this.configuration).registerSmartContract(networkId, contractAddress, registerSmartContractRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Update a smart contract\n     * @summary Update a smart contract\n     * @param {string} networkId The ID of the network to fetch.\n     * @param {string} contractAddress EVM address of the smart contract (42 characters, including \\&#39;0x\\&#39;, in lowercase)\n     * @param {UpdateSmartContractRequest} [updateSmartContractRequest]\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof SmartContractsApi\n     */\n    updateSmartContract(networkId, contractAddress, updateSmartContractRequest, options) {\n        return (0, exports.SmartContractsApiFp)(this.configuration).updateSmartContract(networkId, contractAddress, updateSmartContractRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.SmartContractsApi = SmartContractsApi;\n/**\n * SmartWalletsApi - axios parameter creator\n * @export\n */\nconst SmartWalletsApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Broadcast a user operation\n         * @summary Broadcast a user operation\n         * @param {string} smartWalletAddress The address of the smart wallet to broadcast the user operation from.\n         * @param {string} userOpHash The hash of the user operation to broadcast\n         * @param {BroadcastUserOperationRequest} [broadcastUserOperationRequest]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        broadcastUserOperation: async (smartWalletAddress, userOpHash, broadcastUserOperationRequest, options = {}) => {\n            // verify required parameter 'smartWalletAddress' is not null or undefined\n            (0, common_1.assertParamExists)('broadcastUserOperation', 'smartWalletAddress', smartWalletAddress);\n            // verify required parameter 'userOpHash' is not null or undefined\n            (0, common_1.assertParamExists)('broadcastUserOperation', 'userOpHash', userOpHash);\n            const localVarPath = `/v1/smart_wallets/{smart_wallet_address}/user_operations/{user_op_hash}/broadcast`\n                .replace(`{${\"smart_wallet_address\"}}`, encodeURIComponent(String(smartWalletAddress)))\n                .replace(`{${\"user_op_hash\"}}`, encodeURIComponent(String(userOpHash)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(broadcastUserOperationRequest, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Create a new smart wallet, not scoped to a given network.\n         * @summary Create a new smart wallet\n         * @param {CreateSmartWalletRequest} [createSmartWalletRequest]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createSmartWallet: async (createSmartWalletRequest, options = {}) => {\n            const localVarPath = `/v1/smart_wallets`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createSmartWalletRequest, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Create a new user operation on a smart wallet.\n         * @summary Create a new user operation\n         * @param {string} smartWalletAddress The address of the smart wallet to create the user operation on.\n         * @param {string} networkId The ID of the network to create the user operation on.\n         * @param {CreateUserOperationRequest} [createUserOperationRequest]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createUserOperation: async (smartWalletAddress, networkId, createUserOperationRequest, options = {}) => {\n            // verify required parameter 'smartWalletAddress' is not null or undefined\n            (0, common_1.assertParamExists)('createUserOperation', 'smartWalletAddress', smartWalletAddress);\n            // verify required parameter 'networkId' is not null or undefined\n            (0, common_1.assertParamExists)('createUserOperation', 'networkId', networkId);\n            const localVarPath = `/v1/smart_wallets/{smart_wallet_address}/networks/{network_id}/user_operations`\n                .replace(`{${\"smart_wallet_address\"}}`, encodeURIComponent(String(smartWalletAddress)))\n                .replace(`{${\"network_id\"}}`, encodeURIComponent(String(networkId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createUserOperationRequest, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Get smart wallet\n         * @summary Get smart wallet by address\n         * @param {string} smartWalletAddress The address of that smart wallet to fetch.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getSmartWallet: async (smartWalletAddress, options = {}) => {\n            // verify required parameter 'smartWalletAddress' is not null or undefined\n            (0, common_1.assertParamExists)('getSmartWallet', 'smartWalletAddress', smartWalletAddress);\n            const localVarPath = `/v1/smart_wallets/{smart_wallet_address}`\n                .replace(`{${\"smart_wallet_address\"}}`, encodeURIComponent(String(smartWalletAddress)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Get user operation\n         * @summary Get user operation\n         * @param {string} smartWalletAddress The address of the smart wallet the user operation belongs to.\n         * @param {string} userOpHash The hash of the user operation to fetch\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getUserOperation: async (smartWalletAddress, userOpHash, options = {}) => {\n            // verify required parameter 'smartWalletAddress' is not null or undefined\n            (0, common_1.assertParamExists)('getUserOperation', 'smartWalletAddress', smartWalletAddress);\n            // verify required parameter 'userOpHash' is not null or undefined\n            (0, common_1.assertParamExists)('getUserOperation', 'userOpHash', userOpHash);\n            const localVarPath = `/v1/smart_wallets/{smart_wallet_address}/user_operations/{user_op_hash}`\n                .replace(`{${\"smart_wallet_address\"}}`, encodeURIComponent(String(smartWalletAddress)))\n                .replace(`{${\"user_op_hash\"}}`, encodeURIComponent(String(userOpHash)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * List smart wallets\n         * @summary List smart wallets\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listSmartWallets: async (limit, page, options = {}) => {\n            const localVarPath = `/v1/smart_wallets`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (page !== undefined) {\n                localVarQueryParameter['page'] = page;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.SmartWalletsApiAxiosParamCreator = SmartWalletsApiAxiosParamCreator;\n/**\n * SmartWalletsApi - functional programming interface\n * @export\n */\nconst SmartWalletsApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.SmartWalletsApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * Broadcast a user operation\n         * @summary Broadcast a user operation\n         * @param {string} smartWalletAddress The address of the smart wallet to broadcast the user operation from.\n         * @param {string} userOpHash The hash of the user operation to broadcast\n         * @param {BroadcastUserOperationRequest} [broadcastUserOperationRequest]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async broadcastUserOperation(smartWalletAddress, userOpHash, broadcastUserOperationRequest, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.broadcastUserOperation(smartWalletAddress, userOpHash, broadcastUserOperationRequest, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['SmartWalletsApi.broadcastUserOperation']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Create a new smart wallet, not scoped to a given network.\n         * @summary Create a new smart wallet\n         * @param {CreateSmartWalletRequest} [createSmartWalletRequest]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async createSmartWallet(createSmartWalletRequest, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.createSmartWallet(createSmartWalletRequest, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['SmartWalletsApi.createSmartWallet']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Create a new user operation on a smart wallet.\n         * @summary Create a new user operation\n         * @param {string} smartWalletAddress The address of the smart wallet to create the user operation on.\n         * @param {string} networkId The ID of the network to create the user operation on.\n         * @param {CreateUserOperationRequest} [createUserOperationRequest]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async createUserOperation(smartWalletAddress, networkId, createUserOperationRequest, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserOperation(smartWalletAddress, networkId, createUserOperationRequest, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['SmartWalletsApi.createUserOperation']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Get smart wallet\n         * @summary Get smart wallet by address\n         * @param {string} smartWalletAddress The address of that smart wallet to fetch.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async getSmartWallet(smartWalletAddress, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getSmartWallet(smartWalletAddress, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['SmartWalletsApi.getSmartWallet']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Get user operation\n         * @summary Get user operation\n         * @param {string} smartWalletAddress The address of the smart wallet the user operation belongs to.\n         * @param {string} userOpHash The hash of the user operation to fetch\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async getUserOperation(smartWalletAddress, userOpHash, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserOperation(smartWalletAddress, userOpHash, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['SmartWalletsApi.getUserOperation']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * List smart wallets\n         * @summary List smart wallets\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async listSmartWallets(limit, page, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.listSmartWallets(limit, page, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['SmartWalletsApi.listSmartWallets']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.SmartWalletsApiFp = SmartWalletsApiFp;\n/**\n * SmartWalletsApi - factory interface\n * @export\n */\nconst SmartWalletsApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.SmartWalletsApiFp)(configuration);\n    return {\n        /**\n         * Broadcast a user operation\n         * @summary Broadcast a user operation\n         * @param {string} smartWalletAddress The address of the smart wallet to broadcast the user operation from.\n         * @param {string} userOpHash The hash of the user operation to broadcast\n         * @param {BroadcastUserOperationRequest} [broadcastUserOperationRequest]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        broadcastUserOperation(smartWalletAddress, userOpHash, broadcastUserOperationRequest, options) {\n            return localVarFp.broadcastUserOperation(smartWalletAddress, userOpHash, broadcastUserOperationRequest, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Create a new smart wallet, not scoped to a given network.\n         * @summary Create a new smart wallet\n         * @param {CreateSmartWalletRequest} [createSmartWalletRequest]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createSmartWallet(createSmartWalletRequest, options) {\n            return localVarFp.createSmartWallet(createSmartWalletRequest, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Create a new user operation on a smart wallet.\n         * @summary Create a new user operation\n         * @param {string} smartWalletAddress The address of the smart wallet to create the user operation on.\n         * @param {string} networkId The ID of the network to create the user operation on.\n         * @param {CreateUserOperationRequest} [createUserOperationRequest]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createUserOperation(smartWalletAddress, networkId, createUserOperationRequest, options) {\n            return localVarFp.createUserOperation(smartWalletAddress, networkId, createUserOperationRequest, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Get smart wallet\n         * @summary Get smart wallet by address\n         * @param {string} smartWalletAddress The address of that smart wallet to fetch.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getSmartWallet(smartWalletAddress, options) {\n            return localVarFp.getSmartWallet(smartWalletAddress, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Get user operation\n         * @summary Get user operation\n         * @param {string} smartWalletAddress The address of the smart wallet the user operation belongs to.\n         * @param {string} userOpHash The hash of the user operation to fetch\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getUserOperation(smartWalletAddress, userOpHash, options) {\n            return localVarFp.getUserOperation(smartWalletAddress, userOpHash, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * List smart wallets\n         * @summary List smart wallets\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listSmartWallets(limit, page, options) {\n            return localVarFp.listSmartWallets(limit, page, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.SmartWalletsApiFactory = SmartWalletsApiFactory;\n/**\n * SmartWalletsApi - object-oriented interface\n * @export\n * @class SmartWalletsApi\n * @extends {BaseAPI}\n */\nclass SmartWalletsApi extends base_1.BaseAPI {\n    /**\n     * Broadcast a user operation\n     * @summary Broadcast a user operation\n     * @param {string} smartWalletAddress The address of the smart wallet to broadcast the user operation from.\n     * @param {string} userOpHash The hash of the user operation to broadcast\n     * @param {BroadcastUserOperationRequest} [broadcastUserOperationRequest]\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof SmartWalletsApi\n     */\n    broadcastUserOperation(smartWalletAddress, userOpHash, broadcastUserOperationRequest, options) {\n        return (0, exports.SmartWalletsApiFp)(this.configuration).broadcastUserOperation(smartWalletAddress, userOpHash, broadcastUserOperationRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Create a new smart wallet, not scoped to a given network.\n     * @summary Create a new smart wallet\n     * @param {CreateSmartWalletRequest} [createSmartWalletRequest]\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof SmartWalletsApi\n     */\n    createSmartWallet(createSmartWalletRequest, options) {\n        return (0, exports.SmartWalletsApiFp)(this.configuration).createSmartWallet(createSmartWalletRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Create a new user operation on a smart wallet.\n     * @summary Create a new user operation\n     * @param {string} smartWalletAddress The address of the smart wallet to create the user operation on.\n     * @param {string} networkId The ID of the network to create the user operation on.\n     * @param {CreateUserOperationRequest} [createUserOperationRequest]\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof SmartWalletsApi\n     */\n    createUserOperation(smartWalletAddress, networkId, createUserOperationRequest, options) {\n        return (0, exports.SmartWalletsApiFp)(this.configuration).createUserOperation(smartWalletAddress, networkId, createUserOperationRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Get smart wallet\n     * @summary Get smart wallet by address\n     * @param {string} smartWalletAddress The address of that smart wallet to fetch.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof SmartWalletsApi\n     */\n    getSmartWallet(smartWalletAddress, options) {\n        return (0, exports.SmartWalletsApiFp)(this.configuration).getSmartWallet(smartWalletAddress, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Get user operation\n     * @summary Get user operation\n     * @param {string} smartWalletAddress The address of the smart wallet the user operation belongs to.\n     * @param {string} userOpHash The hash of the user operation to fetch\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof SmartWalletsApi\n     */\n    getUserOperation(smartWalletAddress, userOpHash, options) {\n        return (0, exports.SmartWalletsApiFp)(this.configuration).getUserOperation(smartWalletAddress, userOpHash, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * List smart wallets\n     * @summary List smart wallets\n     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof SmartWalletsApi\n     */\n    listSmartWallets(limit, page, options) {\n        return (0, exports.SmartWalletsApiFp)(this.configuration).listSmartWallets(limit, page, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.SmartWalletsApi = SmartWalletsApi;\n/**\n * StakeApi - axios parameter creator\n * @export\n */\nconst StakeApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Build a new staking operation\n         * @summary Build a new staking operation\n         * @param {BuildStakingOperationRequest} buildStakingOperationRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        buildStakingOperation: async (buildStakingOperationRequest, options = {}) => {\n            // verify required parameter 'buildStakingOperationRequest' is not null or undefined\n            (0, common_1.assertParamExists)('buildStakingOperation', 'buildStakingOperationRequest', buildStakingOperationRequest);\n            const localVarPath = `/v1/stake/build`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(buildStakingOperationRequest, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Fetch historical staking balances for given address.\n         * @summary Fetch historical staking balances\n         * @param {string} networkId The ID of the blockchain network.\n         * @param {string} assetId The ID of the asset for which the historical staking balances are being fetched.\n         * @param {string} addressId The onchain address for which the historical staking balances are being fetched.\n         * @param {string} startTime The start time of this historical staking balance period.\n         * @param {string} endTime The end time of this historical staking balance period.\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        fetchHistoricalStakingBalances: async (networkId, assetId, addressId, startTime, endTime, limit, page, options = {}) => {\n            // verify required parameter 'networkId' is not null or undefined\n            (0, common_1.assertParamExists)('fetchHistoricalStakingBalances', 'networkId', networkId);\n            // verify required parameter 'assetId' is not null or undefined\n            (0, common_1.assertParamExists)('fetchHistoricalStakingBalances', 'assetId', assetId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('fetchHistoricalStakingBalances', 'addressId', addressId);\n            // verify required parameter 'startTime' is not null or undefined\n            (0, common_1.assertParamExists)('fetchHistoricalStakingBalances', 'startTime', startTime);\n            // verify required parameter 'endTime' is not null or undefined\n            (0, common_1.assertParamExists)('fetchHistoricalStakingBalances', 'endTime', endTime);\n            const localVarPath = `/v1/networks/{network_id}/addresses/{address_id}/stake/balances`\n                .replace(`{${\"network_id\"}}`, encodeURIComponent(String(networkId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (page !== undefined) {\n                localVarQueryParameter['page'] = page;\n            }\n            if (assetId !== undefined) {\n                localVarQueryParameter['asset_id'] = assetId;\n            }\n            if (startTime !== undefined) {\n                localVarQueryParameter['start_time'] = (startTime instanceof Date) ?\n                    startTime.toISOString() :\n                    startTime;\n            }\n            if (endTime !== undefined) {\n                localVarQueryParameter['end_time'] = (endTime instanceof Date) ?\n                    endTime.toISOString() :\n                    endTime;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Fetch staking rewards for a list of addresses\n         * @summary Fetch staking rewards\n         * @param {FetchStakingRewardsRequest} fetchStakingRewardsRequest\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        fetchStakingRewards: async (fetchStakingRewardsRequest, limit, page, options = {}) => {\n            // verify required parameter 'fetchStakingRewardsRequest' is not null or undefined\n            (0, common_1.assertParamExists)('fetchStakingRewards', 'fetchStakingRewardsRequest', fetchStakingRewardsRequest);\n            const localVarPath = `/v1/stake/rewards/search`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (page !== undefined) {\n                localVarQueryParameter['page'] = page;\n            }\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(fetchStakingRewardsRequest, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Get the latest state of a staking operation\n         * @summary Get the latest state of a staking operation\n         * @param {string} networkId The ID of the blockchain network\n         * @param {string} addressId The ID of the address to fetch the staking operation for\n         * @param {string} stakingOperationId The ID of the staking operation\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getExternalStakingOperation: async (networkId, addressId, stakingOperationId, options = {}) => {\n            // verify required parameter 'networkId' is not null or undefined\n            (0, common_1.assertParamExists)('getExternalStakingOperation', 'networkId', networkId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('getExternalStakingOperation', 'addressId', addressId);\n            // verify required parameter 'stakingOperationId' is not null or undefined\n            (0, common_1.assertParamExists)('getExternalStakingOperation', 'stakingOperationId', stakingOperationId);\n            const localVarPath = `/v1/networks/{network_id}/addresses/{address_id}/staking_operations/{staking_operation_id}`\n                .replace(`{${\"network_id\"}}`, encodeURIComponent(String(networkId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)))\n                .replace(`{${\"staking_operation_id\"}}`, encodeURIComponent(String(stakingOperationId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Get staking context for an address\n         * @summary Get staking context\n         * @param {GetStakingContextRequest} getStakingContextRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getStakingContext: async (getStakingContextRequest, options = {}) => {\n            // verify required parameter 'getStakingContextRequest' is not null or undefined\n            (0, common_1.assertParamExists)('getStakingContext', 'getStakingContextRequest', getStakingContextRequest);\n            const localVarPath = `/v1/stake/context`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(getStakingContextRequest, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Get a validator belonging to the user for a given network, asset and id.\n         * @summary Get a validator belonging to the CDP project\n         * @param {string} networkId The ID of the blockchain network.\n         * @param {string} assetId The symbol of the asset to get the validator for.\n         * @param {string} validatorId The unique id of the validator to fetch details for.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getValidator: async (networkId, assetId, validatorId, options = {}) => {\n            // verify required parameter 'networkId' is not null or undefined\n            (0, common_1.assertParamExists)('getValidator', 'networkId', networkId);\n            // verify required parameter 'assetId' is not null or undefined\n            (0, common_1.assertParamExists)('getValidator', 'assetId', assetId);\n            // verify required parameter 'validatorId' is not null or undefined\n            (0, common_1.assertParamExists)('getValidator', 'validatorId', validatorId);\n            const localVarPath = `/v1/networks/{network_id}/assets/{asset_id}/validators/{validator_id}`\n                .replace(`{${\"network_id\"}}`, encodeURIComponent(String(networkId)))\n                .replace(`{${\"asset_id\"}}`, encodeURIComponent(String(assetId)))\n                .replace(`{${\"validator_id\"}}`, encodeURIComponent(String(validatorId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * List validators belonging to the user for a given network and asset.\n         * @summary List validators belonging to the CDP project\n         * @param {string} networkId The ID of the blockchain network.\n         * @param {string} assetId The symbol of the asset to get the validators for.\n         * @param {ValidatorStatus} [status] A filter to list validators based on a status.\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listValidators: async (networkId, assetId, status, limit, page, options = {}) => {\n            // verify required parameter 'networkId' is not null or undefined\n            (0, common_1.assertParamExists)('listValidators', 'networkId', networkId);\n            // verify required parameter 'assetId' is not null or undefined\n            (0, common_1.assertParamExists)('listValidators', 'assetId', assetId);\n            const localVarPath = `/v1/networks/{network_id}/assets/{asset_id}/validators`\n                .replace(`{${\"network_id\"}}`, encodeURIComponent(String(networkId)))\n                .replace(`{${\"asset_id\"}}`, encodeURIComponent(String(assetId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            if (status !== undefined) {\n                localVarQueryParameter['status'] = status;\n            }\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (page !== undefined) {\n                localVarQueryParameter['page'] = page;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.StakeApiAxiosParamCreator = StakeApiAxiosParamCreator;\n/**\n * StakeApi - functional programming interface\n * @export\n */\nconst StakeApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.StakeApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * Build a new staking operation\n         * @summary Build a new staking operation\n         * @param {BuildStakingOperationRequest} buildStakingOperationRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async buildStakingOperation(buildStakingOperationRequest, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.buildStakingOperation(buildStakingOperationRequest, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['StakeApi.buildStakingOperation']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Fetch historical staking balances for given address.\n         * @summary Fetch historical staking balances\n         * @param {string} networkId The ID of the blockchain network.\n         * @param {string} assetId The ID of the asset for which the historical staking balances are being fetched.\n         * @param {string} addressId The onchain address for which the historical staking balances are being fetched.\n         * @param {string} startTime The start time of this historical staking balance period.\n         * @param {string} endTime The end time of this historical staking balance period.\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async fetchHistoricalStakingBalances(networkId, assetId, addressId, startTime, endTime, limit, page, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchHistoricalStakingBalances(networkId, assetId, addressId, startTime, endTime, limit, page, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['StakeApi.fetchHistoricalStakingBalances']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Fetch staking rewards for a list of addresses\n         * @summary Fetch staking rewards\n         * @param {FetchStakingRewardsRequest} fetchStakingRewardsRequest\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async fetchStakingRewards(fetchStakingRewardsRequest, limit, page, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchStakingRewards(fetchStakingRewardsRequest, limit, page, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['StakeApi.fetchStakingRewards']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Get the latest state of a staking operation\n         * @summary Get the latest state of a staking operation\n         * @param {string} networkId The ID of the blockchain network\n         * @param {string} addressId The ID of the address to fetch the staking operation for\n         * @param {string} stakingOperationId The ID of the staking operation\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async getExternalStakingOperation(networkId, addressId, stakingOperationId, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getExternalStakingOperation(networkId, addressId, stakingOperationId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['StakeApi.getExternalStakingOperation']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Get staking context for an address\n         * @summary Get staking context\n         * @param {GetStakingContextRequest} getStakingContextRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async getStakingContext(getStakingContextRequest, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getStakingContext(getStakingContextRequest, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['StakeApi.getStakingContext']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Get a validator belonging to the user for a given network, asset and id.\n         * @summary Get a validator belonging to the CDP project\n         * @param {string} networkId The ID of the blockchain network.\n         * @param {string} assetId The symbol of the asset to get the validator for.\n         * @param {string} validatorId The unique id of the validator to fetch details for.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async getValidator(networkId, assetId, validatorId, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getValidator(networkId, assetId, validatorId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['StakeApi.getValidator']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * List validators belonging to the user for a given network and asset.\n         * @summary List validators belonging to the CDP project\n         * @param {string} networkId The ID of the blockchain network.\n         * @param {string} assetId The symbol of the asset to get the validators for.\n         * @param {ValidatorStatus} [status] A filter to list validators based on a status.\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async listValidators(networkId, assetId, status, limit, page, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.listValidators(networkId, assetId, status, limit, page, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['StakeApi.listValidators']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.StakeApiFp = StakeApiFp;\n/**\n * StakeApi - factory interface\n * @export\n */\nconst StakeApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.StakeApiFp)(configuration);\n    return {\n        /**\n         * Build a new staking operation\n         * @summary Build a new staking operation\n         * @param {BuildStakingOperationRequest} buildStakingOperationRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        buildStakingOperation(buildStakingOperationRequest, options) {\n            return localVarFp.buildStakingOperation(buildStakingOperationRequest, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Fetch historical staking balances for given address.\n         * @summary Fetch historical staking balances\n         * @param {string} networkId The ID of the blockchain network.\n         * @param {string} assetId The ID of the asset for which the historical staking balances are being fetched.\n         * @param {string} addressId The onchain address for which the historical staking balances are being fetched.\n         * @param {string} startTime The start time of this historical staking balance period.\n         * @param {string} endTime The end time of this historical staking balance period.\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        fetchHistoricalStakingBalances(networkId, assetId, addressId, startTime, endTime, limit, page, options) {\n            return localVarFp.fetchHistoricalStakingBalances(networkId, assetId, addressId, startTime, endTime, limit, page, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Fetch staking rewards for a list of addresses\n         * @summary Fetch staking rewards\n         * @param {FetchStakingRewardsRequest} fetchStakingRewardsRequest\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        fetchStakingRewards(fetchStakingRewardsRequest, limit, page, options) {\n            return localVarFp.fetchStakingRewards(fetchStakingRewardsRequest, limit, page, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Get the latest state of a staking operation\n         * @summary Get the latest state of a staking operation\n         * @param {string} networkId The ID of the blockchain network\n         * @param {string} addressId The ID of the address to fetch the staking operation for\n         * @param {string} stakingOperationId The ID of the staking operation\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getExternalStakingOperation(networkId, addressId, stakingOperationId, options) {\n            return localVarFp.getExternalStakingOperation(networkId, addressId, stakingOperationId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Get staking context for an address\n         * @summary Get staking context\n         * @param {GetStakingContextRequest} getStakingContextRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getStakingContext(getStakingContextRequest, options) {\n            return localVarFp.getStakingContext(getStakingContextRequest, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Get a validator belonging to the user for a given network, asset and id.\n         * @summary Get a validator belonging to the CDP project\n         * @param {string} networkId The ID of the blockchain network.\n         * @param {string} assetId The symbol of the asset to get the validator for.\n         * @param {string} validatorId The unique id of the validator to fetch details for.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getValidator(networkId, assetId, validatorId, options) {\n            return localVarFp.getValidator(networkId, assetId, validatorId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * List validators belonging to the user for a given network and asset.\n         * @summary List validators belonging to the CDP project\n         * @param {string} networkId The ID of the blockchain network.\n         * @param {string} assetId The symbol of the asset to get the validators for.\n         * @param {ValidatorStatus} [status] A filter to list validators based on a status.\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listValidators(networkId, assetId, status, limit, page, options) {\n            return localVarFp.listValidators(networkId, assetId, status, limit, page, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.StakeApiFactory = StakeApiFactory;\n/**\n * StakeApi - object-oriented interface\n * @export\n * @class StakeApi\n * @extends {BaseAPI}\n */\nclass StakeApi extends base_1.BaseAPI {\n    /**\n     * Build a new staking operation\n     * @summary Build a new staking operation\n     * @param {BuildStakingOperationRequest} buildStakingOperationRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof StakeApi\n     */\n    buildStakingOperation(buildStakingOperationRequest, options) {\n        return (0, exports.StakeApiFp)(this.configuration).buildStakingOperation(buildStakingOperationRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Fetch historical staking balances for given address.\n     * @summary Fetch historical staking balances\n     * @param {string} networkId The ID of the blockchain network.\n     * @param {string} assetId The ID of the asset for which the historical staking balances are being fetched.\n     * @param {string} addressId The onchain address for which the historical staking balances are being fetched.\n     * @param {string} startTime The start time of this historical staking balance period.\n     * @param {string} endTime The end time of this historical staking balance period.\n     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.\n     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof StakeApi\n     */\n    fetchHistoricalStakingBalances(networkId, assetId, addressId, startTime, endTime, limit, page, options) {\n        return (0, exports.StakeApiFp)(this.configuration).fetchHistoricalStakingBalances(networkId, assetId, addressId, startTime, endTime, limit, page, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Fetch staking rewards for a list of addresses\n     * @summary Fetch staking rewards\n     * @param {FetchStakingRewardsRequest} fetchStakingRewardsRequest\n     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.\n     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof StakeApi\n     */\n    fetchStakingRewards(fetchStakingRewardsRequest, limit, page, options) {\n        return (0, exports.StakeApiFp)(this.configuration).fetchStakingRewards(fetchStakingRewardsRequest, limit, page, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Get the latest state of a staking operation\n     * @summary Get the latest state of a staking operation\n     * @param {string} networkId The ID of the blockchain network\n     * @param {string} addressId The ID of the address to fetch the staking operation for\n     * @param {string} stakingOperationId The ID of the staking operation\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof StakeApi\n     */\n    getExternalStakingOperation(networkId, addressId, stakingOperationId, options) {\n        return (0, exports.StakeApiFp)(this.configuration).getExternalStakingOperation(networkId, addressId, stakingOperationId, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Get staking context for an address\n     * @summary Get staking context\n     * @param {GetStakingContextRequest} getStakingContextRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof StakeApi\n     */\n    getStakingContext(getStakingContextRequest, options) {\n        return (0, exports.StakeApiFp)(this.configuration).getStakingContext(getStakingContextRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Get a validator belonging to the user for a given network, asset and id.\n     * @summary Get a validator belonging to the CDP project\n     * @param {string} networkId The ID of the blockchain network.\n     * @param {string} assetId The symbol of the asset to get the validator for.\n     * @param {string} validatorId The unique id of the validator to fetch details for.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof StakeApi\n     */\n    getValidator(networkId, assetId, validatorId, options) {\n        return (0, exports.StakeApiFp)(this.configuration).getValidator(networkId, assetId, validatorId, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * List validators belonging to the user for a given network and asset.\n     * @summary List validators belonging to the CDP project\n     * @param {string} networkId The ID of the blockchain network.\n     * @param {string} assetId The symbol of the asset to get the validators for.\n     * @param {ValidatorStatus} [status] A filter to list validators based on a status.\n     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.\n     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof StakeApi\n     */\n    listValidators(networkId, assetId, status, limit, page, options) {\n        return (0, exports.StakeApiFp)(this.configuration).listValidators(networkId, assetId, status, limit, page, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.StakeApi = StakeApi;\n/**\n * TradesApi - axios parameter creator\n * @export\n */\nconst TradesApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Broadcast a trade\n         * @summary Broadcast a trade\n         * @param {string} walletId The ID of the wallet the address belongs to\n         * @param {string} addressId The ID of the address the trade belongs to\n         * @param {string} tradeId The ID of the trade to broadcast\n         * @param {BroadcastTradeRequest} broadcastTradeRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        broadcastTrade: async (walletId, addressId, tradeId, broadcastTradeRequest, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('broadcastTrade', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('broadcastTrade', 'addressId', addressId);\n            // verify required parameter 'tradeId' is not null or undefined\n            (0, common_1.assertParamExists)('broadcastTrade', 'tradeId', tradeId);\n            // verify required parameter 'broadcastTradeRequest' is not null or undefined\n            (0, common_1.assertParamExists)('broadcastTrade', 'broadcastTradeRequest', broadcastTradeRequest);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/trades/{trade_id}/broadcast`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)))\n                .replace(`{${\"trade_id\"}}`, encodeURIComponent(String(tradeId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(broadcastTradeRequest, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Create a new trade\n         * @summary Create a new trade for an address\n         * @param {string} walletId The ID of the wallet the source address belongs to\n         * @param {string} addressId The ID of the address to conduct the trade from\n         * @param {CreateTradeRequest} createTradeRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createTrade: async (walletId, addressId, createTradeRequest, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('createTrade', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('createTrade', 'addressId', addressId);\n            // verify required parameter 'createTradeRequest' is not null or undefined\n            (0, common_1.assertParamExists)('createTrade', 'createTradeRequest', createTradeRequest);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/trades`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createTradeRequest, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Get a trade by ID\n         * @summary Get a trade by ID\n         * @param {string} walletId The ID of the wallet the address belongs to\n         * @param {string} addressId The ID of the address the trade belongs to\n         * @param {string} tradeId The ID of the trade to fetch\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getTrade: async (walletId, addressId, tradeId, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('getTrade', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('getTrade', 'addressId', addressId);\n            // verify required parameter 'tradeId' is not null or undefined\n            (0, common_1.assertParamExists)('getTrade', 'tradeId', tradeId);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/trades/{trade_id}`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)))\n                .replace(`{${\"trade_id\"}}`, encodeURIComponent(String(tradeId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * List trades for an address.\n         * @summary List trades for an address.\n         * @param {string} walletId The ID of the wallet the address belongs to\n         * @param {string} addressId The ID of the address to list trades for\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listTrades: async (walletId, addressId, limit, page, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('listTrades', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('listTrades', 'addressId', addressId);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/trades`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (page !== undefined) {\n                localVarQueryParameter['page'] = page;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.TradesApiAxiosParamCreator = TradesApiAxiosParamCreator;\n/**\n * TradesApi - functional programming interface\n * @export\n */\nconst TradesApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.TradesApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * Broadcast a trade\n         * @summary Broadcast a trade\n         * @param {string} walletId The ID of the wallet the address belongs to\n         * @param {string} addressId The ID of the address the trade belongs to\n         * @param {string} tradeId The ID of the trade to broadcast\n         * @param {BroadcastTradeRequest} broadcastTradeRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async broadcastTrade(walletId, addressId, tradeId, broadcastTradeRequest, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.broadcastTrade(walletId, addressId, tradeId, broadcastTradeRequest, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['TradesApi.broadcastTrade']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Create a new trade\n         * @summary Create a new trade for an address\n         * @param {string} walletId The ID of the wallet the source address belongs to\n         * @param {string} addressId The ID of the address to conduct the trade from\n         * @param {CreateTradeRequest} createTradeRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async createTrade(walletId, addressId, createTradeRequest, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.createTrade(walletId, addressId, createTradeRequest, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['TradesApi.createTrade']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Get a trade by ID\n         * @summary Get a trade by ID\n         * @param {string} walletId The ID of the wallet the address belongs to\n         * @param {string} addressId The ID of the address the trade belongs to\n         * @param {string} tradeId The ID of the trade to fetch\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async getTrade(walletId, addressId, tradeId, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getTrade(walletId, addressId, tradeId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['TradesApi.getTrade']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * List trades for an address.\n         * @summary List trades for an address.\n         * @param {string} walletId The ID of the wallet the address belongs to\n         * @param {string} addressId The ID of the address to list trades for\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async listTrades(walletId, addressId, limit, page, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.listTrades(walletId, addressId, limit, page, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['TradesApi.listTrades']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.TradesApiFp = TradesApiFp;\n/**\n * TradesApi - factory interface\n * @export\n */\nconst TradesApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.TradesApiFp)(configuration);\n    return {\n        /**\n         * Broadcast a trade\n         * @summary Broadcast a trade\n         * @param {string} walletId The ID of the wallet the address belongs to\n         * @param {string} addressId The ID of the address the trade belongs to\n         * @param {string} tradeId The ID of the trade to broadcast\n         * @param {BroadcastTradeRequest} broadcastTradeRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        broadcastTrade(walletId, addressId, tradeId, broadcastTradeRequest, options) {\n            return localVarFp.broadcastTrade(walletId, addressId, tradeId, broadcastTradeRequest, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Create a new trade\n         * @summary Create a new trade for an address\n         * @param {string} walletId The ID of the wallet the source address belongs to\n         * @param {string} addressId The ID of the address to conduct the trade from\n         * @param {CreateTradeRequest} createTradeRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createTrade(walletId, addressId, createTradeRequest, options) {\n            return localVarFp.createTrade(walletId, addressId, createTradeRequest, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Get a trade by ID\n         * @summary Get a trade by ID\n         * @param {string} walletId The ID of the wallet the address belongs to\n         * @param {string} addressId The ID of the address the trade belongs to\n         * @param {string} tradeId The ID of the trade to fetch\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getTrade(walletId, addressId, tradeId, options) {\n            return localVarFp.getTrade(walletId, addressId, tradeId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * List trades for an address.\n         * @summary List trades for an address.\n         * @param {string} walletId The ID of the wallet the address belongs to\n         * @param {string} addressId The ID of the address to list trades for\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listTrades(walletId, addressId, limit, page, options) {\n            return localVarFp.listTrades(walletId, addressId, limit, page, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.TradesApiFactory = TradesApiFactory;\n/**\n * TradesApi - object-oriented interface\n * @export\n * @class TradesApi\n * @extends {BaseAPI}\n */\nclass TradesApi extends base_1.BaseAPI {\n    /**\n     * Broadcast a trade\n     * @summary Broadcast a trade\n     * @param {string} walletId The ID of the wallet the address belongs to\n     * @param {string} addressId The ID of the address the trade belongs to\n     * @param {string} tradeId The ID of the trade to broadcast\n     * @param {BroadcastTradeRequest} broadcastTradeRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof TradesApi\n     */\n    broadcastTrade(walletId, addressId, tradeId, broadcastTradeRequest, options) {\n        return (0, exports.TradesApiFp)(this.configuration).broadcastTrade(walletId, addressId, tradeId, broadcastTradeRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Create a new trade\n     * @summary Create a new trade for an address\n     * @param {string} walletId The ID of the wallet the source address belongs to\n     * @param {string} addressId The ID of the address to conduct the trade from\n     * @param {CreateTradeRequest} createTradeRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof TradesApi\n     */\n    createTrade(walletId, addressId, createTradeRequest, options) {\n        return (0, exports.TradesApiFp)(this.configuration).createTrade(walletId, addressId, createTradeRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Get a trade by ID\n     * @summary Get a trade by ID\n     * @param {string} walletId The ID of the wallet the address belongs to\n     * @param {string} addressId The ID of the address the trade belongs to\n     * @param {string} tradeId The ID of the trade to fetch\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof TradesApi\n     */\n    getTrade(walletId, addressId, tradeId, options) {\n        return (0, exports.TradesApiFp)(this.configuration).getTrade(walletId, addressId, tradeId, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * List trades for an address.\n     * @summary List trades for an address.\n     * @param {string} walletId The ID of the wallet the address belongs to\n     * @param {string} addressId The ID of the address to list trades for\n     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof TradesApi\n     */\n    listTrades(walletId, addressId, limit, page, options) {\n        return (0, exports.TradesApiFp)(this.configuration).listTrades(walletId, addressId, limit, page, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.TradesApi = TradesApi;\n/**\n * TransactionHistoryApi - axios parameter creator\n * @export\n */\nconst TransactionHistoryApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * List all transactions that interact with the address.\n         * @summary List transactions for an address.\n         * @param {string} networkId The ID of the blockchain network\n         * @param {string} addressId The ID of the address to fetch the transactions for.\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listAddressTransactions: async (networkId, addressId, limit, page, options = {}) => {\n            // verify required parameter 'networkId' is not null or undefined\n            (0, common_1.assertParamExists)('listAddressTransactions', 'networkId', networkId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('listAddressTransactions', 'addressId', addressId);\n            const localVarPath = `/v1/networks/{network_id}/addresses/{address_id}/transactions`\n                .replace(`{${\"network_id\"}}`, encodeURIComponent(String(networkId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (page !== undefined) {\n                localVarQueryParameter['page'] = page;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.TransactionHistoryApiAxiosParamCreator = TransactionHistoryApiAxiosParamCreator;\n/**\n * TransactionHistoryApi - functional programming interface\n * @export\n */\nconst TransactionHistoryApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.TransactionHistoryApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * List all transactions that interact with the address.\n         * @summary List transactions for an address.\n         * @param {string} networkId The ID of the blockchain network\n         * @param {string} addressId The ID of the address to fetch the transactions for.\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async listAddressTransactions(networkId, addressId, limit, page, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.listAddressTransactions(networkId, addressId, limit, page, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['TransactionHistoryApi.listAddressTransactions']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.TransactionHistoryApiFp = TransactionHistoryApiFp;\n/**\n * TransactionHistoryApi - factory interface\n * @export\n */\nconst TransactionHistoryApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.TransactionHistoryApiFp)(configuration);\n    return {\n        /**\n         * List all transactions that interact with the address.\n         * @summary List transactions for an address.\n         * @param {string} networkId The ID of the blockchain network\n         * @param {string} addressId The ID of the address to fetch the transactions for.\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listAddressTransactions(networkId, addressId, limit, page, options) {\n            return localVarFp.listAddressTransactions(networkId, addressId, limit, page, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.TransactionHistoryApiFactory = TransactionHistoryApiFactory;\n/**\n * TransactionHistoryApi - object-oriented interface\n * @export\n * @class TransactionHistoryApi\n * @extends {BaseAPI}\n */\nclass TransactionHistoryApi extends base_1.BaseAPI {\n    /**\n     * List all transactions that interact with the address.\n     * @summary List transactions for an address.\n     * @param {string} networkId The ID of the blockchain network\n     * @param {string} addressId The ID of the address to fetch the transactions for.\n     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof TransactionHistoryApi\n     */\n    listAddressTransactions(networkId, addressId, limit, page, options) {\n        return (0, exports.TransactionHistoryApiFp)(this.configuration).listAddressTransactions(networkId, addressId, limit, page, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.TransactionHistoryApi = TransactionHistoryApi;\n/**\n * TransfersApi - axios parameter creator\n * @export\n */\nconst TransfersApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Broadcast a transfer\n         * @summary Broadcast a transfer\n         * @param {string} walletId The ID of the wallet the address belongs to\n         * @param {string} addressId The ID of the address the transfer belongs to\n         * @param {string} transferId The ID of the transfer to broadcast\n         * @param {BroadcastTransferRequest} broadcastTransferRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        broadcastTransfer: async (walletId, addressId, transferId, broadcastTransferRequest, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('broadcastTransfer', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('broadcastTransfer', 'addressId', addressId);\n            // verify required parameter 'transferId' is not null or undefined\n            (0, common_1.assertParamExists)('broadcastTransfer', 'transferId', transferId);\n            // verify required parameter 'broadcastTransferRequest' is not null or undefined\n            (0, common_1.assertParamExists)('broadcastTransfer', 'broadcastTransferRequest', broadcastTransferRequest);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/transfers/{transfer_id}/broadcast`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)))\n                .replace(`{${\"transfer_id\"}}`, encodeURIComponent(String(transferId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(broadcastTransferRequest, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Create a new transfer\n         * @summary Create a new transfer for an address\n         * @param {string} walletId The ID of the wallet the source address belongs to\n         * @param {string} addressId The ID of the address to transfer from\n         * @param {CreateTransferRequest} createTransferRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createTransfer: async (walletId, addressId, createTransferRequest, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('createTransfer', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('createTransfer', 'addressId', addressId);\n            // verify required parameter 'createTransferRequest' is not null or undefined\n            (0, common_1.assertParamExists)('createTransfer', 'createTransferRequest', createTransferRequest);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/transfers`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createTransferRequest, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Get a transfer by ID\n         * @summary Get a transfer by ID\n         * @param {string} walletId The ID of the wallet the address belongs to\n         * @param {string} addressId The ID of the address the transfer belongs to\n         * @param {string} transferId The ID of the transfer to fetch\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getTransfer: async (walletId, addressId, transferId, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('getTransfer', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('getTransfer', 'addressId', addressId);\n            // verify required parameter 'transferId' is not null or undefined\n            (0, common_1.assertParamExists)('getTransfer', 'transferId', transferId);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/transfers/{transfer_id}`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)))\n                .replace(`{${\"transfer_id\"}}`, encodeURIComponent(String(transferId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * List transfers for an address.\n         * @summary List transfers for an address.\n         * @param {string} walletId The ID of the wallet the address belongs to\n         * @param {string} addressId The ID of the address to list transfers for\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listTransfers: async (walletId, addressId, limit, page, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('listTransfers', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('listTransfers', 'addressId', addressId);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/transfers`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (page !== undefined) {\n                localVarQueryParameter['page'] = page;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.TransfersApiAxiosParamCreator = TransfersApiAxiosParamCreator;\n/**\n * TransfersApi - functional programming interface\n * @export\n */\nconst TransfersApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.TransfersApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * Broadcast a transfer\n         * @summary Broadcast a transfer\n         * @param {string} walletId The ID of the wallet the address belongs to\n         * @param {string} addressId The ID of the address the transfer belongs to\n         * @param {string} transferId The ID of the transfer to broadcast\n         * @param {BroadcastTransferRequest} broadcastTransferRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async broadcastTransfer(walletId, addressId, transferId, broadcastTransferRequest, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.broadcastTransfer(walletId, addressId, transferId, broadcastTransferRequest, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['TransfersApi.broadcastTransfer']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Create a new transfer\n         * @summary Create a new transfer for an address\n         * @param {string} walletId The ID of the wallet the source address belongs to\n         * @param {string} addressId The ID of the address to transfer from\n         * @param {CreateTransferRequest} createTransferRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async createTransfer(walletId, addressId, createTransferRequest, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.createTransfer(walletId, addressId, createTransferRequest, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['TransfersApi.createTransfer']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Get a transfer by ID\n         * @summary Get a transfer by ID\n         * @param {string} walletId The ID of the wallet the address belongs to\n         * @param {string} addressId The ID of the address the transfer belongs to\n         * @param {string} transferId The ID of the transfer to fetch\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async getTransfer(walletId, addressId, transferId, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransfer(walletId, addressId, transferId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['TransfersApi.getTransfer']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * List transfers for an address.\n         * @summary List transfers for an address.\n         * @param {string} walletId The ID of the wallet the address belongs to\n         * @param {string} addressId The ID of the address to list transfers for\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async listTransfers(walletId, addressId, limit, page, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.listTransfers(walletId, addressId, limit, page, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['TransfersApi.listTransfers']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.TransfersApiFp = TransfersApiFp;\n/**\n * TransfersApi - factory interface\n * @export\n */\nconst TransfersApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.TransfersApiFp)(configuration);\n    return {\n        /**\n         * Broadcast a transfer\n         * @summary Broadcast a transfer\n         * @param {string} walletId The ID of the wallet the address belongs to\n         * @param {string} addressId The ID of the address the transfer belongs to\n         * @param {string} transferId The ID of the transfer to broadcast\n         * @param {BroadcastTransferRequest} broadcastTransferRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        broadcastTransfer(walletId, addressId, transferId, broadcastTransferRequest, options) {\n            return localVarFp.broadcastTransfer(walletId, addressId, transferId, broadcastTransferRequest, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Create a new transfer\n         * @summary Create a new transfer for an address\n         * @param {string} walletId The ID of the wallet the source address belongs to\n         * @param {string} addressId The ID of the address to transfer from\n         * @param {CreateTransferRequest} createTransferRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createTransfer(walletId, addressId, createTransferRequest, options) {\n            return localVarFp.createTransfer(walletId, addressId, createTransferRequest, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Get a transfer by ID\n         * @summary Get a transfer by ID\n         * @param {string} walletId The ID of the wallet the address belongs to\n         * @param {string} addressId The ID of the address the transfer belongs to\n         * @param {string} transferId The ID of the transfer to fetch\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getTransfer(walletId, addressId, transferId, options) {\n            return localVarFp.getTransfer(walletId, addressId, transferId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * List transfers for an address.\n         * @summary List transfers for an address.\n         * @param {string} walletId The ID of the wallet the address belongs to\n         * @param {string} addressId The ID of the address to list transfers for\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listTransfers(walletId, addressId, limit, page, options) {\n            return localVarFp.listTransfers(walletId, addressId, limit, page, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.TransfersApiFactory = TransfersApiFactory;\n/**\n * TransfersApi - object-oriented interface\n * @export\n * @class TransfersApi\n * @extends {BaseAPI}\n */\nclass TransfersApi extends base_1.BaseAPI {\n    /**\n     * Broadcast a transfer\n     * @summary Broadcast a transfer\n     * @param {string} walletId The ID of the wallet the address belongs to\n     * @param {string} addressId The ID of the address the transfer belongs to\n     * @param {string} transferId The ID of the transfer to broadcast\n     * @param {BroadcastTransferRequest} broadcastTransferRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof TransfersApi\n     */\n    broadcastTransfer(walletId, addressId, transferId, broadcastTransferRequest, options) {\n        return (0, exports.TransfersApiFp)(this.configuration).broadcastTransfer(walletId, addressId, transferId, broadcastTransferRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Create a new transfer\n     * @summary Create a new transfer for an address\n     * @param {string} walletId The ID of the wallet the source address belongs to\n     * @param {string} addressId The ID of the address to transfer from\n     * @param {CreateTransferRequest} createTransferRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof TransfersApi\n     */\n    createTransfer(walletId, addressId, createTransferRequest, options) {\n        return (0, exports.TransfersApiFp)(this.configuration).createTransfer(walletId, addressId, createTransferRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Get a transfer by ID\n     * @summary Get a transfer by ID\n     * @param {string} walletId The ID of the wallet the address belongs to\n     * @param {string} addressId The ID of the address the transfer belongs to\n     * @param {string} transferId The ID of the transfer to fetch\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof TransfersApi\n     */\n    getTransfer(walletId, addressId, transferId, options) {\n        return (0, exports.TransfersApiFp)(this.configuration).getTransfer(walletId, addressId, transferId, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * List transfers for an address.\n     * @summary List transfers for an address.\n     * @param {string} walletId The ID of the wallet the address belongs to\n     * @param {string} addressId The ID of the address to list transfers for\n     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof TransfersApi\n     */\n    listTransfers(walletId, addressId, limit, page, options) {\n        return (0, exports.TransfersApiFp)(this.configuration).listTransfers(walletId, addressId, limit, page, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.TransfersApi = TransfersApi;\n/**\n * UsersApi - axios parameter creator\n * @export\n */\nconst UsersApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Get current user\n         * @summary Get current user\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getCurrentUser: async (options = {}) => {\n            const localVarPath = `/v1/users/me`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.UsersApiAxiosParamCreator = UsersApiAxiosParamCreator;\n/**\n * UsersApi - functional programming interface\n * @export\n */\nconst UsersApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.UsersApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * Get current user\n         * @summary Get current user\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async getCurrentUser(options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentUser(options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['UsersApi.getCurrentUser']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.UsersApiFp = UsersApiFp;\n/**\n * UsersApi - factory interface\n * @export\n */\nconst UsersApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.UsersApiFp)(configuration);\n    return {\n        /**\n         * Get current user\n         * @summary Get current user\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getCurrentUser(options) {\n            return localVarFp.getCurrentUser(options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.UsersApiFactory = UsersApiFactory;\n/**\n * UsersApi - object-oriented interface\n * @export\n * @class UsersApi\n * @extends {BaseAPI}\n */\nclass UsersApi extends base_1.BaseAPI {\n    /**\n     * Get current user\n     * @summary Get current user\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof UsersApi\n     */\n    getCurrentUser(options) {\n        return (0, exports.UsersApiFp)(this.configuration).getCurrentUser(options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.UsersApi = UsersApi;\n/**\n * WalletsApi - axios parameter creator\n * @export\n */\nconst WalletsApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Create a new wallet scoped to the user.\n         * @summary Create a new wallet\n         * @param {CreateWalletRequest} [createWalletRequest]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createWallet: async (createWalletRequest, options = {}) => {\n            const localVarPath = `/v1/wallets`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createWalletRequest, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Get wallet\n         * @summary Get wallet by ID\n         * @param {string} walletId The ID of the wallet to fetch\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getWallet: async (walletId, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('getWallet', 'walletId', walletId);\n            const localVarPath = `/v1/wallets/{wallet_id}`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Get the aggregated balance of an asset across all of the addresses in the wallet.\n         * @summary Get the balance of an asset in the wallet\n         * @param {string} walletId The ID of the wallet to fetch the balance for\n         * @param {string} assetId The symbol of the asset to fetch the balance for\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getWalletBalance: async (walletId, assetId, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('getWalletBalance', 'walletId', walletId);\n            // verify required parameter 'assetId' is not null or undefined\n            (0, common_1.assertParamExists)('getWalletBalance', 'assetId', assetId);\n            const localVarPath = `/v1/wallets/{wallet_id}/balances/{asset_id}`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"asset_id\"}}`, encodeURIComponent(String(assetId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * List the balances of all of the addresses in the wallet aggregated by asset.\n         * @summary List wallet balances\n         * @param {string} walletId The ID of the wallet to fetch the balances for\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listWalletBalances: async (walletId, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('listWalletBalances', 'walletId', walletId);\n            const localVarPath = `/v1/wallets/{wallet_id}/balances`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * List wallets belonging to the user.\n         * @summary List wallets\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listWallets: async (limit, page, options = {}) => {\n            const localVarPath = `/v1/wallets`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (page !== undefined) {\n                localVarQueryParameter['page'] = page;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.WalletsApiAxiosParamCreator = WalletsApiAxiosParamCreator;\n/**\n * WalletsApi - functional programming interface\n * @export\n */\nconst WalletsApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.WalletsApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * Create a new wallet scoped to the user.\n         * @summary Create a new wallet\n         * @param {CreateWalletRequest} [createWalletRequest]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async createWallet(createWalletRequest, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.createWallet(createWalletRequest, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['WalletsApi.createWallet']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Get wallet\n         * @summary Get wallet by ID\n         * @param {string} walletId The ID of the wallet to fetch\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async getWallet(walletId, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getWallet(walletId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['WalletsApi.getWallet']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Get the aggregated balance of an asset across all of the addresses in the wallet.\n         * @summary Get the balance of an asset in the wallet\n         * @param {string} walletId The ID of the wallet to fetch the balance for\n         * @param {string} assetId The symbol of the asset to fetch the balance for\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async getWalletBalance(walletId, assetId, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getWalletBalance(walletId, assetId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['WalletsApi.getWalletBalance']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * List the balances of all of the addresses in the wallet aggregated by asset.\n         * @summary List wallet balances\n         * @param {string} walletId The ID of the wallet to fetch the balances for\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async listWalletBalances(walletId, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.listWalletBalances(walletId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['WalletsApi.listWalletBalances']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * List wallets belonging to the user.\n         * @summary List wallets\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async listWallets(limit, page, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.listWallets(limit, page, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['WalletsApi.listWallets']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.WalletsApiFp = WalletsApiFp;\n/**\n * WalletsApi - factory interface\n * @export\n */\nconst WalletsApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.WalletsApiFp)(configuration);\n    return {\n        /**\n         * Create a new wallet scoped to the user.\n         * @summary Create a new wallet\n         * @param {CreateWalletRequest} [createWalletRequest]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createWallet(createWalletRequest, options) {\n            return localVarFp.createWallet(createWalletRequest, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Get wallet\n         * @summary Get wallet by ID\n         * @param {string} walletId The ID of the wallet to fetch\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getWallet(walletId, options) {\n            return localVarFp.getWallet(walletId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Get the aggregated balance of an asset across all of the addresses in the wallet.\n         * @summary Get the balance of an asset in the wallet\n         * @param {string} walletId The ID of the wallet to fetch the balance for\n         * @param {string} assetId The symbol of the asset to fetch the balance for\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getWalletBalance(walletId, assetId, options) {\n            return localVarFp.getWalletBalance(walletId, assetId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * List the balances of all of the addresses in the wallet aggregated by asset.\n         * @summary List wallet balances\n         * @param {string} walletId The ID of the wallet to fetch the balances for\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listWalletBalances(walletId, options) {\n            return localVarFp.listWalletBalances(walletId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * List wallets belonging to the user.\n         * @summary List wallets\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listWallets(limit, page, options) {\n            return localVarFp.listWallets(limit, page, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.WalletsApiFactory = WalletsApiFactory;\n/**\n * WalletsApi - object-oriented interface\n * @export\n * @class WalletsApi\n * @extends {BaseAPI}\n */\nclass WalletsApi extends base_1.BaseAPI {\n    /**\n     * Create a new wallet scoped to the user.\n     * @summary Create a new wallet\n     * @param {CreateWalletRequest} [createWalletRequest]\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof WalletsApi\n     */\n    createWallet(createWalletRequest, options) {\n        return (0, exports.WalletsApiFp)(this.configuration).createWallet(createWalletRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Get wallet\n     * @summary Get wallet by ID\n     * @param {string} walletId The ID of the wallet to fetch\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof WalletsApi\n     */\n    getWallet(walletId, options) {\n        return (0, exports.WalletsApiFp)(this.configuration).getWallet(walletId, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Get the aggregated balance of an asset across all of the addresses in the wallet.\n     * @summary Get the balance of an asset in the wallet\n     * @param {string} walletId The ID of the wallet to fetch the balance for\n     * @param {string} assetId The symbol of the asset to fetch the balance for\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof WalletsApi\n     */\n    getWalletBalance(walletId, assetId, options) {\n        return (0, exports.WalletsApiFp)(this.configuration).getWalletBalance(walletId, assetId, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * List the balances of all of the addresses in the wallet aggregated by asset.\n     * @summary List wallet balances\n     * @param {string} walletId The ID of the wallet to fetch the balances for\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof WalletsApi\n     */\n    listWalletBalances(walletId, options) {\n        return (0, exports.WalletsApiFp)(this.configuration).listWalletBalances(walletId, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * List wallets belonging to the user.\n     * @summary List wallets\n     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof WalletsApi\n     */\n    listWallets(limit, page, options) {\n        return (0, exports.WalletsApiFp)(this.configuration).listWallets(limit, page, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.WalletsApi = WalletsApi;\n/**\n * WebhooksApi - axios parameter creator\n * @export\n */\nconst WebhooksApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Create a new webhook scoped to a wallet\n         * @summary Create a new webhook scoped to a wallet\n         * @param {string} walletId The ID of the wallet to create the webhook for.\n         * @param {CreateWalletWebhookRequest} [createWalletWebhookRequest]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createWalletWebhook: async (walletId, createWalletWebhookRequest, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('createWalletWebhook', 'walletId', walletId);\n            const localVarPath = `/v1/wallets/{wallet_id}/webhooks`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createWalletWebhookRequest, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Create a new webhook\n         * @summary Create a new webhook\n         * @param {CreateWebhookRequest} [createWebhookRequest]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createWebhook: async (createWebhookRequest, options = {}) => {\n            const localVarPath = `/v1/webhooks`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createWebhookRequest, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Delete a webhook\n         * @summary Delete a webhook\n         * @param {string} webhookId The Webhook uuid that needs to be deleted\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        deleteWebhook: async (webhookId, options = {}) => {\n            // verify required parameter 'webhookId' is not null or undefined\n            (0, common_1.assertParamExists)('deleteWebhook', 'webhookId', webhookId);\n            const localVarPath = `/v1/webhooks/{webhook_id}`\n                .replace(`{${\"webhook_id\"}}`, encodeURIComponent(String(webhookId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * List webhooks, optionally filtered by event type.\n         * @summary List webhooks\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listWebhooks: async (limit, page, options = {}) => {\n            const localVarPath = `/v1/webhooks`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (page !== undefined) {\n                localVarQueryParameter['page'] = page;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Update a webhook\n         * @summary Update a webhook\n         * @param {string} webhookId The Webhook id that needs to be updated\n         * @param {UpdateWebhookRequest} [updateWebhookRequest]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        updateWebhook: async (webhookId, updateWebhookRequest, options = {}) => {\n            // verify required parameter 'webhookId' is not null or undefined\n            (0, common_1.assertParamExists)('updateWebhook', 'webhookId', webhookId);\n            const localVarPath = `/v1/webhooks/{webhook_id}`\n                .replace(`{${\"webhook_id\"}}`, encodeURIComponent(String(webhookId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            // authentication apiKey required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            // authentication session required\n            await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, \"Jwt\", configuration);\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updateWebhookRequest, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.WebhooksApiAxiosParamCreator = WebhooksApiAxiosParamCreator;\n/**\n * WebhooksApi - functional programming interface\n * @export\n */\nconst WebhooksApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.WebhooksApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * Create a new webhook scoped to a wallet\n         * @summary Create a new webhook scoped to a wallet\n         * @param {string} walletId The ID of the wallet to create the webhook for.\n         * @param {CreateWalletWebhookRequest} [createWalletWebhookRequest]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async createWalletWebhook(walletId, createWalletWebhookRequest, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.createWalletWebhook(walletId, createWalletWebhookRequest, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['WebhooksApi.createWalletWebhook']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Create a new webhook\n         * @summary Create a new webhook\n         * @param {CreateWebhookRequest} [createWebhookRequest]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async createWebhook(createWebhookRequest, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.createWebhook(createWebhookRequest, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['WebhooksApi.createWebhook']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Delete a webhook\n         * @summary Delete a webhook\n         * @param {string} webhookId The Webhook uuid that needs to be deleted\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async deleteWebhook(webhookId, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWebhook(webhookId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['WebhooksApi.deleteWebhook']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * List webhooks, optionally filtered by event type.\n         * @summary List webhooks\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async listWebhooks(limit, page, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.listWebhooks(limit, page, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['WebhooksApi.listWebhooks']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Update a webhook\n         * @summary Update a webhook\n         * @param {string} webhookId The Webhook id that needs to be updated\n         * @param {UpdateWebhookRequest} [updateWebhookRequest]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async updateWebhook(webhookId, updateWebhookRequest, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWebhook(webhookId, updateWebhookRequest, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['WebhooksApi.updateWebhook']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.WebhooksApiFp = WebhooksApiFp;\n/**\n * WebhooksApi - factory interface\n * @export\n */\nconst WebhooksApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.WebhooksApiFp)(configuration);\n    return {\n        /**\n         * Create a new webhook scoped to a wallet\n         * @summary Create a new webhook scoped to a wallet\n         * @param {string} walletId The ID of the wallet to create the webhook for.\n         * @param {CreateWalletWebhookRequest} [createWalletWebhookRequest]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createWalletWebhook(walletId, createWalletWebhookRequest, options) {\n            return localVarFp.createWalletWebhook(walletId, createWalletWebhookRequest, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Create a new webhook\n         * @summary Create a new webhook\n         * @param {CreateWebhookRequest} [createWebhookRequest]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createWebhook(createWebhookRequest, options) {\n            return localVarFp.createWebhook(createWebhookRequest, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Delete a webhook\n         * @summary Delete a webhook\n         * @param {string} webhookId The Webhook uuid that needs to be deleted\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        deleteWebhook(webhookId, options) {\n            return localVarFp.deleteWebhook(webhookId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * List webhooks, optionally filtered by event type.\n         * @summary List webhooks\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listWebhooks(limit, page, options) {\n            return localVarFp.listWebhooks(limit, page, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Update a webhook\n         * @summary Update a webhook\n         * @param {string} webhookId The Webhook id that needs to be updated\n         * @param {UpdateWebhookRequest} [updateWebhookRequest]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        updateWebhook(webhookId, updateWebhookRequest, options) {\n            return localVarFp.updateWebhook(webhookId, updateWebhookRequest, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.WebhooksApiFactory = WebhooksApiFactory;\n/**\n * WebhooksApi - object-oriented interface\n * @export\n * @class WebhooksApi\n * @extends {BaseAPI}\n */\nclass WebhooksApi extends base_1.BaseAPI {\n    /**\n     * Create a new webhook scoped to a wallet\n     * @summary Create a new webhook scoped to a wallet\n     * @param {string} walletId The ID of the wallet to create the webhook for.\n     * @param {CreateWalletWebhookRequest} [createWalletWebhookRequest]\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof WebhooksApi\n     */\n    createWalletWebhook(walletId, createWalletWebhookRequest, options) {\n        return (0, exports.WebhooksApiFp)(this.configuration).createWalletWebhook(walletId, createWalletWebhookRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Create a new webhook\n     * @summary Create a new webhook\n     * @param {CreateWebhookRequest} [createWebhookRequest]\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof WebhooksApi\n     */\n    createWebhook(createWebhookRequest, options) {\n        return (0, exports.WebhooksApiFp)(this.configuration).createWebhook(createWebhookRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Delete a webhook\n     * @summary Delete a webhook\n     * @param {string} webhookId The Webhook uuid that needs to be deleted\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof WebhooksApi\n     */\n    deleteWebhook(webhookId, options) {\n        return (0, exports.WebhooksApiFp)(this.configuration).deleteWebhook(webhookId, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * List webhooks, optionally filtered by event type.\n     * @summary List webhooks\n     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof WebhooksApi\n     */\n    listWebhooks(limit, page, options) {\n        return (0, exports.WebhooksApiFp)(this.configuration).listWebhooks(limit, page, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Update a webhook\n     * @summary Update a webhook\n     * @param {string} webhookId The Webhook id that needs to be updated\n     * @param {UpdateWebhookRequest} [updateWebhookRequest]\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof WebhooksApi\n     */\n    updateWebhook(webhookId, updateWebhookRequest, options) {\n        return (0, exports.WebhooksApiFp)(this.configuration).updateWebhook(webhookId, updateWebhookRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.WebhooksApi = WebhooksApi;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NsaWVudC9hcGkuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHlCQUF5QixHQUFHLGdDQUFnQyxHQUFHLDJCQUEyQixHQUFHLDBDQUEwQyxHQUFHLGVBQWUsR0FBRyxzQkFBc0IsR0FBRyxpQkFBaUIsR0FBRyxnQ0FBZ0MsR0FBRyw0QkFBNEIsR0FBRyxtQ0FBbUMsR0FBRyw4QkFBOEIsR0FBRyw2Q0FBNkMsR0FBRyw4QkFBOEIsR0FBRyxxQ0FBcUMsR0FBRyxnQ0FBZ0MsR0FBRywrQ0FBK0MsR0FBRyx5QkFBeUIsR0FBRyxnQ0FBZ0MsR0FBRywyQkFBMkIsR0FBRywwQ0FBMEMsR0FBRyx5QkFBeUIsR0FBRyxnQ0FBZ0MsR0FBRywyQkFBMkIsR0FBRywwQ0FBMEMsR0FBRyxpQkFBaUIsR0FBRyx3QkFBd0IsR0FBRyxtQkFBbUIsR0FBRyxrQ0FBa0MsR0FBRyxvQkFBb0IsR0FBRywyQkFBMkIsR0FBRyxzQkFBc0IsR0FBRyxxQ0FBcUMsR0FBRyxxQkFBcUIsR0FBRyx3QkFBd0IsR0FBRyxvQ0FBb0MsR0FBRyx1QkFBdUIsR0FBRywrQkFBK0IsR0FBRyx1QkFBdUIsR0FBRyw2QkFBNkIsR0FBRyx5QkFBeUIsR0FBRywyQkFBMkIsR0FBRyw4QkFBOEIsR0FBRyxrQ0FBa0MsR0FBRywrQkFBK0IsR0FBRyw2QkFBNkIsR0FBRyx5QkFBeUIsR0FBRyxrQ0FBa0MsR0FBRyx5QkFBeUIsR0FBRyxpQ0FBaUMsR0FBRywrQkFBK0I7QUFDdGtELG9DQUFvQyxHQUFHLGtCQUFrQixHQUFHLHlCQUF5QixHQUFHLG9CQUFvQixHQUFHLG1DQUFtQyxHQUFHLGdCQUFnQixHQUFHLHVCQUF1QixHQUFHLGtCQUFrQixHQUFHLGlDQUFpQyxHQUFHLG9CQUFvQixHQUFHLDJCQUEyQixHQUFHLHNCQUFzQixHQUFHLHFDQUFxQyxHQUFHLDZCQUE2QixHQUFHLG9DQUFvQyxHQUFHLCtCQUErQixHQUFHLDhDQUE4QyxHQUFHLGlCQUFpQixHQUFHLHdCQUF3QixHQUFHLG1CQUFtQixHQUFHLGtDQUFrQyxHQUFHLGdCQUFnQixHQUFHLHVCQUF1QixHQUFHLGtCQUFrQixHQUFHLGlDQUFpQyxHQUFHLHVCQUF1QixHQUFHLDhCQUE4QixHQUFHLHlCQUF5QixHQUFHLHdDQUF3QyxHQUFHLHlCQUF5QixHQUFHLGdDQUFnQyxHQUFHLDJCQUEyQixHQUFHLDBDQUEwQyxHQUFHLHdCQUF3QixHQUFHLCtCQUErQixHQUFHLDBCQUEwQixHQUFHLHlDQUF5QyxHQUFHLHFCQUFxQixHQUFHLDRCQUE0QixHQUFHLHVCQUF1QixHQUFHLHNDQUFzQyxHQUFHLHlDQUF5QyxHQUFHLDBCQUEwQixHQUFHLGlDQUFpQyxHQUFHLDRCQUE0QixHQUFHLDJDQUEyQyxHQUFHLG1CQUFtQixHQUFHLDBCQUEwQixHQUFHLHFCQUFxQixHQUFHLG9DQUFvQztBQUNoaEQsbUJBQW1CLEdBQUcsMEJBQTBCLEdBQUcscUJBQXFCO0FBQ3hFLGdDQUFnQyxtQkFBTyxDQUFDLDZEQUFPO0FBQy9DO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQU8sQ0FBQyxtRkFBVTtBQUNuQztBQUNBLGVBQWUsbUJBQU8sQ0FBQywrRUFBUTtBQUMvQiwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsc0JBQXNCO0FBQ3pDLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBLDBFQUEwRTtBQUMxRTtBQUNBO0FBQ0EsK0NBQStDLFVBQVU7QUFDekQsMkJBQTJCLEVBQUUsYUFBYTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsK0JBQStCO0FBQ2xELG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBLHVHQUF1RztBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxVQUFVLFlBQVksV0FBVztBQUNoRiwyQkFBMkIsRUFBRSxhQUFhO0FBQzFDLDJCQUEyQixFQUFFLGNBQWM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFVBQVUsWUFBWSxXQUFXO0FBQ2hGLDJCQUEyQixFQUFFLGFBQWE7QUFDMUMsMkJBQTJCLEVBQUUsY0FBYztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQSw0RUFBNEU7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFVBQVUsWUFBWSxXQUFXLFdBQVcsU0FBUztBQUNwRywyQkFBMkIsRUFBRSxhQUFhO0FBQzFDLDJCQUEyQixFQUFFLGNBQWM7QUFDM0MsMkJBQTJCLEVBQUUsWUFBWTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQSx5RkFBeUY7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFVBQVUsWUFBWSxXQUFXLHFCQUFxQixxQkFBcUI7QUFDMUgsMkJBQTJCLEVBQUUsYUFBYTtBQUMxQywyQkFBMkIsRUFBRSxjQUFjO0FBQzNDLDJCQUEyQixFQUFFLHdCQUF3QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUSwwRUFBMEU7QUFDckcsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0EsMkVBQTJFO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFVBQVUsWUFBWSxXQUFXO0FBQ2hGLDJCQUEyQixFQUFFLGFBQWE7QUFDMUMsMkJBQTJCLEVBQUUsY0FBYztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUSwwRUFBMEU7QUFDckcsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQSwrQ0FBK0MsVUFBVTtBQUN6RCwyQkFBMkIsRUFBRSxhQUFhO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRLDBFQUEwRTtBQUNyRyxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQSxvRkFBb0Y7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsVUFBVSxZQUFZLFdBQVc7QUFDaEYsMkJBQTJCLEVBQUUsYUFBYTtBQUMxQywyQkFBMkIsRUFBRSxjQUFjO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixHQUFHO0FBQ3RCO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0EsNkVBQTZFO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFVBQVUsWUFBWSxXQUFXO0FBQ2hGLDJCQUEyQixFQUFFLGFBQWE7QUFDMUMsMkJBQTJCLEVBQUUsY0FBYztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsc0JBQXNCO0FBQ3pDLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLCtCQUErQjtBQUNsRCxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRLDBFQUEwRTtBQUNyRyxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRLDBFQUEwRTtBQUNyRyxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRLDBFQUEwRTtBQUNyRyxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixHQUFHO0FBQ3RCO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLHNCQUFzQjtBQUN6QyxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQiwrQkFBK0I7QUFDbEQsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUSwwRUFBMEU7QUFDckcsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUSwwRUFBMEU7QUFDckcsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUSwwRUFBMEU7QUFDckcsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsR0FBRztBQUN0QjtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsc0JBQXNCO0FBQ3JDLGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSwrQkFBK0I7QUFDOUMsZUFBZSxHQUFHO0FBQ2xCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLEdBQUc7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLEdBQUc7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLEdBQUc7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUSwwRUFBMEU7QUFDakcsZUFBZSxHQUFHO0FBQ2xCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVEsMEVBQTBFO0FBQ2pHLGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUSwwRUFBMEU7QUFDakcsZUFBZSxHQUFHO0FBQ2xCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxHQUFHO0FBQ2xCO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsV0FBVyxTQUFTLFNBQVM7QUFDN0UsMkJBQTJCLEVBQUUsY0FBYztBQUMzQywyQkFBMkIsRUFBRSxZQUFZO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxHQUFHO0FBQ2xCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVEsMEVBQTBFO0FBQ3JHLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBLHFHQUFxRztBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsV0FBVyxZQUFZLFdBQVcsa0JBQWtCLFNBQVM7QUFDN0csMkJBQTJCLEVBQUUsY0FBYztBQUMzQywyQkFBMkIsRUFBRSxjQUFjO0FBQzNDLDJCQUEyQixFQUFFLFlBQVk7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRLDBFQUEwRTtBQUNyRyxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUSwwRUFBMEU7QUFDckcsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRLDBFQUEwRTtBQUNqRyxlQUFlLEdBQUc7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUSxrRkFBa0YsUUFBUTtBQUNySCxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUSw4RUFBOEU7QUFDekcsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0EsNEpBQTRKO0FBQzVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsV0FBVyxrQkFBa0IsaUJBQWlCO0FBQzlGLDJCQUEyQixFQUFFLGNBQWM7QUFDM0MsMkJBQTJCLEVBQUUsb0JBQW9CO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUSxrRkFBa0YsUUFBUTtBQUNySCxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUSw4RUFBOEU7QUFDekcsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVEsa0ZBQWtGLFFBQVE7QUFDckgsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVEsOEVBQThFO0FBQ3pHLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVEsa0ZBQWtGLFFBQVE7QUFDakgsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUSw4RUFBOEU7QUFDckcsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxHQUFHO0FBQ2xCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLG9DQUFvQztBQUN2RCxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQSx1SUFBdUk7QUFDdkk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxVQUFVLFlBQVksV0FBVyx1QkFBdUIsdUJBQXVCO0FBQzlILDJCQUEyQixFQUFFLGFBQWE7QUFDMUMsMkJBQTJCLEVBQUUsY0FBYztBQUMzQywyQkFBMkIsRUFBRSwwQkFBMEI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLGlDQUFpQztBQUNwRCxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQSwyR0FBMkc7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFVBQVUsWUFBWSxXQUFXO0FBQ2hGLDJCQUEyQixFQUFFLGFBQWE7QUFDMUMsMkJBQTJCLEVBQUUsY0FBYztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQSw2RkFBNkY7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFVBQVUsWUFBWSxXQUFXLHVCQUF1Qix1QkFBdUI7QUFDOUgsMkJBQTJCLEVBQUUsYUFBYTtBQUMxQywyQkFBMkIsRUFBRSxjQUFjO0FBQzNDLDJCQUEyQixFQUFFLDBCQUEwQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUSwwRUFBMEU7QUFDckcsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0Esc0ZBQXNGO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFVBQVUsWUFBWSxXQUFXO0FBQ2hGLDJCQUEyQixFQUFFLGFBQWE7QUFDMUMsMkJBQTJCLEVBQUUsY0FBYztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLG9DQUFvQztBQUN2RCxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixpQ0FBaUM7QUFDcEQsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRLDBFQUEwRTtBQUNyRyxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsb0NBQW9DO0FBQ3ZELG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLGlDQUFpQztBQUNwRCxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVEsMEVBQTBFO0FBQ3JHLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxvQ0FBb0M7QUFDbkQsZUFBZSxHQUFHO0FBQ2xCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLGlDQUFpQztBQUNoRCxlQUFlLEdBQUc7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLEdBQUc7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVEsMEVBQTBFO0FBQ2pHLGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixxQ0FBcUM7QUFDeEQsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0Esb0hBQW9IO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxXQUFXLFlBQVksV0FBVztBQUNsRiwyQkFBMkIsRUFBRSxjQUFjO0FBQzNDLDJCQUEyQixFQUFFLGNBQWM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixrQ0FBa0M7QUFDckQsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0EsMEhBQTBIO0FBQzFIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsV0FBVyxZQUFZLFdBQVcsWUFBWSxZQUFZO0FBQzFHLDJCQUEyQixFQUFFLGNBQWM7QUFDM0MsMkJBQTJCLEVBQUUsY0FBYztBQUMzQywyQkFBMkIsRUFBRSxlQUFlO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQiwrQkFBK0I7QUFDbEQsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0Esd0dBQXdHO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxXQUFXLFlBQVksV0FBVztBQUNsRiwyQkFBMkIsRUFBRSxjQUFjO0FBQzNDLDJCQUEyQixFQUFFLGNBQWM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0EscUZBQXFGO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxXQUFXLFlBQVksV0FBVyxXQUFXLFNBQVM7QUFDdEcsMkJBQTJCLEVBQUUsY0FBYztBQUMzQywyQkFBMkIsRUFBRSxjQUFjO0FBQzNDLDJCQUEyQixFQUFFLFlBQVk7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0Esa0ZBQWtGO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxXQUFXLFlBQVksV0FBVyxZQUFZLFlBQVk7QUFDMUcsMkJBQTJCLEVBQUUsY0FBYztBQUMzQywyQkFBMkIsRUFBRSxjQUFjO0FBQzNDLDJCQUEyQixFQUFFLGVBQWU7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQSwrRUFBK0U7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFdBQVcsWUFBWSxXQUFXLFNBQVMsUUFBUTtBQUNuRywyQkFBMkIsRUFBRSxjQUFjO0FBQzNDLDJCQUEyQixFQUFFLGNBQWM7QUFDM0MsMkJBQTJCLEVBQUUsV0FBVztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUSwwRUFBMEU7QUFDckcsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0Esb0ZBQW9GO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFdBQVcsWUFBWSxXQUFXO0FBQ2xGLDJCQUEyQixFQUFFLGNBQWM7QUFDM0MsMkJBQTJCLEVBQUUsY0FBYztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsU0FBUztBQUM1QixtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQSxnR0FBZ0c7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsV0FBVyxZQUFZLFdBQVc7QUFDbEYsMkJBQTJCLEVBQUUsY0FBYztBQUMzQywyQkFBMkIsRUFBRSxjQUFjO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIscUNBQXFDO0FBQ3hELG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLGtDQUFrQztBQUNyRCxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQiwrQkFBK0I7QUFDbEQsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUSwwRUFBMEU7QUFDckcsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsU0FBUztBQUM1QixtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIscUNBQXFDO0FBQ3hELG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLGtDQUFrQztBQUNyRCxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQiwrQkFBK0I7QUFDbEQsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUSwwRUFBMEU7QUFDckcsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsU0FBUztBQUM1QixtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxxQ0FBcUM7QUFDcEQsZUFBZSxHQUFHO0FBQ2xCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxrQ0FBa0M7QUFDakQsZUFBZSxHQUFHO0FBQ2xCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLCtCQUErQjtBQUM5QyxlQUFlLEdBQUc7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLEdBQUc7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLEdBQUc7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLEdBQUc7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUSwwRUFBMEU7QUFDakcsZUFBZSxHQUFHO0FBQ2xCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQiw0QkFBNEI7QUFDL0MsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0EsaUdBQWlHO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxVQUFVLFlBQVksV0FBVztBQUNoRiwyQkFBMkIsRUFBRSxhQUFhO0FBQzFDLDJCQUEyQixFQUFFLGNBQWM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLHdCQUF3QjtBQUMzQyxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQSx5RkFBeUY7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFVBQVUsWUFBWSxXQUFXO0FBQ2hGLDJCQUEyQixFQUFFLGFBQWE7QUFDMUMsMkJBQTJCLEVBQUUsY0FBYztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQSxtRkFBbUY7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFVBQVUsWUFBWSxXQUFXLGtCQUFrQixrQkFBa0I7QUFDcEgsMkJBQTJCLEVBQUUsYUFBYTtBQUMxQywyQkFBMkIsRUFBRSxjQUFjO0FBQzNDLDJCQUEyQixFQUFFLHFCQUFxQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUSwwRUFBMEU7QUFDckcsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0EsaUZBQWlGO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFVBQVUsWUFBWSxXQUFXO0FBQ2hGLDJCQUEyQixFQUFFLGFBQWE7QUFDMUMsMkJBQTJCLEVBQUUsY0FBYztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLDRCQUE0QjtBQUMvQyxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQix3QkFBd0I7QUFDM0MsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRLDBFQUEwRTtBQUNyRyxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsNEJBQTRCO0FBQy9DLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLHdCQUF3QjtBQUMzQyxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVEsMEVBQTBFO0FBQ3JHLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLDRCQUE0QjtBQUMzQyxlQUFlLEdBQUc7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsd0JBQXdCO0FBQ3ZDLGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUSwwRUFBMEU7QUFDakcsZUFBZSxHQUFHO0FBQ2xCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLGtDQUFrQztBQUNyRCxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQSxpSUFBaUk7QUFDakk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxVQUFVLFlBQVksV0FBVyxxQkFBcUIscUJBQXFCO0FBQzFILDJCQUEyQixFQUFFLGFBQWE7QUFDMUMsMkJBQTJCLEVBQUUsY0FBYztBQUMzQywyQkFBMkIsRUFBRSx3QkFBd0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLCtCQUErQjtBQUNsRCxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQSx1R0FBdUc7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFVBQVUsWUFBWSxXQUFXO0FBQ2hGLDJCQUEyQixFQUFFLGFBQWE7QUFDMUMsMkJBQTJCLEVBQUUsY0FBYztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQSx5RkFBeUY7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFVBQVUsWUFBWSxXQUFXLHFCQUFxQixxQkFBcUI7QUFDMUgsMkJBQTJCLEVBQUUsYUFBYTtBQUMxQywyQkFBMkIsRUFBRSxjQUFjO0FBQzNDLDJCQUEyQixFQUFFLHdCQUF3QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLGtDQUFrQztBQUNyRCxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQiwrQkFBK0I7QUFDbEQsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsa0NBQWtDO0FBQ3JELG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLCtCQUErQjtBQUNsRCxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxrQ0FBa0M7QUFDakQsZUFBZSxHQUFHO0FBQ2xCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLCtCQUErQjtBQUM5QyxlQUFlLEdBQUc7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLEdBQUc7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBLGdEQUFnRCxXQUFXO0FBQzNELDJCQUEyQixFQUFFLGNBQWM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQiwwQ0FBMEM7QUFDN0QsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVEsMEVBQTBFO0FBQ3JHLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBLCtGQUErRjtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxXQUFXLFlBQVksV0FBVztBQUNsRiwyQkFBMkIsRUFBRSxjQUFjO0FBQzNDLDJCQUEyQixFQUFFLGNBQWM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQiwwQ0FBMEM7QUFDN0QsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVEsMEVBQTBFO0FBQ3JHLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQiwwQ0FBMEM7QUFDN0QsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVEsMEVBQTBFO0FBQ3JHLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLDBDQUEwQztBQUN6RCxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRLDBFQUEwRTtBQUNqRyxlQUFlLEdBQUc7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFdBQVcsWUFBWSxXQUFXO0FBQ2xGLDJCQUEyQixFQUFFLGNBQWM7QUFDM0MsMkJBQTJCLEVBQUUsY0FBYztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwyQkFBMkI7QUFDOUMsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0EsMEVBQTBFO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQSxzREFBc0QsaUJBQWlCO0FBQ3ZFLDJCQUEyQixFQUFFLG9CQUFvQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUSwwRUFBMEU7QUFDckcsbUJBQW1CLEdBQUc7QUFDdEI7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSxnRkFBZ0Y7QUFDaEY7QUFDQTtBQUNBLHNEQUFzRCxpQkFBaUI7QUFDdkUsMkJBQTJCLEVBQUUsb0JBQW9CO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVEsMEVBQTBFO0FBQ3JHLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQix5QkFBeUI7QUFDNUMsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0EsdUdBQXVHO0FBQ3ZHO0FBQ0E7QUFDQSxzREFBc0QsaUJBQWlCO0FBQ3ZFLDJCQUEyQixFQUFFLG9CQUFvQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsOEJBQThCO0FBQ2pELG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBLGlIQUFpSDtBQUNqSDtBQUNBO0FBQ0Esc0RBQXNELGlCQUFpQjtBQUN2RSwyQkFBMkIsRUFBRSxvQkFBb0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwyQkFBMkI7QUFDOUMsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRLDBFQUEwRTtBQUNyRyxtQkFBbUIsR0FBRztBQUN0QjtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVEsMEVBQTBFO0FBQ3JHLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLHlCQUF5QjtBQUM1QyxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQiw4QkFBOEI7QUFDakQsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDJCQUEyQjtBQUM5QyxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVEsMEVBQTBFO0FBQ3JHLG1CQUFtQixHQUFHO0FBQ3RCO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUSwwRUFBMEU7QUFDckcsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIseUJBQXlCO0FBQzVDLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLDhCQUE4QjtBQUNqRCxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMkJBQTJCO0FBQzFDLGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLEdBQUc7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUSwwRUFBMEU7QUFDakcsZUFBZSxHQUFHO0FBQ2xCO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRLDBFQUEwRTtBQUNqRyxlQUFlLEdBQUc7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSx5QkFBeUI7QUFDeEMsZUFBZSxHQUFHO0FBQ2xCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsOEJBQThCO0FBQzdDLGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw2QkFBNkI7QUFDaEQsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0EsOEVBQThFO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQiw0QkFBNEI7QUFDL0MsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0EsaUdBQWlHO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxVQUFVLFlBQVksV0FBVztBQUNoRiwyQkFBMkIsRUFBRSxhQUFhO0FBQzFDLDJCQUEyQixFQUFFLGNBQWM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLDRCQUE0QjtBQUMvQyxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQSxrSEFBa0g7QUFDbEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxVQUFVLFlBQVksV0FBVyxrQkFBa0Isa0JBQWtCO0FBQ3BILDJCQUEyQixFQUFFLGFBQWE7QUFDMUMsMkJBQTJCLEVBQUUsY0FBYztBQUMzQywyQkFBMkIsRUFBRSxxQkFBcUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxVQUFVLFlBQVksV0FBVyxrQkFBa0Isa0JBQWtCO0FBQ3BILDJCQUEyQixFQUFFLGFBQWE7QUFDMUMsMkJBQTJCLEVBQUUsY0FBYztBQUMzQywyQkFBMkIsRUFBRSxxQkFBcUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLHFCQUFxQjtBQUN4QyxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQSwwRkFBMEY7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFdBQVcsa0JBQWtCLGlCQUFpQjtBQUM5RiwyQkFBMkIsRUFBRSxjQUFjO0FBQzNDLDJCQUEyQixFQUFFLG9CQUFvQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVEsa0ZBQWtGLFFBQVE7QUFDckgsbUJBQW1CLDhCQUE4QjtBQUNqRCxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQSw0R0FBNEc7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsV0FBVyxrQkFBa0IsaUJBQWlCO0FBQzlGLDJCQUEyQixFQUFFLGNBQWM7QUFDM0MsMkJBQTJCLEVBQUUsb0JBQW9CO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUSxrRkFBa0YsUUFBUTtBQUNySCxtQkFBbUIsNEJBQTRCO0FBQy9DLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBLHdHQUF3RztBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxXQUFXLGtCQUFrQixpQkFBaUI7QUFDOUYsMkJBQTJCLEVBQUUsY0FBYztBQUMzQywyQkFBMkIsRUFBRSxvQkFBb0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNkJBQTZCO0FBQ2hELG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLDRCQUE0QjtBQUMvQyxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQiw0QkFBNEI7QUFDL0MsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLHFCQUFxQjtBQUN4QyxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRLGtGQUFrRixRQUFRO0FBQ3JILG1CQUFtQiw4QkFBOEI7QUFDakQsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUSxrRkFBa0YsUUFBUTtBQUNySCxtQkFBbUIsNEJBQTRCO0FBQy9DLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw2QkFBNkI7QUFDaEQsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsNEJBQTRCO0FBQy9DLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLDRCQUE0QjtBQUMvQyxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIscUJBQXFCO0FBQ3hDLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVEsa0ZBQWtGLFFBQVE7QUFDckgsbUJBQW1CLDhCQUE4QjtBQUNqRCxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRLGtGQUFrRixRQUFRO0FBQ3JILG1CQUFtQiw0QkFBNEI7QUFDL0MsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDZCQUE2QjtBQUM1QyxlQUFlLEdBQUc7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsNEJBQTRCO0FBQzNDLGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsNEJBQTRCO0FBQzNDLGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLEdBQUc7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUscUJBQXFCO0FBQ3BDLGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVEsa0ZBQWtGLFFBQVE7QUFDakgsZUFBZSw4QkFBOEI7QUFDN0MsZUFBZSxHQUFHO0FBQ2xCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUSxrRkFBa0YsUUFBUTtBQUNqSCxlQUFlLDRCQUE0QjtBQUMzQyxlQUFlLEdBQUc7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsK0JBQStCO0FBQ2xELG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBLGtIQUFrSDtBQUNsSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxxQkFBcUIsa0JBQWtCLGFBQWE7QUFDekcsMkJBQTJCLEVBQUUsd0JBQXdCO0FBQ3JELDJCQUEyQixFQUFFLGdCQUFnQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMEJBQTBCO0FBQzdDLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBLHdFQUF3RTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQiw0QkFBNEI7QUFDL0MsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0EsMkdBQTJHO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELHFCQUFxQixXQUFXLFdBQVc7QUFDaEcsMkJBQTJCLEVBQUUsd0JBQXdCO0FBQ3JELDJCQUEyQixFQUFFLGNBQWM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0EsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQSxxREFBcUQscUJBQXFCO0FBQzFFLDJCQUEyQixFQUFFLHdCQUF3QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQSw2RUFBNkU7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQscUJBQXFCLGtCQUFrQixhQUFhO0FBQ3pHLDJCQUEyQixFQUFFLHdCQUF3QjtBQUNyRCwyQkFBMkIsRUFBRSxnQkFBZ0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVEsMEVBQTBFO0FBQ3JHLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsK0JBQStCO0FBQ2xELG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDBCQUEwQjtBQUM3QyxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQiw0QkFBNEI7QUFDL0MsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVEsMEVBQTBFO0FBQ3JHLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQiwrQkFBK0I7QUFDbEQsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMEJBQTBCO0FBQzdDLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLDRCQUE0QjtBQUMvQyxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUSwwRUFBMEU7QUFDckcsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsK0JBQStCO0FBQzlDLGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMEJBQTBCO0FBQ3pDLGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSw0QkFBNEI7QUFDM0MsZUFBZSxHQUFHO0FBQ2xCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxHQUFHO0FBQ2xCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUSwwRUFBMEU7QUFDakcsZUFBZSxHQUFHO0FBQ2xCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDhCQUE4QjtBQUNqRCxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQSxnRkFBZ0Y7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRLDBFQUEwRTtBQUNyRyxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQSwySEFBMkg7QUFDM0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsV0FBVyxZQUFZLFdBQVc7QUFDbEYsMkJBQTJCLEVBQUUsY0FBYztBQUMzQywyQkFBMkIsRUFBRSxjQUFjO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDRCQUE0QjtBQUMvQyxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUSwwRUFBMEU7QUFDckcsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0EseUZBQXlGO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQSxrR0FBa0c7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFdBQVcsWUFBWSxXQUFXLHFCQUFxQixxQkFBcUI7QUFDNUgsMkJBQTJCLEVBQUUsY0FBYztBQUMzQywyQkFBMkIsRUFBRSxjQUFjO0FBQzNDLDJCQUEyQixFQUFFLHdCQUF3QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMEJBQTBCO0FBQzdDLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBLHdFQUF3RTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0EsMEVBQTBFO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxXQUFXLFNBQVMsU0FBUyxhQUFhLGFBQWE7QUFDdkcsMkJBQTJCLEVBQUUsY0FBYztBQUMzQywyQkFBMkIsRUFBRSxZQUFZO0FBQ3pDLDJCQUEyQixFQUFFLGdCQUFnQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsaUJBQWlCO0FBQ3BDLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRLDBFQUEwRTtBQUNyRyxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQSxvRkFBb0Y7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsV0FBVyxTQUFTLFNBQVM7QUFDN0UsMkJBQTJCLEVBQUUsY0FBYztBQUMzQywyQkFBMkIsRUFBRSxZQUFZO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsOEJBQThCO0FBQ2pELG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVEsMEVBQTBFO0FBQ3JHLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDRCQUE0QjtBQUMvQyxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUSwwRUFBMEU7QUFDckcsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwwQkFBMEI7QUFDN0MsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixpQkFBaUI7QUFDcEMsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVEsMEVBQTBFO0FBQ3JHLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw4QkFBOEI7QUFDakQsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUSwwRUFBMEU7QUFDckcsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNEJBQTRCO0FBQy9DLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRLDBFQUEwRTtBQUNyRyxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDBCQUEwQjtBQUM3QyxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLGlCQUFpQjtBQUNwQyxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUSwwRUFBMEU7QUFDckcsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDhCQUE4QjtBQUM3QyxlQUFlLEdBQUc7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVEsMEVBQTBFO0FBQ2pHLGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNEJBQTRCO0FBQzNDLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVEsMEVBQTBFO0FBQ2pHLGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMEJBQTBCO0FBQ3pDLGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxpQkFBaUI7QUFDaEMsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUSwwRUFBMEU7QUFDakcsZUFBZSxHQUFHO0FBQ2xCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLHVCQUF1QjtBQUMxQyxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQSxnR0FBZ0c7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxVQUFVLFlBQVksV0FBVyxTQUFTLFNBQVM7QUFDbEcsMkJBQTJCLEVBQUUsYUFBYTtBQUMxQywyQkFBMkIsRUFBRSxjQUFjO0FBQzNDLDJCQUEyQixFQUFFLFlBQVk7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLG9CQUFvQjtBQUN2QyxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQSxpRkFBaUY7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFVBQVUsWUFBWSxXQUFXO0FBQ2hGLDJCQUEyQixFQUFFLGFBQWE7QUFDMUMsMkJBQTJCLEVBQUUsY0FBYztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFVBQVUsWUFBWSxXQUFXLFNBQVMsU0FBUztBQUNsRywyQkFBMkIsRUFBRSxhQUFhO0FBQzFDLDJCQUEyQixFQUFFLGNBQWM7QUFDM0MsMkJBQTJCLEVBQUUsWUFBWTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUSwwRUFBMEU7QUFDckcsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0EseUVBQXlFO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFVBQVUsWUFBWSxXQUFXO0FBQ2hGLDJCQUEyQixFQUFFLGFBQWE7QUFDMUMsMkJBQTJCLEVBQUUsY0FBYztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLHVCQUF1QjtBQUMxQyxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixvQkFBb0I7QUFDdkMsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRLDBFQUEwRTtBQUNyRyxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsdUJBQXVCO0FBQzFDLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLG9CQUFvQjtBQUN2QyxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVEsMEVBQTBFO0FBQ3JHLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSx1QkFBdUI7QUFDdEMsZUFBZSxHQUFHO0FBQ2xCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLG9CQUFvQjtBQUNuQyxlQUFlLEdBQUc7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLEdBQUc7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVEsMEVBQTBFO0FBQ2pHLGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRLDBFQUEwRTtBQUNyRyxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQSx1RkFBdUY7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsV0FBVyxZQUFZLFdBQVc7QUFDbEYsMkJBQTJCLEVBQUUsY0FBYztBQUMzQywyQkFBMkIsRUFBRSxjQUFjO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUSwwRUFBMEU7QUFDckcsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVEsMEVBQTBFO0FBQ3JHLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRLDBFQUEwRTtBQUNqRyxlQUFlLEdBQUc7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsMEJBQTBCO0FBQzdDLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBLHlHQUF5RztBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFVBQVUsWUFBWSxXQUFXLFlBQVksWUFBWTtBQUN4RywyQkFBMkIsRUFBRSxhQUFhO0FBQzFDLDJCQUEyQixFQUFFLGNBQWM7QUFDM0MsMkJBQTJCLEVBQUUsZUFBZTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsdUJBQXVCO0FBQzFDLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBLHVGQUF1RjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsVUFBVSxZQUFZLFdBQVc7QUFDaEYsMkJBQTJCLEVBQUUsYUFBYTtBQUMxQywyQkFBMkIsRUFBRSxjQUFjO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBLHlFQUF5RTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsVUFBVSxZQUFZLFdBQVcsWUFBWSxZQUFZO0FBQ3hHLDJCQUEyQixFQUFFLGFBQWE7QUFDMUMsMkJBQTJCLEVBQUUsY0FBYztBQUMzQywyQkFBMkIsRUFBRSxlQUFlO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRLDBFQUEwRTtBQUNyRyxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQSw0RUFBNEU7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsVUFBVSxZQUFZLFdBQVc7QUFDaEYsMkJBQTJCLEVBQUUsYUFBYTtBQUMxQywyQkFBMkIsRUFBRSxjQUFjO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsMEJBQTBCO0FBQzdDLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLHVCQUF1QjtBQUMxQyxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVEsMEVBQTBFO0FBQ3JHLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQiwwQkFBMEI7QUFDN0MsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsdUJBQXVCO0FBQzFDLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUSwwRUFBMEU7QUFDckcsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLDBCQUEwQjtBQUN6QyxlQUFlLEdBQUc7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsdUJBQXVCO0FBQ3RDLGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUSwwRUFBMEU7QUFDakcsZUFBZSxHQUFHO0FBQ2xCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixxQkFBcUI7QUFDeEMsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQSwrQ0FBK0MsVUFBVTtBQUN6RCwyQkFBMkIsRUFBRSxhQUFhO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxVQUFVLFdBQVcsU0FBUztBQUM3RSwyQkFBMkIsRUFBRSxhQUFhO0FBQzFDLDJCQUEyQixFQUFFLFlBQVk7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQSwrQ0FBK0MsVUFBVTtBQUN6RCwyQkFBMkIsRUFBRSxhQUFhO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRLDBFQUEwRTtBQUNyRyxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHFCQUFxQjtBQUN4QyxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRLDBFQUEwRTtBQUNyRyxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIscUJBQXFCO0FBQ3hDLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVEsMEVBQTBFO0FBQ3JHLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxQkFBcUI7QUFDcEMsZUFBZSxHQUFHO0FBQ2xCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxHQUFHO0FBQ2xCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVEsMEVBQTBFO0FBQ2pHLGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQiw0QkFBNEI7QUFDL0MsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0Esc0ZBQXNGO0FBQ3RGO0FBQ0E7QUFDQSwrQ0FBK0MsVUFBVTtBQUN6RCwyQkFBMkIsRUFBRSxhQUFhO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBLGdEQUFnRCxXQUFXO0FBQzNELDJCQUEyQixFQUFFLGNBQWM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVEsMEVBQTBFO0FBQ3JHLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixzQkFBc0I7QUFDekMsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0EsMkVBQTJFO0FBQzNFO0FBQ0E7QUFDQSxnREFBZ0QsV0FBVztBQUMzRCwyQkFBMkIsRUFBRSxjQUFjO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLDRCQUE0QjtBQUMvQyxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekMsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRLDBFQUEwRTtBQUNyRyxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixzQkFBc0I7QUFDekMsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLDRCQUE0QjtBQUMvQyxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekMsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRLDBFQUEwRTtBQUNyRyxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixzQkFBc0I7QUFDekMsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSw0QkFBNEI7QUFDM0MsZUFBZSxHQUFHO0FBQ2xCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxzQkFBc0I7QUFDckMsZUFBZSxHQUFHO0FBQ2xCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVEsMEVBQTBFO0FBQ2pHLGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLHNCQUFzQjtBQUNyQyxlQUFlLEdBQUc7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cnZpdmFsLWZ1bi8uL25vZGVfbW9kdWxlcy9AY29pbmJhc2UvY29pbmJhc2Utc2RrL2Rpc3QvY2xpZW50L2FwaS5qcz80ZDExIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyogdHNsaW50OmRpc2FibGUgKi9cbi8qIGVzbGludC1kaXNhYmxlICovXG4vKipcbiAqIENvaW5iYXNlIFBsYXRmb3JtIEFQSVxuICogVGhpcyBpcyB0aGUgT3BlbkFQSSAzLjAgc3BlY2lmaWNhdGlvbiBmb3IgdGhlIENvaW5iYXNlIFBsYXRmb3JtIEFQSXMsIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCB0aGUgQ29pbmJhc2UgUGxhdGZvcm0gU0RLcy5cbiAqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgT3BlbkFQSSBkb2N1bWVudDogMC4wLjEtYWxwaGFcbiAqXG4gKlxuICogTk9URTogVGhpcyBjbGFzcyBpcyBhdXRvIGdlbmVyYXRlZCBieSBPcGVuQVBJIEdlbmVyYXRvciAoaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoKS5cbiAqIGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaFxuICogRG8gbm90IGVkaXQgdGhlIGNsYXNzIG1hbnVhbGx5LlxuICovXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1QQ1dhbGxldFN0YWtlQXBpID0gZXhwb3J0cy5NUENXYWxsZXRTdGFrZUFwaUZhY3RvcnkgPSBleHBvcnRzLk1QQ1dhbGxldFN0YWtlQXBpRnAgPSBleHBvcnRzLk1QQ1dhbGxldFN0YWtlQXBpQXhpb3NQYXJhbUNyZWF0b3IgPSBleHBvcnRzLkZ1bmRBcGkgPSBleHBvcnRzLkZ1bmRBcGlGYWN0b3J5ID0gZXhwb3J0cy5GdW5kQXBpRnAgPSBleHBvcnRzLkZ1bmRBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IGV4cG9ydHMuRXh0ZXJuYWxBZGRyZXNzZXNBcGkgPSBleHBvcnRzLkV4dGVybmFsQWRkcmVzc2VzQXBpRmFjdG9yeSA9IGV4cG9ydHMuRXh0ZXJuYWxBZGRyZXNzZXNBcGlGcCA9IGV4cG9ydHMuRXh0ZXJuYWxBZGRyZXNzZXNBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IGV4cG9ydHMuQ29udHJhY3RJbnZvY2F0aW9uc0FwaSA9IGV4cG9ydHMuQ29udHJhY3RJbnZvY2F0aW9uc0FwaUZhY3RvcnkgPSBleHBvcnRzLkNvbnRyYWN0SW52b2NhdGlvbnNBcGlGcCA9IGV4cG9ydHMuQ29udHJhY3RJbnZvY2F0aW9uc0FwaUF4aW9zUGFyYW1DcmVhdG9yID0gZXhwb3J0cy5Db250cmFjdEV2ZW50c0FwaSA9IGV4cG9ydHMuQ29udHJhY3RFdmVudHNBcGlGYWN0b3J5ID0gZXhwb3J0cy5Db250cmFjdEV2ZW50c0FwaUZwID0gZXhwb3J0cy5Db250cmFjdEV2ZW50c0FwaUF4aW9zUGFyYW1DcmVhdG9yID0gZXhwb3J0cy5CYWxhbmNlSGlzdG9yeUFwaSA9IGV4cG9ydHMuQmFsYW5jZUhpc3RvcnlBcGlGYWN0b3J5ID0gZXhwb3J0cy5CYWxhbmNlSGlzdG9yeUFwaUZwID0gZXhwb3J0cy5CYWxhbmNlSGlzdG9yeUFwaUF4aW9zUGFyYW1DcmVhdG9yID0gZXhwb3J0cy5Bc3NldHNBcGkgPSBleHBvcnRzLkFzc2V0c0FwaUZhY3RvcnkgPSBleHBvcnRzLkFzc2V0c0FwaUZwID0gZXhwb3J0cy5Bc3NldHNBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IGV4cG9ydHMuQWRkcmVzc2VzQXBpID0gZXhwb3J0cy5BZGRyZXNzZXNBcGlGYWN0b3J5ID0gZXhwb3J0cy5BZGRyZXNzZXNBcGlGcCA9IGV4cG9ydHMuQWRkcmVzc2VzQXBpQXhpb3NQYXJhbUNyZWF0b3IgPSBleHBvcnRzLldlYmhvb2tTdGF0dXMgPSBleHBvcnRzLldlYmhvb2tFdmVudFR5cGUgPSBleHBvcnRzLldhbGxldFNlcnZlclNpZ25lclN0YXR1c0VudW0gPSBleHBvcnRzLlZhbGlkYXRvclN0YXR1cyA9IGV4cG9ydHMuVXNlck9wZXJhdGlvblN0YXR1c0VudW0gPSBleHBvcnRzLlRyYW5zYWN0aW9uVHlwZSA9IGV4cG9ydHMuVHJhbnNhY3Rpb25TdGF0dXNFbnVtID0gZXhwb3J0cy5Ub2tlblRyYW5zZmVyVHlwZSA9IGV4cG9ydHMuU3Rha2luZ1Jld2FyZEZvcm1hdCA9IGV4cG9ydHMuU3Rha2luZ1Jld2FyZFN0YXRlRW51bSA9IGV4cG9ydHMuU3Rha2luZ09wZXJhdGlvblN0YXR1c0VudW0gPSBleHBvcnRzLlNwb25zb3JlZFNlbmRTdGF0dXNFbnVtID0gZXhwb3J0cy5Tb2xpZGl0eVZhbHVlVHlwZUVudW0gPSBleHBvcnRzLlNtYXJ0Q29udHJhY3RUeXBlID0gZXhwb3J0cy5QYXlsb2FkU2lnbmF0dXJlU3RhdHVzRW51bSA9IGV4cG9ydHMuTmV0d29ya0lkZW50aWZpZXIgPSBleHBvcnRzLk5ldHdvcmtQcm90b2NvbEZhbWlseUVudW0gPSBleHBvcnRzLkZ1bmRPcGVyYXRpb25TdGF0dXNFbnVtID0gdm9pZCAwO1xuZXhwb3J0cy5XZWJob29rc0FwaUF4aW9zUGFyYW1DcmVhdG9yID0gZXhwb3J0cy5XYWxsZXRzQXBpID0gZXhwb3J0cy5XYWxsZXRzQXBpRmFjdG9yeSA9IGV4cG9ydHMuV2FsbGV0c0FwaUZwID0gZXhwb3J0cy5XYWxsZXRzQXBpQXhpb3NQYXJhbUNyZWF0b3IgPSBleHBvcnRzLlVzZXJzQXBpID0gZXhwb3J0cy5Vc2Vyc0FwaUZhY3RvcnkgPSBleHBvcnRzLlVzZXJzQXBpRnAgPSBleHBvcnRzLlVzZXJzQXBpQXhpb3NQYXJhbUNyZWF0b3IgPSBleHBvcnRzLlRyYW5zZmVyc0FwaSA9IGV4cG9ydHMuVHJhbnNmZXJzQXBpRmFjdG9yeSA9IGV4cG9ydHMuVHJhbnNmZXJzQXBpRnAgPSBleHBvcnRzLlRyYW5zZmVyc0FwaUF4aW9zUGFyYW1DcmVhdG9yID0gZXhwb3J0cy5UcmFuc2FjdGlvbkhpc3RvcnlBcGkgPSBleHBvcnRzLlRyYW5zYWN0aW9uSGlzdG9yeUFwaUZhY3RvcnkgPSBleHBvcnRzLlRyYW5zYWN0aW9uSGlzdG9yeUFwaUZwID0gZXhwb3J0cy5UcmFuc2FjdGlvbkhpc3RvcnlBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IGV4cG9ydHMuVHJhZGVzQXBpID0gZXhwb3J0cy5UcmFkZXNBcGlGYWN0b3J5ID0gZXhwb3J0cy5UcmFkZXNBcGlGcCA9IGV4cG9ydHMuVHJhZGVzQXBpQXhpb3NQYXJhbUNyZWF0b3IgPSBleHBvcnRzLlN0YWtlQXBpID0gZXhwb3J0cy5TdGFrZUFwaUZhY3RvcnkgPSBleHBvcnRzLlN0YWtlQXBpRnAgPSBleHBvcnRzLlN0YWtlQXBpQXhpb3NQYXJhbUNyZWF0b3IgPSBleHBvcnRzLlNtYXJ0V2FsbGV0c0FwaSA9IGV4cG9ydHMuU21hcnRXYWxsZXRzQXBpRmFjdG9yeSA9IGV4cG9ydHMuU21hcnRXYWxsZXRzQXBpRnAgPSBleHBvcnRzLlNtYXJ0V2FsbGV0c0FwaUF4aW9zUGFyYW1DcmVhdG9yID0gZXhwb3J0cy5TbWFydENvbnRyYWN0c0FwaSA9IGV4cG9ydHMuU21hcnRDb250cmFjdHNBcGlGYWN0b3J5ID0gZXhwb3J0cy5TbWFydENvbnRyYWN0c0FwaUZwID0gZXhwb3J0cy5TbWFydENvbnRyYWN0c0FwaUF4aW9zUGFyYW1DcmVhdG9yID0gZXhwb3J0cy5TZXJ2ZXJTaWduZXJzQXBpID0gZXhwb3J0cy5TZXJ2ZXJTaWduZXJzQXBpRmFjdG9yeSA9IGV4cG9ydHMuU2VydmVyU2lnbmVyc0FwaUZwID0gZXhwb3J0cy5TZXJ2ZXJTaWduZXJzQXBpQXhpb3NQYXJhbUNyZWF0b3IgPSBleHBvcnRzLlJlcHV0YXRpb25BcGkgPSBleHBvcnRzLlJlcHV0YXRpb25BcGlGYWN0b3J5ID0gZXhwb3J0cy5SZXB1dGF0aW9uQXBpRnAgPSBleHBvcnRzLlJlcHV0YXRpb25BcGlBeGlvc1BhcmFtQ3JlYXRvciA9IGV4cG9ydHMuUmVzb2x2ZUlkZW50aXR5QnlBZGRyZXNzUm9sZXNFbnVtID0gZXhwb3J0cy5PbmNoYWluSWRlbnRpdHlBcGkgPSBleHBvcnRzLk9uY2hhaW5JZGVudGl0eUFwaUZhY3RvcnkgPSBleHBvcnRzLk9uY2hhaW5JZGVudGl0eUFwaUZwID0gZXhwb3J0cy5PbmNoYWluSWRlbnRpdHlBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IGV4cG9ydHMuTmV0d29ya3NBcGkgPSBleHBvcnRzLk5ldHdvcmtzQXBpRmFjdG9yeSA9IGV4cG9ydHMuTmV0d29ya3NBcGlGcCA9IGV4cG9ydHMuTmV0d29ya3NBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IHZvaWQgMDtcbmV4cG9ydHMuV2ViaG9va3NBcGkgPSBleHBvcnRzLldlYmhvb2tzQXBpRmFjdG9yeSA9IGV4cG9ydHMuV2ViaG9va3NBcGlGcCA9IHZvaWQgMDtcbmNvbnN0IGF4aW9zXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImF4aW9zXCIpKTtcbi8vIFNvbWUgaW1wb3J0cyBub3QgdXNlZCBkZXBlbmRpbmcgb24gdGVtcGxhdGUgY29uZGl0aW9uc1xuLy8gQHRzLWlnbm9yZVxuY29uc3QgY29tbW9uXzEgPSByZXF1aXJlKFwiLi9jb21tb25cIik7XG4vLyBAdHMtaWdub3JlXG5jb25zdCBiYXNlXzEgPSByZXF1aXJlKFwiLi9iYXNlXCIpO1xuZXhwb3J0cy5GdW5kT3BlcmF0aW9uU3RhdHVzRW51bSA9IHtcbiAgICBQZW5kaW5nOiAncGVuZGluZycsXG4gICAgQ29tcGxldGU6ICdjb21wbGV0ZScsXG4gICAgRmFpbGVkOiAnZmFpbGVkJ1xufTtcbmV4cG9ydHMuTmV0d29ya1Byb3RvY29sRmFtaWx5RW51bSA9IHtcbiAgICBFdm06ICdldm0nLFxuICAgIFNvbGFuYTogJ3NvbGFuYSdcbn07XG4vKipcbiAqIFRoZSBJRCBvZiB0aGUgYmxvY2tjaGFpbiBuZXR3b3JrLiBUaGlzIGlzIHVuaXF1ZSBhY3Jvc3MgYWxsIG5ldHdvcmtzLCBhbmQgdGFrZXMgdGhlIGZvcm0gb2YgYDxibG9ja2NoYWluPi08bmV0d29yaz5gLlxuICogQGV4cG9ydFxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuZXhwb3J0cy5OZXR3b3JrSWRlbnRpZmllciA9IHtcbiAgICBCYXNlU2Vwb2xpYTogJ2Jhc2Utc2Vwb2xpYScsXG4gICAgQmFzZU1haW5uZXQ6ICdiYXNlLW1haW5uZXQnLFxuICAgIEV0aGVyZXVtSG9sZXNreTogJ2V0aGVyZXVtLWhvbGVza3knLFxuICAgIEV0aGVyZXVtU2Vwb2xpYTogJ2V0aGVyZXVtLXNlcG9saWEnLFxuICAgIEV0aGVyZXVtTWFpbm5ldDogJ2V0aGVyZXVtLW1haW5uZXQnLFxuICAgIFBvbHlnb25NYWlubmV0OiAncG9seWdvbi1tYWlubmV0JyxcbiAgICBTb2xhbmFEZXZuZXQ6ICdzb2xhbmEtZGV2bmV0JyxcbiAgICBTb2xhbmFNYWlubmV0OiAnc29sYW5hLW1haW5uZXQnLFxuICAgIEFyYml0cnVtTWFpbm5ldDogJ2FyYml0cnVtLW1haW5uZXQnLFxuICAgIEFyYml0cnVtU2Vwb2xpYTogJ2FyYml0cnVtLXNlcG9saWEnLFxuICAgIEJpdGNvaW5NYWlubmV0OiAnYml0Y29pbi1tYWlubmV0JyxcbiAgICBOZWFyVGVzdG5ldDogJ25lYXItdGVzdG5ldCcsXG4gICAgTmVhck1haW5uZXQ6ICduZWFyLW1haW5uZXQnXG59O1xuZXhwb3J0cy5QYXlsb2FkU2lnbmF0dXJlU3RhdHVzRW51bSA9IHtcbiAgICBQZW5kaW5nOiAncGVuZGluZycsXG4gICAgU2lnbmVkOiAnc2lnbmVkJyxcbiAgICBGYWlsZWQ6ICdmYWlsZWQnXG59O1xuLyoqXG4gKiBUaGUgdHlwZSBvZiB0aGUgc21hcnQgY29udHJhY3QuXG4gKiBAZXhwb3J0XG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5leHBvcnRzLlNtYXJ0Q29udHJhY3RUeXBlID0ge1xuICAgIEVyYzIwOiAnZXJjMjAnLFxuICAgIEVyYzcyMTogJ2VyYzcyMScsXG4gICAgRXJjMTE1NTogJ2VyYzExNTUnLFxuICAgIEN1c3RvbTogJ2N1c3RvbSdcbn07XG5leHBvcnRzLlNvbGlkaXR5VmFsdWVUeXBlRW51bSA9IHtcbiAgICBVaW50ODogJ3VpbnQ4JyxcbiAgICBVaW50MTY6ICd1aW50MTYnLFxuICAgIFVpbnQzMjogJ3VpbnQzMicsXG4gICAgVWludDY0OiAndWludDY0JyxcbiAgICBVaW50MTI4OiAndWludDEyOCcsXG4gICAgVWludDE2MDogJ3VpbnQxNjAnLFxuICAgIFVpbnQyNTY6ICd1aW50MjU2JyxcbiAgICBJbnQ4OiAnaW50OCcsXG4gICAgSW50MTY6ICdpbnQxNicsXG4gICAgSW50MjQ6ICdpbnQyNCcsXG4gICAgSW50MzI6ICdpbnQzMicsXG4gICAgSW50NTY6ICdpbnQ1NicsXG4gICAgSW50NjQ6ICdpbnQ2NCcsXG4gICAgSW50MTI4OiAnaW50MTI4JyxcbiAgICBJbnQyNTY6ICdpbnQyNTYnLFxuICAgIEFkZHJlc3M6ICdhZGRyZXNzJyxcbiAgICBCb29sOiAnYm9vbCcsXG4gICAgU3RyaW5nOiAnc3RyaW5nJyxcbiAgICBCeXRlczogJ2J5dGVzJyxcbiAgICBCeXRlczE6ICdieXRlczEnLFxuICAgIEJ5dGVzMjogJ2J5dGVzMicsXG4gICAgQnl0ZXMzOiAnYnl0ZXMzJyxcbiAgICBCeXRlczQ6ICdieXRlczQnLFxuICAgIEJ5dGVzNTogJ2J5dGVzNScsXG4gICAgQnl0ZXM2OiAnYnl0ZXM2JyxcbiAgICBCeXRlczc6ICdieXRlczcnLFxuICAgIEJ5dGVzODogJ2J5dGVzOCcsXG4gICAgQnl0ZXM5OiAnYnl0ZXM5JyxcbiAgICBCeXRlczEwOiAnYnl0ZXMxMCcsXG4gICAgQnl0ZXMxMTogJ2J5dGVzMTEnLFxuICAgIEJ5dGVzMTI6ICdieXRlczEyJyxcbiAgICBCeXRlczEzOiAnYnl0ZXMxMycsXG4gICAgQnl0ZXMxNDogJ2J5dGVzMTQnLFxuICAgIEJ5dGVzMTU6ICdieXRlczE1JyxcbiAgICBCeXRlczE2OiAnYnl0ZXMxNicsXG4gICAgQnl0ZXMxNzogJ2J5dGVzMTcnLFxuICAgIEJ5dGVzMTg6ICdieXRlczE4JyxcbiAgICBCeXRlczE5OiAnYnl0ZXMxOScsXG4gICAgQnl0ZXMyMDogJ2J5dGVzMjAnLFxuICAgIEJ5dGVzMjE6ICdieXRlczIxJyxcbiAgICBCeXRlczIyOiAnYnl0ZXMyMicsXG4gICAgQnl0ZXMyMzogJ2J5dGVzMjMnLFxuICAgIEJ5dGVzMjQ6ICdieXRlczI0JyxcbiAgICBCeXRlczI1OiAnYnl0ZXMyNScsXG4gICAgQnl0ZXMyNjogJ2J5dGVzMjYnLFxuICAgIEJ5dGVzMjc6ICdieXRlczI3JyxcbiAgICBCeXRlczI4OiAnYnl0ZXMyOCcsXG4gICAgQnl0ZXMyOTogJ2J5dGVzMjknLFxuICAgIEJ5dGVzMzA6ICdieXRlczMwJyxcbiAgICBCeXRlczMxOiAnYnl0ZXMzMScsXG4gICAgQnl0ZXMzMjogJ2J5dGVzMzInLFxuICAgIEFycmF5OiAnYXJyYXknLFxuICAgIFR1cGxlOiAndHVwbGUnXG59O1xuZXhwb3J0cy5TcG9uc29yZWRTZW5kU3RhdHVzRW51bSA9IHtcbiAgICBQZW5kaW5nOiAncGVuZGluZycsXG4gICAgU2lnbmVkOiAnc2lnbmVkJyxcbiAgICBTdWJtaXR0ZWQ6ICdzdWJtaXR0ZWQnLFxuICAgIENvbXBsZXRlOiAnY29tcGxldGUnLFxuICAgIEZhaWxlZDogJ2ZhaWxlZCdcbn07XG5leHBvcnRzLlN0YWtpbmdPcGVyYXRpb25TdGF0dXNFbnVtID0ge1xuICAgIEluaXRpYWxpemVkOiAnaW5pdGlhbGl6ZWQnLFxuICAgIENvbXBsZXRlOiAnY29tcGxldGUnLFxuICAgIEZhaWxlZDogJ2ZhaWxlZCcsXG4gICAgVW5zcGVjaWZpZWQ6ICd1bnNwZWNpZmllZCdcbn07XG5leHBvcnRzLlN0YWtpbmdSZXdhcmRTdGF0ZUVudW0gPSB7XG4gICAgUGVuZGluZzogJ3BlbmRpbmcnLFxuICAgIERpc3RyaWJ1dGVkOiAnZGlzdHJpYnV0ZWQnXG59O1xuLyoqXG4gKiBUaGUgZm9ybWF0IGluIHdoaWNoIHRoZSByZXdhcmRzIGFyZSB0byBiZSBmZXRjaGVkIGkuZSBuYXRpdmUgb3IgaW4gZXF1aXZhbGVudCBVU0RcbiAqIEBleHBvcnRcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbmV4cG9ydHMuU3Rha2luZ1Jld2FyZEZvcm1hdCA9IHtcbiAgICBVc2Q6ICd1c2QnLFxuICAgIE5hdGl2ZTogJ25hdGl2ZSdcbn07XG4vKipcbiAqIFRoZSB0eXBlIG9mIHRoZSB0b2tlbiB0cmFuc2Zlci5cbiAqIEBleHBvcnRcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbmV4cG9ydHMuVG9rZW5UcmFuc2ZlclR5cGUgPSB7XG4gICAgRXJjMjA6ICdlcmMyMCcsXG4gICAgRXJjNzIxOiAnZXJjNzIxJyxcbiAgICBFcmMxMTU1OiAnZXJjMTE1NScsXG4gICAgVW5rbm93bjogJ3Vua25vd24nXG59O1xuZXhwb3J0cy5UcmFuc2FjdGlvblN0YXR1c0VudW0gPSB7XG4gICAgUGVuZGluZzogJ3BlbmRpbmcnLFxuICAgIFNpZ25lZDogJ3NpZ25lZCcsXG4gICAgQnJvYWRjYXN0OiAnYnJvYWRjYXN0JyxcbiAgICBDb21wbGV0ZTogJ2NvbXBsZXRlJyxcbiAgICBGYWlsZWQ6ICdmYWlsZWQnLFxuICAgIFVuc3BlY2lmaWVkOiAndW5zcGVjaWZpZWQnXG59O1xuLyoqXG4gKlxuICogQGV4cG9ydFxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuZXhwb3J0cy5UcmFuc2FjdGlvblR5cGUgPSB7XG4gICAgVHJhbnNmZXI6ICd0cmFuc2Zlcidcbn07XG5leHBvcnRzLlVzZXJPcGVyYXRpb25TdGF0dXNFbnVtID0ge1xuICAgIFBlbmRpbmc6ICdwZW5kaW5nJyxcbiAgICBTaWduZWQ6ICdzaWduZWQnLFxuICAgIEJyb2FkY2FzdDogJ2Jyb2FkY2FzdCcsXG4gICAgQ29tcGxldGU6ICdjb21wbGV0ZScsXG4gICAgRmFpbGVkOiAnZmFpbGVkJ1xufTtcbi8qKlxuICogVGhlIHN0YXR1cyBvZiB0aGUgdmFsaWRhdG9yLlxuICogQGV4cG9ydFxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuZXhwb3J0cy5WYWxpZGF0b3JTdGF0dXMgPSB7XG4gICAgVW5rbm93bjogJ3Vua25vd24nLFxuICAgIFByb3Zpc2lvbmluZzogJ3Byb3Zpc2lvbmluZycsXG4gICAgUHJvdmlzaW9uZWQ6ICdwcm92aXNpb25lZCcsXG4gICAgRGVwb3NpdGVkOiAnZGVwb3NpdGVkJyxcbiAgICBQZW5kaW5nQWN0aXZhdGlvbjogJ3BlbmRpbmdfYWN0aXZhdGlvbicsXG4gICAgQWN0aXZlOiAnYWN0aXZlJyxcbiAgICBFeGl0aW5nOiAnZXhpdGluZycsXG4gICAgRXhpdGVkOiAnZXhpdGVkJyxcbiAgICBXaXRoZHJhd2FsQXZhaWxhYmxlOiAnd2l0aGRyYXdhbF9hdmFpbGFibGUnLFxuICAgIFdpdGhkcmF3YWxDb21wbGV0ZTogJ3dpdGhkcmF3YWxfY29tcGxldGUnLFxuICAgIEFjdGl2ZVNsYXNoZWQ6ICdhY3RpdmVfc2xhc2hlZCcsXG4gICAgRXhpdGVkU2xhc2hlZDogJ2V4aXRlZF9zbGFzaGVkJyxcbiAgICBSZWFwZWQ6ICdyZWFwZWQnXG59O1xuZXhwb3J0cy5XYWxsZXRTZXJ2ZXJTaWduZXJTdGF0dXNFbnVtID0ge1xuICAgIFBlbmRpbmdTZWVkQ3JlYXRpb246ICdwZW5kaW5nX3NlZWRfY3JlYXRpb24nLFxuICAgIEFjdGl2ZVNlZWQ6ICdhY3RpdmVfc2VlZCdcbn07XG4vKipcbiAqXG4gKiBAZXhwb3J0XG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5leHBvcnRzLldlYmhvb2tFdmVudFR5cGUgPSB7XG4gICAgVW5zcGVjaWZpZWQ6ICd1bnNwZWNpZmllZCcsXG4gICAgRXJjMjBUcmFuc2ZlcjogJ2VyYzIwX3RyYW5zZmVyJyxcbiAgICBFcmM3MjFUcmFuc2ZlcjogJ2VyYzcyMV90cmFuc2ZlcicsXG4gICAgV2FsbGV0QWN0aXZpdHk6ICd3YWxsZXRfYWN0aXZpdHknLFxuICAgIFNtYXJ0Q29udHJhY3RFdmVudEFjdGl2aXR5OiAnc21hcnRfY29udHJhY3RfZXZlbnRfYWN0aXZpdHknXG59O1xuLyoqXG4gKiBUaGUgc3RhdHVzIG9mIHRoZSB3ZWJob29rLlxuICogQGV4cG9ydFxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuZXhwb3J0cy5XZWJob29rU3RhdHVzID0ge1xuICAgIEFjdGl2ZTogJ2FjdGl2ZScsXG4gICAgSW5hY3RpdmU6ICdpbmFjdGl2ZSdcbn07XG4vKipcbiAqIEFkZHJlc3Nlc0FwaSAtIGF4aW9zIHBhcmFtZXRlciBjcmVhdG9yXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IEFkZHJlc3Nlc0FwaUF4aW9zUGFyYW1DcmVhdG9yID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgbmV3IGFkZHJlc3Mgc2NvcGVkIHRvIHRoZSB3YWxsZXQuXG4gICAgICAgICAqIEBzdW1tYXJ5IENyZWF0ZSBhIG5ldyBhZGRyZXNzXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0byBjcmVhdGUgdGhlIGFkZHJlc3MgaW4uXG4gICAgICAgICAqIEBwYXJhbSB7Q3JlYXRlQWRkcmVzc1JlcXVlc3R9IFtjcmVhdGVBZGRyZXNzUmVxdWVzdF1cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZUFkZHJlc3M6IGFzeW5jICh3YWxsZXRJZCwgY3JlYXRlQWRkcmVzc1JlcXVlc3QsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnd2FsbGV0SWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnY3JlYXRlQWRkcmVzcycsICd3YWxsZXRJZCcsIHdhbGxldElkKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvd2FsbGV0cy97d2FsbGV0X2lkfS9hZGRyZXNzZXNgXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wid2FsbGV0X2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcod2FsbGV0SWQpKSk7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IHsgbWV0aG9kOiAnUE9TVCcsIC4uLmJhc2VPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gYXBpS2V5IHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIkp3dFwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IHsgLi4ubG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIC4uLmhlYWRlcnNGcm9tQmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMuaGVhZGVycyB9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5kYXRhID0gKDAsIGNvbW1vbl8xLnNlcmlhbGl6ZURhdGFJZk5lZWRlZCkoY3JlYXRlQWRkcmVzc1JlcXVlc3QsIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIG5ldyBwYXlsb2FkIHNpZ25hdHVyZSB3aXRoIGFuIGFkZHJlc3MuXG4gICAgICAgICAqIEBzdW1tYXJ5IENyZWF0ZSBhIG5ldyBwYXlsb2FkIHNpZ25hdHVyZS5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIG9uY2hhaW4gYWRkcmVzcyBvZiB0aGUgYWRkcmVzcyB0byBzaWduIHRoZSBwYXlsb2FkIHdpdGguXG4gICAgICAgICAqIEBwYXJhbSB7Q3JlYXRlUGF5bG9hZFNpZ25hdHVyZVJlcXVlc3R9IFtjcmVhdGVQYXlsb2FkU2lnbmF0dXJlUmVxdWVzdF1cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZVBheWxvYWRTaWduYXR1cmU6IGFzeW5jICh3YWxsZXRJZCwgYWRkcmVzc0lkLCBjcmVhdGVQYXlsb2FkU2lnbmF0dXJlUmVxdWVzdCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICd3YWxsZXRJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdjcmVhdGVQYXlsb2FkU2lnbmF0dXJlJywgJ3dhbGxldElkJywgd2FsbGV0SWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnYWRkcmVzc0lkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2NyZWF0ZVBheWxvYWRTaWduYXR1cmUnLCAnYWRkcmVzc0lkJywgYWRkcmVzc0lkKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvd2FsbGV0cy97d2FsbGV0X2lkfS9hZGRyZXNzZXMve2FkZHJlc3NfaWR9L3BheWxvYWRfc2lnbmF0dXJlc2BcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJ3YWxsZXRfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyh3YWxsZXRJZCkpKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcImFkZHJlc3NfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhhZGRyZXNzSWQpKSk7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IHsgbWV0aG9kOiAnUE9TVCcsIC4uLmJhc2VPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gYXBpS2V5IHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIkp3dFwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IHsgLi4ubG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIC4uLmhlYWRlcnNGcm9tQmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMuaGVhZGVycyB9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5kYXRhID0gKDAsIGNvbW1vbl8xLnNlcmlhbGl6ZURhdGFJZk5lZWRlZCkoY3JlYXRlUGF5bG9hZFNpZ25hdHVyZVJlcXVlc3QsIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBhZGRyZXNzXG4gICAgICAgICAqIEBzdW1tYXJ5IEdldCBhZGRyZXNzIGJ5IG9uY2hhaW4gYWRkcmVzc1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0by5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgb25jaGFpbiBhZGRyZXNzIG9mIHRoZSBhZGRyZXNzIHRoYXQgaXMgYmVpbmcgZmV0Y2hlZC5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGdldEFkZHJlc3M6IGFzeW5jICh3YWxsZXRJZCwgYWRkcmVzc0lkLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ3dhbGxldElkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2dldEFkZHJlc3MnLCAnd2FsbGV0SWQnLCB3YWxsZXRJZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdhZGRyZXNzSWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZ2V0QWRkcmVzcycsICdhZGRyZXNzSWQnLCBhZGRyZXNzSWQpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS93YWxsZXRzL3t3YWxsZXRfaWR9L2FkZHJlc3Nlcy97YWRkcmVzc19pZH1gXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wid2FsbGV0X2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcod2FsbGV0SWQpKSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJhZGRyZXNzX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoYWRkcmVzc0lkKSkpO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7IG1ldGhvZDogJ0dFVCcsIC4uLmJhc2VPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gYXBpS2V5IHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIkp3dFwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIHNlc3Npb24gcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0geyAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlciwgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucywgLi4ub3B0aW9ucy5oZWFkZXJzIH07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGFkZHJlc3MgYmFsYW5jZVxuICAgICAgICAgKiBAc3VtbWFyeSBHZXQgYWRkcmVzcyBiYWxhbmNlIGZvciBhc3NldFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdG8gZmV0Y2ggdGhlIGJhbGFuY2UgZm9yXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIG9uY2hhaW4gYWRkcmVzcyBvZiB0aGUgYWRkcmVzcyB0aGF0IGlzIGJlaW5nIGZldGNoZWQuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhc3NldElkIFRoZSBzeW1ib2wgb2YgdGhlIGFzc2V0IHRvIGZldGNoIHRoZSBiYWxhbmNlIGZvclxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0QWRkcmVzc0JhbGFuY2U6IGFzeW5jICh3YWxsZXRJZCwgYWRkcmVzc0lkLCBhc3NldElkLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ3dhbGxldElkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2dldEFkZHJlc3NCYWxhbmNlJywgJ3dhbGxldElkJywgd2FsbGV0SWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnYWRkcmVzc0lkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2dldEFkZHJlc3NCYWxhbmNlJywgJ2FkZHJlc3NJZCcsIGFkZHJlc3NJZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdhc3NldElkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2dldEFkZHJlc3NCYWxhbmNlJywgJ2Fzc2V0SWQnLCBhc3NldElkKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvd2FsbGV0cy97d2FsbGV0X2lkfS9hZGRyZXNzZXMve2FkZHJlc3NfaWR9L2JhbGFuY2VzL3thc3NldF9pZH1gXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wid2FsbGV0X2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcod2FsbGV0SWQpKSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJhZGRyZXNzX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoYWRkcmVzc0lkKSkpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wiYXNzZXRfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhhc3NldElkKSkpO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7IG1ldGhvZDogJ0dFVCcsIC4uLmJhc2VPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gYXBpS2V5IHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIkp3dFwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIHNlc3Npb24gcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0geyAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlciwgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucywgLi4ub3B0aW9ucy5oZWFkZXJzIH07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHBheWxvYWQgc2lnbmF0dXJlLlxuICAgICAgICAgKiBAc3VtbWFyeSBHZXQgcGF5bG9hZCBzaWduYXR1cmUuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBvbmNoYWluIGFkZHJlc3Mgb2YgdGhlIGFkZHJlc3MgdGhhdCBzaWduZWQgdGhlIHBheWxvYWQuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXlsb2FkU2lnbmF0dXJlSWQgVGhlIElEIG9mIHRoZSBwYXlsb2FkIHNpZ25hdHVyZSB0byBmZXRjaC5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGdldFBheWxvYWRTaWduYXR1cmU6IGFzeW5jICh3YWxsZXRJZCwgYWRkcmVzc0lkLCBwYXlsb2FkU2lnbmF0dXJlSWQsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnd2FsbGV0SWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZ2V0UGF5bG9hZFNpZ25hdHVyZScsICd3YWxsZXRJZCcsIHdhbGxldElkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2FkZHJlc3NJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdnZXRQYXlsb2FkU2lnbmF0dXJlJywgJ2FkZHJlc3NJZCcsIGFkZHJlc3NJZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdwYXlsb2FkU2lnbmF0dXJlSWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZ2V0UGF5bG9hZFNpZ25hdHVyZScsICdwYXlsb2FkU2lnbmF0dXJlSWQnLCBwYXlsb2FkU2lnbmF0dXJlSWQpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS93YWxsZXRzL3t3YWxsZXRfaWR9L2FkZHJlc3Nlcy97YWRkcmVzc19pZH0vcGF5bG9hZF9zaWduYXR1cmVzL3twYXlsb2FkX3NpZ25hdHVyZV9pZH1gXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wid2FsbGV0X2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcod2FsbGV0SWQpKSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJhZGRyZXNzX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoYWRkcmVzc0lkKSkpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wicGF5bG9hZF9zaWduYXR1cmVfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhwYXlsb2FkU2lnbmF0dXJlSWQpKSk7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IHsgbWV0aG9kOiAnR0VUJywgLi4uYmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBhcGlLZXkgcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gc2Vzc2lvbiByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJKd3RcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSB7IC4uLmxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCAuLi5oZWFkZXJzRnJvbUJhc2VPcHRpb25zLCAuLi5vcHRpb25zLmhlYWRlcnMgfTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgYWRkcmVzcyBiYWxhbmNlc1xuICAgICAgICAgKiBAc3VtbWFyeSBHZXQgYWxsIGJhbGFuY2VzIGZvciBhZGRyZXNzXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0byBmZXRjaCB0aGUgYmFsYW5jZXMgZm9yXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIG9uY2hhaW4gYWRkcmVzcyBvZiB0aGUgYWRkcmVzcyB0aGF0IGlzIGJlaW5nIGZldGNoZWQuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZV0gQSBjdXJzb3IgZm9yIHBhZ2luYXRpb24gYWNyb3NzIG11bHRpcGxlIHBhZ2VzIG9mIHJlc3VsdHMuIERvblxcJiMzOTt0IGluY2x1ZGUgdGhpcyBwYXJhbWV0ZXIgb24gdGhlIGZpcnN0IGNhbGwuIFVzZSB0aGUgbmV4dF9wYWdlIHZhbHVlIHJldHVybmVkIGluIGEgcHJldmlvdXMgcmVzcG9uc2UgdG8gcmVxdWVzdCBzdWJzZXF1ZW50IHJlc3VsdHMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBsaXN0QWRkcmVzc0JhbGFuY2VzOiBhc3luYyAod2FsbGV0SWQsIGFkZHJlc3NJZCwgcGFnZSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICd3YWxsZXRJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdsaXN0QWRkcmVzc0JhbGFuY2VzJywgJ3dhbGxldElkJywgd2FsbGV0SWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnYWRkcmVzc0lkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2xpc3RBZGRyZXNzQmFsYW5jZXMnLCAnYWRkcmVzc0lkJywgYWRkcmVzc0lkKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvd2FsbGV0cy97d2FsbGV0X2lkfS9hZGRyZXNzZXMve2FkZHJlc3NfaWR9L2JhbGFuY2VzYFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcIndhbGxldF9pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHdhbGxldElkKSkpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wiYWRkcmVzc19pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKGFkZHJlc3NJZCkpKTtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0geyBtZXRob2Q6ICdHRVQnLCAuLi5iYXNlT3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIGFwaUtleSByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJKd3RcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBzZXNzaW9uIHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIkp3dFwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIGlmIChwYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydwYWdlJ10gPSBwYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0geyAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlciwgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucywgLi4ub3B0aW9ucy5oZWFkZXJzIH07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdCBhZGRyZXNzZXMgaW4gdGhlIHdhbGxldC5cbiAgICAgICAgICogQHN1bW1hcnkgTGlzdCBhZGRyZXNzZXMgaW4gYSB3YWxsZXQuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB3aG9zZSBhZGRyZXNzZXMgdG8gZmV0Y2hcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gQSBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIG9iamVjdHMgdG8gYmUgcmV0dXJuZWQuIExpbWl0IGNhbiByYW5nZSBiZXR3ZWVuIDEgYW5kIDEwMCwgYW5kIHRoZSBkZWZhdWx0IGlzIDEwLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VdIEEgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiByZXN1bHRzLiBEb25cXCYjMzk7dCBpbmNsdWRlIHRoaXMgcGFyYW1ldGVyIG9uIHRoZSBmaXJzdCBjYWxsLiBVc2UgdGhlIG5leHRfcGFnZSB2YWx1ZSByZXR1cm5lZCBpbiBhIHByZXZpb3VzIHJlc3BvbnNlIHRvIHJlcXVlc3Qgc3Vic2VxdWVudCByZXN1bHRzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgbGlzdEFkZHJlc3NlczogYXN5bmMgKHdhbGxldElkLCBsaW1pdCwgcGFnZSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICd3YWxsZXRJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdsaXN0QWRkcmVzc2VzJywgJ3dhbGxldElkJywgd2FsbGV0SWQpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS93YWxsZXRzL3t3YWxsZXRfaWR9L2FkZHJlc3Nlc2BcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJ3YWxsZXRfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyh3YWxsZXRJZCkpKTtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0geyBtZXRob2Q6ICdHRVQnLCAuLi5iYXNlT3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIGFwaUtleSByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJKd3RcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBzZXNzaW9uIHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIkp3dFwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIGlmIChsaW1pdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnbGltaXQnXSA9IGxpbWl0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ3BhZ2UnXSA9IHBhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSB7IC4uLmxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCAuLi5oZWFkZXJzRnJvbUJhc2VPcHRpb25zLCAuLi5vcHRpb25zLmhlYWRlcnMgfTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0IHBheWxvYWQgc2lnbmF0dXJlcyBmb3IgYW4gYWRkcmVzcy5cbiAgICAgICAgICogQHN1bW1hcnkgTGlzdCBwYXlsb2FkIHNpZ25hdHVyZXMgZm9yIGFuIGFkZHJlc3MuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBvbmNoYWluIGFkZHJlc3Mgb2YgdGhlIGFkZHJlc3Mgd2hvc2UgcGF5bG9hZCBzaWduYXR1cmVzIHRvIGZldGNoLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBBIGxpbWl0IG9uIHRoZSBudW1iZXIgb2Ygb2JqZWN0cyB0byBiZSByZXR1cm5lZC4gTGltaXQgY2FuIHJhbmdlIGJldHdlZW4gMSBhbmQgMTAwLCBhbmQgdGhlIGRlZmF1bHQgaXMgMTAuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZV0gQSBjdXJzb3IgZm9yIHBhZ2luYXRpb24gYWNyb3NzIG11bHRpcGxlIHBhZ2VzIG9mIHJlc3VsdHMuIERvblxcJiMzOTt0IGluY2x1ZGUgdGhpcyBwYXJhbWV0ZXIgb24gdGhlIGZpcnN0IGNhbGwuIFVzZSB0aGUgbmV4dF9wYWdlIHZhbHVlIHJldHVybmVkIGluIGEgcHJldmlvdXMgcmVzcG9uc2UgdG8gcmVxdWVzdCBzdWJzZXF1ZW50IHJlc3VsdHMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBsaXN0UGF5bG9hZFNpZ25hdHVyZXM6IGFzeW5jICh3YWxsZXRJZCwgYWRkcmVzc0lkLCBsaW1pdCwgcGFnZSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICd3YWxsZXRJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdsaXN0UGF5bG9hZFNpZ25hdHVyZXMnLCAnd2FsbGV0SWQnLCB3YWxsZXRJZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdhZGRyZXNzSWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnbGlzdFBheWxvYWRTaWduYXR1cmVzJywgJ2FkZHJlc3NJZCcsIGFkZHJlc3NJZCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL3dhbGxldHMve3dhbGxldF9pZH0vYWRkcmVzc2VzL3thZGRyZXNzX2lkfS9wYXlsb2FkX3NpZ25hdHVyZXNgXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wid2FsbGV0X2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcod2FsbGV0SWQpKSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJhZGRyZXNzX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoYWRkcmVzc0lkKSkpO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7IG1ldGhvZDogJ0dFVCcsIC4uLmJhc2VPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gYXBpS2V5IHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIkp3dFwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIHNlc3Npb24gcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgaWYgKGxpbWl0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydsaW1pdCddID0gbGltaXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsncGFnZSddID0gcGFnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IHsgLi4ubG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIC4uLmhlYWRlcnNGcm9tQmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMuaGVhZGVycyB9O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlcXVlc3QgZmF1Y2V0IGZ1bmRzIHRvIGJlIHNlbnQgdG8gb25jaGFpbiBhZGRyZXNzLlxuICAgICAgICAgKiBAc3VtbWFyeSBSZXF1ZXN0IGZhdWNldCBmdW5kcyBmb3Igb25jaGFpbiBhZGRyZXNzLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0by5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgb25jaGFpbiBhZGRyZXNzIG9mIHRoZSBhZGRyZXNzIHRoYXQgaXMgYmVpbmcgZmV0Y2hlZC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFthc3NldElkXSBUaGUgSUQgb2YgdGhlIGFzc2V0IHRvIHRyYW5zZmVyIGZyb20gdGhlIGZhdWNldC5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQGRlcHJlY2F0ZWRcbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIHJlcXVlc3RGYXVjZXRGdW5kczogYXN5bmMgKHdhbGxldElkLCBhZGRyZXNzSWQsIGFzc2V0SWQsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnd2FsbGV0SWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgncmVxdWVzdEZhdWNldEZ1bmRzJywgJ3dhbGxldElkJywgd2FsbGV0SWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnYWRkcmVzc0lkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ3JlcXVlc3RGYXVjZXRGdW5kcycsICdhZGRyZXNzSWQnLCBhZGRyZXNzSWQpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS93YWxsZXRzL3t3YWxsZXRfaWR9L2FkZHJlc3Nlcy97YWRkcmVzc19pZH0vZmF1Y2V0YFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcIndhbGxldF9pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHdhbGxldElkKSkpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wiYWRkcmVzc19pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKGFkZHJlc3NJZCkpKTtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0geyBtZXRob2Q6ICdQT1NUJywgLi4uYmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBhcGlLZXkgcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgaWYgKGFzc2V0SWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ2Fzc2V0X2lkJ10gPSBhc3NldElkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0geyAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlciwgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucywgLi4ub3B0aW9ucy5oZWFkZXJzIH07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5BZGRyZXNzZXNBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IEFkZHJlc3Nlc0FwaUF4aW9zUGFyYW1DcmVhdG9yO1xuLyoqXG4gKiBBZGRyZXNzZXNBcGkgLSBmdW5jdGlvbmFsIHByb2dyYW1taW5nIGludGVyZmFjZVxuICogQGV4cG9ydFxuICovXG5jb25zdCBBZGRyZXNzZXNBcGlGcCA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uKSB7XG4gICAgY29uc3QgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvciA9ICgwLCBleHBvcnRzLkFkZHJlc3Nlc0FwaUF4aW9zUGFyYW1DcmVhdG9yKShjb25maWd1cmF0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgbmV3IGFkZHJlc3Mgc2NvcGVkIHRvIHRoZSB3YWxsZXQuXG4gICAgICAgICAqIEBzdW1tYXJ5IENyZWF0ZSBhIG5ldyBhZGRyZXNzXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0byBjcmVhdGUgdGhlIGFkZHJlc3MgaW4uXG4gICAgICAgICAqIEBwYXJhbSB7Q3JlYXRlQWRkcmVzc1JlcXVlc3R9IFtjcmVhdGVBZGRyZXNzUmVxdWVzdF1cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGNyZWF0ZUFkZHJlc3Mod2FsbGV0SWQsIGNyZWF0ZUFkZHJlc3NSZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuY3JlYXRlQWRkcmVzcyh3YWxsZXRJZCwgY3JlYXRlQWRkcmVzc1JlcXVlc3QsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IGNvbmZpZ3VyYXRpb24/LnNlcnZlckluZGV4ID8/IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnQWRkcmVzc2VzQXBpLmNyZWF0ZUFkZHJlc3MnXT8uW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdPy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgbmV3IHBheWxvYWQgc2lnbmF0dXJlIHdpdGggYW4gYWRkcmVzcy5cbiAgICAgICAgICogQHN1bW1hcnkgQ3JlYXRlIGEgbmV3IHBheWxvYWQgc2lnbmF0dXJlLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0by5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgb25jaGFpbiBhZGRyZXNzIG9mIHRoZSBhZGRyZXNzIHRvIHNpZ24gdGhlIHBheWxvYWQgd2l0aC5cbiAgICAgICAgICogQHBhcmFtIHtDcmVhdGVQYXlsb2FkU2lnbmF0dXJlUmVxdWVzdH0gW2NyZWF0ZVBheWxvYWRTaWduYXR1cmVSZXF1ZXN0XVxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgY3JlYXRlUGF5bG9hZFNpZ25hdHVyZSh3YWxsZXRJZCwgYWRkcmVzc0lkLCBjcmVhdGVQYXlsb2FkU2lnbmF0dXJlUmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmNyZWF0ZVBheWxvYWRTaWduYXR1cmUod2FsbGV0SWQsIGFkZHJlc3NJZCwgY3JlYXRlUGF5bG9hZFNpZ25hdHVyZVJlcXVlc3QsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IGNvbmZpZ3VyYXRpb24/LnNlcnZlckluZGV4ID8/IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnQWRkcmVzc2VzQXBpLmNyZWF0ZVBheWxvYWRTaWduYXR1cmUnXT8uW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdPy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGFkZHJlc3NcbiAgICAgICAgICogQHN1bW1hcnkgR2V0IGFkZHJlc3MgYnkgb25jaGFpbiBhZGRyZXNzXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBvbmNoYWluIGFkZHJlc3Mgb2YgdGhlIGFkZHJlc3MgdGhhdCBpcyBiZWluZyBmZXRjaGVkLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgZ2V0QWRkcmVzcyh3YWxsZXRJZCwgYWRkcmVzc0lkLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuZ2V0QWRkcmVzcyh3YWxsZXRJZCwgYWRkcmVzc0lkLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSBjb25maWd1cmF0aW9uPy5zZXJ2ZXJJbmRleCA/PyAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ0FkZHJlc3Nlc0FwaS5nZXRBZGRyZXNzJ10/Lltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XT8udXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBhZGRyZXNzIGJhbGFuY2VcbiAgICAgICAgICogQHN1bW1hcnkgR2V0IGFkZHJlc3MgYmFsYW5jZSBmb3IgYXNzZXRcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRvIGZldGNoIHRoZSBiYWxhbmNlIGZvclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBvbmNoYWluIGFkZHJlc3Mgb2YgdGhlIGFkZHJlc3MgdGhhdCBpcyBiZWluZyBmZXRjaGVkLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXNzZXRJZCBUaGUgc3ltYm9sIG9mIHRoZSBhc3NldCB0byBmZXRjaCB0aGUgYmFsYW5jZSBmb3JcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGdldEFkZHJlc3NCYWxhbmNlKHdhbGxldElkLCBhZGRyZXNzSWQsIGFzc2V0SWQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5nZXRBZGRyZXNzQmFsYW5jZSh3YWxsZXRJZCwgYWRkcmVzc0lkLCBhc3NldElkLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSBjb25maWd1cmF0aW9uPy5zZXJ2ZXJJbmRleCA/PyAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ0FkZHJlc3Nlc0FwaS5nZXRBZGRyZXNzQmFsYW5jZSddPy5bbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0/LnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgcGF5bG9hZCBzaWduYXR1cmUuXG4gICAgICAgICAqIEBzdW1tYXJ5IEdldCBwYXlsb2FkIHNpZ25hdHVyZS5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIG9uY2hhaW4gYWRkcmVzcyBvZiB0aGUgYWRkcmVzcyB0aGF0IHNpZ25lZCB0aGUgcGF5bG9hZC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHBheWxvYWRTaWduYXR1cmVJZCBUaGUgSUQgb2YgdGhlIHBheWxvYWQgc2lnbmF0dXJlIHRvIGZldGNoLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgZ2V0UGF5bG9hZFNpZ25hdHVyZSh3YWxsZXRJZCwgYWRkcmVzc0lkLCBwYXlsb2FkU2lnbmF0dXJlSWQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5nZXRQYXlsb2FkU2lnbmF0dXJlKHdhbGxldElkLCBhZGRyZXNzSWQsIHBheWxvYWRTaWduYXR1cmVJZCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gY29uZmlndXJhdGlvbj8uc2VydmVySW5kZXggPz8gMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydBZGRyZXNzZXNBcGkuZ2V0UGF5bG9hZFNpZ25hdHVyZSddPy5bbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0/LnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgYWRkcmVzcyBiYWxhbmNlc1xuICAgICAgICAgKiBAc3VtbWFyeSBHZXQgYWxsIGJhbGFuY2VzIGZvciBhZGRyZXNzXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0byBmZXRjaCB0aGUgYmFsYW5jZXMgZm9yXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIG9uY2hhaW4gYWRkcmVzcyBvZiB0aGUgYWRkcmVzcyB0aGF0IGlzIGJlaW5nIGZldGNoZWQuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZV0gQSBjdXJzb3IgZm9yIHBhZ2luYXRpb24gYWNyb3NzIG11bHRpcGxlIHBhZ2VzIG9mIHJlc3VsdHMuIERvblxcJiMzOTt0IGluY2x1ZGUgdGhpcyBwYXJhbWV0ZXIgb24gdGhlIGZpcnN0IGNhbGwuIFVzZSB0aGUgbmV4dF9wYWdlIHZhbHVlIHJldHVybmVkIGluIGEgcHJldmlvdXMgcmVzcG9uc2UgdG8gcmVxdWVzdCBzdWJzZXF1ZW50IHJlc3VsdHMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBsaXN0QWRkcmVzc0JhbGFuY2VzKHdhbGxldElkLCBhZGRyZXNzSWQsIHBhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5saXN0QWRkcmVzc0JhbGFuY2VzKHdhbGxldElkLCBhZGRyZXNzSWQsIHBhZ2UsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IGNvbmZpZ3VyYXRpb24/LnNlcnZlckluZGV4ID8/IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnQWRkcmVzc2VzQXBpLmxpc3RBZGRyZXNzQmFsYW5jZXMnXT8uW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdPy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdCBhZGRyZXNzZXMgaW4gdGhlIHdhbGxldC5cbiAgICAgICAgICogQHN1bW1hcnkgTGlzdCBhZGRyZXNzZXMgaW4gYSB3YWxsZXQuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB3aG9zZSBhZGRyZXNzZXMgdG8gZmV0Y2hcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gQSBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIG9iamVjdHMgdG8gYmUgcmV0dXJuZWQuIExpbWl0IGNhbiByYW5nZSBiZXR3ZWVuIDEgYW5kIDEwMCwgYW5kIHRoZSBkZWZhdWx0IGlzIDEwLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VdIEEgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiByZXN1bHRzLiBEb25cXCYjMzk7dCBpbmNsdWRlIHRoaXMgcGFyYW1ldGVyIG9uIHRoZSBmaXJzdCBjYWxsLiBVc2UgdGhlIG5leHRfcGFnZSB2YWx1ZSByZXR1cm5lZCBpbiBhIHByZXZpb3VzIHJlc3BvbnNlIHRvIHJlcXVlc3Qgc3Vic2VxdWVudCByZXN1bHRzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgbGlzdEFkZHJlc3Nlcyh3YWxsZXRJZCwgbGltaXQsIHBhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5saXN0QWRkcmVzc2VzKHdhbGxldElkLCBsaW1pdCwgcGFnZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gY29uZmlndXJhdGlvbj8uc2VydmVySW5kZXggPz8gMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydBZGRyZXNzZXNBcGkubGlzdEFkZHJlc3NlcyddPy5bbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0/LnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0IHBheWxvYWQgc2lnbmF0dXJlcyBmb3IgYW4gYWRkcmVzcy5cbiAgICAgICAgICogQHN1bW1hcnkgTGlzdCBwYXlsb2FkIHNpZ25hdHVyZXMgZm9yIGFuIGFkZHJlc3MuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBvbmNoYWluIGFkZHJlc3Mgb2YgdGhlIGFkZHJlc3Mgd2hvc2UgcGF5bG9hZCBzaWduYXR1cmVzIHRvIGZldGNoLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBBIGxpbWl0IG9uIHRoZSBudW1iZXIgb2Ygb2JqZWN0cyB0byBiZSByZXR1cm5lZC4gTGltaXQgY2FuIHJhbmdlIGJldHdlZW4gMSBhbmQgMTAwLCBhbmQgdGhlIGRlZmF1bHQgaXMgMTAuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZV0gQSBjdXJzb3IgZm9yIHBhZ2luYXRpb24gYWNyb3NzIG11bHRpcGxlIHBhZ2VzIG9mIHJlc3VsdHMuIERvblxcJiMzOTt0IGluY2x1ZGUgdGhpcyBwYXJhbWV0ZXIgb24gdGhlIGZpcnN0IGNhbGwuIFVzZSB0aGUgbmV4dF9wYWdlIHZhbHVlIHJldHVybmVkIGluIGEgcHJldmlvdXMgcmVzcG9uc2UgdG8gcmVxdWVzdCBzdWJzZXF1ZW50IHJlc3VsdHMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBsaXN0UGF5bG9hZFNpZ25hdHVyZXMod2FsbGV0SWQsIGFkZHJlc3NJZCwgbGltaXQsIHBhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5saXN0UGF5bG9hZFNpZ25hdHVyZXMod2FsbGV0SWQsIGFkZHJlc3NJZCwgbGltaXQsIHBhZ2UsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IGNvbmZpZ3VyYXRpb24/LnNlcnZlckluZGV4ID8/IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnQWRkcmVzc2VzQXBpLmxpc3RQYXlsb2FkU2lnbmF0dXJlcyddPy5bbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0/LnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXF1ZXN0IGZhdWNldCBmdW5kcyB0byBiZSBzZW50IHRvIG9uY2hhaW4gYWRkcmVzcy5cbiAgICAgICAgICogQHN1bW1hcnkgUmVxdWVzdCBmYXVjZXQgZnVuZHMgZm9yIG9uY2hhaW4gYWRkcmVzcy5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIG9uY2hhaW4gYWRkcmVzcyBvZiB0aGUgYWRkcmVzcyB0aGF0IGlzIGJlaW5nIGZldGNoZWQuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbYXNzZXRJZF0gVGhlIElEIG9mIHRoZSBhc3NldCB0byB0cmFuc2ZlciBmcm9tIHRoZSBmYXVjZXQuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEBkZXByZWNhdGVkXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyByZXF1ZXN0RmF1Y2V0RnVuZHMod2FsbGV0SWQsIGFkZHJlc3NJZCwgYXNzZXRJZCwgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLnJlcXVlc3RGYXVjZXRGdW5kcyh3YWxsZXRJZCwgYWRkcmVzc0lkLCBhc3NldElkLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSBjb25maWd1cmF0aW9uPy5zZXJ2ZXJJbmRleCA/PyAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ0FkZHJlc3Nlc0FwaS5yZXF1ZXN0RmF1Y2V0RnVuZHMnXT8uW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdPy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5BZGRyZXNzZXNBcGlGcCA9IEFkZHJlc3Nlc0FwaUZwO1xuLyoqXG4gKiBBZGRyZXNzZXNBcGkgLSBmYWN0b3J5IGludGVyZmFjZVxuICogQGV4cG9ydFxuICovXG5jb25zdCBBZGRyZXNzZXNBcGlGYWN0b3J5ID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24sIGJhc2VQYXRoLCBheGlvcykge1xuICAgIGNvbnN0IGxvY2FsVmFyRnAgPSAoMCwgZXhwb3J0cy5BZGRyZXNzZXNBcGlGcCkoY29uZmlndXJhdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIG5ldyBhZGRyZXNzIHNjb3BlZCB0byB0aGUgd2FsbGV0LlxuICAgICAgICAgKiBAc3VtbWFyeSBDcmVhdGUgYSBuZXcgYWRkcmVzc1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdG8gY3JlYXRlIHRoZSBhZGRyZXNzIGluLlxuICAgICAgICAgKiBAcGFyYW0ge0NyZWF0ZUFkZHJlc3NSZXF1ZXN0fSBbY3JlYXRlQWRkcmVzc1JlcXVlc3RdXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGVBZGRyZXNzKHdhbGxldElkLCBjcmVhdGVBZGRyZXNzUmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuY3JlYXRlQWRkcmVzcyh3YWxsZXRJZCwgY3JlYXRlQWRkcmVzc1JlcXVlc3QsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSBuZXcgcGF5bG9hZCBzaWduYXR1cmUgd2l0aCBhbiBhZGRyZXNzLlxuICAgICAgICAgKiBAc3VtbWFyeSBDcmVhdGUgYSBuZXcgcGF5bG9hZCBzaWduYXR1cmUuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBvbmNoYWluIGFkZHJlc3Mgb2YgdGhlIGFkZHJlc3MgdG8gc2lnbiB0aGUgcGF5bG9hZCB3aXRoLlxuICAgICAgICAgKiBAcGFyYW0ge0NyZWF0ZVBheWxvYWRTaWduYXR1cmVSZXF1ZXN0fSBbY3JlYXRlUGF5bG9hZFNpZ25hdHVyZVJlcXVlc3RdXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGVQYXlsb2FkU2lnbmF0dXJlKHdhbGxldElkLCBhZGRyZXNzSWQsIGNyZWF0ZVBheWxvYWRTaWduYXR1cmVSZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5jcmVhdGVQYXlsb2FkU2lnbmF0dXJlKHdhbGxldElkLCBhZGRyZXNzSWQsIGNyZWF0ZVBheWxvYWRTaWduYXR1cmVSZXF1ZXN0LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGFkZHJlc3NcbiAgICAgICAgICogQHN1bW1hcnkgR2V0IGFkZHJlc3MgYnkgb25jaGFpbiBhZGRyZXNzXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBvbmNoYWluIGFkZHJlc3Mgb2YgdGhlIGFkZHJlc3MgdGhhdCBpcyBiZWluZyBmZXRjaGVkLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0QWRkcmVzcyh3YWxsZXRJZCwgYWRkcmVzc0lkLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5nZXRBZGRyZXNzKHdhbGxldElkLCBhZGRyZXNzSWQsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgYWRkcmVzcyBiYWxhbmNlXG4gICAgICAgICAqIEBzdW1tYXJ5IEdldCBhZGRyZXNzIGJhbGFuY2UgZm9yIGFzc2V0XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0byBmZXRjaCB0aGUgYmFsYW5jZSBmb3JcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgb25jaGFpbiBhZGRyZXNzIG9mIHRoZSBhZGRyZXNzIHRoYXQgaXMgYmVpbmcgZmV0Y2hlZC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFzc2V0SWQgVGhlIHN5bWJvbCBvZiB0aGUgYXNzZXQgdG8gZmV0Y2ggdGhlIGJhbGFuY2UgZm9yXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRBZGRyZXNzQmFsYW5jZSh3YWxsZXRJZCwgYWRkcmVzc0lkLCBhc3NldElkLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5nZXRBZGRyZXNzQmFsYW5jZSh3YWxsZXRJZCwgYWRkcmVzc0lkLCBhc3NldElkLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHBheWxvYWQgc2lnbmF0dXJlLlxuICAgICAgICAgKiBAc3VtbWFyeSBHZXQgcGF5bG9hZCBzaWduYXR1cmUuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBvbmNoYWluIGFkZHJlc3Mgb2YgdGhlIGFkZHJlc3MgdGhhdCBzaWduZWQgdGhlIHBheWxvYWQuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXlsb2FkU2lnbmF0dXJlSWQgVGhlIElEIG9mIHRoZSBwYXlsb2FkIHNpZ25hdHVyZSB0byBmZXRjaC5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGdldFBheWxvYWRTaWduYXR1cmUod2FsbGV0SWQsIGFkZHJlc3NJZCwgcGF5bG9hZFNpZ25hdHVyZUlkLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5nZXRQYXlsb2FkU2lnbmF0dXJlKHdhbGxldElkLCBhZGRyZXNzSWQsIHBheWxvYWRTaWduYXR1cmVJZCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBhZGRyZXNzIGJhbGFuY2VzXG4gICAgICAgICAqIEBzdW1tYXJ5IEdldCBhbGwgYmFsYW5jZXMgZm9yIGFkZHJlc3NcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRvIGZldGNoIHRoZSBiYWxhbmNlcyBmb3JcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgb25jaGFpbiBhZGRyZXNzIG9mIHRoZSBhZGRyZXNzIHRoYXQgaXMgYmVpbmcgZmV0Y2hlZC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlXSBBIGN1cnNvciBmb3IgcGFnaW5hdGlvbiBhY3Jvc3MgbXVsdGlwbGUgcGFnZXMgb2YgcmVzdWx0cy4gRG9uXFwmIzM5O3QgaW5jbHVkZSB0aGlzIHBhcmFtZXRlciBvbiB0aGUgZmlyc3QgY2FsbC4gVXNlIHRoZSBuZXh0X3BhZ2UgdmFsdWUgcmV0dXJuZWQgaW4gYSBwcmV2aW91cyByZXNwb25zZSB0byByZXF1ZXN0IHN1YnNlcXVlbnQgcmVzdWx0cy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGxpc3RBZGRyZXNzQmFsYW5jZXMod2FsbGV0SWQsIGFkZHJlc3NJZCwgcGFnZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAubGlzdEFkZHJlc3NCYWxhbmNlcyh3YWxsZXRJZCwgYWRkcmVzc0lkLCBwYWdlLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdCBhZGRyZXNzZXMgaW4gdGhlIHdhbGxldC5cbiAgICAgICAgICogQHN1bW1hcnkgTGlzdCBhZGRyZXNzZXMgaW4gYSB3YWxsZXQuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB3aG9zZSBhZGRyZXNzZXMgdG8gZmV0Y2hcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gQSBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIG9iamVjdHMgdG8gYmUgcmV0dXJuZWQuIExpbWl0IGNhbiByYW5nZSBiZXR3ZWVuIDEgYW5kIDEwMCwgYW5kIHRoZSBkZWZhdWx0IGlzIDEwLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VdIEEgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiByZXN1bHRzLiBEb25cXCYjMzk7dCBpbmNsdWRlIHRoaXMgcGFyYW1ldGVyIG9uIHRoZSBmaXJzdCBjYWxsLiBVc2UgdGhlIG5leHRfcGFnZSB2YWx1ZSByZXR1cm5lZCBpbiBhIHByZXZpb3VzIHJlc3BvbnNlIHRvIHJlcXVlc3Qgc3Vic2VxdWVudCByZXN1bHRzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgbGlzdEFkZHJlc3Nlcyh3YWxsZXRJZCwgbGltaXQsIHBhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmxpc3RBZGRyZXNzZXMod2FsbGV0SWQsIGxpbWl0LCBwYWdlLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdCBwYXlsb2FkIHNpZ25hdHVyZXMgZm9yIGFuIGFkZHJlc3MuXG4gICAgICAgICAqIEBzdW1tYXJ5IExpc3QgcGF5bG9hZCBzaWduYXR1cmVzIGZvciBhbiBhZGRyZXNzLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0by5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgb25jaGFpbiBhZGRyZXNzIG9mIHRoZSBhZGRyZXNzIHdob3NlIHBheWxvYWQgc2lnbmF0dXJlcyB0byBmZXRjaC5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gQSBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIG9iamVjdHMgdG8gYmUgcmV0dXJuZWQuIExpbWl0IGNhbiByYW5nZSBiZXR3ZWVuIDEgYW5kIDEwMCwgYW5kIHRoZSBkZWZhdWx0IGlzIDEwLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VdIEEgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiByZXN1bHRzLiBEb25cXCYjMzk7dCBpbmNsdWRlIHRoaXMgcGFyYW1ldGVyIG9uIHRoZSBmaXJzdCBjYWxsLiBVc2UgdGhlIG5leHRfcGFnZSB2YWx1ZSByZXR1cm5lZCBpbiBhIHByZXZpb3VzIHJlc3BvbnNlIHRvIHJlcXVlc3Qgc3Vic2VxdWVudCByZXN1bHRzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgbGlzdFBheWxvYWRTaWduYXR1cmVzKHdhbGxldElkLCBhZGRyZXNzSWQsIGxpbWl0LCBwYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5saXN0UGF5bG9hZFNpZ25hdHVyZXMod2FsbGV0SWQsIGFkZHJlc3NJZCwgbGltaXQsIHBhZ2UsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXF1ZXN0IGZhdWNldCBmdW5kcyB0byBiZSBzZW50IHRvIG9uY2hhaW4gYWRkcmVzcy5cbiAgICAgICAgICogQHN1bW1hcnkgUmVxdWVzdCBmYXVjZXQgZnVuZHMgZm9yIG9uY2hhaW4gYWRkcmVzcy5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIG9uY2hhaW4gYWRkcmVzcyBvZiB0aGUgYWRkcmVzcyB0aGF0IGlzIGJlaW5nIGZldGNoZWQuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbYXNzZXRJZF0gVGhlIElEIG9mIHRoZSBhc3NldCB0byB0cmFuc2ZlciBmcm9tIHRoZSBmYXVjZXQuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEBkZXByZWNhdGVkXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICByZXF1ZXN0RmF1Y2V0RnVuZHMod2FsbGV0SWQsIGFkZHJlc3NJZCwgYXNzZXRJZCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAucmVxdWVzdEZhdWNldEZ1bmRzKHdhbGxldElkLCBhZGRyZXNzSWQsIGFzc2V0SWQsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5leHBvcnRzLkFkZHJlc3Nlc0FwaUZhY3RvcnkgPSBBZGRyZXNzZXNBcGlGYWN0b3J5O1xuLyoqXG4gKiBBZGRyZXNzZXNBcGkgLSBvYmplY3Qtb3JpZW50ZWQgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKiBAY2xhc3MgQWRkcmVzc2VzQXBpXG4gKiBAZXh0ZW5kcyB7QmFzZUFQSX1cbiAqL1xuY2xhc3MgQWRkcmVzc2VzQXBpIGV4dGVuZHMgYmFzZV8xLkJhc2VBUEkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBhZGRyZXNzIHNjb3BlZCB0byB0aGUgd2FsbGV0LlxuICAgICAqIEBzdW1tYXJ5IENyZWF0ZSBhIG5ldyBhZGRyZXNzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRvIGNyZWF0ZSB0aGUgYWRkcmVzcyBpbi5cbiAgICAgKiBAcGFyYW0ge0NyZWF0ZUFkZHJlc3NSZXF1ZXN0fSBbY3JlYXRlQWRkcmVzc1JlcXVlc3RdXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBBZGRyZXNzZXNBcGlcbiAgICAgKi9cbiAgICBjcmVhdGVBZGRyZXNzKHdhbGxldElkLCBjcmVhdGVBZGRyZXNzUmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuQWRkcmVzc2VzQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuY3JlYXRlQWRkcmVzcyh3YWxsZXRJZCwgY3JlYXRlQWRkcmVzc1JlcXVlc3QsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgcGF5bG9hZCBzaWduYXR1cmUgd2l0aCBhbiBhZGRyZXNzLlxuICAgICAqIEBzdW1tYXJ5IENyZWF0ZSBhIG5ldyBwYXlsb2FkIHNpZ25hdHVyZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0by5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBvbmNoYWluIGFkZHJlc3Mgb2YgdGhlIGFkZHJlc3MgdG8gc2lnbiB0aGUgcGF5bG9hZCB3aXRoLlxuICAgICAqIEBwYXJhbSB7Q3JlYXRlUGF5bG9hZFNpZ25hdHVyZVJlcXVlc3R9IFtjcmVhdGVQYXlsb2FkU2lnbmF0dXJlUmVxdWVzdF1cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIEFkZHJlc3Nlc0FwaVxuICAgICAqL1xuICAgIGNyZWF0ZVBheWxvYWRTaWduYXR1cmUod2FsbGV0SWQsIGFkZHJlc3NJZCwgY3JlYXRlUGF5bG9hZFNpZ25hdHVyZVJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLkFkZHJlc3Nlc0FwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLmNyZWF0ZVBheWxvYWRTaWduYXR1cmUod2FsbGV0SWQsIGFkZHJlc3NJZCwgY3JlYXRlUGF5bG9hZFNpZ25hdHVyZVJlcXVlc3QsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYWRkcmVzc1xuICAgICAqIEBzdW1tYXJ5IEdldCBhZGRyZXNzIGJ5IG9uY2hhaW4gYWRkcmVzc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIG9uY2hhaW4gYWRkcmVzcyBvZiB0aGUgYWRkcmVzcyB0aGF0IGlzIGJlaW5nIGZldGNoZWQuXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBBZGRyZXNzZXNBcGlcbiAgICAgKi9cbiAgICBnZXRBZGRyZXNzKHdhbGxldElkLCBhZGRyZXNzSWQsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLkFkZHJlc3Nlc0FwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLmdldEFkZHJlc3Mod2FsbGV0SWQsIGFkZHJlc3NJZCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhZGRyZXNzIGJhbGFuY2VcbiAgICAgKiBAc3VtbWFyeSBHZXQgYWRkcmVzcyBiYWxhbmNlIGZvciBhc3NldFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0byBmZXRjaCB0aGUgYmFsYW5jZSBmb3JcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBvbmNoYWluIGFkZHJlc3Mgb2YgdGhlIGFkZHJlc3MgdGhhdCBpcyBiZWluZyBmZXRjaGVkLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhc3NldElkIFRoZSBzeW1ib2wgb2YgdGhlIGFzc2V0IHRvIGZldGNoIHRoZSBiYWxhbmNlIGZvclxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgQWRkcmVzc2VzQXBpXG4gICAgICovXG4gICAgZ2V0QWRkcmVzc0JhbGFuY2Uod2FsbGV0SWQsIGFkZHJlc3NJZCwgYXNzZXRJZCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuQWRkcmVzc2VzQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuZ2V0QWRkcmVzc0JhbGFuY2Uod2FsbGV0SWQsIGFkZHJlc3NJZCwgYXNzZXRJZCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBwYXlsb2FkIHNpZ25hdHVyZS5cbiAgICAgKiBAc3VtbWFyeSBHZXQgcGF5bG9hZCBzaWduYXR1cmUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG8uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgb25jaGFpbiBhZGRyZXNzIG9mIHRoZSBhZGRyZXNzIHRoYXQgc2lnbmVkIHRoZSBwYXlsb2FkLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXlsb2FkU2lnbmF0dXJlSWQgVGhlIElEIG9mIHRoZSBwYXlsb2FkIHNpZ25hdHVyZSB0byBmZXRjaC5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIEFkZHJlc3Nlc0FwaVxuICAgICAqL1xuICAgIGdldFBheWxvYWRTaWduYXR1cmUod2FsbGV0SWQsIGFkZHJlc3NJZCwgcGF5bG9hZFNpZ25hdHVyZUlkLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5BZGRyZXNzZXNBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5nZXRQYXlsb2FkU2lnbmF0dXJlKHdhbGxldElkLCBhZGRyZXNzSWQsIHBheWxvYWRTaWduYXR1cmVJZCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhZGRyZXNzIGJhbGFuY2VzXG4gICAgICogQHN1bW1hcnkgR2V0IGFsbCBiYWxhbmNlcyBmb3IgYWRkcmVzc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0byBmZXRjaCB0aGUgYmFsYW5jZXMgZm9yXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgb25jaGFpbiBhZGRyZXNzIG9mIHRoZSBhZGRyZXNzIHRoYXQgaXMgYmVpbmcgZmV0Y2hlZC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VdIEEgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiByZXN1bHRzLiBEb25cXCYjMzk7dCBpbmNsdWRlIHRoaXMgcGFyYW1ldGVyIG9uIHRoZSBmaXJzdCBjYWxsLiBVc2UgdGhlIG5leHRfcGFnZSB2YWx1ZSByZXR1cm5lZCBpbiBhIHByZXZpb3VzIHJlc3BvbnNlIHRvIHJlcXVlc3Qgc3Vic2VxdWVudCByZXN1bHRzLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgQWRkcmVzc2VzQXBpXG4gICAgICovXG4gICAgbGlzdEFkZHJlc3NCYWxhbmNlcyh3YWxsZXRJZCwgYWRkcmVzc0lkLCBwYWdlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5BZGRyZXNzZXNBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5saXN0QWRkcmVzc0JhbGFuY2VzKHdhbGxldElkLCBhZGRyZXNzSWQsIHBhZ2UsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0IGFkZHJlc3NlcyBpbiB0aGUgd2FsbGV0LlxuICAgICAqIEBzdW1tYXJ5IExpc3QgYWRkcmVzc2VzIGluIGEgd2FsbGV0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB3aG9zZSBhZGRyZXNzZXMgdG8gZmV0Y2hcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBBIGxpbWl0IG9uIHRoZSBudW1iZXIgb2Ygb2JqZWN0cyB0byBiZSByZXR1cm5lZC4gTGltaXQgY2FuIHJhbmdlIGJldHdlZW4gMSBhbmQgMTAwLCBhbmQgdGhlIGRlZmF1bHQgaXMgMTAuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlXSBBIGN1cnNvciBmb3IgcGFnaW5hdGlvbiBhY3Jvc3MgbXVsdGlwbGUgcGFnZXMgb2YgcmVzdWx0cy4gRG9uXFwmIzM5O3QgaW5jbHVkZSB0aGlzIHBhcmFtZXRlciBvbiB0aGUgZmlyc3QgY2FsbC4gVXNlIHRoZSBuZXh0X3BhZ2UgdmFsdWUgcmV0dXJuZWQgaW4gYSBwcmV2aW91cyByZXNwb25zZSB0byByZXF1ZXN0IHN1YnNlcXVlbnQgcmVzdWx0cy5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIEFkZHJlc3Nlc0FwaVxuICAgICAqL1xuICAgIGxpc3RBZGRyZXNzZXMod2FsbGV0SWQsIGxpbWl0LCBwYWdlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5BZGRyZXNzZXNBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5saXN0QWRkcmVzc2VzKHdhbGxldElkLCBsaW1pdCwgcGFnZSwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3QgcGF5bG9hZCBzaWduYXR1cmVzIGZvciBhbiBhZGRyZXNzLlxuICAgICAqIEBzdW1tYXJ5IExpc3QgcGF5bG9hZCBzaWduYXR1cmVzIGZvciBhbiBhZGRyZXNzLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIG9uY2hhaW4gYWRkcmVzcyBvZiB0aGUgYWRkcmVzcyB3aG9zZSBwYXlsb2FkIHNpZ25hdHVyZXMgdG8gZmV0Y2guXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gQSBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIG9iamVjdHMgdG8gYmUgcmV0dXJuZWQuIExpbWl0IGNhbiByYW5nZSBiZXR3ZWVuIDEgYW5kIDEwMCwgYW5kIHRoZSBkZWZhdWx0IGlzIDEwLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZV0gQSBjdXJzb3IgZm9yIHBhZ2luYXRpb24gYWNyb3NzIG11bHRpcGxlIHBhZ2VzIG9mIHJlc3VsdHMuIERvblxcJiMzOTt0IGluY2x1ZGUgdGhpcyBwYXJhbWV0ZXIgb24gdGhlIGZpcnN0IGNhbGwuIFVzZSB0aGUgbmV4dF9wYWdlIHZhbHVlIHJldHVybmVkIGluIGEgcHJldmlvdXMgcmVzcG9uc2UgdG8gcmVxdWVzdCBzdWJzZXF1ZW50IHJlc3VsdHMuXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBBZGRyZXNzZXNBcGlcbiAgICAgKi9cbiAgICBsaXN0UGF5bG9hZFNpZ25hdHVyZXMod2FsbGV0SWQsIGFkZHJlc3NJZCwgbGltaXQsIHBhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLkFkZHJlc3Nlc0FwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLmxpc3RQYXlsb2FkU2lnbmF0dXJlcyh3YWxsZXRJZCwgYWRkcmVzc0lkLCBsaW1pdCwgcGFnZSwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlcXVlc3QgZmF1Y2V0IGZ1bmRzIHRvIGJlIHNlbnQgdG8gb25jaGFpbiBhZGRyZXNzLlxuICAgICAqIEBzdW1tYXJ5IFJlcXVlc3QgZmF1Y2V0IGZ1bmRzIGZvciBvbmNoYWluIGFkZHJlc3MuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG8uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgb25jaGFpbiBhZGRyZXNzIG9mIHRoZSBhZGRyZXNzIHRoYXQgaXMgYmVpbmcgZmV0Y2hlZC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2Fzc2V0SWRdIFRoZSBJRCBvZiB0aGUgYXNzZXQgdG8gdHJhbnNmZXIgZnJvbSB0aGUgZmF1Y2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBBZGRyZXNzZXNBcGlcbiAgICAgKi9cbiAgICByZXF1ZXN0RmF1Y2V0RnVuZHMod2FsbGV0SWQsIGFkZHJlc3NJZCwgYXNzZXRJZCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuQWRkcmVzc2VzQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikucmVxdWVzdEZhdWNldEZ1bmRzKHdhbGxldElkLCBhZGRyZXNzSWQsIGFzc2V0SWQsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuQWRkcmVzc2VzQXBpID0gQWRkcmVzc2VzQXBpO1xuLyoqXG4gKiBBc3NldHNBcGkgLSBheGlvcyBwYXJhbWV0ZXIgY3JlYXRvclxuICogQGV4cG9ydFxuICovXG5jb25zdCBBc3NldHNBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgYXNzZXQgZm9yIHRoZSBzcGVjaWZpZWQgYXNzZXQgSUQuXG4gICAgICAgICAqIEBzdW1tYXJ5IEdldCB0aGUgYXNzZXQgZm9yIHRoZSBzcGVjaWZpZWQgYXNzZXQgSUQuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWQgVGhlIElEIG9mIHRoZSBibG9ja2NoYWluIG5ldHdvcmtcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFzc2V0SWQgVGhlIElEIG9mIHRoZSBhc3NldCB0byBmZXRjaC4gVGhpcyBjb3VsZCBiZSBhIHN5bWJvbCBvciBhbiBFUkMyMCBjb250cmFjdCBhZGRyZXNzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0QXNzZXQ6IGFzeW5jIChuZXR3b3JrSWQsIGFzc2V0SWQsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnbmV0d29ya0lkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2dldEFzc2V0JywgJ25ldHdvcmtJZCcsIG5ldHdvcmtJZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdhc3NldElkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2dldEFzc2V0JywgJ2Fzc2V0SWQnLCBhc3NldElkKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvbmV0d29ya3Mve25ldHdvcmtfaWR9L2Fzc2V0cy97YXNzZXRfaWR9YFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcIm5ldHdvcmtfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhuZXR3b3JrSWQpKSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJhc3NldF9pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKGFzc2V0SWQpKSk7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IHsgbWV0aG9kOiAnR0VUJywgLi4uYmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBhcGlLZXkgcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gc2Vzc2lvbiByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJKd3RcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSB7IC4uLmxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCAuLi5oZWFkZXJzRnJvbUJhc2VPcHRpb25zLCAuLi5vcHRpb25zLmhlYWRlcnMgfTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5leHBvcnRzLkFzc2V0c0FwaUF4aW9zUGFyYW1DcmVhdG9yID0gQXNzZXRzQXBpQXhpb3NQYXJhbUNyZWF0b3I7XG4vKipcbiAqIEFzc2V0c0FwaSAtIGZ1bmN0aW9uYWwgcHJvZ3JhbW1pbmcgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IEFzc2V0c0FwaUZwID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24pIHtcbiAgICBjb25zdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yID0gKDAsIGV4cG9ydHMuQXNzZXRzQXBpQXhpb3NQYXJhbUNyZWF0b3IpKGNvbmZpZ3VyYXRpb24pO1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGFzc2V0IGZvciB0aGUgc3BlY2lmaWVkIGFzc2V0IElELlxuICAgICAgICAgKiBAc3VtbWFyeSBHZXQgdGhlIGFzc2V0IGZvciB0aGUgc3BlY2lmaWVkIGFzc2V0IElELlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29ya0lkIFRoZSBJRCBvZiB0aGUgYmxvY2tjaGFpbiBuZXR3b3JrXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhc3NldElkIFRoZSBJRCBvZiB0aGUgYXNzZXQgdG8gZmV0Y2guIFRoaXMgY291bGQgYmUgYSBzeW1ib2wgb3IgYW4gRVJDMjAgY29udHJhY3QgYWRkcmVzcy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGdldEFzc2V0KG5ldHdvcmtJZCwgYXNzZXRJZCwgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmdldEFzc2V0KG5ldHdvcmtJZCwgYXNzZXRJZCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gY29uZmlndXJhdGlvbj8uc2VydmVySW5kZXggPz8gMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydBc3NldHNBcGkuZ2V0QXNzZXQnXT8uW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdPy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5Bc3NldHNBcGlGcCA9IEFzc2V0c0FwaUZwO1xuLyoqXG4gKiBBc3NldHNBcGkgLSBmYWN0b3J5IGludGVyZmFjZVxuICogQGV4cG9ydFxuICovXG5jb25zdCBBc3NldHNBcGlGYWN0b3J5ID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24sIGJhc2VQYXRoLCBheGlvcykge1xuICAgIGNvbnN0IGxvY2FsVmFyRnAgPSAoMCwgZXhwb3J0cy5Bc3NldHNBcGlGcCkoY29uZmlndXJhdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgYXNzZXQgZm9yIHRoZSBzcGVjaWZpZWQgYXNzZXQgSUQuXG4gICAgICAgICAqIEBzdW1tYXJ5IEdldCB0aGUgYXNzZXQgZm9yIHRoZSBzcGVjaWZpZWQgYXNzZXQgSUQuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWQgVGhlIElEIG9mIHRoZSBibG9ja2NoYWluIG5ldHdvcmtcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFzc2V0SWQgVGhlIElEIG9mIHRoZSBhc3NldCB0byBmZXRjaC4gVGhpcyBjb3VsZCBiZSBhIHN5bWJvbCBvciBhbiBFUkMyMCBjb250cmFjdCBhZGRyZXNzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0QXNzZXQobmV0d29ya0lkLCBhc3NldElkLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5nZXRBc3NldChuZXR3b3JrSWQsIGFzc2V0SWQsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5leHBvcnRzLkFzc2V0c0FwaUZhY3RvcnkgPSBBc3NldHNBcGlGYWN0b3J5O1xuLyoqXG4gKiBBc3NldHNBcGkgLSBvYmplY3Qtb3JpZW50ZWQgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKiBAY2xhc3MgQXNzZXRzQXBpXG4gKiBAZXh0ZW5kcyB7QmFzZUFQSX1cbiAqL1xuY2xhc3MgQXNzZXRzQXBpIGV4dGVuZHMgYmFzZV8xLkJhc2VBUEkge1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgYXNzZXQgZm9yIHRoZSBzcGVjaWZpZWQgYXNzZXQgSUQuXG4gICAgICogQHN1bW1hcnkgR2V0IHRoZSBhc3NldCBmb3IgdGhlIHNwZWNpZmllZCBhc3NldCBJRC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29ya0lkIFRoZSBJRCBvZiB0aGUgYmxvY2tjaGFpbiBuZXR3b3JrXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFzc2V0SWQgVGhlIElEIG9mIHRoZSBhc3NldCB0byBmZXRjaC4gVGhpcyBjb3VsZCBiZSBhIHN5bWJvbCBvciBhbiBFUkMyMCBjb250cmFjdCBhZGRyZXNzLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgQXNzZXRzQXBpXG4gICAgICovXG4gICAgZ2V0QXNzZXQobmV0d29ya0lkLCBhc3NldElkLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5Bc3NldHNBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5nZXRBc3NldChuZXR3b3JrSWQsIGFzc2V0SWQsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuQXNzZXRzQXBpID0gQXNzZXRzQXBpO1xuLyoqXG4gKiBCYWxhbmNlSGlzdG9yeUFwaSAtIGF4aW9zIHBhcmFtZXRlciBjcmVhdG9yXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IEJhbGFuY2VIaXN0b3J5QXBpQXhpb3NQYXJhbUNyZWF0b3IgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbikge1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0IHRoZSBoaXN0b3JpY2FsIGJhbGFuY2Ugb2YgYW4gYXNzZXQgaW4gYSBzcGVjaWZpYyBhZGRyZXNzLlxuICAgICAgICAgKiBAc3VtbWFyeSBHZXQgYWRkcmVzcyBiYWxhbmNlIGhpc3RvcnkgZm9yIGFzc2V0XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWQgVGhlIElEIG9mIHRoZSBibG9ja2NoYWluIG5ldHdvcmtcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdG8gZmV0Y2ggdGhlIGhpc3RvcmljYWwgYmFsYW5jZSBmb3IuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhc3NldElkIFRoZSBzeW1ib2wgb2YgdGhlIGFzc2V0IHRvIGZldGNoIHRoZSBoaXN0b3JpY2FsIGJhbGFuY2UgZm9yLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBBIGxpbWl0IG9uIHRoZSBudW1iZXIgb2Ygb2JqZWN0cyB0byBiZSByZXR1cm5lZC4gTGltaXQgY2FuIHJhbmdlIGJldHdlZW4gMSBhbmQgMTAwLCBhbmQgdGhlIGRlZmF1bHQgaXMgMTAuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZV0gQSBjdXJzb3IgZm9yIHBhZ2luYXRpb24gYWNyb3NzIG11bHRpcGxlIHBhZ2VzIG9mIHJlc3VsdHMuIERvblxcJiMzOTt0IGluY2x1ZGUgdGhpcyBwYXJhbWV0ZXIgb24gdGhlIGZpcnN0IGNhbGwuIFVzZSB0aGUgbmV4dF9wYWdlIHZhbHVlIHJldHVybmVkIGluIGEgcHJldmlvdXMgcmVzcG9uc2UgdG8gcmVxdWVzdCBzdWJzZXF1ZW50IHJlc3VsdHMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBsaXN0QWRkcmVzc0hpc3RvcmljYWxCYWxhbmNlOiBhc3luYyAobmV0d29ya0lkLCBhZGRyZXNzSWQsIGFzc2V0SWQsIGxpbWl0LCBwYWdlLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ25ldHdvcmtJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdsaXN0QWRkcmVzc0hpc3RvcmljYWxCYWxhbmNlJywgJ25ldHdvcmtJZCcsIG5ldHdvcmtJZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdhZGRyZXNzSWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnbGlzdEFkZHJlc3NIaXN0b3JpY2FsQmFsYW5jZScsICdhZGRyZXNzSWQnLCBhZGRyZXNzSWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnYXNzZXRJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdsaXN0QWRkcmVzc0hpc3RvcmljYWxCYWxhbmNlJywgJ2Fzc2V0SWQnLCBhc3NldElkKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvbmV0d29ya3Mve25ldHdvcmtfaWR9L2FkZHJlc3Nlcy97YWRkcmVzc19pZH0vYmFsYW5jZV9oaXN0b3J5L3thc3NldF9pZH1gXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wibmV0d29ya19pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKG5ldHdvcmtJZCkpKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcImFkZHJlc3NfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhhZGRyZXNzSWQpKSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJhc3NldF9pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKGFzc2V0SWQpKSk7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IHsgbWV0aG9kOiAnR0VUJywgLi4uYmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBhcGlLZXkgcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gc2Vzc2lvbiByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJKd3RcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBpZiAobGltaXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ2xpbWl0J10gPSBsaW1pdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydwYWdlJ10gPSBwYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0geyAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlciwgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucywgLi4ub3B0aW9ucy5oZWFkZXJzIH07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5CYWxhbmNlSGlzdG9yeUFwaUF4aW9zUGFyYW1DcmVhdG9yID0gQmFsYW5jZUhpc3RvcnlBcGlBeGlvc1BhcmFtQ3JlYXRvcjtcbi8qKlxuICogQmFsYW5jZUhpc3RvcnlBcGkgLSBmdW5jdGlvbmFsIHByb2dyYW1taW5nIGludGVyZmFjZVxuICogQGV4cG9ydFxuICovXG5jb25zdCBCYWxhbmNlSGlzdG9yeUFwaUZwID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24pIHtcbiAgICBjb25zdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yID0gKDAsIGV4cG9ydHMuQmFsYW5jZUhpc3RvcnlBcGlBeGlvc1BhcmFtQ3JlYXRvcikoY29uZmlndXJhdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3QgdGhlIGhpc3RvcmljYWwgYmFsYW5jZSBvZiBhbiBhc3NldCBpbiBhIHNwZWNpZmljIGFkZHJlc3MuXG4gICAgICAgICAqIEBzdW1tYXJ5IEdldCBhZGRyZXNzIGJhbGFuY2UgaGlzdG9yeSBmb3IgYXNzZXRcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5ldHdvcmtJZCBUaGUgSUQgb2YgdGhlIGJsb2NrY2hhaW4gbmV0d29ya1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0byBmZXRjaCB0aGUgaGlzdG9yaWNhbCBiYWxhbmNlIGZvci5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFzc2V0SWQgVGhlIHN5bWJvbCBvZiB0aGUgYXNzZXQgdG8gZmV0Y2ggdGhlIGhpc3RvcmljYWwgYmFsYW5jZSBmb3IuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIEEgbGltaXQgb24gdGhlIG51bWJlciBvZiBvYmplY3RzIHRvIGJlIHJldHVybmVkLiBMaW1pdCBjYW4gcmFuZ2UgYmV0d2VlbiAxIGFuZCAxMDAsIGFuZCB0aGUgZGVmYXVsdCBpcyAxMC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlXSBBIGN1cnNvciBmb3IgcGFnaW5hdGlvbiBhY3Jvc3MgbXVsdGlwbGUgcGFnZXMgb2YgcmVzdWx0cy4gRG9uXFwmIzM5O3QgaW5jbHVkZSB0aGlzIHBhcmFtZXRlciBvbiB0aGUgZmlyc3QgY2FsbC4gVXNlIHRoZSBuZXh0X3BhZ2UgdmFsdWUgcmV0dXJuZWQgaW4gYSBwcmV2aW91cyByZXNwb25zZSB0byByZXF1ZXN0IHN1YnNlcXVlbnQgcmVzdWx0cy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGxpc3RBZGRyZXNzSGlzdG9yaWNhbEJhbGFuY2UobmV0d29ya0lkLCBhZGRyZXNzSWQsIGFzc2V0SWQsIGxpbWl0LCBwYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IubGlzdEFkZHJlc3NIaXN0b3JpY2FsQmFsYW5jZShuZXR3b3JrSWQsIGFkZHJlc3NJZCwgYXNzZXRJZCwgbGltaXQsIHBhZ2UsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IGNvbmZpZ3VyYXRpb24/LnNlcnZlckluZGV4ID8/IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnQmFsYW5jZUhpc3RvcnlBcGkubGlzdEFkZHJlc3NIaXN0b3JpY2FsQmFsYW5jZSddPy5bbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0/LnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5leHBvcnRzLkJhbGFuY2VIaXN0b3J5QXBpRnAgPSBCYWxhbmNlSGlzdG9yeUFwaUZwO1xuLyoqXG4gKiBCYWxhbmNlSGlzdG9yeUFwaSAtIGZhY3RvcnkgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IEJhbGFuY2VIaXN0b3J5QXBpRmFjdG9yeSA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uLCBiYXNlUGF0aCwgYXhpb3MpIHtcbiAgICBjb25zdCBsb2NhbFZhckZwID0gKDAsIGV4cG9ydHMuQmFsYW5jZUhpc3RvcnlBcGlGcCkoY29uZmlndXJhdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3QgdGhlIGhpc3RvcmljYWwgYmFsYW5jZSBvZiBhbiBhc3NldCBpbiBhIHNwZWNpZmljIGFkZHJlc3MuXG4gICAgICAgICAqIEBzdW1tYXJ5IEdldCBhZGRyZXNzIGJhbGFuY2UgaGlzdG9yeSBmb3IgYXNzZXRcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5ldHdvcmtJZCBUaGUgSUQgb2YgdGhlIGJsb2NrY2hhaW4gbmV0d29ya1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0byBmZXRjaCB0aGUgaGlzdG9yaWNhbCBiYWxhbmNlIGZvci5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFzc2V0SWQgVGhlIHN5bWJvbCBvZiB0aGUgYXNzZXQgdG8gZmV0Y2ggdGhlIGhpc3RvcmljYWwgYmFsYW5jZSBmb3IuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIEEgbGltaXQgb24gdGhlIG51bWJlciBvZiBvYmplY3RzIHRvIGJlIHJldHVybmVkLiBMaW1pdCBjYW4gcmFuZ2UgYmV0d2VlbiAxIGFuZCAxMDAsIGFuZCB0aGUgZGVmYXVsdCBpcyAxMC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlXSBBIGN1cnNvciBmb3IgcGFnaW5hdGlvbiBhY3Jvc3MgbXVsdGlwbGUgcGFnZXMgb2YgcmVzdWx0cy4gRG9uXFwmIzM5O3QgaW5jbHVkZSB0aGlzIHBhcmFtZXRlciBvbiB0aGUgZmlyc3QgY2FsbC4gVXNlIHRoZSBuZXh0X3BhZ2UgdmFsdWUgcmV0dXJuZWQgaW4gYSBwcmV2aW91cyByZXNwb25zZSB0byByZXF1ZXN0IHN1YnNlcXVlbnQgcmVzdWx0cy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGxpc3RBZGRyZXNzSGlzdG9yaWNhbEJhbGFuY2UobmV0d29ya0lkLCBhZGRyZXNzSWQsIGFzc2V0SWQsIGxpbWl0LCBwYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5saXN0QWRkcmVzc0hpc3RvcmljYWxCYWxhbmNlKG5ldHdvcmtJZCwgYWRkcmVzc0lkLCBhc3NldElkLCBsaW1pdCwgcGFnZSwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuQmFsYW5jZUhpc3RvcnlBcGlGYWN0b3J5ID0gQmFsYW5jZUhpc3RvcnlBcGlGYWN0b3J5O1xuLyoqXG4gKiBCYWxhbmNlSGlzdG9yeUFwaSAtIG9iamVjdC1vcmllbnRlZCBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqIEBjbGFzcyBCYWxhbmNlSGlzdG9yeUFwaVxuICogQGV4dGVuZHMge0Jhc2VBUEl9XG4gKi9cbmNsYXNzIEJhbGFuY2VIaXN0b3J5QXBpIGV4dGVuZHMgYmFzZV8xLkJhc2VBUEkge1xuICAgIC8qKlxuICAgICAqIExpc3QgdGhlIGhpc3RvcmljYWwgYmFsYW5jZSBvZiBhbiBhc3NldCBpbiBhIHNwZWNpZmljIGFkZHJlc3MuXG4gICAgICogQHN1bW1hcnkgR2V0IGFkZHJlc3MgYmFsYW5jZSBoaXN0b3J5IGZvciBhc3NldFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWQgVGhlIElEIG9mIHRoZSBibG9ja2NoYWluIG5ldHdvcmtcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0byBmZXRjaCB0aGUgaGlzdG9yaWNhbCBiYWxhbmNlIGZvci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXNzZXRJZCBUaGUgc3ltYm9sIG9mIHRoZSBhc3NldCB0byBmZXRjaCB0aGUgaGlzdG9yaWNhbCBiYWxhbmNlIGZvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBBIGxpbWl0IG9uIHRoZSBudW1iZXIgb2Ygb2JqZWN0cyB0byBiZSByZXR1cm5lZC4gTGltaXQgY2FuIHJhbmdlIGJldHdlZW4gMSBhbmQgMTAwLCBhbmQgdGhlIGRlZmF1bHQgaXMgMTAuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlXSBBIGN1cnNvciBmb3IgcGFnaW5hdGlvbiBhY3Jvc3MgbXVsdGlwbGUgcGFnZXMgb2YgcmVzdWx0cy4gRG9uXFwmIzM5O3QgaW5jbHVkZSB0aGlzIHBhcmFtZXRlciBvbiB0aGUgZmlyc3QgY2FsbC4gVXNlIHRoZSBuZXh0X3BhZ2UgdmFsdWUgcmV0dXJuZWQgaW4gYSBwcmV2aW91cyByZXNwb25zZSB0byByZXF1ZXN0IHN1YnNlcXVlbnQgcmVzdWx0cy5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIEJhbGFuY2VIaXN0b3J5QXBpXG4gICAgICovXG4gICAgbGlzdEFkZHJlc3NIaXN0b3JpY2FsQmFsYW5jZShuZXR3b3JrSWQsIGFkZHJlc3NJZCwgYXNzZXRJZCwgbGltaXQsIHBhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLkJhbGFuY2VIaXN0b3J5QXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikubGlzdEFkZHJlc3NIaXN0b3JpY2FsQmFsYW5jZShuZXR3b3JrSWQsIGFkZHJlc3NJZCwgYXNzZXRJZCwgbGltaXQsIHBhZ2UsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuQmFsYW5jZUhpc3RvcnlBcGkgPSBCYWxhbmNlSGlzdG9yeUFwaTtcbi8qKlxuICogQ29udHJhY3RFdmVudHNBcGkgLSBheGlvcyBwYXJhbWV0ZXIgY3JlYXRvclxuICogQGV4cG9ydFxuICovXG5jb25zdCBDb250cmFjdEV2ZW50c0FwaUF4aW9zUGFyYW1DcmVhdG9yID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0cmlldmUgZXZlbnRzIGZvciBhIHNwZWNpZmljIGNvbnRyYWN0XG4gICAgICAgICAqIEBzdW1tYXJ5IExpc3QgY29udHJhY3QgZXZlbnRzXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWQgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBibG9ja2NoYWluIG5ldHdvcmtcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3RvY29sTmFtZSBDYXNlLXNlbnNpdGl2ZSBuYW1lIG9mIHRoZSBibG9ja2NoYWluIHByb3RvY29sXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb250cmFjdEFkZHJlc3MgRVZNIGFkZHJlc3Mgb2YgdGhlIHNtYXJ0IGNvbnRyYWN0ICg0MiBjaGFyYWN0ZXJzLCBpbmNsdWRpbmcgXFwmIzM5OzB4XFwmIzM5OywgaW4gbG93ZXJjYXNlKVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29udHJhY3ROYW1lIENhc2Utc2Vuc2l0aXZlIG5hbWUgb2YgdGhlIHNwZWNpZmljIGNvbnRyYWN0IHdpdGhpbiB0aGUgcHJvamVjdFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIENhc2Utc2Vuc2l0aXZlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIGZpbHRlciBmb3IgaW4gdGhlIGNvbnRyYWN0XFwmIzM5O3MgbG9nc1xuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gZnJvbUJsb2NrSGVpZ2h0IExvd2VyIGJvdW5kIG9mIHRoZSBibG9jayByYW5nZSB0byBxdWVyeSAoaW5jbHVzaXZlKVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gdG9CbG9ja0hlaWdodCBVcHBlciBib3VuZCBvZiB0aGUgYmxvY2sgcmFuZ2UgdG8gcXVlcnkgKGluY2x1c2l2ZSlcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtuZXh0UGFnZV0gUGFnaW5hdGlvbiB0b2tlbiBmb3IgcmV0cmlldmluZyB0aGUgbmV4dCBzZXQgb2YgcmVzdWx0c1xuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgbGlzdENvbnRyYWN0RXZlbnRzOiBhc3luYyAobmV0d29ya0lkLCBwcm90b2NvbE5hbWUsIGNvbnRyYWN0QWRkcmVzcywgY29udHJhY3ROYW1lLCBldmVudE5hbWUsIGZyb21CbG9ja0hlaWdodCwgdG9CbG9ja0hlaWdodCwgbmV4dFBhZ2UsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnbmV0d29ya0lkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2xpc3RDb250cmFjdEV2ZW50cycsICduZXR3b3JrSWQnLCBuZXR3b3JrSWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAncHJvdG9jb2xOYW1lJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2xpc3RDb250cmFjdEV2ZW50cycsICdwcm90b2NvbE5hbWUnLCBwcm90b2NvbE5hbWUpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnY29udHJhY3RBZGRyZXNzJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2xpc3RDb250cmFjdEV2ZW50cycsICdjb250cmFjdEFkZHJlc3MnLCBjb250cmFjdEFkZHJlc3MpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnY29udHJhY3ROYW1lJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2xpc3RDb250cmFjdEV2ZW50cycsICdjb250cmFjdE5hbWUnLCBjb250cmFjdE5hbWUpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnZXZlbnROYW1lJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2xpc3RDb250cmFjdEV2ZW50cycsICdldmVudE5hbWUnLCBldmVudE5hbWUpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnZnJvbUJsb2NrSGVpZ2h0JyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2xpc3RDb250cmFjdEV2ZW50cycsICdmcm9tQmxvY2tIZWlnaHQnLCBmcm9tQmxvY2tIZWlnaHQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAndG9CbG9ja0hlaWdodCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdsaXN0Q29udHJhY3RFdmVudHMnLCAndG9CbG9ja0hlaWdodCcsIHRvQmxvY2tIZWlnaHQpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS9uZXR3b3Jrcy97bmV0d29ya19pZH0vc21hcnRfY29udHJhY3RzL3tjb250cmFjdF9hZGRyZXNzfS9ldmVudHNgXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wibmV0d29ya19pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKG5ldHdvcmtJZCkpKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcImNvbnRyYWN0X2FkZHJlc3NcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhjb250cmFjdEFkZHJlc3MpKSk7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IHsgbWV0aG9kOiAnR0VUJywgLi4uYmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBhcGlLZXkgcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gc2Vzc2lvbiByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJKd3RcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBpZiAocHJvdG9jb2xOYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydwcm90b2NvbF9uYW1lJ10gPSBwcm90b2NvbE5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29udHJhY3ROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydjb250cmFjdF9uYW1lJ10gPSBjb250cmFjdE5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXZlbnROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydldmVudF9uYW1lJ10gPSBldmVudE5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZnJvbUJsb2NrSGVpZ2h0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydmcm9tX2Jsb2NrX2hlaWdodCddID0gZnJvbUJsb2NrSGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRvQmxvY2tIZWlnaHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ3RvX2Jsb2NrX2hlaWdodCddID0gdG9CbG9ja0hlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXh0UGFnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnbmV4dF9wYWdlJ10gPSBuZXh0UGFnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IHsgLi4ubG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIC4uLmhlYWRlcnNGcm9tQmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMuaGVhZGVycyB9O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuQ29udHJhY3RFdmVudHNBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IENvbnRyYWN0RXZlbnRzQXBpQXhpb3NQYXJhbUNyZWF0b3I7XG4vKipcbiAqIENvbnRyYWN0RXZlbnRzQXBpIC0gZnVuY3Rpb25hbCBwcm9ncmFtbWluZyBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgQ29udHJhY3RFdmVudHNBcGlGcCA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uKSB7XG4gICAgY29uc3QgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvciA9ICgwLCBleHBvcnRzLkNvbnRyYWN0RXZlbnRzQXBpQXhpb3NQYXJhbUNyZWF0b3IpKGNvbmZpZ3VyYXRpb24pO1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXRyaWV2ZSBldmVudHMgZm9yIGEgc3BlY2lmaWMgY29udHJhY3RcbiAgICAgICAgICogQHN1bW1hcnkgTGlzdCBjb250cmFjdCBldmVudHNcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5ldHdvcmtJZCBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIGJsb2NrY2hhaW4gbmV0d29ya1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvdG9jb2xOYW1lIENhc2Utc2Vuc2l0aXZlIG5hbWUgb2YgdGhlIGJsb2NrY2hhaW4gcHJvdG9jb2xcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRyYWN0QWRkcmVzcyBFVk0gYWRkcmVzcyBvZiB0aGUgc21hcnQgY29udHJhY3QgKDQyIGNoYXJhY3RlcnMsIGluY2x1ZGluZyBcXCYjMzk7MHhcXCYjMzk7LCBpbiBsb3dlcmNhc2UpXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb250cmFjdE5hbWUgQ2FzZS1zZW5zaXRpdmUgbmFtZSBvZiB0aGUgc3BlY2lmaWMgY29udHJhY3Qgd2l0aGluIHRoZSBwcm9qZWN0XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgQ2FzZS1zZW5zaXRpdmUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gZmlsdGVyIGZvciBpbiB0aGUgY29udHJhY3RcXCYjMzk7cyBsb2dzXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tQmxvY2tIZWlnaHQgTG93ZXIgYm91bmQgb2YgdGhlIGJsb2NrIHJhbmdlIHRvIHF1ZXJ5IChpbmNsdXNpdmUpXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0b0Jsb2NrSGVpZ2h0IFVwcGVyIGJvdW5kIG9mIHRoZSBibG9jayByYW5nZSB0byBxdWVyeSAoaW5jbHVzaXZlKVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW25leHRQYWdlXSBQYWdpbmF0aW9uIHRva2VuIGZvciByZXRyaWV2aW5nIHRoZSBuZXh0IHNldCBvZiByZXN1bHRzXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBsaXN0Q29udHJhY3RFdmVudHMobmV0d29ya0lkLCBwcm90b2NvbE5hbWUsIGNvbnRyYWN0QWRkcmVzcywgY29udHJhY3ROYW1lLCBldmVudE5hbWUsIGZyb21CbG9ja0hlaWdodCwgdG9CbG9ja0hlaWdodCwgbmV4dFBhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5saXN0Q29udHJhY3RFdmVudHMobmV0d29ya0lkLCBwcm90b2NvbE5hbWUsIGNvbnRyYWN0QWRkcmVzcywgY29udHJhY3ROYW1lLCBldmVudE5hbWUsIGZyb21CbG9ja0hlaWdodCwgdG9CbG9ja0hlaWdodCwgbmV4dFBhZ2UsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IGNvbmZpZ3VyYXRpb24/LnNlcnZlckluZGV4ID8/IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnQ29udHJhY3RFdmVudHNBcGkubGlzdENvbnRyYWN0RXZlbnRzJ10/Lltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XT8udXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuQ29udHJhY3RFdmVudHNBcGlGcCA9IENvbnRyYWN0RXZlbnRzQXBpRnA7XG4vKipcbiAqIENvbnRyYWN0RXZlbnRzQXBpIC0gZmFjdG9yeSBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgQ29udHJhY3RFdmVudHNBcGlGYWN0b3J5ID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24sIGJhc2VQYXRoLCBheGlvcykge1xuICAgIGNvbnN0IGxvY2FsVmFyRnAgPSAoMCwgZXhwb3J0cy5Db250cmFjdEV2ZW50c0FwaUZwKShjb25maWd1cmF0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0cmlldmUgZXZlbnRzIGZvciBhIHNwZWNpZmljIGNvbnRyYWN0XG4gICAgICAgICAqIEBzdW1tYXJ5IExpc3QgY29udHJhY3QgZXZlbnRzXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWQgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBibG9ja2NoYWluIG5ldHdvcmtcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3RvY29sTmFtZSBDYXNlLXNlbnNpdGl2ZSBuYW1lIG9mIHRoZSBibG9ja2NoYWluIHByb3RvY29sXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb250cmFjdEFkZHJlc3MgRVZNIGFkZHJlc3Mgb2YgdGhlIHNtYXJ0IGNvbnRyYWN0ICg0MiBjaGFyYWN0ZXJzLCBpbmNsdWRpbmcgXFwmIzM5OzB4XFwmIzM5OywgaW4gbG93ZXJjYXNlKVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29udHJhY3ROYW1lIENhc2Utc2Vuc2l0aXZlIG5hbWUgb2YgdGhlIHNwZWNpZmljIGNvbnRyYWN0IHdpdGhpbiB0aGUgcHJvamVjdFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIENhc2Utc2Vuc2l0aXZlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIGZpbHRlciBmb3IgaW4gdGhlIGNvbnRyYWN0XFwmIzM5O3MgbG9nc1xuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gZnJvbUJsb2NrSGVpZ2h0IExvd2VyIGJvdW5kIG9mIHRoZSBibG9jayByYW5nZSB0byBxdWVyeSAoaW5jbHVzaXZlKVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gdG9CbG9ja0hlaWdodCBVcHBlciBib3VuZCBvZiB0aGUgYmxvY2sgcmFuZ2UgdG8gcXVlcnkgKGluY2x1c2l2ZSlcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtuZXh0UGFnZV0gUGFnaW5hdGlvbiB0b2tlbiBmb3IgcmV0cmlldmluZyB0aGUgbmV4dCBzZXQgb2YgcmVzdWx0c1xuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgbGlzdENvbnRyYWN0RXZlbnRzKG5ldHdvcmtJZCwgcHJvdG9jb2xOYW1lLCBjb250cmFjdEFkZHJlc3MsIGNvbnRyYWN0TmFtZSwgZXZlbnROYW1lLCBmcm9tQmxvY2tIZWlnaHQsIHRvQmxvY2tIZWlnaHQsIG5leHRQYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5saXN0Q29udHJhY3RFdmVudHMobmV0d29ya0lkLCBwcm90b2NvbE5hbWUsIGNvbnRyYWN0QWRkcmVzcywgY29udHJhY3ROYW1lLCBldmVudE5hbWUsIGZyb21CbG9ja0hlaWdodCwgdG9CbG9ja0hlaWdodCwgbmV4dFBhZ2UsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5leHBvcnRzLkNvbnRyYWN0RXZlbnRzQXBpRmFjdG9yeSA9IENvbnRyYWN0RXZlbnRzQXBpRmFjdG9yeTtcbi8qKlxuICogQ29udHJhY3RFdmVudHNBcGkgLSBvYmplY3Qtb3JpZW50ZWQgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKiBAY2xhc3MgQ29udHJhY3RFdmVudHNBcGlcbiAqIEBleHRlbmRzIHtCYXNlQVBJfVxuICovXG5jbGFzcyBDb250cmFjdEV2ZW50c0FwaSBleHRlbmRzIGJhc2VfMS5CYXNlQVBJIHtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSBldmVudHMgZm9yIGEgc3BlY2lmaWMgY29udHJhY3RcbiAgICAgKiBAc3VtbWFyeSBMaXN0IGNvbnRyYWN0IGV2ZW50c1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWQgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBibG9ja2NoYWluIG5ldHdvcmtcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvdG9jb2xOYW1lIENhc2Utc2Vuc2l0aXZlIG5hbWUgb2YgdGhlIGJsb2NrY2hhaW4gcHJvdG9jb2xcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29udHJhY3RBZGRyZXNzIEVWTSBhZGRyZXNzIG9mIHRoZSBzbWFydCBjb250cmFjdCAoNDIgY2hhcmFjdGVycywgaW5jbHVkaW5nIFxcJiMzOTsweFxcJiMzOTssIGluIGxvd2VyY2FzZSlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29udHJhY3ROYW1lIENhc2Utc2Vuc2l0aXZlIG5hbWUgb2YgdGhlIHNwZWNpZmljIGNvbnRyYWN0IHdpdGhpbiB0aGUgcHJvamVjdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgQ2FzZS1zZW5zaXRpdmUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gZmlsdGVyIGZvciBpbiB0aGUgY29udHJhY3RcXCYjMzk7cyBsb2dzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGZyb21CbG9ja0hlaWdodCBMb3dlciBib3VuZCBvZiB0aGUgYmxvY2sgcmFuZ2UgdG8gcXVlcnkgKGluY2x1c2l2ZSlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdG9CbG9ja0hlaWdodCBVcHBlciBib3VuZCBvZiB0aGUgYmxvY2sgcmFuZ2UgdG8gcXVlcnkgKGluY2x1c2l2ZSlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW25leHRQYWdlXSBQYWdpbmF0aW9uIHRva2VuIGZvciByZXRyaWV2aW5nIHRoZSBuZXh0IHNldCBvZiByZXN1bHRzXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBDb250cmFjdEV2ZW50c0FwaVxuICAgICAqL1xuICAgIGxpc3RDb250cmFjdEV2ZW50cyhuZXR3b3JrSWQsIHByb3RvY29sTmFtZSwgY29udHJhY3RBZGRyZXNzLCBjb250cmFjdE5hbWUsIGV2ZW50TmFtZSwgZnJvbUJsb2NrSGVpZ2h0LCB0b0Jsb2NrSGVpZ2h0LCBuZXh0UGFnZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuQ29udHJhY3RFdmVudHNBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5saXN0Q29udHJhY3RFdmVudHMobmV0d29ya0lkLCBwcm90b2NvbE5hbWUsIGNvbnRyYWN0QWRkcmVzcywgY29udHJhY3ROYW1lLCBldmVudE5hbWUsIGZyb21CbG9ja0hlaWdodCwgdG9CbG9ja0hlaWdodCwgbmV4dFBhZ2UsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29udHJhY3RFdmVudHNBcGkgPSBDb250cmFjdEV2ZW50c0FwaTtcbi8qKlxuICogQ29udHJhY3RJbnZvY2F0aW9uc0FwaSAtIGF4aW9zIHBhcmFtZXRlciBjcmVhdG9yXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IENvbnRyYWN0SW52b2NhdGlvbnNBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJyb2FkY2FzdCBhIGNvbnRyYWN0IGludm9jYXRpb24uXG4gICAgICAgICAqIEBzdW1tYXJ5IEJyb2FkY2FzdCBhIGNvbnRyYWN0IGludm9jYXRpb24uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0aGUgY29udHJhY3QgaW52b2NhdGlvbiBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29udHJhY3RJbnZvY2F0aW9uSWQgVGhlIElEIG9mIHRoZSBjb250cmFjdCBpbnZvY2F0aW9uIHRvIGJyb2FkY2FzdC5cbiAgICAgICAgICogQHBhcmFtIHtCcm9hZGNhc3RDb250cmFjdEludm9jYXRpb25SZXF1ZXN0fSBicm9hZGNhc3RDb250cmFjdEludm9jYXRpb25SZXF1ZXN0XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBicm9hZGNhc3RDb250cmFjdEludm9jYXRpb246IGFzeW5jICh3YWxsZXRJZCwgYWRkcmVzc0lkLCBjb250cmFjdEludm9jYXRpb25JZCwgYnJvYWRjYXN0Q29udHJhY3RJbnZvY2F0aW9uUmVxdWVzdCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICd3YWxsZXRJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdicm9hZGNhc3RDb250cmFjdEludm9jYXRpb24nLCAnd2FsbGV0SWQnLCB3YWxsZXRJZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdhZGRyZXNzSWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnYnJvYWRjYXN0Q29udHJhY3RJbnZvY2F0aW9uJywgJ2FkZHJlc3NJZCcsIGFkZHJlc3NJZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdjb250cmFjdEludm9jYXRpb25JZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdicm9hZGNhc3RDb250cmFjdEludm9jYXRpb24nLCAnY29udHJhY3RJbnZvY2F0aW9uSWQnLCBjb250cmFjdEludm9jYXRpb25JZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdicm9hZGNhc3RDb250cmFjdEludm9jYXRpb25SZXF1ZXN0JyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2Jyb2FkY2FzdENvbnRyYWN0SW52b2NhdGlvbicsICdicm9hZGNhc3RDb250cmFjdEludm9jYXRpb25SZXF1ZXN0JywgYnJvYWRjYXN0Q29udHJhY3RJbnZvY2F0aW9uUmVxdWVzdCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL3dhbGxldHMve3dhbGxldF9pZH0vYWRkcmVzc2VzL3thZGRyZXNzX2lkfS9jb250cmFjdF9pbnZvY2F0aW9ucy97Y29udHJhY3RfaW52b2NhdGlvbl9pZH0vYnJvYWRjYXN0YFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcIndhbGxldF9pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHdhbGxldElkKSkpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wiYWRkcmVzc19pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKGFkZHJlc3NJZCkpKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcImNvbnRyYWN0X2ludm9jYXRpb25faWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhjb250cmFjdEludm9jYXRpb25JZCkpKTtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0geyBtZXRob2Q6ICdQT1NUJywgLi4uYmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBhcGlLZXkgcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXJbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0geyAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlciwgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucywgLi4ub3B0aW9ucy5oZWFkZXJzIH07XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmRhdGEgPSAoMCwgY29tbW9uXzEuc2VyaWFsaXplRGF0YUlmTmVlZGVkKShicm9hZGNhc3RDb250cmFjdEludm9jYXRpb25SZXF1ZXN0LCBsb2NhbFZhclJlcXVlc3RPcHRpb25zLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSBuZXcgY29udHJhY3QgaW52b2NhdGlvbi5cbiAgICAgICAgICogQHN1bW1hcnkgQ3JlYXRlIGEgbmV3IGNvbnRyYWN0IGludm9jYXRpb24gZm9yIGFuIGFkZHJlc3MuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgc291cmNlIGFkZHJlc3MgYmVsb25ncyB0by5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdG8gaW52b2tlIHRoZSBjb250cmFjdCBmcm9tLlxuICAgICAgICAgKiBAcGFyYW0ge0NyZWF0ZUNvbnRyYWN0SW52b2NhdGlvblJlcXVlc3R9IGNyZWF0ZUNvbnRyYWN0SW52b2NhdGlvblJlcXVlc3RcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZUNvbnRyYWN0SW52b2NhdGlvbjogYXN5bmMgKHdhbGxldElkLCBhZGRyZXNzSWQsIGNyZWF0ZUNvbnRyYWN0SW52b2NhdGlvblJlcXVlc3QsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnd2FsbGV0SWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnY3JlYXRlQ29udHJhY3RJbnZvY2F0aW9uJywgJ3dhbGxldElkJywgd2FsbGV0SWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnYWRkcmVzc0lkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2NyZWF0ZUNvbnRyYWN0SW52b2NhdGlvbicsICdhZGRyZXNzSWQnLCBhZGRyZXNzSWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnY3JlYXRlQ29udHJhY3RJbnZvY2F0aW9uUmVxdWVzdCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdjcmVhdGVDb250cmFjdEludm9jYXRpb24nLCAnY3JlYXRlQ29udHJhY3RJbnZvY2F0aW9uUmVxdWVzdCcsIGNyZWF0ZUNvbnRyYWN0SW52b2NhdGlvblJlcXVlc3QpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS93YWxsZXRzL3t3YWxsZXRfaWR9L2FkZHJlc3Nlcy97YWRkcmVzc19pZH0vY29udHJhY3RfaW52b2NhdGlvbnNgXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wid2FsbGV0X2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcod2FsbGV0SWQpKSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJhZGRyZXNzX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoYWRkcmVzc0lkKSkpO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7IG1ldGhvZDogJ1BPU1QnLCAuLi5iYXNlT3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIGFwaUtleSByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJKd3RcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBsb2NhbFZhckhlYWRlclBhcmFtZXRlclsnQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSB7IC4uLmxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCAuLi5oZWFkZXJzRnJvbUJhc2VPcHRpb25zLCAuLi5vcHRpb25zLmhlYWRlcnMgfTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuZGF0YSA9ICgwLCBjb21tb25fMS5zZXJpYWxpemVEYXRhSWZOZWVkZWQpKGNyZWF0ZUNvbnRyYWN0SW52b2NhdGlvblJlcXVlc3QsIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBhIGNvbnRyYWN0IGludm9jYXRpb24gYnkgSUQuXG4gICAgICAgICAqIEBzdW1tYXJ5IEdldCBhIGNvbnRyYWN0IGludm9jYXRpb24gYnkgSUQuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0aGUgY29udHJhY3QgaW52b2NhdGlvbiBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29udHJhY3RJbnZvY2F0aW9uSWQgVGhlIElEIG9mIHRoZSBjb250cmFjdCBpbnZvY2F0aW9uIHRvIGZldGNoLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0Q29udHJhY3RJbnZvY2F0aW9uOiBhc3luYyAod2FsbGV0SWQsIGFkZHJlc3NJZCwgY29udHJhY3RJbnZvY2F0aW9uSWQsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnd2FsbGV0SWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZ2V0Q29udHJhY3RJbnZvY2F0aW9uJywgJ3dhbGxldElkJywgd2FsbGV0SWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnYWRkcmVzc0lkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2dldENvbnRyYWN0SW52b2NhdGlvbicsICdhZGRyZXNzSWQnLCBhZGRyZXNzSWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnY29udHJhY3RJbnZvY2F0aW9uSWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZ2V0Q29udHJhY3RJbnZvY2F0aW9uJywgJ2NvbnRyYWN0SW52b2NhdGlvbklkJywgY29udHJhY3RJbnZvY2F0aW9uSWQpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS93YWxsZXRzL3t3YWxsZXRfaWR9L2FkZHJlc3Nlcy97YWRkcmVzc19pZH0vY29udHJhY3RfaW52b2NhdGlvbnMve2NvbnRyYWN0X2ludm9jYXRpb25faWR9YFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcIndhbGxldF9pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHdhbGxldElkKSkpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wiYWRkcmVzc19pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKGFkZHJlc3NJZCkpKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcImNvbnRyYWN0X2ludm9jYXRpb25faWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhjb250cmFjdEludm9jYXRpb25JZCkpKTtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0geyBtZXRob2Q6ICdHRVQnLCAuLi5iYXNlT3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIGFwaUtleSByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJKd3RcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBzZXNzaW9uIHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIkp3dFwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IHsgLi4ubG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIC4uLmhlYWRlcnNGcm9tQmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMuaGVhZGVycyB9O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3QgY29udHJhY3QgaW52b2NhdGlvbnMgZm9yIGFuIGFkZHJlc3MuXG4gICAgICAgICAqIEBzdW1tYXJ5IExpc3QgY29udHJhY3QgaW52b2NhdGlvbnMgZm9yIGFuIGFkZHJlc3MuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0byBsaXN0IGNvbnRyYWN0IGludm9jYXRpb25zIGZvci5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gQSBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIG9iamVjdHMgdG8gYmUgcmV0dXJuZWQuIExpbWl0IGNhbiByYW5nZSBiZXR3ZWVuIDEgYW5kIDEwMCwgYW5kIHRoZSBkZWZhdWx0IGlzIDEwLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VdIEEgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiByZXN1bHRzLiBEb25cXCYjMzk7dCBpbmNsdWRlIHRoaXMgcGFyYW1ldGVyIG9uIHRoZSBmaXJzdCBjYWxsLiBVc2UgdGhlIG5leHRfcGFnZSB2YWx1ZSByZXR1cm5lZCBpbiBhIHByZXZpb3VzIHJlc3BvbnNlIHRvIHJlcXVlc3Qgc3Vic2VxdWVudCByZXN1bHRzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgbGlzdENvbnRyYWN0SW52b2NhdGlvbnM6IGFzeW5jICh3YWxsZXRJZCwgYWRkcmVzc0lkLCBsaW1pdCwgcGFnZSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICd3YWxsZXRJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdsaXN0Q29udHJhY3RJbnZvY2F0aW9ucycsICd3YWxsZXRJZCcsIHdhbGxldElkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2FkZHJlc3NJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdsaXN0Q29udHJhY3RJbnZvY2F0aW9ucycsICdhZGRyZXNzSWQnLCBhZGRyZXNzSWQpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS93YWxsZXRzL3t3YWxsZXRfaWR9L2FkZHJlc3Nlcy97YWRkcmVzc19pZH0vY29udHJhY3RfaW52b2NhdGlvbnNgXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wid2FsbGV0X2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcod2FsbGV0SWQpKSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJhZGRyZXNzX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoYWRkcmVzc0lkKSkpO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7IG1ldGhvZDogJ0dFVCcsIC4uLmJhc2VPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gYXBpS2V5IHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIkp3dFwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIHNlc3Npb24gcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgaWYgKGxpbWl0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydsaW1pdCddID0gbGltaXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsncGFnZSddID0gcGFnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IHsgLi4ubG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIC4uLmhlYWRlcnNGcm9tQmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMuaGVhZGVycyB9O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuQ29udHJhY3RJbnZvY2F0aW9uc0FwaUF4aW9zUGFyYW1DcmVhdG9yID0gQ29udHJhY3RJbnZvY2F0aW9uc0FwaUF4aW9zUGFyYW1DcmVhdG9yO1xuLyoqXG4gKiBDb250cmFjdEludm9jYXRpb25zQXBpIC0gZnVuY3Rpb25hbCBwcm9ncmFtbWluZyBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgQ29udHJhY3RJbnZvY2F0aW9uc0FwaUZwID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24pIHtcbiAgICBjb25zdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yID0gKDAsIGV4cG9ydHMuQ29udHJhY3RJbnZvY2F0aW9uc0FwaUF4aW9zUGFyYW1DcmVhdG9yKShjb25maWd1cmF0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQnJvYWRjYXN0IGEgY29udHJhY3QgaW52b2NhdGlvbi5cbiAgICAgICAgICogQHN1bW1hcnkgQnJvYWRjYXN0IGEgY29udHJhY3QgaW52b2NhdGlvbi5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRoZSBjb250cmFjdCBpbnZvY2F0aW9uIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb250cmFjdEludm9jYXRpb25JZCBUaGUgSUQgb2YgdGhlIGNvbnRyYWN0IGludm9jYXRpb24gdG8gYnJvYWRjYXN0LlxuICAgICAgICAgKiBAcGFyYW0ge0Jyb2FkY2FzdENvbnRyYWN0SW52b2NhdGlvblJlcXVlc3R9IGJyb2FkY2FzdENvbnRyYWN0SW52b2NhdGlvblJlcXVlc3RcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGJyb2FkY2FzdENvbnRyYWN0SW52b2NhdGlvbih3YWxsZXRJZCwgYWRkcmVzc0lkLCBjb250cmFjdEludm9jYXRpb25JZCwgYnJvYWRjYXN0Q29udHJhY3RJbnZvY2F0aW9uUmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmJyb2FkY2FzdENvbnRyYWN0SW52b2NhdGlvbih3YWxsZXRJZCwgYWRkcmVzc0lkLCBjb250cmFjdEludm9jYXRpb25JZCwgYnJvYWRjYXN0Q29udHJhY3RJbnZvY2F0aW9uUmVxdWVzdCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gY29uZmlndXJhdGlvbj8uc2VydmVySW5kZXggPz8gMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydDb250cmFjdEludm9jYXRpb25zQXBpLmJyb2FkY2FzdENvbnRyYWN0SW52b2NhdGlvbiddPy5bbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0/LnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSBuZXcgY29udHJhY3QgaW52b2NhdGlvbi5cbiAgICAgICAgICogQHN1bW1hcnkgQ3JlYXRlIGEgbmV3IGNvbnRyYWN0IGludm9jYXRpb24gZm9yIGFuIGFkZHJlc3MuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgc291cmNlIGFkZHJlc3MgYmVsb25ncyB0by5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdG8gaW52b2tlIHRoZSBjb250cmFjdCBmcm9tLlxuICAgICAgICAgKiBAcGFyYW0ge0NyZWF0ZUNvbnRyYWN0SW52b2NhdGlvblJlcXVlc3R9IGNyZWF0ZUNvbnRyYWN0SW52b2NhdGlvblJlcXVlc3RcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGNyZWF0ZUNvbnRyYWN0SW52b2NhdGlvbih3YWxsZXRJZCwgYWRkcmVzc0lkLCBjcmVhdGVDb250cmFjdEludm9jYXRpb25SZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuY3JlYXRlQ29udHJhY3RJbnZvY2F0aW9uKHdhbGxldElkLCBhZGRyZXNzSWQsIGNyZWF0ZUNvbnRyYWN0SW52b2NhdGlvblJlcXVlc3QsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IGNvbmZpZ3VyYXRpb24/LnNlcnZlckluZGV4ID8/IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnQ29udHJhY3RJbnZvY2F0aW9uc0FwaS5jcmVhdGVDb250cmFjdEludm9jYXRpb24nXT8uW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdPy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGEgY29udHJhY3QgaW52b2NhdGlvbiBieSBJRC5cbiAgICAgICAgICogQHN1bW1hcnkgR2V0IGEgY29udHJhY3QgaW52b2NhdGlvbiBieSBJRC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRoZSBjb250cmFjdCBpbnZvY2F0aW9uIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb250cmFjdEludm9jYXRpb25JZCBUaGUgSUQgb2YgdGhlIGNvbnRyYWN0IGludm9jYXRpb24gdG8gZmV0Y2guXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBnZXRDb250cmFjdEludm9jYXRpb24od2FsbGV0SWQsIGFkZHJlc3NJZCwgY29udHJhY3RJbnZvY2F0aW9uSWQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5nZXRDb250cmFjdEludm9jYXRpb24od2FsbGV0SWQsIGFkZHJlc3NJZCwgY29udHJhY3RJbnZvY2F0aW9uSWQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IGNvbmZpZ3VyYXRpb24/LnNlcnZlckluZGV4ID8/IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnQ29udHJhY3RJbnZvY2F0aW9uc0FwaS5nZXRDb250cmFjdEludm9jYXRpb24nXT8uW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdPy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdCBjb250cmFjdCBpbnZvY2F0aW9ucyBmb3IgYW4gYWRkcmVzcy5cbiAgICAgICAgICogQHN1bW1hcnkgTGlzdCBjb250cmFjdCBpbnZvY2F0aW9ucyBmb3IgYW4gYWRkcmVzcy5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRvIGxpc3QgY29udHJhY3QgaW52b2NhdGlvbnMgZm9yLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBBIGxpbWl0IG9uIHRoZSBudW1iZXIgb2Ygb2JqZWN0cyB0byBiZSByZXR1cm5lZC4gTGltaXQgY2FuIHJhbmdlIGJldHdlZW4gMSBhbmQgMTAwLCBhbmQgdGhlIGRlZmF1bHQgaXMgMTAuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZV0gQSBjdXJzb3IgZm9yIHBhZ2luYXRpb24gYWNyb3NzIG11bHRpcGxlIHBhZ2VzIG9mIHJlc3VsdHMuIERvblxcJiMzOTt0IGluY2x1ZGUgdGhpcyBwYXJhbWV0ZXIgb24gdGhlIGZpcnN0IGNhbGwuIFVzZSB0aGUgbmV4dF9wYWdlIHZhbHVlIHJldHVybmVkIGluIGEgcHJldmlvdXMgcmVzcG9uc2UgdG8gcmVxdWVzdCBzdWJzZXF1ZW50IHJlc3VsdHMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBsaXN0Q29udHJhY3RJbnZvY2F0aW9ucyh3YWxsZXRJZCwgYWRkcmVzc0lkLCBsaW1pdCwgcGFnZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmxpc3RDb250cmFjdEludm9jYXRpb25zKHdhbGxldElkLCBhZGRyZXNzSWQsIGxpbWl0LCBwYWdlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSBjb25maWd1cmF0aW9uPy5zZXJ2ZXJJbmRleCA/PyAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ0NvbnRyYWN0SW52b2NhdGlvbnNBcGkubGlzdENvbnRyYWN0SW52b2NhdGlvbnMnXT8uW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdPy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5Db250cmFjdEludm9jYXRpb25zQXBpRnAgPSBDb250cmFjdEludm9jYXRpb25zQXBpRnA7XG4vKipcbiAqIENvbnRyYWN0SW52b2NhdGlvbnNBcGkgLSBmYWN0b3J5IGludGVyZmFjZVxuICogQGV4cG9ydFxuICovXG5jb25zdCBDb250cmFjdEludm9jYXRpb25zQXBpRmFjdG9yeSA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uLCBiYXNlUGF0aCwgYXhpb3MpIHtcbiAgICBjb25zdCBsb2NhbFZhckZwID0gKDAsIGV4cG9ydHMuQ29udHJhY3RJbnZvY2F0aW9uc0FwaUZwKShjb25maWd1cmF0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQnJvYWRjYXN0IGEgY29udHJhY3QgaW52b2NhdGlvbi5cbiAgICAgICAgICogQHN1bW1hcnkgQnJvYWRjYXN0IGEgY29udHJhY3QgaW52b2NhdGlvbi5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRoZSBjb250cmFjdCBpbnZvY2F0aW9uIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb250cmFjdEludm9jYXRpb25JZCBUaGUgSUQgb2YgdGhlIGNvbnRyYWN0IGludm9jYXRpb24gdG8gYnJvYWRjYXN0LlxuICAgICAgICAgKiBAcGFyYW0ge0Jyb2FkY2FzdENvbnRyYWN0SW52b2NhdGlvblJlcXVlc3R9IGJyb2FkY2FzdENvbnRyYWN0SW52b2NhdGlvblJlcXVlc3RcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGJyb2FkY2FzdENvbnRyYWN0SW52b2NhdGlvbih3YWxsZXRJZCwgYWRkcmVzc0lkLCBjb250cmFjdEludm9jYXRpb25JZCwgYnJvYWRjYXN0Q29udHJhY3RJbnZvY2F0aW9uUmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuYnJvYWRjYXN0Q29udHJhY3RJbnZvY2F0aW9uKHdhbGxldElkLCBhZGRyZXNzSWQsIGNvbnRyYWN0SW52b2NhdGlvbklkLCBicm9hZGNhc3RDb250cmFjdEludm9jYXRpb25SZXF1ZXN0LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgbmV3IGNvbnRyYWN0IGludm9jYXRpb24uXG4gICAgICAgICAqIEBzdW1tYXJ5IENyZWF0ZSBhIG5ldyBjb250cmFjdCBpbnZvY2F0aW9uIGZvciBhbiBhZGRyZXNzLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIHNvdXJjZSBhZGRyZXNzIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRvIGludm9rZSB0aGUgY29udHJhY3QgZnJvbS5cbiAgICAgICAgICogQHBhcmFtIHtDcmVhdGVDb250cmFjdEludm9jYXRpb25SZXF1ZXN0fSBjcmVhdGVDb250cmFjdEludm9jYXRpb25SZXF1ZXN0XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGVDb250cmFjdEludm9jYXRpb24od2FsbGV0SWQsIGFkZHJlc3NJZCwgY3JlYXRlQ29udHJhY3RJbnZvY2F0aW9uUmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuY3JlYXRlQ29udHJhY3RJbnZvY2F0aW9uKHdhbGxldElkLCBhZGRyZXNzSWQsIGNyZWF0ZUNvbnRyYWN0SW52b2NhdGlvblJlcXVlc3QsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgYSBjb250cmFjdCBpbnZvY2F0aW9uIGJ5IElELlxuICAgICAgICAgKiBAc3VtbWFyeSBHZXQgYSBjb250cmFjdCBpbnZvY2F0aW9uIGJ5IElELlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0by5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdGhlIGNvbnRyYWN0IGludm9jYXRpb24gYmVsb25ncyB0by5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRyYWN0SW52b2NhdGlvbklkIFRoZSBJRCBvZiB0aGUgY29udHJhY3QgaW52b2NhdGlvbiB0byBmZXRjaC5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGdldENvbnRyYWN0SW52b2NhdGlvbih3YWxsZXRJZCwgYWRkcmVzc0lkLCBjb250cmFjdEludm9jYXRpb25JZCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuZ2V0Q29udHJhY3RJbnZvY2F0aW9uKHdhbGxldElkLCBhZGRyZXNzSWQsIGNvbnRyYWN0SW52b2NhdGlvbklkLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdCBjb250cmFjdCBpbnZvY2F0aW9ucyBmb3IgYW4gYWRkcmVzcy5cbiAgICAgICAgICogQHN1bW1hcnkgTGlzdCBjb250cmFjdCBpbnZvY2F0aW9ucyBmb3IgYW4gYWRkcmVzcy5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRvIGxpc3QgY29udHJhY3QgaW52b2NhdGlvbnMgZm9yLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBBIGxpbWl0IG9uIHRoZSBudW1iZXIgb2Ygb2JqZWN0cyB0byBiZSByZXR1cm5lZC4gTGltaXQgY2FuIHJhbmdlIGJldHdlZW4gMSBhbmQgMTAwLCBhbmQgdGhlIGRlZmF1bHQgaXMgMTAuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZV0gQSBjdXJzb3IgZm9yIHBhZ2luYXRpb24gYWNyb3NzIG11bHRpcGxlIHBhZ2VzIG9mIHJlc3VsdHMuIERvblxcJiMzOTt0IGluY2x1ZGUgdGhpcyBwYXJhbWV0ZXIgb24gdGhlIGZpcnN0IGNhbGwuIFVzZSB0aGUgbmV4dF9wYWdlIHZhbHVlIHJldHVybmVkIGluIGEgcHJldmlvdXMgcmVzcG9uc2UgdG8gcmVxdWVzdCBzdWJzZXF1ZW50IHJlc3VsdHMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBsaXN0Q29udHJhY3RJbnZvY2F0aW9ucyh3YWxsZXRJZCwgYWRkcmVzc0lkLCBsaW1pdCwgcGFnZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAubGlzdENvbnRyYWN0SW52b2NhdGlvbnMod2FsbGV0SWQsIGFkZHJlc3NJZCwgbGltaXQsIHBhZ2UsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5leHBvcnRzLkNvbnRyYWN0SW52b2NhdGlvbnNBcGlGYWN0b3J5ID0gQ29udHJhY3RJbnZvY2F0aW9uc0FwaUZhY3Rvcnk7XG4vKipcbiAqIENvbnRyYWN0SW52b2NhdGlvbnNBcGkgLSBvYmplY3Qtb3JpZW50ZWQgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKiBAY2xhc3MgQ29udHJhY3RJbnZvY2F0aW9uc0FwaVxuICogQGV4dGVuZHMge0Jhc2VBUEl9XG4gKi9cbmNsYXNzIENvbnRyYWN0SW52b2NhdGlvbnNBcGkgZXh0ZW5kcyBiYXNlXzEuQmFzZUFQSSB7XG4gICAgLyoqXG4gICAgICogQnJvYWRjYXN0IGEgY29udHJhY3QgaW52b2NhdGlvbi5cbiAgICAgKiBAc3VtbWFyeSBCcm9hZGNhc3QgYSBjb250cmFjdCBpbnZvY2F0aW9uLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRoZSBjb250cmFjdCBpbnZvY2F0aW9uIGJlbG9uZ3MgdG8uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRyYWN0SW52b2NhdGlvbklkIFRoZSBJRCBvZiB0aGUgY29udHJhY3QgaW52b2NhdGlvbiB0byBicm9hZGNhc3QuXG4gICAgICogQHBhcmFtIHtCcm9hZGNhc3RDb250cmFjdEludm9jYXRpb25SZXF1ZXN0fSBicm9hZGNhc3RDb250cmFjdEludm9jYXRpb25SZXF1ZXN0XG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBDb250cmFjdEludm9jYXRpb25zQXBpXG4gICAgICovXG4gICAgYnJvYWRjYXN0Q29udHJhY3RJbnZvY2F0aW9uKHdhbGxldElkLCBhZGRyZXNzSWQsIGNvbnRyYWN0SW52b2NhdGlvbklkLCBicm9hZGNhc3RDb250cmFjdEludm9jYXRpb25SZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5Db250cmFjdEludm9jYXRpb25zQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuYnJvYWRjYXN0Q29udHJhY3RJbnZvY2F0aW9uKHdhbGxldElkLCBhZGRyZXNzSWQsIGNvbnRyYWN0SW52b2NhdGlvbklkLCBicm9hZGNhc3RDb250cmFjdEludm9jYXRpb25SZXF1ZXN0LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IGNvbnRyYWN0IGludm9jYXRpb24uXG4gICAgICogQHN1bW1hcnkgQ3JlYXRlIGEgbmV3IGNvbnRyYWN0IGludm9jYXRpb24gZm9yIGFuIGFkZHJlc3MuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBzb3VyY2UgYWRkcmVzcyBiZWxvbmdzIHRvLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRvIGludm9rZSB0aGUgY29udHJhY3QgZnJvbS5cbiAgICAgKiBAcGFyYW0ge0NyZWF0ZUNvbnRyYWN0SW52b2NhdGlvblJlcXVlc3R9IGNyZWF0ZUNvbnRyYWN0SW52b2NhdGlvblJlcXVlc3RcbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIENvbnRyYWN0SW52b2NhdGlvbnNBcGlcbiAgICAgKi9cbiAgICBjcmVhdGVDb250cmFjdEludm9jYXRpb24od2FsbGV0SWQsIGFkZHJlc3NJZCwgY3JlYXRlQ29udHJhY3RJbnZvY2F0aW9uUmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuQ29udHJhY3RJbnZvY2F0aW9uc0FwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLmNyZWF0ZUNvbnRyYWN0SW52b2NhdGlvbih3YWxsZXRJZCwgYWRkcmVzc0lkLCBjcmVhdGVDb250cmFjdEludm9jYXRpb25SZXF1ZXN0LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGEgY29udHJhY3QgaW52b2NhdGlvbiBieSBJRC5cbiAgICAgKiBAc3VtbWFyeSBHZXQgYSBjb250cmFjdCBpbnZvY2F0aW9uIGJ5IElELlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRoZSBjb250cmFjdCBpbnZvY2F0aW9uIGJlbG9uZ3MgdG8uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRyYWN0SW52b2NhdGlvbklkIFRoZSBJRCBvZiB0aGUgY29udHJhY3QgaW52b2NhdGlvbiB0byBmZXRjaC5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIENvbnRyYWN0SW52b2NhdGlvbnNBcGlcbiAgICAgKi9cbiAgICBnZXRDb250cmFjdEludm9jYXRpb24od2FsbGV0SWQsIGFkZHJlc3NJZCwgY29udHJhY3RJbnZvY2F0aW9uSWQsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLkNvbnRyYWN0SW52b2NhdGlvbnNBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5nZXRDb250cmFjdEludm9jYXRpb24od2FsbGV0SWQsIGFkZHJlc3NJZCwgY29udHJhY3RJbnZvY2F0aW9uSWQsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0IGNvbnRyYWN0IGludm9jYXRpb25zIGZvciBhbiBhZGRyZXNzLlxuICAgICAqIEBzdW1tYXJ5IExpc3QgY29udHJhY3QgaW52b2NhdGlvbnMgZm9yIGFuIGFkZHJlc3MuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG8uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdG8gbGlzdCBjb250cmFjdCBpbnZvY2F0aW9ucyBmb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gQSBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIG9iamVjdHMgdG8gYmUgcmV0dXJuZWQuIExpbWl0IGNhbiByYW5nZSBiZXR3ZWVuIDEgYW5kIDEwMCwgYW5kIHRoZSBkZWZhdWx0IGlzIDEwLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZV0gQSBjdXJzb3IgZm9yIHBhZ2luYXRpb24gYWNyb3NzIG11bHRpcGxlIHBhZ2VzIG9mIHJlc3VsdHMuIERvblxcJiMzOTt0IGluY2x1ZGUgdGhpcyBwYXJhbWV0ZXIgb24gdGhlIGZpcnN0IGNhbGwuIFVzZSB0aGUgbmV4dF9wYWdlIHZhbHVlIHJldHVybmVkIGluIGEgcHJldmlvdXMgcmVzcG9uc2UgdG8gcmVxdWVzdCBzdWJzZXF1ZW50IHJlc3VsdHMuXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBDb250cmFjdEludm9jYXRpb25zQXBpXG4gICAgICovXG4gICAgbGlzdENvbnRyYWN0SW52b2NhdGlvbnMod2FsbGV0SWQsIGFkZHJlc3NJZCwgbGltaXQsIHBhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLkNvbnRyYWN0SW52b2NhdGlvbnNBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5saXN0Q29udHJhY3RJbnZvY2F0aW9ucyh3YWxsZXRJZCwgYWRkcmVzc0lkLCBsaW1pdCwgcGFnZSwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxufVxuZXhwb3J0cy5Db250cmFjdEludm9jYXRpb25zQXBpID0gQ29udHJhY3RJbnZvY2F0aW9uc0FwaTtcbi8qKlxuICogRXh0ZXJuYWxBZGRyZXNzZXNBcGkgLSBheGlvcyBwYXJhbWV0ZXIgY3JlYXRvclxuICogQGV4cG9ydFxuICovXG5jb25zdCBFeHRlcm5hbEFkZHJlc3Nlc0FwaUF4aW9zUGFyYW1DcmVhdG9yID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQnJvYWRjYXN0IGFuIGFyYml0cmFyeSB0cmFuc2FjdGlvbiB0byB0aGUgbm9kZSBjb25zdHJ1Y3RlZCBhbmQgc2lnbmVkIGJ5IGFuIGV4dGVybmFsIGFkZHJlc3MuXG4gICAgICAgICAqIEBzdW1tYXJ5IEJyb2FkY2FzdCBhbiBhcmJpdHJhcnkgdHJhbnNhY3Rpb24uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWQgVGhlIElEIG9mIHRoZSBuZXR3b3JrIHRoZSBleHRlcm5hbCBhZGRyZXNzIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIG9uY2hhaW4gYWRkcmVzcyBvZiB0aGUgdHJhbnNhY3Rpb24gc2VuZGVyLlxuICAgICAgICAgKiBAcGFyYW0ge0Jyb2FkY2FzdEV4dGVybmFsVHJhbnNhY3Rpb25SZXF1ZXN0fSBicm9hZGNhc3RFeHRlcm5hbFRyYW5zYWN0aW9uUmVxdWVzdFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYnJvYWRjYXN0RXh0ZXJuYWxUcmFuc2FjdGlvbjogYXN5bmMgKG5ldHdvcmtJZCwgYWRkcmVzc0lkLCBicm9hZGNhc3RFeHRlcm5hbFRyYW5zYWN0aW9uUmVxdWVzdCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICduZXR3b3JrSWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnYnJvYWRjYXN0RXh0ZXJuYWxUcmFuc2FjdGlvbicsICduZXR3b3JrSWQnLCBuZXR3b3JrSWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnYWRkcmVzc0lkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2Jyb2FkY2FzdEV4dGVybmFsVHJhbnNhY3Rpb24nLCAnYWRkcmVzc0lkJywgYWRkcmVzc0lkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2Jyb2FkY2FzdEV4dGVybmFsVHJhbnNhY3Rpb25SZXF1ZXN0JyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2Jyb2FkY2FzdEV4dGVybmFsVHJhbnNhY3Rpb24nLCAnYnJvYWRjYXN0RXh0ZXJuYWxUcmFuc2FjdGlvblJlcXVlc3QnLCBicm9hZGNhc3RFeHRlcm5hbFRyYW5zYWN0aW9uUmVxdWVzdCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL25ldHdvcmtzL3tuZXR3b3JrX2lkfS9hZGRyZXNzZXMve2FkZHJlc3NfaWR9L3RyYW5zYWN0aW9uc2BcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJuZXR3b3JrX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcobmV0d29ya0lkKSkpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wiYWRkcmVzc19pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKGFkZHJlc3NJZCkpKTtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0geyBtZXRob2Q6ICdQT1NUJywgLi4uYmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBhcGlLZXkgcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gc2Vzc2lvbiByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJKd3RcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBsb2NhbFZhckhlYWRlclBhcmFtZXRlclsnQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSB7IC4uLmxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCAuLi5oZWFkZXJzRnJvbUJhc2VPcHRpb25zLCAuLi5vcHRpb25zLmhlYWRlcnMgfTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuZGF0YSA9ICgwLCBjb21tb25fMS5zZXJpYWxpemVEYXRhSWZOZWVkZWQpKGJyb2FkY2FzdEV4dGVybmFsVHJhbnNhY3Rpb25SZXF1ZXN0LCBsb2NhbFZhclJlcXVlc3RPcHRpb25zLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCcm9hZGNhc3QgYW4gZXh0ZXJuYWwgYWRkcmVzc1xcJ3MgdHJhbnNmZXIgd2l0aCBhIHNpZ25lZCBwYXlsb2FkXG4gICAgICAgICAqIEBzdW1tYXJ5IEJyb2FkY2FzdCBhbiBleHRlcm5hbCBhZGRyZXNzXFwnIHRyYW5zZmVyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWQgVGhlIElEIG9mIHRoZSBuZXR3b3JrIHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG9cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdGhlIHRyYW5zZmVyIGJlbG9uZ3MgdG9cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHRyYW5zZmVySWQgVGhlIElEIG9mIHRoZSB0cmFuc2ZlciB0byBicm9hZGNhc3RcbiAgICAgICAgICogQHBhcmFtIHtCcm9hZGNhc3RFeHRlcm5hbFRyYW5zZmVyUmVxdWVzdH0gYnJvYWRjYXN0RXh0ZXJuYWxUcmFuc2ZlclJlcXVlc3RcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGJyb2FkY2FzdEV4dGVybmFsVHJhbnNmZXI6IGFzeW5jIChuZXR3b3JrSWQsIGFkZHJlc3NJZCwgdHJhbnNmZXJJZCwgYnJvYWRjYXN0RXh0ZXJuYWxUcmFuc2ZlclJlcXVlc3QsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnbmV0d29ya0lkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2Jyb2FkY2FzdEV4dGVybmFsVHJhbnNmZXInLCAnbmV0d29ya0lkJywgbmV0d29ya0lkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2FkZHJlc3NJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdicm9hZGNhc3RFeHRlcm5hbFRyYW5zZmVyJywgJ2FkZHJlc3NJZCcsIGFkZHJlc3NJZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICd0cmFuc2ZlcklkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2Jyb2FkY2FzdEV4dGVybmFsVHJhbnNmZXInLCAndHJhbnNmZXJJZCcsIHRyYW5zZmVySWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnYnJvYWRjYXN0RXh0ZXJuYWxUcmFuc2ZlclJlcXVlc3QnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnYnJvYWRjYXN0RXh0ZXJuYWxUcmFuc2ZlcicsICdicm9hZGNhc3RFeHRlcm5hbFRyYW5zZmVyUmVxdWVzdCcsIGJyb2FkY2FzdEV4dGVybmFsVHJhbnNmZXJSZXF1ZXN0KTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvbmV0d29ya3Mve25ldHdvcmtfaWR9L2FkZHJlc3Nlcy97YWRkcmVzc19pZH0vdHJhbnNmZXJzL3t0cmFuc2Zlcl9pZH0vYnJvYWRjYXN0YFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcIm5ldHdvcmtfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhuZXR3b3JrSWQpKSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJhZGRyZXNzX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoYWRkcmVzc0lkKSkpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1widHJhbnNmZXJfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyh0cmFuc2ZlcklkKSkpO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7IG1ldGhvZDogJ1BPU1QnLCAuLi5iYXNlT3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIGFwaUtleSByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJKd3RcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBsb2NhbFZhckhlYWRlclBhcmFtZXRlclsnQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSB7IC4uLmxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCAuLi5oZWFkZXJzRnJvbUJhc2VPcHRpb25zLCAuLi5vcHRpb25zLmhlYWRlcnMgfTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuZGF0YSA9ICgwLCBjb21tb25fMS5zZXJpYWxpemVEYXRhSWZOZWVkZWQpKGJyb2FkY2FzdEV4dGVybmFsVHJhbnNmZXJSZXF1ZXN0LCBsb2NhbFZhclJlcXVlc3RPcHRpb25zLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSBuZXcgdHJhbnNmZXIgYmV0d2VlbiBhZGRyZXNzZXMuXG4gICAgICAgICAqIEBzdW1tYXJ5IENyZWF0ZSBhIG5ldyB0cmFuc2ZlclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29ya0lkIFRoZSBJRCBvZiB0aGUgbmV0d29yayB0aGUgYWRkcmVzcyBpcyBvblxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0byB0cmFuc2ZlciBmcm9tXG4gICAgICAgICAqIEBwYXJhbSB7Q3JlYXRlRXh0ZXJuYWxUcmFuc2ZlclJlcXVlc3R9IGNyZWF0ZUV4dGVybmFsVHJhbnNmZXJSZXF1ZXN0XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGVFeHRlcm5hbFRyYW5zZmVyOiBhc3luYyAobmV0d29ya0lkLCBhZGRyZXNzSWQsIGNyZWF0ZUV4dGVybmFsVHJhbnNmZXJSZXF1ZXN0LCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ25ldHdvcmtJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdjcmVhdGVFeHRlcm5hbFRyYW5zZmVyJywgJ25ldHdvcmtJZCcsIG5ldHdvcmtJZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdhZGRyZXNzSWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnY3JlYXRlRXh0ZXJuYWxUcmFuc2ZlcicsICdhZGRyZXNzSWQnLCBhZGRyZXNzSWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnY3JlYXRlRXh0ZXJuYWxUcmFuc2ZlclJlcXVlc3QnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnY3JlYXRlRXh0ZXJuYWxUcmFuc2ZlcicsICdjcmVhdGVFeHRlcm5hbFRyYW5zZmVyUmVxdWVzdCcsIGNyZWF0ZUV4dGVybmFsVHJhbnNmZXJSZXF1ZXN0KTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvbmV0d29ya3Mve25ldHdvcmtfaWR9L2FkZHJlc3Nlcy97YWRkcmVzc19pZH0vdHJhbnNmZXJzYFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcIm5ldHdvcmtfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhuZXR3b3JrSWQpKSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJhZGRyZXNzX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoYWRkcmVzc0lkKSkpO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7IG1ldGhvZDogJ1BPU1QnLCAuLi5iYXNlT3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIGFwaUtleSByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJKd3RcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBsb2NhbFZhckhlYWRlclBhcmFtZXRlclsnQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSB7IC4uLmxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCAuLi5oZWFkZXJzRnJvbUJhc2VPcHRpb25zLCAuLi5vcHRpb25zLmhlYWRlcnMgfTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuZGF0YSA9ICgwLCBjb21tb25fMS5zZXJpYWxpemVEYXRhSWZOZWVkZWQpKGNyZWF0ZUV4dGVybmFsVHJhbnNmZXJSZXF1ZXN0LCBsb2NhbFZhclJlcXVlc3RPcHRpb25zLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGJhbGFuY2Ugb2YgYW4gYXNzZXQgaW4gYW4gZXh0ZXJuYWwgYWRkcmVzc1xuICAgICAgICAgKiBAc3VtbWFyeSBHZXQgdGhlIGJhbGFuY2Ugb2YgYW4gYXNzZXQgaW4gYW4gZXh0ZXJuYWwgYWRkcmVzc1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29ya0lkIFRoZSBJRCBvZiB0aGUgYmxvY2tjaGFpbiBuZXR3b3JrXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRvIGZldGNoIHRoZSBiYWxhbmNlIGZvclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXNzZXRJZCBUaGUgSUQgb2YgdGhlIGFzc2V0IHRvIGZldGNoIHRoZSBiYWxhbmNlIGZvclxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0RXh0ZXJuYWxBZGRyZXNzQmFsYW5jZTogYXN5bmMgKG5ldHdvcmtJZCwgYWRkcmVzc0lkLCBhc3NldElkLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ25ldHdvcmtJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdnZXRFeHRlcm5hbEFkZHJlc3NCYWxhbmNlJywgJ25ldHdvcmtJZCcsIG5ldHdvcmtJZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdhZGRyZXNzSWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZ2V0RXh0ZXJuYWxBZGRyZXNzQmFsYW5jZScsICdhZGRyZXNzSWQnLCBhZGRyZXNzSWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnYXNzZXRJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdnZXRFeHRlcm5hbEFkZHJlc3NCYWxhbmNlJywgJ2Fzc2V0SWQnLCBhc3NldElkKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvbmV0d29ya3Mve25ldHdvcmtfaWR9L2FkZHJlc3Nlcy97YWRkcmVzc19pZH0vYmFsYW5jZXMve2Fzc2V0X2lkfWBcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJuZXR3b3JrX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcobmV0d29ya0lkKSkpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wiYWRkcmVzc19pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKGFkZHJlc3NJZCkpKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcImFzc2V0X2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoYXNzZXRJZCkpKTtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0geyBtZXRob2Q6ICdHRVQnLCAuLi5iYXNlT3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIGFwaUtleSByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJKd3RcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBzZXNzaW9uIHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIkp3dFwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IHsgLi4ubG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIC4uLmhlYWRlcnNGcm9tQmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMuaGVhZGVycyB9O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBhbiBleHRlcm5hbCBhZGRyZXNzXFwnIHRyYW5zZmVyIGJ5IElEXG4gICAgICAgICAqIEBzdW1tYXJ5IEdldCBhIGV4dGVybmFsIGFkZHJlc3NcXCcgdHJhbnNmZXJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5ldHdvcmtJZCBUaGUgSUQgb2YgdGhlIG5ldHdvcmsgdGhlIGFkZHJlc3MgaXMgb25cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdGhlIHRyYW5zZmVyIGJlbG9uZ3MgdG9cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHRyYW5zZmVySWQgVGhlIElEIG9mIHRoZSB0cmFuc2ZlciB0byBmZXRjaFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0RXh0ZXJuYWxUcmFuc2ZlcjogYXN5bmMgKG5ldHdvcmtJZCwgYWRkcmVzc0lkLCB0cmFuc2ZlcklkLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ25ldHdvcmtJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdnZXRFeHRlcm5hbFRyYW5zZmVyJywgJ25ldHdvcmtJZCcsIG5ldHdvcmtJZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdhZGRyZXNzSWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZ2V0RXh0ZXJuYWxUcmFuc2ZlcicsICdhZGRyZXNzSWQnLCBhZGRyZXNzSWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAndHJhbnNmZXJJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdnZXRFeHRlcm5hbFRyYW5zZmVyJywgJ3RyYW5zZmVySWQnLCB0cmFuc2ZlcklkKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvbmV0d29ya3Mve25ldHdvcmtfaWR9L2FkZHJlc3Nlcy97YWRkcmVzc19pZH0vdHJhbnNmZXJzL3t0cmFuc2Zlcl9pZH1gXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wibmV0d29ya19pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKG5ldHdvcmtJZCkpKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcImFkZHJlc3NfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhhZGRyZXNzSWQpKSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJ0cmFuc2Zlcl9pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHRyYW5zZmVySWQpKSk7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IHsgbWV0aG9kOiAnR0VUJywgLi4uYmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBhcGlLZXkgcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0geyAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlciwgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucywgLi4ub3B0aW9ucy5oZWFkZXJzIH07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBzdGF0dXMgb2YgYSBmYXVjZXQgdHJhbnNhY3Rpb25cbiAgICAgICAgICogQHN1bW1hcnkgR2V0IHRoZSBzdGF0dXMgb2YgYSBmYXVjZXQgdHJhbnNhY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5ldHdvcmtJZCBUaGUgSUQgb2YgdGhlIGJsb2NrY2hhaW4gbmV0d29ya1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0byBmZXRjaCB0aGUgZmF1Y2V0IHRyYW5zYWN0aW9uIGZvclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHhIYXNoIFRoZSBoYXNoIG9mIHRoZSBmYXVjZXQgdHJhbnNhY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGdldEZhdWNldFRyYW5zYWN0aW9uOiBhc3luYyAobmV0d29ya0lkLCBhZGRyZXNzSWQsIHR4SGFzaCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICduZXR3b3JrSWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZ2V0RmF1Y2V0VHJhbnNhY3Rpb24nLCAnbmV0d29ya0lkJywgbmV0d29ya0lkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2FkZHJlc3NJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdnZXRGYXVjZXRUcmFuc2FjdGlvbicsICdhZGRyZXNzSWQnLCBhZGRyZXNzSWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAndHhIYXNoJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2dldEZhdWNldFRyYW5zYWN0aW9uJywgJ3R4SGFzaCcsIHR4SGFzaCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL25ldHdvcmtzL3tuZXR3b3JrX2lkfS9hZGRyZXNzZXMve2FkZHJlc3NfaWR9L2ZhdWNldC97dHhfaGFzaH1gXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wibmV0d29ya19pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKG5ldHdvcmtJZCkpKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcImFkZHJlc3NfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhhZGRyZXNzSWQpKSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJ0eF9oYXNoXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcodHhIYXNoKSkpO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7IG1ldGhvZDogJ0dFVCcsIC4uLmJhc2VPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gYXBpS2V5IHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIkp3dFwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIHNlc3Npb24gcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0geyAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlciwgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucywgLi4ub3B0aW9ucy5oZWFkZXJzIH07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdCBhbGwgb2YgdGhlIGJhbGFuY2VzIG9mIGFuIGV4dGVybmFsIGFkZHJlc3NcbiAgICAgICAgICogQHN1bW1hcnkgR2V0IHRoZSBiYWxhbmNlcyBvZiBhbiBleHRlcm5hbCBhZGRyZXNzXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWQgVGhlIElEIG9mIHRoZSBibG9ja2NoYWluIG5ldHdvcmtcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdG8gZmV0Y2ggdGhlIGJhbGFuY2UgZm9yXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZV0gQSBjdXJzb3IgZm9yIHBhZ2luYXRpb24gYWNyb3NzIG11bHRpcGxlIHBhZ2VzIG9mIHJlc3VsdHMuIERvblxcJiMzOTt0IGluY2x1ZGUgdGhpcyBwYXJhbWV0ZXIgb24gdGhlIGZpcnN0IGNhbGwuIFVzZSB0aGUgbmV4dF9wYWdlIHZhbHVlIHJldHVybmVkIGluIGEgcHJldmlvdXMgcmVzcG9uc2UgdG8gcmVxdWVzdCBzdWJzZXF1ZW50IHJlc3VsdHMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBsaXN0RXh0ZXJuYWxBZGRyZXNzQmFsYW5jZXM6IGFzeW5jIChuZXR3b3JrSWQsIGFkZHJlc3NJZCwgcGFnZSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICduZXR3b3JrSWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnbGlzdEV4dGVybmFsQWRkcmVzc0JhbGFuY2VzJywgJ25ldHdvcmtJZCcsIG5ldHdvcmtJZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdhZGRyZXNzSWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnbGlzdEV4dGVybmFsQWRkcmVzc0JhbGFuY2VzJywgJ2FkZHJlc3NJZCcsIGFkZHJlc3NJZCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL25ldHdvcmtzL3tuZXR3b3JrX2lkfS9hZGRyZXNzZXMve2FkZHJlc3NfaWR9L2JhbGFuY2VzYFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcIm5ldHdvcmtfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhuZXR3b3JrSWQpKSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJhZGRyZXNzX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoYWRkcmVzc0lkKSkpO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7IG1ldGhvZDogJ0dFVCcsIC4uLmJhc2VPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gYXBpS2V5IHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIkp3dFwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIHNlc3Npb24gcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgaWYgKHBhZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ3BhZ2UnXSA9IHBhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSB7IC4uLmxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCAuLi5oZWFkZXJzRnJvbUJhc2VPcHRpb25zLCAuLi5vcHRpb25zLmhlYWRlcnMgfTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXF1ZXN0IGZhdWNldCBmdW5kcyB0byBiZSBzZW50IHRvIGV4dGVybmFsIGFkZHJlc3MuXG4gICAgICAgICAqIEBzdW1tYXJ5IFJlcXVlc3QgZmF1Y2V0IGZ1bmRzIGZvciBleHRlcm5hbCBhZGRyZXNzLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29ya0lkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIG9uY2hhaW4gYWRkcmVzcyBvZiB0aGUgYWRkcmVzcyB0aGF0IGlzIGJlaW5nIGZldGNoZWQuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbYXNzZXRJZF0gVGhlIElEIG9mIHRoZSBhc3NldCB0byB0cmFuc2ZlciBmcm9tIHRoZSBmYXVjZXQuXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NraXBXYWl0XSBXaGV0aGVyIHRvIHNraXAgd2FpdGluZyBmb3IgdGhlIHRyYW5zYWN0aW9uIHRvIGJlIG1pbmVkLiBUaGlzIHdpbGwgYmVjb21lIHRoZSBkZWZhdWx0IGJlaGF2aW9yIGluIHRoZSBmdXR1cmUuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICByZXF1ZXN0RXh0ZXJuYWxGYXVjZXRGdW5kczogYXN5bmMgKG5ldHdvcmtJZCwgYWRkcmVzc0lkLCBhc3NldElkLCBza2lwV2FpdCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICduZXR3b3JrSWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgncmVxdWVzdEV4dGVybmFsRmF1Y2V0RnVuZHMnLCAnbmV0d29ya0lkJywgbmV0d29ya0lkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2FkZHJlc3NJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdyZXF1ZXN0RXh0ZXJuYWxGYXVjZXRGdW5kcycsICdhZGRyZXNzSWQnLCBhZGRyZXNzSWQpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS9uZXR3b3Jrcy97bmV0d29ya19pZH0vYWRkcmVzc2VzL3thZGRyZXNzX2lkfS9mYXVjZXRgXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wibmV0d29ya19pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKG5ldHdvcmtJZCkpKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcImFkZHJlc3NfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhhZGRyZXNzSWQpKSk7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IHsgbWV0aG9kOiAnUE9TVCcsIC4uLmJhc2VPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gYXBpS2V5IHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIkp3dFwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIHNlc3Npb24gcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgaWYgKGFzc2V0SWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ2Fzc2V0X2lkJ10gPSBhc3NldElkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNraXBXYWl0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydza2lwX3dhaXQnXSA9IHNraXBXYWl0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0geyAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlciwgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucywgLi4ub3B0aW9ucy5oZWFkZXJzIH07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5FeHRlcm5hbEFkZHJlc3Nlc0FwaUF4aW9zUGFyYW1DcmVhdG9yID0gRXh0ZXJuYWxBZGRyZXNzZXNBcGlBeGlvc1BhcmFtQ3JlYXRvcjtcbi8qKlxuICogRXh0ZXJuYWxBZGRyZXNzZXNBcGkgLSBmdW5jdGlvbmFsIHByb2dyYW1taW5nIGludGVyZmFjZVxuICogQGV4cG9ydFxuICovXG5jb25zdCBFeHRlcm5hbEFkZHJlc3Nlc0FwaUZwID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24pIHtcbiAgICBjb25zdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yID0gKDAsIGV4cG9ydHMuRXh0ZXJuYWxBZGRyZXNzZXNBcGlBeGlvc1BhcmFtQ3JlYXRvcikoY29uZmlndXJhdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJyb2FkY2FzdCBhbiBhcmJpdHJhcnkgdHJhbnNhY3Rpb24gdG8gdGhlIG5vZGUgY29uc3RydWN0ZWQgYW5kIHNpZ25lZCBieSBhbiBleHRlcm5hbCBhZGRyZXNzLlxuICAgICAgICAgKiBAc3VtbWFyeSBCcm9hZGNhc3QgYW4gYXJiaXRyYXJ5IHRyYW5zYWN0aW9uLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29ya0lkIFRoZSBJRCBvZiB0aGUgbmV0d29yayB0aGUgZXh0ZXJuYWwgYWRkcmVzcyBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBvbmNoYWluIGFkZHJlc3Mgb2YgdGhlIHRyYW5zYWN0aW9uIHNlbmRlci5cbiAgICAgICAgICogQHBhcmFtIHtCcm9hZGNhc3RFeHRlcm5hbFRyYW5zYWN0aW9uUmVxdWVzdH0gYnJvYWRjYXN0RXh0ZXJuYWxUcmFuc2FjdGlvblJlcXVlc3RcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGJyb2FkY2FzdEV4dGVybmFsVHJhbnNhY3Rpb24obmV0d29ya0lkLCBhZGRyZXNzSWQsIGJyb2FkY2FzdEV4dGVybmFsVHJhbnNhY3Rpb25SZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuYnJvYWRjYXN0RXh0ZXJuYWxUcmFuc2FjdGlvbihuZXR3b3JrSWQsIGFkZHJlc3NJZCwgYnJvYWRjYXN0RXh0ZXJuYWxUcmFuc2FjdGlvblJlcXVlc3QsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IGNvbmZpZ3VyYXRpb24/LnNlcnZlckluZGV4ID8/IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnRXh0ZXJuYWxBZGRyZXNzZXNBcGkuYnJvYWRjYXN0RXh0ZXJuYWxUcmFuc2FjdGlvbiddPy5bbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0/LnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCcm9hZGNhc3QgYW4gZXh0ZXJuYWwgYWRkcmVzc1xcJ3MgdHJhbnNmZXIgd2l0aCBhIHNpZ25lZCBwYXlsb2FkXG4gICAgICAgICAqIEBzdW1tYXJ5IEJyb2FkY2FzdCBhbiBleHRlcm5hbCBhZGRyZXNzXFwnIHRyYW5zZmVyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWQgVGhlIElEIG9mIHRoZSBuZXR3b3JrIHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG9cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdGhlIHRyYW5zZmVyIGJlbG9uZ3MgdG9cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHRyYW5zZmVySWQgVGhlIElEIG9mIHRoZSB0cmFuc2ZlciB0byBicm9hZGNhc3RcbiAgICAgICAgICogQHBhcmFtIHtCcm9hZGNhc3RFeHRlcm5hbFRyYW5zZmVyUmVxdWVzdH0gYnJvYWRjYXN0RXh0ZXJuYWxUcmFuc2ZlclJlcXVlc3RcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGJyb2FkY2FzdEV4dGVybmFsVHJhbnNmZXIobmV0d29ya0lkLCBhZGRyZXNzSWQsIHRyYW5zZmVySWQsIGJyb2FkY2FzdEV4dGVybmFsVHJhbnNmZXJSZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuYnJvYWRjYXN0RXh0ZXJuYWxUcmFuc2ZlcihuZXR3b3JrSWQsIGFkZHJlc3NJZCwgdHJhbnNmZXJJZCwgYnJvYWRjYXN0RXh0ZXJuYWxUcmFuc2ZlclJlcXVlc3QsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IGNvbmZpZ3VyYXRpb24/LnNlcnZlckluZGV4ID8/IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnRXh0ZXJuYWxBZGRyZXNzZXNBcGkuYnJvYWRjYXN0RXh0ZXJuYWxUcmFuc2ZlciddPy5bbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0/LnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSBuZXcgdHJhbnNmZXIgYmV0d2VlbiBhZGRyZXNzZXMuXG4gICAgICAgICAqIEBzdW1tYXJ5IENyZWF0ZSBhIG5ldyB0cmFuc2ZlclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29ya0lkIFRoZSBJRCBvZiB0aGUgbmV0d29yayB0aGUgYWRkcmVzcyBpcyBvblxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0byB0cmFuc2ZlciBmcm9tXG4gICAgICAgICAqIEBwYXJhbSB7Q3JlYXRlRXh0ZXJuYWxUcmFuc2ZlclJlcXVlc3R9IGNyZWF0ZUV4dGVybmFsVHJhbnNmZXJSZXF1ZXN0XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBjcmVhdGVFeHRlcm5hbFRyYW5zZmVyKG5ldHdvcmtJZCwgYWRkcmVzc0lkLCBjcmVhdGVFeHRlcm5hbFRyYW5zZmVyUmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmNyZWF0ZUV4dGVybmFsVHJhbnNmZXIobmV0d29ya0lkLCBhZGRyZXNzSWQsIGNyZWF0ZUV4dGVybmFsVHJhbnNmZXJSZXF1ZXN0LCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSBjb25maWd1cmF0aW9uPy5zZXJ2ZXJJbmRleCA/PyAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ0V4dGVybmFsQWRkcmVzc2VzQXBpLmNyZWF0ZUV4dGVybmFsVHJhbnNmZXInXT8uW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdPy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBiYWxhbmNlIG9mIGFuIGFzc2V0IGluIGFuIGV4dGVybmFsIGFkZHJlc3NcbiAgICAgICAgICogQHN1bW1hcnkgR2V0IHRoZSBiYWxhbmNlIG9mIGFuIGFzc2V0IGluIGFuIGV4dGVybmFsIGFkZHJlc3NcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5ldHdvcmtJZCBUaGUgSUQgb2YgdGhlIGJsb2NrY2hhaW4gbmV0d29ya1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0byBmZXRjaCB0aGUgYmFsYW5jZSBmb3JcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFzc2V0SWQgVGhlIElEIG9mIHRoZSBhc3NldCB0byBmZXRjaCB0aGUgYmFsYW5jZSBmb3JcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGdldEV4dGVybmFsQWRkcmVzc0JhbGFuY2UobmV0d29ya0lkLCBhZGRyZXNzSWQsIGFzc2V0SWQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5nZXRFeHRlcm5hbEFkZHJlc3NCYWxhbmNlKG5ldHdvcmtJZCwgYWRkcmVzc0lkLCBhc3NldElkLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSBjb25maWd1cmF0aW9uPy5zZXJ2ZXJJbmRleCA/PyAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ0V4dGVybmFsQWRkcmVzc2VzQXBpLmdldEV4dGVybmFsQWRkcmVzc0JhbGFuY2UnXT8uW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdPy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGFuIGV4dGVybmFsIGFkZHJlc3NcXCcgdHJhbnNmZXIgYnkgSURcbiAgICAgICAgICogQHN1bW1hcnkgR2V0IGEgZXh0ZXJuYWwgYWRkcmVzc1xcJyB0cmFuc2ZlclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29ya0lkIFRoZSBJRCBvZiB0aGUgbmV0d29yayB0aGUgYWRkcmVzcyBpcyBvblxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0aGUgdHJhbnNmZXIgYmVsb25ncyB0b1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHJhbnNmZXJJZCBUaGUgSUQgb2YgdGhlIHRyYW5zZmVyIHRvIGZldGNoXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBnZXRFeHRlcm5hbFRyYW5zZmVyKG5ldHdvcmtJZCwgYWRkcmVzc0lkLCB0cmFuc2ZlcklkLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuZ2V0RXh0ZXJuYWxUcmFuc2ZlcihuZXR3b3JrSWQsIGFkZHJlc3NJZCwgdHJhbnNmZXJJZCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gY29uZmlndXJhdGlvbj8uc2VydmVySW5kZXggPz8gMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydFeHRlcm5hbEFkZHJlc3Nlc0FwaS5nZXRFeHRlcm5hbFRyYW5zZmVyJ10/Lltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XT8udXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgc3RhdHVzIG9mIGEgZmF1Y2V0IHRyYW5zYWN0aW9uXG4gICAgICAgICAqIEBzdW1tYXJ5IEdldCB0aGUgc3RhdHVzIG9mIGEgZmF1Y2V0IHRyYW5zYWN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWQgVGhlIElEIG9mIHRoZSBibG9ja2NoYWluIG5ldHdvcmtcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdG8gZmV0Y2ggdGhlIGZhdWNldCB0cmFuc2FjdGlvbiBmb3JcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHR4SGFzaCBUaGUgaGFzaCBvZiB0aGUgZmF1Y2V0IHRyYW5zYWN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBnZXRGYXVjZXRUcmFuc2FjdGlvbihuZXR3b3JrSWQsIGFkZHJlc3NJZCwgdHhIYXNoLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuZ2V0RmF1Y2V0VHJhbnNhY3Rpb24obmV0d29ya0lkLCBhZGRyZXNzSWQsIHR4SGFzaCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gY29uZmlndXJhdGlvbj8uc2VydmVySW5kZXggPz8gMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydFeHRlcm5hbEFkZHJlc3Nlc0FwaS5nZXRGYXVjZXRUcmFuc2FjdGlvbiddPy5bbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0/LnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0IGFsbCBvZiB0aGUgYmFsYW5jZXMgb2YgYW4gZXh0ZXJuYWwgYWRkcmVzc1xuICAgICAgICAgKiBAc3VtbWFyeSBHZXQgdGhlIGJhbGFuY2VzIG9mIGFuIGV4dGVybmFsIGFkZHJlc3NcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5ldHdvcmtJZCBUaGUgSUQgb2YgdGhlIGJsb2NrY2hhaW4gbmV0d29ya1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0byBmZXRjaCB0aGUgYmFsYW5jZSBmb3JcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlXSBBIGN1cnNvciBmb3IgcGFnaW5hdGlvbiBhY3Jvc3MgbXVsdGlwbGUgcGFnZXMgb2YgcmVzdWx0cy4gRG9uXFwmIzM5O3QgaW5jbHVkZSB0aGlzIHBhcmFtZXRlciBvbiB0aGUgZmlyc3QgY2FsbC4gVXNlIHRoZSBuZXh0X3BhZ2UgdmFsdWUgcmV0dXJuZWQgaW4gYSBwcmV2aW91cyByZXNwb25zZSB0byByZXF1ZXN0IHN1YnNlcXVlbnQgcmVzdWx0cy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGxpc3RFeHRlcm5hbEFkZHJlc3NCYWxhbmNlcyhuZXR3b3JrSWQsIGFkZHJlc3NJZCwgcGFnZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmxpc3RFeHRlcm5hbEFkZHJlc3NCYWxhbmNlcyhuZXR3b3JrSWQsIGFkZHJlc3NJZCwgcGFnZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gY29uZmlndXJhdGlvbj8uc2VydmVySW5kZXggPz8gMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydFeHRlcm5hbEFkZHJlc3Nlc0FwaS5saXN0RXh0ZXJuYWxBZGRyZXNzQmFsYW5jZXMnXT8uW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdPy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogUmVxdWVzdCBmYXVjZXQgZnVuZHMgdG8gYmUgc2VudCB0byBleHRlcm5hbCBhZGRyZXNzLlxuICAgICAgICAgKiBAc3VtbWFyeSBSZXF1ZXN0IGZhdWNldCBmdW5kcyBmb3IgZXh0ZXJuYWwgYWRkcmVzcy5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5ldHdvcmtJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBvbmNoYWluIGFkZHJlc3Mgb2YgdGhlIGFkZHJlc3MgdGhhdCBpcyBiZWluZyBmZXRjaGVkLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2Fzc2V0SWRdIFRoZSBJRCBvZiB0aGUgYXNzZXQgdG8gdHJhbnNmZXIgZnJvbSB0aGUgZmF1Y2V0LlxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtza2lwV2FpdF0gV2hldGhlciB0byBza2lwIHdhaXRpbmcgZm9yIHRoZSB0cmFuc2FjdGlvbiB0byBiZSBtaW5lZC4gVGhpcyB3aWxsIGJlY29tZSB0aGUgZGVmYXVsdCBiZWhhdmlvciBpbiB0aGUgZnV0dXJlLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgcmVxdWVzdEV4dGVybmFsRmF1Y2V0RnVuZHMobmV0d29ya0lkLCBhZGRyZXNzSWQsIGFzc2V0SWQsIHNraXBXYWl0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IucmVxdWVzdEV4dGVybmFsRmF1Y2V0RnVuZHMobmV0d29ya0lkLCBhZGRyZXNzSWQsIGFzc2V0SWQsIHNraXBXYWl0LCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSBjb25maWd1cmF0aW9uPy5zZXJ2ZXJJbmRleCA/PyAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ0V4dGVybmFsQWRkcmVzc2VzQXBpLnJlcXVlc3RFeHRlcm5hbEZhdWNldEZ1bmRzJ10/Lltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XT8udXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuRXh0ZXJuYWxBZGRyZXNzZXNBcGlGcCA9IEV4dGVybmFsQWRkcmVzc2VzQXBpRnA7XG4vKipcbiAqIEV4dGVybmFsQWRkcmVzc2VzQXBpIC0gZmFjdG9yeSBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgRXh0ZXJuYWxBZGRyZXNzZXNBcGlGYWN0b3J5ID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24sIGJhc2VQYXRoLCBheGlvcykge1xuICAgIGNvbnN0IGxvY2FsVmFyRnAgPSAoMCwgZXhwb3J0cy5FeHRlcm5hbEFkZHJlc3Nlc0FwaUZwKShjb25maWd1cmF0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQnJvYWRjYXN0IGFuIGFyYml0cmFyeSB0cmFuc2FjdGlvbiB0byB0aGUgbm9kZSBjb25zdHJ1Y3RlZCBhbmQgc2lnbmVkIGJ5IGFuIGV4dGVybmFsIGFkZHJlc3MuXG4gICAgICAgICAqIEBzdW1tYXJ5IEJyb2FkY2FzdCBhbiBhcmJpdHJhcnkgdHJhbnNhY3Rpb24uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWQgVGhlIElEIG9mIHRoZSBuZXR3b3JrIHRoZSBleHRlcm5hbCBhZGRyZXNzIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIG9uY2hhaW4gYWRkcmVzcyBvZiB0aGUgdHJhbnNhY3Rpb24gc2VuZGVyLlxuICAgICAgICAgKiBAcGFyYW0ge0Jyb2FkY2FzdEV4dGVybmFsVHJhbnNhY3Rpb25SZXF1ZXN0fSBicm9hZGNhc3RFeHRlcm5hbFRyYW5zYWN0aW9uUmVxdWVzdFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYnJvYWRjYXN0RXh0ZXJuYWxUcmFuc2FjdGlvbihuZXR3b3JrSWQsIGFkZHJlc3NJZCwgYnJvYWRjYXN0RXh0ZXJuYWxUcmFuc2FjdGlvblJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmJyb2FkY2FzdEV4dGVybmFsVHJhbnNhY3Rpb24obmV0d29ya0lkLCBhZGRyZXNzSWQsIGJyb2FkY2FzdEV4dGVybmFsVHJhbnNhY3Rpb25SZXF1ZXN0LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQnJvYWRjYXN0IGFuIGV4dGVybmFsIGFkZHJlc3NcXCdzIHRyYW5zZmVyIHdpdGggYSBzaWduZWQgcGF5bG9hZFxuICAgICAgICAgKiBAc3VtbWFyeSBCcm9hZGNhc3QgYW4gZXh0ZXJuYWwgYWRkcmVzc1xcJyB0cmFuc2ZlclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29ya0lkIFRoZSBJRCBvZiB0aGUgbmV0d29yayB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRoZSB0cmFuc2ZlciBiZWxvbmdzIHRvXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0cmFuc2ZlcklkIFRoZSBJRCBvZiB0aGUgdHJhbnNmZXIgdG8gYnJvYWRjYXN0XG4gICAgICAgICAqIEBwYXJhbSB7QnJvYWRjYXN0RXh0ZXJuYWxUcmFuc2ZlclJlcXVlc3R9IGJyb2FkY2FzdEV4dGVybmFsVHJhbnNmZXJSZXF1ZXN0XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBicm9hZGNhc3RFeHRlcm5hbFRyYW5zZmVyKG5ldHdvcmtJZCwgYWRkcmVzc0lkLCB0cmFuc2ZlcklkLCBicm9hZGNhc3RFeHRlcm5hbFRyYW5zZmVyUmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuYnJvYWRjYXN0RXh0ZXJuYWxUcmFuc2ZlcihuZXR3b3JrSWQsIGFkZHJlc3NJZCwgdHJhbnNmZXJJZCwgYnJvYWRjYXN0RXh0ZXJuYWxUcmFuc2ZlclJlcXVlc3QsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSBuZXcgdHJhbnNmZXIgYmV0d2VlbiBhZGRyZXNzZXMuXG4gICAgICAgICAqIEBzdW1tYXJ5IENyZWF0ZSBhIG5ldyB0cmFuc2ZlclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29ya0lkIFRoZSBJRCBvZiB0aGUgbmV0d29yayB0aGUgYWRkcmVzcyBpcyBvblxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0byB0cmFuc2ZlciBmcm9tXG4gICAgICAgICAqIEBwYXJhbSB7Q3JlYXRlRXh0ZXJuYWxUcmFuc2ZlclJlcXVlc3R9IGNyZWF0ZUV4dGVybmFsVHJhbnNmZXJSZXF1ZXN0XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGVFeHRlcm5hbFRyYW5zZmVyKG5ldHdvcmtJZCwgYWRkcmVzc0lkLCBjcmVhdGVFeHRlcm5hbFRyYW5zZmVyUmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuY3JlYXRlRXh0ZXJuYWxUcmFuc2ZlcihuZXR3b3JrSWQsIGFkZHJlc3NJZCwgY3JlYXRlRXh0ZXJuYWxUcmFuc2ZlclJlcXVlc3QsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGJhbGFuY2Ugb2YgYW4gYXNzZXQgaW4gYW4gZXh0ZXJuYWwgYWRkcmVzc1xuICAgICAgICAgKiBAc3VtbWFyeSBHZXQgdGhlIGJhbGFuY2Ugb2YgYW4gYXNzZXQgaW4gYW4gZXh0ZXJuYWwgYWRkcmVzc1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29ya0lkIFRoZSBJRCBvZiB0aGUgYmxvY2tjaGFpbiBuZXR3b3JrXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRvIGZldGNoIHRoZSBiYWxhbmNlIGZvclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXNzZXRJZCBUaGUgSUQgb2YgdGhlIGFzc2V0IHRvIGZldGNoIHRoZSBiYWxhbmNlIGZvclxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0RXh0ZXJuYWxBZGRyZXNzQmFsYW5jZShuZXR3b3JrSWQsIGFkZHJlc3NJZCwgYXNzZXRJZCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuZ2V0RXh0ZXJuYWxBZGRyZXNzQmFsYW5jZShuZXR3b3JrSWQsIGFkZHJlc3NJZCwgYXNzZXRJZCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBhbiBleHRlcm5hbCBhZGRyZXNzXFwnIHRyYW5zZmVyIGJ5IElEXG4gICAgICAgICAqIEBzdW1tYXJ5IEdldCBhIGV4dGVybmFsIGFkZHJlc3NcXCcgdHJhbnNmZXJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5ldHdvcmtJZCBUaGUgSUQgb2YgdGhlIG5ldHdvcmsgdGhlIGFkZHJlc3MgaXMgb25cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdGhlIHRyYW5zZmVyIGJlbG9uZ3MgdG9cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHRyYW5zZmVySWQgVGhlIElEIG9mIHRoZSB0cmFuc2ZlciB0byBmZXRjaFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0RXh0ZXJuYWxUcmFuc2ZlcihuZXR3b3JrSWQsIGFkZHJlc3NJZCwgdHJhbnNmZXJJZCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuZ2V0RXh0ZXJuYWxUcmFuc2ZlcihuZXR3b3JrSWQsIGFkZHJlc3NJZCwgdHJhbnNmZXJJZCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgc3RhdHVzIG9mIGEgZmF1Y2V0IHRyYW5zYWN0aW9uXG4gICAgICAgICAqIEBzdW1tYXJ5IEdldCB0aGUgc3RhdHVzIG9mIGEgZmF1Y2V0IHRyYW5zYWN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWQgVGhlIElEIG9mIHRoZSBibG9ja2NoYWluIG5ldHdvcmtcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdG8gZmV0Y2ggdGhlIGZhdWNldCB0cmFuc2FjdGlvbiBmb3JcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHR4SGFzaCBUaGUgaGFzaCBvZiB0aGUgZmF1Y2V0IHRyYW5zYWN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRGYXVjZXRUcmFuc2FjdGlvbihuZXR3b3JrSWQsIGFkZHJlc3NJZCwgdHhIYXNoLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5nZXRGYXVjZXRUcmFuc2FjdGlvbihuZXR3b3JrSWQsIGFkZHJlc3NJZCwgdHhIYXNoLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdCBhbGwgb2YgdGhlIGJhbGFuY2VzIG9mIGFuIGV4dGVybmFsIGFkZHJlc3NcbiAgICAgICAgICogQHN1bW1hcnkgR2V0IHRoZSBiYWxhbmNlcyBvZiBhbiBleHRlcm5hbCBhZGRyZXNzXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWQgVGhlIElEIG9mIHRoZSBibG9ja2NoYWluIG5ldHdvcmtcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdG8gZmV0Y2ggdGhlIGJhbGFuY2UgZm9yXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZV0gQSBjdXJzb3IgZm9yIHBhZ2luYXRpb24gYWNyb3NzIG11bHRpcGxlIHBhZ2VzIG9mIHJlc3VsdHMuIERvblxcJiMzOTt0IGluY2x1ZGUgdGhpcyBwYXJhbWV0ZXIgb24gdGhlIGZpcnN0IGNhbGwuIFVzZSB0aGUgbmV4dF9wYWdlIHZhbHVlIHJldHVybmVkIGluIGEgcHJldmlvdXMgcmVzcG9uc2UgdG8gcmVxdWVzdCBzdWJzZXF1ZW50IHJlc3VsdHMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBsaXN0RXh0ZXJuYWxBZGRyZXNzQmFsYW5jZXMobmV0d29ya0lkLCBhZGRyZXNzSWQsIHBhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmxpc3RFeHRlcm5hbEFkZHJlc3NCYWxhbmNlcyhuZXR3b3JrSWQsIGFkZHJlc3NJZCwgcGFnZSwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlcXVlc3QgZmF1Y2V0IGZ1bmRzIHRvIGJlIHNlbnQgdG8gZXh0ZXJuYWwgYWRkcmVzcy5cbiAgICAgICAgICogQHN1bW1hcnkgUmVxdWVzdCBmYXVjZXQgZnVuZHMgZm9yIGV4dGVybmFsIGFkZHJlc3MuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0by5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgb25jaGFpbiBhZGRyZXNzIG9mIHRoZSBhZGRyZXNzIHRoYXQgaXMgYmVpbmcgZmV0Y2hlZC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFthc3NldElkXSBUaGUgSUQgb2YgdGhlIGFzc2V0IHRvIHRyYW5zZmVyIGZyb20gdGhlIGZhdWNldC5cbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbc2tpcFdhaXRdIFdoZXRoZXIgdG8gc2tpcCB3YWl0aW5nIGZvciB0aGUgdHJhbnNhY3Rpb24gdG8gYmUgbWluZWQuIFRoaXMgd2lsbCBiZWNvbWUgdGhlIGRlZmF1bHQgYmVoYXZpb3IgaW4gdGhlIGZ1dHVyZS5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIHJlcXVlc3RFeHRlcm5hbEZhdWNldEZ1bmRzKG5ldHdvcmtJZCwgYWRkcmVzc0lkLCBhc3NldElkLCBza2lwV2FpdCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAucmVxdWVzdEV4dGVybmFsRmF1Y2V0RnVuZHMobmV0d29ya0lkLCBhZGRyZXNzSWQsIGFzc2V0SWQsIHNraXBXYWl0LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5FeHRlcm5hbEFkZHJlc3Nlc0FwaUZhY3RvcnkgPSBFeHRlcm5hbEFkZHJlc3Nlc0FwaUZhY3Rvcnk7XG4vKipcbiAqIEV4dGVybmFsQWRkcmVzc2VzQXBpIC0gb2JqZWN0LW9yaWVudGVkIGludGVyZmFjZVxuICogQGV4cG9ydFxuICogQGNsYXNzIEV4dGVybmFsQWRkcmVzc2VzQXBpXG4gKiBAZXh0ZW5kcyB7QmFzZUFQSX1cbiAqL1xuY2xhc3MgRXh0ZXJuYWxBZGRyZXNzZXNBcGkgZXh0ZW5kcyBiYXNlXzEuQmFzZUFQSSB7XG4gICAgLyoqXG4gICAgICogQnJvYWRjYXN0IGFuIGFyYml0cmFyeSB0cmFuc2FjdGlvbiB0byB0aGUgbm9kZSBjb25zdHJ1Y3RlZCBhbmQgc2lnbmVkIGJ5IGFuIGV4dGVybmFsIGFkZHJlc3MuXG4gICAgICogQHN1bW1hcnkgQnJvYWRjYXN0IGFuIGFyYml0cmFyeSB0cmFuc2FjdGlvbi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29ya0lkIFRoZSBJRCBvZiB0aGUgbmV0d29yayB0aGUgZXh0ZXJuYWwgYWRkcmVzcyBiZWxvbmdzIHRvLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIG9uY2hhaW4gYWRkcmVzcyBvZiB0aGUgdHJhbnNhY3Rpb24gc2VuZGVyLlxuICAgICAqIEBwYXJhbSB7QnJvYWRjYXN0RXh0ZXJuYWxUcmFuc2FjdGlvblJlcXVlc3R9IGJyb2FkY2FzdEV4dGVybmFsVHJhbnNhY3Rpb25SZXF1ZXN0XG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBFeHRlcm5hbEFkZHJlc3Nlc0FwaVxuICAgICAqL1xuICAgIGJyb2FkY2FzdEV4dGVybmFsVHJhbnNhY3Rpb24obmV0d29ya0lkLCBhZGRyZXNzSWQsIGJyb2FkY2FzdEV4dGVybmFsVHJhbnNhY3Rpb25SZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5FeHRlcm5hbEFkZHJlc3Nlc0FwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLmJyb2FkY2FzdEV4dGVybmFsVHJhbnNhY3Rpb24obmV0d29ya0lkLCBhZGRyZXNzSWQsIGJyb2FkY2FzdEV4dGVybmFsVHJhbnNhY3Rpb25SZXF1ZXN0LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQnJvYWRjYXN0IGFuIGV4dGVybmFsIGFkZHJlc3NcXCdzIHRyYW5zZmVyIHdpdGggYSBzaWduZWQgcGF5bG9hZFxuICAgICAqIEBzdW1tYXJ5IEJyb2FkY2FzdCBhbiBleHRlcm5hbCBhZGRyZXNzXFwnIHRyYW5zZmVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5ldHdvcmtJZCBUaGUgSUQgb2YgdGhlIG5ldHdvcmsgdGhlIGFkZHJlc3MgYmVsb25ncyB0b1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRoZSB0cmFuc2ZlciBiZWxvbmdzIHRvXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRyYW5zZmVySWQgVGhlIElEIG9mIHRoZSB0cmFuc2ZlciB0byBicm9hZGNhc3RcbiAgICAgKiBAcGFyYW0ge0Jyb2FkY2FzdEV4dGVybmFsVHJhbnNmZXJSZXF1ZXN0fSBicm9hZGNhc3RFeHRlcm5hbFRyYW5zZmVyUmVxdWVzdFxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgRXh0ZXJuYWxBZGRyZXNzZXNBcGlcbiAgICAgKi9cbiAgICBicm9hZGNhc3RFeHRlcm5hbFRyYW5zZmVyKG5ldHdvcmtJZCwgYWRkcmVzc0lkLCB0cmFuc2ZlcklkLCBicm9hZGNhc3RFeHRlcm5hbFRyYW5zZmVyUmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuRXh0ZXJuYWxBZGRyZXNzZXNBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5icm9hZGNhc3RFeHRlcm5hbFRyYW5zZmVyKG5ldHdvcmtJZCwgYWRkcmVzc0lkLCB0cmFuc2ZlcklkLCBicm9hZGNhc3RFeHRlcm5hbFRyYW5zZmVyUmVxdWVzdCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyB0cmFuc2ZlciBiZXR3ZWVuIGFkZHJlc3Nlcy5cbiAgICAgKiBAc3VtbWFyeSBDcmVhdGUgYSBuZXcgdHJhbnNmZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29ya0lkIFRoZSBJRCBvZiB0aGUgbmV0d29yayB0aGUgYWRkcmVzcyBpcyBvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRvIHRyYW5zZmVyIGZyb21cbiAgICAgKiBAcGFyYW0ge0NyZWF0ZUV4dGVybmFsVHJhbnNmZXJSZXF1ZXN0fSBjcmVhdGVFeHRlcm5hbFRyYW5zZmVyUmVxdWVzdFxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgRXh0ZXJuYWxBZGRyZXNzZXNBcGlcbiAgICAgKi9cbiAgICBjcmVhdGVFeHRlcm5hbFRyYW5zZmVyKG5ldHdvcmtJZCwgYWRkcmVzc0lkLCBjcmVhdGVFeHRlcm5hbFRyYW5zZmVyUmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuRXh0ZXJuYWxBZGRyZXNzZXNBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5jcmVhdGVFeHRlcm5hbFRyYW5zZmVyKG5ldHdvcmtJZCwgYWRkcmVzc0lkLCBjcmVhdGVFeHRlcm5hbFRyYW5zZmVyUmVxdWVzdCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgYmFsYW5jZSBvZiBhbiBhc3NldCBpbiBhbiBleHRlcm5hbCBhZGRyZXNzXG4gICAgICogQHN1bW1hcnkgR2V0IHRoZSBiYWxhbmNlIG9mIGFuIGFzc2V0IGluIGFuIGV4dGVybmFsIGFkZHJlc3NcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29ya0lkIFRoZSBJRCBvZiB0aGUgYmxvY2tjaGFpbiBuZXR3b3JrXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdG8gZmV0Y2ggdGhlIGJhbGFuY2UgZm9yXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFzc2V0SWQgVGhlIElEIG9mIHRoZSBhc3NldCB0byBmZXRjaCB0aGUgYmFsYW5jZSBmb3JcbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIEV4dGVybmFsQWRkcmVzc2VzQXBpXG4gICAgICovXG4gICAgZ2V0RXh0ZXJuYWxBZGRyZXNzQmFsYW5jZShuZXR3b3JrSWQsIGFkZHJlc3NJZCwgYXNzZXRJZCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuRXh0ZXJuYWxBZGRyZXNzZXNBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5nZXRFeHRlcm5hbEFkZHJlc3NCYWxhbmNlKG5ldHdvcmtJZCwgYWRkcmVzc0lkLCBhc3NldElkLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGFuIGV4dGVybmFsIGFkZHJlc3NcXCcgdHJhbnNmZXIgYnkgSURcbiAgICAgKiBAc3VtbWFyeSBHZXQgYSBleHRlcm5hbCBhZGRyZXNzXFwnIHRyYW5zZmVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5ldHdvcmtJZCBUaGUgSUQgb2YgdGhlIG5ldHdvcmsgdGhlIGFkZHJlc3MgaXMgb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0aGUgdHJhbnNmZXIgYmVsb25ncyB0b1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0cmFuc2ZlcklkIFRoZSBJRCBvZiB0aGUgdHJhbnNmZXIgdG8gZmV0Y2hcbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIEV4dGVybmFsQWRkcmVzc2VzQXBpXG4gICAgICovXG4gICAgZ2V0RXh0ZXJuYWxUcmFuc2ZlcihuZXR3b3JrSWQsIGFkZHJlc3NJZCwgdHJhbnNmZXJJZCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuRXh0ZXJuYWxBZGRyZXNzZXNBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5nZXRFeHRlcm5hbFRyYW5zZmVyKG5ldHdvcmtJZCwgYWRkcmVzc0lkLCB0cmFuc2ZlcklkLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBzdGF0dXMgb2YgYSBmYXVjZXQgdHJhbnNhY3Rpb25cbiAgICAgKiBAc3VtbWFyeSBHZXQgdGhlIHN0YXR1cyBvZiBhIGZhdWNldCB0cmFuc2FjdGlvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWQgVGhlIElEIG9mIHRoZSBibG9ja2NoYWluIG5ldHdvcmtcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0byBmZXRjaCB0aGUgZmF1Y2V0IHRyYW5zYWN0aW9uIGZvclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eEhhc2ggVGhlIGhhc2ggb2YgdGhlIGZhdWNldCB0cmFuc2FjdGlvblxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgRXh0ZXJuYWxBZGRyZXNzZXNBcGlcbiAgICAgKi9cbiAgICBnZXRGYXVjZXRUcmFuc2FjdGlvbihuZXR3b3JrSWQsIGFkZHJlc3NJZCwgdHhIYXNoLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5FeHRlcm5hbEFkZHJlc3Nlc0FwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLmdldEZhdWNldFRyYW5zYWN0aW9uKG5ldHdvcmtJZCwgYWRkcmVzc0lkLCB0eEhhc2gsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0IGFsbCBvZiB0aGUgYmFsYW5jZXMgb2YgYW4gZXh0ZXJuYWwgYWRkcmVzc1xuICAgICAqIEBzdW1tYXJ5IEdldCB0aGUgYmFsYW5jZXMgb2YgYW4gZXh0ZXJuYWwgYWRkcmVzc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWQgVGhlIElEIG9mIHRoZSBibG9ja2NoYWluIG5ldHdvcmtcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0byBmZXRjaCB0aGUgYmFsYW5jZSBmb3JcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VdIEEgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiByZXN1bHRzLiBEb25cXCYjMzk7dCBpbmNsdWRlIHRoaXMgcGFyYW1ldGVyIG9uIHRoZSBmaXJzdCBjYWxsLiBVc2UgdGhlIG5leHRfcGFnZSB2YWx1ZSByZXR1cm5lZCBpbiBhIHByZXZpb3VzIHJlc3BvbnNlIHRvIHJlcXVlc3Qgc3Vic2VxdWVudCByZXN1bHRzLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgRXh0ZXJuYWxBZGRyZXNzZXNBcGlcbiAgICAgKi9cbiAgICBsaXN0RXh0ZXJuYWxBZGRyZXNzQmFsYW5jZXMobmV0d29ya0lkLCBhZGRyZXNzSWQsIHBhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLkV4dGVybmFsQWRkcmVzc2VzQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikubGlzdEV4dGVybmFsQWRkcmVzc0JhbGFuY2VzKG5ldHdvcmtJZCwgYWRkcmVzc0lkLCBwYWdlLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVxdWVzdCBmYXVjZXQgZnVuZHMgdG8gYmUgc2VudCB0byBleHRlcm5hbCBhZGRyZXNzLlxuICAgICAqIEBzdW1tYXJ5IFJlcXVlc3QgZmF1Y2V0IGZ1bmRzIGZvciBleHRlcm5hbCBhZGRyZXNzLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0by5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBvbmNoYWluIGFkZHJlc3Mgb2YgdGhlIGFkZHJlc3MgdGhhdCBpcyBiZWluZyBmZXRjaGVkLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbYXNzZXRJZF0gVGhlIElEIG9mIHRoZSBhc3NldCB0byB0cmFuc2ZlciBmcm9tIHRoZSBmYXVjZXQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbc2tpcFdhaXRdIFdoZXRoZXIgdG8gc2tpcCB3YWl0aW5nIGZvciB0aGUgdHJhbnNhY3Rpb24gdG8gYmUgbWluZWQuIFRoaXMgd2lsbCBiZWNvbWUgdGhlIGRlZmF1bHQgYmVoYXZpb3IgaW4gdGhlIGZ1dHVyZS5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIEV4dGVybmFsQWRkcmVzc2VzQXBpXG4gICAgICovXG4gICAgcmVxdWVzdEV4dGVybmFsRmF1Y2V0RnVuZHMobmV0d29ya0lkLCBhZGRyZXNzSWQsIGFzc2V0SWQsIHNraXBXYWl0LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5FeHRlcm5hbEFkZHJlc3Nlc0FwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLnJlcXVlc3RFeHRlcm5hbEZhdWNldEZ1bmRzKG5ldHdvcmtJZCwgYWRkcmVzc0lkLCBhc3NldElkLCBza2lwV2FpdCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxufVxuZXhwb3J0cy5FeHRlcm5hbEFkZHJlc3Nlc0FwaSA9IEV4dGVybmFsQWRkcmVzc2VzQXBpO1xuLyoqXG4gKiBGdW5kQXBpIC0gYXhpb3MgcGFyYW1ldGVyIGNyZWF0b3JcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgRnVuZEFwaUF4aW9zUGFyYW1DcmVhdG9yID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgbmV3IGZ1bmQgb3BlcmF0aW9uIHdpdGggYW4gYWRkcmVzcy5cbiAgICAgICAgICogQHN1bW1hcnkgQ3JlYXRlIGEgbmV3IGZ1bmQgb3BlcmF0aW9uLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0by5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgb25jaGFpbiBhZGRyZXNzIHRvIGJlIGZ1bmRlZC5cbiAgICAgICAgICogQHBhcmFtIHtDcmVhdGVGdW5kT3BlcmF0aW9uUmVxdWVzdH0gY3JlYXRlRnVuZE9wZXJhdGlvblJlcXVlc3RcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZUZ1bmRPcGVyYXRpb246IGFzeW5jICh3YWxsZXRJZCwgYWRkcmVzc0lkLCBjcmVhdGVGdW5kT3BlcmF0aW9uUmVxdWVzdCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICd3YWxsZXRJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdjcmVhdGVGdW5kT3BlcmF0aW9uJywgJ3dhbGxldElkJywgd2FsbGV0SWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnYWRkcmVzc0lkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2NyZWF0ZUZ1bmRPcGVyYXRpb24nLCAnYWRkcmVzc0lkJywgYWRkcmVzc0lkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2NyZWF0ZUZ1bmRPcGVyYXRpb25SZXF1ZXN0JyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2NyZWF0ZUZ1bmRPcGVyYXRpb24nLCAnY3JlYXRlRnVuZE9wZXJhdGlvblJlcXVlc3QnLCBjcmVhdGVGdW5kT3BlcmF0aW9uUmVxdWVzdCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL3dhbGxldHMve3dhbGxldF9pZH0vYWRkcmVzc2VzL3thZGRyZXNzX2lkfS9mdW5kX29wZXJhdGlvbnNgXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wid2FsbGV0X2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcod2FsbGV0SWQpKSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJhZGRyZXNzX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoYWRkcmVzc0lkKSkpO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7IG1ldGhvZDogJ1BPU1QnLCAuLi5iYXNlT3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIGFwaUtleSByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJKd3RcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBsb2NhbFZhckhlYWRlclBhcmFtZXRlclsnQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSB7IC4uLmxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCAuLi5oZWFkZXJzRnJvbUJhc2VPcHRpb25zLCAuLi5vcHRpb25zLmhlYWRlcnMgfTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuZGF0YSA9ICgwLCBjb21tb25fMS5zZXJpYWxpemVEYXRhSWZOZWVkZWQpKGNyZWF0ZUZ1bmRPcGVyYXRpb25SZXF1ZXN0LCBsb2NhbFZhclJlcXVlc3RPcHRpb25zLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSBuZXcgZnVuZCBvcGVyYXRpb24gd2l0aCBhbiBhZGRyZXNzLlxuICAgICAgICAgKiBAc3VtbWFyeSBDcmVhdGUgYSBGdW5kIE9wZXJhdGlvbiBxdW90ZS5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIG9uY2hhaW4gYWRkcmVzcyB0byBiZSBmdW5kZWQuXG4gICAgICAgICAqIEBwYXJhbSB7Q3JlYXRlRnVuZFF1b3RlUmVxdWVzdH0gY3JlYXRlRnVuZFF1b3RlUmVxdWVzdFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgY3JlYXRlRnVuZFF1b3RlOiBhc3luYyAod2FsbGV0SWQsIGFkZHJlc3NJZCwgY3JlYXRlRnVuZFF1b3RlUmVxdWVzdCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICd3YWxsZXRJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdjcmVhdGVGdW5kUXVvdGUnLCAnd2FsbGV0SWQnLCB3YWxsZXRJZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdhZGRyZXNzSWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnY3JlYXRlRnVuZFF1b3RlJywgJ2FkZHJlc3NJZCcsIGFkZHJlc3NJZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdjcmVhdGVGdW5kUXVvdGVSZXF1ZXN0JyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2NyZWF0ZUZ1bmRRdW90ZScsICdjcmVhdGVGdW5kUXVvdGVSZXF1ZXN0JywgY3JlYXRlRnVuZFF1b3RlUmVxdWVzdCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL3dhbGxldHMve3dhbGxldF9pZH0vYWRkcmVzc2VzL3thZGRyZXNzX2lkfS9mdW5kX29wZXJhdGlvbnMvcXVvdGVgXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wid2FsbGV0X2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcod2FsbGV0SWQpKSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJhZGRyZXNzX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoYWRkcmVzc0lkKSkpO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7IG1ldGhvZDogJ1BPU1QnLCAuLi5iYXNlT3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIGFwaUtleSByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJKd3RcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBsb2NhbFZhckhlYWRlclBhcmFtZXRlclsnQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSB7IC4uLmxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCAuLi5oZWFkZXJzRnJvbUJhc2VPcHRpb25zLCAuLi5vcHRpb25zLmhlYWRlcnMgfTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuZGF0YSA9ICgwLCBjb21tb25fMS5zZXJpYWxpemVEYXRhSWZOZWVkZWQpKGNyZWF0ZUZ1bmRRdW90ZVJlcXVlc3QsIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBmdW5kIG9wZXJhdGlvbi5cbiAgICAgICAgICogQHN1bW1hcnkgR2V0IGZ1bmQgb3BlcmF0aW9uLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0by5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgb25jaGFpbiBhZGRyZXNzIG9mIHRoZSBhZGRyZXNzIHRoYXQgY3JlYXRlZCB0aGUgZnVuZCBvcGVyYXRpb24uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmdW5kT3BlcmF0aW9uSWQgVGhlIElEIG9mIHRoZSBmdW5kIG9wZXJhdGlvbiB0byBmZXRjaC5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGdldEZ1bmRPcGVyYXRpb246IGFzeW5jICh3YWxsZXRJZCwgYWRkcmVzc0lkLCBmdW5kT3BlcmF0aW9uSWQsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnd2FsbGV0SWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZ2V0RnVuZE9wZXJhdGlvbicsICd3YWxsZXRJZCcsIHdhbGxldElkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2FkZHJlc3NJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdnZXRGdW5kT3BlcmF0aW9uJywgJ2FkZHJlc3NJZCcsIGFkZHJlc3NJZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdmdW5kT3BlcmF0aW9uSWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZ2V0RnVuZE9wZXJhdGlvbicsICdmdW5kT3BlcmF0aW9uSWQnLCBmdW5kT3BlcmF0aW9uSWQpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS93YWxsZXRzL3t3YWxsZXRfaWR9L2FkZHJlc3Nlcy97YWRkcmVzc19pZH0vZnVuZF9vcGVyYXRpb25zL3tmdW5kX29wZXJhdGlvbl9pZH1gXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wid2FsbGV0X2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcod2FsbGV0SWQpKSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJhZGRyZXNzX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoYWRkcmVzc0lkKSkpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wiZnVuZF9vcGVyYXRpb25faWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhmdW5kT3BlcmF0aW9uSWQpKSk7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IHsgbWV0aG9kOiAnR0VUJywgLi4uYmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBhcGlLZXkgcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gc2Vzc2lvbiByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJKd3RcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSB7IC4uLmxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCAuLi5oZWFkZXJzRnJvbUJhc2VPcHRpb25zLCAuLi5vcHRpb25zLmhlYWRlcnMgfTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0IGZ1bmQgb3BlcmF0aW9ucyBmb3IgYW4gYWRkcmVzcy5cbiAgICAgICAgICogQHN1bW1hcnkgTGlzdCBmdW5kIG9wZXJhdGlvbnMgZm9yIGFuIGFkZHJlc3MuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBvbmNoYWluIGFkZHJlc3Mgb2YgdGhlIGFkZHJlc3MgdG8gbGlzdCBmdW5kIG9wZXJhdGlvbnMgZm9yLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBBIGxpbWl0IG9uIHRoZSBudW1iZXIgb2Ygb2JqZWN0cyB0byBiZSByZXR1cm5lZC4gTGltaXQgY2FuIHJhbmdlIGJldHdlZW4gMSBhbmQgMTAwLCBhbmQgdGhlIGRlZmF1bHQgaXMgMTAuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZV0gQSBjdXJzb3IgZm9yIHBhZ2luYXRpb24gYWNyb3NzIG11bHRpcGxlIHBhZ2VzIG9mIHJlc3VsdHMuIERvblxcJiMzOTt0IGluY2x1ZGUgdGhpcyBwYXJhbWV0ZXIgb24gdGhlIGZpcnN0IGNhbGwuIFVzZSB0aGUgbmV4dF9wYWdlIHZhbHVlIHJldHVybmVkIGluIGEgcHJldmlvdXMgcmVzcG9uc2UgdG8gcmVxdWVzdCBzdWJzZXF1ZW50IHJlc3VsdHMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBsaXN0RnVuZE9wZXJhdGlvbnM6IGFzeW5jICh3YWxsZXRJZCwgYWRkcmVzc0lkLCBsaW1pdCwgcGFnZSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICd3YWxsZXRJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdsaXN0RnVuZE9wZXJhdGlvbnMnLCAnd2FsbGV0SWQnLCB3YWxsZXRJZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdhZGRyZXNzSWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnbGlzdEZ1bmRPcGVyYXRpb25zJywgJ2FkZHJlc3NJZCcsIGFkZHJlc3NJZCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL3dhbGxldHMve3dhbGxldF9pZH0vYWRkcmVzc2VzL3thZGRyZXNzX2lkfS9mdW5kX29wZXJhdGlvbnNgXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wid2FsbGV0X2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcod2FsbGV0SWQpKSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJhZGRyZXNzX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoYWRkcmVzc0lkKSkpO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7IG1ldGhvZDogJ0dFVCcsIC4uLmJhc2VPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gYXBpS2V5IHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIkp3dFwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIHNlc3Npb24gcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgaWYgKGxpbWl0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydsaW1pdCddID0gbGltaXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsncGFnZSddID0gcGFnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IHsgLi4ubG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIC4uLmhlYWRlcnNGcm9tQmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMuaGVhZGVycyB9O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuRnVuZEFwaUF4aW9zUGFyYW1DcmVhdG9yID0gRnVuZEFwaUF4aW9zUGFyYW1DcmVhdG9yO1xuLyoqXG4gKiBGdW5kQXBpIC0gZnVuY3Rpb25hbCBwcm9ncmFtbWluZyBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgRnVuZEFwaUZwID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24pIHtcbiAgICBjb25zdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yID0gKDAsIGV4cG9ydHMuRnVuZEFwaUF4aW9zUGFyYW1DcmVhdG9yKShjb25maWd1cmF0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgbmV3IGZ1bmQgb3BlcmF0aW9uIHdpdGggYW4gYWRkcmVzcy5cbiAgICAgICAgICogQHN1bW1hcnkgQ3JlYXRlIGEgbmV3IGZ1bmQgb3BlcmF0aW9uLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0by5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgb25jaGFpbiBhZGRyZXNzIHRvIGJlIGZ1bmRlZC5cbiAgICAgICAgICogQHBhcmFtIHtDcmVhdGVGdW5kT3BlcmF0aW9uUmVxdWVzdH0gY3JlYXRlRnVuZE9wZXJhdGlvblJlcXVlc3RcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGNyZWF0ZUZ1bmRPcGVyYXRpb24od2FsbGV0SWQsIGFkZHJlc3NJZCwgY3JlYXRlRnVuZE9wZXJhdGlvblJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5jcmVhdGVGdW5kT3BlcmF0aW9uKHdhbGxldElkLCBhZGRyZXNzSWQsIGNyZWF0ZUZ1bmRPcGVyYXRpb25SZXF1ZXN0LCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSBjb25maWd1cmF0aW9uPy5zZXJ2ZXJJbmRleCA/PyAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ0Z1bmRBcGkuY3JlYXRlRnVuZE9wZXJhdGlvbiddPy5bbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0/LnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSBuZXcgZnVuZCBvcGVyYXRpb24gd2l0aCBhbiBhZGRyZXNzLlxuICAgICAgICAgKiBAc3VtbWFyeSBDcmVhdGUgYSBGdW5kIE9wZXJhdGlvbiBxdW90ZS5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIG9uY2hhaW4gYWRkcmVzcyB0byBiZSBmdW5kZWQuXG4gICAgICAgICAqIEBwYXJhbSB7Q3JlYXRlRnVuZFF1b3RlUmVxdWVzdH0gY3JlYXRlRnVuZFF1b3RlUmVxdWVzdFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgY3JlYXRlRnVuZFF1b3RlKHdhbGxldElkLCBhZGRyZXNzSWQsIGNyZWF0ZUZ1bmRRdW90ZVJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5jcmVhdGVGdW5kUXVvdGUod2FsbGV0SWQsIGFkZHJlc3NJZCwgY3JlYXRlRnVuZFF1b3RlUmVxdWVzdCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gY29uZmlndXJhdGlvbj8uc2VydmVySW5kZXggPz8gMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydGdW5kQXBpLmNyZWF0ZUZ1bmRRdW90ZSddPy5bbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0/LnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgZnVuZCBvcGVyYXRpb24uXG4gICAgICAgICAqIEBzdW1tYXJ5IEdldCBmdW5kIG9wZXJhdGlvbi5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIG9uY2hhaW4gYWRkcmVzcyBvZiB0aGUgYWRkcmVzcyB0aGF0IGNyZWF0ZWQgdGhlIGZ1bmQgb3BlcmF0aW9uLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZnVuZE9wZXJhdGlvbklkIFRoZSBJRCBvZiB0aGUgZnVuZCBvcGVyYXRpb24gdG8gZmV0Y2guXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBnZXRGdW5kT3BlcmF0aW9uKHdhbGxldElkLCBhZGRyZXNzSWQsIGZ1bmRPcGVyYXRpb25JZCwgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmdldEZ1bmRPcGVyYXRpb24od2FsbGV0SWQsIGFkZHJlc3NJZCwgZnVuZE9wZXJhdGlvbklkLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSBjb25maWd1cmF0aW9uPy5zZXJ2ZXJJbmRleCA/PyAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ0Z1bmRBcGkuZ2V0RnVuZE9wZXJhdGlvbiddPy5bbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0/LnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0IGZ1bmQgb3BlcmF0aW9ucyBmb3IgYW4gYWRkcmVzcy5cbiAgICAgICAgICogQHN1bW1hcnkgTGlzdCBmdW5kIG9wZXJhdGlvbnMgZm9yIGFuIGFkZHJlc3MuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBvbmNoYWluIGFkZHJlc3Mgb2YgdGhlIGFkZHJlc3MgdG8gbGlzdCBmdW5kIG9wZXJhdGlvbnMgZm9yLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBBIGxpbWl0IG9uIHRoZSBudW1iZXIgb2Ygb2JqZWN0cyB0byBiZSByZXR1cm5lZC4gTGltaXQgY2FuIHJhbmdlIGJldHdlZW4gMSBhbmQgMTAwLCBhbmQgdGhlIGRlZmF1bHQgaXMgMTAuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZV0gQSBjdXJzb3IgZm9yIHBhZ2luYXRpb24gYWNyb3NzIG11bHRpcGxlIHBhZ2VzIG9mIHJlc3VsdHMuIERvblxcJiMzOTt0IGluY2x1ZGUgdGhpcyBwYXJhbWV0ZXIgb24gdGhlIGZpcnN0IGNhbGwuIFVzZSB0aGUgbmV4dF9wYWdlIHZhbHVlIHJldHVybmVkIGluIGEgcHJldmlvdXMgcmVzcG9uc2UgdG8gcmVxdWVzdCBzdWJzZXF1ZW50IHJlc3VsdHMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBsaXN0RnVuZE9wZXJhdGlvbnMod2FsbGV0SWQsIGFkZHJlc3NJZCwgbGltaXQsIHBhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5saXN0RnVuZE9wZXJhdGlvbnMod2FsbGV0SWQsIGFkZHJlc3NJZCwgbGltaXQsIHBhZ2UsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IGNvbmZpZ3VyYXRpb24/LnNlcnZlckluZGV4ID8/IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnRnVuZEFwaS5saXN0RnVuZE9wZXJhdGlvbnMnXT8uW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdPy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5GdW5kQXBpRnAgPSBGdW5kQXBpRnA7XG4vKipcbiAqIEZ1bmRBcGkgLSBmYWN0b3J5IGludGVyZmFjZVxuICogQGV4cG9ydFxuICovXG5jb25zdCBGdW5kQXBpRmFjdG9yeSA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uLCBiYXNlUGF0aCwgYXhpb3MpIHtcbiAgICBjb25zdCBsb2NhbFZhckZwID0gKDAsIGV4cG9ydHMuRnVuZEFwaUZwKShjb25maWd1cmF0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgbmV3IGZ1bmQgb3BlcmF0aW9uIHdpdGggYW4gYWRkcmVzcy5cbiAgICAgICAgICogQHN1bW1hcnkgQ3JlYXRlIGEgbmV3IGZ1bmQgb3BlcmF0aW9uLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0by5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgb25jaGFpbiBhZGRyZXNzIHRvIGJlIGZ1bmRlZC5cbiAgICAgICAgICogQHBhcmFtIHtDcmVhdGVGdW5kT3BlcmF0aW9uUmVxdWVzdH0gY3JlYXRlRnVuZE9wZXJhdGlvblJlcXVlc3RcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZUZ1bmRPcGVyYXRpb24od2FsbGV0SWQsIGFkZHJlc3NJZCwgY3JlYXRlRnVuZE9wZXJhdGlvblJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmNyZWF0ZUZ1bmRPcGVyYXRpb24od2FsbGV0SWQsIGFkZHJlc3NJZCwgY3JlYXRlRnVuZE9wZXJhdGlvblJlcXVlc3QsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSBuZXcgZnVuZCBvcGVyYXRpb24gd2l0aCBhbiBhZGRyZXNzLlxuICAgICAgICAgKiBAc3VtbWFyeSBDcmVhdGUgYSBGdW5kIE9wZXJhdGlvbiBxdW90ZS5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIG9uY2hhaW4gYWRkcmVzcyB0byBiZSBmdW5kZWQuXG4gICAgICAgICAqIEBwYXJhbSB7Q3JlYXRlRnVuZFF1b3RlUmVxdWVzdH0gY3JlYXRlRnVuZFF1b3RlUmVxdWVzdFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgY3JlYXRlRnVuZFF1b3RlKHdhbGxldElkLCBhZGRyZXNzSWQsIGNyZWF0ZUZ1bmRRdW90ZVJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmNyZWF0ZUZ1bmRRdW90ZSh3YWxsZXRJZCwgYWRkcmVzc0lkLCBjcmVhdGVGdW5kUXVvdGVSZXF1ZXN0LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGZ1bmQgb3BlcmF0aW9uLlxuICAgICAgICAgKiBAc3VtbWFyeSBHZXQgZnVuZCBvcGVyYXRpb24uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBvbmNoYWluIGFkZHJlc3Mgb2YgdGhlIGFkZHJlc3MgdGhhdCBjcmVhdGVkIHRoZSBmdW5kIG9wZXJhdGlvbi5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGZ1bmRPcGVyYXRpb25JZCBUaGUgSUQgb2YgdGhlIGZ1bmQgb3BlcmF0aW9uIHRvIGZldGNoLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0RnVuZE9wZXJhdGlvbih3YWxsZXRJZCwgYWRkcmVzc0lkLCBmdW5kT3BlcmF0aW9uSWQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmdldEZ1bmRPcGVyYXRpb24od2FsbGV0SWQsIGFkZHJlc3NJZCwgZnVuZE9wZXJhdGlvbklkLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdCBmdW5kIG9wZXJhdGlvbnMgZm9yIGFuIGFkZHJlc3MuXG4gICAgICAgICAqIEBzdW1tYXJ5IExpc3QgZnVuZCBvcGVyYXRpb25zIGZvciBhbiBhZGRyZXNzLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0by5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgb25jaGFpbiBhZGRyZXNzIG9mIHRoZSBhZGRyZXNzIHRvIGxpc3QgZnVuZCBvcGVyYXRpb25zIGZvci5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gQSBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIG9iamVjdHMgdG8gYmUgcmV0dXJuZWQuIExpbWl0IGNhbiByYW5nZSBiZXR3ZWVuIDEgYW5kIDEwMCwgYW5kIHRoZSBkZWZhdWx0IGlzIDEwLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VdIEEgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiByZXN1bHRzLiBEb25cXCYjMzk7dCBpbmNsdWRlIHRoaXMgcGFyYW1ldGVyIG9uIHRoZSBmaXJzdCBjYWxsLiBVc2UgdGhlIG5leHRfcGFnZSB2YWx1ZSByZXR1cm5lZCBpbiBhIHByZXZpb3VzIHJlc3BvbnNlIHRvIHJlcXVlc3Qgc3Vic2VxdWVudCByZXN1bHRzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgbGlzdEZ1bmRPcGVyYXRpb25zKHdhbGxldElkLCBhZGRyZXNzSWQsIGxpbWl0LCBwYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5saXN0RnVuZE9wZXJhdGlvbnMod2FsbGV0SWQsIGFkZHJlc3NJZCwgbGltaXQsIHBhZ2UsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5leHBvcnRzLkZ1bmRBcGlGYWN0b3J5ID0gRnVuZEFwaUZhY3Rvcnk7XG4vKipcbiAqIEZ1bmRBcGkgLSBvYmplY3Qtb3JpZW50ZWQgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKiBAY2xhc3MgRnVuZEFwaVxuICogQGV4dGVuZHMge0Jhc2VBUEl9XG4gKi9cbmNsYXNzIEZ1bmRBcGkgZXh0ZW5kcyBiYXNlXzEuQmFzZUFQSSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IGZ1bmQgb3BlcmF0aW9uIHdpdGggYW4gYWRkcmVzcy5cbiAgICAgKiBAc3VtbWFyeSBDcmVhdGUgYSBuZXcgZnVuZCBvcGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG8uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgb25jaGFpbiBhZGRyZXNzIHRvIGJlIGZ1bmRlZC5cbiAgICAgKiBAcGFyYW0ge0NyZWF0ZUZ1bmRPcGVyYXRpb25SZXF1ZXN0fSBjcmVhdGVGdW5kT3BlcmF0aW9uUmVxdWVzdFxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgRnVuZEFwaVxuICAgICAqL1xuICAgIGNyZWF0ZUZ1bmRPcGVyYXRpb24od2FsbGV0SWQsIGFkZHJlc3NJZCwgY3JlYXRlRnVuZE9wZXJhdGlvblJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLkZ1bmRBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5jcmVhdGVGdW5kT3BlcmF0aW9uKHdhbGxldElkLCBhZGRyZXNzSWQsIGNyZWF0ZUZ1bmRPcGVyYXRpb25SZXF1ZXN0LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IGZ1bmQgb3BlcmF0aW9uIHdpdGggYW4gYWRkcmVzcy5cbiAgICAgKiBAc3VtbWFyeSBDcmVhdGUgYSBGdW5kIE9wZXJhdGlvbiBxdW90ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0by5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBvbmNoYWluIGFkZHJlc3MgdG8gYmUgZnVuZGVkLlxuICAgICAqIEBwYXJhbSB7Q3JlYXRlRnVuZFF1b3RlUmVxdWVzdH0gY3JlYXRlRnVuZFF1b3RlUmVxdWVzdFxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgRnVuZEFwaVxuICAgICAqL1xuICAgIGNyZWF0ZUZ1bmRRdW90ZSh3YWxsZXRJZCwgYWRkcmVzc0lkLCBjcmVhdGVGdW5kUXVvdGVSZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5GdW5kQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuY3JlYXRlRnVuZFF1b3RlKHdhbGxldElkLCBhZGRyZXNzSWQsIGNyZWF0ZUZ1bmRRdW90ZVJlcXVlc3QsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgZnVuZCBvcGVyYXRpb24uXG4gICAgICogQHN1bW1hcnkgR2V0IGZ1bmQgb3BlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIG9uY2hhaW4gYWRkcmVzcyBvZiB0aGUgYWRkcmVzcyB0aGF0IGNyZWF0ZWQgdGhlIGZ1bmQgb3BlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmdW5kT3BlcmF0aW9uSWQgVGhlIElEIG9mIHRoZSBmdW5kIG9wZXJhdGlvbiB0byBmZXRjaC5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIEZ1bmRBcGlcbiAgICAgKi9cbiAgICBnZXRGdW5kT3BlcmF0aW9uKHdhbGxldElkLCBhZGRyZXNzSWQsIGZ1bmRPcGVyYXRpb25JZCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuRnVuZEFwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLmdldEZ1bmRPcGVyYXRpb24od2FsbGV0SWQsIGFkZHJlc3NJZCwgZnVuZE9wZXJhdGlvbklkLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdCBmdW5kIG9wZXJhdGlvbnMgZm9yIGFuIGFkZHJlc3MuXG4gICAgICogQHN1bW1hcnkgTGlzdCBmdW5kIG9wZXJhdGlvbnMgZm9yIGFuIGFkZHJlc3MuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG8uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgb25jaGFpbiBhZGRyZXNzIG9mIHRoZSBhZGRyZXNzIHRvIGxpc3QgZnVuZCBvcGVyYXRpb25zIGZvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBBIGxpbWl0IG9uIHRoZSBudW1iZXIgb2Ygb2JqZWN0cyB0byBiZSByZXR1cm5lZC4gTGltaXQgY2FuIHJhbmdlIGJldHdlZW4gMSBhbmQgMTAwLCBhbmQgdGhlIGRlZmF1bHQgaXMgMTAuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlXSBBIGN1cnNvciBmb3IgcGFnaW5hdGlvbiBhY3Jvc3MgbXVsdGlwbGUgcGFnZXMgb2YgcmVzdWx0cy4gRG9uXFwmIzM5O3QgaW5jbHVkZSB0aGlzIHBhcmFtZXRlciBvbiB0aGUgZmlyc3QgY2FsbC4gVXNlIHRoZSBuZXh0X3BhZ2UgdmFsdWUgcmV0dXJuZWQgaW4gYSBwcmV2aW91cyByZXNwb25zZSB0byByZXF1ZXN0IHN1YnNlcXVlbnQgcmVzdWx0cy5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIEZ1bmRBcGlcbiAgICAgKi9cbiAgICBsaXN0RnVuZE9wZXJhdGlvbnMod2FsbGV0SWQsIGFkZHJlc3NJZCwgbGltaXQsIHBhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLkZ1bmRBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5saXN0RnVuZE9wZXJhdGlvbnMod2FsbGV0SWQsIGFkZHJlc3NJZCwgbGltaXQsIHBhZ2UsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuRnVuZEFwaSA9IEZ1bmRBcGk7XG4vKipcbiAqIE1QQ1dhbGxldFN0YWtlQXBpIC0gYXhpb3MgcGFyYW1ldGVyIGNyZWF0b3JcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgTVBDV2FsbGV0U3Rha2VBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJyb2FkY2FzdCBhIHN0YWtpbmcgb3BlcmF0aW9uLlxuICAgICAgICAgKiBAc3VtbWFyeSBCcm9hZGNhc3QgYSBzdGFraW5nIG9wZXJhdGlvblxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0by5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdGhlIHN0YWtpbmcgb3BlcmF0aW9uIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdGFraW5nT3BlcmF0aW9uSWQgVGhlIElEIG9mIHRoZSBzdGFraW5nIG9wZXJhdGlvbiB0byBicm9hZGNhc3QuXG4gICAgICAgICAqIEBwYXJhbSB7QnJvYWRjYXN0U3Rha2luZ09wZXJhdGlvblJlcXVlc3R9IGJyb2FkY2FzdFN0YWtpbmdPcGVyYXRpb25SZXF1ZXN0XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBicm9hZGNhc3RTdGFraW5nT3BlcmF0aW9uOiBhc3luYyAod2FsbGV0SWQsIGFkZHJlc3NJZCwgc3Rha2luZ09wZXJhdGlvbklkLCBicm9hZGNhc3RTdGFraW5nT3BlcmF0aW9uUmVxdWVzdCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICd3YWxsZXRJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdicm9hZGNhc3RTdGFraW5nT3BlcmF0aW9uJywgJ3dhbGxldElkJywgd2FsbGV0SWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnYWRkcmVzc0lkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2Jyb2FkY2FzdFN0YWtpbmdPcGVyYXRpb24nLCAnYWRkcmVzc0lkJywgYWRkcmVzc0lkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ3N0YWtpbmdPcGVyYXRpb25JZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdicm9hZGNhc3RTdGFraW5nT3BlcmF0aW9uJywgJ3N0YWtpbmdPcGVyYXRpb25JZCcsIHN0YWtpbmdPcGVyYXRpb25JZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdicm9hZGNhc3RTdGFraW5nT3BlcmF0aW9uUmVxdWVzdCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdicm9hZGNhc3RTdGFraW5nT3BlcmF0aW9uJywgJ2Jyb2FkY2FzdFN0YWtpbmdPcGVyYXRpb25SZXF1ZXN0JywgYnJvYWRjYXN0U3Rha2luZ09wZXJhdGlvblJlcXVlc3QpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS93YWxsZXRzL3t3YWxsZXRfaWR9L2FkZHJlc3Nlcy97YWRkcmVzc19pZH0vc3Rha2luZ19vcGVyYXRpb25zL3tzdGFraW5nX29wZXJhdGlvbl9pZH0vYnJvYWRjYXN0YFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcIndhbGxldF9pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHdhbGxldElkKSkpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wiYWRkcmVzc19pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKGFkZHJlc3NJZCkpKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcInN0YWtpbmdfb3BlcmF0aW9uX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoc3Rha2luZ09wZXJhdGlvbklkKSkpO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7IG1ldGhvZDogJ1BPU1QnLCAuLi5iYXNlT3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIGFwaUtleSByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJKd3RcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBsb2NhbFZhckhlYWRlclBhcmFtZXRlclsnQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSB7IC4uLmxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCAuLi5oZWFkZXJzRnJvbUJhc2VPcHRpb25zLCAuLi5vcHRpb25zLmhlYWRlcnMgfTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuZGF0YSA9ICgwLCBjb21tb25fMS5zZXJpYWxpemVEYXRhSWZOZWVkZWQpKGJyb2FkY2FzdFN0YWtpbmdPcGVyYXRpb25SZXF1ZXN0LCBsb2NhbFZhclJlcXVlc3RPcHRpb25zLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSBuZXcgc3Rha2luZyBvcGVyYXRpb24uXG4gICAgICAgICAqIEBzdW1tYXJ5IENyZWF0ZSBhIG5ldyBzdGFraW5nIG9wZXJhdGlvbiBmb3IgYW4gYWRkcmVzc1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0by5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdG8gY3JlYXRlIHRoZSBzdGFraW5nIG9wZXJhdGlvbiBmb3IuXG4gICAgICAgICAqIEBwYXJhbSB7Q3JlYXRlU3Rha2luZ09wZXJhdGlvblJlcXVlc3R9IGNyZWF0ZVN0YWtpbmdPcGVyYXRpb25SZXF1ZXN0XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGVTdGFraW5nT3BlcmF0aW9uOiBhc3luYyAod2FsbGV0SWQsIGFkZHJlc3NJZCwgY3JlYXRlU3Rha2luZ09wZXJhdGlvblJlcXVlc3QsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnd2FsbGV0SWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnY3JlYXRlU3Rha2luZ09wZXJhdGlvbicsICd3YWxsZXRJZCcsIHdhbGxldElkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2FkZHJlc3NJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdjcmVhdGVTdGFraW5nT3BlcmF0aW9uJywgJ2FkZHJlc3NJZCcsIGFkZHJlc3NJZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdjcmVhdGVTdGFraW5nT3BlcmF0aW9uUmVxdWVzdCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdjcmVhdGVTdGFraW5nT3BlcmF0aW9uJywgJ2NyZWF0ZVN0YWtpbmdPcGVyYXRpb25SZXF1ZXN0JywgY3JlYXRlU3Rha2luZ09wZXJhdGlvblJlcXVlc3QpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS93YWxsZXRzL3t3YWxsZXRfaWR9L2FkZHJlc3Nlcy97YWRkcmVzc19pZH0vc3Rha2luZ19vcGVyYXRpb25zYFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcIndhbGxldF9pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHdhbGxldElkKSkpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wiYWRkcmVzc19pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKGFkZHJlc3NJZCkpKTtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0geyBtZXRob2Q6ICdQT1NUJywgLi4uYmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBhcGlLZXkgcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXJbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0geyAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlciwgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucywgLi4ub3B0aW9ucy5oZWFkZXJzIH07XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmRhdGEgPSAoMCwgY29tbW9uXzEuc2VyaWFsaXplRGF0YUlmTmVlZGVkKShjcmVhdGVTdGFraW5nT3BlcmF0aW9uUmVxdWVzdCwgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucywgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBsYXRlc3Qgc3RhdGUgb2YgYSBzdGFraW5nIG9wZXJhdGlvbi5cbiAgICAgICAgICogQHN1bW1hcnkgR2V0IHRoZSBsYXRlc3Qgc3RhdGUgb2YgYSBzdGFraW5nIG9wZXJhdGlvblxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0b1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0byBmZXRjaCB0aGUgc3Rha2luZyBvcGVyYXRpb24gZm9yLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3Rha2luZ09wZXJhdGlvbklkIFRoZSBJRCBvZiB0aGUgc3Rha2luZyBvcGVyYXRpb24uXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRTdGFraW5nT3BlcmF0aW9uOiBhc3luYyAod2FsbGV0SWQsIGFkZHJlc3NJZCwgc3Rha2luZ09wZXJhdGlvbklkLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ3dhbGxldElkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2dldFN0YWtpbmdPcGVyYXRpb24nLCAnd2FsbGV0SWQnLCB3YWxsZXRJZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdhZGRyZXNzSWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZ2V0U3Rha2luZ09wZXJhdGlvbicsICdhZGRyZXNzSWQnLCBhZGRyZXNzSWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnc3Rha2luZ09wZXJhdGlvbklkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2dldFN0YWtpbmdPcGVyYXRpb24nLCAnc3Rha2luZ09wZXJhdGlvbklkJywgc3Rha2luZ09wZXJhdGlvbklkKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvd2FsbGV0cy97d2FsbGV0X2lkfS9hZGRyZXNzZXMve2FkZHJlc3NfaWR9L3N0YWtpbmdfb3BlcmF0aW9ucy97c3Rha2luZ19vcGVyYXRpb25faWR9YFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcIndhbGxldF9pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHdhbGxldElkKSkpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wiYWRkcmVzc19pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKGFkZHJlc3NJZCkpKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcInN0YWtpbmdfb3BlcmF0aW9uX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoc3Rha2luZ09wZXJhdGlvbklkKSkpO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7IG1ldGhvZDogJ0dFVCcsIC4uLmJhc2VPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gYXBpS2V5IHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIkp3dFwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIHNlc3Npb24gcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0geyAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlciwgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucywgLi4ub3B0aW9ucy5oZWFkZXJzIH07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5NUENXYWxsZXRTdGFrZUFwaUF4aW9zUGFyYW1DcmVhdG9yID0gTVBDV2FsbGV0U3Rha2VBcGlBeGlvc1BhcmFtQ3JlYXRvcjtcbi8qKlxuICogTVBDV2FsbGV0U3Rha2VBcGkgLSBmdW5jdGlvbmFsIHByb2dyYW1taW5nIGludGVyZmFjZVxuICogQGV4cG9ydFxuICovXG5jb25zdCBNUENXYWxsZXRTdGFrZUFwaUZwID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24pIHtcbiAgICBjb25zdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yID0gKDAsIGV4cG9ydHMuTVBDV2FsbGV0U3Rha2VBcGlBeGlvc1BhcmFtQ3JlYXRvcikoY29uZmlndXJhdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJyb2FkY2FzdCBhIHN0YWtpbmcgb3BlcmF0aW9uLlxuICAgICAgICAgKiBAc3VtbWFyeSBCcm9hZGNhc3QgYSBzdGFraW5nIG9wZXJhdGlvblxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0by5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdGhlIHN0YWtpbmcgb3BlcmF0aW9uIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdGFraW5nT3BlcmF0aW9uSWQgVGhlIElEIG9mIHRoZSBzdGFraW5nIG9wZXJhdGlvbiB0byBicm9hZGNhc3QuXG4gICAgICAgICAqIEBwYXJhbSB7QnJvYWRjYXN0U3Rha2luZ09wZXJhdGlvblJlcXVlc3R9IGJyb2FkY2FzdFN0YWtpbmdPcGVyYXRpb25SZXF1ZXN0XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBicm9hZGNhc3RTdGFraW5nT3BlcmF0aW9uKHdhbGxldElkLCBhZGRyZXNzSWQsIHN0YWtpbmdPcGVyYXRpb25JZCwgYnJvYWRjYXN0U3Rha2luZ09wZXJhdGlvblJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5icm9hZGNhc3RTdGFraW5nT3BlcmF0aW9uKHdhbGxldElkLCBhZGRyZXNzSWQsIHN0YWtpbmdPcGVyYXRpb25JZCwgYnJvYWRjYXN0U3Rha2luZ09wZXJhdGlvblJlcXVlc3QsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IGNvbmZpZ3VyYXRpb24/LnNlcnZlckluZGV4ID8/IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnTVBDV2FsbGV0U3Rha2VBcGkuYnJvYWRjYXN0U3Rha2luZ09wZXJhdGlvbiddPy5bbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0/LnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSBuZXcgc3Rha2luZyBvcGVyYXRpb24uXG4gICAgICAgICAqIEBzdW1tYXJ5IENyZWF0ZSBhIG5ldyBzdGFraW5nIG9wZXJhdGlvbiBmb3IgYW4gYWRkcmVzc1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0by5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdG8gY3JlYXRlIHRoZSBzdGFraW5nIG9wZXJhdGlvbiBmb3IuXG4gICAgICAgICAqIEBwYXJhbSB7Q3JlYXRlU3Rha2luZ09wZXJhdGlvblJlcXVlc3R9IGNyZWF0ZVN0YWtpbmdPcGVyYXRpb25SZXF1ZXN0XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBjcmVhdGVTdGFraW5nT3BlcmF0aW9uKHdhbGxldElkLCBhZGRyZXNzSWQsIGNyZWF0ZVN0YWtpbmdPcGVyYXRpb25SZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuY3JlYXRlU3Rha2luZ09wZXJhdGlvbih3YWxsZXRJZCwgYWRkcmVzc0lkLCBjcmVhdGVTdGFraW5nT3BlcmF0aW9uUmVxdWVzdCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gY29uZmlndXJhdGlvbj8uc2VydmVySW5kZXggPz8gMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydNUENXYWxsZXRTdGFrZUFwaS5jcmVhdGVTdGFraW5nT3BlcmF0aW9uJ10/Lltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XT8udXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgbGF0ZXN0IHN0YXRlIG9mIGEgc3Rha2luZyBvcGVyYXRpb24uXG4gICAgICAgICAqIEBzdW1tYXJ5IEdldCB0aGUgbGF0ZXN0IHN0YXRlIG9mIGEgc3Rha2luZyBvcGVyYXRpb25cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG9cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdG8gZmV0Y2ggdGhlIHN0YWtpbmcgb3BlcmF0aW9uIGZvci5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHN0YWtpbmdPcGVyYXRpb25JZCBUaGUgSUQgb2YgdGhlIHN0YWtpbmcgb3BlcmF0aW9uLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgZ2V0U3Rha2luZ09wZXJhdGlvbih3YWxsZXRJZCwgYWRkcmVzc0lkLCBzdGFraW5nT3BlcmF0aW9uSWQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5nZXRTdGFraW5nT3BlcmF0aW9uKHdhbGxldElkLCBhZGRyZXNzSWQsIHN0YWtpbmdPcGVyYXRpb25JZCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gY29uZmlndXJhdGlvbj8uc2VydmVySW5kZXggPz8gMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydNUENXYWxsZXRTdGFrZUFwaS5nZXRTdGFraW5nT3BlcmF0aW9uJ10/Lltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XT8udXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuTVBDV2FsbGV0U3Rha2VBcGlGcCA9IE1QQ1dhbGxldFN0YWtlQXBpRnA7XG4vKipcbiAqIE1QQ1dhbGxldFN0YWtlQXBpIC0gZmFjdG9yeSBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgTVBDV2FsbGV0U3Rha2VBcGlGYWN0b3J5ID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24sIGJhc2VQYXRoLCBheGlvcykge1xuICAgIGNvbnN0IGxvY2FsVmFyRnAgPSAoMCwgZXhwb3J0cy5NUENXYWxsZXRTdGFrZUFwaUZwKShjb25maWd1cmF0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQnJvYWRjYXN0IGEgc3Rha2luZyBvcGVyYXRpb24uXG4gICAgICAgICAqIEBzdW1tYXJ5IEJyb2FkY2FzdCBhIHN0YWtpbmcgb3BlcmF0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0aGUgc3Rha2luZyBvcGVyYXRpb24gYmVsb25ncyB0by5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHN0YWtpbmdPcGVyYXRpb25JZCBUaGUgSUQgb2YgdGhlIHN0YWtpbmcgb3BlcmF0aW9uIHRvIGJyb2FkY2FzdC5cbiAgICAgICAgICogQHBhcmFtIHtCcm9hZGNhc3RTdGFraW5nT3BlcmF0aW9uUmVxdWVzdH0gYnJvYWRjYXN0U3Rha2luZ09wZXJhdGlvblJlcXVlc3RcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGJyb2FkY2FzdFN0YWtpbmdPcGVyYXRpb24od2FsbGV0SWQsIGFkZHJlc3NJZCwgc3Rha2luZ09wZXJhdGlvbklkLCBicm9hZGNhc3RTdGFraW5nT3BlcmF0aW9uUmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuYnJvYWRjYXN0U3Rha2luZ09wZXJhdGlvbih3YWxsZXRJZCwgYWRkcmVzc0lkLCBzdGFraW5nT3BlcmF0aW9uSWQsIGJyb2FkY2FzdFN0YWtpbmdPcGVyYXRpb25SZXF1ZXN0LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgbmV3IHN0YWtpbmcgb3BlcmF0aW9uLlxuICAgICAgICAgKiBAc3VtbWFyeSBDcmVhdGUgYSBuZXcgc3Rha2luZyBvcGVyYXRpb24gZm9yIGFuIGFkZHJlc3NcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRvIGNyZWF0ZSB0aGUgc3Rha2luZyBvcGVyYXRpb24gZm9yLlxuICAgICAgICAgKiBAcGFyYW0ge0NyZWF0ZVN0YWtpbmdPcGVyYXRpb25SZXF1ZXN0fSBjcmVhdGVTdGFraW5nT3BlcmF0aW9uUmVxdWVzdFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgY3JlYXRlU3Rha2luZ09wZXJhdGlvbih3YWxsZXRJZCwgYWRkcmVzc0lkLCBjcmVhdGVTdGFraW5nT3BlcmF0aW9uUmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuY3JlYXRlU3Rha2luZ09wZXJhdGlvbih3YWxsZXRJZCwgYWRkcmVzc0lkLCBjcmVhdGVTdGFraW5nT3BlcmF0aW9uUmVxdWVzdCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgbGF0ZXN0IHN0YXRlIG9mIGEgc3Rha2luZyBvcGVyYXRpb24uXG4gICAgICAgICAqIEBzdW1tYXJ5IEdldCB0aGUgbGF0ZXN0IHN0YXRlIG9mIGEgc3Rha2luZyBvcGVyYXRpb25cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG9cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdG8gZmV0Y2ggdGhlIHN0YWtpbmcgb3BlcmF0aW9uIGZvci5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHN0YWtpbmdPcGVyYXRpb25JZCBUaGUgSUQgb2YgdGhlIHN0YWtpbmcgb3BlcmF0aW9uLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0U3Rha2luZ09wZXJhdGlvbih3YWxsZXRJZCwgYWRkcmVzc0lkLCBzdGFraW5nT3BlcmF0aW9uSWQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmdldFN0YWtpbmdPcGVyYXRpb24od2FsbGV0SWQsIGFkZHJlc3NJZCwgc3Rha2luZ09wZXJhdGlvbklkLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5NUENXYWxsZXRTdGFrZUFwaUZhY3RvcnkgPSBNUENXYWxsZXRTdGFrZUFwaUZhY3Rvcnk7XG4vKipcbiAqIE1QQ1dhbGxldFN0YWtlQXBpIC0gb2JqZWN0LW9yaWVudGVkIGludGVyZmFjZVxuICogQGV4cG9ydFxuICogQGNsYXNzIE1QQ1dhbGxldFN0YWtlQXBpXG4gKiBAZXh0ZW5kcyB7QmFzZUFQSX1cbiAqL1xuY2xhc3MgTVBDV2FsbGV0U3Rha2VBcGkgZXh0ZW5kcyBiYXNlXzEuQmFzZUFQSSB7XG4gICAgLyoqXG4gICAgICogQnJvYWRjYXN0IGEgc3Rha2luZyBvcGVyYXRpb24uXG4gICAgICogQHN1bW1hcnkgQnJvYWRjYXN0IGEgc3Rha2luZyBvcGVyYXRpb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0by5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0aGUgc3Rha2luZyBvcGVyYXRpb24gYmVsb25ncyB0by5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3Rha2luZ09wZXJhdGlvbklkIFRoZSBJRCBvZiB0aGUgc3Rha2luZyBvcGVyYXRpb24gdG8gYnJvYWRjYXN0LlxuICAgICAqIEBwYXJhbSB7QnJvYWRjYXN0U3Rha2luZ09wZXJhdGlvblJlcXVlc3R9IGJyb2FkY2FzdFN0YWtpbmdPcGVyYXRpb25SZXF1ZXN0XG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBNUENXYWxsZXRTdGFrZUFwaVxuICAgICAqL1xuICAgIGJyb2FkY2FzdFN0YWtpbmdPcGVyYXRpb24od2FsbGV0SWQsIGFkZHJlc3NJZCwgc3Rha2luZ09wZXJhdGlvbklkLCBicm9hZGNhc3RTdGFraW5nT3BlcmF0aW9uUmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuTVBDV2FsbGV0U3Rha2VBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5icm9hZGNhc3RTdGFraW5nT3BlcmF0aW9uKHdhbGxldElkLCBhZGRyZXNzSWQsIHN0YWtpbmdPcGVyYXRpb25JZCwgYnJvYWRjYXN0U3Rha2luZ09wZXJhdGlvblJlcXVlc3QsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgc3Rha2luZyBvcGVyYXRpb24uXG4gICAgICogQHN1bW1hcnkgQ3JlYXRlIGEgbmV3IHN0YWtpbmcgb3BlcmF0aW9uIGZvciBhbiBhZGRyZXNzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG8uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdG8gY3JlYXRlIHRoZSBzdGFraW5nIG9wZXJhdGlvbiBmb3IuXG4gICAgICogQHBhcmFtIHtDcmVhdGVTdGFraW5nT3BlcmF0aW9uUmVxdWVzdH0gY3JlYXRlU3Rha2luZ09wZXJhdGlvblJlcXVlc3RcbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIE1QQ1dhbGxldFN0YWtlQXBpXG4gICAgICovXG4gICAgY3JlYXRlU3Rha2luZ09wZXJhdGlvbih3YWxsZXRJZCwgYWRkcmVzc0lkLCBjcmVhdGVTdGFraW5nT3BlcmF0aW9uUmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuTVBDV2FsbGV0U3Rha2VBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5jcmVhdGVTdGFraW5nT3BlcmF0aW9uKHdhbGxldElkLCBhZGRyZXNzSWQsIGNyZWF0ZVN0YWtpbmdPcGVyYXRpb25SZXF1ZXN0LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBsYXRlc3Qgc3RhdGUgb2YgYSBzdGFraW5nIG9wZXJhdGlvbi5cbiAgICAgKiBAc3VtbWFyeSBHZXQgdGhlIGxhdGVzdCBzdGF0ZSBvZiBhIHN0YWtpbmcgb3BlcmF0aW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG9cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0byBmZXRjaCB0aGUgc3Rha2luZyBvcGVyYXRpb24gZm9yLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdGFraW5nT3BlcmF0aW9uSWQgVGhlIElEIG9mIHRoZSBzdGFraW5nIG9wZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIE1QQ1dhbGxldFN0YWtlQXBpXG4gICAgICovXG4gICAgZ2V0U3Rha2luZ09wZXJhdGlvbih3YWxsZXRJZCwgYWRkcmVzc0lkLCBzdGFraW5nT3BlcmF0aW9uSWQsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLk1QQ1dhbGxldFN0YWtlQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuZ2V0U3Rha2luZ09wZXJhdGlvbih3YWxsZXRJZCwgYWRkcmVzc0lkLCBzdGFraW5nT3BlcmF0aW9uSWQsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuTVBDV2FsbGV0U3Rha2VBcGkgPSBNUENXYWxsZXRTdGFrZUFwaTtcbi8qKlxuICogTmV0d29ya3NBcGkgLSBheGlvcyBwYXJhbWV0ZXIgY3JlYXRvclxuICogQGV4cG9ydFxuICovXG5jb25zdCBOZXR3b3Jrc0FwaUF4aW9zUGFyYW1DcmVhdG9yID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IG5ldHdvcmtcbiAgICAgICAgICogQHN1bW1hcnkgR2V0IG5ldHdvcmsgYnkgSURcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5ldHdvcmtJZCBUaGUgSUQgb2YgdGhlIG5ldHdvcmsgdG8gZmV0Y2guXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBnZXROZXR3b3JrOiBhc3luYyAobmV0d29ya0lkLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ25ldHdvcmtJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdnZXROZXR3b3JrJywgJ25ldHdvcmtJZCcsIG5ldHdvcmtJZCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL25ldHdvcmtzL3tuZXR3b3JrX2lkfWBcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJuZXR3b3JrX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcobmV0d29ya0lkKSkpO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7IG1ldGhvZDogJ0dFVCcsIC4uLmJhc2VPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gYXBpS2V5IHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIkp3dFwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIHNlc3Npb24gcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0geyAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlciwgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucywgLi4ub3B0aW9ucy5oZWFkZXJzIH07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5OZXR3b3Jrc0FwaUF4aW9zUGFyYW1DcmVhdG9yID0gTmV0d29ya3NBcGlBeGlvc1BhcmFtQ3JlYXRvcjtcbi8qKlxuICogTmV0d29ya3NBcGkgLSBmdW5jdGlvbmFsIHByb2dyYW1taW5nIGludGVyZmFjZVxuICogQGV4cG9ydFxuICovXG5jb25zdCBOZXR3b3Jrc0FwaUZwID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24pIHtcbiAgICBjb25zdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yID0gKDAsIGV4cG9ydHMuTmV0d29ya3NBcGlBeGlvc1BhcmFtQ3JlYXRvcikoY29uZmlndXJhdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBuZXR3b3JrXG4gICAgICAgICAqIEBzdW1tYXJ5IEdldCBuZXR3b3JrIGJ5IElEXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWQgVGhlIElEIG9mIHRoZSBuZXR3b3JrIHRvIGZldGNoLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgZ2V0TmV0d29yayhuZXR3b3JrSWQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5nZXROZXR3b3JrKG5ldHdvcmtJZCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gY29uZmlndXJhdGlvbj8uc2VydmVySW5kZXggPz8gMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydOZXR3b3Jrc0FwaS5nZXROZXR3b3JrJ10/Lltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XT8udXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuTmV0d29ya3NBcGlGcCA9IE5ldHdvcmtzQXBpRnA7XG4vKipcbiAqIE5ldHdvcmtzQXBpIC0gZmFjdG9yeSBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgTmV0d29ya3NBcGlGYWN0b3J5ID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24sIGJhc2VQYXRoLCBheGlvcykge1xuICAgIGNvbnN0IGxvY2FsVmFyRnAgPSAoMCwgZXhwb3J0cy5OZXR3b3Jrc0FwaUZwKShjb25maWd1cmF0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IG5ldHdvcmtcbiAgICAgICAgICogQHN1bW1hcnkgR2V0IG5ldHdvcmsgYnkgSURcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5ldHdvcmtJZCBUaGUgSUQgb2YgdGhlIG5ldHdvcmsgdG8gZmV0Y2guXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBnZXROZXR3b3JrKG5ldHdvcmtJZCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuZ2V0TmV0d29yayhuZXR3b3JrSWQsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5leHBvcnRzLk5ldHdvcmtzQXBpRmFjdG9yeSA9IE5ldHdvcmtzQXBpRmFjdG9yeTtcbi8qKlxuICogTmV0d29ya3NBcGkgLSBvYmplY3Qtb3JpZW50ZWQgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKiBAY2xhc3MgTmV0d29ya3NBcGlcbiAqIEBleHRlbmRzIHtCYXNlQVBJfVxuICovXG5jbGFzcyBOZXR3b3Jrc0FwaSBleHRlbmRzIGJhc2VfMS5CYXNlQVBJIHtcbiAgICAvKipcbiAgICAgKiBHZXQgbmV0d29ya1xuICAgICAqIEBzdW1tYXJ5IEdldCBuZXR3b3JrIGJ5IElEXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5ldHdvcmtJZCBUaGUgSUQgb2YgdGhlIG5ldHdvcmsgdG8gZmV0Y2guXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBOZXR3b3Jrc0FwaVxuICAgICAqL1xuICAgIGdldE5ldHdvcmsobmV0d29ya0lkLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5OZXR3b3Jrc0FwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLmdldE5ldHdvcmsobmV0d29ya0lkLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG59XG5leHBvcnRzLk5ldHdvcmtzQXBpID0gTmV0d29ya3NBcGk7XG4vKipcbiAqIE9uY2hhaW5JZGVudGl0eUFwaSAtIGF4aW9zIHBhcmFtZXRlciBjcmVhdG9yXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IE9uY2hhaW5JZGVudGl0eUFwaUF4aW9zUGFyYW1DcmVhdG9yID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogT2J0YWlucyBvbmNoYWluIGlkZW50aXR5IGZvciBhbiBhZGRyZXNzIG9uIGEgc3BlY2lmaWMgbmV0d29ya1xuICAgICAgICAgKiBAc3VtbWFyeSBPYnRhaW5zIG9uY2hhaW4gaWRlbnRpdHkgZm9yIGFuIGFkZHJlc3Mgb24gYSBzcGVjaWZpYyBuZXR3b3JrXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWQgVGhlIElEIG9mIHRoZSBibG9ja2NoYWluIG5ldHdvcmtcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdG8gZmV0Y2ggdGhlIGlkZW50aXR5IGZvclxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5PFJlc29sdmVJZGVudGl0eUJ5QWRkcmVzc1JvbGVzRW51bT59IFtyb2xlc10gQSBmaWx0ZXIgYnkgcm9sZSBvZiB0aGUgbmFtZXMgcmVsYXRlZCB0byB0aGlzIGFkZHJlc3MgKG1hbmFnZWQgb3Igb3duZWQpXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIEEgbGltaXQgb24gdGhlIG51bWJlciBvZiBvYmplY3RzIHRvIGJlIHJldHVybmVkLiBMaW1pdCBjYW4gcmFuZ2UgYmV0d2VlbiAxIGFuZCAxMDAsIGFuZCB0aGUgZGVmYXVsdCBpcyAxMC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlXSBBIGN1cnNvciBmb3IgcGFnaW5hdGlvbiBhY3Jvc3MgbXVsdGlwbGUgcGFnZXMgb2YgcmVzdWx0cy4gRG9uXFwmIzM5O3QgaW5jbHVkZSB0aGlzIHBhcmFtZXRlciBvbiB0aGUgZmlyc3QgY2FsbC4gVXNlIHRoZSBuZXh0X3BhZ2UgdmFsdWUgcmV0dXJuZWQgaW4gYSBwcmV2aW91cyByZXNwb25zZSB0byByZXF1ZXN0IHN1YnNlcXVlbnQgcmVzdWx0cy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIHJlc29sdmVJZGVudGl0eUJ5QWRkcmVzczogYXN5bmMgKG5ldHdvcmtJZCwgYWRkcmVzc0lkLCByb2xlcywgbGltaXQsIHBhZ2UsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnbmV0d29ya0lkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ3Jlc29sdmVJZGVudGl0eUJ5QWRkcmVzcycsICduZXR3b3JrSWQnLCBuZXR3b3JrSWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnYWRkcmVzc0lkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ3Jlc29sdmVJZGVudGl0eUJ5QWRkcmVzcycsICdhZGRyZXNzSWQnLCBhZGRyZXNzSWQpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS9uZXR3b3Jrcy97bmV0d29ya19pZH0vYWRkcmVzc2VzL3thZGRyZXNzX2lkfS9pZGVudGl0eWBcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJuZXR3b3JrX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcobmV0d29ya0lkKSkpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wiYWRkcmVzc19pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKGFkZHJlc3NJZCkpKTtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0geyBtZXRob2Q6ICdHRVQnLCAuLi5iYXNlT3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIGFwaUtleSByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJKd3RcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBzZXNzaW9uIHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIkp3dFwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIGlmIChyb2xlcykge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ3JvbGVzJ10gPSByb2xlcy5qb2luKGJhc2VfMS5DT0xMRUNUSU9OX0ZPUk1BVFMuY3N2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsaW1pdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnbGltaXQnXSA9IGxpbWl0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ3BhZ2UnXSA9IHBhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSB7IC4uLmxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCAuLi5oZWFkZXJzRnJvbUJhc2VPcHRpb25zLCAuLi5vcHRpb25zLmhlYWRlcnMgfTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5leHBvcnRzLk9uY2hhaW5JZGVudGl0eUFwaUF4aW9zUGFyYW1DcmVhdG9yID0gT25jaGFpbklkZW50aXR5QXBpQXhpb3NQYXJhbUNyZWF0b3I7XG4vKipcbiAqIE9uY2hhaW5JZGVudGl0eUFwaSAtIGZ1bmN0aW9uYWwgcHJvZ3JhbW1pbmcgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IE9uY2hhaW5JZGVudGl0eUFwaUZwID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24pIHtcbiAgICBjb25zdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yID0gKDAsIGV4cG9ydHMuT25jaGFpbklkZW50aXR5QXBpQXhpb3NQYXJhbUNyZWF0b3IpKGNvbmZpZ3VyYXRpb24pO1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPYnRhaW5zIG9uY2hhaW4gaWRlbnRpdHkgZm9yIGFuIGFkZHJlc3Mgb24gYSBzcGVjaWZpYyBuZXR3b3JrXG4gICAgICAgICAqIEBzdW1tYXJ5IE9idGFpbnMgb25jaGFpbiBpZGVudGl0eSBmb3IgYW4gYWRkcmVzcyBvbiBhIHNwZWNpZmljIG5ldHdvcmtcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5ldHdvcmtJZCBUaGUgSUQgb2YgdGhlIGJsb2NrY2hhaW4gbmV0d29ya1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0byBmZXRjaCB0aGUgaWRlbnRpdHkgZm9yXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXk8UmVzb2x2ZUlkZW50aXR5QnlBZGRyZXNzUm9sZXNFbnVtPn0gW3JvbGVzXSBBIGZpbHRlciBieSByb2xlIG9mIHRoZSBuYW1lcyByZWxhdGVkIHRvIHRoaXMgYWRkcmVzcyAobWFuYWdlZCBvciBvd25lZClcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gQSBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIG9iamVjdHMgdG8gYmUgcmV0dXJuZWQuIExpbWl0IGNhbiByYW5nZSBiZXR3ZWVuIDEgYW5kIDEwMCwgYW5kIHRoZSBkZWZhdWx0IGlzIDEwLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VdIEEgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiByZXN1bHRzLiBEb25cXCYjMzk7dCBpbmNsdWRlIHRoaXMgcGFyYW1ldGVyIG9uIHRoZSBmaXJzdCBjYWxsLiBVc2UgdGhlIG5leHRfcGFnZSB2YWx1ZSByZXR1cm5lZCBpbiBhIHByZXZpb3VzIHJlc3BvbnNlIHRvIHJlcXVlc3Qgc3Vic2VxdWVudCByZXN1bHRzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgcmVzb2x2ZUlkZW50aXR5QnlBZGRyZXNzKG5ldHdvcmtJZCwgYWRkcmVzc0lkLCByb2xlcywgbGltaXQsIHBhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5yZXNvbHZlSWRlbnRpdHlCeUFkZHJlc3MobmV0d29ya0lkLCBhZGRyZXNzSWQsIHJvbGVzLCBsaW1pdCwgcGFnZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gY29uZmlndXJhdGlvbj8uc2VydmVySW5kZXggPz8gMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydPbmNoYWluSWRlbnRpdHlBcGkucmVzb2x2ZUlkZW50aXR5QnlBZGRyZXNzJ10/Lltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XT8udXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuT25jaGFpbklkZW50aXR5QXBpRnAgPSBPbmNoYWluSWRlbnRpdHlBcGlGcDtcbi8qKlxuICogT25jaGFpbklkZW50aXR5QXBpIC0gZmFjdG9yeSBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgT25jaGFpbklkZW50aXR5QXBpRmFjdG9yeSA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uLCBiYXNlUGF0aCwgYXhpb3MpIHtcbiAgICBjb25zdCBsb2NhbFZhckZwID0gKDAsIGV4cG9ydHMuT25jaGFpbklkZW50aXR5QXBpRnApKGNvbmZpZ3VyYXRpb24pO1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPYnRhaW5zIG9uY2hhaW4gaWRlbnRpdHkgZm9yIGFuIGFkZHJlc3Mgb24gYSBzcGVjaWZpYyBuZXR3b3JrXG4gICAgICAgICAqIEBzdW1tYXJ5IE9idGFpbnMgb25jaGFpbiBpZGVudGl0eSBmb3IgYW4gYWRkcmVzcyBvbiBhIHNwZWNpZmljIG5ldHdvcmtcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5ldHdvcmtJZCBUaGUgSUQgb2YgdGhlIGJsb2NrY2hhaW4gbmV0d29ya1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0byBmZXRjaCB0aGUgaWRlbnRpdHkgZm9yXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXk8UmVzb2x2ZUlkZW50aXR5QnlBZGRyZXNzUm9sZXNFbnVtPn0gW3JvbGVzXSBBIGZpbHRlciBieSByb2xlIG9mIHRoZSBuYW1lcyByZWxhdGVkIHRvIHRoaXMgYWRkcmVzcyAobWFuYWdlZCBvciBvd25lZClcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gQSBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIG9iamVjdHMgdG8gYmUgcmV0dXJuZWQuIExpbWl0IGNhbiByYW5nZSBiZXR3ZWVuIDEgYW5kIDEwMCwgYW5kIHRoZSBkZWZhdWx0IGlzIDEwLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VdIEEgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiByZXN1bHRzLiBEb25cXCYjMzk7dCBpbmNsdWRlIHRoaXMgcGFyYW1ldGVyIG9uIHRoZSBmaXJzdCBjYWxsLiBVc2UgdGhlIG5leHRfcGFnZSB2YWx1ZSByZXR1cm5lZCBpbiBhIHByZXZpb3VzIHJlc3BvbnNlIHRvIHJlcXVlc3Qgc3Vic2VxdWVudCByZXN1bHRzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgcmVzb2x2ZUlkZW50aXR5QnlBZGRyZXNzKG5ldHdvcmtJZCwgYWRkcmVzc0lkLCByb2xlcywgbGltaXQsIHBhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLnJlc29sdmVJZGVudGl0eUJ5QWRkcmVzcyhuZXR3b3JrSWQsIGFkZHJlc3NJZCwgcm9sZXMsIGxpbWl0LCBwYWdlLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5PbmNoYWluSWRlbnRpdHlBcGlGYWN0b3J5ID0gT25jaGFpbklkZW50aXR5QXBpRmFjdG9yeTtcbi8qKlxuICogT25jaGFpbklkZW50aXR5QXBpIC0gb2JqZWN0LW9yaWVudGVkIGludGVyZmFjZVxuICogQGV4cG9ydFxuICogQGNsYXNzIE9uY2hhaW5JZGVudGl0eUFwaVxuICogQGV4dGVuZHMge0Jhc2VBUEl9XG4gKi9cbmNsYXNzIE9uY2hhaW5JZGVudGl0eUFwaSBleHRlbmRzIGJhc2VfMS5CYXNlQVBJIHtcbiAgICAvKipcbiAgICAgKiBPYnRhaW5zIG9uY2hhaW4gaWRlbnRpdHkgZm9yIGFuIGFkZHJlc3Mgb24gYSBzcGVjaWZpYyBuZXR3b3JrXG4gICAgICogQHN1bW1hcnkgT2J0YWlucyBvbmNoYWluIGlkZW50aXR5IGZvciBhbiBhZGRyZXNzIG9uIGEgc3BlY2lmaWMgbmV0d29ya1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWQgVGhlIElEIG9mIHRoZSBibG9ja2NoYWluIG5ldHdvcmtcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0byBmZXRjaCB0aGUgaWRlbnRpdHkgZm9yXG4gICAgICogQHBhcmFtIHtBcnJheTxSZXNvbHZlSWRlbnRpdHlCeUFkZHJlc3NSb2xlc0VudW0+fSBbcm9sZXNdIEEgZmlsdGVyIGJ5IHJvbGUgb2YgdGhlIG5hbWVzIHJlbGF0ZWQgdG8gdGhpcyBhZGRyZXNzIChtYW5hZ2VkIG9yIG93bmVkKVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIEEgbGltaXQgb24gdGhlIG51bWJlciBvZiBvYmplY3RzIHRvIGJlIHJldHVybmVkLiBMaW1pdCBjYW4gcmFuZ2UgYmV0d2VlbiAxIGFuZCAxMDAsIGFuZCB0aGUgZGVmYXVsdCBpcyAxMC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VdIEEgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiByZXN1bHRzLiBEb25cXCYjMzk7dCBpbmNsdWRlIHRoaXMgcGFyYW1ldGVyIG9uIHRoZSBmaXJzdCBjYWxsLiBVc2UgdGhlIG5leHRfcGFnZSB2YWx1ZSByZXR1cm5lZCBpbiBhIHByZXZpb3VzIHJlc3BvbnNlIHRvIHJlcXVlc3Qgc3Vic2VxdWVudCByZXN1bHRzLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgT25jaGFpbklkZW50aXR5QXBpXG4gICAgICovXG4gICAgcmVzb2x2ZUlkZW50aXR5QnlBZGRyZXNzKG5ldHdvcmtJZCwgYWRkcmVzc0lkLCByb2xlcywgbGltaXQsIHBhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLk9uY2hhaW5JZGVudGl0eUFwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLnJlc29sdmVJZGVudGl0eUJ5QWRkcmVzcyhuZXR3b3JrSWQsIGFkZHJlc3NJZCwgcm9sZXMsIGxpbWl0LCBwYWdlLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG59XG5leHBvcnRzLk9uY2hhaW5JZGVudGl0eUFwaSA9IE9uY2hhaW5JZGVudGl0eUFwaTtcbi8qKlxuICogQGV4cG9ydFxuICovXG5leHBvcnRzLlJlc29sdmVJZGVudGl0eUJ5QWRkcmVzc1JvbGVzRW51bSA9IHtcbiAgICBNYW5hZ2VkOiAnbWFuYWdlZCcsXG4gICAgT3duZWQ6ICdvd25lZCdcbn07XG4vKipcbiAqIFJlcHV0YXRpb25BcGkgLSBheGlvcyBwYXJhbWV0ZXIgY3JlYXRvclxuICogQGV4cG9ydFxuICovXG5jb25zdCBSZXB1dGF0aW9uQXBpQXhpb3NQYXJhbUNyZWF0b3IgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbikge1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIG9uY2hhaW4gcmVwdXRhdGlvbiBvZiBhbiBleHRlcm5hbCBhZGRyZXNzXG4gICAgICAgICAqIEBzdW1tYXJ5IEdldCB0aGUgb25jaGFpbiByZXB1dGF0aW9uIG9mIGFuIGV4dGVybmFsIGFkZHJlc3NcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5ldHdvcmtJZCBUaGUgSUQgb2YgdGhlIGJsb2NrY2hhaW4gbmV0d29yay5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdG8gZmV0Y2ggdGhlIHJlcHV0YXRpb24gZm9yLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0QWRkcmVzc1JlcHV0YXRpb246IGFzeW5jIChuZXR3b3JrSWQsIGFkZHJlc3NJZCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICduZXR3b3JrSWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZ2V0QWRkcmVzc1JlcHV0YXRpb24nLCAnbmV0d29ya0lkJywgbmV0d29ya0lkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2FkZHJlc3NJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdnZXRBZGRyZXNzUmVwdXRhdGlvbicsICdhZGRyZXNzSWQnLCBhZGRyZXNzSWQpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS9uZXR3b3Jrcy97bmV0d29ya19pZH0vYWRkcmVzc2VzL3thZGRyZXNzX2lkfS9yZXB1dGF0aW9uYFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcIm5ldHdvcmtfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhuZXR3b3JrSWQpKSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJhZGRyZXNzX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoYWRkcmVzc0lkKSkpO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7IG1ldGhvZDogJ0dFVCcsIC4uLmJhc2VPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gYXBpS2V5IHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIkp3dFwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIHNlc3Npb24gcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0geyAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlciwgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucywgLi4ub3B0aW9ucy5oZWFkZXJzIH07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5SZXB1dGF0aW9uQXBpQXhpb3NQYXJhbUNyZWF0b3IgPSBSZXB1dGF0aW9uQXBpQXhpb3NQYXJhbUNyZWF0b3I7XG4vKipcbiAqIFJlcHV0YXRpb25BcGkgLSBmdW5jdGlvbmFsIHByb2dyYW1taW5nIGludGVyZmFjZVxuICogQGV4cG9ydFxuICovXG5jb25zdCBSZXB1dGF0aW9uQXBpRnAgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbikge1xuICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IgPSAoMCwgZXhwb3J0cy5SZXB1dGF0aW9uQXBpQXhpb3NQYXJhbUNyZWF0b3IpKGNvbmZpZ3VyYXRpb24pO1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIG9uY2hhaW4gcmVwdXRhdGlvbiBvZiBhbiBleHRlcm5hbCBhZGRyZXNzXG4gICAgICAgICAqIEBzdW1tYXJ5IEdldCB0aGUgb25jaGFpbiByZXB1dGF0aW9uIG9mIGFuIGV4dGVybmFsIGFkZHJlc3NcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5ldHdvcmtJZCBUaGUgSUQgb2YgdGhlIGJsb2NrY2hhaW4gbmV0d29yay5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdG8gZmV0Y2ggdGhlIHJlcHV0YXRpb24gZm9yLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgZ2V0QWRkcmVzc1JlcHV0YXRpb24obmV0d29ya0lkLCBhZGRyZXNzSWQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5nZXRBZGRyZXNzUmVwdXRhdGlvbihuZXR3b3JrSWQsIGFkZHJlc3NJZCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gY29uZmlndXJhdGlvbj8uc2VydmVySW5kZXggPz8gMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydSZXB1dGF0aW9uQXBpLmdldEFkZHJlc3NSZXB1dGF0aW9uJ10/Lltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XT8udXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuUmVwdXRhdGlvbkFwaUZwID0gUmVwdXRhdGlvbkFwaUZwO1xuLyoqXG4gKiBSZXB1dGF0aW9uQXBpIC0gZmFjdG9yeSBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgUmVwdXRhdGlvbkFwaUZhY3RvcnkgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbiwgYmFzZVBhdGgsIGF4aW9zKSB7XG4gICAgY29uc3QgbG9jYWxWYXJGcCA9ICgwLCBleHBvcnRzLlJlcHV0YXRpb25BcGlGcCkoY29uZmlndXJhdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgb25jaGFpbiByZXB1dGF0aW9uIG9mIGFuIGV4dGVybmFsIGFkZHJlc3NcbiAgICAgICAgICogQHN1bW1hcnkgR2V0IHRoZSBvbmNoYWluIHJlcHV0YXRpb24gb2YgYW4gZXh0ZXJuYWwgYWRkcmVzc1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29ya0lkIFRoZSBJRCBvZiB0aGUgYmxvY2tjaGFpbiBuZXR3b3JrLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0byBmZXRjaCB0aGUgcmVwdXRhdGlvbiBmb3IuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRBZGRyZXNzUmVwdXRhdGlvbihuZXR3b3JrSWQsIGFkZHJlc3NJZCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuZ2V0QWRkcmVzc1JlcHV0YXRpb24obmV0d29ya0lkLCBhZGRyZXNzSWQsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5leHBvcnRzLlJlcHV0YXRpb25BcGlGYWN0b3J5ID0gUmVwdXRhdGlvbkFwaUZhY3Rvcnk7XG4vKipcbiAqIFJlcHV0YXRpb25BcGkgLSBvYmplY3Qtb3JpZW50ZWQgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKiBAY2xhc3MgUmVwdXRhdGlvbkFwaVxuICogQGV4dGVuZHMge0Jhc2VBUEl9XG4gKi9cbmNsYXNzIFJlcHV0YXRpb25BcGkgZXh0ZW5kcyBiYXNlXzEuQmFzZUFQSSB7XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBvbmNoYWluIHJlcHV0YXRpb24gb2YgYW4gZXh0ZXJuYWwgYWRkcmVzc1xuICAgICAqIEBzdW1tYXJ5IEdldCB0aGUgb25jaGFpbiByZXB1dGF0aW9uIG9mIGFuIGV4dGVybmFsIGFkZHJlc3NcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29ya0lkIFRoZSBJRCBvZiB0aGUgYmxvY2tjaGFpbiBuZXR3b3JrLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRvIGZldGNoIHRoZSByZXB1dGF0aW9uIGZvci5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIFJlcHV0YXRpb25BcGlcbiAgICAgKi9cbiAgICBnZXRBZGRyZXNzUmVwdXRhdGlvbihuZXR3b3JrSWQsIGFkZHJlc3NJZCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuUmVwdXRhdGlvbkFwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLmdldEFkZHJlc3NSZXB1dGF0aW9uKG5ldHdvcmtJZCwgYWRkcmVzc0lkLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG59XG5leHBvcnRzLlJlcHV0YXRpb25BcGkgPSBSZXB1dGF0aW9uQXBpO1xuLyoqXG4gKiBTZXJ2ZXJTaWduZXJzQXBpIC0gYXhpb3MgcGFyYW1ldGVyIGNyZWF0b3JcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgU2VydmVyU2lnbmVyc0FwaUF4aW9zUGFyYW1DcmVhdG9yID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgbmV3IFNlcnZlci1TaWduZXJcbiAgICAgICAgICogQHN1bW1hcnkgQ3JlYXRlIGEgbmV3IFNlcnZlci1TaWduZXJcbiAgICAgICAgICogQHBhcmFtIHtDcmVhdGVTZXJ2ZXJTaWduZXJSZXF1ZXN0fSBbY3JlYXRlU2VydmVyU2lnbmVyUmVxdWVzdF1cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZVNlcnZlclNpZ25lcjogYXN5bmMgKGNyZWF0ZVNlcnZlclNpZ25lclJlcXVlc3QsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS9zZXJ2ZXJfc2lnbmVyc2A7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IHsgbWV0aG9kOiAnUE9TVCcsIC4uLmJhc2VPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gYXBpS2V5IHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIkp3dFwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IHsgLi4ubG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIC4uLmhlYWRlcnNGcm9tQmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMuaGVhZGVycyB9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5kYXRhID0gKDAsIGNvbW1vbl8xLnNlcmlhbGl6ZURhdGFJZk5lZWRlZCkoY3JlYXRlU2VydmVyU2lnbmVyUmVxdWVzdCwgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucywgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGEgc2VydmVyIHNpZ25lciBieSBJRFxuICAgICAgICAgKiBAc3VtbWFyeSBHZXQgYSBzZXJ2ZXIgc2lnbmVyIGJ5IElEXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZXJ2ZXJTaWduZXJJZCBUaGUgSUQgb2YgdGhlIHNlcnZlciBzaWduZXIgdG8gZmV0Y2hcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGdldFNlcnZlclNpZ25lcjogYXN5bmMgKHNlcnZlclNpZ25lcklkLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ3NlcnZlclNpZ25lcklkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2dldFNlcnZlclNpZ25lcicsICdzZXJ2ZXJTaWduZXJJZCcsIHNlcnZlclNpZ25lcklkKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvc2VydmVyX3NpZ25lcnMve3NlcnZlcl9zaWduZXJfaWR9YFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcInNlcnZlcl9zaWduZXJfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhzZXJ2ZXJTaWduZXJJZCkpKTtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0geyBtZXRob2Q6ICdHRVQnLCAuLi5iYXNlT3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIGFwaUtleSByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJKd3RcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBzZXNzaW9uIHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIkp3dFwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IHsgLi4ubG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIC4uLmhlYWRlcnNGcm9tQmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMuaGVhZGVycyB9O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3QgZXZlbnRzIGZvciBhIHNlcnZlciBzaWduZXJcbiAgICAgICAgICogQHN1bW1hcnkgTGlzdCBldmVudHMgZm9yIGEgc2VydmVyIHNpZ25lclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VydmVyU2lnbmVySWQgVGhlIElEIG9mIHRoZSBzZXJ2ZXIgc2lnbmVyIHRvIGZldGNoIGV2ZW50cyBmb3JcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gQSBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIG9iamVjdHMgdG8gYmUgcmV0dXJuZWQuIExpbWl0IGNhbiByYW5nZSBiZXR3ZWVuIDEgYW5kIDEwMCwgYW5kIHRoZSBkZWZhdWx0IGlzIDEwLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VdIEEgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiByZXN1bHRzLiBEb25cXCYjMzk7dCBpbmNsdWRlIHRoaXMgcGFyYW1ldGVyIG9uIHRoZSBmaXJzdCBjYWxsLiBVc2UgdGhlIG5leHRfcGFnZSB2YWx1ZSByZXR1cm5lZCBpbiBhIHByZXZpb3VzIHJlc3BvbnNlIHRvIHJlcXVlc3Qgc3Vic2VxdWVudCByZXN1bHRzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgbGlzdFNlcnZlclNpZ25lckV2ZW50czogYXN5bmMgKHNlcnZlclNpZ25lcklkLCBsaW1pdCwgcGFnZSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdzZXJ2ZXJTaWduZXJJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdsaXN0U2VydmVyU2lnbmVyRXZlbnRzJywgJ3NlcnZlclNpZ25lcklkJywgc2VydmVyU2lnbmVySWQpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS9zZXJ2ZXJfc2lnbmVycy97c2VydmVyX3NpZ25lcl9pZH0vZXZlbnRzYFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcInNlcnZlcl9zaWduZXJfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhzZXJ2ZXJTaWduZXJJZCkpKTtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0geyBtZXRob2Q6ICdHRVQnLCAuLi5iYXNlT3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIGFwaUtleSByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJKd3RcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBpZiAobGltaXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ2xpbWl0J10gPSBsaW1pdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydwYWdlJ10gPSBwYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0geyAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlciwgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucywgLi4ub3B0aW9ucy5oZWFkZXJzIH07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdCBzZXJ2ZXIgc2lnbmVycyBmb3IgdGhlIGN1cnJlbnQgcHJvamVjdFxuICAgICAgICAgKiBAc3VtbWFyeSBMaXN0IHNlcnZlciBzaWduZXJzIGZvciB0aGUgY3VycmVudCBwcm9qZWN0XG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIEEgbGltaXQgb24gdGhlIG51bWJlciBvZiBvYmplY3RzIHRvIGJlIHJldHVybmVkLiBMaW1pdCBjYW4gcmFuZ2UgYmV0d2VlbiAxIGFuZCAxMDAsIGFuZCB0aGUgZGVmYXVsdCBpcyAxMC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlXSBBIGN1cnNvciBmb3IgcGFnaW5hdGlvbiBhY3Jvc3MgbXVsdGlwbGUgcGFnZXMgb2YgcmVzdWx0cy4gRG9uXFwmIzM5O3QgaW5jbHVkZSB0aGlzIHBhcmFtZXRlciBvbiB0aGUgZmlyc3QgY2FsbC4gVXNlIHRoZSBuZXh0X3BhZ2UgdmFsdWUgcmV0dXJuZWQgaW4gYSBwcmV2aW91cyByZXNwb25zZSB0byByZXF1ZXN0IHN1YnNlcXVlbnQgcmVzdWx0cy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGxpc3RTZXJ2ZXJTaWduZXJzOiBhc3luYyAobGltaXQsIHBhZ2UsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS9zZXJ2ZXJfc2lnbmVyc2A7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IHsgbWV0aG9kOiAnR0VUJywgLi4uYmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBhcGlLZXkgcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gc2Vzc2lvbiByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJKd3RcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBpZiAobGltaXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ2xpbWl0J10gPSBsaW1pdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydwYWdlJ10gPSBwYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0geyAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlciwgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucywgLi4ub3B0aW9ucy5oZWFkZXJzIH07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogU3VibWl0IHRoZSByZXN1bHQgb2YgYSBzZXJ2ZXIgc2lnbmVyIGV2ZW50XG4gICAgICAgICAqIEBzdW1tYXJ5IFN1Ym1pdCB0aGUgcmVzdWx0IG9mIGEgc2VydmVyIHNpZ25lciBldmVudFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VydmVyU2lnbmVySWQgVGhlIElEIG9mIHRoZSBzZXJ2ZXIgc2lnbmVyIHRvIHN1Ym1pdCB0aGUgZXZlbnQgcmVzdWx0IGZvclxuICAgICAgICAgKiBAcGFyYW0ge1NlZWRDcmVhdGlvbkV2ZW50UmVzdWx0fSBbc2VlZENyZWF0aW9uRXZlbnRSZXN1bHRdXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBzdWJtaXRTZXJ2ZXJTaWduZXJTZWVkRXZlbnRSZXN1bHQ6IGFzeW5jIChzZXJ2ZXJTaWduZXJJZCwgc2VlZENyZWF0aW9uRXZlbnRSZXN1bHQsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnc2VydmVyU2lnbmVySWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnc3VibWl0U2VydmVyU2lnbmVyU2VlZEV2ZW50UmVzdWx0JywgJ3NlcnZlclNpZ25lcklkJywgc2VydmVyU2lnbmVySWQpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS9zZXJ2ZXJfc2lnbmVycy97c2VydmVyX3NpZ25lcl9pZH0vc2VlZF9ldmVudF9yZXN1bHRgXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wic2VydmVyX3NpZ25lcl9pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHNlcnZlclNpZ25lcklkKSkpO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7IG1ldGhvZDogJ1BPU1QnLCAuLi5iYXNlT3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIGFwaUtleSByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJKd3RcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBsb2NhbFZhckhlYWRlclBhcmFtZXRlclsnQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSB7IC4uLmxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCAuLi5oZWFkZXJzRnJvbUJhc2VPcHRpb25zLCAuLi5vcHRpb25zLmhlYWRlcnMgfTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuZGF0YSA9ICgwLCBjb21tb25fMS5zZXJpYWxpemVEYXRhSWZOZWVkZWQpKHNlZWRDcmVhdGlvbkV2ZW50UmVzdWx0LCBsb2NhbFZhclJlcXVlc3RPcHRpb25zLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdWJtaXQgdGhlIHJlc3VsdCBvZiBhIHNlcnZlciBzaWduZXIgZXZlbnRcbiAgICAgICAgICogQHN1bW1hcnkgU3VibWl0IHRoZSByZXN1bHQgb2YgYSBzZXJ2ZXIgc2lnbmVyIGV2ZW50XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZXJ2ZXJTaWduZXJJZCBUaGUgSUQgb2YgdGhlIHNlcnZlciBzaWduZXIgdG8gc3VibWl0IHRoZSBldmVudCByZXN1bHQgZm9yXG4gICAgICAgICAqIEBwYXJhbSB7U2lnbmF0dXJlQ3JlYXRpb25FdmVudFJlc3VsdH0gW3NpZ25hdHVyZUNyZWF0aW9uRXZlbnRSZXN1bHRdXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBzdWJtaXRTZXJ2ZXJTaWduZXJTaWduYXR1cmVFdmVudFJlc3VsdDogYXN5bmMgKHNlcnZlclNpZ25lcklkLCBzaWduYXR1cmVDcmVhdGlvbkV2ZW50UmVzdWx0LCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ3NlcnZlclNpZ25lcklkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ3N1Ym1pdFNlcnZlclNpZ25lclNpZ25hdHVyZUV2ZW50UmVzdWx0JywgJ3NlcnZlclNpZ25lcklkJywgc2VydmVyU2lnbmVySWQpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS9zZXJ2ZXJfc2lnbmVycy97c2VydmVyX3NpZ25lcl9pZH0vc2lnbmF0dXJlX2V2ZW50X3Jlc3VsdGBcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJzZXJ2ZXJfc2lnbmVyX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoc2VydmVyU2lnbmVySWQpKSk7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IHsgbWV0aG9kOiAnUE9TVCcsIC4uLmJhc2VPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gYXBpS2V5IHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIkp3dFwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IHsgLi4ubG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIC4uLmhlYWRlcnNGcm9tQmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMuaGVhZGVycyB9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5kYXRhID0gKDAsIGNvbW1vbl8xLnNlcmlhbGl6ZURhdGFJZk5lZWRlZCkoc2lnbmF0dXJlQ3JlYXRpb25FdmVudFJlc3VsdCwgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucywgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5TZXJ2ZXJTaWduZXJzQXBpQXhpb3NQYXJhbUNyZWF0b3IgPSBTZXJ2ZXJTaWduZXJzQXBpQXhpb3NQYXJhbUNyZWF0b3I7XG4vKipcbiAqIFNlcnZlclNpZ25lcnNBcGkgLSBmdW5jdGlvbmFsIHByb2dyYW1taW5nIGludGVyZmFjZVxuICogQGV4cG9ydFxuICovXG5jb25zdCBTZXJ2ZXJTaWduZXJzQXBpRnAgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbikge1xuICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IgPSAoMCwgZXhwb3J0cy5TZXJ2ZXJTaWduZXJzQXBpQXhpb3NQYXJhbUNyZWF0b3IpKGNvbmZpZ3VyYXRpb24pO1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSBuZXcgU2VydmVyLVNpZ25lclxuICAgICAgICAgKiBAc3VtbWFyeSBDcmVhdGUgYSBuZXcgU2VydmVyLVNpZ25lclxuICAgICAgICAgKiBAcGFyYW0ge0NyZWF0ZVNlcnZlclNpZ25lclJlcXVlc3R9IFtjcmVhdGVTZXJ2ZXJTaWduZXJSZXF1ZXN0XVxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgY3JlYXRlU2VydmVyU2lnbmVyKGNyZWF0ZVNlcnZlclNpZ25lclJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5jcmVhdGVTZXJ2ZXJTaWduZXIoY3JlYXRlU2VydmVyU2lnbmVyUmVxdWVzdCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gY29uZmlndXJhdGlvbj8uc2VydmVySW5kZXggPz8gMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydTZXJ2ZXJTaWduZXJzQXBpLmNyZWF0ZVNlcnZlclNpZ25lciddPy5bbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0/LnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgYSBzZXJ2ZXIgc2lnbmVyIGJ5IElEXG4gICAgICAgICAqIEBzdW1tYXJ5IEdldCBhIHNlcnZlciBzaWduZXIgYnkgSURcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHNlcnZlclNpZ25lcklkIFRoZSBJRCBvZiB0aGUgc2VydmVyIHNpZ25lciB0byBmZXRjaFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgZ2V0U2VydmVyU2lnbmVyKHNlcnZlclNpZ25lcklkLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuZ2V0U2VydmVyU2lnbmVyKHNlcnZlclNpZ25lcklkLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSBjb25maWd1cmF0aW9uPy5zZXJ2ZXJJbmRleCA/PyAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ1NlcnZlclNpZ25lcnNBcGkuZ2V0U2VydmVyU2lnbmVyJ10/Lltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XT8udXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3QgZXZlbnRzIGZvciBhIHNlcnZlciBzaWduZXJcbiAgICAgICAgICogQHN1bW1hcnkgTGlzdCBldmVudHMgZm9yIGEgc2VydmVyIHNpZ25lclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VydmVyU2lnbmVySWQgVGhlIElEIG9mIHRoZSBzZXJ2ZXIgc2lnbmVyIHRvIGZldGNoIGV2ZW50cyBmb3JcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gQSBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIG9iamVjdHMgdG8gYmUgcmV0dXJuZWQuIExpbWl0IGNhbiByYW5nZSBiZXR3ZWVuIDEgYW5kIDEwMCwgYW5kIHRoZSBkZWZhdWx0IGlzIDEwLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VdIEEgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiByZXN1bHRzLiBEb25cXCYjMzk7dCBpbmNsdWRlIHRoaXMgcGFyYW1ldGVyIG9uIHRoZSBmaXJzdCBjYWxsLiBVc2UgdGhlIG5leHRfcGFnZSB2YWx1ZSByZXR1cm5lZCBpbiBhIHByZXZpb3VzIHJlc3BvbnNlIHRvIHJlcXVlc3Qgc3Vic2VxdWVudCByZXN1bHRzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgbGlzdFNlcnZlclNpZ25lckV2ZW50cyhzZXJ2ZXJTaWduZXJJZCwgbGltaXQsIHBhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5saXN0U2VydmVyU2lnbmVyRXZlbnRzKHNlcnZlclNpZ25lcklkLCBsaW1pdCwgcGFnZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gY29uZmlndXJhdGlvbj8uc2VydmVySW5kZXggPz8gMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydTZXJ2ZXJTaWduZXJzQXBpLmxpc3RTZXJ2ZXJTaWduZXJFdmVudHMnXT8uW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdPy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdCBzZXJ2ZXIgc2lnbmVycyBmb3IgdGhlIGN1cnJlbnQgcHJvamVjdFxuICAgICAgICAgKiBAc3VtbWFyeSBMaXN0IHNlcnZlciBzaWduZXJzIGZvciB0aGUgY3VycmVudCBwcm9qZWN0XG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIEEgbGltaXQgb24gdGhlIG51bWJlciBvZiBvYmplY3RzIHRvIGJlIHJldHVybmVkLiBMaW1pdCBjYW4gcmFuZ2UgYmV0d2VlbiAxIGFuZCAxMDAsIGFuZCB0aGUgZGVmYXVsdCBpcyAxMC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlXSBBIGN1cnNvciBmb3IgcGFnaW5hdGlvbiBhY3Jvc3MgbXVsdGlwbGUgcGFnZXMgb2YgcmVzdWx0cy4gRG9uXFwmIzM5O3QgaW5jbHVkZSB0aGlzIHBhcmFtZXRlciBvbiB0aGUgZmlyc3QgY2FsbC4gVXNlIHRoZSBuZXh0X3BhZ2UgdmFsdWUgcmV0dXJuZWQgaW4gYSBwcmV2aW91cyByZXNwb25zZSB0byByZXF1ZXN0IHN1YnNlcXVlbnQgcmVzdWx0cy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGxpc3RTZXJ2ZXJTaWduZXJzKGxpbWl0LCBwYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IubGlzdFNlcnZlclNpZ25lcnMobGltaXQsIHBhZ2UsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IGNvbmZpZ3VyYXRpb24/LnNlcnZlckluZGV4ID8/IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnU2VydmVyU2lnbmVyc0FwaS5saXN0U2VydmVyU2lnbmVycyddPy5bbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0/LnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdWJtaXQgdGhlIHJlc3VsdCBvZiBhIHNlcnZlciBzaWduZXIgZXZlbnRcbiAgICAgICAgICogQHN1bW1hcnkgU3VibWl0IHRoZSByZXN1bHQgb2YgYSBzZXJ2ZXIgc2lnbmVyIGV2ZW50XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZXJ2ZXJTaWduZXJJZCBUaGUgSUQgb2YgdGhlIHNlcnZlciBzaWduZXIgdG8gc3VibWl0IHRoZSBldmVudCByZXN1bHQgZm9yXG4gICAgICAgICAqIEBwYXJhbSB7U2VlZENyZWF0aW9uRXZlbnRSZXN1bHR9IFtzZWVkQ3JlYXRpb25FdmVudFJlc3VsdF1cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIHN1Ym1pdFNlcnZlclNpZ25lclNlZWRFdmVudFJlc3VsdChzZXJ2ZXJTaWduZXJJZCwgc2VlZENyZWF0aW9uRXZlbnRSZXN1bHQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5zdWJtaXRTZXJ2ZXJTaWduZXJTZWVkRXZlbnRSZXN1bHQoc2VydmVyU2lnbmVySWQsIHNlZWRDcmVhdGlvbkV2ZW50UmVzdWx0LCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSBjb25maWd1cmF0aW9uPy5zZXJ2ZXJJbmRleCA/PyAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ1NlcnZlclNpZ25lcnNBcGkuc3VibWl0U2VydmVyU2lnbmVyU2VlZEV2ZW50UmVzdWx0J10/Lltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XT8udXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN1Ym1pdCB0aGUgcmVzdWx0IG9mIGEgc2VydmVyIHNpZ25lciBldmVudFxuICAgICAgICAgKiBAc3VtbWFyeSBTdWJtaXQgdGhlIHJlc3VsdCBvZiBhIHNlcnZlciBzaWduZXIgZXZlbnRcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHNlcnZlclNpZ25lcklkIFRoZSBJRCBvZiB0aGUgc2VydmVyIHNpZ25lciB0byBzdWJtaXQgdGhlIGV2ZW50IHJlc3VsdCBmb3JcbiAgICAgICAgICogQHBhcmFtIHtTaWduYXR1cmVDcmVhdGlvbkV2ZW50UmVzdWx0fSBbc2lnbmF0dXJlQ3JlYXRpb25FdmVudFJlc3VsdF1cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIHN1Ym1pdFNlcnZlclNpZ25lclNpZ25hdHVyZUV2ZW50UmVzdWx0KHNlcnZlclNpZ25lcklkLCBzaWduYXR1cmVDcmVhdGlvbkV2ZW50UmVzdWx0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3Iuc3VibWl0U2VydmVyU2lnbmVyU2lnbmF0dXJlRXZlbnRSZXN1bHQoc2VydmVyU2lnbmVySWQsIHNpZ25hdHVyZUNyZWF0aW9uRXZlbnRSZXN1bHQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IGNvbmZpZ3VyYXRpb24/LnNlcnZlckluZGV4ID8/IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnU2VydmVyU2lnbmVyc0FwaS5zdWJtaXRTZXJ2ZXJTaWduZXJTaWduYXR1cmVFdmVudFJlc3VsdCddPy5bbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0/LnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5leHBvcnRzLlNlcnZlclNpZ25lcnNBcGlGcCA9IFNlcnZlclNpZ25lcnNBcGlGcDtcbi8qKlxuICogU2VydmVyU2lnbmVyc0FwaSAtIGZhY3RvcnkgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IFNlcnZlclNpZ25lcnNBcGlGYWN0b3J5ID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24sIGJhc2VQYXRoLCBheGlvcykge1xuICAgIGNvbnN0IGxvY2FsVmFyRnAgPSAoMCwgZXhwb3J0cy5TZXJ2ZXJTaWduZXJzQXBpRnApKGNvbmZpZ3VyYXRpb24pO1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSBuZXcgU2VydmVyLVNpZ25lclxuICAgICAgICAgKiBAc3VtbWFyeSBDcmVhdGUgYSBuZXcgU2VydmVyLVNpZ25lclxuICAgICAgICAgKiBAcGFyYW0ge0NyZWF0ZVNlcnZlclNpZ25lclJlcXVlc3R9IFtjcmVhdGVTZXJ2ZXJTaWduZXJSZXF1ZXN0XVxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgY3JlYXRlU2VydmVyU2lnbmVyKGNyZWF0ZVNlcnZlclNpZ25lclJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmNyZWF0ZVNlcnZlclNpZ25lcihjcmVhdGVTZXJ2ZXJTaWduZXJSZXF1ZXN0LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGEgc2VydmVyIHNpZ25lciBieSBJRFxuICAgICAgICAgKiBAc3VtbWFyeSBHZXQgYSBzZXJ2ZXIgc2lnbmVyIGJ5IElEXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZXJ2ZXJTaWduZXJJZCBUaGUgSUQgb2YgdGhlIHNlcnZlciBzaWduZXIgdG8gZmV0Y2hcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGdldFNlcnZlclNpZ25lcihzZXJ2ZXJTaWduZXJJZCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuZ2V0U2VydmVyU2lnbmVyKHNlcnZlclNpZ25lcklkLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdCBldmVudHMgZm9yIGEgc2VydmVyIHNpZ25lclxuICAgICAgICAgKiBAc3VtbWFyeSBMaXN0IGV2ZW50cyBmb3IgYSBzZXJ2ZXIgc2lnbmVyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZXJ2ZXJTaWduZXJJZCBUaGUgSUQgb2YgdGhlIHNlcnZlciBzaWduZXIgdG8gZmV0Y2ggZXZlbnRzIGZvclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBBIGxpbWl0IG9uIHRoZSBudW1iZXIgb2Ygb2JqZWN0cyB0byBiZSByZXR1cm5lZC4gTGltaXQgY2FuIHJhbmdlIGJldHdlZW4gMSBhbmQgMTAwLCBhbmQgdGhlIGRlZmF1bHQgaXMgMTAuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZV0gQSBjdXJzb3IgZm9yIHBhZ2luYXRpb24gYWNyb3NzIG11bHRpcGxlIHBhZ2VzIG9mIHJlc3VsdHMuIERvblxcJiMzOTt0IGluY2x1ZGUgdGhpcyBwYXJhbWV0ZXIgb24gdGhlIGZpcnN0IGNhbGwuIFVzZSB0aGUgbmV4dF9wYWdlIHZhbHVlIHJldHVybmVkIGluIGEgcHJldmlvdXMgcmVzcG9uc2UgdG8gcmVxdWVzdCBzdWJzZXF1ZW50IHJlc3VsdHMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEBkZXByZWNhdGVkXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBsaXN0U2VydmVyU2lnbmVyRXZlbnRzKHNlcnZlclNpZ25lcklkLCBsaW1pdCwgcGFnZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAubGlzdFNlcnZlclNpZ25lckV2ZW50cyhzZXJ2ZXJTaWduZXJJZCwgbGltaXQsIHBhZ2UsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0IHNlcnZlciBzaWduZXJzIGZvciB0aGUgY3VycmVudCBwcm9qZWN0XG4gICAgICAgICAqIEBzdW1tYXJ5IExpc3Qgc2VydmVyIHNpZ25lcnMgZm9yIHRoZSBjdXJyZW50IHByb2plY3RcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gQSBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIG9iamVjdHMgdG8gYmUgcmV0dXJuZWQuIExpbWl0IGNhbiByYW5nZSBiZXR3ZWVuIDEgYW5kIDEwMCwgYW5kIHRoZSBkZWZhdWx0IGlzIDEwLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VdIEEgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiByZXN1bHRzLiBEb25cXCYjMzk7dCBpbmNsdWRlIHRoaXMgcGFyYW1ldGVyIG9uIHRoZSBmaXJzdCBjYWxsLiBVc2UgdGhlIG5leHRfcGFnZSB2YWx1ZSByZXR1cm5lZCBpbiBhIHByZXZpb3VzIHJlc3BvbnNlIHRvIHJlcXVlc3Qgc3Vic2VxdWVudCByZXN1bHRzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgbGlzdFNlcnZlclNpZ25lcnMobGltaXQsIHBhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmxpc3RTZXJ2ZXJTaWduZXJzKGxpbWl0LCBwYWdlLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogU3VibWl0IHRoZSByZXN1bHQgb2YgYSBzZXJ2ZXIgc2lnbmVyIGV2ZW50XG4gICAgICAgICAqIEBzdW1tYXJ5IFN1Ym1pdCB0aGUgcmVzdWx0IG9mIGEgc2VydmVyIHNpZ25lciBldmVudFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VydmVyU2lnbmVySWQgVGhlIElEIG9mIHRoZSBzZXJ2ZXIgc2lnbmVyIHRvIHN1Ym1pdCB0aGUgZXZlbnQgcmVzdWx0IGZvclxuICAgICAgICAgKiBAcGFyYW0ge1NlZWRDcmVhdGlvbkV2ZW50UmVzdWx0fSBbc2VlZENyZWF0aW9uRXZlbnRSZXN1bHRdXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBzdWJtaXRTZXJ2ZXJTaWduZXJTZWVkRXZlbnRSZXN1bHQoc2VydmVyU2lnbmVySWQsIHNlZWRDcmVhdGlvbkV2ZW50UmVzdWx0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5zdWJtaXRTZXJ2ZXJTaWduZXJTZWVkRXZlbnRSZXN1bHQoc2VydmVyU2lnbmVySWQsIHNlZWRDcmVhdGlvbkV2ZW50UmVzdWx0LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogU3VibWl0IHRoZSByZXN1bHQgb2YgYSBzZXJ2ZXIgc2lnbmVyIGV2ZW50XG4gICAgICAgICAqIEBzdW1tYXJ5IFN1Ym1pdCB0aGUgcmVzdWx0IG9mIGEgc2VydmVyIHNpZ25lciBldmVudFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VydmVyU2lnbmVySWQgVGhlIElEIG9mIHRoZSBzZXJ2ZXIgc2lnbmVyIHRvIHN1Ym1pdCB0aGUgZXZlbnQgcmVzdWx0IGZvclxuICAgICAgICAgKiBAcGFyYW0ge1NpZ25hdHVyZUNyZWF0aW9uRXZlbnRSZXN1bHR9IFtzaWduYXR1cmVDcmVhdGlvbkV2ZW50UmVzdWx0XVxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgc3VibWl0U2VydmVyU2lnbmVyU2lnbmF0dXJlRXZlbnRSZXN1bHQoc2VydmVyU2lnbmVySWQsIHNpZ25hdHVyZUNyZWF0aW9uRXZlbnRSZXN1bHQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLnN1Ym1pdFNlcnZlclNpZ25lclNpZ25hdHVyZUV2ZW50UmVzdWx0KHNlcnZlclNpZ25lcklkLCBzaWduYXR1cmVDcmVhdGlvbkV2ZW50UmVzdWx0LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5TZXJ2ZXJTaWduZXJzQXBpRmFjdG9yeSA9IFNlcnZlclNpZ25lcnNBcGlGYWN0b3J5O1xuLyoqXG4gKiBTZXJ2ZXJTaWduZXJzQXBpIC0gb2JqZWN0LW9yaWVudGVkIGludGVyZmFjZVxuICogQGV4cG9ydFxuICogQGNsYXNzIFNlcnZlclNpZ25lcnNBcGlcbiAqIEBleHRlbmRzIHtCYXNlQVBJfVxuICovXG5jbGFzcyBTZXJ2ZXJTaWduZXJzQXBpIGV4dGVuZHMgYmFzZV8xLkJhc2VBUEkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBTZXJ2ZXItU2lnbmVyXG4gICAgICogQHN1bW1hcnkgQ3JlYXRlIGEgbmV3IFNlcnZlci1TaWduZXJcbiAgICAgKiBAcGFyYW0ge0NyZWF0ZVNlcnZlclNpZ25lclJlcXVlc3R9IFtjcmVhdGVTZXJ2ZXJTaWduZXJSZXF1ZXN0XVxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgU2VydmVyU2lnbmVyc0FwaVxuICAgICAqL1xuICAgIGNyZWF0ZVNlcnZlclNpZ25lcihjcmVhdGVTZXJ2ZXJTaWduZXJSZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5TZXJ2ZXJTaWduZXJzQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuY3JlYXRlU2VydmVyU2lnbmVyKGNyZWF0ZVNlcnZlclNpZ25lclJlcXVlc3QsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYSBzZXJ2ZXIgc2lnbmVyIGJ5IElEXG4gICAgICogQHN1bW1hcnkgR2V0IGEgc2VydmVyIHNpZ25lciBieSBJRFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZXJ2ZXJTaWduZXJJZCBUaGUgSUQgb2YgdGhlIHNlcnZlciBzaWduZXIgdG8gZmV0Y2hcbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIFNlcnZlclNpZ25lcnNBcGlcbiAgICAgKi9cbiAgICBnZXRTZXJ2ZXJTaWduZXIoc2VydmVyU2lnbmVySWQsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLlNlcnZlclNpZ25lcnNBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5nZXRTZXJ2ZXJTaWduZXIoc2VydmVyU2lnbmVySWQsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0IGV2ZW50cyBmb3IgYSBzZXJ2ZXIgc2lnbmVyXG4gICAgICogQHN1bW1hcnkgTGlzdCBldmVudHMgZm9yIGEgc2VydmVyIHNpZ25lclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZXJ2ZXJTaWduZXJJZCBUaGUgSUQgb2YgdGhlIHNlcnZlciBzaWduZXIgdG8gZmV0Y2ggZXZlbnRzIGZvclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIEEgbGltaXQgb24gdGhlIG51bWJlciBvZiBvYmplY3RzIHRvIGJlIHJldHVybmVkLiBMaW1pdCBjYW4gcmFuZ2UgYmV0d2VlbiAxIGFuZCAxMDAsIGFuZCB0aGUgZGVmYXVsdCBpcyAxMC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VdIEEgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiByZXN1bHRzLiBEb25cXCYjMzk7dCBpbmNsdWRlIHRoaXMgcGFyYW1ldGVyIG9uIHRoZSBmaXJzdCBjYWxsLiBVc2UgdGhlIG5leHRfcGFnZSB2YWx1ZSByZXR1cm5lZCBpbiBhIHByZXZpb3VzIHJlc3BvbnNlIHRvIHJlcXVlc3Qgc3Vic2VxdWVudCByZXN1bHRzLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBTZXJ2ZXJTaWduZXJzQXBpXG4gICAgICovXG4gICAgbGlzdFNlcnZlclNpZ25lckV2ZW50cyhzZXJ2ZXJTaWduZXJJZCwgbGltaXQsIHBhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLlNlcnZlclNpZ25lcnNBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5saXN0U2VydmVyU2lnbmVyRXZlbnRzKHNlcnZlclNpZ25lcklkLCBsaW1pdCwgcGFnZSwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3Qgc2VydmVyIHNpZ25lcnMgZm9yIHRoZSBjdXJyZW50IHByb2plY3RcbiAgICAgKiBAc3VtbWFyeSBMaXN0IHNlcnZlciBzaWduZXJzIGZvciB0aGUgY3VycmVudCBwcm9qZWN0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gQSBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIG9iamVjdHMgdG8gYmUgcmV0dXJuZWQuIExpbWl0IGNhbiByYW5nZSBiZXR3ZWVuIDEgYW5kIDEwMCwgYW5kIHRoZSBkZWZhdWx0IGlzIDEwLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZV0gQSBjdXJzb3IgZm9yIHBhZ2luYXRpb24gYWNyb3NzIG11bHRpcGxlIHBhZ2VzIG9mIHJlc3VsdHMuIERvblxcJiMzOTt0IGluY2x1ZGUgdGhpcyBwYXJhbWV0ZXIgb24gdGhlIGZpcnN0IGNhbGwuIFVzZSB0aGUgbmV4dF9wYWdlIHZhbHVlIHJldHVybmVkIGluIGEgcHJldmlvdXMgcmVzcG9uc2UgdG8gcmVxdWVzdCBzdWJzZXF1ZW50IHJlc3VsdHMuXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBTZXJ2ZXJTaWduZXJzQXBpXG4gICAgICovXG4gICAgbGlzdFNlcnZlclNpZ25lcnMobGltaXQsIHBhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLlNlcnZlclNpZ25lcnNBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5saXN0U2VydmVyU2lnbmVycyhsaW1pdCwgcGFnZSwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN1Ym1pdCB0aGUgcmVzdWx0IG9mIGEgc2VydmVyIHNpZ25lciBldmVudFxuICAgICAqIEBzdW1tYXJ5IFN1Ym1pdCB0aGUgcmVzdWx0IG9mIGEgc2VydmVyIHNpZ25lciBldmVudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZXJ2ZXJTaWduZXJJZCBUaGUgSUQgb2YgdGhlIHNlcnZlciBzaWduZXIgdG8gc3VibWl0IHRoZSBldmVudCByZXN1bHQgZm9yXG4gICAgICogQHBhcmFtIHtTZWVkQ3JlYXRpb25FdmVudFJlc3VsdH0gW3NlZWRDcmVhdGlvbkV2ZW50UmVzdWx0XVxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgU2VydmVyU2lnbmVyc0FwaVxuICAgICAqL1xuICAgIHN1Ym1pdFNlcnZlclNpZ25lclNlZWRFdmVudFJlc3VsdChzZXJ2ZXJTaWduZXJJZCwgc2VlZENyZWF0aW9uRXZlbnRSZXN1bHQsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLlNlcnZlclNpZ25lcnNBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5zdWJtaXRTZXJ2ZXJTaWduZXJTZWVkRXZlbnRSZXN1bHQoc2VydmVyU2lnbmVySWQsIHNlZWRDcmVhdGlvbkV2ZW50UmVzdWx0LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3VibWl0IHRoZSByZXN1bHQgb2YgYSBzZXJ2ZXIgc2lnbmVyIGV2ZW50XG4gICAgICogQHN1bW1hcnkgU3VibWl0IHRoZSByZXN1bHQgb2YgYSBzZXJ2ZXIgc2lnbmVyIGV2ZW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNlcnZlclNpZ25lcklkIFRoZSBJRCBvZiB0aGUgc2VydmVyIHNpZ25lciB0byBzdWJtaXQgdGhlIGV2ZW50IHJlc3VsdCBmb3JcbiAgICAgKiBAcGFyYW0ge1NpZ25hdHVyZUNyZWF0aW9uRXZlbnRSZXN1bHR9IFtzaWduYXR1cmVDcmVhdGlvbkV2ZW50UmVzdWx0XVxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgU2VydmVyU2lnbmVyc0FwaVxuICAgICAqL1xuICAgIHN1Ym1pdFNlcnZlclNpZ25lclNpZ25hdHVyZUV2ZW50UmVzdWx0KHNlcnZlclNpZ25lcklkLCBzaWduYXR1cmVDcmVhdGlvbkV2ZW50UmVzdWx0LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5TZXJ2ZXJTaWduZXJzQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuc3VibWl0U2VydmVyU2lnbmVyU2lnbmF0dXJlRXZlbnRSZXN1bHQoc2VydmVyU2lnbmVySWQsIHNpZ25hdHVyZUNyZWF0aW9uRXZlbnRSZXN1bHQsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuU2VydmVyU2lnbmVyc0FwaSA9IFNlcnZlclNpZ25lcnNBcGk7XG4vKipcbiAqIFNtYXJ0Q29udHJhY3RzQXBpIC0gYXhpb3MgcGFyYW1ldGVyIGNyZWF0b3JcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgU21hcnRDb250cmFjdHNBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbXBpbGUgYSBzbWFydCBjb250cmFjdFxuICAgICAgICAgKiBAc3VtbWFyeSBDb21waWxlIGEgc21hcnQgY29udHJhY3RcbiAgICAgICAgICogQHBhcmFtIHtDb21waWxlU21hcnRDb250cmFjdFJlcXVlc3R9IGNvbXBpbGVTbWFydENvbnRyYWN0UmVxdWVzdFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgY29tcGlsZVNtYXJ0Q29udHJhY3Q6IGFzeW5jIChjb21waWxlU21hcnRDb250cmFjdFJlcXVlc3QsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnY29tcGlsZVNtYXJ0Q29udHJhY3RSZXF1ZXN0JyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2NvbXBpbGVTbWFydENvbnRyYWN0JywgJ2NvbXBpbGVTbWFydENvbnRyYWN0UmVxdWVzdCcsIGNvbXBpbGVTbWFydENvbnRyYWN0UmVxdWVzdCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL3NtYXJ0X2NvbnRyYWN0cy9jb21waWxlYDtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0geyBtZXRob2Q6ICdQT1NUJywgLi4uYmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBhcGlLZXkgcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXJbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0geyAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlciwgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucywgLi4ub3B0aW9ucy5oZWFkZXJzIH07XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmRhdGEgPSAoMCwgY29tbW9uXzEuc2VyaWFsaXplRGF0YUlmTmVlZGVkKShjb21waWxlU21hcnRDb250cmFjdFJlcXVlc3QsIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIG5ldyBzbWFydCBjb250cmFjdFxuICAgICAgICAgKiBAc3VtbWFyeSBDcmVhdGUgYSBuZXcgc21hcnQgY29udHJhY3RcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRvIGRlcGxveSB0aGUgc21hcnQgY29udHJhY3QgZnJvbS5cbiAgICAgICAgICogQHBhcmFtIHtDcmVhdGVTbWFydENvbnRyYWN0UmVxdWVzdH0gY3JlYXRlU21hcnRDb250cmFjdFJlcXVlc3RcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZVNtYXJ0Q29udHJhY3Q6IGFzeW5jICh3YWxsZXRJZCwgYWRkcmVzc0lkLCBjcmVhdGVTbWFydENvbnRyYWN0UmVxdWVzdCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICd3YWxsZXRJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdjcmVhdGVTbWFydENvbnRyYWN0JywgJ3dhbGxldElkJywgd2FsbGV0SWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnYWRkcmVzc0lkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2NyZWF0ZVNtYXJ0Q29udHJhY3QnLCAnYWRkcmVzc0lkJywgYWRkcmVzc0lkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2NyZWF0ZVNtYXJ0Q29udHJhY3RSZXF1ZXN0JyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2NyZWF0ZVNtYXJ0Q29udHJhY3QnLCAnY3JlYXRlU21hcnRDb250cmFjdFJlcXVlc3QnLCBjcmVhdGVTbWFydENvbnRyYWN0UmVxdWVzdCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL3dhbGxldHMve3dhbGxldF9pZH0vYWRkcmVzc2VzL3thZGRyZXNzX2lkfS9zbWFydF9jb250cmFjdHNgXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wid2FsbGV0X2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcod2FsbGV0SWQpKSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJhZGRyZXNzX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoYWRkcmVzc0lkKSkpO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7IG1ldGhvZDogJ1BPU1QnLCAuLi5iYXNlT3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIGFwaUtleSByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJKd3RcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBsb2NhbFZhckhlYWRlclBhcmFtZXRlclsnQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSB7IC4uLmxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCAuLi5oZWFkZXJzRnJvbUJhc2VPcHRpb25zLCAuLi5vcHRpb25zLmhlYWRlcnMgfTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuZGF0YSA9ICgwLCBjb21tb25fMS5zZXJpYWxpemVEYXRhSWZOZWVkZWQpKGNyZWF0ZVNtYXJ0Q29udHJhY3RSZXF1ZXN0LCBsb2NhbFZhclJlcXVlc3RPcHRpb25zLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXBsb3lzIGEgc21hcnQgY29udHJhY3QsIGJ5IGJyb2FkY2FzdGluZyB0aGUgdHJhbnNhY3Rpb24gdG8gdGhlIG5ldHdvcmsuXG4gICAgICAgICAqIEBzdW1tYXJ5IERlcGxveSBhIHNtYXJ0IGNvbnRyYWN0XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0byBicm9hZGNhc3QgdGhlIHRyYW5zYWN0aW9uIGZyb20uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzbWFydENvbnRyYWN0SWQgVGhlIFVVSUQgb2YgdGhlIHNtYXJ0IGNvbnRyYWN0IHRvIGJyb2FkY2FzdCB0aGUgdHJhbnNhY3Rpb24gdG8uXG4gICAgICAgICAqIEBwYXJhbSB7RGVwbG95U21hcnRDb250cmFjdFJlcXVlc3R9IGRlcGxveVNtYXJ0Q29udHJhY3RSZXF1ZXN0XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBkZXBsb3lTbWFydENvbnRyYWN0OiBhc3luYyAod2FsbGV0SWQsIGFkZHJlc3NJZCwgc21hcnRDb250cmFjdElkLCBkZXBsb3lTbWFydENvbnRyYWN0UmVxdWVzdCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICd3YWxsZXRJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdkZXBsb3lTbWFydENvbnRyYWN0JywgJ3dhbGxldElkJywgd2FsbGV0SWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnYWRkcmVzc0lkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2RlcGxveVNtYXJ0Q29udHJhY3QnLCAnYWRkcmVzc0lkJywgYWRkcmVzc0lkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ3NtYXJ0Q29udHJhY3RJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdkZXBsb3lTbWFydENvbnRyYWN0JywgJ3NtYXJ0Q29udHJhY3RJZCcsIHNtYXJ0Q29udHJhY3RJZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdkZXBsb3lTbWFydENvbnRyYWN0UmVxdWVzdCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdkZXBsb3lTbWFydENvbnRyYWN0JywgJ2RlcGxveVNtYXJ0Q29udHJhY3RSZXF1ZXN0JywgZGVwbG95U21hcnRDb250cmFjdFJlcXVlc3QpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS93YWxsZXRzL3t3YWxsZXRfaWR9L2FkZHJlc3Nlcy97YWRkcmVzc19pZH0vc21hcnRfY29udHJhY3RzL3tzbWFydF9jb250cmFjdF9pZH0vZGVwbG95YFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcIndhbGxldF9pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHdhbGxldElkKSkpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wiYWRkcmVzc19pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKGFkZHJlc3NJZCkpKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcInNtYXJ0X2NvbnRyYWN0X2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoc21hcnRDb250cmFjdElkKSkpO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7IG1ldGhvZDogJ1BPU1QnLCAuLi5iYXNlT3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIGFwaUtleSByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJKd3RcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBsb2NhbFZhckhlYWRlclBhcmFtZXRlclsnQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSB7IC4uLmxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCAuLi5oZWFkZXJzRnJvbUJhc2VPcHRpb25zLCAuLi5vcHRpb25zLmhlYWRlcnMgfTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuZGF0YSA9ICgwLCBjb21tb25fMS5zZXJpYWxpemVEYXRhSWZOZWVkZWQpKGRlcGxveVNtYXJ0Q29udHJhY3RSZXF1ZXN0LCBsb2NhbFZhclJlcXVlc3RPcHRpb25zLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgYSBzcGVjaWZpYyBzbWFydCBjb250cmFjdCBkZXBsb3llZCBieSBhZGRyZXNzLlxuICAgICAgICAgKiBAc3VtbWFyeSBHZXQgYSBzcGVjaWZpYyBzbWFydCBjb250cmFjdCBkZXBsb3llZCBieSBhZGRyZXNzXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0byBmZXRjaCB0aGUgc21hcnQgY29udHJhY3QgZm9yLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc21hcnRDb250cmFjdElkIFRoZSBVVUlEIG9mIHRoZSBzbWFydCBjb250cmFjdCB0byBmZXRjaC5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGdldFNtYXJ0Q29udHJhY3Q6IGFzeW5jICh3YWxsZXRJZCwgYWRkcmVzc0lkLCBzbWFydENvbnRyYWN0SWQsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnd2FsbGV0SWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZ2V0U21hcnRDb250cmFjdCcsICd3YWxsZXRJZCcsIHdhbGxldElkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2FkZHJlc3NJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdnZXRTbWFydENvbnRyYWN0JywgJ2FkZHJlc3NJZCcsIGFkZHJlc3NJZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdzbWFydENvbnRyYWN0SWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZ2V0U21hcnRDb250cmFjdCcsICdzbWFydENvbnRyYWN0SWQnLCBzbWFydENvbnRyYWN0SWQpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS93YWxsZXRzL3t3YWxsZXRfaWR9L2FkZHJlc3Nlcy97YWRkcmVzc19pZH0vc21hcnRfY29udHJhY3RzL3tzbWFydF9jb250cmFjdF9pZH1gXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wid2FsbGV0X2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcod2FsbGV0SWQpKSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJhZGRyZXNzX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoYWRkcmVzc0lkKSkpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wic21hcnRfY29udHJhY3RfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhzbWFydENvbnRyYWN0SWQpKSk7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IHsgbWV0aG9kOiAnR0VUJywgLi4uYmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBhcGlLZXkgcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gc2Vzc2lvbiByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJKd3RcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSB7IC4uLmxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCAuLi5oZWFkZXJzRnJvbUJhc2VPcHRpb25zLCAuLi5vcHRpb25zLmhlYWRlcnMgfTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0IHNtYXJ0IGNvbnRyYWN0c1xuICAgICAgICAgKiBAc3VtbWFyeSBMaXN0IHNtYXJ0IGNvbnRyYWN0c1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VdIFBhZ2luYXRpb24gdG9rZW4gZm9yIHJldHJpZXZpbmcgdGhlIG5leHQgc2V0IG9mIHJlc3VsdHNcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGxpc3RTbWFydENvbnRyYWN0czogYXN5bmMgKHBhZ2UsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS9zbWFydF9jb250cmFjdHNgO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7IG1ldGhvZDogJ0dFVCcsIC4uLmJhc2VPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gYXBpS2V5IHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIkp3dFwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIHNlc3Npb24gcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgaWYgKHBhZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ3BhZ2UnXSA9IHBhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSB7IC4uLmxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCAuLi5oZWFkZXJzRnJvbUJhc2VPcHRpb25zLCAuLi5vcHRpb25zLmhlYWRlcnMgfTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQZXJmb3JtIGEgcmVhZCBvcGVyYXRpb24gb24gYSBzbWFydCBjb250cmFjdCB3aXRob3V0IGNyZWF0aW5nIGEgdHJhbnNhY3Rpb25cbiAgICAgICAgICogQHN1bW1hcnkgUmVhZCBkYXRhIGZyb20gYSBzbWFydCBjb250cmFjdFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29ya0lkXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb250cmFjdEFkZHJlc3NcbiAgICAgICAgICogQHBhcmFtIHtSZWFkQ29udHJhY3RSZXF1ZXN0fSByZWFkQ29udHJhY3RSZXF1ZXN0XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICByZWFkQ29udHJhY3Q6IGFzeW5jIChuZXR3b3JrSWQsIGNvbnRyYWN0QWRkcmVzcywgcmVhZENvbnRyYWN0UmVxdWVzdCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICduZXR3b3JrSWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgncmVhZENvbnRyYWN0JywgJ25ldHdvcmtJZCcsIG5ldHdvcmtJZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdjb250cmFjdEFkZHJlc3MnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgncmVhZENvbnRyYWN0JywgJ2NvbnRyYWN0QWRkcmVzcycsIGNvbnRyYWN0QWRkcmVzcyk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdyZWFkQ29udHJhY3RSZXF1ZXN0JyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ3JlYWRDb250cmFjdCcsICdyZWFkQ29udHJhY3RSZXF1ZXN0JywgcmVhZENvbnRyYWN0UmVxdWVzdCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL25ldHdvcmtzL3tuZXR3b3JrX2lkfS9zbWFydF9jb250cmFjdHMve2NvbnRyYWN0X2FkZHJlc3N9L3JlYWRgXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wibmV0d29ya19pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKG5ldHdvcmtJZCkpKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcImNvbnRyYWN0X2FkZHJlc3NcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhjb250cmFjdEFkZHJlc3MpKSk7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IHsgbWV0aG9kOiAnUE9TVCcsIC4uLmJhc2VPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gYXBpS2V5IHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIkp3dFwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIHNlc3Npb24gcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXJbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0geyAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlciwgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucywgLi4ub3B0aW9ucy5oZWFkZXJzIH07XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmRhdGEgPSAoMCwgY29tbW9uXzEuc2VyaWFsaXplRGF0YUlmTmVlZGVkKShyZWFkQ29udHJhY3RSZXF1ZXN0LCBsb2NhbFZhclJlcXVlc3RPcHRpb25zLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWdpc3RlciBhIHNtYXJ0IGNvbnRyYWN0XG4gICAgICAgICAqIEBzdW1tYXJ5IFJlZ2lzdGVyIGEgc21hcnQgY29udHJhY3RcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5ldHdvcmtJZCBUaGUgSUQgb2YgdGhlIG5ldHdvcmsgdG8gZmV0Y2guXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb250cmFjdEFkZHJlc3MgRVZNIGFkZHJlc3Mgb2YgdGhlIHNtYXJ0IGNvbnRyYWN0ICg0MiBjaGFyYWN0ZXJzLCBpbmNsdWRpbmcgXFwmIzM5OzB4XFwmIzM5OywgaW4gbG93ZXJjYXNlKVxuICAgICAgICAgKiBAcGFyYW0ge1JlZ2lzdGVyU21hcnRDb250cmFjdFJlcXVlc3R9IFtyZWdpc3RlclNtYXJ0Q29udHJhY3RSZXF1ZXN0XVxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgcmVnaXN0ZXJTbWFydENvbnRyYWN0OiBhc3luYyAobmV0d29ya0lkLCBjb250cmFjdEFkZHJlc3MsIHJlZ2lzdGVyU21hcnRDb250cmFjdFJlcXVlc3QsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnbmV0d29ya0lkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ3JlZ2lzdGVyU21hcnRDb250cmFjdCcsICduZXR3b3JrSWQnLCBuZXR3b3JrSWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnY29udHJhY3RBZGRyZXNzJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ3JlZ2lzdGVyU21hcnRDb250cmFjdCcsICdjb250cmFjdEFkZHJlc3MnLCBjb250cmFjdEFkZHJlc3MpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS9uZXR3b3Jrcy97bmV0d29ya19pZH0vc21hcnRfY29udHJhY3RzL3tjb250cmFjdF9hZGRyZXNzfS9yZWdpc3RlcmBcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJuZXR3b3JrX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcobmV0d29ya0lkKSkpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wiY29udHJhY3RfYWRkcmVzc1wifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKGNvbnRyYWN0QWRkcmVzcykpKTtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0geyBtZXRob2Q6ICdQT1NUJywgLi4uYmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBhcGlLZXkgcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gc2Vzc2lvbiByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJKd3RcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBsb2NhbFZhckhlYWRlclBhcmFtZXRlclsnQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSB7IC4uLmxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCAuLi5oZWFkZXJzRnJvbUJhc2VPcHRpb25zLCAuLi5vcHRpb25zLmhlYWRlcnMgfTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuZGF0YSA9ICgwLCBjb21tb25fMS5zZXJpYWxpemVEYXRhSWZOZWVkZWQpKHJlZ2lzdGVyU21hcnRDb250cmFjdFJlcXVlc3QsIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZSBhIHNtYXJ0IGNvbnRyYWN0XG4gICAgICAgICAqIEBzdW1tYXJ5IFVwZGF0ZSBhIHNtYXJ0IGNvbnRyYWN0XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWQgVGhlIElEIG9mIHRoZSBuZXR3b3JrIHRvIGZldGNoLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29udHJhY3RBZGRyZXNzIEVWTSBhZGRyZXNzIG9mIHRoZSBzbWFydCBjb250cmFjdCAoNDIgY2hhcmFjdGVycywgaW5jbHVkaW5nIFxcJiMzOTsweFxcJiMzOTssIGluIGxvd2VyY2FzZSlcbiAgICAgICAgICogQHBhcmFtIHtVcGRhdGVTbWFydENvbnRyYWN0UmVxdWVzdH0gW3VwZGF0ZVNtYXJ0Q29udHJhY3RSZXF1ZXN0XVxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgdXBkYXRlU21hcnRDb250cmFjdDogYXN5bmMgKG5ldHdvcmtJZCwgY29udHJhY3RBZGRyZXNzLCB1cGRhdGVTbWFydENvbnRyYWN0UmVxdWVzdCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICduZXR3b3JrSWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgndXBkYXRlU21hcnRDb250cmFjdCcsICduZXR3b3JrSWQnLCBuZXR3b3JrSWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnY29udHJhY3RBZGRyZXNzJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ3VwZGF0ZVNtYXJ0Q29udHJhY3QnLCAnY29udHJhY3RBZGRyZXNzJywgY29udHJhY3RBZGRyZXNzKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvbmV0d29ya3Mve25ldHdvcmtfaWR9L3NtYXJ0X2NvbnRyYWN0cy97Y29udHJhY3RfYWRkcmVzc31gXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wibmV0d29ya19pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKG5ldHdvcmtJZCkpKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcImNvbnRyYWN0X2FkZHJlc3NcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhjb250cmFjdEFkZHJlc3MpKSk7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IHsgbWV0aG9kOiAnUFVUJywgLi4uYmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBhcGlLZXkgcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gc2Vzc2lvbiByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJKd3RcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBsb2NhbFZhckhlYWRlclBhcmFtZXRlclsnQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSB7IC4uLmxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCAuLi5oZWFkZXJzRnJvbUJhc2VPcHRpb25zLCAuLi5vcHRpb25zLmhlYWRlcnMgfTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuZGF0YSA9ICgwLCBjb21tb25fMS5zZXJpYWxpemVEYXRhSWZOZWVkZWQpKHVwZGF0ZVNtYXJ0Q29udHJhY3RSZXF1ZXN0LCBsb2NhbFZhclJlcXVlc3RPcHRpb25zLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5leHBvcnRzLlNtYXJ0Q29udHJhY3RzQXBpQXhpb3NQYXJhbUNyZWF0b3IgPSBTbWFydENvbnRyYWN0c0FwaUF4aW9zUGFyYW1DcmVhdG9yO1xuLyoqXG4gKiBTbWFydENvbnRyYWN0c0FwaSAtIGZ1bmN0aW9uYWwgcHJvZ3JhbW1pbmcgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IFNtYXJ0Q29udHJhY3RzQXBpRnAgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbikge1xuICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IgPSAoMCwgZXhwb3J0cy5TbWFydENvbnRyYWN0c0FwaUF4aW9zUGFyYW1DcmVhdG9yKShjb25maWd1cmF0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29tcGlsZSBhIHNtYXJ0IGNvbnRyYWN0XG4gICAgICAgICAqIEBzdW1tYXJ5IENvbXBpbGUgYSBzbWFydCBjb250cmFjdFxuICAgICAgICAgKiBAcGFyYW0ge0NvbXBpbGVTbWFydENvbnRyYWN0UmVxdWVzdH0gY29tcGlsZVNtYXJ0Q29udHJhY3RSZXF1ZXN0XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBjb21waWxlU21hcnRDb250cmFjdChjb21waWxlU21hcnRDb250cmFjdFJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5jb21waWxlU21hcnRDb250cmFjdChjb21waWxlU21hcnRDb250cmFjdFJlcXVlc3QsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IGNvbmZpZ3VyYXRpb24/LnNlcnZlckluZGV4ID8/IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnU21hcnRDb250cmFjdHNBcGkuY29tcGlsZVNtYXJ0Q29udHJhY3QnXT8uW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdPy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgbmV3IHNtYXJ0IGNvbnRyYWN0XG4gICAgICAgICAqIEBzdW1tYXJ5IENyZWF0ZSBhIG5ldyBzbWFydCBjb250cmFjdFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0by5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdG8gZGVwbG95IHRoZSBzbWFydCBjb250cmFjdCBmcm9tLlxuICAgICAgICAgKiBAcGFyYW0ge0NyZWF0ZVNtYXJ0Q29udHJhY3RSZXF1ZXN0fSBjcmVhdGVTbWFydENvbnRyYWN0UmVxdWVzdFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgY3JlYXRlU21hcnRDb250cmFjdCh3YWxsZXRJZCwgYWRkcmVzc0lkLCBjcmVhdGVTbWFydENvbnRyYWN0UmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmNyZWF0ZVNtYXJ0Q29udHJhY3Qod2FsbGV0SWQsIGFkZHJlc3NJZCwgY3JlYXRlU21hcnRDb250cmFjdFJlcXVlc3QsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IGNvbmZpZ3VyYXRpb24/LnNlcnZlckluZGV4ID8/IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnU21hcnRDb250cmFjdHNBcGkuY3JlYXRlU21hcnRDb250cmFjdCddPy5bbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0/LnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXBsb3lzIGEgc21hcnQgY29udHJhY3QsIGJ5IGJyb2FkY2FzdGluZyB0aGUgdHJhbnNhY3Rpb24gdG8gdGhlIG5ldHdvcmsuXG4gICAgICAgICAqIEBzdW1tYXJ5IERlcGxveSBhIHNtYXJ0IGNvbnRyYWN0XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0byBicm9hZGNhc3QgdGhlIHRyYW5zYWN0aW9uIGZyb20uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzbWFydENvbnRyYWN0SWQgVGhlIFVVSUQgb2YgdGhlIHNtYXJ0IGNvbnRyYWN0IHRvIGJyb2FkY2FzdCB0aGUgdHJhbnNhY3Rpb24gdG8uXG4gICAgICAgICAqIEBwYXJhbSB7RGVwbG95U21hcnRDb250cmFjdFJlcXVlc3R9IGRlcGxveVNtYXJ0Q29udHJhY3RSZXF1ZXN0XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBkZXBsb3lTbWFydENvbnRyYWN0KHdhbGxldElkLCBhZGRyZXNzSWQsIHNtYXJ0Q29udHJhY3RJZCwgZGVwbG95U21hcnRDb250cmFjdFJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5kZXBsb3lTbWFydENvbnRyYWN0KHdhbGxldElkLCBhZGRyZXNzSWQsIHNtYXJ0Q29udHJhY3RJZCwgZGVwbG95U21hcnRDb250cmFjdFJlcXVlc3QsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IGNvbmZpZ3VyYXRpb24/LnNlcnZlckluZGV4ID8/IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnU21hcnRDb250cmFjdHNBcGkuZGVwbG95U21hcnRDb250cmFjdCddPy5bbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0/LnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgYSBzcGVjaWZpYyBzbWFydCBjb250cmFjdCBkZXBsb3llZCBieSBhZGRyZXNzLlxuICAgICAgICAgKiBAc3VtbWFyeSBHZXQgYSBzcGVjaWZpYyBzbWFydCBjb250cmFjdCBkZXBsb3llZCBieSBhZGRyZXNzXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0byBmZXRjaCB0aGUgc21hcnQgY29udHJhY3QgZm9yLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc21hcnRDb250cmFjdElkIFRoZSBVVUlEIG9mIHRoZSBzbWFydCBjb250cmFjdCB0byBmZXRjaC5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGdldFNtYXJ0Q29udHJhY3Qod2FsbGV0SWQsIGFkZHJlc3NJZCwgc21hcnRDb250cmFjdElkLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuZ2V0U21hcnRDb250cmFjdCh3YWxsZXRJZCwgYWRkcmVzc0lkLCBzbWFydENvbnRyYWN0SWQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IGNvbmZpZ3VyYXRpb24/LnNlcnZlckluZGV4ID8/IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnU21hcnRDb250cmFjdHNBcGkuZ2V0U21hcnRDb250cmFjdCddPy5bbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0/LnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0IHNtYXJ0IGNvbnRyYWN0c1xuICAgICAgICAgKiBAc3VtbWFyeSBMaXN0IHNtYXJ0IGNvbnRyYWN0c1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VdIFBhZ2luYXRpb24gdG9rZW4gZm9yIHJldHJpZXZpbmcgdGhlIG5leHQgc2V0IG9mIHJlc3VsdHNcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGxpc3RTbWFydENvbnRyYWN0cyhwYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IubGlzdFNtYXJ0Q29udHJhY3RzKHBhZ2UsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IGNvbmZpZ3VyYXRpb24/LnNlcnZlckluZGV4ID8/IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnU21hcnRDb250cmFjdHNBcGkubGlzdFNtYXJ0Q29udHJhY3RzJ10/Lltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XT8udXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBlcmZvcm0gYSByZWFkIG9wZXJhdGlvbiBvbiBhIHNtYXJ0IGNvbnRyYWN0IHdpdGhvdXQgY3JlYXRpbmcgYSB0cmFuc2FjdGlvblxuICAgICAgICAgKiBAc3VtbWFyeSBSZWFkIGRhdGEgZnJvbSBhIHNtYXJ0IGNvbnRyYWN0XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWRcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRyYWN0QWRkcmVzc1xuICAgICAgICAgKiBAcGFyYW0ge1JlYWRDb250cmFjdFJlcXVlc3R9IHJlYWRDb250cmFjdFJlcXVlc3RcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIHJlYWRDb250cmFjdChuZXR3b3JrSWQsIGNvbnRyYWN0QWRkcmVzcywgcmVhZENvbnRyYWN0UmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLnJlYWRDb250cmFjdChuZXR3b3JrSWQsIGNvbnRyYWN0QWRkcmVzcywgcmVhZENvbnRyYWN0UmVxdWVzdCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gY29uZmlndXJhdGlvbj8uc2VydmVySW5kZXggPz8gMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydTbWFydENvbnRyYWN0c0FwaS5yZWFkQ29udHJhY3QnXT8uW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdPy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogUmVnaXN0ZXIgYSBzbWFydCBjb250cmFjdFxuICAgICAgICAgKiBAc3VtbWFyeSBSZWdpc3RlciBhIHNtYXJ0IGNvbnRyYWN0XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWQgVGhlIElEIG9mIHRoZSBuZXR3b3JrIHRvIGZldGNoLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29udHJhY3RBZGRyZXNzIEVWTSBhZGRyZXNzIG9mIHRoZSBzbWFydCBjb250cmFjdCAoNDIgY2hhcmFjdGVycywgaW5jbHVkaW5nIFxcJiMzOTsweFxcJiMzOTssIGluIGxvd2VyY2FzZSlcbiAgICAgICAgICogQHBhcmFtIHtSZWdpc3RlclNtYXJ0Q29udHJhY3RSZXF1ZXN0fSBbcmVnaXN0ZXJTbWFydENvbnRyYWN0UmVxdWVzdF1cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIHJlZ2lzdGVyU21hcnRDb250cmFjdChuZXR3b3JrSWQsIGNvbnRyYWN0QWRkcmVzcywgcmVnaXN0ZXJTbWFydENvbnRyYWN0UmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLnJlZ2lzdGVyU21hcnRDb250cmFjdChuZXR3b3JrSWQsIGNvbnRyYWN0QWRkcmVzcywgcmVnaXN0ZXJTbWFydENvbnRyYWN0UmVxdWVzdCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gY29uZmlndXJhdGlvbj8uc2VydmVySW5kZXggPz8gMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydTbWFydENvbnRyYWN0c0FwaS5yZWdpc3RlclNtYXJ0Q29udHJhY3QnXT8uW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdPy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlIGEgc21hcnQgY29udHJhY3RcbiAgICAgICAgICogQHN1bW1hcnkgVXBkYXRlIGEgc21hcnQgY29udHJhY3RcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5ldHdvcmtJZCBUaGUgSUQgb2YgdGhlIG5ldHdvcmsgdG8gZmV0Y2guXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb250cmFjdEFkZHJlc3MgRVZNIGFkZHJlc3Mgb2YgdGhlIHNtYXJ0IGNvbnRyYWN0ICg0MiBjaGFyYWN0ZXJzLCBpbmNsdWRpbmcgXFwmIzM5OzB4XFwmIzM5OywgaW4gbG93ZXJjYXNlKVxuICAgICAgICAgKiBAcGFyYW0ge1VwZGF0ZVNtYXJ0Q29udHJhY3RSZXF1ZXN0fSBbdXBkYXRlU21hcnRDb250cmFjdFJlcXVlc3RdXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyB1cGRhdGVTbWFydENvbnRyYWN0KG5ldHdvcmtJZCwgY29udHJhY3RBZGRyZXNzLCB1cGRhdGVTbWFydENvbnRyYWN0UmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLnVwZGF0ZVNtYXJ0Q29udHJhY3QobmV0d29ya0lkLCBjb250cmFjdEFkZHJlc3MsIHVwZGF0ZVNtYXJ0Q29udHJhY3RSZXF1ZXN0LCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSBjb25maWd1cmF0aW9uPy5zZXJ2ZXJJbmRleCA/PyAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ1NtYXJ0Q29udHJhY3RzQXBpLnVwZGF0ZVNtYXJ0Q29udHJhY3QnXT8uW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdPy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5TbWFydENvbnRyYWN0c0FwaUZwID0gU21hcnRDb250cmFjdHNBcGlGcDtcbi8qKlxuICogU21hcnRDb250cmFjdHNBcGkgLSBmYWN0b3J5IGludGVyZmFjZVxuICogQGV4cG9ydFxuICovXG5jb25zdCBTbWFydENvbnRyYWN0c0FwaUZhY3RvcnkgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbiwgYmFzZVBhdGgsIGF4aW9zKSB7XG4gICAgY29uc3QgbG9jYWxWYXJGcCA9ICgwLCBleHBvcnRzLlNtYXJ0Q29udHJhY3RzQXBpRnApKGNvbmZpZ3VyYXRpb24pO1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb21waWxlIGEgc21hcnQgY29udHJhY3RcbiAgICAgICAgICogQHN1bW1hcnkgQ29tcGlsZSBhIHNtYXJ0IGNvbnRyYWN0XG4gICAgICAgICAqIEBwYXJhbSB7Q29tcGlsZVNtYXJ0Q29udHJhY3RSZXF1ZXN0fSBjb21waWxlU21hcnRDb250cmFjdFJlcXVlc3RcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGNvbXBpbGVTbWFydENvbnRyYWN0KGNvbXBpbGVTbWFydENvbnRyYWN0UmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuY29tcGlsZVNtYXJ0Q29udHJhY3QoY29tcGlsZVNtYXJ0Q29udHJhY3RSZXF1ZXN0LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgbmV3IHNtYXJ0IGNvbnRyYWN0XG4gICAgICAgICAqIEBzdW1tYXJ5IENyZWF0ZSBhIG5ldyBzbWFydCBjb250cmFjdFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0by5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdG8gZGVwbG95IHRoZSBzbWFydCBjb250cmFjdCBmcm9tLlxuICAgICAgICAgKiBAcGFyYW0ge0NyZWF0ZVNtYXJ0Q29udHJhY3RSZXF1ZXN0fSBjcmVhdGVTbWFydENvbnRyYWN0UmVxdWVzdFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgY3JlYXRlU21hcnRDb250cmFjdCh3YWxsZXRJZCwgYWRkcmVzc0lkLCBjcmVhdGVTbWFydENvbnRyYWN0UmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuY3JlYXRlU21hcnRDb250cmFjdCh3YWxsZXRJZCwgYWRkcmVzc0lkLCBjcmVhdGVTbWFydENvbnRyYWN0UmVxdWVzdCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlcGxveXMgYSBzbWFydCBjb250cmFjdCwgYnkgYnJvYWRjYXN0aW5nIHRoZSB0cmFuc2FjdGlvbiB0byB0aGUgbmV0d29yay5cbiAgICAgICAgICogQHN1bW1hcnkgRGVwbG95IGEgc21hcnQgY29udHJhY3RcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRvIGJyb2FkY2FzdCB0aGUgdHJhbnNhY3Rpb24gZnJvbS5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHNtYXJ0Q29udHJhY3RJZCBUaGUgVVVJRCBvZiB0aGUgc21hcnQgY29udHJhY3QgdG8gYnJvYWRjYXN0IHRoZSB0cmFuc2FjdGlvbiB0by5cbiAgICAgICAgICogQHBhcmFtIHtEZXBsb3lTbWFydENvbnRyYWN0UmVxdWVzdH0gZGVwbG95U21hcnRDb250cmFjdFJlcXVlc3RcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGRlcGxveVNtYXJ0Q29udHJhY3Qod2FsbGV0SWQsIGFkZHJlc3NJZCwgc21hcnRDb250cmFjdElkLCBkZXBsb3lTbWFydENvbnRyYWN0UmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuZGVwbG95U21hcnRDb250cmFjdCh3YWxsZXRJZCwgYWRkcmVzc0lkLCBzbWFydENvbnRyYWN0SWQsIGRlcGxveVNtYXJ0Q29udHJhY3RSZXF1ZXN0LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGEgc3BlY2lmaWMgc21hcnQgY29udHJhY3QgZGVwbG95ZWQgYnkgYWRkcmVzcy5cbiAgICAgICAgICogQHN1bW1hcnkgR2V0IGEgc3BlY2lmaWMgc21hcnQgY29udHJhY3QgZGVwbG95ZWQgYnkgYWRkcmVzc1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0by5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdG8gZmV0Y2ggdGhlIHNtYXJ0IGNvbnRyYWN0IGZvci5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHNtYXJ0Q29udHJhY3RJZCBUaGUgVVVJRCBvZiB0aGUgc21hcnQgY29udHJhY3QgdG8gZmV0Y2guXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRTbWFydENvbnRyYWN0KHdhbGxldElkLCBhZGRyZXNzSWQsIHNtYXJ0Q29udHJhY3RJZCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuZ2V0U21hcnRDb250cmFjdCh3YWxsZXRJZCwgYWRkcmVzc0lkLCBzbWFydENvbnRyYWN0SWQsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0IHNtYXJ0IGNvbnRyYWN0c1xuICAgICAgICAgKiBAc3VtbWFyeSBMaXN0IHNtYXJ0IGNvbnRyYWN0c1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VdIFBhZ2luYXRpb24gdG9rZW4gZm9yIHJldHJpZXZpbmcgdGhlIG5leHQgc2V0IG9mIHJlc3VsdHNcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGxpc3RTbWFydENvbnRyYWN0cyhwYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5saXN0U21hcnRDb250cmFjdHMocGFnZSwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBlcmZvcm0gYSByZWFkIG9wZXJhdGlvbiBvbiBhIHNtYXJ0IGNvbnRyYWN0IHdpdGhvdXQgY3JlYXRpbmcgYSB0cmFuc2FjdGlvblxuICAgICAgICAgKiBAc3VtbWFyeSBSZWFkIGRhdGEgZnJvbSBhIHNtYXJ0IGNvbnRyYWN0XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWRcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRyYWN0QWRkcmVzc1xuICAgICAgICAgKiBAcGFyYW0ge1JlYWRDb250cmFjdFJlcXVlc3R9IHJlYWRDb250cmFjdFJlcXVlc3RcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIHJlYWRDb250cmFjdChuZXR3b3JrSWQsIGNvbnRyYWN0QWRkcmVzcywgcmVhZENvbnRyYWN0UmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAucmVhZENvbnRyYWN0KG5ldHdvcmtJZCwgY29udHJhY3RBZGRyZXNzLCByZWFkQ29udHJhY3RSZXF1ZXN0LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogUmVnaXN0ZXIgYSBzbWFydCBjb250cmFjdFxuICAgICAgICAgKiBAc3VtbWFyeSBSZWdpc3RlciBhIHNtYXJ0IGNvbnRyYWN0XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWQgVGhlIElEIG9mIHRoZSBuZXR3b3JrIHRvIGZldGNoLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29udHJhY3RBZGRyZXNzIEVWTSBhZGRyZXNzIG9mIHRoZSBzbWFydCBjb250cmFjdCAoNDIgY2hhcmFjdGVycywgaW5jbHVkaW5nIFxcJiMzOTsweFxcJiMzOTssIGluIGxvd2VyY2FzZSlcbiAgICAgICAgICogQHBhcmFtIHtSZWdpc3RlclNtYXJ0Q29udHJhY3RSZXF1ZXN0fSBbcmVnaXN0ZXJTbWFydENvbnRyYWN0UmVxdWVzdF1cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIHJlZ2lzdGVyU21hcnRDb250cmFjdChuZXR3b3JrSWQsIGNvbnRyYWN0QWRkcmVzcywgcmVnaXN0ZXJTbWFydENvbnRyYWN0UmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAucmVnaXN0ZXJTbWFydENvbnRyYWN0KG5ldHdvcmtJZCwgY29udHJhY3RBZGRyZXNzLCByZWdpc3RlclNtYXJ0Q29udHJhY3RSZXF1ZXN0LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlIGEgc21hcnQgY29udHJhY3RcbiAgICAgICAgICogQHN1bW1hcnkgVXBkYXRlIGEgc21hcnQgY29udHJhY3RcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5ldHdvcmtJZCBUaGUgSUQgb2YgdGhlIG5ldHdvcmsgdG8gZmV0Y2guXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb250cmFjdEFkZHJlc3MgRVZNIGFkZHJlc3Mgb2YgdGhlIHNtYXJ0IGNvbnRyYWN0ICg0MiBjaGFyYWN0ZXJzLCBpbmNsdWRpbmcgXFwmIzM5OzB4XFwmIzM5OywgaW4gbG93ZXJjYXNlKVxuICAgICAgICAgKiBAcGFyYW0ge1VwZGF0ZVNtYXJ0Q29udHJhY3RSZXF1ZXN0fSBbdXBkYXRlU21hcnRDb250cmFjdFJlcXVlc3RdXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICB1cGRhdGVTbWFydENvbnRyYWN0KG5ldHdvcmtJZCwgY29udHJhY3RBZGRyZXNzLCB1cGRhdGVTbWFydENvbnRyYWN0UmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAudXBkYXRlU21hcnRDb250cmFjdChuZXR3b3JrSWQsIGNvbnRyYWN0QWRkcmVzcywgdXBkYXRlU21hcnRDb250cmFjdFJlcXVlc3QsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5leHBvcnRzLlNtYXJ0Q29udHJhY3RzQXBpRmFjdG9yeSA9IFNtYXJ0Q29udHJhY3RzQXBpRmFjdG9yeTtcbi8qKlxuICogU21hcnRDb250cmFjdHNBcGkgLSBvYmplY3Qtb3JpZW50ZWQgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKiBAY2xhc3MgU21hcnRDb250cmFjdHNBcGlcbiAqIEBleHRlbmRzIHtCYXNlQVBJfVxuICovXG5jbGFzcyBTbWFydENvbnRyYWN0c0FwaSBleHRlbmRzIGJhc2VfMS5CYXNlQVBJIHtcbiAgICAvKipcbiAgICAgKiBDb21waWxlIGEgc21hcnQgY29udHJhY3RcbiAgICAgKiBAc3VtbWFyeSBDb21waWxlIGEgc21hcnQgY29udHJhY3RcbiAgICAgKiBAcGFyYW0ge0NvbXBpbGVTbWFydENvbnRyYWN0UmVxdWVzdH0gY29tcGlsZVNtYXJ0Q29udHJhY3RSZXF1ZXN0XG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBTbWFydENvbnRyYWN0c0FwaVxuICAgICAqL1xuICAgIGNvbXBpbGVTbWFydENvbnRyYWN0KGNvbXBpbGVTbWFydENvbnRyYWN0UmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuU21hcnRDb250cmFjdHNBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5jb21waWxlU21hcnRDb250cmFjdChjb21waWxlU21hcnRDb250cmFjdFJlcXVlc3QsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgc21hcnQgY29udHJhY3RcbiAgICAgKiBAc3VtbWFyeSBDcmVhdGUgYSBuZXcgc21hcnQgY29udHJhY3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0by5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0byBkZXBsb3kgdGhlIHNtYXJ0IGNvbnRyYWN0IGZyb20uXG4gICAgICogQHBhcmFtIHtDcmVhdGVTbWFydENvbnRyYWN0UmVxdWVzdH0gY3JlYXRlU21hcnRDb250cmFjdFJlcXVlc3RcbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIFNtYXJ0Q29udHJhY3RzQXBpXG4gICAgICovXG4gICAgY3JlYXRlU21hcnRDb250cmFjdCh3YWxsZXRJZCwgYWRkcmVzc0lkLCBjcmVhdGVTbWFydENvbnRyYWN0UmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuU21hcnRDb250cmFjdHNBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5jcmVhdGVTbWFydENvbnRyYWN0KHdhbGxldElkLCBhZGRyZXNzSWQsIGNyZWF0ZVNtYXJ0Q29udHJhY3RSZXF1ZXN0LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVwbG95cyBhIHNtYXJ0IGNvbnRyYWN0LCBieSBicm9hZGNhc3RpbmcgdGhlIHRyYW5zYWN0aW9uIHRvIHRoZSBuZXR3b3JrLlxuICAgICAqIEBzdW1tYXJ5IERlcGxveSBhIHNtYXJ0IGNvbnRyYWN0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG8uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdG8gYnJvYWRjYXN0IHRoZSB0cmFuc2FjdGlvbiBmcm9tLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzbWFydENvbnRyYWN0SWQgVGhlIFVVSUQgb2YgdGhlIHNtYXJ0IGNvbnRyYWN0IHRvIGJyb2FkY2FzdCB0aGUgdHJhbnNhY3Rpb24gdG8uXG4gICAgICogQHBhcmFtIHtEZXBsb3lTbWFydENvbnRyYWN0UmVxdWVzdH0gZGVwbG95U21hcnRDb250cmFjdFJlcXVlc3RcbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIFNtYXJ0Q29udHJhY3RzQXBpXG4gICAgICovXG4gICAgZGVwbG95U21hcnRDb250cmFjdCh3YWxsZXRJZCwgYWRkcmVzc0lkLCBzbWFydENvbnRyYWN0SWQsIGRlcGxveVNtYXJ0Q29udHJhY3RSZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5TbWFydENvbnRyYWN0c0FwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLmRlcGxveVNtYXJ0Q29udHJhY3Qod2FsbGV0SWQsIGFkZHJlc3NJZCwgc21hcnRDb250cmFjdElkLCBkZXBsb3lTbWFydENvbnRyYWN0UmVxdWVzdCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhIHNwZWNpZmljIHNtYXJ0IGNvbnRyYWN0IGRlcGxveWVkIGJ5IGFkZHJlc3MuXG4gICAgICogQHN1bW1hcnkgR2V0IGEgc3BlY2lmaWMgc21hcnQgY29udHJhY3QgZGVwbG95ZWQgYnkgYWRkcmVzc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRvIGZldGNoIHRoZSBzbWFydCBjb250cmFjdCBmb3IuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNtYXJ0Q29udHJhY3RJZCBUaGUgVVVJRCBvZiB0aGUgc21hcnQgY29udHJhY3QgdG8gZmV0Y2guXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBTbWFydENvbnRyYWN0c0FwaVxuICAgICAqL1xuICAgIGdldFNtYXJ0Q29udHJhY3Qod2FsbGV0SWQsIGFkZHJlc3NJZCwgc21hcnRDb250cmFjdElkLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5TbWFydENvbnRyYWN0c0FwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLmdldFNtYXJ0Q29udHJhY3Qod2FsbGV0SWQsIGFkZHJlc3NJZCwgc21hcnRDb250cmFjdElkLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdCBzbWFydCBjb250cmFjdHNcbiAgICAgKiBAc3VtbWFyeSBMaXN0IHNtYXJ0IGNvbnRyYWN0c1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZV0gUGFnaW5hdGlvbiB0b2tlbiBmb3IgcmV0cmlldmluZyB0aGUgbmV4dCBzZXQgb2YgcmVzdWx0c1xuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgU21hcnRDb250cmFjdHNBcGlcbiAgICAgKi9cbiAgICBsaXN0U21hcnRDb250cmFjdHMocGFnZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuU21hcnRDb250cmFjdHNBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5saXN0U21hcnRDb250cmFjdHMocGFnZSwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm0gYSByZWFkIG9wZXJhdGlvbiBvbiBhIHNtYXJ0IGNvbnRyYWN0IHdpdGhvdXQgY3JlYXRpbmcgYSB0cmFuc2FjdGlvblxuICAgICAqIEBzdW1tYXJ5IFJlYWQgZGF0YSBmcm9tIGEgc21hcnQgY29udHJhY3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29ya0lkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRyYWN0QWRkcmVzc1xuICAgICAqIEBwYXJhbSB7UmVhZENvbnRyYWN0UmVxdWVzdH0gcmVhZENvbnRyYWN0UmVxdWVzdFxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgU21hcnRDb250cmFjdHNBcGlcbiAgICAgKi9cbiAgICByZWFkQ29udHJhY3QobmV0d29ya0lkLCBjb250cmFjdEFkZHJlc3MsIHJlYWRDb250cmFjdFJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLlNtYXJ0Q29udHJhY3RzQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikucmVhZENvbnRyYWN0KG5ldHdvcmtJZCwgY29udHJhY3RBZGRyZXNzLCByZWFkQ29udHJhY3RSZXF1ZXN0LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgYSBzbWFydCBjb250cmFjdFxuICAgICAqIEBzdW1tYXJ5IFJlZ2lzdGVyIGEgc21hcnQgY29udHJhY3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29ya0lkIFRoZSBJRCBvZiB0aGUgbmV0d29yayB0byBmZXRjaC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29udHJhY3RBZGRyZXNzIEVWTSBhZGRyZXNzIG9mIHRoZSBzbWFydCBjb250cmFjdCAoNDIgY2hhcmFjdGVycywgaW5jbHVkaW5nIFxcJiMzOTsweFxcJiMzOTssIGluIGxvd2VyY2FzZSlcbiAgICAgKiBAcGFyYW0ge1JlZ2lzdGVyU21hcnRDb250cmFjdFJlcXVlc3R9IFtyZWdpc3RlclNtYXJ0Q29udHJhY3RSZXF1ZXN0XVxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgU21hcnRDb250cmFjdHNBcGlcbiAgICAgKi9cbiAgICByZWdpc3RlclNtYXJ0Q29udHJhY3QobmV0d29ya0lkLCBjb250cmFjdEFkZHJlc3MsIHJlZ2lzdGVyU21hcnRDb250cmFjdFJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLlNtYXJ0Q29udHJhY3RzQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikucmVnaXN0ZXJTbWFydENvbnRyYWN0KG5ldHdvcmtJZCwgY29udHJhY3RBZGRyZXNzLCByZWdpc3RlclNtYXJ0Q29udHJhY3RSZXF1ZXN0LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIGEgc21hcnQgY29udHJhY3RcbiAgICAgKiBAc3VtbWFyeSBVcGRhdGUgYSBzbWFydCBjb250cmFjdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWQgVGhlIElEIG9mIHRoZSBuZXR3b3JrIHRvIGZldGNoLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb250cmFjdEFkZHJlc3MgRVZNIGFkZHJlc3Mgb2YgdGhlIHNtYXJ0IGNvbnRyYWN0ICg0MiBjaGFyYWN0ZXJzLCBpbmNsdWRpbmcgXFwmIzM5OzB4XFwmIzM5OywgaW4gbG93ZXJjYXNlKVxuICAgICAqIEBwYXJhbSB7VXBkYXRlU21hcnRDb250cmFjdFJlcXVlc3R9IFt1cGRhdGVTbWFydENvbnRyYWN0UmVxdWVzdF1cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIFNtYXJ0Q29udHJhY3RzQXBpXG4gICAgICovXG4gICAgdXBkYXRlU21hcnRDb250cmFjdChuZXR3b3JrSWQsIGNvbnRyYWN0QWRkcmVzcywgdXBkYXRlU21hcnRDb250cmFjdFJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLlNtYXJ0Q29udHJhY3RzQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikudXBkYXRlU21hcnRDb250cmFjdChuZXR3b3JrSWQsIGNvbnRyYWN0QWRkcmVzcywgdXBkYXRlU21hcnRDb250cmFjdFJlcXVlc3QsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuU21hcnRDb250cmFjdHNBcGkgPSBTbWFydENvbnRyYWN0c0FwaTtcbi8qKlxuICogU21hcnRXYWxsZXRzQXBpIC0gYXhpb3MgcGFyYW1ldGVyIGNyZWF0b3JcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgU21hcnRXYWxsZXRzQXBpQXhpb3NQYXJhbUNyZWF0b3IgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbikge1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCcm9hZGNhc3QgYSB1c2VyIG9wZXJhdGlvblxuICAgICAgICAgKiBAc3VtbWFyeSBCcm9hZGNhc3QgYSB1c2VyIG9wZXJhdGlvblxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc21hcnRXYWxsZXRBZGRyZXNzIFRoZSBhZGRyZXNzIG9mIHRoZSBzbWFydCB3YWxsZXQgdG8gYnJvYWRjYXN0IHRoZSB1c2VyIG9wZXJhdGlvbiBmcm9tLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlck9wSGFzaCBUaGUgaGFzaCBvZiB0aGUgdXNlciBvcGVyYXRpb24gdG8gYnJvYWRjYXN0XG4gICAgICAgICAqIEBwYXJhbSB7QnJvYWRjYXN0VXNlck9wZXJhdGlvblJlcXVlc3R9IFticm9hZGNhc3RVc2VyT3BlcmF0aW9uUmVxdWVzdF1cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGJyb2FkY2FzdFVzZXJPcGVyYXRpb246IGFzeW5jIChzbWFydFdhbGxldEFkZHJlc3MsIHVzZXJPcEhhc2gsIGJyb2FkY2FzdFVzZXJPcGVyYXRpb25SZXF1ZXN0LCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ3NtYXJ0V2FsbGV0QWRkcmVzcycgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdicm9hZGNhc3RVc2VyT3BlcmF0aW9uJywgJ3NtYXJ0V2FsbGV0QWRkcmVzcycsIHNtYXJ0V2FsbGV0QWRkcmVzcyk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICd1c2VyT3BIYXNoJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2Jyb2FkY2FzdFVzZXJPcGVyYXRpb24nLCAndXNlck9wSGFzaCcsIHVzZXJPcEhhc2gpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS9zbWFydF93YWxsZXRzL3tzbWFydF93YWxsZXRfYWRkcmVzc30vdXNlcl9vcGVyYXRpb25zL3t1c2VyX29wX2hhc2h9L2Jyb2FkY2FzdGBcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJzbWFydF93YWxsZXRfYWRkcmVzc1wifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHNtYXJ0V2FsbGV0QWRkcmVzcykpKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcInVzZXJfb3BfaGFzaFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHVzZXJPcEhhc2gpKSk7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IHsgbWV0aG9kOiAnUE9TVCcsIC4uLmJhc2VPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gYXBpS2V5IHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIkp3dFwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IHsgLi4ubG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIC4uLmhlYWRlcnNGcm9tQmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMuaGVhZGVycyB9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5kYXRhID0gKDAsIGNvbW1vbl8xLnNlcmlhbGl6ZURhdGFJZk5lZWRlZCkoYnJvYWRjYXN0VXNlck9wZXJhdGlvblJlcXVlc3QsIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIG5ldyBzbWFydCB3YWxsZXQsIG5vdCBzY29wZWQgdG8gYSBnaXZlbiBuZXR3b3JrLlxuICAgICAgICAgKiBAc3VtbWFyeSBDcmVhdGUgYSBuZXcgc21hcnQgd2FsbGV0XG4gICAgICAgICAqIEBwYXJhbSB7Q3JlYXRlU21hcnRXYWxsZXRSZXF1ZXN0fSBbY3JlYXRlU21hcnRXYWxsZXRSZXF1ZXN0XVxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgY3JlYXRlU21hcnRXYWxsZXQ6IGFzeW5jIChjcmVhdGVTbWFydFdhbGxldFJlcXVlc3QsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS9zbWFydF93YWxsZXRzYDtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0geyBtZXRob2Q6ICdQT1NUJywgLi4uYmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBhcGlLZXkgcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXJbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0geyAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlciwgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucywgLi4ub3B0aW9ucy5oZWFkZXJzIH07XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmRhdGEgPSAoMCwgY29tbW9uXzEuc2VyaWFsaXplRGF0YUlmTmVlZGVkKShjcmVhdGVTbWFydFdhbGxldFJlcXVlc3QsIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIG5ldyB1c2VyIG9wZXJhdGlvbiBvbiBhIHNtYXJ0IHdhbGxldC5cbiAgICAgICAgICogQHN1bW1hcnkgQ3JlYXRlIGEgbmV3IHVzZXIgb3BlcmF0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzbWFydFdhbGxldEFkZHJlc3MgVGhlIGFkZHJlc3Mgb2YgdGhlIHNtYXJ0IHdhbGxldCB0byBjcmVhdGUgdGhlIHVzZXIgb3BlcmF0aW9uIG9uLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29ya0lkIFRoZSBJRCBvZiB0aGUgbmV0d29yayB0byBjcmVhdGUgdGhlIHVzZXIgb3BlcmF0aW9uIG9uLlxuICAgICAgICAgKiBAcGFyYW0ge0NyZWF0ZVVzZXJPcGVyYXRpb25SZXF1ZXN0fSBbY3JlYXRlVXNlck9wZXJhdGlvblJlcXVlc3RdXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGVVc2VyT3BlcmF0aW9uOiBhc3luYyAoc21hcnRXYWxsZXRBZGRyZXNzLCBuZXR3b3JrSWQsIGNyZWF0ZVVzZXJPcGVyYXRpb25SZXF1ZXN0LCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ3NtYXJ0V2FsbGV0QWRkcmVzcycgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdjcmVhdGVVc2VyT3BlcmF0aW9uJywgJ3NtYXJ0V2FsbGV0QWRkcmVzcycsIHNtYXJ0V2FsbGV0QWRkcmVzcyk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICduZXR3b3JrSWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnY3JlYXRlVXNlck9wZXJhdGlvbicsICduZXR3b3JrSWQnLCBuZXR3b3JrSWQpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS9zbWFydF93YWxsZXRzL3tzbWFydF93YWxsZXRfYWRkcmVzc30vbmV0d29ya3Mve25ldHdvcmtfaWR9L3VzZXJfb3BlcmF0aW9uc2BcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJzbWFydF93YWxsZXRfYWRkcmVzc1wifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHNtYXJ0V2FsbGV0QWRkcmVzcykpKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcIm5ldHdvcmtfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhuZXR3b3JrSWQpKSk7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IHsgbWV0aG9kOiAnUE9TVCcsIC4uLmJhc2VPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gYXBpS2V5IHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIkp3dFwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IHsgLi4ubG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIC4uLmhlYWRlcnNGcm9tQmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMuaGVhZGVycyB9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5kYXRhID0gKDAsIGNvbW1vbl8xLnNlcmlhbGl6ZURhdGFJZk5lZWRlZCkoY3JlYXRlVXNlck9wZXJhdGlvblJlcXVlc3QsIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBzbWFydCB3YWxsZXRcbiAgICAgICAgICogQHN1bW1hcnkgR2V0IHNtYXJ0IHdhbGxldCBieSBhZGRyZXNzXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzbWFydFdhbGxldEFkZHJlc3MgVGhlIGFkZHJlc3Mgb2YgdGhhdCBzbWFydCB3YWxsZXQgdG8gZmV0Y2guXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRTbWFydFdhbGxldDogYXN5bmMgKHNtYXJ0V2FsbGV0QWRkcmVzcywgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdzbWFydFdhbGxldEFkZHJlc3MnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZ2V0U21hcnRXYWxsZXQnLCAnc21hcnRXYWxsZXRBZGRyZXNzJywgc21hcnRXYWxsZXRBZGRyZXNzKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvc21hcnRfd2FsbGV0cy97c21hcnRfd2FsbGV0X2FkZHJlc3N9YFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcInNtYXJ0X3dhbGxldF9hZGRyZXNzXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoc21hcnRXYWxsZXRBZGRyZXNzKSkpO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7IG1ldGhvZDogJ0dFVCcsIC4uLmJhc2VPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gYXBpS2V5IHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIkp3dFwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIHNlc3Npb24gcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0geyAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlciwgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucywgLi4ub3B0aW9ucy5oZWFkZXJzIH07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHVzZXIgb3BlcmF0aW9uXG4gICAgICAgICAqIEBzdW1tYXJ5IEdldCB1c2VyIG9wZXJhdGlvblxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc21hcnRXYWxsZXRBZGRyZXNzIFRoZSBhZGRyZXNzIG9mIHRoZSBzbWFydCB3YWxsZXQgdGhlIHVzZXIgb3BlcmF0aW9uIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VyT3BIYXNoIFRoZSBoYXNoIG9mIHRoZSB1c2VyIG9wZXJhdGlvbiB0byBmZXRjaFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0VXNlck9wZXJhdGlvbjogYXN5bmMgKHNtYXJ0V2FsbGV0QWRkcmVzcywgdXNlck9wSGFzaCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdzbWFydFdhbGxldEFkZHJlc3MnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZ2V0VXNlck9wZXJhdGlvbicsICdzbWFydFdhbGxldEFkZHJlc3MnLCBzbWFydFdhbGxldEFkZHJlc3MpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAndXNlck9wSGFzaCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdnZXRVc2VyT3BlcmF0aW9uJywgJ3VzZXJPcEhhc2gnLCB1c2VyT3BIYXNoKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvc21hcnRfd2FsbGV0cy97c21hcnRfd2FsbGV0X2FkZHJlc3N9L3VzZXJfb3BlcmF0aW9ucy97dXNlcl9vcF9oYXNofWBcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJzbWFydF93YWxsZXRfYWRkcmVzc1wifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHNtYXJ0V2FsbGV0QWRkcmVzcykpKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcInVzZXJfb3BfaGFzaFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHVzZXJPcEhhc2gpKSk7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IHsgbWV0aG9kOiAnR0VUJywgLi4uYmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBhcGlLZXkgcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gc2Vzc2lvbiByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJKd3RcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSB7IC4uLmxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCAuLi5oZWFkZXJzRnJvbUJhc2VPcHRpb25zLCAuLi5vcHRpb25zLmhlYWRlcnMgfTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0IHNtYXJ0IHdhbGxldHNcbiAgICAgICAgICogQHN1bW1hcnkgTGlzdCBzbWFydCB3YWxsZXRzXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIEEgbGltaXQgb24gdGhlIG51bWJlciBvZiBvYmplY3RzIHRvIGJlIHJldHVybmVkLiBMaW1pdCBjYW4gcmFuZ2UgYmV0d2VlbiAxIGFuZCAxMDAsIGFuZCB0aGUgZGVmYXVsdCBpcyAxMC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlXSBBIGN1cnNvciBmb3IgcGFnaW5hdGlvbiBhY3Jvc3MgbXVsdGlwbGUgcGFnZXMgb2YgcmVzdWx0cy4gRG9uXFwmIzM5O3QgaW5jbHVkZSB0aGlzIHBhcmFtZXRlciBvbiB0aGUgZmlyc3QgY2FsbC4gVXNlIHRoZSBuZXh0X3BhZ2UgdmFsdWUgcmV0dXJuZWQgaW4gYSBwcmV2aW91cyByZXNwb25zZSB0byByZXF1ZXN0IHN1YnNlcXVlbnQgcmVzdWx0cy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGxpc3RTbWFydFdhbGxldHM6IGFzeW5jIChsaW1pdCwgcGFnZSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL3NtYXJ0X3dhbGxldHNgO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7IG1ldGhvZDogJ0dFVCcsIC4uLmJhc2VPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gYXBpS2V5IHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIkp3dFwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIHNlc3Npb24gcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgaWYgKGxpbWl0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydsaW1pdCddID0gbGltaXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsncGFnZSddID0gcGFnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IHsgLi4ubG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIC4uLmhlYWRlcnNGcm9tQmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMuaGVhZGVycyB9O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuU21hcnRXYWxsZXRzQXBpQXhpb3NQYXJhbUNyZWF0b3IgPSBTbWFydFdhbGxldHNBcGlBeGlvc1BhcmFtQ3JlYXRvcjtcbi8qKlxuICogU21hcnRXYWxsZXRzQXBpIC0gZnVuY3Rpb25hbCBwcm9ncmFtbWluZyBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgU21hcnRXYWxsZXRzQXBpRnAgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbikge1xuICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IgPSAoMCwgZXhwb3J0cy5TbWFydFdhbGxldHNBcGlBeGlvc1BhcmFtQ3JlYXRvcikoY29uZmlndXJhdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJyb2FkY2FzdCBhIHVzZXIgb3BlcmF0aW9uXG4gICAgICAgICAqIEBzdW1tYXJ5IEJyb2FkY2FzdCBhIHVzZXIgb3BlcmF0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzbWFydFdhbGxldEFkZHJlc3MgVGhlIGFkZHJlc3Mgb2YgdGhlIHNtYXJ0IHdhbGxldCB0byBicm9hZGNhc3QgdGhlIHVzZXIgb3BlcmF0aW9uIGZyb20uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VyT3BIYXNoIFRoZSBoYXNoIG9mIHRoZSB1c2VyIG9wZXJhdGlvbiB0byBicm9hZGNhc3RcbiAgICAgICAgICogQHBhcmFtIHtCcm9hZGNhc3RVc2VyT3BlcmF0aW9uUmVxdWVzdH0gW2Jyb2FkY2FzdFVzZXJPcGVyYXRpb25SZXF1ZXN0XVxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgYnJvYWRjYXN0VXNlck9wZXJhdGlvbihzbWFydFdhbGxldEFkZHJlc3MsIHVzZXJPcEhhc2gsIGJyb2FkY2FzdFVzZXJPcGVyYXRpb25SZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuYnJvYWRjYXN0VXNlck9wZXJhdGlvbihzbWFydFdhbGxldEFkZHJlc3MsIHVzZXJPcEhhc2gsIGJyb2FkY2FzdFVzZXJPcGVyYXRpb25SZXF1ZXN0LCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSBjb25maWd1cmF0aW9uPy5zZXJ2ZXJJbmRleCA/PyAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ1NtYXJ0V2FsbGV0c0FwaS5icm9hZGNhc3RVc2VyT3BlcmF0aW9uJ10/Lltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XT8udXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIG5ldyBzbWFydCB3YWxsZXQsIG5vdCBzY29wZWQgdG8gYSBnaXZlbiBuZXR3b3JrLlxuICAgICAgICAgKiBAc3VtbWFyeSBDcmVhdGUgYSBuZXcgc21hcnQgd2FsbGV0XG4gICAgICAgICAqIEBwYXJhbSB7Q3JlYXRlU21hcnRXYWxsZXRSZXF1ZXN0fSBbY3JlYXRlU21hcnRXYWxsZXRSZXF1ZXN0XVxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgY3JlYXRlU21hcnRXYWxsZXQoY3JlYXRlU21hcnRXYWxsZXRSZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuY3JlYXRlU21hcnRXYWxsZXQoY3JlYXRlU21hcnRXYWxsZXRSZXF1ZXN0LCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSBjb25maWd1cmF0aW9uPy5zZXJ2ZXJJbmRleCA/PyAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ1NtYXJ0V2FsbGV0c0FwaS5jcmVhdGVTbWFydFdhbGxldCddPy5bbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0/LnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSBuZXcgdXNlciBvcGVyYXRpb24gb24gYSBzbWFydCB3YWxsZXQuXG4gICAgICAgICAqIEBzdW1tYXJ5IENyZWF0ZSBhIG5ldyB1c2VyIG9wZXJhdGlvblxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc21hcnRXYWxsZXRBZGRyZXNzIFRoZSBhZGRyZXNzIG9mIHRoZSBzbWFydCB3YWxsZXQgdG8gY3JlYXRlIHRoZSB1c2VyIG9wZXJhdGlvbiBvbi5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5ldHdvcmtJZCBUaGUgSUQgb2YgdGhlIG5ldHdvcmsgdG8gY3JlYXRlIHRoZSB1c2VyIG9wZXJhdGlvbiBvbi5cbiAgICAgICAgICogQHBhcmFtIHtDcmVhdGVVc2VyT3BlcmF0aW9uUmVxdWVzdH0gW2NyZWF0ZVVzZXJPcGVyYXRpb25SZXF1ZXN0XVxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgY3JlYXRlVXNlck9wZXJhdGlvbihzbWFydFdhbGxldEFkZHJlc3MsIG5ldHdvcmtJZCwgY3JlYXRlVXNlck9wZXJhdGlvblJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5jcmVhdGVVc2VyT3BlcmF0aW9uKHNtYXJ0V2FsbGV0QWRkcmVzcywgbmV0d29ya0lkLCBjcmVhdGVVc2VyT3BlcmF0aW9uUmVxdWVzdCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gY29uZmlndXJhdGlvbj8uc2VydmVySW5kZXggPz8gMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydTbWFydFdhbGxldHNBcGkuY3JlYXRlVXNlck9wZXJhdGlvbiddPy5bbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0/LnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgc21hcnQgd2FsbGV0XG4gICAgICAgICAqIEBzdW1tYXJ5IEdldCBzbWFydCB3YWxsZXQgYnkgYWRkcmVzc1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc21hcnRXYWxsZXRBZGRyZXNzIFRoZSBhZGRyZXNzIG9mIHRoYXQgc21hcnQgd2FsbGV0IHRvIGZldGNoLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgZ2V0U21hcnRXYWxsZXQoc21hcnRXYWxsZXRBZGRyZXNzLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuZ2V0U21hcnRXYWxsZXQoc21hcnRXYWxsZXRBZGRyZXNzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSBjb25maWd1cmF0aW9uPy5zZXJ2ZXJJbmRleCA/PyAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ1NtYXJ0V2FsbGV0c0FwaS5nZXRTbWFydFdhbGxldCddPy5bbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0/LnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdXNlciBvcGVyYXRpb25cbiAgICAgICAgICogQHN1bW1hcnkgR2V0IHVzZXIgb3BlcmF0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzbWFydFdhbGxldEFkZHJlc3MgVGhlIGFkZHJlc3Mgb2YgdGhlIHNtYXJ0IHdhbGxldCB0aGUgdXNlciBvcGVyYXRpb24gYmVsb25ncyB0by5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJPcEhhc2ggVGhlIGhhc2ggb2YgdGhlIHVzZXIgb3BlcmF0aW9uIHRvIGZldGNoXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBnZXRVc2VyT3BlcmF0aW9uKHNtYXJ0V2FsbGV0QWRkcmVzcywgdXNlck9wSGFzaCwgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmdldFVzZXJPcGVyYXRpb24oc21hcnRXYWxsZXRBZGRyZXNzLCB1c2VyT3BIYXNoLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSBjb25maWd1cmF0aW9uPy5zZXJ2ZXJJbmRleCA/PyAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ1NtYXJ0V2FsbGV0c0FwaS5nZXRVc2VyT3BlcmF0aW9uJ10/Lltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XT8udXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3Qgc21hcnQgd2FsbGV0c1xuICAgICAgICAgKiBAc3VtbWFyeSBMaXN0IHNtYXJ0IHdhbGxldHNcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gQSBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIG9iamVjdHMgdG8gYmUgcmV0dXJuZWQuIExpbWl0IGNhbiByYW5nZSBiZXR3ZWVuIDEgYW5kIDEwMCwgYW5kIHRoZSBkZWZhdWx0IGlzIDEwLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VdIEEgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiByZXN1bHRzLiBEb25cXCYjMzk7dCBpbmNsdWRlIHRoaXMgcGFyYW1ldGVyIG9uIHRoZSBmaXJzdCBjYWxsLiBVc2UgdGhlIG5leHRfcGFnZSB2YWx1ZSByZXR1cm5lZCBpbiBhIHByZXZpb3VzIHJlc3BvbnNlIHRvIHJlcXVlc3Qgc3Vic2VxdWVudCByZXN1bHRzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgbGlzdFNtYXJ0V2FsbGV0cyhsaW1pdCwgcGFnZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmxpc3RTbWFydFdhbGxldHMobGltaXQsIHBhZ2UsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IGNvbmZpZ3VyYXRpb24/LnNlcnZlckluZGV4ID8/IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnU21hcnRXYWxsZXRzQXBpLmxpc3RTbWFydFdhbGxldHMnXT8uW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdPy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5TbWFydFdhbGxldHNBcGlGcCA9IFNtYXJ0V2FsbGV0c0FwaUZwO1xuLyoqXG4gKiBTbWFydFdhbGxldHNBcGkgLSBmYWN0b3J5IGludGVyZmFjZVxuICogQGV4cG9ydFxuICovXG5jb25zdCBTbWFydFdhbGxldHNBcGlGYWN0b3J5ID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24sIGJhc2VQYXRoLCBheGlvcykge1xuICAgIGNvbnN0IGxvY2FsVmFyRnAgPSAoMCwgZXhwb3J0cy5TbWFydFdhbGxldHNBcGlGcCkoY29uZmlndXJhdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJyb2FkY2FzdCBhIHVzZXIgb3BlcmF0aW9uXG4gICAgICAgICAqIEBzdW1tYXJ5IEJyb2FkY2FzdCBhIHVzZXIgb3BlcmF0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzbWFydFdhbGxldEFkZHJlc3MgVGhlIGFkZHJlc3Mgb2YgdGhlIHNtYXJ0IHdhbGxldCB0byBicm9hZGNhc3QgdGhlIHVzZXIgb3BlcmF0aW9uIGZyb20uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VyT3BIYXNoIFRoZSBoYXNoIG9mIHRoZSB1c2VyIG9wZXJhdGlvbiB0byBicm9hZGNhc3RcbiAgICAgICAgICogQHBhcmFtIHtCcm9hZGNhc3RVc2VyT3BlcmF0aW9uUmVxdWVzdH0gW2Jyb2FkY2FzdFVzZXJPcGVyYXRpb25SZXF1ZXN0XVxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYnJvYWRjYXN0VXNlck9wZXJhdGlvbihzbWFydFdhbGxldEFkZHJlc3MsIHVzZXJPcEhhc2gsIGJyb2FkY2FzdFVzZXJPcGVyYXRpb25SZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5icm9hZGNhc3RVc2VyT3BlcmF0aW9uKHNtYXJ0V2FsbGV0QWRkcmVzcywgdXNlck9wSGFzaCwgYnJvYWRjYXN0VXNlck9wZXJhdGlvblJlcXVlc3QsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSBuZXcgc21hcnQgd2FsbGV0LCBub3Qgc2NvcGVkIHRvIGEgZ2l2ZW4gbmV0d29yay5cbiAgICAgICAgICogQHN1bW1hcnkgQ3JlYXRlIGEgbmV3IHNtYXJ0IHdhbGxldFxuICAgICAgICAgKiBAcGFyYW0ge0NyZWF0ZVNtYXJ0V2FsbGV0UmVxdWVzdH0gW2NyZWF0ZVNtYXJ0V2FsbGV0UmVxdWVzdF1cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZVNtYXJ0V2FsbGV0KGNyZWF0ZVNtYXJ0V2FsbGV0UmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuY3JlYXRlU21hcnRXYWxsZXQoY3JlYXRlU21hcnRXYWxsZXRSZXF1ZXN0LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgbmV3IHVzZXIgb3BlcmF0aW9uIG9uIGEgc21hcnQgd2FsbGV0LlxuICAgICAgICAgKiBAc3VtbWFyeSBDcmVhdGUgYSBuZXcgdXNlciBvcGVyYXRpb25cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHNtYXJ0V2FsbGV0QWRkcmVzcyBUaGUgYWRkcmVzcyBvZiB0aGUgc21hcnQgd2FsbGV0IHRvIGNyZWF0ZSB0aGUgdXNlciBvcGVyYXRpb24gb24uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWQgVGhlIElEIG9mIHRoZSBuZXR3b3JrIHRvIGNyZWF0ZSB0aGUgdXNlciBvcGVyYXRpb24gb24uXG4gICAgICAgICAqIEBwYXJhbSB7Q3JlYXRlVXNlck9wZXJhdGlvblJlcXVlc3R9IFtjcmVhdGVVc2VyT3BlcmF0aW9uUmVxdWVzdF1cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZVVzZXJPcGVyYXRpb24oc21hcnRXYWxsZXRBZGRyZXNzLCBuZXR3b3JrSWQsIGNyZWF0ZVVzZXJPcGVyYXRpb25SZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5jcmVhdGVVc2VyT3BlcmF0aW9uKHNtYXJ0V2FsbGV0QWRkcmVzcywgbmV0d29ya0lkLCBjcmVhdGVVc2VyT3BlcmF0aW9uUmVxdWVzdCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBzbWFydCB3YWxsZXRcbiAgICAgICAgICogQHN1bW1hcnkgR2V0IHNtYXJ0IHdhbGxldCBieSBhZGRyZXNzXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzbWFydFdhbGxldEFkZHJlc3MgVGhlIGFkZHJlc3Mgb2YgdGhhdCBzbWFydCB3YWxsZXQgdG8gZmV0Y2guXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRTbWFydFdhbGxldChzbWFydFdhbGxldEFkZHJlc3MsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmdldFNtYXJ0V2FsbGV0KHNtYXJ0V2FsbGV0QWRkcmVzcywgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB1c2VyIG9wZXJhdGlvblxuICAgICAgICAgKiBAc3VtbWFyeSBHZXQgdXNlciBvcGVyYXRpb25cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHNtYXJ0V2FsbGV0QWRkcmVzcyBUaGUgYWRkcmVzcyBvZiB0aGUgc21hcnQgd2FsbGV0IHRoZSB1c2VyIG9wZXJhdGlvbiBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlck9wSGFzaCBUaGUgaGFzaCBvZiB0aGUgdXNlciBvcGVyYXRpb24gdG8gZmV0Y2hcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGdldFVzZXJPcGVyYXRpb24oc21hcnRXYWxsZXRBZGRyZXNzLCB1c2VyT3BIYXNoLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5nZXRVc2VyT3BlcmF0aW9uKHNtYXJ0V2FsbGV0QWRkcmVzcywgdXNlck9wSGFzaCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3Qgc21hcnQgd2FsbGV0c1xuICAgICAgICAgKiBAc3VtbWFyeSBMaXN0IHNtYXJ0IHdhbGxldHNcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gQSBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIG9iamVjdHMgdG8gYmUgcmV0dXJuZWQuIExpbWl0IGNhbiByYW5nZSBiZXR3ZWVuIDEgYW5kIDEwMCwgYW5kIHRoZSBkZWZhdWx0IGlzIDEwLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VdIEEgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiByZXN1bHRzLiBEb25cXCYjMzk7dCBpbmNsdWRlIHRoaXMgcGFyYW1ldGVyIG9uIHRoZSBmaXJzdCBjYWxsLiBVc2UgdGhlIG5leHRfcGFnZSB2YWx1ZSByZXR1cm5lZCBpbiBhIHByZXZpb3VzIHJlc3BvbnNlIHRvIHJlcXVlc3Qgc3Vic2VxdWVudCByZXN1bHRzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgbGlzdFNtYXJ0V2FsbGV0cyhsaW1pdCwgcGFnZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAubGlzdFNtYXJ0V2FsbGV0cyhsaW1pdCwgcGFnZSwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuU21hcnRXYWxsZXRzQXBpRmFjdG9yeSA9IFNtYXJ0V2FsbGV0c0FwaUZhY3Rvcnk7XG4vKipcbiAqIFNtYXJ0V2FsbGV0c0FwaSAtIG9iamVjdC1vcmllbnRlZCBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqIEBjbGFzcyBTbWFydFdhbGxldHNBcGlcbiAqIEBleHRlbmRzIHtCYXNlQVBJfVxuICovXG5jbGFzcyBTbWFydFdhbGxldHNBcGkgZXh0ZW5kcyBiYXNlXzEuQmFzZUFQSSB7XG4gICAgLyoqXG4gICAgICogQnJvYWRjYXN0IGEgdXNlciBvcGVyYXRpb25cbiAgICAgKiBAc3VtbWFyeSBCcm9hZGNhc3QgYSB1c2VyIG9wZXJhdGlvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzbWFydFdhbGxldEFkZHJlc3MgVGhlIGFkZHJlc3Mgb2YgdGhlIHNtYXJ0IHdhbGxldCB0byBicm9hZGNhc3QgdGhlIHVzZXIgb3BlcmF0aW9uIGZyb20uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJPcEhhc2ggVGhlIGhhc2ggb2YgdGhlIHVzZXIgb3BlcmF0aW9uIHRvIGJyb2FkY2FzdFxuICAgICAqIEBwYXJhbSB7QnJvYWRjYXN0VXNlck9wZXJhdGlvblJlcXVlc3R9IFticm9hZGNhc3RVc2VyT3BlcmF0aW9uUmVxdWVzdF1cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIFNtYXJ0V2FsbGV0c0FwaVxuICAgICAqL1xuICAgIGJyb2FkY2FzdFVzZXJPcGVyYXRpb24oc21hcnRXYWxsZXRBZGRyZXNzLCB1c2VyT3BIYXNoLCBicm9hZGNhc3RVc2VyT3BlcmF0aW9uUmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuU21hcnRXYWxsZXRzQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuYnJvYWRjYXN0VXNlck9wZXJhdGlvbihzbWFydFdhbGxldEFkZHJlc3MsIHVzZXJPcEhhc2gsIGJyb2FkY2FzdFVzZXJPcGVyYXRpb25SZXF1ZXN0LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IHNtYXJ0IHdhbGxldCwgbm90IHNjb3BlZCB0byBhIGdpdmVuIG5ldHdvcmsuXG4gICAgICogQHN1bW1hcnkgQ3JlYXRlIGEgbmV3IHNtYXJ0IHdhbGxldFxuICAgICAqIEBwYXJhbSB7Q3JlYXRlU21hcnRXYWxsZXRSZXF1ZXN0fSBbY3JlYXRlU21hcnRXYWxsZXRSZXF1ZXN0XVxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgU21hcnRXYWxsZXRzQXBpXG4gICAgICovXG4gICAgY3JlYXRlU21hcnRXYWxsZXQoY3JlYXRlU21hcnRXYWxsZXRSZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5TbWFydFdhbGxldHNBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5jcmVhdGVTbWFydFdhbGxldChjcmVhdGVTbWFydFdhbGxldFJlcXVlc3QsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgdXNlciBvcGVyYXRpb24gb24gYSBzbWFydCB3YWxsZXQuXG4gICAgICogQHN1bW1hcnkgQ3JlYXRlIGEgbmV3IHVzZXIgb3BlcmF0aW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNtYXJ0V2FsbGV0QWRkcmVzcyBUaGUgYWRkcmVzcyBvZiB0aGUgc21hcnQgd2FsbGV0IHRvIGNyZWF0ZSB0aGUgdXNlciBvcGVyYXRpb24gb24uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5ldHdvcmtJZCBUaGUgSUQgb2YgdGhlIG5ldHdvcmsgdG8gY3JlYXRlIHRoZSB1c2VyIG9wZXJhdGlvbiBvbi5cbiAgICAgKiBAcGFyYW0ge0NyZWF0ZVVzZXJPcGVyYXRpb25SZXF1ZXN0fSBbY3JlYXRlVXNlck9wZXJhdGlvblJlcXVlc3RdXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBTbWFydFdhbGxldHNBcGlcbiAgICAgKi9cbiAgICBjcmVhdGVVc2VyT3BlcmF0aW9uKHNtYXJ0V2FsbGV0QWRkcmVzcywgbmV0d29ya0lkLCBjcmVhdGVVc2VyT3BlcmF0aW9uUmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuU21hcnRXYWxsZXRzQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuY3JlYXRlVXNlck9wZXJhdGlvbihzbWFydFdhbGxldEFkZHJlc3MsIG5ldHdvcmtJZCwgY3JlYXRlVXNlck9wZXJhdGlvblJlcXVlc3QsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgc21hcnQgd2FsbGV0XG4gICAgICogQHN1bW1hcnkgR2V0IHNtYXJ0IHdhbGxldCBieSBhZGRyZXNzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNtYXJ0V2FsbGV0QWRkcmVzcyBUaGUgYWRkcmVzcyBvZiB0aGF0IHNtYXJ0IHdhbGxldCB0byBmZXRjaC5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIFNtYXJ0V2FsbGV0c0FwaVxuICAgICAqL1xuICAgIGdldFNtYXJ0V2FsbGV0KHNtYXJ0V2FsbGV0QWRkcmVzcywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuU21hcnRXYWxsZXRzQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuZ2V0U21hcnRXYWxsZXQoc21hcnRXYWxsZXRBZGRyZXNzLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHVzZXIgb3BlcmF0aW9uXG4gICAgICogQHN1bW1hcnkgR2V0IHVzZXIgb3BlcmF0aW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNtYXJ0V2FsbGV0QWRkcmVzcyBUaGUgYWRkcmVzcyBvZiB0aGUgc21hcnQgd2FsbGV0IHRoZSB1c2VyIG9wZXJhdGlvbiBiZWxvbmdzIHRvLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VyT3BIYXNoIFRoZSBoYXNoIG9mIHRoZSB1c2VyIG9wZXJhdGlvbiB0byBmZXRjaFxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgU21hcnRXYWxsZXRzQXBpXG4gICAgICovXG4gICAgZ2V0VXNlck9wZXJhdGlvbihzbWFydFdhbGxldEFkZHJlc3MsIHVzZXJPcEhhc2gsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLlNtYXJ0V2FsbGV0c0FwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLmdldFVzZXJPcGVyYXRpb24oc21hcnRXYWxsZXRBZGRyZXNzLCB1c2VyT3BIYXNoLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdCBzbWFydCB3YWxsZXRzXG4gICAgICogQHN1bW1hcnkgTGlzdCBzbWFydCB3YWxsZXRzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gQSBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIG9iamVjdHMgdG8gYmUgcmV0dXJuZWQuIExpbWl0IGNhbiByYW5nZSBiZXR3ZWVuIDEgYW5kIDEwMCwgYW5kIHRoZSBkZWZhdWx0IGlzIDEwLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZV0gQSBjdXJzb3IgZm9yIHBhZ2luYXRpb24gYWNyb3NzIG11bHRpcGxlIHBhZ2VzIG9mIHJlc3VsdHMuIERvblxcJiMzOTt0IGluY2x1ZGUgdGhpcyBwYXJhbWV0ZXIgb24gdGhlIGZpcnN0IGNhbGwuIFVzZSB0aGUgbmV4dF9wYWdlIHZhbHVlIHJldHVybmVkIGluIGEgcHJldmlvdXMgcmVzcG9uc2UgdG8gcmVxdWVzdCBzdWJzZXF1ZW50IHJlc3VsdHMuXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBTbWFydFdhbGxldHNBcGlcbiAgICAgKi9cbiAgICBsaXN0U21hcnRXYWxsZXRzKGxpbWl0LCBwYWdlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5TbWFydFdhbGxldHNBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5saXN0U21hcnRXYWxsZXRzKGxpbWl0LCBwYWdlLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG59XG5leHBvcnRzLlNtYXJ0V2FsbGV0c0FwaSA9IFNtYXJ0V2FsbGV0c0FwaTtcbi8qKlxuICogU3Rha2VBcGkgLSBheGlvcyBwYXJhbWV0ZXIgY3JlYXRvclxuICogQGV4cG9ydFxuICovXG5jb25zdCBTdGFrZUFwaUF4aW9zUGFyYW1DcmVhdG9yID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQnVpbGQgYSBuZXcgc3Rha2luZyBvcGVyYXRpb25cbiAgICAgICAgICogQHN1bW1hcnkgQnVpbGQgYSBuZXcgc3Rha2luZyBvcGVyYXRpb25cbiAgICAgICAgICogQHBhcmFtIHtCdWlsZFN0YWtpbmdPcGVyYXRpb25SZXF1ZXN0fSBidWlsZFN0YWtpbmdPcGVyYXRpb25SZXF1ZXN0XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBidWlsZFN0YWtpbmdPcGVyYXRpb246IGFzeW5jIChidWlsZFN0YWtpbmdPcGVyYXRpb25SZXF1ZXN0LCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2J1aWxkU3Rha2luZ09wZXJhdGlvblJlcXVlc3QnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnYnVpbGRTdGFraW5nT3BlcmF0aW9uJywgJ2J1aWxkU3Rha2luZ09wZXJhdGlvblJlcXVlc3QnLCBidWlsZFN0YWtpbmdPcGVyYXRpb25SZXF1ZXN0KTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvc3Rha2UvYnVpbGRgO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7IG1ldGhvZDogJ1BPU1QnLCAuLi5iYXNlT3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIGFwaUtleSByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJKd3RcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBzZXNzaW9uIHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIkp3dFwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IHsgLi4ubG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIC4uLmhlYWRlcnNGcm9tQmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMuaGVhZGVycyB9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5kYXRhID0gKDAsIGNvbW1vbl8xLnNlcmlhbGl6ZURhdGFJZk5lZWRlZCkoYnVpbGRTdGFraW5nT3BlcmF0aW9uUmVxdWVzdCwgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucywgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogRmV0Y2ggaGlzdG9yaWNhbCBzdGFraW5nIGJhbGFuY2VzIGZvciBnaXZlbiBhZGRyZXNzLlxuICAgICAgICAgKiBAc3VtbWFyeSBGZXRjaCBoaXN0b3JpY2FsIHN0YWtpbmcgYmFsYW5jZXNcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5ldHdvcmtJZCBUaGUgSUQgb2YgdGhlIGJsb2NrY2hhaW4gbmV0d29yay5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFzc2V0SWQgVGhlIElEIG9mIHRoZSBhc3NldCBmb3Igd2hpY2ggdGhlIGhpc3RvcmljYWwgc3Rha2luZyBiYWxhbmNlcyBhcmUgYmVpbmcgZmV0Y2hlZC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgb25jaGFpbiBhZGRyZXNzIGZvciB3aGljaCB0aGUgaGlzdG9yaWNhbCBzdGFraW5nIGJhbGFuY2VzIGFyZSBiZWluZyBmZXRjaGVkLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RhcnRUaW1lIFRoZSBzdGFydCB0aW1lIG9mIHRoaXMgaGlzdG9yaWNhbCBzdGFraW5nIGJhbGFuY2UgcGVyaW9kLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZW5kVGltZSBUaGUgZW5kIHRpbWUgb2YgdGhpcyBoaXN0b3JpY2FsIHN0YWtpbmcgYmFsYW5jZSBwZXJpb2QuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIEEgbGltaXQgb24gdGhlIG51bWJlciBvZiBvYmplY3RzIHRvIGJlIHJldHVybmVkLiBMaW1pdCBjYW4gcmFuZ2UgYmV0d2VlbiAxIGFuZCAxMDAsIGFuZCB0aGUgZGVmYXVsdCBpcyA1MC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlXSBBIGN1cnNvciBmb3IgcGFnaW5hdGlvbiBhY3Jvc3MgbXVsdGlwbGUgcGFnZXMgb2YgcmVzdWx0cy4gRG9uXFwmIzM5O3QgaW5jbHVkZSB0aGlzIHBhcmFtZXRlciBvbiB0aGUgZmlyc3QgY2FsbC4gVXNlIHRoZSBuZXh0X3BhZ2UgdmFsdWUgcmV0dXJuZWQgaW4gYSBwcmV2aW91cyByZXNwb25zZSB0byByZXF1ZXN0IHN1YnNlcXVlbnQgcmVzdWx0cy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGZldGNoSGlzdG9yaWNhbFN0YWtpbmdCYWxhbmNlczogYXN5bmMgKG5ldHdvcmtJZCwgYXNzZXRJZCwgYWRkcmVzc0lkLCBzdGFydFRpbWUsIGVuZFRpbWUsIGxpbWl0LCBwYWdlLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ25ldHdvcmtJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdmZXRjaEhpc3RvcmljYWxTdGFraW5nQmFsYW5jZXMnLCAnbmV0d29ya0lkJywgbmV0d29ya0lkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2Fzc2V0SWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZmV0Y2hIaXN0b3JpY2FsU3Rha2luZ0JhbGFuY2VzJywgJ2Fzc2V0SWQnLCBhc3NldElkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2FkZHJlc3NJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdmZXRjaEhpc3RvcmljYWxTdGFraW5nQmFsYW5jZXMnLCAnYWRkcmVzc0lkJywgYWRkcmVzc0lkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ3N0YXJ0VGltZScgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdmZXRjaEhpc3RvcmljYWxTdGFraW5nQmFsYW5jZXMnLCAnc3RhcnRUaW1lJywgc3RhcnRUaW1lKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2VuZFRpbWUnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZmV0Y2hIaXN0b3JpY2FsU3Rha2luZ0JhbGFuY2VzJywgJ2VuZFRpbWUnLCBlbmRUaW1lKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvbmV0d29ya3Mve25ldHdvcmtfaWR9L2FkZHJlc3Nlcy97YWRkcmVzc19pZH0vc3Rha2UvYmFsYW5jZXNgXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wibmV0d29ya19pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKG5ldHdvcmtJZCkpKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcImFkZHJlc3NfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhhZGRyZXNzSWQpKSk7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IHsgbWV0aG9kOiAnR0VUJywgLi4uYmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBhcGlLZXkgcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gc2Vzc2lvbiByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJKd3RcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBpZiAobGltaXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ2xpbWl0J10gPSBsaW1pdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydwYWdlJ10gPSBwYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFzc2V0SWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ2Fzc2V0X2lkJ10gPSBhc3NldElkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXJ0VGltZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnc3RhcnRfdGltZSddID0gKHN0YXJ0VGltZSBpbnN0YW5jZW9mIERhdGUpID9cbiAgICAgICAgICAgICAgICAgICAgc3RhcnRUaW1lLnRvSVNPU3RyaW5nKCkgOlxuICAgICAgICAgICAgICAgICAgICBzdGFydFRpbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW5kVGltZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnZW5kX3RpbWUnXSA9IChlbmRUaW1lIGluc3RhbmNlb2YgRGF0ZSkgP1xuICAgICAgICAgICAgICAgICAgICBlbmRUaW1lLnRvSVNPU3RyaW5nKCkgOlxuICAgICAgICAgICAgICAgICAgICBlbmRUaW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0geyAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlciwgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucywgLi4ub3B0aW9ucy5oZWFkZXJzIH07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogRmV0Y2ggc3Rha2luZyByZXdhcmRzIGZvciBhIGxpc3Qgb2YgYWRkcmVzc2VzXG4gICAgICAgICAqIEBzdW1tYXJ5IEZldGNoIHN0YWtpbmcgcmV3YXJkc1xuICAgICAgICAgKiBAcGFyYW0ge0ZldGNoU3Rha2luZ1Jld2FyZHNSZXF1ZXN0fSBmZXRjaFN0YWtpbmdSZXdhcmRzUmVxdWVzdFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBBIGxpbWl0IG9uIHRoZSBudW1iZXIgb2Ygb2JqZWN0cyB0byBiZSByZXR1cm5lZC4gTGltaXQgY2FuIHJhbmdlIGJldHdlZW4gMSBhbmQgMTAwLCBhbmQgdGhlIGRlZmF1bHQgaXMgNTAuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZV0gQSBjdXJzb3IgZm9yIHBhZ2luYXRpb24gYWNyb3NzIG11bHRpcGxlIHBhZ2VzIG9mIHJlc3VsdHMuIERvblxcJiMzOTt0IGluY2x1ZGUgdGhpcyBwYXJhbWV0ZXIgb24gdGhlIGZpcnN0IGNhbGwuIFVzZSB0aGUgbmV4dF9wYWdlIHZhbHVlIHJldHVybmVkIGluIGEgcHJldmlvdXMgcmVzcG9uc2UgdG8gcmVxdWVzdCBzdWJzZXF1ZW50IHJlc3VsdHMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBmZXRjaFN0YWtpbmdSZXdhcmRzOiBhc3luYyAoZmV0Y2hTdGFraW5nUmV3YXJkc1JlcXVlc3QsIGxpbWl0LCBwYWdlLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2ZldGNoU3Rha2luZ1Jld2FyZHNSZXF1ZXN0JyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2ZldGNoU3Rha2luZ1Jld2FyZHMnLCAnZmV0Y2hTdGFraW5nUmV3YXJkc1JlcXVlc3QnLCBmZXRjaFN0YWtpbmdSZXdhcmRzUmVxdWVzdCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL3N0YWtlL3Jld2FyZHMvc2VhcmNoYDtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0geyBtZXRob2Q6ICdQT1NUJywgLi4uYmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBhcGlLZXkgcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gc2Vzc2lvbiByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJKd3RcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBpZiAobGltaXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ2xpbWl0J10gPSBsaW1pdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydwYWdlJ10gPSBwYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXJbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0geyAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlciwgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucywgLi4ub3B0aW9ucy5oZWFkZXJzIH07XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmRhdGEgPSAoMCwgY29tbW9uXzEuc2VyaWFsaXplRGF0YUlmTmVlZGVkKShmZXRjaFN0YWtpbmdSZXdhcmRzUmVxdWVzdCwgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucywgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBsYXRlc3Qgc3RhdGUgb2YgYSBzdGFraW5nIG9wZXJhdGlvblxuICAgICAgICAgKiBAc3VtbWFyeSBHZXQgdGhlIGxhdGVzdCBzdGF0ZSBvZiBhIHN0YWtpbmcgb3BlcmF0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWQgVGhlIElEIG9mIHRoZSBibG9ja2NoYWluIG5ldHdvcmtcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdG8gZmV0Y2ggdGhlIHN0YWtpbmcgb3BlcmF0aW9uIGZvclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3Rha2luZ09wZXJhdGlvbklkIFRoZSBJRCBvZiB0aGUgc3Rha2luZyBvcGVyYXRpb25cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGdldEV4dGVybmFsU3Rha2luZ09wZXJhdGlvbjogYXN5bmMgKG5ldHdvcmtJZCwgYWRkcmVzc0lkLCBzdGFraW5nT3BlcmF0aW9uSWQsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnbmV0d29ya0lkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2dldEV4dGVybmFsU3Rha2luZ09wZXJhdGlvbicsICduZXR3b3JrSWQnLCBuZXR3b3JrSWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnYWRkcmVzc0lkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2dldEV4dGVybmFsU3Rha2luZ09wZXJhdGlvbicsICdhZGRyZXNzSWQnLCBhZGRyZXNzSWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnc3Rha2luZ09wZXJhdGlvbklkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2dldEV4dGVybmFsU3Rha2luZ09wZXJhdGlvbicsICdzdGFraW5nT3BlcmF0aW9uSWQnLCBzdGFraW5nT3BlcmF0aW9uSWQpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS9uZXR3b3Jrcy97bmV0d29ya19pZH0vYWRkcmVzc2VzL3thZGRyZXNzX2lkfS9zdGFraW5nX29wZXJhdGlvbnMve3N0YWtpbmdfb3BlcmF0aW9uX2lkfWBcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJuZXR3b3JrX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcobmV0d29ya0lkKSkpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wiYWRkcmVzc19pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKGFkZHJlc3NJZCkpKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcInN0YWtpbmdfb3BlcmF0aW9uX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoc3Rha2luZ09wZXJhdGlvbklkKSkpO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7IG1ldGhvZDogJ0dFVCcsIC4uLmJhc2VPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gYXBpS2V5IHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIkp3dFwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIHNlc3Npb24gcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0geyAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlciwgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucywgLi4ub3B0aW9ucy5oZWFkZXJzIH07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHN0YWtpbmcgY29udGV4dCBmb3IgYW4gYWRkcmVzc1xuICAgICAgICAgKiBAc3VtbWFyeSBHZXQgc3Rha2luZyBjb250ZXh0XG4gICAgICAgICAqIEBwYXJhbSB7R2V0U3Rha2luZ0NvbnRleHRSZXF1ZXN0fSBnZXRTdGFraW5nQ29udGV4dFJlcXVlc3RcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGdldFN0YWtpbmdDb250ZXh0OiBhc3luYyAoZ2V0U3Rha2luZ0NvbnRleHRSZXF1ZXN0LCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2dldFN0YWtpbmdDb250ZXh0UmVxdWVzdCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdnZXRTdGFraW5nQ29udGV4dCcsICdnZXRTdGFraW5nQ29udGV4dFJlcXVlc3QnLCBnZXRTdGFraW5nQ29udGV4dFJlcXVlc3QpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS9zdGFrZS9jb250ZXh0YDtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0geyBtZXRob2Q6ICdQT1NUJywgLi4uYmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBhcGlLZXkgcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gc2Vzc2lvbiByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJKd3RcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBsb2NhbFZhckhlYWRlclBhcmFtZXRlclsnQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSB7IC4uLmxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCAuLi5oZWFkZXJzRnJvbUJhc2VPcHRpb25zLCAuLi5vcHRpb25zLmhlYWRlcnMgfTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuZGF0YSA9ICgwLCBjb21tb25fMS5zZXJpYWxpemVEYXRhSWZOZWVkZWQpKGdldFN0YWtpbmdDb250ZXh0UmVxdWVzdCwgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucywgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGEgdmFsaWRhdG9yIGJlbG9uZ2luZyB0byB0aGUgdXNlciBmb3IgYSBnaXZlbiBuZXR3b3JrLCBhc3NldCBhbmQgaWQuXG4gICAgICAgICAqIEBzdW1tYXJ5IEdldCBhIHZhbGlkYXRvciBiZWxvbmdpbmcgdG8gdGhlIENEUCBwcm9qZWN0XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWQgVGhlIElEIG9mIHRoZSBibG9ja2NoYWluIG5ldHdvcmsuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhc3NldElkIFRoZSBzeW1ib2wgb2YgdGhlIGFzc2V0IHRvIGdldCB0aGUgdmFsaWRhdG9yIGZvci5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbGlkYXRvcklkIFRoZSB1bmlxdWUgaWQgb2YgdGhlIHZhbGlkYXRvciB0byBmZXRjaCBkZXRhaWxzIGZvci5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGdldFZhbGlkYXRvcjogYXN5bmMgKG5ldHdvcmtJZCwgYXNzZXRJZCwgdmFsaWRhdG9ySWQsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnbmV0d29ya0lkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2dldFZhbGlkYXRvcicsICduZXR3b3JrSWQnLCBuZXR3b3JrSWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnYXNzZXRJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdnZXRWYWxpZGF0b3InLCAnYXNzZXRJZCcsIGFzc2V0SWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAndmFsaWRhdG9ySWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZ2V0VmFsaWRhdG9yJywgJ3ZhbGlkYXRvcklkJywgdmFsaWRhdG9ySWQpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS9uZXR3b3Jrcy97bmV0d29ya19pZH0vYXNzZXRzL3thc3NldF9pZH0vdmFsaWRhdG9ycy97dmFsaWRhdG9yX2lkfWBcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJuZXR3b3JrX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcobmV0d29ya0lkKSkpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wiYXNzZXRfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhhc3NldElkKSkpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1widmFsaWRhdG9yX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcodmFsaWRhdG9ySWQpKSk7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IHsgbWV0aG9kOiAnR0VUJywgLi4uYmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBhcGlLZXkgcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gc2Vzc2lvbiByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJKd3RcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSB7IC4uLmxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCAuLi5oZWFkZXJzRnJvbUJhc2VPcHRpb25zLCAuLi5vcHRpb25zLmhlYWRlcnMgfTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0IHZhbGlkYXRvcnMgYmVsb25naW5nIHRvIHRoZSB1c2VyIGZvciBhIGdpdmVuIG5ldHdvcmsgYW5kIGFzc2V0LlxuICAgICAgICAgKiBAc3VtbWFyeSBMaXN0IHZhbGlkYXRvcnMgYmVsb25naW5nIHRvIHRoZSBDRFAgcHJvamVjdFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29ya0lkIFRoZSBJRCBvZiB0aGUgYmxvY2tjaGFpbiBuZXR3b3JrLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXNzZXRJZCBUaGUgc3ltYm9sIG9mIHRoZSBhc3NldCB0byBnZXQgdGhlIHZhbGlkYXRvcnMgZm9yLlxuICAgICAgICAgKiBAcGFyYW0ge1ZhbGlkYXRvclN0YXR1c30gW3N0YXR1c10gQSBmaWx0ZXIgdG8gbGlzdCB2YWxpZGF0b3JzIGJhc2VkIG9uIGEgc3RhdHVzLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBBIGxpbWl0IG9uIHRoZSBudW1iZXIgb2Ygb2JqZWN0cyB0byBiZSByZXR1cm5lZC4gTGltaXQgY2FuIHJhbmdlIGJldHdlZW4gMSBhbmQgMTAwLCBhbmQgdGhlIGRlZmF1bHQgaXMgNTAuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZV0gQSBjdXJzb3IgZm9yIHBhZ2luYXRpb24gYWNyb3NzIG11bHRpcGxlIHBhZ2VzIG9mIHJlc3VsdHMuIERvblxcJiMzOTt0IGluY2x1ZGUgdGhpcyBwYXJhbWV0ZXIgb24gdGhlIGZpcnN0IGNhbGwuIFVzZSB0aGUgbmV4dF9wYWdlIHZhbHVlIHJldHVybmVkIGluIGEgcHJldmlvdXMgcmVzcG9uc2UgdG8gcmVxdWVzdCBzdWJzZXF1ZW50IHJlc3VsdHMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBsaXN0VmFsaWRhdG9yczogYXN5bmMgKG5ldHdvcmtJZCwgYXNzZXRJZCwgc3RhdHVzLCBsaW1pdCwgcGFnZSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICduZXR3b3JrSWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnbGlzdFZhbGlkYXRvcnMnLCAnbmV0d29ya0lkJywgbmV0d29ya0lkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2Fzc2V0SWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnbGlzdFZhbGlkYXRvcnMnLCAnYXNzZXRJZCcsIGFzc2V0SWQpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS9uZXR3b3Jrcy97bmV0d29ya19pZH0vYXNzZXRzL3thc3NldF9pZH0vdmFsaWRhdG9yc2BcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJuZXR3b3JrX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcobmV0d29ya0lkKSkpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wiYXNzZXRfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhhc3NldElkKSkpO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7IG1ldGhvZDogJ0dFVCcsIC4uLmJhc2VPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gYXBpS2V5IHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIkp3dFwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIHNlc3Npb24gcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgaWYgKHN0YXR1cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnc3RhdHVzJ10gPSBzdGF0dXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGltaXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ2xpbWl0J10gPSBsaW1pdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydwYWdlJ10gPSBwYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0geyAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlciwgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucywgLi4ub3B0aW9ucy5oZWFkZXJzIH07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5TdGFrZUFwaUF4aW9zUGFyYW1DcmVhdG9yID0gU3Rha2VBcGlBeGlvc1BhcmFtQ3JlYXRvcjtcbi8qKlxuICogU3Rha2VBcGkgLSBmdW5jdGlvbmFsIHByb2dyYW1taW5nIGludGVyZmFjZVxuICogQGV4cG9ydFxuICovXG5jb25zdCBTdGFrZUFwaUZwID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24pIHtcbiAgICBjb25zdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yID0gKDAsIGV4cG9ydHMuU3Rha2VBcGlBeGlvc1BhcmFtQ3JlYXRvcikoY29uZmlndXJhdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJ1aWxkIGEgbmV3IHN0YWtpbmcgb3BlcmF0aW9uXG4gICAgICAgICAqIEBzdW1tYXJ5IEJ1aWxkIGEgbmV3IHN0YWtpbmcgb3BlcmF0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7QnVpbGRTdGFraW5nT3BlcmF0aW9uUmVxdWVzdH0gYnVpbGRTdGFraW5nT3BlcmF0aW9uUmVxdWVzdFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgYnVpbGRTdGFraW5nT3BlcmF0aW9uKGJ1aWxkU3Rha2luZ09wZXJhdGlvblJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5idWlsZFN0YWtpbmdPcGVyYXRpb24oYnVpbGRTdGFraW5nT3BlcmF0aW9uUmVxdWVzdCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gY29uZmlndXJhdGlvbj8uc2VydmVySW5kZXggPz8gMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydTdGFrZUFwaS5idWlsZFN0YWtpbmdPcGVyYXRpb24nXT8uW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdPy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogRmV0Y2ggaGlzdG9yaWNhbCBzdGFraW5nIGJhbGFuY2VzIGZvciBnaXZlbiBhZGRyZXNzLlxuICAgICAgICAgKiBAc3VtbWFyeSBGZXRjaCBoaXN0b3JpY2FsIHN0YWtpbmcgYmFsYW5jZXNcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5ldHdvcmtJZCBUaGUgSUQgb2YgdGhlIGJsb2NrY2hhaW4gbmV0d29yay5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFzc2V0SWQgVGhlIElEIG9mIHRoZSBhc3NldCBmb3Igd2hpY2ggdGhlIGhpc3RvcmljYWwgc3Rha2luZyBiYWxhbmNlcyBhcmUgYmVpbmcgZmV0Y2hlZC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgb25jaGFpbiBhZGRyZXNzIGZvciB3aGljaCB0aGUgaGlzdG9yaWNhbCBzdGFraW5nIGJhbGFuY2VzIGFyZSBiZWluZyBmZXRjaGVkLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RhcnRUaW1lIFRoZSBzdGFydCB0aW1lIG9mIHRoaXMgaGlzdG9yaWNhbCBzdGFraW5nIGJhbGFuY2UgcGVyaW9kLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZW5kVGltZSBUaGUgZW5kIHRpbWUgb2YgdGhpcyBoaXN0b3JpY2FsIHN0YWtpbmcgYmFsYW5jZSBwZXJpb2QuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIEEgbGltaXQgb24gdGhlIG51bWJlciBvZiBvYmplY3RzIHRvIGJlIHJldHVybmVkLiBMaW1pdCBjYW4gcmFuZ2UgYmV0d2VlbiAxIGFuZCAxMDAsIGFuZCB0aGUgZGVmYXVsdCBpcyA1MC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlXSBBIGN1cnNvciBmb3IgcGFnaW5hdGlvbiBhY3Jvc3MgbXVsdGlwbGUgcGFnZXMgb2YgcmVzdWx0cy4gRG9uXFwmIzM5O3QgaW5jbHVkZSB0aGlzIHBhcmFtZXRlciBvbiB0aGUgZmlyc3QgY2FsbC4gVXNlIHRoZSBuZXh0X3BhZ2UgdmFsdWUgcmV0dXJuZWQgaW4gYSBwcmV2aW91cyByZXNwb25zZSB0byByZXF1ZXN0IHN1YnNlcXVlbnQgcmVzdWx0cy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGZldGNoSGlzdG9yaWNhbFN0YWtpbmdCYWxhbmNlcyhuZXR3b3JrSWQsIGFzc2V0SWQsIGFkZHJlc3NJZCwgc3RhcnRUaW1lLCBlbmRUaW1lLCBsaW1pdCwgcGFnZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmZldGNoSGlzdG9yaWNhbFN0YWtpbmdCYWxhbmNlcyhuZXR3b3JrSWQsIGFzc2V0SWQsIGFkZHJlc3NJZCwgc3RhcnRUaW1lLCBlbmRUaW1lLCBsaW1pdCwgcGFnZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gY29uZmlndXJhdGlvbj8uc2VydmVySW5kZXggPz8gMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydTdGFrZUFwaS5mZXRjaEhpc3RvcmljYWxTdGFraW5nQmFsYW5jZXMnXT8uW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdPy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogRmV0Y2ggc3Rha2luZyByZXdhcmRzIGZvciBhIGxpc3Qgb2YgYWRkcmVzc2VzXG4gICAgICAgICAqIEBzdW1tYXJ5IEZldGNoIHN0YWtpbmcgcmV3YXJkc1xuICAgICAgICAgKiBAcGFyYW0ge0ZldGNoU3Rha2luZ1Jld2FyZHNSZXF1ZXN0fSBmZXRjaFN0YWtpbmdSZXdhcmRzUmVxdWVzdFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBBIGxpbWl0IG9uIHRoZSBudW1iZXIgb2Ygb2JqZWN0cyB0byBiZSByZXR1cm5lZC4gTGltaXQgY2FuIHJhbmdlIGJldHdlZW4gMSBhbmQgMTAwLCBhbmQgdGhlIGRlZmF1bHQgaXMgNTAuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZV0gQSBjdXJzb3IgZm9yIHBhZ2luYXRpb24gYWNyb3NzIG11bHRpcGxlIHBhZ2VzIG9mIHJlc3VsdHMuIERvblxcJiMzOTt0IGluY2x1ZGUgdGhpcyBwYXJhbWV0ZXIgb24gdGhlIGZpcnN0IGNhbGwuIFVzZSB0aGUgbmV4dF9wYWdlIHZhbHVlIHJldHVybmVkIGluIGEgcHJldmlvdXMgcmVzcG9uc2UgdG8gcmVxdWVzdCBzdWJzZXF1ZW50IHJlc3VsdHMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBmZXRjaFN0YWtpbmdSZXdhcmRzKGZldGNoU3Rha2luZ1Jld2FyZHNSZXF1ZXN0LCBsaW1pdCwgcGFnZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmZldGNoU3Rha2luZ1Jld2FyZHMoZmV0Y2hTdGFraW5nUmV3YXJkc1JlcXVlc3QsIGxpbWl0LCBwYWdlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSBjb25maWd1cmF0aW9uPy5zZXJ2ZXJJbmRleCA/PyAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ1N0YWtlQXBpLmZldGNoU3Rha2luZ1Jld2FyZHMnXT8uW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdPy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBsYXRlc3Qgc3RhdGUgb2YgYSBzdGFraW5nIG9wZXJhdGlvblxuICAgICAgICAgKiBAc3VtbWFyeSBHZXQgdGhlIGxhdGVzdCBzdGF0ZSBvZiBhIHN0YWtpbmcgb3BlcmF0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWQgVGhlIElEIG9mIHRoZSBibG9ja2NoYWluIG5ldHdvcmtcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdG8gZmV0Y2ggdGhlIHN0YWtpbmcgb3BlcmF0aW9uIGZvclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3Rha2luZ09wZXJhdGlvbklkIFRoZSBJRCBvZiB0aGUgc3Rha2luZyBvcGVyYXRpb25cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGdldEV4dGVybmFsU3Rha2luZ09wZXJhdGlvbihuZXR3b3JrSWQsIGFkZHJlc3NJZCwgc3Rha2luZ09wZXJhdGlvbklkLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuZ2V0RXh0ZXJuYWxTdGFraW5nT3BlcmF0aW9uKG5ldHdvcmtJZCwgYWRkcmVzc0lkLCBzdGFraW5nT3BlcmF0aW9uSWQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IGNvbmZpZ3VyYXRpb24/LnNlcnZlckluZGV4ID8/IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnU3Rha2VBcGkuZ2V0RXh0ZXJuYWxTdGFraW5nT3BlcmF0aW9uJ10/Lltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XT8udXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBzdGFraW5nIGNvbnRleHQgZm9yIGFuIGFkZHJlc3NcbiAgICAgICAgICogQHN1bW1hcnkgR2V0IHN0YWtpbmcgY29udGV4dFxuICAgICAgICAgKiBAcGFyYW0ge0dldFN0YWtpbmdDb250ZXh0UmVxdWVzdH0gZ2V0U3Rha2luZ0NvbnRleHRSZXF1ZXN0XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBnZXRTdGFraW5nQ29udGV4dChnZXRTdGFraW5nQ29udGV4dFJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5nZXRTdGFraW5nQ29udGV4dChnZXRTdGFraW5nQ29udGV4dFJlcXVlc3QsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IGNvbmZpZ3VyYXRpb24/LnNlcnZlckluZGV4ID8/IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnU3Rha2VBcGkuZ2V0U3Rha2luZ0NvbnRleHQnXT8uW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdPy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGEgdmFsaWRhdG9yIGJlbG9uZ2luZyB0byB0aGUgdXNlciBmb3IgYSBnaXZlbiBuZXR3b3JrLCBhc3NldCBhbmQgaWQuXG4gICAgICAgICAqIEBzdW1tYXJ5IEdldCBhIHZhbGlkYXRvciBiZWxvbmdpbmcgdG8gdGhlIENEUCBwcm9qZWN0XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWQgVGhlIElEIG9mIHRoZSBibG9ja2NoYWluIG5ldHdvcmsuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhc3NldElkIFRoZSBzeW1ib2wgb2YgdGhlIGFzc2V0IHRvIGdldCB0aGUgdmFsaWRhdG9yIGZvci5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbGlkYXRvcklkIFRoZSB1bmlxdWUgaWQgb2YgdGhlIHZhbGlkYXRvciB0byBmZXRjaCBkZXRhaWxzIGZvci5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGdldFZhbGlkYXRvcihuZXR3b3JrSWQsIGFzc2V0SWQsIHZhbGlkYXRvcklkLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuZ2V0VmFsaWRhdG9yKG5ldHdvcmtJZCwgYXNzZXRJZCwgdmFsaWRhdG9ySWQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IGNvbmZpZ3VyYXRpb24/LnNlcnZlckluZGV4ID8/IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnU3Rha2VBcGkuZ2V0VmFsaWRhdG9yJ10/Lltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XT8udXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3QgdmFsaWRhdG9ycyBiZWxvbmdpbmcgdG8gdGhlIHVzZXIgZm9yIGEgZ2l2ZW4gbmV0d29yayBhbmQgYXNzZXQuXG4gICAgICAgICAqIEBzdW1tYXJ5IExpc3QgdmFsaWRhdG9ycyBiZWxvbmdpbmcgdG8gdGhlIENEUCBwcm9qZWN0XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWQgVGhlIElEIG9mIHRoZSBibG9ja2NoYWluIG5ldHdvcmsuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhc3NldElkIFRoZSBzeW1ib2wgb2YgdGhlIGFzc2V0IHRvIGdldCB0aGUgdmFsaWRhdG9ycyBmb3IuXG4gICAgICAgICAqIEBwYXJhbSB7VmFsaWRhdG9yU3RhdHVzfSBbc3RhdHVzXSBBIGZpbHRlciB0byBsaXN0IHZhbGlkYXRvcnMgYmFzZWQgb24gYSBzdGF0dXMuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIEEgbGltaXQgb24gdGhlIG51bWJlciBvZiBvYmplY3RzIHRvIGJlIHJldHVybmVkLiBMaW1pdCBjYW4gcmFuZ2UgYmV0d2VlbiAxIGFuZCAxMDAsIGFuZCB0aGUgZGVmYXVsdCBpcyA1MC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlXSBBIGN1cnNvciBmb3IgcGFnaW5hdGlvbiBhY3Jvc3MgbXVsdGlwbGUgcGFnZXMgb2YgcmVzdWx0cy4gRG9uXFwmIzM5O3QgaW5jbHVkZSB0aGlzIHBhcmFtZXRlciBvbiB0aGUgZmlyc3QgY2FsbC4gVXNlIHRoZSBuZXh0X3BhZ2UgdmFsdWUgcmV0dXJuZWQgaW4gYSBwcmV2aW91cyByZXNwb25zZSB0byByZXF1ZXN0IHN1YnNlcXVlbnQgcmVzdWx0cy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGxpc3RWYWxpZGF0b3JzKG5ldHdvcmtJZCwgYXNzZXRJZCwgc3RhdHVzLCBsaW1pdCwgcGFnZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmxpc3RWYWxpZGF0b3JzKG5ldHdvcmtJZCwgYXNzZXRJZCwgc3RhdHVzLCBsaW1pdCwgcGFnZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gY29uZmlndXJhdGlvbj8uc2VydmVySW5kZXggPz8gMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydTdGFrZUFwaS5saXN0VmFsaWRhdG9ycyddPy5bbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0/LnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5leHBvcnRzLlN0YWtlQXBpRnAgPSBTdGFrZUFwaUZwO1xuLyoqXG4gKiBTdGFrZUFwaSAtIGZhY3RvcnkgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IFN0YWtlQXBpRmFjdG9yeSA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uLCBiYXNlUGF0aCwgYXhpb3MpIHtcbiAgICBjb25zdCBsb2NhbFZhckZwID0gKDAsIGV4cG9ydHMuU3Rha2VBcGlGcCkoY29uZmlndXJhdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJ1aWxkIGEgbmV3IHN0YWtpbmcgb3BlcmF0aW9uXG4gICAgICAgICAqIEBzdW1tYXJ5IEJ1aWxkIGEgbmV3IHN0YWtpbmcgb3BlcmF0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7QnVpbGRTdGFraW5nT3BlcmF0aW9uUmVxdWVzdH0gYnVpbGRTdGFraW5nT3BlcmF0aW9uUmVxdWVzdFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYnVpbGRTdGFraW5nT3BlcmF0aW9uKGJ1aWxkU3Rha2luZ09wZXJhdGlvblJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmJ1aWxkU3Rha2luZ09wZXJhdGlvbihidWlsZFN0YWtpbmdPcGVyYXRpb25SZXF1ZXN0LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogRmV0Y2ggaGlzdG9yaWNhbCBzdGFraW5nIGJhbGFuY2VzIGZvciBnaXZlbiBhZGRyZXNzLlxuICAgICAgICAgKiBAc3VtbWFyeSBGZXRjaCBoaXN0b3JpY2FsIHN0YWtpbmcgYmFsYW5jZXNcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5ldHdvcmtJZCBUaGUgSUQgb2YgdGhlIGJsb2NrY2hhaW4gbmV0d29yay5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFzc2V0SWQgVGhlIElEIG9mIHRoZSBhc3NldCBmb3Igd2hpY2ggdGhlIGhpc3RvcmljYWwgc3Rha2luZyBiYWxhbmNlcyBhcmUgYmVpbmcgZmV0Y2hlZC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgb25jaGFpbiBhZGRyZXNzIGZvciB3aGljaCB0aGUgaGlzdG9yaWNhbCBzdGFraW5nIGJhbGFuY2VzIGFyZSBiZWluZyBmZXRjaGVkLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RhcnRUaW1lIFRoZSBzdGFydCB0aW1lIG9mIHRoaXMgaGlzdG9yaWNhbCBzdGFraW5nIGJhbGFuY2UgcGVyaW9kLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZW5kVGltZSBUaGUgZW5kIHRpbWUgb2YgdGhpcyBoaXN0b3JpY2FsIHN0YWtpbmcgYmFsYW5jZSBwZXJpb2QuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIEEgbGltaXQgb24gdGhlIG51bWJlciBvZiBvYmplY3RzIHRvIGJlIHJldHVybmVkLiBMaW1pdCBjYW4gcmFuZ2UgYmV0d2VlbiAxIGFuZCAxMDAsIGFuZCB0aGUgZGVmYXVsdCBpcyA1MC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlXSBBIGN1cnNvciBmb3IgcGFnaW5hdGlvbiBhY3Jvc3MgbXVsdGlwbGUgcGFnZXMgb2YgcmVzdWx0cy4gRG9uXFwmIzM5O3QgaW5jbHVkZSB0aGlzIHBhcmFtZXRlciBvbiB0aGUgZmlyc3QgY2FsbC4gVXNlIHRoZSBuZXh0X3BhZ2UgdmFsdWUgcmV0dXJuZWQgaW4gYSBwcmV2aW91cyByZXNwb25zZSB0byByZXF1ZXN0IHN1YnNlcXVlbnQgcmVzdWx0cy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGZldGNoSGlzdG9yaWNhbFN0YWtpbmdCYWxhbmNlcyhuZXR3b3JrSWQsIGFzc2V0SWQsIGFkZHJlc3NJZCwgc3RhcnRUaW1lLCBlbmRUaW1lLCBsaW1pdCwgcGFnZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuZmV0Y2hIaXN0b3JpY2FsU3Rha2luZ0JhbGFuY2VzKG5ldHdvcmtJZCwgYXNzZXRJZCwgYWRkcmVzc0lkLCBzdGFydFRpbWUsIGVuZFRpbWUsIGxpbWl0LCBwYWdlLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogRmV0Y2ggc3Rha2luZyByZXdhcmRzIGZvciBhIGxpc3Qgb2YgYWRkcmVzc2VzXG4gICAgICAgICAqIEBzdW1tYXJ5IEZldGNoIHN0YWtpbmcgcmV3YXJkc1xuICAgICAgICAgKiBAcGFyYW0ge0ZldGNoU3Rha2luZ1Jld2FyZHNSZXF1ZXN0fSBmZXRjaFN0YWtpbmdSZXdhcmRzUmVxdWVzdFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBBIGxpbWl0IG9uIHRoZSBudW1iZXIgb2Ygb2JqZWN0cyB0byBiZSByZXR1cm5lZC4gTGltaXQgY2FuIHJhbmdlIGJldHdlZW4gMSBhbmQgMTAwLCBhbmQgdGhlIGRlZmF1bHQgaXMgNTAuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZV0gQSBjdXJzb3IgZm9yIHBhZ2luYXRpb24gYWNyb3NzIG11bHRpcGxlIHBhZ2VzIG9mIHJlc3VsdHMuIERvblxcJiMzOTt0IGluY2x1ZGUgdGhpcyBwYXJhbWV0ZXIgb24gdGhlIGZpcnN0IGNhbGwuIFVzZSB0aGUgbmV4dF9wYWdlIHZhbHVlIHJldHVybmVkIGluIGEgcHJldmlvdXMgcmVzcG9uc2UgdG8gcmVxdWVzdCBzdWJzZXF1ZW50IHJlc3VsdHMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBmZXRjaFN0YWtpbmdSZXdhcmRzKGZldGNoU3Rha2luZ1Jld2FyZHNSZXF1ZXN0LCBsaW1pdCwgcGFnZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuZmV0Y2hTdGFraW5nUmV3YXJkcyhmZXRjaFN0YWtpbmdSZXdhcmRzUmVxdWVzdCwgbGltaXQsIHBhZ2UsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGxhdGVzdCBzdGF0ZSBvZiBhIHN0YWtpbmcgb3BlcmF0aW9uXG4gICAgICAgICAqIEBzdW1tYXJ5IEdldCB0aGUgbGF0ZXN0IHN0YXRlIG9mIGEgc3Rha2luZyBvcGVyYXRpb25cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5ldHdvcmtJZCBUaGUgSUQgb2YgdGhlIGJsb2NrY2hhaW4gbmV0d29ya1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0byBmZXRjaCB0aGUgc3Rha2luZyBvcGVyYXRpb24gZm9yXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdGFraW5nT3BlcmF0aW9uSWQgVGhlIElEIG9mIHRoZSBzdGFraW5nIG9wZXJhdGlvblxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0RXh0ZXJuYWxTdGFraW5nT3BlcmF0aW9uKG5ldHdvcmtJZCwgYWRkcmVzc0lkLCBzdGFraW5nT3BlcmF0aW9uSWQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmdldEV4dGVybmFsU3Rha2luZ09wZXJhdGlvbihuZXR3b3JrSWQsIGFkZHJlc3NJZCwgc3Rha2luZ09wZXJhdGlvbklkLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHN0YWtpbmcgY29udGV4dCBmb3IgYW4gYWRkcmVzc1xuICAgICAgICAgKiBAc3VtbWFyeSBHZXQgc3Rha2luZyBjb250ZXh0XG4gICAgICAgICAqIEBwYXJhbSB7R2V0U3Rha2luZ0NvbnRleHRSZXF1ZXN0fSBnZXRTdGFraW5nQ29udGV4dFJlcXVlc3RcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGdldFN0YWtpbmdDb250ZXh0KGdldFN0YWtpbmdDb250ZXh0UmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuZ2V0U3Rha2luZ0NvbnRleHQoZ2V0U3Rha2luZ0NvbnRleHRSZXF1ZXN0LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGEgdmFsaWRhdG9yIGJlbG9uZ2luZyB0byB0aGUgdXNlciBmb3IgYSBnaXZlbiBuZXR3b3JrLCBhc3NldCBhbmQgaWQuXG4gICAgICAgICAqIEBzdW1tYXJ5IEdldCBhIHZhbGlkYXRvciBiZWxvbmdpbmcgdG8gdGhlIENEUCBwcm9qZWN0XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWQgVGhlIElEIG9mIHRoZSBibG9ja2NoYWluIG5ldHdvcmsuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhc3NldElkIFRoZSBzeW1ib2wgb2YgdGhlIGFzc2V0IHRvIGdldCB0aGUgdmFsaWRhdG9yIGZvci5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbGlkYXRvcklkIFRoZSB1bmlxdWUgaWQgb2YgdGhlIHZhbGlkYXRvciB0byBmZXRjaCBkZXRhaWxzIGZvci5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGdldFZhbGlkYXRvcihuZXR3b3JrSWQsIGFzc2V0SWQsIHZhbGlkYXRvcklkLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5nZXRWYWxpZGF0b3IobmV0d29ya0lkLCBhc3NldElkLCB2YWxpZGF0b3JJZCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3QgdmFsaWRhdG9ycyBiZWxvbmdpbmcgdG8gdGhlIHVzZXIgZm9yIGEgZ2l2ZW4gbmV0d29yayBhbmQgYXNzZXQuXG4gICAgICAgICAqIEBzdW1tYXJ5IExpc3QgdmFsaWRhdG9ycyBiZWxvbmdpbmcgdG8gdGhlIENEUCBwcm9qZWN0XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWQgVGhlIElEIG9mIHRoZSBibG9ja2NoYWluIG5ldHdvcmsuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhc3NldElkIFRoZSBzeW1ib2wgb2YgdGhlIGFzc2V0IHRvIGdldCB0aGUgdmFsaWRhdG9ycyBmb3IuXG4gICAgICAgICAqIEBwYXJhbSB7VmFsaWRhdG9yU3RhdHVzfSBbc3RhdHVzXSBBIGZpbHRlciB0byBsaXN0IHZhbGlkYXRvcnMgYmFzZWQgb24gYSBzdGF0dXMuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIEEgbGltaXQgb24gdGhlIG51bWJlciBvZiBvYmplY3RzIHRvIGJlIHJldHVybmVkLiBMaW1pdCBjYW4gcmFuZ2UgYmV0d2VlbiAxIGFuZCAxMDAsIGFuZCB0aGUgZGVmYXVsdCBpcyA1MC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlXSBBIGN1cnNvciBmb3IgcGFnaW5hdGlvbiBhY3Jvc3MgbXVsdGlwbGUgcGFnZXMgb2YgcmVzdWx0cy4gRG9uXFwmIzM5O3QgaW5jbHVkZSB0aGlzIHBhcmFtZXRlciBvbiB0aGUgZmlyc3QgY2FsbC4gVXNlIHRoZSBuZXh0X3BhZ2UgdmFsdWUgcmV0dXJuZWQgaW4gYSBwcmV2aW91cyByZXNwb25zZSB0byByZXF1ZXN0IHN1YnNlcXVlbnQgcmVzdWx0cy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGxpc3RWYWxpZGF0b3JzKG5ldHdvcmtJZCwgYXNzZXRJZCwgc3RhdHVzLCBsaW1pdCwgcGFnZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAubGlzdFZhbGlkYXRvcnMobmV0d29ya0lkLCBhc3NldElkLCBzdGF0dXMsIGxpbWl0LCBwYWdlLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5TdGFrZUFwaUZhY3RvcnkgPSBTdGFrZUFwaUZhY3Rvcnk7XG4vKipcbiAqIFN0YWtlQXBpIC0gb2JqZWN0LW9yaWVudGVkIGludGVyZmFjZVxuICogQGV4cG9ydFxuICogQGNsYXNzIFN0YWtlQXBpXG4gKiBAZXh0ZW5kcyB7QmFzZUFQSX1cbiAqL1xuY2xhc3MgU3Rha2VBcGkgZXh0ZW5kcyBiYXNlXzEuQmFzZUFQSSB7XG4gICAgLyoqXG4gICAgICogQnVpbGQgYSBuZXcgc3Rha2luZyBvcGVyYXRpb25cbiAgICAgKiBAc3VtbWFyeSBCdWlsZCBhIG5ldyBzdGFraW5nIG9wZXJhdGlvblxuICAgICAqIEBwYXJhbSB7QnVpbGRTdGFraW5nT3BlcmF0aW9uUmVxdWVzdH0gYnVpbGRTdGFraW5nT3BlcmF0aW9uUmVxdWVzdFxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgU3Rha2VBcGlcbiAgICAgKi9cbiAgICBidWlsZFN0YWtpbmdPcGVyYXRpb24oYnVpbGRTdGFraW5nT3BlcmF0aW9uUmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuU3Rha2VBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5idWlsZFN0YWtpbmdPcGVyYXRpb24oYnVpbGRTdGFraW5nT3BlcmF0aW9uUmVxdWVzdCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoIGhpc3RvcmljYWwgc3Rha2luZyBiYWxhbmNlcyBmb3IgZ2l2ZW4gYWRkcmVzcy5cbiAgICAgKiBAc3VtbWFyeSBGZXRjaCBoaXN0b3JpY2FsIHN0YWtpbmcgYmFsYW5jZXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29ya0lkIFRoZSBJRCBvZiB0aGUgYmxvY2tjaGFpbiBuZXR3b3JrLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhc3NldElkIFRoZSBJRCBvZiB0aGUgYXNzZXQgZm9yIHdoaWNoIHRoZSBoaXN0b3JpY2FsIHN0YWtpbmcgYmFsYW5jZXMgYXJlIGJlaW5nIGZldGNoZWQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgb25jaGFpbiBhZGRyZXNzIGZvciB3aGljaCB0aGUgaGlzdG9yaWNhbCBzdGFraW5nIGJhbGFuY2VzIGFyZSBiZWluZyBmZXRjaGVkLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdGFydFRpbWUgVGhlIHN0YXJ0IHRpbWUgb2YgdGhpcyBoaXN0b3JpY2FsIHN0YWtpbmcgYmFsYW5jZSBwZXJpb2QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGVuZFRpbWUgVGhlIGVuZCB0aW1lIG9mIHRoaXMgaGlzdG9yaWNhbCBzdGFraW5nIGJhbGFuY2UgcGVyaW9kLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIEEgbGltaXQgb24gdGhlIG51bWJlciBvZiBvYmplY3RzIHRvIGJlIHJldHVybmVkLiBMaW1pdCBjYW4gcmFuZ2UgYmV0d2VlbiAxIGFuZCAxMDAsIGFuZCB0aGUgZGVmYXVsdCBpcyA1MC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VdIEEgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiByZXN1bHRzLiBEb25cXCYjMzk7dCBpbmNsdWRlIHRoaXMgcGFyYW1ldGVyIG9uIHRoZSBmaXJzdCBjYWxsLiBVc2UgdGhlIG5leHRfcGFnZSB2YWx1ZSByZXR1cm5lZCBpbiBhIHByZXZpb3VzIHJlc3BvbnNlIHRvIHJlcXVlc3Qgc3Vic2VxdWVudCByZXN1bHRzLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgU3Rha2VBcGlcbiAgICAgKi9cbiAgICBmZXRjaEhpc3RvcmljYWxTdGFraW5nQmFsYW5jZXMobmV0d29ya0lkLCBhc3NldElkLCBhZGRyZXNzSWQsIHN0YXJ0VGltZSwgZW5kVGltZSwgbGltaXQsIHBhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLlN0YWtlQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuZmV0Y2hIaXN0b3JpY2FsU3Rha2luZ0JhbGFuY2VzKG5ldHdvcmtJZCwgYXNzZXRJZCwgYWRkcmVzc0lkLCBzdGFydFRpbWUsIGVuZFRpbWUsIGxpbWl0LCBwYWdlLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2ggc3Rha2luZyByZXdhcmRzIGZvciBhIGxpc3Qgb2YgYWRkcmVzc2VzXG4gICAgICogQHN1bW1hcnkgRmV0Y2ggc3Rha2luZyByZXdhcmRzXG4gICAgICogQHBhcmFtIHtGZXRjaFN0YWtpbmdSZXdhcmRzUmVxdWVzdH0gZmV0Y2hTdGFraW5nUmV3YXJkc1JlcXVlc3RcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBBIGxpbWl0IG9uIHRoZSBudW1iZXIgb2Ygb2JqZWN0cyB0byBiZSByZXR1cm5lZC4gTGltaXQgY2FuIHJhbmdlIGJldHdlZW4gMSBhbmQgMTAwLCBhbmQgdGhlIGRlZmF1bHQgaXMgNTAuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlXSBBIGN1cnNvciBmb3IgcGFnaW5hdGlvbiBhY3Jvc3MgbXVsdGlwbGUgcGFnZXMgb2YgcmVzdWx0cy4gRG9uXFwmIzM5O3QgaW5jbHVkZSB0aGlzIHBhcmFtZXRlciBvbiB0aGUgZmlyc3QgY2FsbC4gVXNlIHRoZSBuZXh0X3BhZ2UgdmFsdWUgcmV0dXJuZWQgaW4gYSBwcmV2aW91cyByZXNwb25zZSB0byByZXF1ZXN0IHN1YnNlcXVlbnQgcmVzdWx0cy5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIFN0YWtlQXBpXG4gICAgICovXG4gICAgZmV0Y2hTdGFraW5nUmV3YXJkcyhmZXRjaFN0YWtpbmdSZXdhcmRzUmVxdWVzdCwgbGltaXQsIHBhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLlN0YWtlQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuZmV0Y2hTdGFraW5nUmV3YXJkcyhmZXRjaFN0YWtpbmdSZXdhcmRzUmVxdWVzdCwgbGltaXQsIHBhZ2UsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGxhdGVzdCBzdGF0ZSBvZiBhIHN0YWtpbmcgb3BlcmF0aW9uXG4gICAgICogQHN1bW1hcnkgR2V0IHRoZSBsYXRlc3Qgc3RhdGUgb2YgYSBzdGFraW5nIG9wZXJhdGlvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWQgVGhlIElEIG9mIHRoZSBibG9ja2NoYWluIG5ldHdvcmtcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0byBmZXRjaCB0aGUgc3Rha2luZyBvcGVyYXRpb24gZm9yXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0YWtpbmdPcGVyYXRpb25JZCBUaGUgSUQgb2YgdGhlIHN0YWtpbmcgb3BlcmF0aW9uXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBTdGFrZUFwaVxuICAgICAqL1xuICAgIGdldEV4dGVybmFsU3Rha2luZ09wZXJhdGlvbihuZXR3b3JrSWQsIGFkZHJlc3NJZCwgc3Rha2luZ09wZXJhdGlvbklkLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5TdGFrZUFwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLmdldEV4dGVybmFsU3Rha2luZ09wZXJhdGlvbihuZXR3b3JrSWQsIGFkZHJlc3NJZCwgc3Rha2luZ09wZXJhdGlvbklkLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHN0YWtpbmcgY29udGV4dCBmb3IgYW4gYWRkcmVzc1xuICAgICAqIEBzdW1tYXJ5IEdldCBzdGFraW5nIGNvbnRleHRcbiAgICAgKiBAcGFyYW0ge0dldFN0YWtpbmdDb250ZXh0UmVxdWVzdH0gZ2V0U3Rha2luZ0NvbnRleHRSZXF1ZXN0XG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBTdGFrZUFwaVxuICAgICAqL1xuICAgIGdldFN0YWtpbmdDb250ZXh0KGdldFN0YWtpbmdDb250ZXh0UmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuU3Rha2VBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5nZXRTdGFraW5nQ29udGV4dChnZXRTdGFraW5nQ29udGV4dFJlcXVlc3QsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYSB2YWxpZGF0b3IgYmVsb25naW5nIHRvIHRoZSB1c2VyIGZvciBhIGdpdmVuIG5ldHdvcmssIGFzc2V0IGFuZCBpZC5cbiAgICAgKiBAc3VtbWFyeSBHZXQgYSB2YWxpZGF0b3IgYmVsb25naW5nIHRvIHRoZSBDRFAgcHJvamVjdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWQgVGhlIElEIG9mIHRoZSBibG9ja2NoYWluIG5ldHdvcmsuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFzc2V0SWQgVGhlIHN5bWJvbCBvZiB0aGUgYXNzZXQgdG8gZ2V0IHRoZSB2YWxpZGF0b3IgZm9yLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWxpZGF0b3JJZCBUaGUgdW5pcXVlIGlkIG9mIHRoZSB2YWxpZGF0b3IgdG8gZmV0Y2ggZGV0YWlscyBmb3IuXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBTdGFrZUFwaVxuICAgICAqL1xuICAgIGdldFZhbGlkYXRvcihuZXR3b3JrSWQsIGFzc2V0SWQsIHZhbGlkYXRvcklkLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5TdGFrZUFwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLmdldFZhbGlkYXRvcihuZXR3b3JrSWQsIGFzc2V0SWQsIHZhbGlkYXRvcklkLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdCB2YWxpZGF0b3JzIGJlbG9uZ2luZyB0byB0aGUgdXNlciBmb3IgYSBnaXZlbiBuZXR3b3JrIGFuZCBhc3NldC5cbiAgICAgKiBAc3VtbWFyeSBMaXN0IHZhbGlkYXRvcnMgYmVsb25naW5nIHRvIHRoZSBDRFAgcHJvamVjdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWQgVGhlIElEIG9mIHRoZSBibG9ja2NoYWluIG5ldHdvcmsuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFzc2V0SWQgVGhlIHN5bWJvbCBvZiB0aGUgYXNzZXQgdG8gZ2V0IHRoZSB2YWxpZGF0b3JzIGZvci5cbiAgICAgKiBAcGFyYW0ge1ZhbGlkYXRvclN0YXR1c30gW3N0YXR1c10gQSBmaWx0ZXIgdG8gbGlzdCB2YWxpZGF0b3JzIGJhc2VkIG9uIGEgc3RhdHVzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIEEgbGltaXQgb24gdGhlIG51bWJlciBvZiBvYmplY3RzIHRvIGJlIHJldHVybmVkLiBMaW1pdCBjYW4gcmFuZ2UgYmV0d2VlbiAxIGFuZCAxMDAsIGFuZCB0aGUgZGVmYXVsdCBpcyA1MC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VdIEEgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiByZXN1bHRzLiBEb25cXCYjMzk7dCBpbmNsdWRlIHRoaXMgcGFyYW1ldGVyIG9uIHRoZSBmaXJzdCBjYWxsLiBVc2UgdGhlIG5leHRfcGFnZSB2YWx1ZSByZXR1cm5lZCBpbiBhIHByZXZpb3VzIHJlc3BvbnNlIHRvIHJlcXVlc3Qgc3Vic2VxdWVudCByZXN1bHRzLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgU3Rha2VBcGlcbiAgICAgKi9cbiAgICBsaXN0VmFsaWRhdG9ycyhuZXR3b3JrSWQsIGFzc2V0SWQsIHN0YXR1cywgbGltaXQsIHBhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLlN0YWtlQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikubGlzdFZhbGlkYXRvcnMobmV0d29ya0lkLCBhc3NldElkLCBzdGF0dXMsIGxpbWl0LCBwYWdlLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG59XG5leHBvcnRzLlN0YWtlQXBpID0gU3Rha2VBcGk7XG4vKipcbiAqIFRyYWRlc0FwaSAtIGF4aW9zIHBhcmFtZXRlciBjcmVhdG9yXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IFRyYWRlc0FwaUF4aW9zUGFyYW1DcmVhdG9yID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQnJvYWRjYXN0IGEgdHJhZGVcbiAgICAgICAgICogQHN1bW1hcnkgQnJvYWRjYXN0IGEgdHJhZGVcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG9cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdGhlIHRyYWRlIGJlbG9uZ3MgdG9cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHRyYWRlSWQgVGhlIElEIG9mIHRoZSB0cmFkZSB0byBicm9hZGNhc3RcbiAgICAgICAgICogQHBhcmFtIHtCcm9hZGNhc3RUcmFkZVJlcXVlc3R9IGJyb2FkY2FzdFRyYWRlUmVxdWVzdFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYnJvYWRjYXN0VHJhZGU6IGFzeW5jICh3YWxsZXRJZCwgYWRkcmVzc0lkLCB0cmFkZUlkLCBicm9hZGNhc3RUcmFkZVJlcXVlc3QsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnd2FsbGV0SWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnYnJvYWRjYXN0VHJhZGUnLCAnd2FsbGV0SWQnLCB3YWxsZXRJZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdhZGRyZXNzSWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnYnJvYWRjYXN0VHJhZGUnLCAnYWRkcmVzc0lkJywgYWRkcmVzc0lkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ3RyYWRlSWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnYnJvYWRjYXN0VHJhZGUnLCAndHJhZGVJZCcsIHRyYWRlSWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnYnJvYWRjYXN0VHJhZGVSZXF1ZXN0JyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2Jyb2FkY2FzdFRyYWRlJywgJ2Jyb2FkY2FzdFRyYWRlUmVxdWVzdCcsIGJyb2FkY2FzdFRyYWRlUmVxdWVzdCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL3dhbGxldHMve3dhbGxldF9pZH0vYWRkcmVzc2VzL3thZGRyZXNzX2lkfS90cmFkZXMve3RyYWRlX2lkfS9icm9hZGNhc3RgXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wid2FsbGV0X2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcod2FsbGV0SWQpKSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJhZGRyZXNzX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoYWRkcmVzc0lkKSkpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1widHJhZGVfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyh0cmFkZUlkKSkpO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7IG1ldGhvZDogJ1BPU1QnLCAuLi5iYXNlT3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIGFwaUtleSByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJKd3RcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBsb2NhbFZhckhlYWRlclBhcmFtZXRlclsnQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSB7IC4uLmxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCAuLi5oZWFkZXJzRnJvbUJhc2VPcHRpb25zLCAuLi5vcHRpb25zLmhlYWRlcnMgfTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuZGF0YSA9ICgwLCBjb21tb25fMS5zZXJpYWxpemVEYXRhSWZOZWVkZWQpKGJyb2FkY2FzdFRyYWRlUmVxdWVzdCwgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucywgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgbmV3IHRyYWRlXG4gICAgICAgICAqIEBzdW1tYXJ5IENyZWF0ZSBhIG5ldyB0cmFkZSBmb3IgYW4gYWRkcmVzc1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIHNvdXJjZSBhZGRyZXNzIGJlbG9uZ3MgdG9cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdG8gY29uZHVjdCB0aGUgdHJhZGUgZnJvbVxuICAgICAgICAgKiBAcGFyYW0ge0NyZWF0ZVRyYWRlUmVxdWVzdH0gY3JlYXRlVHJhZGVSZXF1ZXN0XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGVUcmFkZTogYXN5bmMgKHdhbGxldElkLCBhZGRyZXNzSWQsIGNyZWF0ZVRyYWRlUmVxdWVzdCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICd3YWxsZXRJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdjcmVhdGVUcmFkZScsICd3YWxsZXRJZCcsIHdhbGxldElkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2FkZHJlc3NJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdjcmVhdGVUcmFkZScsICdhZGRyZXNzSWQnLCBhZGRyZXNzSWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnY3JlYXRlVHJhZGVSZXF1ZXN0JyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2NyZWF0ZVRyYWRlJywgJ2NyZWF0ZVRyYWRlUmVxdWVzdCcsIGNyZWF0ZVRyYWRlUmVxdWVzdCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL3dhbGxldHMve3dhbGxldF9pZH0vYWRkcmVzc2VzL3thZGRyZXNzX2lkfS90cmFkZXNgXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wid2FsbGV0X2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcod2FsbGV0SWQpKSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJhZGRyZXNzX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoYWRkcmVzc0lkKSkpO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7IG1ldGhvZDogJ1BPU1QnLCAuLi5iYXNlT3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIGFwaUtleSByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJKd3RcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBsb2NhbFZhckhlYWRlclBhcmFtZXRlclsnQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSB7IC4uLmxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCAuLi5oZWFkZXJzRnJvbUJhc2VPcHRpb25zLCAuLi5vcHRpb25zLmhlYWRlcnMgfTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuZGF0YSA9ICgwLCBjb21tb25fMS5zZXJpYWxpemVEYXRhSWZOZWVkZWQpKGNyZWF0ZVRyYWRlUmVxdWVzdCwgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucywgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGEgdHJhZGUgYnkgSURcbiAgICAgICAgICogQHN1bW1hcnkgR2V0IGEgdHJhZGUgYnkgSURcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG9cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdGhlIHRyYWRlIGJlbG9uZ3MgdG9cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHRyYWRlSWQgVGhlIElEIG9mIHRoZSB0cmFkZSB0byBmZXRjaFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0VHJhZGU6IGFzeW5jICh3YWxsZXRJZCwgYWRkcmVzc0lkLCB0cmFkZUlkLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ3dhbGxldElkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2dldFRyYWRlJywgJ3dhbGxldElkJywgd2FsbGV0SWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnYWRkcmVzc0lkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2dldFRyYWRlJywgJ2FkZHJlc3NJZCcsIGFkZHJlc3NJZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICd0cmFkZUlkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2dldFRyYWRlJywgJ3RyYWRlSWQnLCB0cmFkZUlkKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvd2FsbGV0cy97d2FsbGV0X2lkfS9hZGRyZXNzZXMve2FkZHJlc3NfaWR9L3RyYWRlcy97dHJhZGVfaWR9YFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcIndhbGxldF9pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHdhbGxldElkKSkpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wiYWRkcmVzc19pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKGFkZHJlc3NJZCkpKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcInRyYWRlX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcodHJhZGVJZCkpKTtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0geyBtZXRob2Q6ICdHRVQnLCAuLi5iYXNlT3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIGFwaUtleSByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJKd3RcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBzZXNzaW9uIHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIkp3dFwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IHsgLi4ubG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIC4uLmhlYWRlcnNGcm9tQmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMuaGVhZGVycyB9O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3QgdHJhZGVzIGZvciBhbiBhZGRyZXNzLlxuICAgICAgICAgKiBAc3VtbWFyeSBMaXN0IHRyYWRlcyBmb3IgYW4gYWRkcmVzcy5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG9cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdG8gbGlzdCB0cmFkZXMgZm9yXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIEEgbGltaXQgb24gdGhlIG51bWJlciBvZiBvYmplY3RzIHRvIGJlIHJldHVybmVkLiBMaW1pdCBjYW4gcmFuZ2UgYmV0d2VlbiAxIGFuZCAxMDAsIGFuZCB0aGUgZGVmYXVsdCBpcyAxMC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlXSBBIGN1cnNvciBmb3IgcGFnaW5hdGlvbiBhY3Jvc3MgbXVsdGlwbGUgcGFnZXMgb2YgcmVzdWx0cy4gRG9uXFwmIzM5O3QgaW5jbHVkZSB0aGlzIHBhcmFtZXRlciBvbiB0aGUgZmlyc3QgY2FsbC4gVXNlIHRoZSBuZXh0X3BhZ2UgdmFsdWUgcmV0dXJuZWQgaW4gYSBwcmV2aW91cyByZXNwb25zZSB0byByZXF1ZXN0IHN1YnNlcXVlbnQgcmVzdWx0cy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGxpc3RUcmFkZXM6IGFzeW5jICh3YWxsZXRJZCwgYWRkcmVzc0lkLCBsaW1pdCwgcGFnZSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICd3YWxsZXRJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdsaXN0VHJhZGVzJywgJ3dhbGxldElkJywgd2FsbGV0SWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnYWRkcmVzc0lkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2xpc3RUcmFkZXMnLCAnYWRkcmVzc0lkJywgYWRkcmVzc0lkKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvd2FsbGV0cy97d2FsbGV0X2lkfS9hZGRyZXNzZXMve2FkZHJlc3NfaWR9L3RyYWRlc2BcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJ3YWxsZXRfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyh3YWxsZXRJZCkpKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcImFkZHJlc3NfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhhZGRyZXNzSWQpKSk7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IHsgbWV0aG9kOiAnR0VUJywgLi4uYmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBhcGlLZXkgcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gc2Vzc2lvbiByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJKd3RcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBpZiAobGltaXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ2xpbWl0J10gPSBsaW1pdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydwYWdlJ10gPSBwYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0geyAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlciwgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucywgLi4ub3B0aW9ucy5oZWFkZXJzIH07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5UcmFkZXNBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IFRyYWRlc0FwaUF4aW9zUGFyYW1DcmVhdG9yO1xuLyoqXG4gKiBUcmFkZXNBcGkgLSBmdW5jdGlvbmFsIHByb2dyYW1taW5nIGludGVyZmFjZVxuICogQGV4cG9ydFxuICovXG5jb25zdCBUcmFkZXNBcGlGcCA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uKSB7XG4gICAgY29uc3QgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvciA9ICgwLCBleHBvcnRzLlRyYWRlc0FwaUF4aW9zUGFyYW1DcmVhdG9yKShjb25maWd1cmF0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQnJvYWRjYXN0IGEgdHJhZGVcbiAgICAgICAgICogQHN1bW1hcnkgQnJvYWRjYXN0IGEgdHJhZGVcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG9cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdGhlIHRyYWRlIGJlbG9uZ3MgdG9cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHRyYWRlSWQgVGhlIElEIG9mIHRoZSB0cmFkZSB0byBicm9hZGNhc3RcbiAgICAgICAgICogQHBhcmFtIHtCcm9hZGNhc3RUcmFkZVJlcXVlc3R9IGJyb2FkY2FzdFRyYWRlUmVxdWVzdFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgYnJvYWRjYXN0VHJhZGUod2FsbGV0SWQsIGFkZHJlc3NJZCwgdHJhZGVJZCwgYnJvYWRjYXN0VHJhZGVSZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuYnJvYWRjYXN0VHJhZGUod2FsbGV0SWQsIGFkZHJlc3NJZCwgdHJhZGVJZCwgYnJvYWRjYXN0VHJhZGVSZXF1ZXN0LCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSBjb25maWd1cmF0aW9uPy5zZXJ2ZXJJbmRleCA/PyAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ1RyYWRlc0FwaS5icm9hZGNhc3RUcmFkZSddPy5bbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0/LnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSBuZXcgdHJhZGVcbiAgICAgICAgICogQHN1bW1hcnkgQ3JlYXRlIGEgbmV3IHRyYWRlIGZvciBhbiBhZGRyZXNzXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgc291cmNlIGFkZHJlc3MgYmVsb25ncyB0b1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0byBjb25kdWN0IHRoZSB0cmFkZSBmcm9tXG4gICAgICAgICAqIEBwYXJhbSB7Q3JlYXRlVHJhZGVSZXF1ZXN0fSBjcmVhdGVUcmFkZVJlcXVlc3RcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGNyZWF0ZVRyYWRlKHdhbGxldElkLCBhZGRyZXNzSWQsIGNyZWF0ZVRyYWRlUmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmNyZWF0ZVRyYWRlKHdhbGxldElkLCBhZGRyZXNzSWQsIGNyZWF0ZVRyYWRlUmVxdWVzdCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gY29uZmlndXJhdGlvbj8uc2VydmVySW5kZXggPz8gMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydUcmFkZXNBcGkuY3JlYXRlVHJhZGUnXT8uW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdPy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGEgdHJhZGUgYnkgSURcbiAgICAgICAgICogQHN1bW1hcnkgR2V0IGEgdHJhZGUgYnkgSURcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG9cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdGhlIHRyYWRlIGJlbG9uZ3MgdG9cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHRyYWRlSWQgVGhlIElEIG9mIHRoZSB0cmFkZSB0byBmZXRjaFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgZ2V0VHJhZGUod2FsbGV0SWQsIGFkZHJlc3NJZCwgdHJhZGVJZCwgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmdldFRyYWRlKHdhbGxldElkLCBhZGRyZXNzSWQsIHRyYWRlSWQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IGNvbmZpZ3VyYXRpb24/LnNlcnZlckluZGV4ID8/IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnVHJhZGVzQXBpLmdldFRyYWRlJ10/Lltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XT8udXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3QgdHJhZGVzIGZvciBhbiBhZGRyZXNzLlxuICAgICAgICAgKiBAc3VtbWFyeSBMaXN0IHRyYWRlcyBmb3IgYW4gYWRkcmVzcy5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG9cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdG8gbGlzdCB0cmFkZXMgZm9yXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIEEgbGltaXQgb24gdGhlIG51bWJlciBvZiBvYmplY3RzIHRvIGJlIHJldHVybmVkLiBMaW1pdCBjYW4gcmFuZ2UgYmV0d2VlbiAxIGFuZCAxMDAsIGFuZCB0aGUgZGVmYXVsdCBpcyAxMC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlXSBBIGN1cnNvciBmb3IgcGFnaW5hdGlvbiBhY3Jvc3MgbXVsdGlwbGUgcGFnZXMgb2YgcmVzdWx0cy4gRG9uXFwmIzM5O3QgaW5jbHVkZSB0aGlzIHBhcmFtZXRlciBvbiB0aGUgZmlyc3QgY2FsbC4gVXNlIHRoZSBuZXh0X3BhZ2UgdmFsdWUgcmV0dXJuZWQgaW4gYSBwcmV2aW91cyByZXNwb25zZSB0byByZXF1ZXN0IHN1YnNlcXVlbnQgcmVzdWx0cy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGxpc3RUcmFkZXMod2FsbGV0SWQsIGFkZHJlc3NJZCwgbGltaXQsIHBhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5saXN0VHJhZGVzKHdhbGxldElkLCBhZGRyZXNzSWQsIGxpbWl0LCBwYWdlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSBjb25maWd1cmF0aW9uPy5zZXJ2ZXJJbmRleCA/PyAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ1RyYWRlc0FwaS5saXN0VHJhZGVzJ10/Lltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XT8udXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuVHJhZGVzQXBpRnAgPSBUcmFkZXNBcGlGcDtcbi8qKlxuICogVHJhZGVzQXBpIC0gZmFjdG9yeSBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgVHJhZGVzQXBpRmFjdG9yeSA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uLCBiYXNlUGF0aCwgYXhpb3MpIHtcbiAgICBjb25zdCBsb2NhbFZhckZwID0gKDAsIGV4cG9ydHMuVHJhZGVzQXBpRnApKGNvbmZpZ3VyYXRpb24pO1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCcm9hZGNhc3QgYSB0cmFkZVxuICAgICAgICAgKiBAc3VtbWFyeSBCcm9hZGNhc3QgYSB0cmFkZVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0b1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0aGUgdHJhZGUgYmVsb25ncyB0b1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHJhZGVJZCBUaGUgSUQgb2YgdGhlIHRyYWRlIHRvIGJyb2FkY2FzdFxuICAgICAgICAgKiBAcGFyYW0ge0Jyb2FkY2FzdFRyYWRlUmVxdWVzdH0gYnJvYWRjYXN0VHJhZGVSZXF1ZXN0XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBicm9hZGNhc3RUcmFkZSh3YWxsZXRJZCwgYWRkcmVzc0lkLCB0cmFkZUlkLCBicm9hZGNhc3RUcmFkZVJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmJyb2FkY2FzdFRyYWRlKHdhbGxldElkLCBhZGRyZXNzSWQsIHRyYWRlSWQsIGJyb2FkY2FzdFRyYWRlUmVxdWVzdCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIG5ldyB0cmFkZVxuICAgICAgICAgKiBAc3VtbWFyeSBDcmVhdGUgYSBuZXcgdHJhZGUgZm9yIGFuIGFkZHJlc3NcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBzb3VyY2UgYWRkcmVzcyBiZWxvbmdzIHRvXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRvIGNvbmR1Y3QgdGhlIHRyYWRlIGZyb21cbiAgICAgICAgICogQHBhcmFtIHtDcmVhdGVUcmFkZVJlcXVlc3R9IGNyZWF0ZVRyYWRlUmVxdWVzdFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgY3JlYXRlVHJhZGUod2FsbGV0SWQsIGFkZHJlc3NJZCwgY3JlYXRlVHJhZGVSZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5jcmVhdGVUcmFkZSh3YWxsZXRJZCwgYWRkcmVzc0lkLCBjcmVhdGVUcmFkZVJlcXVlc3QsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgYSB0cmFkZSBieSBJRFxuICAgICAgICAgKiBAc3VtbWFyeSBHZXQgYSB0cmFkZSBieSBJRFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0b1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0aGUgdHJhZGUgYmVsb25ncyB0b1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHJhZGVJZCBUaGUgSUQgb2YgdGhlIHRyYWRlIHRvIGZldGNoXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRUcmFkZSh3YWxsZXRJZCwgYWRkcmVzc0lkLCB0cmFkZUlkLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5nZXRUcmFkZSh3YWxsZXRJZCwgYWRkcmVzc0lkLCB0cmFkZUlkLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdCB0cmFkZXMgZm9yIGFuIGFkZHJlc3MuXG4gICAgICAgICAqIEBzdW1tYXJ5IExpc3QgdHJhZGVzIGZvciBhbiBhZGRyZXNzLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0b1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0byBsaXN0IHRyYWRlcyBmb3JcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gQSBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIG9iamVjdHMgdG8gYmUgcmV0dXJuZWQuIExpbWl0IGNhbiByYW5nZSBiZXR3ZWVuIDEgYW5kIDEwMCwgYW5kIHRoZSBkZWZhdWx0IGlzIDEwLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VdIEEgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiByZXN1bHRzLiBEb25cXCYjMzk7dCBpbmNsdWRlIHRoaXMgcGFyYW1ldGVyIG9uIHRoZSBmaXJzdCBjYWxsLiBVc2UgdGhlIG5leHRfcGFnZSB2YWx1ZSByZXR1cm5lZCBpbiBhIHByZXZpb3VzIHJlc3BvbnNlIHRvIHJlcXVlc3Qgc3Vic2VxdWVudCByZXN1bHRzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgbGlzdFRyYWRlcyh3YWxsZXRJZCwgYWRkcmVzc0lkLCBsaW1pdCwgcGFnZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAubGlzdFRyYWRlcyh3YWxsZXRJZCwgYWRkcmVzc0lkLCBsaW1pdCwgcGFnZSwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuVHJhZGVzQXBpRmFjdG9yeSA9IFRyYWRlc0FwaUZhY3Rvcnk7XG4vKipcbiAqIFRyYWRlc0FwaSAtIG9iamVjdC1vcmllbnRlZCBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqIEBjbGFzcyBUcmFkZXNBcGlcbiAqIEBleHRlbmRzIHtCYXNlQVBJfVxuICovXG5jbGFzcyBUcmFkZXNBcGkgZXh0ZW5kcyBiYXNlXzEuQmFzZUFQSSB7XG4gICAgLyoqXG4gICAgICogQnJvYWRjYXN0IGEgdHJhZGVcbiAgICAgKiBAc3VtbWFyeSBCcm9hZGNhc3QgYSB0cmFkZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdGhlIHRyYWRlIGJlbG9uZ3MgdG9cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHJhZGVJZCBUaGUgSUQgb2YgdGhlIHRyYWRlIHRvIGJyb2FkY2FzdFxuICAgICAqIEBwYXJhbSB7QnJvYWRjYXN0VHJhZGVSZXF1ZXN0fSBicm9hZGNhc3RUcmFkZVJlcXVlc3RcbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIFRyYWRlc0FwaVxuICAgICAqL1xuICAgIGJyb2FkY2FzdFRyYWRlKHdhbGxldElkLCBhZGRyZXNzSWQsIHRyYWRlSWQsIGJyb2FkY2FzdFRyYWRlUmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuVHJhZGVzQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuYnJvYWRjYXN0VHJhZGUod2FsbGV0SWQsIGFkZHJlc3NJZCwgdHJhZGVJZCwgYnJvYWRjYXN0VHJhZGVSZXF1ZXN0LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IHRyYWRlXG4gICAgICogQHN1bW1hcnkgQ3JlYXRlIGEgbmV3IHRyYWRlIGZvciBhbiBhZGRyZXNzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBzb3VyY2UgYWRkcmVzcyBiZWxvbmdzIHRvXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdG8gY29uZHVjdCB0aGUgdHJhZGUgZnJvbVxuICAgICAqIEBwYXJhbSB7Q3JlYXRlVHJhZGVSZXF1ZXN0fSBjcmVhdGVUcmFkZVJlcXVlc3RcbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIFRyYWRlc0FwaVxuICAgICAqL1xuICAgIGNyZWF0ZVRyYWRlKHdhbGxldElkLCBhZGRyZXNzSWQsIGNyZWF0ZVRyYWRlUmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuVHJhZGVzQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuY3JlYXRlVHJhZGUod2FsbGV0SWQsIGFkZHJlc3NJZCwgY3JlYXRlVHJhZGVSZXF1ZXN0LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGEgdHJhZGUgYnkgSURcbiAgICAgKiBAc3VtbWFyeSBHZXQgYSB0cmFkZSBieSBJRFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdGhlIHRyYWRlIGJlbG9uZ3MgdG9cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHJhZGVJZCBUaGUgSUQgb2YgdGhlIHRyYWRlIHRvIGZldGNoXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBUcmFkZXNBcGlcbiAgICAgKi9cbiAgICBnZXRUcmFkZSh3YWxsZXRJZCwgYWRkcmVzc0lkLCB0cmFkZUlkLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5UcmFkZXNBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5nZXRUcmFkZSh3YWxsZXRJZCwgYWRkcmVzc0lkLCB0cmFkZUlkLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdCB0cmFkZXMgZm9yIGFuIGFkZHJlc3MuXG4gICAgICogQHN1bW1hcnkgTGlzdCB0cmFkZXMgZm9yIGFuIGFkZHJlc3MuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG9cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0byBsaXN0IHRyYWRlcyBmb3JcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBBIGxpbWl0IG9uIHRoZSBudW1iZXIgb2Ygb2JqZWN0cyB0byBiZSByZXR1cm5lZC4gTGltaXQgY2FuIHJhbmdlIGJldHdlZW4gMSBhbmQgMTAwLCBhbmQgdGhlIGRlZmF1bHQgaXMgMTAuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlXSBBIGN1cnNvciBmb3IgcGFnaW5hdGlvbiBhY3Jvc3MgbXVsdGlwbGUgcGFnZXMgb2YgcmVzdWx0cy4gRG9uXFwmIzM5O3QgaW5jbHVkZSB0aGlzIHBhcmFtZXRlciBvbiB0aGUgZmlyc3QgY2FsbC4gVXNlIHRoZSBuZXh0X3BhZ2UgdmFsdWUgcmV0dXJuZWQgaW4gYSBwcmV2aW91cyByZXNwb25zZSB0byByZXF1ZXN0IHN1YnNlcXVlbnQgcmVzdWx0cy5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIFRyYWRlc0FwaVxuICAgICAqL1xuICAgIGxpc3RUcmFkZXMod2FsbGV0SWQsIGFkZHJlc3NJZCwgbGltaXQsIHBhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLlRyYWRlc0FwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLmxpc3RUcmFkZXMod2FsbGV0SWQsIGFkZHJlc3NJZCwgbGltaXQsIHBhZ2UsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuVHJhZGVzQXBpID0gVHJhZGVzQXBpO1xuLyoqXG4gKiBUcmFuc2FjdGlvbkhpc3RvcnlBcGkgLSBheGlvcyBwYXJhbWV0ZXIgY3JlYXRvclxuICogQGV4cG9ydFxuICovXG5jb25zdCBUcmFuc2FjdGlvbkhpc3RvcnlBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3QgYWxsIHRyYW5zYWN0aW9ucyB0aGF0IGludGVyYWN0IHdpdGggdGhlIGFkZHJlc3MuXG4gICAgICAgICAqIEBzdW1tYXJ5IExpc3QgdHJhbnNhY3Rpb25zIGZvciBhbiBhZGRyZXNzLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29ya0lkIFRoZSBJRCBvZiB0aGUgYmxvY2tjaGFpbiBuZXR3b3JrXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRvIGZldGNoIHRoZSB0cmFuc2FjdGlvbnMgZm9yLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBBIGxpbWl0IG9uIHRoZSBudW1iZXIgb2Ygb2JqZWN0cyB0byBiZSByZXR1cm5lZC4gTGltaXQgY2FuIHJhbmdlIGJldHdlZW4gMSBhbmQgMTAwLCBhbmQgdGhlIGRlZmF1bHQgaXMgMTAuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZV0gQSBjdXJzb3IgZm9yIHBhZ2luYXRpb24gYWNyb3NzIG11bHRpcGxlIHBhZ2VzIG9mIHJlc3VsdHMuIERvblxcJiMzOTt0IGluY2x1ZGUgdGhpcyBwYXJhbWV0ZXIgb24gdGhlIGZpcnN0IGNhbGwuIFVzZSB0aGUgbmV4dF9wYWdlIHZhbHVlIHJldHVybmVkIGluIGEgcHJldmlvdXMgcmVzcG9uc2UgdG8gcmVxdWVzdCBzdWJzZXF1ZW50IHJlc3VsdHMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBsaXN0QWRkcmVzc1RyYW5zYWN0aW9uczogYXN5bmMgKG5ldHdvcmtJZCwgYWRkcmVzc0lkLCBsaW1pdCwgcGFnZSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICduZXR3b3JrSWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnbGlzdEFkZHJlc3NUcmFuc2FjdGlvbnMnLCAnbmV0d29ya0lkJywgbmV0d29ya0lkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2FkZHJlc3NJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdsaXN0QWRkcmVzc1RyYW5zYWN0aW9ucycsICdhZGRyZXNzSWQnLCBhZGRyZXNzSWQpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS9uZXR3b3Jrcy97bmV0d29ya19pZH0vYWRkcmVzc2VzL3thZGRyZXNzX2lkfS90cmFuc2FjdGlvbnNgXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wibmV0d29ya19pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKG5ldHdvcmtJZCkpKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcImFkZHJlc3NfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhhZGRyZXNzSWQpKSk7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IHsgbWV0aG9kOiAnR0VUJywgLi4uYmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBhcGlLZXkgcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gc2Vzc2lvbiByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJKd3RcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBpZiAobGltaXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ2xpbWl0J10gPSBsaW1pdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydwYWdlJ10gPSBwYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0geyAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlciwgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucywgLi4ub3B0aW9ucy5oZWFkZXJzIH07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5UcmFuc2FjdGlvbkhpc3RvcnlBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IFRyYW5zYWN0aW9uSGlzdG9yeUFwaUF4aW9zUGFyYW1DcmVhdG9yO1xuLyoqXG4gKiBUcmFuc2FjdGlvbkhpc3RvcnlBcGkgLSBmdW5jdGlvbmFsIHByb2dyYW1taW5nIGludGVyZmFjZVxuICogQGV4cG9ydFxuICovXG5jb25zdCBUcmFuc2FjdGlvbkhpc3RvcnlBcGlGcCA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uKSB7XG4gICAgY29uc3QgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvciA9ICgwLCBleHBvcnRzLlRyYW5zYWN0aW9uSGlzdG9yeUFwaUF4aW9zUGFyYW1DcmVhdG9yKShjb25maWd1cmF0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdCBhbGwgdHJhbnNhY3Rpb25zIHRoYXQgaW50ZXJhY3Qgd2l0aCB0aGUgYWRkcmVzcy5cbiAgICAgICAgICogQHN1bW1hcnkgTGlzdCB0cmFuc2FjdGlvbnMgZm9yIGFuIGFkZHJlc3MuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWQgVGhlIElEIG9mIHRoZSBibG9ja2NoYWluIG5ldHdvcmtcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdG8gZmV0Y2ggdGhlIHRyYW5zYWN0aW9ucyBmb3IuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIEEgbGltaXQgb24gdGhlIG51bWJlciBvZiBvYmplY3RzIHRvIGJlIHJldHVybmVkLiBMaW1pdCBjYW4gcmFuZ2UgYmV0d2VlbiAxIGFuZCAxMDAsIGFuZCB0aGUgZGVmYXVsdCBpcyAxMC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlXSBBIGN1cnNvciBmb3IgcGFnaW5hdGlvbiBhY3Jvc3MgbXVsdGlwbGUgcGFnZXMgb2YgcmVzdWx0cy4gRG9uXFwmIzM5O3QgaW5jbHVkZSB0aGlzIHBhcmFtZXRlciBvbiB0aGUgZmlyc3QgY2FsbC4gVXNlIHRoZSBuZXh0X3BhZ2UgdmFsdWUgcmV0dXJuZWQgaW4gYSBwcmV2aW91cyByZXNwb25zZSB0byByZXF1ZXN0IHN1YnNlcXVlbnQgcmVzdWx0cy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGxpc3RBZGRyZXNzVHJhbnNhY3Rpb25zKG5ldHdvcmtJZCwgYWRkcmVzc0lkLCBsaW1pdCwgcGFnZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmxpc3RBZGRyZXNzVHJhbnNhY3Rpb25zKG5ldHdvcmtJZCwgYWRkcmVzc0lkLCBsaW1pdCwgcGFnZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gY29uZmlndXJhdGlvbj8uc2VydmVySW5kZXggPz8gMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydUcmFuc2FjdGlvbkhpc3RvcnlBcGkubGlzdEFkZHJlc3NUcmFuc2FjdGlvbnMnXT8uW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdPy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5UcmFuc2FjdGlvbkhpc3RvcnlBcGlGcCA9IFRyYW5zYWN0aW9uSGlzdG9yeUFwaUZwO1xuLyoqXG4gKiBUcmFuc2FjdGlvbkhpc3RvcnlBcGkgLSBmYWN0b3J5IGludGVyZmFjZVxuICogQGV4cG9ydFxuICovXG5jb25zdCBUcmFuc2FjdGlvbkhpc3RvcnlBcGlGYWN0b3J5ID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24sIGJhc2VQYXRoLCBheGlvcykge1xuICAgIGNvbnN0IGxvY2FsVmFyRnAgPSAoMCwgZXhwb3J0cy5UcmFuc2FjdGlvbkhpc3RvcnlBcGlGcCkoY29uZmlndXJhdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3QgYWxsIHRyYW5zYWN0aW9ucyB0aGF0IGludGVyYWN0IHdpdGggdGhlIGFkZHJlc3MuXG4gICAgICAgICAqIEBzdW1tYXJ5IExpc3QgdHJhbnNhY3Rpb25zIGZvciBhbiBhZGRyZXNzLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29ya0lkIFRoZSBJRCBvZiB0aGUgYmxvY2tjaGFpbiBuZXR3b3JrXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRvIGZldGNoIHRoZSB0cmFuc2FjdGlvbnMgZm9yLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBBIGxpbWl0IG9uIHRoZSBudW1iZXIgb2Ygb2JqZWN0cyB0byBiZSByZXR1cm5lZC4gTGltaXQgY2FuIHJhbmdlIGJldHdlZW4gMSBhbmQgMTAwLCBhbmQgdGhlIGRlZmF1bHQgaXMgMTAuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZV0gQSBjdXJzb3IgZm9yIHBhZ2luYXRpb24gYWNyb3NzIG11bHRpcGxlIHBhZ2VzIG9mIHJlc3VsdHMuIERvblxcJiMzOTt0IGluY2x1ZGUgdGhpcyBwYXJhbWV0ZXIgb24gdGhlIGZpcnN0IGNhbGwuIFVzZSB0aGUgbmV4dF9wYWdlIHZhbHVlIHJldHVybmVkIGluIGEgcHJldmlvdXMgcmVzcG9uc2UgdG8gcmVxdWVzdCBzdWJzZXF1ZW50IHJlc3VsdHMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBsaXN0QWRkcmVzc1RyYW5zYWN0aW9ucyhuZXR3b3JrSWQsIGFkZHJlc3NJZCwgbGltaXQsIHBhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmxpc3RBZGRyZXNzVHJhbnNhY3Rpb25zKG5ldHdvcmtJZCwgYWRkcmVzc0lkLCBsaW1pdCwgcGFnZSwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuVHJhbnNhY3Rpb25IaXN0b3J5QXBpRmFjdG9yeSA9IFRyYW5zYWN0aW9uSGlzdG9yeUFwaUZhY3Rvcnk7XG4vKipcbiAqIFRyYW5zYWN0aW9uSGlzdG9yeUFwaSAtIG9iamVjdC1vcmllbnRlZCBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqIEBjbGFzcyBUcmFuc2FjdGlvbkhpc3RvcnlBcGlcbiAqIEBleHRlbmRzIHtCYXNlQVBJfVxuICovXG5jbGFzcyBUcmFuc2FjdGlvbkhpc3RvcnlBcGkgZXh0ZW5kcyBiYXNlXzEuQmFzZUFQSSB7XG4gICAgLyoqXG4gICAgICogTGlzdCBhbGwgdHJhbnNhY3Rpb25zIHRoYXQgaW50ZXJhY3Qgd2l0aCB0aGUgYWRkcmVzcy5cbiAgICAgKiBAc3VtbWFyeSBMaXN0IHRyYW5zYWN0aW9ucyBmb3IgYW4gYWRkcmVzcy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29ya0lkIFRoZSBJRCBvZiB0aGUgYmxvY2tjaGFpbiBuZXR3b3JrXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdG8gZmV0Y2ggdGhlIHRyYW5zYWN0aW9ucyBmb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gQSBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIG9iamVjdHMgdG8gYmUgcmV0dXJuZWQuIExpbWl0IGNhbiByYW5nZSBiZXR3ZWVuIDEgYW5kIDEwMCwgYW5kIHRoZSBkZWZhdWx0IGlzIDEwLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZV0gQSBjdXJzb3IgZm9yIHBhZ2luYXRpb24gYWNyb3NzIG11bHRpcGxlIHBhZ2VzIG9mIHJlc3VsdHMuIERvblxcJiMzOTt0IGluY2x1ZGUgdGhpcyBwYXJhbWV0ZXIgb24gdGhlIGZpcnN0IGNhbGwuIFVzZSB0aGUgbmV4dF9wYWdlIHZhbHVlIHJldHVybmVkIGluIGEgcHJldmlvdXMgcmVzcG9uc2UgdG8gcmVxdWVzdCBzdWJzZXF1ZW50IHJlc3VsdHMuXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBUcmFuc2FjdGlvbkhpc3RvcnlBcGlcbiAgICAgKi9cbiAgICBsaXN0QWRkcmVzc1RyYW5zYWN0aW9ucyhuZXR3b3JrSWQsIGFkZHJlc3NJZCwgbGltaXQsIHBhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLlRyYW5zYWN0aW9uSGlzdG9yeUFwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLmxpc3RBZGRyZXNzVHJhbnNhY3Rpb25zKG5ldHdvcmtJZCwgYWRkcmVzc0lkLCBsaW1pdCwgcGFnZSwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxufVxuZXhwb3J0cy5UcmFuc2FjdGlvbkhpc3RvcnlBcGkgPSBUcmFuc2FjdGlvbkhpc3RvcnlBcGk7XG4vKipcbiAqIFRyYW5zZmVyc0FwaSAtIGF4aW9zIHBhcmFtZXRlciBjcmVhdG9yXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IFRyYW5zZmVyc0FwaUF4aW9zUGFyYW1DcmVhdG9yID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQnJvYWRjYXN0IGEgdHJhbnNmZXJcbiAgICAgICAgICogQHN1bW1hcnkgQnJvYWRjYXN0IGEgdHJhbnNmZXJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG9cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdGhlIHRyYW5zZmVyIGJlbG9uZ3MgdG9cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHRyYW5zZmVySWQgVGhlIElEIG9mIHRoZSB0cmFuc2ZlciB0byBicm9hZGNhc3RcbiAgICAgICAgICogQHBhcmFtIHtCcm9hZGNhc3RUcmFuc2ZlclJlcXVlc3R9IGJyb2FkY2FzdFRyYW5zZmVyUmVxdWVzdFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYnJvYWRjYXN0VHJhbnNmZXI6IGFzeW5jICh3YWxsZXRJZCwgYWRkcmVzc0lkLCB0cmFuc2ZlcklkLCBicm9hZGNhc3RUcmFuc2ZlclJlcXVlc3QsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnd2FsbGV0SWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnYnJvYWRjYXN0VHJhbnNmZXInLCAnd2FsbGV0SWQnLCB3YWxsZXRJZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdhZGRyZXNzSWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnYnJvYWRjYXN0VHJhbnNmZXInLCAnYWRkcmVzc0lkJywgYWRkcmVzc0lkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ3RyYW5zZmVySWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnYnJvYWRjYXN0VHJhbnNmZXInLCAndHJhbnNmZXJJZCcsIHRyYW5zZmVySWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnYnJvYWRjYXN0VHJhbnNmZXJSZXF1ZXN0JyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2Jyb2FkY2FzdFRyYW5zZmVyJywgJ2Jyb2FkY2FzdFRyYW5zZmVyUmVxdWVzdCcsIGJyb2FkY2FzdFRyYW5zZmVyUmVxdWVzdCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL3dhbGxldHMve3dhbGxldF9pZH0vYWRkcmVzc2VzL3thZGRyZXNzX2lkfS90cmFuc2ZlcnMve3RyYW5zZmVyX2lkfS9icm9hZGNhc3RgXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wid2FsbGV0X2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcod2FsbGV0SWQpKSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJhZGRyZXNzX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoYWRkcmVzc0lkKSkpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1widHJhbnNmZXJfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyh0cmFuc2ZlcklkKSkpO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7IG1ldGhvZDogJ1BPU1QnLCAuLi5iYXNlT3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIGFwaUtleSByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJKd3RcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBsb2NhbFZhckhlYWRlclBhcmFtZXRlclsnQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSB7IC4uLmxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCAuLi5oZWFkZXJzRnJvbUJhc2VPcHRpb25zLCAuLi5vcHRpb25zLmhlYWRlcnMgfTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuZGF0YSA9ICgwLCBjb21tb25fMS5zZXJpYWxpemVEYXRhSWZOZWVkZWQpKGJyb2FkY2FzdFRyYW5zZmVyUmVxdWVzdCwgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucywgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgbmV3IHRyYW5zZmVyXG4gICAgICAgICAqIEBzdW1tYXJ5IENyZWF0ZSBhIG5ldyB0cmFuc2ZlciBmb3IgYW4gYWRkcmVzc1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIHNvdXJjZSBhZGRyZXNzIGJlbG9uZ3MgdG9cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdG8gdHJhbnNmZXIgZnJvbVxuICAgICAgICAgKiBAcGFyYW0ge0NyZWF0ZVRyYW5zZmVyUmVxdWVzdH0gY3JlYXRlVHJhbnNmZXJSZXF1ZXN0XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGVUcmFuc2ZlcjogYXN5bmMgKHdhbGxldElkLCBhZGRyZXNzSWQsIGNyZWF0ZVRyYW5zZmVyUmVxdWVzdCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICd3YWxsZXRJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdjcmVhdGVUcmFuc2ZlcicsICd3YWxsZXRJZCcsIHdhbGxldElkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2FkZHJlc3NJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdjcmVhdGVUcmFuc2ZlcicsICdhZGRyZXNzSWQnLCBhZGRyZXNzSWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnY3JlYXRlVHJhbnNmZXJSZXF1ZXN0JyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2NyZWF0ZVRyYW5zZmVyJywgJ2NyZWF0ZVRyYW5zZmVyUmVxdWVzdCcsIGNyZWF0ZVRyYW5zZmVyUmVxdWVzdCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL3dhbGxldHMve3dhbGxldF9pZH0vYWRkcmVzc2VzL3thZGRyZXNzX2lkfS90cmFuc2ZlcnNgXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wid2FsbGV0X2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcod2FsbGV0SWQpKSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJhZGRyZXNzX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoYWRkcmVzc0lkKSkpO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7IG1ldGhvZDogJ1BPU1QnLCAuLi5iYXNlT3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIGFwaUtleSByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJKd3RcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBsb2NhbFZhckhlYWRlclBhcmFtZXRlclsnQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSB7IC4uLmxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCAuLi5oZWFkZXJzRnJvbUJhc2VPcHRpb25zLCAuLi5vcHRpb25zLmhlYWRlcnMgfTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuZGF0YSA9ICgwLCBjb21tb25fMS5zZXJpYWxpemVEYXRhSWZOZWVkZWQpKGNyZWF0ZVRyYW5zZmVyUmVxdWVzdCwgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucywgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGEgdHJhbnNmZXIgYnkgSURcbiAgICAgICAgICogQHN1bW1hcnkgR2V0IGEgdHJhbnNmZXIgYnkgSURcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG9cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdGhlIHRyYW5zZmVyIGJlbG9uZ3MgdG9cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHRyYW5zZmVySWQgVGhlIElEIG9mIHRoZSB0cmFuc2ZlciB0byBmZXRjaFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0VHJhbnNmZXI6IGFzeW5jICh3YWxsZXRJZCwgYWRkcmVzc0lkLCB0cmFuc2ZlcklkLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ3dhbGxldElkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2dldFRyYW5zZmVyJywgJ3dhbGxldElkJywgd2FsbGV0SWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnYWRkcmVzc0lkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2dldFRyYW5zZmVyJywgJ2FkZHJlc3NJZCcsIGFkZHJlc3NJZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICd0cmFuc2ZlcklkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2dldFRyYW5zZmVyJywgJ3RyYW5zZmVySWQnLCB0cmFuc2ZlcklkKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvd2FsbGV0cy97d2FsbGV0X2lkfS9hZGRyZXNzZXMve2FkZHJlc3NfaWR9L3RyYW5zZmVycy97dHJhbnNmZXJfaWR9YFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcIndhbGxldF9pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHdhbGxldElkKSkpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wiYWRkcmVzc19pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKGFkZHJlc3NJZCkpKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcInRyYW5zZmVyX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcodHJhbnNmZXJJZCkpKTtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0geyBtZXRob2Q6ICdHRVQnLCAuLi5iYXNlT3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIGFwaUtleSByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJKd3RcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBzZXNzaW9uIHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIkp3dFwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IHsgLi4ubG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIC4uLmhlYWRlcnNGcm9tQmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMuaGVhZGVycyB9O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3QgdHJhbnNmZXJzIGZvciBhbiBhZGRyZXNzLlxuICAgICAgICAgKiBAc3VtbWFyeSBMaXN0IHRyYW5zZmVycyBmb3IgYW4gYWRkcmVzcy5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG9cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdG8gbGlzdCB0cmFuc2ZlcnMgZm9yXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIEEgbGltaXQgb24gdGhlIG51bWJlciBvZiBvYmplY3RzIHRvIGJlIHJldHVybmVkLiBMaW1pdCBjYW4gcmFuZ2UgYmV0d2VlbiAxIGFuZCAxMDAsIGFuZCB0aGUgZGVmYXVsdCBpcyAxMC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlXSBBIGN1cnNvciBmb3IgcGFnaW5hdGlvbiBhY3Jvc3MgbXVsdGlwbGUgcGFnZXMgb2YgcmVzdWx0cy4gRG9uXFwmIzM5O3QgaW5jbHVkZSB0aGlzIHBhcmFtZXRlciBvbiB0aGUgZmlyc3QgY2FsbC4gVXNlIHRoZSBuZXh0X3BhZ2UgdmFsdWUgcmV0dXJuZWQgaW4gYSBwcmV2aW91cyByZXNwb25zZSB0byByZXF1ZXN0IHN1YnNlcXVlbnQgcmVzdWx0cy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGxpc3RUcmFuc2ZlcnM6IGFzeW5jICh3YWxsZXRJZCwgYWRkcmVzc0lkLCBsaW1pdCwgcGFnZSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICd3YWxsZXRJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdsaXN0VHJhbnNmZXJzJywgJ3dhbGxldElkJywgd2FsbGV0SWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnYWRkcmVzc0lkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2xpc3RUcmFuc2ZlcnMnLCAnYWRkcmVzc0lkJywgYWRkcmVzc0lkKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvd2FsbGV0cy97d2FsbGV0X2lkfS9hZGRyZXNzZXMve2FkZHJlc3NfaWR9L3RyYW5zZmVyc2BcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJ3YWxsZXRfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyh3YWxsZXRJZCkpKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcImFkZHJlc3NfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhhZGRyZXNzSWQpKSk7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IHsgbWV0aG9kOiAnR0VUJywgLi4uYmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBhcGlLZXkgcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gc2Vzc2lvbiByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJKd3RcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBpZiAobGltaXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ2xpbWl0J10gPSBsaW1pdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydwYWdlJ10gPSBwYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0geyAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlciwgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucywgLi4ub3B0aW9ucy5oZWFkZXJzIH07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5UcmFuc2ZlcnNBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IFRyYW5zZmVyc0FwaUF4aW9zUGFyYW1DcmVhdG9yO1xuLyoqXG4gKiBUcmFuc2ZlcnNBcGkgLSBmdW5jdGlvbmFsIHByb2dyYW1taW5nIGludGVyZmFjZVxuICogQGV4cG9ydFxuICovXG5jb25zdCBUcmFuc2ZlcnNBcGlGcCA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uKSB7XG4gICAgY29uc3QgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvciA9ICgwLCBleHBvcnRzLlRyYW5zZmVyc0FwaUF4aW9zUGFyYW1DcmVhdG9yKShjb25maWd1cmF0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQnJvYWRjYXN0IGEgdHJhbnNmZXJcbiAgICAgICAgICogQHN1bW1hcnkgQnJvYWRjYXN0IGEgdHJhbnNmZXJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG9cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdGhlIHRyYW5zZmVyIGJlbG9uZ3MgdG9cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHRyYW5zZmVySWQgVGhlIElEIG9mIHRoZSB0cmFuc2ZlciB0byBicm9hZGNhc3RcbiAgICAgICAgICogQHBhcmFtIHtCcm9hZGNhc3RUcmFuc2ZlclJlcXVlc3R9IGJyb2FkY2FzdFRyYW5zZmVyUmVxdWVzdFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgYnJvYWRjYXN0VHJhbnNmZXIod2FsbGV0SWQsIGFkZHJlc3NJZCwgdHJhbnNmZXJJZCwgYnJvYWRjYXN0VHJhbnNmZXJSZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuYnJvYWRjYXN0VHJhbnNmZXIod2FsbGV0SWQsIGFkZHJlc3NJZCwgdHJhbnNmZXJJZCwgYnJvYWRjYXN0VHJhbnNmZXJSZXF1ZXN0LCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSBjb25maWd1cmF0aW9uPy5zZXJ2ZXJJbmRleCA/PyAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ1RyYW5zZmVyc0FwaS5icm9hZGNhc3RUcmFuc2ZlciddPy5bbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0/LnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSBuZXcgdHJhbnNmZXJcbiAgICAgICAgICogQHN1bW1hcnkgQ3JlYXRlIGEgbmV3IHRyYW5zZmVyIGZvciBhbiBhZGRyZXNzXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgc291cmNlIGFkZHJlc3MgYmVsb25ncyB0b1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0byB0cmFuc2ZlciBmcm9tXG4gICAgICAgICAqIEBwYXJhbSB7Q3JlYXRlVHJhbnNmZXJSZXF1ZXN0fSBjcmVhdGVUcmFuc2ZlclJlcXVlc3RcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGNyZWF0ZVRyYW5zZmVyKHdhbGxldElkLCBhZGRyZXNzSWQsIGNyZWF0ZVRyYW5zZmVyUmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmNyZWF0ZVRyYW5zZmVyKHdhbGxldElkLCBhZGRyZXNzSWQsIGNyZWF0ZVRyYW5zZmVyUmVxdWVzdCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gY29uZmlndXJhdGlvbj8uc2VydmVySW5kZXggPz8gMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydUcmFuc2ZlcnNBcGkuY3JlYXRlVHJhbnNmZXInXT8uW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdPy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGEgdHJhbnNmZXIgYnkgSURcbiAgICAgICAgICogQHN1bW1hcnkgR2V0IGEgdHJhbnNmZXIgYnkgSURcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG9cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdGhlIHRyYW5zZmVyIGJlbG9uZ3MgdG9cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHRyYW5zZmVySWQgVGhlIElEIG9mIHRoZSB0cmFuc2ZlciB0byBmZXRjaFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgZ2V0VHJhbnNmZXIod2FsbGV0SWQsIGFkZHJlc3NJZCwgdHJhbnNmZXJJZCwgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmdldFRyYW5zZmVyKHdhbGxldElkLCBhZGRyZXNzSWQsIHRyYW5zZmVySWQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IGNvbmZpZ3VyYXRpb24/LnNlcnZlckluZGV4ID8/IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnVHJhbnNmZXJzQXBpLmdldFRyYW5zZmVyJ10/Lltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XT8udXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3QgdHJhbnNmZXJzIGZvciBhbiBhZGRyZXNzLlxuICAgICAgICAgKiBAc3VtbWFyeSBMaXN0IHRyYW5zZmVycyBmb3IgYW4gYWRkcmVzcy5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG9cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdG8gbGlzdCB0cmFuc2ZlcnMgZm9yXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIEEgbGltaXQgb24gdGhlIG51bWJlciBvZiBvYmplY3RzIHRvIGJlIHJldHVybmVkLiBMaW1pdCBjYW4gcmFuZ2UgYmV0d2VlbiAxIGFuZCAxMDAsIGFuZCB0aGUgZGVmYXVsdCBpcyAxMC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlXSBBIGN1cnNvciBmb3IgcGFnaW5hdGlvbiBhY3Jvc3MgbXVsdGlwbGUgcGFnZXMgb2YgcmVzdWx0cy4gRG9uXFwmIzM5O3QgaW5jbHVkZSB0aGlzIHBhcmFtZXRlciBvbiB0aGUgZmlyc3QgY2FsbC4gVXNlIHRoZSBuZXh0X3BhZ2UgdmFsdWUgcmV0dXJuZWQgaW4gYSBwcmV2aW91cyByZXNwb25zZSB0byByZXF1ZXN0IHN1YnNlcXVlbnQgcmVzdWx0cy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGxpc3RUcmFuc2ZlcnMod2FsbGV0SWQsIGFkZHJlc3NJZCwgbGltaXQsIHBhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5saXN0VHJhbnNmZXJzKHdhbGxldElkLCBhZGRyZXNzSWQsIGxpbWl0LCBwYWdlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSBjb25maWd1cmF0aW9uPy5zZXJ2ZXJJbmRleCA/PyAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ1RyYW5zZmVyc0FwaS5saXN0VHJhbnNmZXJzJ10/Lltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XT8udXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuVHJhbnNmZXJzQXBpRnAgPSBUcmFuc2ZlcnNBcGlGcDtcbi8qKlxuICogVHJhbnNmZXJzQXBpIC0gZmFjdG9yeSBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgVHJhbnNmZXJzQXBpRmFjdG9yeSA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uLCBiYXNlUGF0aCwgYXhpb3MpIHtcbiAgICBjb25zdCBsb2NhbFZhckZwID0gKDAsIGV4cG9ydHMuVHJhbnNmZXJzQXBpRnApKGNvbmZpZ3VyYXRpb24pO1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCcm9hZGNhc3QgYSB0cmFuc2ZlclxuICAgICAgICAgKiBAc3VtbWFyeSBCcm9hZGNhc3QgYSB0cmFuc2ZlclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0b1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0aGUgdHJhbnNmZXIgYmVsb25ncyB0b1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHJhbnNmZXJJZCBUaGUgSUQgb2YgdGhlIHRyYW5zZmVyIHRvIGJyb2FkY2FzdFxuICAgICAgICAgKiBAcGFyYW0ge0Jyb2FkY2FzdFRyYW5zZmVyUmVxdWVzdH0gYnJvYWRjYXN0VHJhbnNmZXJSZXF1ZXN0XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBicm9hZGNhc3RUcmFuc2Zlcih3YWxsZXRJZCwgYWRkcmVzc0lkLCB0cmFuc2ZlcklkLCBicm9hZGNhc3RUcmFuc2ZlclJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmJyb2FkY2FzdFRyYW5zZmVyKHdhbGxldElkLCBhZGRyZXNzSWQsIHRyYW5zZmVySWQsIGJyb2FkY2FzdFRyYW5zZmVyUmVxdWVzdCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIG5ldyB0cmFuc2ZlclxuICAgICAgICAgKiBAc3VtbWFyeSBDcmVhdGUgYSBuZXcgdHJhbnNmZXIgZm9yIGFuIGFkZHJlc3NcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBzb3VyY2UgYWRkcmVzcyBiZWxvbmdzIHRvXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRvIHRyYW5zZmVyIGZyb21cbiAgICAgICAgICogQHBhcmFtIHtDcmVhdGVUcmFuc2ZlclJlcXVlc3R9IGNyZWF0ZVRyYW5zZmVyUmVxdWVzdFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgY3JlYXRlVHJhbnNmZXIod2FsbGV0SWQsIGFkZHJlc3NJZCwgY3JlYXRlVHJhbnNmZXJSZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5jcmVhdGVUcmFuc2Zlcih3YWxsZXRJZCwgYWRkcmVzc0lkLCBjcmVhdGVUcmFuc2ZlclJlcXVlc3QsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgYSB0cmFuc2ZlciBieSBJRFxuICAgICAgICAgKiBAc3VtbWFyeSBHZXQgYSB0cmFuc2ZlciBieSBJRFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0b1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0aGUgdHJhbnNmZXIgYmVsb25ncyB0b1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHJhbnNmZXJJZCBUaGUgSUQgb2YgdGhlIHRyYW5zZmVyIHRvIGZldGNoXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRUcmFuc2Zlcih3YWxsZXRJZCwgYWRkcmVzc0lkLCB0cmFuc2ZlcklkLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5nZXRUcmFuc2Zlcih3YWxsZXRJZCwgYWRkcmVzc0lkLCB0cmFuc2ZlcklkLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdCB0cmFuc2ZlcnMgZm9yIGFuIGFkZHJlc3MuXG4gICAgICAgICAqIEBzdW1tYXJ5IExpc3QgdHJhbnNmZXJzIGZvciBhbiBhZGRyZXNzLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0b1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0byBsaXN0IHRyYW5zZmVycyBmb3JcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gQSBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIG9iamVjdHMgdG8gYmUgcmV0dXJuZWQuIExpbWl0IGNhbiByYW5nZSBiZXR3ZWVuIDEgYW5kIDEwMCwgYW5kIHRoZSBkZWZhdWx0IGlzIDEwLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VdIEEgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiByZXN1bHRzLiBEb25cXCYjMzk7dCBpbmNsdWRlIHRoaXMgcGFyYW1ldGVyIG9uIHRoZSBmaXJzdCBjYWxsLiBVc2UgdGhlIG5leHRfcGFnZSB2YWx1ZSByZXR1cm5lZCBpbiBhIHByZXZpb3VzIHJlc3BvbnNlIHRvIHJlcXVlc3Qgc3Vic2VxdWVudCByZXN1bHRzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgbGlzdFRyYW5zZmVycyh3YWxsZXRJZCwgYWRkcmVzc0lkLCBsaW1pdCwgcGFnZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAubGlzdFRyYW5zZmVycyh3YWxsZXRJZCwgYWRkcmVzc0lkLCBsaW1pdCwgcGFnZSwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuVHJhbnNmZXJzQXBpRmFjdG9yeSA9IFRyYW5zZmVyc0FwaUZhY3Rvcnk7XG4vKipcbiAqIFRyYW5zZmVyc0FwaSAtIG9iamVjdC1vcmllbnRlZCBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqIEBjbGFzcyBUcmFuc2ZlcnNBcGlcbiAqIEBleHRlbmRzIHtCYXNlQVBJfVxuICovXG5jbGFzcyBUcmFuc2ZlcnNBcGkgZXh0ZW5kcyBiYXNlXzEuQmFzZUFQSSB7XG4gICAgLyoqXG4gICAgICogQnJvYWRjYXN0IGEgdHJhbnNmZXJcbiAgICAgKiBAc3VtbWFyeSBCcm9hZGNhc3QgYSB0cmFuc2ZlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdGhlIHRyYW5zZmVyIGJlbG9uZ3MgdG9cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHJhbnNmZXJJZCBUaGUgSUQgb2YgdGhlIHRyYW5zZmVyIHRvIGJyb2FkY2FzdFxuICAgICAqIEBwYXJhbSB7QnJvYWRjYXN0VHJhbnNmZXJSZXF1ZXN0fSBicm9hZGNhc3RUcmFuc2ZlclJlcXVlc3RcbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIFRyYW5zZmVyc0FwaVxuICAgICAqL1xuICAgIGJyb2FkY2FzdFRyYW5zZmVyKHdhbGxldElkLCBhZGRyZXNzSWQsIHRyYW5zZmVySWQsIGJyb2FkY2FzdFRyYW5zZmVyUmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuVHJhbnNmZXJzQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuYnJvYWRjYXN0VHJhbnNmZXIod2FsbGV0SWQsIGFkZHJlc3NJZCwgdHJhbnNmZXJJZCwgYnJvYWRjYXN0VHJhbnNmZXJSZXF1ZXN0LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IHRyYW5zZmVyXG4gICAgICogQHN1bW1hcnkgQ3JlYXRlIGEgbmV3IHRyYW5zZmVyIGZvciBhbiBhZGRyZXNzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBzb3VyY2UgYWRkcmVzcyBiZWxvbmdzIHRvXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdG8gdHJhbnNmZXIgZnJvbVxuICAgICAqIEBwYXJhbSB7Q3JlYXRlVHJhbnNmZXJSZXF1ZXN0fSBjcmVhdGVUcmFuc2ZlclJlcXVlc3RcbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIFRyYW5zZmVyc0FwaVxuICAgICAqL1xuICAgIGNyZWF0ZVRyYW5zZmVyKHdhbGxldElkLCBhZGRyZXNzSWQsIGNyZWF0ZVRyYW5zZmVyUmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuVHJhbnNmZXJzQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuY3JlYXRlVHJhbnNmZXIod2FsbGV0SWQsIGFkZHJlc3NJZCwgY3JlYXRlVHJhbnNmZXJSZXF1ZXN0LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGEgdHJhbnNmZXIgYnkgSURcbiAgICAgKiBAc3VtbWFyeSBHZXQgYSB0cmFuc2ZlciBieSBJRFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdGhlIHRyYW5zZmVyIGJlbG9uZ3MgdG9cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHJhbnNmZXJJZCBUaGUgSUQgb2YgdGhlIHRyYW5zZmVyIHRvIGZldGNoXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBUcmFuc2ZlcnNBcGlcbiAgICAgKi9cbiAgICBnZXRUcmFuc2Zlcih3YWxsZXRJZCwgYWRkcmVzc0lkLCB0cmFuc2ZlcklkLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5UcmFuc2ZlcnNBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5nZXRUcmFuc2Zlcih3YWxsZXRJZCwgYWRkcmVzc0lkLCB0cmFuc2ZlcklkLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdCB0cmFuc2ZlcnMgZm9yIGFuIGFkZHJlc3MuXG4gICAgICogQHN1bW1hcnkgTGlzdCB0cmFuc2ZlcnMgZm9yIGFuIGFkZHJlc3MuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG9cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0byBsaXN0IHRyYW5zZmVycyBmb3JcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBBIGxpbWl0IG9uIHRoZSBudW1iZXIgb2Ygb2JqZWN0cyB0byBiZSByZXR1cm5lZC4gTGltaXQgY2FuIHJhbmdlIGJldHdlZW4gMSBhbmQgMTAwLCBhbmQgdGhlIGRlZmF1bHQgaXMgMTAuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlXSBBIGN1cnNvciBmb3IgcGFnaW5hdGlvbiBhY3Jvc3MgbXVsdGlwbGUgcGFnZXMgb2YgcmVzdWx0cy4gRG9uXFwmIzM5O3QgaW5jbHVkZSB0aGlzIHBhcmFtZXRlciBvbiB0aGUgZmlyc3QgY2FsbC4gVXNlIHRoZSBuZXh0X3BhZ2UgdmFsdWUgcmV0dXJuZWQgaW4gYSBwcmV2aW91cyByZXNwb25zZSB0byByZXF1ZXN0IHN1YnNlcXVlbnQgcmVzdWx0cy5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIFRyYW5zZmVyc0FwaVxuICAgICAqL1xuICAgIGxpc3RUcmFuc2ZlcnMod2FsbGV0SWQsIGFkZHJlc3NJZCwgbGltaXQsIHBhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLlRyYW5zZmVyc0FwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLmxpc3RUcmFuc2ZlcnMod2FsbGV0SWQsIGFkZHJlc3NJZCwgbGltaXQsIHBhZ2UsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuVHJhbnNmZXJzQXBpID0gVHJhbnNmZXJzQXBpO1xuLyoqXG4gKiBVc2Vyc0FwaSAtIGF4aW9zIHBhcmFtZXRlciBjcmVhdG9yXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IFVzZXJzQXBpQXhpb3NQYXJhbUNyZWF0b3IgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbikge1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgY3VycmVudCB1c2VyXG4gICAgICAgICAqIEBzdW1tYXJ5IEdldCBjdXJyZW50IHVzZXJcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGdldEN1cnJlbnRVc2VyOiBhc3luYyAob3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL3VzZXJzL21lYDtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0geyBtZXRob2Q6ICdHRVQnLCAuLi5iYXNlT3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IHsgLi4ubG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIC4uLmhlYWRlcnNGcm9tQmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMuaGVhZGVycyB9O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuVXNlcnNBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IFVzZXJzQXBpQXhpb3NQYXJhbUNyZWF0b3I7XG4vKipcbiAqIFVzZXJzQXBpIC0gZnVuY3Rpb25hbCBwcm9ncmFtbWluZyBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgVXNlcnNBcGlGcCA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uKSB7XG4gICAgY29uc3QgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvciA9ICgwLCBleHBvcnRzLlVzZXJzQXBpQXhpb3NQYXJhbUNyZWF0b3IpKGNvbmZpZ3VyYXRpb24pO1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgY3VycmVudCB1c2VyXG4gICAgICAgICAqIEBzdW1tYXJ5IEdldCBjdXJyZW50IHVzZXJcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGdldEN1cnJlbnRVc2VyKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5nZXRDdXJyZW50VXNlcihvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSBjb25maWd1cmF0aW9uPy5zZXJ2ZXJJbmRleCA/PyAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ1VzZXJzQXBpLmdldEN1cnJlbnRVc2VyJ10/Lltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XT8udXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuVXNlcnNBcGlGcCA9IFVzZXJzQXBpRnA7XG4vKipcbiAqIFVzZXJzQXBpIC0gZmFjdG9yeSBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgVXNlcnNBcGlGYWN0b3J5ID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24sIGJhc2VQYXRoLCBheGlvcykge1xuICAgIGNvbnN0IGxvY2FsVmFyRnAgPSAoMCwgZXhwb3J0cy5Vc2Vyc0FwaUZwKShjb25maWd1cmF0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGN1cnJlbnQgdXNlclxuICAgICAgICAgKiBAc3VtbWFyeSBHZXQgY3VycmVudCB1c2VyXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRDdXJyZW50VXNlcihvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5nZXRDdXJyZW50VXNlcihvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5Vc2Vyc0FwaUZhY3RvcnkgPSBVc2Vyc0FwaUZhY3Rvcnk7XG4vKipcbiAqIFVzZXJzQXBpIC0gb2JqZWN0LW9yaWVudGVkIGludGVyZmFjZVxuICogQGV4cG9ydFxuICogQGNsYXNzIFVzZXJzQXBpXG4gKiBAZXh0ZW5kcyB7QmFzZUFQSX1cbiAqL1xuY2xhc3MgVXNlcnNBcGkgZXh0ZW5kcyBiYXNlXzEuQmFzZUFQSSB7XG4gICAgLyoqXG4gICAgICogR2V0IGN1cnJlbnQgdXNlclxuICAgICAqIEBzdW1tYXJ5IEdldCBjdXJyZW50IHVzZXJcbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIFVzZXJzQXBpXG4gICAgICovXG4gICAgZ2V0Q3VycmVudFVzZXIob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuVXNlcnNBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5nZXRDdXJyZW50VXNlcihvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG59XG5leHBvcnRzLlVzZXJzQXBpID0gVXNlcnNBcGk7XG4vKipcbiAqIFdhbGxldHNBcGkgLSBheGlvcyBwYXJhbWV0ZXIgY3JlYXRvclxuICogQGV4cG9ydFxuICovXG5jb25zdCBXYWxsZXRzQXBpQXhpb3NQYXJhbUNyZWF0b3IgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbikge1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSBuZXcgd2FsbGV0IHNjb3BlZCB0byB0aGUgdXNlci5cbiAgICAgICAgICogQHN1bW1hcnkgQ3JlYXRlIGEgbmV3IHdhbGxldFxuICAgICAgICAgKiBAcGFyYW0ge0NyZWF0ZVdhbGxldFJlcXVlc3R9IFtjcmVhdGVXYWxsZXRSZXF1ZXN0XVxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgY3JlYXRlV2FsbGV0OiBhc3luYyAoY3JlYXRlV2FsbGV0UmVxdWVzdCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL3dhbGxldHNgO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7IG1ldGhvZDogJ1BPU1QnLCAuLi5iYXNlT3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIGFwaUtleSByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJKd3RcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICBsb2NhbFZhckhlYWRlclBhcmFtZXRlclsnQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSB7IC4uLmxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCAuLi5oZWFkZXJzRnJvbUJhc2VPcHRpb25zLCAuLi5vcHRpb25zLmhlYWRlcnMgfTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuZGF0YSA9ICgwLCBjb21tb25fMS5zZXJpYWxpemVEYXRhSWZOZWVkZWQpKGNyZWF0ZVdhbGxldFJlcXVlc3QsIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB3YWxsZXRcbiAgICAgICAgICogQHN1bW1hcnkgR2V0IHdhbGxldCBieSBJRFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdG8gZmV0Y2hcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGdldFdhbGxldDogYXN5bmMgKHdhbGxldElkLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ3dhbGxldElkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2dldFdhbGxldCcsICd3YWxsZXRJZCcsIHdhbGxldElkKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvd2FsbGV0cy97d2FsbGV0X2lkfWBcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJ3YWxsZXRfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyh3YWxsZXRJZCkpKTtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0geyBtZXRob2Q6ICdHRVQnLCAuLi5iYXNlT3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIGFwaUtleSByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJKd3RcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBzZXNzaW9uIHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIkp3dFwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IHsgLi4ubG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIC4uLmhlYWRlcnNGcm9tQmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMuaGVhZGVycyB9O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgYWdncmVnYXRlZCBiYWxhbmNlIG9mIGFuIGFzc2V0IGFjcm9zcyBhbGwgb2YgdGhlIGFkZHJlc3NlcyBpbiB0aGUgd2FsbGV0LlxuICAgICAgICAgKiBAc3VtbWFyeSBHZXQgdGhlIGJhbGFuY2Ugb2YgYW4gYXNzZXQgaW4gdGhlIHdhbGxldFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdG8gZmV0Y2ggdGhlIGJhbGFuY2UgZm9yXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhc3NldElkIFRoZSBzeW1ib2wgb2YgdGhlIGFzc2V0IHRvIGZldGNoIHRoZSBiYWxhbmNlIGZvclxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0V2FsbGV0QmFsYW5jZTogYXN5bmMgKHdhbGxldElkLCBhc3NldElkLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ3dhbGxldElkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2dldFdhbGxldEJhbGFuY2UnLCAnd2FsbGV0SWQnLCB3YWxsZXRJZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdhc3NldElkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2dldFdhbGxldEJhbGFuY2UnLCAnYXNzZXRJZCcsIGFzc2V0SWQpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS93YWxsZXRzL3t3YWxsZXRfaWR9L2JhbGFuY2VzL3thc3NldF9pZH1gXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wid2FsbGV0X2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcod2FsbGV0SWQpKSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJhc3NldF9pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKGFzc2V0SWQpKSk7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IHsgbWV0aG9kOiAnR0VUJywgLi4uYmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBhcGlLZXkgcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gc2Vzc2lvbiByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJKd3RcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSB7IC4uLmxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCAuLi5oZWFkZXJzRnJvbUJhc2VPcHRpb25zLCAuLi5vcHRpb25zLmhlYWRlcnMgfTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0IHRoZSBiYWxhbmNlcyBvZiBhbGwgb2YgdGhlIGFkZHJlc3NlcyBpbiB0aGUgd2FsbGV0IGFnZ3JlZ2F0ZWQgYnkgYXNzZXQuXG4gICAgICAgICAqIEBzdW1tYXJ5IExpc3Qgd2FsbGV0IGJhbGFuY2VzXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0byBmZXRjaCB0aGUgYmFsYW5jZXMgZm9yXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBsaXN0V2FsbGV0QmFsYW5jZXM6IGFzeW5jICh3YWxsZXRJZCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICd3YWxsZXRJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdsaXN0V2FsbGV0QmFsYW5jZXMnLCAnd2FsbGV0SWQnLCB3YWxsZXRJZCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL3dhbGxldHMve3dhbGxldF9pZH0vYmFsYW5jZXNgXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wid2FsbGV0X2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcod2FsbGV0SWQpKSk7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IHsgbWV0aG9kOiAnR0VUJywgLi4uYmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBhcGlLZXkgcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gc2Vzc2lvbiByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJKd3RcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSB7IC4uLmxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCAuLi5oZWFkZXJzRnJvbUJhc2VPcHRpb25zLCAuLi5vcHRpb25zLmhlYWRlcnMgfTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0IHdhbGxldHMgYmVsb25naW5nIHRvIHRoZSB1c2VyLlxuICAgICAgICAgKiBAc3VtbWFyeSBMaXN0IHdhbGxldHNcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gQSBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIG9iamVjdHMgdG8gYmUgcmV0dXJuZWQuIExpbWl0IGNhbiByYW5nZSBiZXR3ZWVuIDEgYW5kIDEwMCwgYW5kIHRoZSBkZWZhdWx0IGlzIDEwLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VdIEEgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiByZXN1bHRzLiBEb25cXCYjMzk7dCBpbmNsdWRlIHRoaXMgcGFyYW1ldGVyIG9uIHRoZSBmaXJzdCBjYWxsLiBVc2UgdGhlIG5leHRfcGFnZSB2YWx1ZSByZXR1cm5lZCBpbiBhIHByZXZpb3VzIHJlc3BvbnNlIHRvIHJlcXVlc3Qgc3Vic2VxdWVudCByZXN1bHRzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgbGlzdFdhbGxldHM6IGFzeW5jIChsaW1pdCwgcGFnZSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL3dhbGxldHNgO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7IG1ldGhvZDogJ0dFVCcsIC4uLmJhc2VPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gYXBpS2V5IHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIkp3dFwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIHNlc3Npb24gcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgaWYgKGxpbWl0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydsaW1pdCddID0gbGltaXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsncGFnZSddID0gcGFnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IHsgLi4ubG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIC4uLmhlYWRlcnNGcm9tQmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMuaGVhZGVycyB9O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuV2FsbGV0c0FwaUF4aW9zUGFyYW1DcmVhdG9yID0gV2FsbGV0c0FwaUF4aW9zUGFyYW1DcmVhdG9yO1xuLyoqXG4gKiBXYWxsZXRzQXBpIC0gZnVuY3Rpb25hbCBwcm9ncmFtbWluZyBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgV2FsbGV0c0FwaUZwID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24pIHtcbiAgICBjb25zdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yID0gKDAsIGV4cG9ydHMuV2FsbGV0c0FwaUF4aW9zUGFyYW1DcmVhdG9yKShjb25maWd1cmF0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgbmV3IHdhbGxldCBzY29wZWQgdG8gdGhlIHVzZXIuXG4gICAgICAgICAqIEBzdW1tYXJ5IENyZWF0ZSBhIG5ldyB3YWxsZXRcbiAgICAgICAgICogQHBhcmFtIHtDcmVhdGVXYWxsZXRSZXF1ZXN0fSBbY3JlYXRlV2FsbGV0UmVxdWVzdF1cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGNyZWF0ZVdhbGxldChjcmVhdGVXYWxsZXRSZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuY3JlYXRlV2FsbGV0KGNyZWF0ZVdhbGxldFJlcXVlc3QsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IGNvbmZpZ3VyYXRpb24/LnNlcnZlckluZGV4ID8/IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnV2FsbGV0c0FwaS5jcmVhdGVXYWxsZXQnXT8uW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdPy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHdhbGxldFxuICAgICAgICAgKiBAc3VtbWFyeSBHZXQgd2FsbGV0IGJ5IElEXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0byBmZXRjaFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgZ2V0V2FsbGV0KHdhbGxldElkLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuZ2V0V2FsbGV0KHdhbGxldElkLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSBjb25maWd1cmF0aW9uPy5zZXJ2ZXJJbmRleCA/PyAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ1dhbGxldHNBcGkuZ2V0V2FsbGV0J10/Lltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XT8udXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgYWdncmVnYXRlZCBiYWxhbmNlIG9mIGFuIGFzc2V0IGFjcm9zcyBhbGwgb2YgdGhlIGFkZHJlc3NlcyBpbiB0aGUgd2FsbGV0LlxuICAgICAgICAgKiBAc3VtbWFyeSBHZXQgdGhlIGJhbGFuY2Ugb2YgYW4gYXNzZXQgaW4gdGhlIHdhbGxldFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdG8gZmV0Y2ggdGhlIGJhbGFuY2UgZm9yXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhc3NldElkIFRoZSBzeW1ib2wgb2YgdGhlIGFzc2V0IHRvIGZldGNoIHRoZSBiYWxhbmNlIGZvclxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgZ2V0V2FsbGV0QmFsYW5jZSh3YWxsZXRJZCwgYXNzZXRJZCwgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmdldFdhbGxldEJhbGFuY2Uod2FsbGV0SWQsIGFzc2V0SWQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IGNvbmZpZ3VyYXRpb24/LnNlcnZlckluZGV4ID8/IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnV2FsbGV0c0FwaS5nZXRXYWxsZXRCYWxhbmNlJ10/Lltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XT8udXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3QgdGhlIGJhbGFuY2VzIG9mIGFsbCBvZiB0aGUgYWRkcmVzc2VzIGluIHRoZSB3YWxsZXQgYWdncmVnYXRlZCBieSBhc3NldC5cbiAgICAgICAgICogQHN1bW1hcnkgTGlzdCB3YWxsZXQgYmFsYW5jZXNcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRvIGZldGNoIHRoZSBiYWxhbmNlcyBmb3JcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGxpc3RXYWxsZXRCYWxhbmNlcyh3YWxsZXRJZCwgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmxpc3RXYWxsZXRCYWxhbmNlcyh3YWxsZXRJZCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gY29uZmlndXJhdGlvbj8uc2VydmVySW5kZXggPz8gMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydXYWxsZXRzQXBpLmxpc3RXYWxsZXRCYWxhbmNlcyddPy5bbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0/LnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0IHdhbGxldHMgYmVsb25naW5nIHRvIHRoZSB1c2VyLlxuICAgICAgICAgKiBAc3VtbWFyeSBMaXN0IHdhbGxldHNcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gQSBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIG9iamVjdHMgdG8gYmUgcmV0dXJuZWQuIExpbWl0IGNhbiByYW5nZSBiZXR3ZWVuIDEgYW5kIDEwMCwgYW5kIHRoZSBkZWZhdWx0IGlzIDEwLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VdIEEgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiByZXN1bHRzLiBEb25cXCYjMzk7dCBpbmNsdWRlIHRoaXMgcGFyYW1ldGVyIG9uIHRoZSBmaXJzdCBjYWxsLiBVc2UgdGhlIG5leHRfcGFnZSB2YWx1ZSByZXR1cm5lZCBpbiBhIHByZXZpb3VzIHJlc3BvbnNlIHRvIHJlcXVlc3Qgc3Vic2VxdWVudCByZXN1bHRzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgbGlzdFdhbGxldHMobGltaXQsIHBhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5saXN0V2FsbGV0cyhsaW1pdCwgcGFnZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gY29uZmlndXJhdGlvbj8uc2VydmVySW5kZXggPz8gMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydXYWxsZXRzQXBpLmxpc3RXYWxsZXRzJ10/Lltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XT8udXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuV2FsbGV0c0FwaUZwID0gV2FsbGV0c0FwaUZwO1xuLyoqXG4gKiBXYWxsZXRzQXBpIC0gZmFjdG9yeSBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgV2FsbGV0c0FwaUZhY3RvcnkgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbiwgYmFzZVBhdGgsIGF4aW9zKSB7XG4gICAgY29uc3QgbG9jYWxWYXJGcCA9ICgwLCBleHBvcnRzLldhbGxldHNBcGlGcCkoY29uZmlndXJhdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIG5ldyB3YWxsZXQgc2NvcGVkIHRvIHRoZSB1c2VyLlxuICAgICAgICAgKiBAc3VtbWFyeSBDcmVhdGUgYSBuZXcgd2FsbGV0XG4gICAgICAgICAqIEBwYXJhbSB7Q3JlYXRlV2FsbGV0UmVxdWVzdH0gW2NyZWF0ZVdhbGxldFJlcXVlc3RdXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGVXYWxsZXQoY3JlYXRlV2FsbGV0UmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuY3JlYXRlV2FsbGV0KGNyZWF0ZVdhbGxldFJlcXVlc3QsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgd2FsbGV0XG4gICAgICAgICAqIEBzdW1tYXJ5IEdldCB3YWxsZXQgYnkgSURcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRvIGZldGNoXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRXYWxsZXQod2FsbGV0SWQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmdldFdhbGxldCh3YWxsZXRJZCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgYWdncmVnYXRlZCBiYWxhbmNlIG9mIGFuIGFzc2V0IGFjcm9zcyBhbGwgb2YgdGhlIGFkZHJlc3NlcyBpbiB0aGUgd2FsbGV0LlxuICAgICAgICAgKiBAc3VtbWFyeSBHZXQgdGhlIGJhbGFuY2Ugb2YgYW4gYXNzZXQgaW4gdGhlIHdhbGxldFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdG8gZmV0Y2ggdGhlIGJhbGFuY2UgZm9yXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhc3NldElkIFRoZSBzeW1ib2wgb2YgdGhlIGFzc2V0IHRvIGZldGNoIHRoZSBiYWxhbmNlIGZvclxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0V2FsbGV0QmFsYW5jZSh3YWxsZXRJZCwgYXNzZXRJZCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuZ2V0V2FsbGV0QmFsYW5jZSh3YWxsZXRJZCwgYXNzZXRJZCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3QgdGhlIGJhbGFuY2VzIG9mIGFsbCBvZiB0aGUgYWRkcmVzc2VzIGluIHRoZSB3YWxsZXQgYWdncmVnYXRlZCBieSBhc3NldC5cbiAgICAgICAgICogQHN1bW1hcnkgTGlzdCB3YWxsZXQgYmFsYW5jZXNcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRvIGZldGNoIHRoZSBiYWxhbmNlcyBmb3JcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGxpc3RXYWxsZXRCYWxhbmNlcyh3YWxsZXRJZCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAubGlzdFdhbGxldEJhbGFuY2VzKHdhbGxldElkLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdCB3YWxsZXRzIGJlbG9uZ2luZyB0byB0aGUgdXNlci5cbiAgICAgICAgICogQHN1bW1hcnkgTGlzdCB3YWxsZXRzXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIEEgbGltaXQgb24gdGhlIG51bWJlciBvZiBvYmplY3RzIHRvIGJlIHJldHVybmVkLiBMaW1pdCBjYW4gcmFuZ2UgYmV0d2VlbiAxIGFuZCAxMDAsIGFuZCB0aGUgZGVmYXVsdCBpcyAxMC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlXSBBIGN1cnNvciBmb3IgcGFnaW5hdGlvbiBhY3Jvc3MgbXVsdGlwbGUgcGFnZXMgb2YgcmVzdWx0cy4gRG9uXFwmIzM5O3QgaW5jbHVkZSB0aGlzIHBhcmFtZXRlciBvbiB0aGUgZmlyc3QgY2FsbC4gVXNlIHRoZSBuZXh0X3BhZ2UgdmFsdWUgcmV0dXJuZWQgaW4gYSBwcmV2aW91cyByZXNwb25zZSB0byByZXF1ZXN0IHN1YnNlcXVlbnQgcmVzdWx0cy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGxpc3RXYWxsZXRzKGxpbWl0LCBwYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5saXN0V2FsbGV0cyhsaW1pdCwgcGFnZSwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuV2FsbGV0c0FwaUZhY3RvcnkgPSBXYWxsZXRzQXBpRmFjdG9yeTtcbi8qKlxuICogV2FsbGV0c0FwaSAtIG9iamVjdC1vcmllbnRlZCBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqIEBjbGFzcyBXYWxsZXRzQXBpXG4gKiBAZXh0ZW5kcyB7QmFzZUFQSX1cbiAqL1xuY2xhc3MgV2FsbGV0c0FwaSBleHRlbmRzIGJhc2VfMS5CYXNlQVBJIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgd2FsbGV0IHNjb3BlZCB0byB0aGUgdXNlci5cbiAgICAgKiBAc3VtbWFyeSBDcmVhdGUgYSBuZXcgd2FsbGV0XG4gICAgICogQHBhcmFtIHtDcmVhdGVXYWxsZXRSZXF1ZXN0fSBbY3JlYXRlV2FsbGV0UmVxdWVzdF1cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIFdhbGxldHNBcGlcbiAgICAgKi9cbiAgICBjcmVhdGVXYWxsZXQoY3JlYXRlV2FsbGV0UmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuV2FsbGV0c0FwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLmNyZWF0ZVdhbGxldChjcmVhdGVXYWxsZXRSZXF1ZXN0LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHdhbGxldFxuICAgICAqIEBzdW1tYXJ5IEdldCB3YWxsZXQgYnkgSURcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdG8gZmV0Y2hcbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIFdhbGxldHNBcGlcbiAgICAgKi9cbiAgICBnZXRXYWxsZXQod2FsbGV0SWQsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLldhbGxldHNBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5nZXRXYWxsZXQod2FsbGV0SWQsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGFnZ3JlZ2F0ZWQgYmFsYW5jZSBvZiBhbiBhc3NldCBhY3Jvc3MgYWxsIG9mIHRoZSBhZGRyZXNzZXMgaW4gdGhlIHdhbGxldC5cbiAgICAgKiBAc3VtbWFyeSBHZXQgdGhlIGJhbGFuY2Ugb2YgYW4gYXNzZXQgaW4gdGhlIHdhbGxldFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0byBmZXRjaCB0aGUgYmFsYW5jZSBmb3JcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXNzZXRJZCBUaGUgc3ltYm9sIG9mIHRoZSBhc3NldCB0byBmZXRjaCB0aGUgYmFsYW5jZSBmb3JcbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIFdhbGxldHNBcGlcbiAgICAgKi9cbiAgICBnZXRXYWxsZXRCYWxhbmNlKHdhbGxldElkLCBhc3NldElkLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5XYWxsZXRzQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuZ2V0V2FsbGV0QmFsYW5jZSh3YWxsZXRJZCwgYXNzZXRJZCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3QgdGhlIGJhbGFuY2VzIG9mIGFsbCBvZiB0aGUgYWRkcmVzc2VzIGluIHRoZSB3YWxsZXQgYWdncmVnYXRlZCBieSBhc3NldC5cbiAgICAgKiBAc3VtbWFyeSBMaXN0IHdhbGxldCBiYWxhbmNlc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0byBmZXRjaCB0aGUgYmFsYW5jZXMgZm9yXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBXYWxsZXRzQXBpXG4gICAgICovXG4gICAgbGlzdFdhbGxldEJhbGFuY2VzKHdhbGxldElkLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5XYWxsZXRzQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikubGlzdFdhbGxldEJhbGFuY2VzKHdhbGxldElkLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdCB3YWxsZXRzIGJlbG9uZ2luZyB0byB0aGUgdXNlci5cbiAgICAgKiBAc3VtbWFyeSBMaXN0IHdhbGxldHNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBBIGxpbWl0IG9uIHRoZSBudW1iZXIgb2Ygb2JqZWN0cyB0byBiZSByZXR1cm5lZC4gTGltaXQgY2FuIHJhbmdlIGJldHdlZW4gMSBhbmQgMTAwLCBhbmQgdGhlIGRlZmF1bHQgaXMgMTAuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlXSBBIGN1cnNvciBmb3IgcGFnaW5hdGlvbiBhY3Jvc3MgbXVsdGlwbGUgcGFnZXMgb2YgcmVzdWx0cy4gRG9uXFwmIzM5O3QgaW5jbHVkZSB0aGlzIHBhcmFtZXRlciBvbiB0aGUgZmlyc3QgY2FsbC4gVXNlIHRoZSBuZXh0X3BhZ2UgdmFsdWUgcmV0dXJuZWQgaW4gYSBwcmV2aW91cyByZXNwb25zZSB0byByZXF1ZXN0IHN1YnNlcXVlbnQgcmVzdWx0cy5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIFdhbGxldHNBcGlcbiAgICAgKi9cbiAgICBsaXN0V2FsbGV0cyhsaW1pdCwgcGFnZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuV2FsbGV0c0FwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLmxpc3RXYWxsZXRzKGxpbWl0LCBwYWdlLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG59XG5leHBvcnRzLldhbGxldHNBcGkgPSBXYWxsZXRzQXBpO1xuLyoqXG4gKiBXZWJob29rc0FwaSAtIGF4aW9zIHBhcmFtZXRlciBjcmVhdG9yXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IFdlYmhvb2tzQXBpQXhpb3NQYXJhbUNyZWF0b3IgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbikge1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSBuZXcgd2ViaG9vayBzY29wZWQgdG8gYSB3YWxsZXRcbiAgICAgICAgICogQHN1bW1hcnkgQ3JlYXRlIGEgbmV3IHdlYmhvb2sgc2NvcGVkIHRvIGEgd2FsbGV0XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0byBjcmVhdGUgdGhlIHdlYmhvb2sgZm9yLlxuICAgICAgICAgKiBAcGFyYW0ge0NyZWF0ZVdhbGxldFdlYmhvb2tSZXF1ZXN0fSBbY3JlYXRlV2FsbGV0V2ViaG9va1JlcXVlc3RdXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGVXYWxsZXRXZWJob29rOiBhc3luYyAod2FsbGV0SWQsIGNyZWF0ZVdhbGxldFdlYmhvb2tSZXF1ZXN0LCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ3dhbGxldElkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2NyZWF0ZVdhbGxldFdlYmhvb2snLCAnd2FsbGV0SWQnLCB3YWxsZXRJZCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL3dhbGxldHMve3dhbGxldF9pZH0vd2ViaG9va3NgXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wid2FsbGV0X2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcod2FsbGV0SWQpKSk7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IHsgbWV0aG9kOiAnUE9TVCcsIC4uLmJhc2VPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gYXBpS2V5IHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIkp3dFwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIHNlc3Npb24gcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXJbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0geyAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlciwgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucywgLi4ub3B0aW9ucy5oZWFkZXJzIH07XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmRhdGEgPSAoMCwgY29tbW9uXzEuc2VyaWFsaXplRGF0YUlmTmVlZGVkKShjcmVhdGVXYWxsZXRXZWJob29rUmVxdWVzdCwgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucywgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgbmV3IHdlYmhvb2tcbiAgICAgICAgICogQHN1bW1hcnkgQ3JlYXRlIGEgbmV3IHdlYmhvb2tcbiAgICAgICAgICogQHBhcmFtIHtDcmVhdGVXZWJob29rUmVxdWVzdH0gW2NyZWF0ZVdlYmhvb2tSZXF1ZXN0XVxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgY3JlYXRlV2ViaG9vazogYXN5bmMgKGNyZWF0ZVdlYmhvb2tSZXF1ZXN0LCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvd2ViaG9va3NgO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7IG1ldGhvZDogJ1BPU1QnLCAuLi5iYXNlT3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIGFwaUtleSByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJKd3RcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBzZXNzaW9uIHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIkp3dFwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IHsgLi4ubG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIC4uLmhlYWRlcnNGcm9tQmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMuaGVhZGVycyB9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5kYXRhID0gKDAsIGNvbW1vbl8xLnNlcmlhbGl6ZURhdGFJZk5lZWRlZCkoY3JlYXRlV2ViaG9va1JlcXVlc3QsIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlbGV0ZSBhIHdlYmhvb2tcbiAgICAgICAgICogQHN1bW1hcnkgRGVsZXRlIGEgd2ViaG9va1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2ViaG9va0lkIFRoZSBXZWJob29rIHV1aWQgdGhhdCBuZWVkcyB0byBiZSBkZWxldGVkXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBkZWxldGVXZWJob29rOiBhc3luYyAod2ViaG9va0lkLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ3dlYmhvb2tJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdkZWxldGVXZWJob29rJywgJ3dlYmhvb2tJZCcsIHdlYmhvb2tJZCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL3dlYmhvb2tzL3t3ZWJob29rX2lkfWBcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJ3ZWJob29rX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcod2ViaG9va0lkKSkpO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7IG1ldGhvZDogJ0RFTEVURScsIC4uLmJhc2VPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gYXBpS2V5IHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIkp3dFwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIHNlc3Npb24gcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0geyAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlciwgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucywgLi4ub3B0aW9ucy5oZWFkZXJzIH07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdCB3ZWJob29rcywgb3B0aW9uYWxseSBmaWx0ZXJlZCBieSBldmVudCB0eXBlLlxuICAgICAgICAgKiBAc3VtbWFyeSBMaXN0IHdlYmhvb2tzXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIEEgbGltaXQgb24gdGhlIG51bWJlciBvZiBvYmplY3RzIHRvIGJlIHJldHVybmVkLiBMaW1pdCBjYW4gcmFuZ2UgYmV0d2VlbiAxIGFuZCAxMDAsIGFuZCB0aGUgZGVmYXVsdCBpcyAxMC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlXSBBIGN1cnNvciBmb3IgcGFnaW5hdGlvbiBhY3Jvc3MgbXVsdGlwbGUgcGFnZXMgb2YgcmVzdWx0cy4gRG9uXFwmIzM5O3QgaW5jbHVkZSB0aGlzIHBhcmFtZXRlciBvbiB0aGUgZmlyc3QgY2FsbC4gVXNlIHRoZSBuZXh0X3BhZ2UgdmFsdWUgcmV0dXJuZWQgaW4gYSBwcmV2aW91cyByZXNwb25zZSB0byByZXF1ZXN0IHN1YnNlcXVlbnQgcmVzdWx0cy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGxpc3RXZWJob29rczogYXN5bmMgKGxpbWl0LCBwYWdlLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvd2ViaG9va3NgO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7IG1ldGhvZDogJ0dFVCcsIC4uLmJhc2VPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24gYXBpS2V5IHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIkp3dFwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIHNlc3Npb24gcmVxdWlyZWRcbiAgICAgICAgICAgIGF3YWl0ICgwLCBjb21tb25fMS5zZXRBcGlLZXlUb09iamVjdCkobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIFwiSnd0XCIsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgaWYgKGxpbWl0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydsaW1pdCddID0gbGltaXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsncGFnZSddID0gcGFnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IHsgLi4ubG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIC4uLmhlYWRlcnNGcm9tQmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMuaGVhZGVycyB9O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZSBhIHdlYmhvb2tcbiAgICAgICAgICogQHN1bW1hcnkgVXBkYXRlIGEgd2ViaG9va1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2ViaG9va0lkIFRoZSBXZWJob29rIGlkIHRoYXQgbmVlZHMgdG8gYmUgdXBkYXRlZFxuICAgICAgICAgKiBAcGFyYW0ge1VwZGF0ZVdlYmhvb2tSZXF1ZXN0fSBbdXBkYXRlV2ViaG9va1JlcXVlc3RdXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICB1cGRhdGVXZWJob29rOiBhc3luYyAod2ViaG9va0lkLCB1cGRhdGVXZWJob29rUmVxdWVzdCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICd3ZWJob29rSWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgndXBkYXRlV2ViaG9vaycsICd3ZWJob29rSWQnLCB3ZWJob29rSWQpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS93ZWJob29rcy97d2ViaG9va19pZH1gXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wid2ViaG9va19pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHdlYmhvb2tJZCkpKTtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0geyBtZXRob2Q6ICdQVVQnLCAuLi5iYXNlT3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIGFwaUtleSByZXF1aXJlZFxuICAgICAgICAgICAgYXdhaXQgKDAsIGNvbW1vbl8xLnNldEFwaUtleVRvT2JqZWN0KShsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgXCJKd3RcIiwgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICAvLyBhdXRoZW50aWNhdGlvbiBzZXNzaW9uIHJlcXVpcmVkXG4gICAgICAgICAgICBhd2FpdCAoMCwgY29tbW9uXzEuc2V0QXBpS2V5VG9PYmplY3QpKGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBcIkp3dFwiLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IHsgLi4ubG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIC4uLmhlYWRlcnNGcm9tQmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMuaGVhZGVycyB9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5kYXRhID0gKDAsIGNvbW1vbl8xLnNlcmlhbGl6ZURhdGFJZk5lZWRlZCkodXBkYXRlV2ViaG9va1JlcXVlc3QsIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuV2ViaG9va3NBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IFdlYmhvb2tzQXBpQXhpb3NQYXJhbUNyZWF0b3I7XG4vKipcbiAqIFdlYmhvb2tzQXBpIC0gZnVuY3Rpb25hbCBwcm9ncmFtbWluZyBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgV2ViaG9va3NBcGlGcCA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uKSB7XG4gICAgY29uc3QgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvciA9ICgwLCBleHBvcnRzLldlYmhvb2tzQXBpQXhpb3NQYXJhbUNyZWF0b3IpKGNvbmZpZ3VyYXRpb24pO1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSBuZXcgd2ViaG9vayBzY29wZWQgdG8gYSB3YWxsZXRcbiAgICAgICAgICogQHN1bW1hcnkgQ3JlYXRlIGEgbmV3IHdlYmhvb2sgc2NvcGVkIHRvIGEgd2FsbGV0XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0byBjcmVhdGUgdGhlIHdlYmhvb2sgZm9yLlxuICAgICAgICAgKiBAcGFyYW0ge0NyZWF0ZVdhbGxldFdlYmhvb2tSZXF1ZXN0fSBbY3JlYXRlV2FsbGV0V2ViaG9va1JlcXVlc3RdXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBjcmVhdGVXYWxsZXRXZWJob29rKHdhbGxldElkLCBjcmVhdGVXYWxsZXRXZWJob29rUmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmNyZWF0ZVdhbGxldFdlYmhvb2sod2FsbGV0SWQsIGNyZWF0ZVdhbGxldFdlYmhvb2tSZXF1ZXN0LCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSBjb25maWd1cmF0aW9uPy5zZXJ2ZXJJbmRleCA/PyAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ1dlYmhvb2tzQXBpLmNyZWF0ZVdhbGxldFdlYmhvb2snXT8uW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdPy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgbmV3IHdlYmhvb2tcbiAgICAgICAgICogQHN1bW1hcnkgQ3JlYXRlIGEgbmV3IHdlYmhvb2tcbiAgICAgICAgICogQHBhcmFtIHtDcmVhdGVXZWJob29rUmVxdWVzdH0gW2NyZWF0ZVdlYmhvb2tSZXF1ZXN0XVxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgY3JlYXRlV2ViaG9vayhjcmVhdGVXZWJob29rUmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmNyZWF0ZVdlYmhvb2soY3JlYXRlV2ViaG9va1JlcXVlc3QsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IGNvbmZpZ3VyYXRpb24/LnNlcnZlckluZGV4ID8/IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnV2ViaG9va3NBcGkuY3JlYXRlV2ViaG9vayddPy5bbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0/LnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWxldGUgYSB3ZWJob29rXG4gICAgICAgICAqIEBzdW1tYXJ5IERlbGV0ZSBhIHdlYmhvb2tcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdlYmhvb2tJZCBUaGUgV2ViaG9vayB1dWlkIHRoYXQgbmVlZHMgdG8gYmUgZGVsZXRlZFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgZGVsZXRlV2ViaG9vayh3ZWJob29rSWQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5kZWxldGVXZWJob29rKHdlYmhvb2tJZCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gY29uZmlndXJhdGlvbj8uc2VydmVySW5kZXggPz8gMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydXZWJob29rc0FwaS5kZWxldGVXZWJob29rJ10/Lltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XT8udXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3Qgd2ViaG9va3MsIG9wdGlvbmFsbHkgZmlsdGVyZWQgYnkgZXZlbnQgdHlwZS5cbiAgICAgICAgICogQHN1bW1hcnkgTGlzdCB3ZWJob29rc1xuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBBIGxpbWl0IG9uIHRoZSBudW1iZXIgb2Ygb2JqZWN0cyB0byBiZSByZXR1cm5lZC4gTGltaXQgY2FuIHJhbmdlIGJldHdlZW4gMSBhbmQgMTAwLCBhbmQgdGhlIGRlZmF1bHQgaXMgMTAuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZV0gQSBjdXJzb3IgZm9yIHBhZ2luYXRpb24gYWNyb3NzIG11bHRpcGxlIHBhZ2VzIG9mIHJlc3VsdHMuIERvblxcJiMzOTt0IGluY2x1ZGUgdGhpcyBwYXJhbWV0ZXIgb24gdGhlIGZpcnN0IGNhbGwuIFVzZSB0aGUgbmV4dF9wYWdlIHZhbHVlIHJldHVybmVkIGluIGEgcHJldmlvdXMgcmVzcG9uc2UgdG8gcmVxdWVzdCBzdWJzZXF1ZW50IHJlc3VsdHMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBsaXN0V2ViaG9va3MobGltaXQsIHBhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5saXN0V2ViaG9va3MobGltaXQsIHBhZ2UsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IGNvbmZpZ3VyYXRpb24/LnNlcnZlckluZGV4ID8/IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnV2ViaG9va3NBcGkubGlzdFdlYmhvb2tzJ10/Lltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XT8udXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZSBhIHdlYmhvb2tcbiAgICAgICAgICogQHN1bW1hcnkgVXBkYXRlIGEgd2ViaG9va1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2ViaG9va0lkIFRoZSBXZWJob29rIGlkIHRoYXQgbmVlZHMgdG8gYmUgdXBkYXRlZFxuICAgICAgICAgKiBAcGFyYW0ge1VwZGF0ZVdlYmhvb2tSZXF1ZXN0fSBbdXBkYXRlV2ViaG9va1JlcXVlc3RdXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyB1cGRhdGVXZWJob29rKHdlYmhvb2tJZCwgdXBkYXRlV2ViaG9va1JlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci51cGRhdGVXZWJob29rKHdlYmhvb2tJZCwgdXBkYXRlV2ViaG9va1JlcXVlc3QsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IGNvbmZpZ3VyYXRpb24/LnNlcnZlckluZGV4ID8/IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnV2ViaG9va3NBcGkudXBkYXRlV2ViaG9vayddPy5bbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0/LnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5leHBvcnRzLldlYmhvb2tzQXBpRnAgPSBXZWJob29rc0FwaUZwO1xuLyoqXG4gKiBXZWJob29rc0FwaSAtIGZhY3RvcnkgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IFdlYmhvb2tzQXBpRmFjdG9yeSA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uLCBiYXNlUGF0aCwgYXhpb3MpIHtcbiAgICBjb25zdCBsb2NhbFZhckZwID0gKDAsIGV4cG9ydHMuV2ViaG9va3NBcGlGcCkoY29uZmlndXJhdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIG5ldyB3ZWJob29rIHNjb3BlZCB0byBhIHdhbGxldFxuICAgICAgICAgKiBAc3VtbWFyeSBDcmVhdGUgYSBuZXcgd2ViaG9vayBzY29wZWQgdG8gYSB3YWxsZXRcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRvIGNyZWF0ZSB0aGUgd2ViaG9vayBmb3IuXG4gICAgICAgICAqIEBwYXJhbSB7Q3JlYXRlV2FsbGV0V2ViaG9va1JlcXVlc3R9IFtjcmVhdGVXYWxsZXRXZWJob29rUmVxdWVzdF1cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZVdhbGxldFdlYmhvb2sod2FsbGV0SWQsIGNyZWF0ZVdhbGxldFdlYmhvb2tSZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5jcmVhdGVXYWxsZXRXZWJob29rKHdhbGxldElkLCBjcmVhdGVXYWxsZXRXZWJob29rUmVxdWVzdCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIG5ldyB3ZWJob29rXG4gICAgICAgICAqIEBzdW1tYXJ5IENyZWF0ZSBhIG5ldyB3ZWJob29rXG4gICAgICAgICAqIEBwYXJhbSB7Q3JlYXRlV2ViaG9va1JlcXVlc3R9IFtjcmVhdGVXZWJob29rUmVxdWVzdF1cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZVdlYmhvb2soY3JlYXRlV2ViaG9va1JlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmNyZWF0ZVdlYmhvb2soY3JlYXRlV2ViaG9va1JlcXVlc3QsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWxldGUgYSB3ZWJob29rXG4gICAgICAgICAqIEBzdW1tYXJ5IERlbGV0ZSBhIHdlYmhvb2tcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdlYmhvb2tJZCBUaGUgV2ViaG9vayB1dWlkIHRoYXQgbmVlZHMgdG8gYmUgZGVsZXRlZFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgZGVsZXRlV2ViaG9vayh3ZWJob29rSWQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmRlbGV0ZVdlYmhvb2sod2ViaG9va0lkLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdCB3ZWJob29rcywgb3B0aW9uYWxseSBmaWx0ZXJlZCBieSBldmVudCB0eXBlLlxuICAgICAgICAgKiBAc3VtbWFyeSBMaXN0IHdlYmhvb2tzXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIEEgbGltaXQgb24gdGhlIG51bWJlciBvZiBvYmplY3RzIHRvIGJlIHJldHVybmVkLiBMaW1pdCBjYW4gcmFuZ2UgYmV0d2VlbiAxIGFuZCAxMDAsIGFuZCB0aGUgZGVmYXVsdCBpcyAxMC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlXSBBIGN1cnNvciBmb3IgcGFnaW5hdGlvbiBhY3Jvc3MgbXVsdGlwbGUgcGFnZXMgb2YgcmVzdWx0cy4gRG9uXFwmIzM5O3QgaW5jbHVkZSB0aGlzIHBhcmFtZXRlciBvbiB0aGUgZmlyc3QgY2FsbC4gVXNlIHRoZSBuZXh0X3BhZ2UgdmFsdWUgcmV0dXJuZWQgaW4gYSBwcmV2aW91cyByZXNwb25zZSB0byByZXF1ZXN0IHN1YnNlcXVlbnQgcmVzdWx0cy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGxpc3RXZWJob29rcyhsaW1pdCwgcGFnZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAubGlzdFdlYmhvb2tzKGxpbWl0LCBwYWdlLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlIGEgd2ViaG9va1xuICAgICAgICAgKiBAc3VtbWFyeSBVcGRhdGUgYSB3ZWJob29rXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3ZWJob29rSWQgVGhlIFdlYmhvb2sgaWQgdGhhdCBuZWVkcyB0byBiZSB1cGRhdGVkXG4gICAgICAgICAqIEBwYXJhbSB7VXBkYXRlV2ViaG9va1JlcXVlc3R9IFt1cGRhdGVXZWJob29rUmVxdWVzdF1cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIHVwZGF0ZVdlYmhvb2sod2ViaG9va0lkLCB1cGRhdGVXZWJob29rUmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAudXBkYXRlV2ViaG9vayh3ZWJob29rSWQsIHVwZGF0ZVdlYmhvb2tSZXF1ZXN0LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5XZWJob29rc0FwaUZhY3RvcnkgPSBXZWJob29rc0FwaUZhY3Rvcnk7XG4vKipcbiAqIFdlYmhvb2tzQXBpIC0gb2JqZWN0LW9yaWVudGVkIGludGVyZmFjZVxuICogQGV4cG9ydFxuICogQGNsYXNzIFdlYmhvb2tzQXBpXG4gKiBAZXh0ZW5kcyB7QmFzZUFQSX1cbiAqL1xuY2xhc3MgV2ViaG9va3NBcGkgZXh0ZW5kcyBiYXNlXzEuQmFzZUFQSSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IHdlYmhvb2sgc2NvcGVkIHRvIGEgd2FsbGV0XG4gICAgICogQHN1bW1hcnkgQ3JlYXRlIGEgbmV3IHdlYmhvb2sgc2NvcGVkIHRvIGEgd2FsbGV0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRvIGNyZWF0ZSB0aGUgd2ViaG9vayBmb3IuXG4gICAgICogQHBhcmFtIHtDcmVhdGVXYWxsZXRXZWJob29rUmVxdWVzdH0gW2NyZWF0ZVdhbGxldFdlYmhvb2tSZXF1ZXN0XVxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgV2ViaG9va3NBcGlcbiAgICAgKi9cbiAgICBjcmVhdGVXYWxsZXRXZWJob29rKHdhbGxldElkLCBjcmVhdGVXYWxsZXRXZWJob29rUmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuV2ViaG9va3NBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5jcmVhdGVXYWxsZXRXZWJob29rKHdhbGxldElkLCBjcmVhdGVXYWxsZXRXZWJob29rUmVxdWVzdCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyB3ZWJob29rXG4gICAgICogQHN1bW1hcnkgQ3JlYXRlIGEgbmV3IHdlYmhvb2tcbiAgICAgKiBAcGFyYW0ge0NyZWF0ZVdlYmhvb2tSZXF1ZXN0fSBbY3JlYXRlV2ViaG9va1JlcXVlc3RdXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBXZWJob29rc0FwaVxuICAgICAqL1xuICAgIGNyZWF0ZVdlYmhvb2soY3JlYXRlV2ViaG9va1JlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLldlYmhvb2tzQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuY3JlYXRlV2ViaG9vayhjcmVhdGVXZWJob29rUmVxdWVzdCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBhIHdlYmhvb2tcbiAgICAgKiBAc3VtbWFyeSBEZWxldGUgYSB3ZWJob29rXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHdlYmhvb2tJZCBUaGUgV2ViaG9vayB1dWlkIHRoYXQgbmVlZHMgdG8gYmUgZGVsZXRlZFxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgV2ViaG9va3NBcGlcbiAgICAgKi9cbiAgICBkZWxldGVXZWJob29rKHdlYmhvb2tJZCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuV2ViaG9va3NBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5kZWxldGVXZWJob29rKHdlYmhvb2tJZCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3Qgd2ViaG9va3MsIG9wdGlvbmFsbHkgZmlsdGVyZWQgYnkgZXZlbnQgdHlwZS5cbiAgICAgKiBAc3VtbWFyeSBMaXN0IHdlYmhvb2tzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gQSBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIG9iamVjdHMgdG8gYmUgcmV0dXJuZWQuIExpbWl0IGNhbiByYW5nZSBiZXR3ZWVuIDEgYW5kIDEwMCwgYW5kIHRoZSBkZWZhdWx0IGlzIDEwLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZV0gQSBjdXJzb3IgZm9yIHBhZ2luYXRpb24gYWNyb3NzIG11bHRpcGxlIHBhZ2VzIG9mIHJlc3VsdHMuIERvblxcJiMzOTt0IGluY2x1ZGUgdGhpcyBwYXJhbWV0ZXIgb24gdGhlIGZpcnN0IGNhbGwuIFVzZSB0aGUgbmV4dF9wYWdlIHZhbHVlIHJldHVybmVkIGluIGEgcHJldmlvdXMgcmVzcG9uc2UgdG8gcmVxdWVzdCBzdWJzZXF1ZW50IHJlc3VsdHMuXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBXZWJob29rc0FwaVxuICAgICAqL1xuICAgIGxpc3RXZWJob29rcyhsaW1pdCwgcGFnZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuV2ViaG9va3NBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5saXN0V2ViaG9va3MobGltaXQsIHBhZ2UsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgYSB3ZWJob29rXG4gICAgICogQHN1bW1hcnkgVXBkYXRlIGEgd2ViaG9va1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3ZWJob29rSWQgVGhlIFdlYmhvb2sgaWQgdGhhdCBuZWVkcyB0byBiZSB1cGRhdGVkXG4gICAgICogQHBhcmFtIHtVcGRhdGVXZWJob29rUmVxdWVzdH0gW3VwZGF0ZVdlYmhvb2tSZXF1ZXN0XVxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgV2ViaG9va3NBcGlcbiAgICAgKi9cbiAgICB1cGRhdGVXZWJob29rKHdlYmhvb2tJZCwgdXBkYXRlV2ViaG9va1JlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLldlYmhvb2tzQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikudXBkYXRlV2ViaG9vayh3ZWJob29rSWQsIHVwZGF0ZVdlYmhvb2tSZXF1ZXN0LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG59XG5leHBvcnRzLldlYmhvb2tzQXBpID0gV2ViaG9va3NBcGk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/client/api.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/client/base.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/client/base.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Coinbase Platform API\n * This is the OpenAPI 3.0 specification for the Coinbase Platform APIs, used in conjunction with the Coinbase Platform SDKs.\n *\n * The version of the OpenAPI document: 0.0.1-alpha\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.operationServerMap = exports.RequiredError = exports.BaseAPI = exports.COLLECTION_FORMATS = exports.BASE_PATH = void 0;\nconst axios_1 = __importDefault(__webpack_require__(/*! axios */ \"(rsc)/./node_modules/axios/dist/node/axios.cjs\"));\nexports.BASE_PATH = \"https://api.cdp.coinbase.com/platform\".replace(/\\/+$/, \"\");\n/**\n *\n * @export\n */\nexports.COLLECTION_FORMATS = {\n    csv: \",\",\n    ssv: \" \",\n    tsv: \"\\t\",\n    pipes: \"|\",\n};\n/**\n *\n * @export\n * @class BaseAPI\n */\nclass BaseAPI {\n    constructor(configuration, basePath = exports.BASE_PATH, axios = axios_1.default) {\n        this.basePath = basePath;\n        this.axios = axios;\n        if (configuration) {\n            this.configuration = configuration;\n            this.basePath = configuration.basePath ?? basePath;\n        }\n    }\n}\nexports.BaseAPI = BaseAPI;\n;\n/**\n *\n * @export\n * @class RequiredError\n * @extends {Error}\n */\nclass RequiredError extends Error {\n    constructor(field, msg) {\n        super(msg);\n        this.field = field;\n        this.name = \"RequiredError\";\n    }\n}\nexports.RequiredError = RequiredError;\n/**\n *\n * @export\n */\nexports.operationServerMap = {};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NsaWVudC9iYXNlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwwQkFBMEIsR0FBRyxxQkFBcUIsR0FBRyxlQUFlLEdBQUcsMEJBQTBCLEdBQUcsaUJBQWlCO0FBQ3JILGdDQUFnQyxtQkFBTyxDQUFDLDZEQUFPO0FBQy9DLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cnZpdmFsLWZ1bi8uL25vZGVfbW9kdWxlcy9AY29pbmJhc2UvY29pbmJhc2Utc2RrL2Rpc3QvY2xpZW50L2Jhc2UuanM/Y2M4NSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qIHRzbGludDpkaXNhYmxlICovXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuLyoqXG4gKiBDb2luYmFzZSBQbGF0Zm9ybSBBUElcbiAqIFRoaXMgaXMgdGhlIE9wZW5BUEkgMy4wIHNwZWNpZmljYXRpb24gZm9yIHRoZSBDb2luYmFzZSBQbGF0Zm9ybSBBUElzLCB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggdGhlIENvaW5iYXNlIFBsYXRmb3JtIFNES3MuXG4gKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIE9wZW5BUEkgZG9jdW1lbnQ6IDAuMC4xLWFscGhhXG4gKlxuICpcbiAqIE5PVEU6IFRoaXMgY2xhc3MgaXMgYXV0byBnZW5lcmF0ZWQgYnkgT3BlbkFQSSBHZW5lcmF0b3IgKGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaCkuXG4gKiBodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2hcbiAqIERvIG5vdCBlZGl0IHRoZSBjbGFzcyBtYW51YWxseS5cbiAqL1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5vcGVyYXRpb25TZXJ2ZXJNYXAgPSBleHBvcnRzLlJlcXVpcmVkRXJyb3IgPSBleHBvcnRzLkJhc2VBUEkgPSBleHBvcnRzLkNPTExFQ1RJT05fRk9STUFUUyA9IGV4cG9ydHMuQkFTRV9QQVRIID0gdm9pZCAwO1xuY29uc3QgYXhpb3NfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYXhpb3NcIikpO1xuZXhwb3J0cy5CQVNFX1BBVEggPSBcImh0dHBzOi8vYXBpLmNkcC5jb2luYmFzZS5jb20vcGxhdGZvcm1cIi5yZXBsYWNlKC9cXC8rJC8sIFwiXCIpO1xuLyoqXG4gKlxuICogQGV4cG9ydFxuICovXG5leHBvcnRzLkNPTExFQ1RJT05fRk9STUFUUyA9IHtcbiAgICBjc3Y6IFwiLFwiLFxuICAgIHNzdjogXCIgXCIsXG4gICAgdHN2OiBcIlxcdFwiLFxuICAgIHBpcGVzOiBcInxcIixcbn07XG4vKipcbiAqXG4gKiBAZXhwb3J0XG4gKiBAY2xhc3MgQmFzZUFQSVxuICovXG5jbGFzcyBCYXNlQVBJIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uLCBiYXNlUGF0aCA9IGV4cG9ydHMuQkFTRV9QQVRILCBheGlvcyA9IGF4aW9zXzEuZGVmYXVsdCkge1xuICAgICAgICB0aGlzLmJhc2VQYXRoID0gYmFzZVBhdGg7XG4gICAgICAgIHRoaXMuYXhpb3MgPSBheGlvcztcbiAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuY29uZmlndXJhdGlvbiA9IGNvbmZpZ3VyYXRpb247XG4gICAgICAgICAgICB0aGlzLmJhc2VQYXRoID0gY29uZmlndXJhdGlvbi5iYXNlUGF0aCA/PyBiYXNlUGF0aDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQmFzZUFQSSA9IEJhc2VBUEk7XG47XG4vKipcbiAqXG4gKiBAZXhwb3J0XG4gKiBAY2xhc3MgUmVxdWlyZWRFcnJvclxuICogQGV4dGVuZHMge0Vycm9yfVxuICovXG5jbGFzcyBSZXF1aXJlZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkLCBtc2cpIHtcbiAgICAgICAgc3VwZXIobXNnKTtcbiAgICAgICAgdGhpcy5maWVsZCA9IGZpZWxkO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIlJlcXVpcmVkRXJyb3JcIjtcbiAgICB9XG59XG5leHBvcnRzLlJlcXVpcmVkRXJyb3IgPSBSZXF1aXJlZEVycm9yO1xuLyoqXG4gKlxuICogQGV4cG9ydFxuICovXG5leHBvcnRzLm9wZXJhdGlvblNlcnZlck1hcCA9IHt9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/client/base.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/client/common.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/client/common.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Coinbase Platform API\n * This is the OpenAPI 3.0 specification for the Coinbase Platform APIs, used in conjunction with the Coinbase Platform SDKs.\n *\n * The version of the OpenAPI document: 0.0.1-alpha\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createRequestFunction = exports.toPathString = exports.serializeDataIfNeeded = exports.setSearchParams = exports.setOAuthToObject = exports.setBearerAuthToObject = exports.setBasicAuthToObject = exports.setApiKeyToObject = exports.assertParamExists = exports.DUMMY_BASE_URL = void 0;\nconst base_1 = __webpack_require__(/*! ./base */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/client/base.js\");\n/**\n *\n * @export\n */\nexports.DUMMY_BASE_URL = 'https://example.com';\n/**\n *\n * @throws {RequiredError}\n * @export\n */\nconst assertParamExists = function (functionName, paramName, paramValue) {\n    if (paramValue === null || paramValue === undefined) {\n        throw new base_1.RequiredError(paramName, `Required parameter ${paramName} was null or undefined when calling ${functionName}.`);\n    }\n};\nexports.assertParamExists = assertParamExists;\n/**\n *\n * @export\n */\nconst setApiKeyToObject = async function (object, keyParamName, configuration) {\n    if (configuration && configuration.apiKey) {\n        const localVarApiKeyValue = typeof configuration.apiKey === 'function'\n            ? await configuration.apiKey(keyParamName)\n            : await configuration.apiKey;\n        object[keyParamName] = localVarApiKeyValue;\n    }\n};\nexports.setApiKeyToObject = setApiKeyToObject;\n/**\n *\n * @export\n */\nconst setBasicAuthToObject = function (object, configuration) {\n    if (configuration && (configuration.username || configuration.password)) {\n        object[\"auth\"] = { username: configuration.username, password: configuration.password };\n    }\n};\nexports.setBasicAuthToObject = setBasicAuthToObject;\n/**\n *\n * @export\n */\nconst setBearerAuthToObject = async function (object, configuration) {\n    if (configuration && configuration.accessToken) {\n        const accessToken = typeof configuration.accessToken === 'function'\n            ? await configuration.accessToken()\n            : await configuration.accessToken;\n        object[\"Authorization\"] = \"Bearer \" + accessToken;\n    }\n};\nexports.setBearerAuthToObject = setBearerAuthToObject;\n/**\n *\n * @export\n */\nconst setOAuthToObject = async function (object, name, scopes, configuration) {\n    if (configuration && configuration.accessToken) {\n        const localVarAccessTokenValue = typeof configuration.accessToken === 'function'\n            ? await configuration.accessToken(name, scopes)\n            : await configuration.accessToken;\n        object[\"Authorization\"] = \"Bearer \" + localVarAccessTokenValue;\n    }\n};\nexports.setOAuthToObject = setOAuthToObject;\nfunction setFlattenedQueryParams(urlSearchParams, parameter, key = \"\") {\n    if (parameter == null)\n        return;\n    if (typeof parameter === \"object\") {\n        if (Array.isArray(parameter)) {\n            parameter.forEach(item => setFlattenedQueryParams(urlSearchParams, item, key));\n        }\n        else {\n            Object.keys(parameter).forEach(currentKey => setFlattenedQueryParams(urlSearchParams, parameter[currentKey], `${key}${key !== '' ? '.' : ''}${currentKey}`));\n        }\n    }\n    else {\n        if (urlSearchParams.has(key)) {\n            urlSearchParams.append(key, parameter);\n        }\n        else {\n            urlSearchParams.set(key, parameter);\n        }\n    }\n}\n/**\n *\n * @export\n */\nconst setSearchParams = function (url, ...objects) {\n    const searchParams = new URLSearchParams(url.search);\n    setFlattenedQueryParams(searchParams, objects);\n    url.search = searchParams.toString();\n};\nexports.setSearchParams = setSearchParams;\n/**\n *\n * @export\n */\nconst serializeDataIfNeeded = function (value, requestOptions, configuration) {\n    const nonString = typeof value !== 'string';\n    const needsSerialization = nonString && configuration && configuration.isJsonMime\n        ? configuration.isJsonMime(requestOptions.headers['Content-Type'])\n        : nonString;\n    return needsSerialization\n        ? JSON.stringify(value !== undefined ? value : {})\n        : (value || \"\");\n};\nexports.serializeDataIfNeeded = serializeDataIfNeeded;\n/**\n *\n * @export\n */\nconst toPathString = function (url) {\n    return url.pathname + url.search + url.hash;\n};\nexports.toPathString = toPathString;\n/**\n *\n * @export\n */\nconst createRequestFunction = function (axiosArgs, globalAxios, BASE_PATH, configuration) {\n    return (axios = globalAxios, basePath = BASE_PATH) => {\n        const axiosRequestArgs = { ...axiosArgs.options, url: (axios.defaults.baseURL ? '' : configuration?.basePath ?? basePath) + axiosArgs.url };\n        return axios.request(axiosRequestArgs);\n    };\n};\nexports.createRequestFunction = createRequestFunction;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NsaWVudC9jb21tb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw2QkFBNkIsR0FBRyxvQkFBb0IsR0FBRyw2QkFBNkIsR0FBRyx1QkFBdUIsR0FBRyx3QkFBd0IsR0FBRyw2QkFBNkIsR0FBRyw0QkFBNEIsR0FBRyx5QkFBeUIsR0FBRyx5QkFBeUIsR0FBRyxzQkFBc0I7QUFDelIsZUFBZSxtQkFBTyxDQUFDLCtFQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsV0FBVyxxQ0FBcUMsYUFBYTtBQUNySTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0SEFBNEgsSUFBSSxFQUFFLHNCQUFzQixFQUFFLFdBQVc7QUFDcks7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQSw2QkFBNkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXJ2aXZhbC1mdW4vLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NsaWVudC9jb21tb24uanM/N2IyOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qIHRzbGludDpkaXNhYmxlICovXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuLyoqXG4gKiBDb2luYmFzZSBQbGF0Zm9ybSBBUElcbiAqIFRoaXMgaXMgdGhlIE9wZW5BUEkgMy4wIHNwZWNpZmljYXRpb24gZm9yIHRoZSBDb2luYmFzZSBQbGF0Zm9ybSBBUElzLCB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggdGhlIENvaW5iYXNlIFBsYXRmb3JtIFNES3MuXG4gKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIE9wZW5BUEkgZG9jdW1lbnQ6IDAuMC4xLWFscGhhXG4gKlxuICpcbiAqIE5PVEU6IFRoaXMgY2xhc3MgaXMgYXV0byBnZW5lcmF0ZWQgYnkgT3BlbkFQSSBHZW5lcmF0b3IgKGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaCkuXG4gKiBodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2hcbiAqIERvIG5vdCBlZGl0IHRoZSBjbGFzcyBtYW51YWxseS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24gPSBleHBvcnRzLnRvUGF0aFN0cmluZyA9IGV4cG9ydHMuc2VyaWFsaXplRGF0YUlmTmVlZGVkID0gZXhwb3J0cy5zZXRTZWFyY2hQYXJhbXMgPSBleHBvcnRzLnNldE9BdXRoVG9PYmplY3QgPSBleHBvcnRzLnNldEJlYXJlckF1dGhUb09iamVjdCA9IGV4cG9ydHMuc2V0QmFzaWNBdXRoVG9PYmplY3QgPSBleHBvcnRzLnNldEFwaUtleVRvT2JqZWN0ID0gZXhwb3J0cy5hc3NlcnRQYXJhbUV4aXN0cyA9IGV4cG9ydHMuRFVNTVlfQkFTRV9VUkwgPSB2b2lkIDA7XG5jb25zdCBiYXNlXzEgPSByZXF1aXJlKFwiLi9iYXNlXCIpO1xuLyoqXG4gKlxuICogQGV4cG9ydFxuICovXG5leHBvcnRzLkRVTU1ZX0JBU0VfVVJMID0gJ2h0dHBzOi8vZXhhbXBsZS5jb20nO1xuLyoqXG4gKlxuICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgYXNzZXJ0UGFyYW1FeGlzdHMgPSBmdW5jdGlvbiAoZnVuY3Rpb25OYW1lLCBwYXJhbU5hbWUsIHBhcmFtVmFsdWUpIHtcbiAgICBpZiAocGFyYW1WYWx1ZSA9PT0gbnVsbCB8fCBwYXJhbVZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IGJhc2VfMS5SZXF1aXJlZEVycm9yKHBhcmFtTmFtZSwgYFJlcXVpcmVkIHBhcmFtZXRlciAke3BhcmFtTmFtZX0gd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyAke2Z1bmN0aW9uTmFtZX0uYCk7XG4gICAgfVxufTtcbmV4cG9ydHMuYXNzZXJ0UGFyYW1FeGlzdHMgPSBhc3NlcnRQYXJhbUV4aXN0cztcbi8qKlxuICpcbiAqIEBleHBvcnRcbiAqL1xuY29uc3Qgc2V0QXBpS2V5VG9PYmplY3QgPSBhc3luYyBmdW5jdGlvbiAob2JqZWN0LCBrZXlQYXJhbU5hbWUsIGNvbmZpZ3VyYXRpb24pIHtcbiAgICBpZiAoY29uZmlndXJhdGlvbiAmJiBjb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICBjb25zdCBsb2NhbFZhckFwaUtleVZhbHVlID0gdHlwZW9mIGNvbmZpZ3VyYXRpb24uYXBpS2V5ID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICA/IGF3YWl0IGNvbmZpZ3VyYXRpb24uYXBpS2V5KGtleVBhcmFtTmFtZSlcbiAgICAgICAgICAgIDogYXdhaXQgY29uZmlndXJhdGlvbi5hcGlLZXk7XG4gICAgICAgIG9iamVjdFtrZXlQYXJhbU5hbWVdID0gbG9jYWxWYXJBcGlLZXlWYWx1ZTtcbiAgICB9XG59O1xuZXhwb3J0cy5zZXRBcGlLZXlUb09iamVjdCA9IHNldEFwaUtleVRvT2JqZWN0O1xuLyoqXG4gKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBzZXRCYXNpY0F1dGhUb09iamVjdCA9IGZ1bmN0aW9uIChvYmplY3QsIGNvbmZpZ3VyYXRpb24pIHtcbiAgICBpZiAoY29uZmlndXJhdGlvbiAmJiAoY29uZmlndXJhdGlvbi51c2VybmFtZSB8fCBjb25maWd1cmF0aW9uLnBhc3N3b3JkKSkge1xuICAgICAgICBvYmplY3RbXCJhdXRoXCJdID0geyB1c2VybmFtZTogY29uZmlndXJhdGlvbi51c2VybmFtZSwgcGFzc3dvcmQ6IGNvbmZpZ3VyYXRpb24ucGFzc3dvcmQgfTtcbiAgICB9XG59O1xuZXhwb3J0cy5zZXRCYXNpY0F1dGhUb09iamVjdCA9IHNldEJhc2ljQXV0aFRvT2JqZWN0O1xuLyoqXG4gKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBzZXRCZWFyZXJBdXRoVG9PYmplY3QgPSBhc3luYyBmdW5jdGlvbiAob2JqZWN0LCBjb25maWd1cmF0aW9uKSB7XG4gICAgaWYgKGNvbmZpZ3VyYXRpb24gJiYgY29uZmlndXJhdGlvbi5hY2Nlc3NUb2tlbikge1xuICAgICAgICBjb25zdCBhY2Nlc3NUb2tlbiA9IHR5cGVvZiBjb25maWd1cmF0aW9uLmFjY2Vzc1Rva2VuID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICA/IGF3YWl0IGNvbmZpZ3VyYXRpb24uYWNjZXNzVG9rZW4oKVxuICAgICAgICAgICAgOiBhd2FpdCBjb25maWd1cmF0aW9uLmFjY2Vzc1Rva2VuO1xuICAgICAgICBvYmplY3RbXCJBdXRob3JpemF0aW9uXCJdID0gXCJCZWFyZXIgXCIgKyBhY2Nlc3NUb2tlbjtcbiAgICB9XG59O1xuZXhwb3J0cy5zZXRCZWFyZXJBdXRoVG9PYmplY3QgPSBzZXRCZWFyZXJBdXRoVG9PYmplY3Q7XG4vKipcbiAqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IHNldE9BdXRoVG9PYmplY3QgPSBhc3luYyBmdW5jdGlvbiAob2JqZWN0LCBuYW1lLCBzY29wZXMsIGNvbmZpZ3VyYXRpb24pIHtcbiAgICBpZiAoY29uZmlndXJhdGlvbiAmJiBjb25maWd1cmF0aW9uLmFjY2Vzc1Rva2VuKSB7XG4gICAgICAgIGNvbnN0IGxvY2FsVmFyQWNjZXNzVG9rZW5WYWx1ZSA9IHR5cGVvZiBjb25maWd1cmF0aW9uLmFjY2Vzc1Rva2VuID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICA/IGF3YWl0IGNvbmZpZ3VyYXRpb24uYWNjZXNzVG9rZW4obmFtZSwgc2NvcGVzKVxuICAgICAgICAgICAgOiBhd2FpdCBjb25maWd1cmF0aW9uLmFjY2Vzc1Rva2VuO1xuICAgICAgICBvYmplY3RbXCJBdXRob3JpemF0aW9uXCJdID0gXCJCZWFyZXIgXCIgKyBsb2NhbFZhckFjY2Vzc1Rva2VuVmFsdWU7XG4gICAgfVxufTtcbmV4cG9ydHMuc2V0T0F1dGhUb09iamVjdCA9IHNldE9BdXRoVG9PYmplY3Q7XG5mdW5jdGlvbiBzZXRGbGF0dGVuZWRRdWVyeVBhcmFtcyh1cmxTZWFyY2hQYXJhbXMsIHBhcmFtZXRlciwga2V5ID0gXCJcIikge1xuICAgIGlmIChwYXJhbWV0ZXIgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmICh0eXBlb2YgcGFyYW1ldGVyID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmFtZXRlcikpIHtcbiAgICAgICAgICAgIHBhcmFtZXRlci5mb3JFYWNoKGl0ZW0gPT4gc2V0RmxhdHRlbmVkUXVlcnlQYXJhbXModXJsU2VhcmNoUGFyYW1zLCBpdGVtLCBrZXkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHBhcmFtZXRlcikuZm9yRWFjaChjdXJyZW50S2V5ID0+IHNldEZsYXR0ZW5lZFF1ZXJ5UGFyYW1zKHVybFNlYXJjaFBhcmFtcywgcGFyYW1ldGVyW2N1cnJlbnRLZXldLCBgJHtrZXl9JHtrZXkgIT09ICcnID8gJy4nIDogJyd9JHtjdXJyZW50S2V5fWApKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKHVybFNlYXJjaFBhcmFtcy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgdXJsU2VhcmNoUGFyYW1zLmFwcGVuZChrZXksIHBhcmFtZXRlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB1cmxTZWFyY2hQYXJhbXMuc2V0KGtleSwgcGFyYW1ldGVyKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICpcbiAqIEBleHBvcnRcbiAqL1xuY29uc3Qgc2V0U2VhcmNoUGFyYW1zID0gZnVuY3Rpb24gKHVybCwgLi4ub2JqZWN0cykge1xuICAgIGNvbnN0IHNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXModXJsLnNlYXJjaCk7XG4gICAgc2V0RmxhdHRlbmVkUXVlcnlQYXJhbXMoc2VhcmNoUGFyYW1zLCBvYmplY3RzKTtcbiAgICB1cmwuc2VhcmNoID0gc2VhcmNoUGFyYW1zLnRvU3RyaW5nKCk7XG59O1xuZXhwb3J0cy5zZXRTZWFyY2hQYXJhbXMgPSBzZXRTZWFyY2hQYXJhbXM7XG4vKipcbiAqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IHNlcmlhbGl6ZURhdGFJZk5lZWRlZCA9IGZ1bmN0aW9uICh2YWx1ZSwgcmVxdWVzdE9wdGlvbnMsIGNvbmZpZ3VyYXRpb24pIHtcbiAgICBjb25zdCBub25TdHJpbmcgPSB0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnO1xuICAgIGNvbnN0IG5lZWRzU2VyaWFsaXphdGlvbiA9IG5vblN0cmluZyAmJiBjb25maWd1cmF0aW9uICYmIGNvbmZpZ3VyYXRpb24uaXNKc29uTWltZVxuICAgICAgICA/IGNvbmZpZ3VyYXRpb24uaXNKc29uTWltZShyZXF1ZXN0T3B0aW9ucy5oZWFkZXJzWydDb250ZW50LVR5cGUnXSlcbiAgICAgICAgOiBub25TdHJpbmc7XG4gICAgcmV0dXJuIG5lZWRzU2VyaWFsaXphdGlvblxuICAgICAgICA/IEpTT04uc3RyaW5naWZ5KHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IHt9KVxuICAgICAgICA6ICh2YWx1ZSB8fCBcIlwiKTtcbn07XG5leHBvcnRzLnNlcmlhbGl6ZURhdGFJZk5lZWRlZCA9IHNlcmlhbGl6ZURhdGFJZk5lZWRlZDtcbi8qKlxuICpcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgdG9QYXRoU3RyaW5nID0gZnVuY3Rpb24gKHVybCkge1xuICAgIHJldHVybiB1cmwucGF0aG5hbWUgKyB1cmwuc2VhcmNoICsgdXJsLmhhc2g7XG59O1xuZXhwb3J0cy50b1BhdGhTdHJpbmcgPSB0b1BhdGhTdHJpbmc7XG4vKipcbiAqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IGNyZWF0ZVJlcXVlc3RGdW5jdGlvbiA9IGZ1bmN0aW9uIChheGlvc0FyZ3MsIGdsb2JhbEF4aW9zLCBCQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pIHtcbiAgICByZXR1cm4gKGF4aW9zID0gZ2xvYmFsQXhpb3MsIGJhc2VQYXRoID0gQkFTRV9QQVRIKSA9PiB7XG4gICAgICAgIGNvbnN0IGF4aW9zUmVxdWVzdEFyZ3MgPSB7IC4uLmF4aW9zQXJncy5vcHRpb25zLCB1cmw6IChheGlvcy5kZWZhdWx0cy5iYXNlVVJMID8gJycgOiBjb25maWd1cmF0aW9uPy5iYXNlUGF0aCA/PyBiYXNlUGF0aCkgKyBheGlvc0FyZ3MudXJsIH07XG4gICAgICAgIHJldHVybiBheGlvcy5yZXF1ZXN0KGF4aW9zUmVxdWVzdEFyZ3MpO1xuICAgIH07XG59O1xuZXhwb3J0cy5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24gPSBjcmVhdGVSZXF1ZXN0RnVuY3Rpb247XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/client/common.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/client/configuration.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/client/configuration.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Coinbase Platform API\n * This is the OpenAPI 3.0 specification for the Coinbase Platform APIs, used in conjunction with the Coinbase Platform SDKs.\n *\n * The version of the OpenAPI document: 0.0.1-alpha\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Configuration = void 0;\nclass Configuration {\n    constructor(param = {}) {\n        this.apiKey = param.apiKey;\n        this.username = param.username;\n        this.password = param.password;\n        this.accessToken = param.accessToken;\n        this.basePath = param.basePath;\n        this.serverIndex = param.serverIndex;\n        this.baseOptions = {\n            headers: {\n                ...param.baseOptions?.headers,\n                'User-Agent': \"OpenAPI-Generator/typescript-axios\"\n            },\n            ...param.baseOptions\n        };\n        this.formDataCtor = param.formDataCtor;\n    }\n    /**\n     * Check if the given MIME is a JSON MIME.\n     * JSON MIME examples:\n     *   application/json\n     *   application/json; charset=UTF8\n     *   APPLICATION/JSON\n     *   application/vnd.company+json\n     * @param mime - MIME (Multipurpose Internet Mail Extensions)\n     * @return True if the given MIME is JSON, false otherwise.\n     */\n    isJsonMime(mime) {\n        const jsonMime = new RegExp('^(application\\/json|[^;/ \\t]+\\/[^;/ \\t]+[+]json)[ \\t]*(;.*)?$', 'i');\n        return mime !== null && (jsonMime.test(mime) || mime.toLowerCase() === 'application/json-patch+json');\n    }\n}\nexports.Configuration = Configuration;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NsaWVudC9jb25maWd1cmF0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCO0FBQ3JCO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELFdBQVcsc0JBQXNCO0FBQzdGO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cnZpdmFsLWZ1bi8uL25vZGVfbW9kdWxlcy9AY29pbmJhc2UvY29pbmJhc2Utc2RrL2Rpc3QvY2xpZW50L2NvbmZpZ3VyYXRpb24uanM/ZDk4OCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qIHRzbGludDpkaXNhYmxlICovXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuLyoqXG4gKiBDb2luYmFzZSBQbGF0Zm9ybSBBUElcbiAqIFRoaXMgaXMgdGhlIE9wZW5BUEkgMy4wIHNwZWNpZmljYXRpb24gZm9yIHRoZSBDb2luYmFzZSBQbGF0Zm9ybSBBUElzLCB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggdGhlIENvaW5iYXNlIFBsYXRmb3JtIFNES3MuXG4gKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIE9wZW5BUEkgZG9jdW1lbnQ6IDAuMC4xLWFscGhhXG4gKlxuICpcbiAqIE5PVEU6IFRoaXMgY2xhc3MgaXMgYXV0byBnZW5lcmF0ZWQgYnkgT3BlbkFQSSBHZW5lcmF0b3IgKGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaCkuXG4gKiBodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2hcbiAqIERvIG5vdCBlZGl0IHRoZSBjbGFzcyBtYW51YWxseS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db25maWd1cmF0aW9uID0gdm9pZCAwO1xuY2xhc3MgQ29uZmlndXJhdGlvbiB7XG4gICAgY29uc3RydWN0b3IocGFyYW0gPSB7fSkge1xuICAgICAgICB0aGlzLmFwaUtleSA9IHBhcmFtLmFwaUtleTtcbiAgICAgICAgdGhpcy51c2VybmFtZSA9IHBhcmFtLnVzZXJuYW1lO1xuICAgICAgICB0aGlzLnBhc3N3b3JkID0gcGFyYW0ucGFzc3dvcmQ7XG4gICAgICAgIHRoaXMuYWNjZXNzVG9rZW4gPSBwYXJhbS5hY2Nlc3NUb2tlbjtcbiAgICAgICAgdGhpcy5iYXNlUGF0aCA9IHBhcmFtLmJhc2VQYXRoO1xuICAgICAgICB0aGlzLnNlcnZlckluZGV4ID0gcGFyYW0uc2VydmVySW5kZXg7XG4gICAgICAgIHRoaXMuYmFzZU9wdGlvbnMgPSB7XG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgLi4ucGFyYW0uYmFzZU9wdGlvbnM/LmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgJ1VzZXItQWdlbnQnOiBcIk9wZW5BUEktR2VuZXJhdG9yL3R5cGVzY3JpcHQtYXhpb3NcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC4uLnBhcmFtLmJhc2VPcHRpb25zXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZm9ybURhdGFDdG9yID0gcGFyYW0uZm9ybURhdGFDdG9yO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGUgZ2l2ZW4gTUlNRSBpcyBhIEpTT04gTUlNRS5cbiAgICAgKiBKU09OIE1JTUUgZXhhbXBsZXM6XG4gICAgICogICBhcHBsaWNhdGlvbi9qc29uXG4gICAgICogICBhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PVVURjhcbiAgICAgKiAgIEFQUExJQ0FUSU9OL0pTT05cbiAgICAgKiAgIGFwcGxpY2F0aW9uL3ZuZC5jb21wYW55K2pzb25cbiAgICAgKiBAcGFyYW0gbWltZSAtIE1JTUUgKE11bHRpcHVycG9zZSBJbnRlcm5ldCBNYWlsIEV4dGVuc2lvbnMpXG4gICAgICogQHJldHVybiBUcnVlIGlmIHRoZSBnaXZlbiBNSU1FIGlzIEpTT04sIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBpc0pzb25NaW1lKG1pbWUpIHtcbiAgICAgICAgY29uc3QganNvbk1pbWUgPSBuZXcgUmVnRXhwKCdeKGFwcGxpY2F0aW9uXFwvanNvbnxbXjsvIFxcdF0rXFwvW147LyBcXHRdK1srXWpzb24pWyBcXHRdKig7LiopPyQnLCAnaScpO1xuICAgICAgICByZXR1cm4gbWltZSAhPT0gbnVsbCAmJiAoanNvbk1pbWUudGVzdChtaW1lKSB8fCBtaW1lLnRvTG93ZXJDYXNlKCkgPT09ICdhcHBsaWNhdGlvbi9qc29uLXBhdGNoK2pzb24nKTtcbiAgICB9XG59XG5leHBvcnRzLkNvbmZpZ3VyYXRpb24gPSBDb25maWd1cmF0aW9uO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/client/configuration.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/client/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/client/index.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Coinbase Platform API\n * This is the OpenAPI 3.0 specification for the Coinbase Platform APIs, used in conjunction with the Coinbase Platform SDKs.\n *\n * The version of the OpenAPI document: 0.0.1-alpha\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./api */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/client/api.js\"), exports);\n__exportStar(__webpack_require__(/*! ./configuration */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/client/configuration.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NsaWVudC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWEsbUJBQU8sQ0FBQyw2RUFBTztBQUM1QixhQUFhLG1CQUFPLENBQUMsaUdBQWlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3Vydml2YWwtZnVuLy4vbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9jb2luYmFzZS1zZGsvZGlzdC9jbGllbnQvaW5kZXguanM/ZGJjZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qIHRzbGludDpkaXNhYmxlICovXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuLyoqXG4gKiBDb2luYmFzZSBQbGF0Zm9ybSBBUElcbiAqIFRoaXMgaXMgdGhlIE9wZW5BUEkgMy4wIHNwZWNpZmljYXRpb24gZm9yIHRoZSBDb2luYmFzZSBQbGF0Zm9ybSBBUElzLCB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggdGhlIENvaW5iYXNlIFBsYXRmb3JtIFNES3MuXG4gKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIE9wZW5BUEkgZG9jdW1lbnQ6IDAuMC4xLWFscGhhXG4gKlxuICpcbiAqIE5PVEU6IFRoaXMgY2xhc3MgaXMgYXV0byBnZW5lcmF0ZWQgYnkgT3BlbkFQSSBHZW5lcmF0b3IgKGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaCkuXG4gKiBodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2hcbiAqIERvIG5vdCBlZGl0IHRoZSBjbGFzcyBtYW51YWxseS5cbiAqL1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYXBpXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jb25maWd1cmF0aW9uXCIpLCBleHBvcnRzKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/client/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/address.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/address.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Address = void 0;\nconst decimal_js_1 = __importDefault(__webpack_require__(/*! decimal.js */ \"(rsc)/./node_modules/decimal.js/decimal.js\"));\nconst coinbase_1 = __webpack_require__(/*! ./coinbase */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/coinbase.js\");\nconst asset_1 = __webpack_require__(/*! ./asset */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/asset.js\");\nconst balance_1 = __webpack_require__(/*! ./balance */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/balance.js\");\nconst balance_map_1 = __webpack_require__(/*! ./balance_map */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/balance_map.js\");\nconst faucet_transaction_1 = __webpack_require__(/*! ./faucet_transaction */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/faucet_transaction.js\");\nconst historical_balance_1 = __webpack_require__(/*! ./historical_balance */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/historical_balance.js\");\nconst types_1 = __webpack_require__(/*! ./types */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/types.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/utils.js\");\nconst staking_reward_1 = __webpack_require__(/*! ./staking_reward */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/staking_reward.js\");\nconst staking_balance_1 = __webpack_require__(/*! ./staking_balance */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/staking_balance.js\");\nconst transaction_1 = __webpack_require__(/*! ./transaction */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/transaction.js\");\nconst address_reputation_1 = __webpack_require__(/*! ./address_reputation */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/address_reputation.js\");\n/**\n * A representation of a blockchain address, which is a user-controlled account on a network.\n */\nclass Address {\n    /**\n     * Initializes a new Address instance.\n     *\n     * @param networkId - The network id.\n     * @param id - The onchain address id.\n     */\n    constructor(networkId, id) {\n        this.networkId = networkId;\n        this.id = id;\n    }\n    /**\n     * Returns the network ID.\n     *\n     * @returns The network ID.\n     */\n    getNetworkId() {\n        return this.networkId;\n    }\n    /**\n     * Returns the address ID.\n     *\n     * @returns The address ID.\n     */\n    getId() {\n        return this.id;\n    }\n    /**\n     * Returns the list of balances for the address.\n     *\n     * @returns The map from asset ID to balance.\n     */\n    async listBalances() {\n        const response = await coinbase_1.Coinbase.apiClients.externalAddress.listExternalAddressBalances(this.getNetworkId(), this.getId());\n        return balance_map_1.BalanceMap.fromBalances(response.data.data);\n    }\n    /**\n     * Returns the balance of the provided asset.\n     *\n     * @param assetId - The asset ID.\n     * @returns The balance of the asset.\n     */\n    async getBalance(assetId) {\n        const response = await coinbase_1.Coinbase.apiClients.externalAddress.getExternalAddressBalance(this.getNetworkId(), this.getId(), asset_1.Asset.primaryDenomination(assetId));\n        if (!response.data) {\n            return new decimal_js_1.default(0);\n        }\n        return balance_1.Balance.fromModelAndAssetId(response.data, assetId).amount;\n    }\n    /**\n     * Returns the historical balances of the provided asset.\n     *\n     * @param assetId - The asset ID.\n     * @param options - The pagination options.\n     * @param options.limit - The maximum number of Historical Balances to return. Limit can range between 1 and 100.\n     * @param options.page - The cursor for pagination across multiple pages of Historical Balances. Don\\&#39;t include this parameter on the first call. Use the next page value returned in a previous response to request subsequent results.\n     *\n     * @returns The paginated list response of Historical Balances for the given Asset ID.\n     */\n    async listHistoricalBalances(assetId, { limit = coinbase_1.Coinbase.defaultPageLimit, page = undefined } = {}) {\n        const data = [];\n        let nextPage;\n        const response = await coinbase_1.Coinbase.apiClients.balanceHistory.listAddressHistoricalBalance(this.getNetworkId(), this.getId(), asset_1.Asset.primaryDenomination(assetId), limit, page);\n        response.data.data.forEach(historicalBalanceModel => {\n            const historicalBalance = historical_balance_1.HistoricalBalance.fromModel(historicalBalanceModel);\n            data.push(historicalBalance);\n        });\n        const hasMore = response.data.has_more;\n        if (hasMore) {\n            if (response.data.next_page) {\n                nextPage = response.data.next_page;\n            }\n        }\n        return {\n            data,\n            hasMore,\n            nextPage,\n        };\n    }\n    /**\n     * Returns the transactions of the address.\n     *\n     * @param options - The pagination options.\n     * @param options.limit - The maximum number of Transactions to return. Limit can range between 1 and 100.\n     * @param options.page - The cursor for pagination across multiple pages of Transactions. Don\\&#39;t include this parameter on the first call. Use the next page value returned in a previous response to request subsequent results.\n     *\n     * @returns The paginated list response of Transactions.\n     */\n    async listTransactions({ limit = coinbase_1.Coinbase.defaultPageLimit, page = undefined, } = {}) {\n        const data = [];\n        let nextPage;\n        const response = await coinbase_1.Coinbase.apiClients.transactionHistory.listAddressTransactions(this.getNetworkId(), this.getId(), limit, page);\n        response.data.data.forEach(transactionModel => {\n            const transaction = new transaction_1.Transaction(transactionModel);\n            data.push(transaction);\n        });\n        const hasMore = response.data.has_more;\n        if (hasMore) {\n            if (response.data.next_page) {\n                nextPage = response.data.next_page;\n            }\n        }\n        return {\n            data,\n            hasMore,\n            nextPage,\n        };\n    }\n    /**\n     * Lists the staking rewards for the address.\n     *\n     * @param assetId - The asset ID.\n     * @param startTime - The start time.\n     * @param endTime - The end time.\n     * @param format - The format to return the rewards in. (usd, native). Defaults to usd.\n     * @returns The staking rewards.\n     */\n    async stakingRewards(assetId, startTime = (0, utils_1.getWeekBackDate)(new Date()), endTime = (0, utils_1.formatDate)(new Date()), format = types_1.StakingRewardFormat.USD) {\n        return staking_reward_1.StakingReward.list(coinbase_1.Coinbase.normalizeNetwork(this.getNetworkId()), assetId, [this.getId()], startTime, endTime, format);\n    }\n    /**\n     * Lists the historical staking balances for the address.\n     *\n     * @param assetId - The asset ID.\n     * @param startTime - The start time.\n     * @param endTime - The end time.\n     * @returns The staking balances.\n     */\n    async historicalStakingBalances(assetId, startTime = (0, utils_1.getWeekBackDate)(new Date()), endTime = (0, utils_1.formatDate)(new Date())) {\n        return staking_balance_1.StakingBalance.list(coinbase_1.Coinbase.normalizeNetwork(this.getNetworkId()), assetId, this.getId(), startTime, endTime);\n    }\n    /**\n     * Get the stakeable balance for the supplied asset.\n     *\n     * @param asset_id - The asset to check the stakeable balance for.\n     * @param mode - The staking mode. Defaults to DEFAULT.\n     * @param options - Additional options for getting the stakeable balance.\n     * @returns The stakeable balance.\n     */\n    async stakeableBalance(asset_id, mode = types_1.StakeOptionsMode.DEFAULT, options = {}) {\n        const balances = await this.getStakingBalances(asset_id, mode, options);\n        return balances.stakeableBalance;\n    }\n    /**\n     * Get the unstakeable balance for the supplied asset.\n     *\n     * @param asset_id - The asset to check the unstakeable balance for.\n     * @param mode - The staking mode. Defaults to DEFAULT.\n     * @param options - Additional options for getting the unstakeable balance.\n     * A. Dedicated ETH Staking\n     *  - `validator_pub_keys` (optional): List of comma separated validator public keys to retrieve unstakeable balance for. Defaults to all validators.\n     * @returns The unstakeable balance.\n     */\n    async unstakeableBalance(asset_id, mode = types_1.StakeOptionsMode.DEFAULT, options = {}) {\n        const balances = await this.getStakingBalances(asset_id, mode, options);\n        return balances.unstakeableBalance;\n    }\n    /**\n     * Get the claimable balance for the supplied asset.\n     *\n     * @param asset_id - The asset to check claimable balance for.\n     * @param mode - The staking mode. Defaults to DEFAULT.\n     * @param options - Additional options for getting the claimable balance.\n     * @returns The claimable balance.\n     */\n    async claimableBalance(asset_id, mode = types_1.StakeOptionsMode.DEFAULT, options = {}) {\n        const balances = await this.getStakingBalances(asset_id, mode, options);\n        return balances.claimableBalance;\n    }\n    /**\n     * Get the pending claimable balance for the supplied asset.\n     *\n     * @param asset_id - The asset to check pending claimable balance for.\n     * @param mode - The staking mode. Defaults to DEFAULT.\n     * @param options - Additional options for getting the pending claimable balance.\n     * @returns The pending claimable balance.\n     */\n    async pendingClaimableBalance(asset_id, mode = types_1.StakeOptionsMode.DEFAULT, options = {}) {\n        const balances = await this.getStakingBalances(asset_id, mode, options);\n        return balances.pendingClaimableBalance;\n    }\n    /**\n     * Requests faucet funds for the address.\n     * Only supported on testnet networks.\n     *\n     * @param assetId - The ID of the asset to transfer from the faucet.\n     * @returns The faucet transaction object.\n     * @throws {Error} If the request does not return a transaction hash.\n     * @throws {Error} If the request fails.\n     */\n    async faucet(assetId) {\n        const response = await coinbase_1.Coinbase.apiClients.externalAddress.requestExternalFaucetFunds(this.getNetworkId(), this.getId(), assetId, true);\n        return new faucet_transaction_1.FaucetTransaction(response.data);\n    }\n    /**\n     * Returns the reputation of the Address.\n     *\n     * @returns The reputation of the Address.\n     * @throws {Error} if the API request to get the Address reputation fails.\n     * @throws {Error} if the Address reputation is not available.\n     */\n    async reputation() {\n        if (this._reputation) {\n            return this._reputation;\n        }\n        const response = await coinbase_1.Coinbase.apiClients.addressReputation.getAddressReputation(this.getNetworkId(), this.getId());\n        this._reputation = new address_reputation_1.AddressReputation(response.data);\n        return this._reputation;\n    }\n    /**\n     * Returns a string representation of the address.\n     *\n     * @returns A string representing the address.\n     */\n    toString() {\n        return `Address { addressId: '${this.getId()}', networkId: '${this.getNetworkId()}' }`;\n    }\n    /**\n     * Validate if the operation is able to stake with the supplied input.\n     *\n     * @param amount - The amount of the asset to stake.\n     * @param assetId - The asset to stake.\n     * @param mode - The staking mode. Defaults to DEFAULT.\n     * @param options - Additional options for the stake operation.\n     * @private\n     * @throws {Error} If the supplied input is not able to create a stake operation.\n     */\n    async validateCanStake(amount, assetId, mode, options) {\n        const stakeableBalance = await this.stakeableBalance(assetId, mode, options);\n        if (new decimal_js_1.default(stakeableBalance).lessThan(amount.toString())) {\n            throw new Error(`Insufficient funds ${amount} requested to stake, only ${stakeableBalance} available.`);\n        }\n    }\n    /**\n     * Validate if the operation is able to unstake with the supplied input.\n     *\n     * @param amount - The amount of the asset to unstake.\n     * @param assetId - The asset to unstake.\n     * @param mode - The staking mode. Defaults to DEFAULT.\n     * @param options - Additional options for the unstake operation.\n     * @private\n     * @throws {Error} If the supplied input is not able to create an unstake operation.\n     */\n    async validateCanUnstake(amount, assetId, mode, options) {\n        const unstakeableBalance = new decimal_js_1.default(await this.unstakeableBalance(assetId, mode, options));\n        if (unstakeableBalance.lessThan(amount.toString())) {\n            throw new Error(`Insufficient funds ${amount} requested to unstake, only ${unstakeableBalance} available.`);\n        }\n    }\n    /**\n     * Validate if the operation is able to claim stake with the supplied input.\n     *\n     * @param amount - The amount of the asset to claim stake.\n     * @param assetId - The asset to claim stake.\n     * @param mode - The staking mode. Defaults to DEFAULT.\n     * @param options - Additional options for the claim stake operation.\n     * @private\n     * @throws {Error} If the supplied input is not able to create a claim stake operation.\n     */\n    async validateCanClaimStake(amount, assetId, mode, options) {\n        if (assetId === \"eth\" && mode === types_1.StakeOptionsMode.NATIVE) {\n            throw new Error(`Claiming stake for ETH is not supported in native mode.`);\n        }\n        const claimableBalance = new decimal_js_1.default(await this.claimableBalance(assetId, mode, options));\n        if (claimableBalance.lessThan(amount.toString())) {\n            throw new Error(`Insufficient funds ${amount} requested to claim stake, only ${claimableBalance} available.`);\n        }\n    }\n    /**\n     * Create a shallow copy of given options.\n     *\n     * @param options - The supplied options to be copied\n     * @private\n     * @returns A copy of the options.\n     */\n    copyOptions(options) {\n        return { ...options };\n    }\n    /**\n     * Get the different staking balance types for the supplied asset.\n     *\n     * @param assetId - The asset to lookup balances for.\n     * @param mode - The staking mode. Defaults to DEFAULT.\n     * @param options - Additional options for the balance lookup.\n     * @private\n     * @returns The different balance types.\n     */\n    async getStakingBalances(assetId, mode, options) {\n        const newOptions = this.copyOptions(options);\n        if (mode) {\n            newOptions.mode = mode;\n        }\n        const request = {\n            network_id: this.getNetworkId(),\n            asset_id: asset_1.Asset.primaryDenomination(assetId),\n            address_id: this.getId(),\n            options: newOptions,\n        };\n        const response = await coinbase_1.Coinbase.apiClients.stake.getStakingContext(request);\n        return {\n            stakeableBalance: balance_1.Balance.fromModelAndAssetId(response.data.context.stakeable_balance, assetId).amount,\n            unstakeableBalance: balance_1.Balance.fromModelAndAssetId(response.data.context.unstakeable_balance, assetId).amount,\n            pendingClaimableBalance: balance_1.Balance.fromModelAndAssetId(response.data.context.pending_claimable_balance, assetId).amount,\n            claimableBalance: balance_1.Balance.fromModelAndAssetId(response.data.context.claimable_balance, assetId).amount,\n        };\n    }\n}\nexports.Address = Address;\nAddress.MAX_HISTORICAL_BALANCE = 1000;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL2FkZHJlc3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxlQUFlO0FBQ2YscUNBQXFDLG1CQUFPLENBQUMsOERBQVk7QUFDekQsbUJBQW1CLG1CQUFPLENBQUMseUZBQVk7QUFDdkMsZ0JBQWdCLG1CQUFPLENBQUMsbUZBQVM7QUFDakMsa0JBQWtCLG1CQUFPLENBQUMsdUZBQVc7QUFDckMsc0JBQXNCLG1CQUFPLENBQUMsK0ZBQWU7QUFDN0MsNkJBQTZCLG1CQUFPLENBQUMsNkdBQXNCO0FBQzNELDZCQUE2QixtQkFBTyxDQUFDLDZHQUFzQjtBQUMzRCxnQkFBZ0IsbUJBQU8sQ0FBQyxtRkFBUztBQUNqQyxnQkFBZ0IsbUJBQU8sQ0FBQyxtRkFBUztBQUNqQyx5QkFBeUIsbUJBQU8sQ0FBQyxxR0FBa0I7QUFDbkQsMEJBQTBCLG1CQUFPLENBQUMsdUdBQW1CO0FBQ3JELHNCQUFzQixtQkFBTyxDQUFDLCtGQUFlO0FBQzdDLDZCQUE2QixtQkFBTyxDQUFDLDZHQUFzQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhHQUE4RztBQUM5RztBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsaUVBQWlFLElBQUk7QUFDakg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1R0FBdUc7QUFDdkc7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGtFQUFrRSxJQUFJO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBGQUEwRjtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRGQUE0RjtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpR0FBaUc7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGNBQWMsYUFBYSxpQkFBaUIsb0JBQW9CLEdBQUc7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsUUFBUSwyQkFBMkIsa0JBQWtCO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsUUFBUSw2QkFBNkIsb0JBQW9CO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsUUFBUSxpQ0FBaUMsa0JBQWtCO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZiIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cnZpdmFsLWZ1bi8uL25vZGVfbW9kdWxlcy9AY29pbmJhc2UvY29pbmJhc2Utc2RrL2Rpc3QvY29pbmJhc2UvYWRkcmVzcy5qcz8yZDM0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BZGRyZXNzID0gdm9pZCAwO1xuY29uc3QgZGVjaW1hbF9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJkZWNpbWFsLmpzXCIpKTtcbmNvbnN0IGNvaW5iYXNlXzEgPSByZXF1aXJlKFwiLi9jb2luYmFzZVwiKTtcbmNvbnN0IGFzc2V0XzEgPSByZXF1aXJlKFwiLi9hc3NldFwiKTtcbmNvbnN0IGJhbGFuY2VfMSA9IHJlcXVpcmUoXCIuL2JhbGFuY2VcIik7XG5jb25zdCBiYWxhbmNlX21hcF8xID0gcmVxdWlyZShcIi4vYmFsYW5jZV9tYXBcIik7XG5jb25zdCBmYXVjZXRfdHJhbnNhY3Rpb25fMSA9IHJlcXVpcmUoXCIuL2ZhdWNldF90cmFuc2FjdGlvblwiKTtcbmNvbnN0IGhpc3RvcmljYWxfYmFsYW5jZV8xID0gcmVxdWlyZShcIi4vaGlzdG9yaWNhbF9iYWxhbmNlXCIpO1xuY29uc3QgdHlwZXNfMSA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuY29uc3Qgc3Rha2luZ19yZXdhcmRfMSA9IHJlcXVpcmUoXCIuL3N0YWtpbmdfcmV3YXJkXCIpO1xuY29uc3Qgc3Rha2luZ19iYWxhbmNlXzEgPSByZXF1aXJlKFwiLi9zdGFraW5nX2JhbGFuY2VcIik7XG5jb25zdCB0cmFuc2FjdGlvbl8xID0gcmVxdWlyZShcIi4vdHJhbnNhY3Rpb25cIik7XG5jb25zdCBhZGRyZXNzX3JlcHV0YXRpb25fMSA9IHJlcXVpcmUoXCIuL2FkZHJlc3NfcmVwdXRhdGlvblwiKTtcbi8qKlxuICogQSByZXByZXNlbnRhdGlvbiBvZiBhIGJsb2NrY2hhaW4gYWRkcmVzcywgd2hpY2ggaXMgYSB1c2VyLWNvbnRyb2xsZWQgYWNjb3VudCBvbiBhIG5ldHdvcmsuXG4gKi9cbmNsYXNzIEFkZHJlc3Mge1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGEgbmV3IEFkZHJlc3MgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmV0d29ya0lkIC0gVGhlIG5ldHdvcmsgaWQuXG4gICAgICogQHBhcmFtIGlkIC0gVGhlIG9uY2hhaW4gYWRkcmVzcyBpZC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihuZXR3b3JrSWQsIGlkKSB7XG4gICAgICAgIHRoaXMubmV0d29ya0lkID0gbmV0d29ya0lkO1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG5ldHdvcmsgSUQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgbmV0d29yayBJRC5cbiAgICAgKi9cbiAgICBnZXROZXR3b3JrSWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5ldHdvcmtJZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYWRkcmVzcyBJRC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBhZGRyZXNzIElELlxuICAgICAqL1xuICAgIGdldElkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbGlzdCBvZiBiYWxhbmNlcyBmb3IgdGhlIGFkZHJlc3MuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgbWFwIGZyb20gYXNzZXQgSUQgdG8gYmFsYW5jZS5cbiAgICAgKi9cbiAgICBhc3luYyBsaXN0QmFsYW5jZXMoKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY29pbmJhc2VfMS5Db2luYmFzZS5hcGlDbGllbnRzLmV4dGVybmFsQWRkcmVzcy5saXN0RXh0ZXJuYWxBZGRyZXNzQmFsYW5jZXModGhpcy5nZXROZXR3b3JrSWQoKSwgdGhpcy5nZXRJZCgpKTtcbiAgICAgICAgcmV0dXJuIGJhbGFuY2VfbWFwXzEuQmFsYW5jZU1hcC5mcm9tQmFsYW5jZXMocmVzcG9uc2UuZGF0YS5kYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYmFsYW5jZSBvZiB0aGUgcHJvdmlkZWQgYXNzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXNzZXRJZCAtIFRoZSBhc3NldCBJRC5cbiAgICAgKiBAcmV0dXJucyBUaGUgYmFsYW5jZSBvZiB0aGUgYXNzZXQuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QmFsYW5jZShhc3NldElkKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY29pbmJhc2VfMS5Db2luYmFzZS5hcGlDbGllbnRzLmV4dGVybmFsQWRkcmVzcy5nZXRFeHRlcm5hbEFkZHJlc3NCYWxhbmNlKHRoaXMuZ2V0TmV0d29ya0lkKCksIHRoaXMuZ2V0SWQoKSwgYXNzZXRfMS5Bc3NldC5wcmltYXJ5RGVub21pbmF0aW9uKGFzc2V0SWQpKTtcbiAgICAgICAgaWYgKCFyZXNwb25zZS5kYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGRlY2ltYWxfanNfMS5kZWZhdWx0KDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiYWxhbmNlXzEuQmFsYW5jZS5mcm9tTW9kZWxBbmRBc3NldElkKHJlc3BvbnNlLmRhdGEsIGFzc2V0SWQpLmFtb3VudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaGlzdG9yaWNhbCBiYWxhbmNlcyBvZiB0aGUgcHJvdmlkZWQgYXNzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXNzZXRJZCAtIFRoZSBhc3NldCBJRC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBwYWdpbmF0aW9uIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIG9wdGlvbnMubGltaXQgLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgSGlzdG9yaWNhbCBCYWxhbmNlcyB0byByZXR1cm4uIExpbWl0IGNhbiByYW5nZSBiZXR3ZWVuIDEgYW5kIDEwMC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5wYWdlIC0gVGhlIGN1cnNvciBmb3IgcGFnaW5hdGlvbiBhY3Jvc3MgbXVsdGlwbGUgcGFnZXMgb2YgSGlzdG9yaWNhbCBCYWxhbmNlcy4gRG9uXFwmIzM5O3QgaW5jbHVkZSB0aGlzIHBhcmFtZXRlciBvbiB0aGUgZmlyc3QgY2FsbC4gVXNlIHRoZSBuZXh0IHBhZ2UgdmFsdWUgcmV0dXJuZWQgaW4gYSBwcmV2aW91cyByZXNwb25zZSB0byByZXF1ZXN0IHN1YnNlcXVlbnQgcmVzdWx0cy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBwYWdpbmF0ZWQgbGlzdCByZXNwb25zZSBvZiBIaXN0b3JpY2FsIEJhbGFuY2VzIGZvciB0aGUgZ2l2ZW4gQXNzZXQgSUQuXG4gICAgICovXG4gICAgYXN5bmMgbGlzdEhpc3RvcmljYWxCYWxhbmNlcyhhc3NldElkLCB7IGxpbWl0ID0gY29pbmJhc2VfMS5Db2luYmFzZS5kZWZhdWx0UGFnZUxpbWl0LCBwYWdlID0gdW5kZWZpbmVkIH0gPSB7fSkge1xuICAgICAgICBjb25zdCBkYXRhID0gW107XG4gICAgICAgIGxldCBuZXh0UGFnZTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjb2luYmFzZV8xLkNvaW5iYXNlLmFwaUNsaWVudHMuYmFsYW5jZUhpc3RvcnkubGlzdEFkZHJlc3NIaXN0b3JpY2FsQmFsYW5jZSh0aGlzLmdldE5ldHdvcmtJZCgpLCB0aGlzLmdldElkKCksIGFzc2V0XzEuQXNzZXQucHJpbWFyeURlbm9taW5hdGlvbihhc3NldElkKSwgbGltaXQsIHBhZ2UpO1xuICAgICAgICByZXNwb25zZS5kYXRhLmRhdGEuZm9yRWFjaChoaXN0b3JpY2FsQmFsYW5jZU1vZGVsID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGhpc3RvcmljYWxCYWxhbmNlID0gaGlzdG9yaWNhbF9iYWxhbmNlXzEuSGlzdG9yaWNhbEJhbGFuY2UuZnJvbU1vZGVsKGhpc3RvcmljYWxCYWxhbmNlTW9kZWwpO1xuICAgICAgICAgICAgZGF0YS5wdXNoKGhpc3RvcmljYWxCYWxhbmNlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGhhc01vcmUgPSByZXNwb25zZS5kYXRhLmhhc19tb3JlO1xuICAgICAgICBpZiAoaGFzTW9yZSkge1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLmRhdGEubmV4dF9wYWdlKSB7XG4gICAgICAgICAgICAgICAgbmV4dFBhZ2UgPSByZXNwb25zZS5kYXRhLm5leHRfcGFnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIGhhc01vcmUsXG4gICAgICAgICAgICBuZXh0UGFnZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdHJhbnNhY3Rpb25zIG9mIHRoZSBhZGRyZXNzLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgcGFnaW5hdGlvbiBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIFRyYW5zYWN0aW9ucyB0byByZXR1cm4uIExpbWl0IGNhbiByYW5nZSBiZXR3ZWVuIDEgYW5kIDEwMC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5wYWdlIC0gVGhlIGN1cnNvciBmb3IgcGFnaW5hdGlvbiBhY3Jvc3MgbXVsdGlwbGUgcGFnZXMgb2YgVHJhbnNhY3Rpb25zLiBEb25cXCYjMzk7dCBpbmNsdWRlIHRoaXMgcGFyYW1ldGVyIG9uIHRoZSBmaXJzdCBjYWxsLiBVc2UgdGhlIG5leHQgcGFnZSB2YWx1ZSByZXR1cm5lZCBpbiBhIHByZXZpb3VzIHJlc3BvbnNlIHRvIHJlcXVlc3Qgc3Vic2VxdWVudCByZXN1bHRzLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHBhZ2luYXRlZCBsaXN0IHJlc3BvbnNlIG9mIFRyYW5zYWN0aW9ucy5cbiAgICAgKi9cbiAgICBhc3luYyBsaXN0VHJhbnNhY3Rpb25zKHsgbGltaXQgPSBjb2luYmFzZV8xLkNvaW5iYXNlLmRlZmF1bHRQYWdlTGltaXQsIHBhZ2UgPSB1bmRlZmluZWQsIH0gPSB7fSkge1xuICAgICAgICBjb25zdCBkYXRhID0gW107XG4gICAgICAgIGxldCBuZXh0UGFnZTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjb2luYmFzZV8xLkNvaW5iYXNlLmFwaUNsaWVudHMudHJhbnNhY3Rpb25IaXN0b3J5Lmxpc3RBZGRyZXNzVHJhbnNhY3Rpb25zKHRoaXMuZ2V0TmV0d29ya0lkKCksIHRoaXMuZ2V0SWQoKSwgbGltaXQsIHBhZ2UpO1xuICAgICAgICByZXNwb25zZS5kYXRhLmRhdGEuZm9yRWFjaCh0cmFuc2FjdGlvbk1vZGVsID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gbmV3IHRyYW5zYWN0aW9uXzEuVHJhbnNhY3Rpb24odHJhbnNhY3Rpb25Nb2RlbCk7XG4gICAgICAgICAgICBkYXRhLnB1c2godHJhbnNhY3Rpb24pO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgaGFzTW9yZSA9IHJlc3BvbnNlLmRhdGEuaGFzX21vcmU7XG4gICAgICAgIGlmIChoYXNNb3JlKSB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UuZGF0YS5uZXh0X3BhZ2UpIHtcbiAgICAgICAgICAgICAgICBuZXh0UGFnZSA9IHJlc3BvbnNlLmRhdGEubmV4dF9wYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgaGFzTW9yZSxcbiAgICAgICAgICAgIG5leHRQYWdlLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0cyB0aGUgc3Rha2luZyByZXdhcmRzIGZvciB0aGUgYWRkcmVzcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhc3NldElkIC0gVGhlIGFzc2V0IElELlxuICAgICAqIEBwYXJhbSBzdGFydFRpbWUgLSBUaGUgc3RhcnQgdGltZS5cbiAgICAgKiBAcGFyYW0gZW5kVGltZSAtIFRoZSBlbmQgdGltZS5cbiAgICAgKiBAcGFyYW0gZm9ybWF0IC0gVGhlIGZvcm1hdCB0byByZXR1cm4gdGhlIHJld2FyZHMgaW4uICh1c2QsIG5hdGl2ZSkuIERlZmF1bHRzIHRvIHVzZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgc3Rha2luZyByZXdhcmRzLlxuICAgICAqL1xuICAgIGFzeW5jIHN0YWtpbmdSZXdhcmRzKGFzc2V0SWQsIHN0YXJ0VGltZSA9ICgwLCB1dGlsc18xLmdldFdlZWtCYWNrRGF0ZSkobmV3IERhdGUoKSksIGVuZFRpbWUgPSAoMCwgdXRpbHNfMS5mb3JtYXREYXRlKShuZXcgRGF0ZSgpKSwgZm9ybWF0ID0gdHlwZXNfMS5TdGFraW5nUmV3YXJkRm9ybWF0LlVTRCkge1xuICAgICAgICByZXR1cm4gc3Rha2luZ19yZXdhcmRfMS5TdGFraW5nUmV3YXJkLmxpc3QoY29pbmJhc2VfMS5Db2luYmFzZS5ub3JtYWxpemVOZXR3b3JrKHRoaXMuZ2V0TmV0d29ya0lkKCkpLCBhc3NldElkLCBbdGhpcy5nZXRJZCgpXSwgc3RhcnRUaW1lLCBlbmRUaW1lLCBmb3JtYXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0cyB0aGUgaGlzdG9yaWNhbCBzdGFraW5nIGJhbGFuY2VzIGZvciB0aGUgYWRkcmVzcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhc3NldElkIC0gVGhlIGFzc2V0IElELlxuICAgICAqIEBwYXJhbSBzdGFydFRpbWUgLSBUaGUgc3RhcnQgdGltZS5cbiAgICAgKiBAcGFyYW0gZW5kVGltZSAtIFRoZSBlbmQgdGltZS5cbiAgICAgKiBAcmV0dXJucyBUaGUgc3Rha2luZyBiYWxhbmNlcy5cbiAgICAgKi9cbiAgICBhc3luYyBoaXN0b3JpY2FsU3Rha2luZ0JhbGFuY2VzKGFzc2V0SWQsIHN0YXJ0VGltZSA9ICgwLCB1dGlsc18xLmdldFdlZWtCYWNrRGF0ZSkobmV3IERhdGUoKSksIGVuZFRpbWUgPSAoMCwgdXRpbHNfMS5mb3JtYXREYXRlKShuZXcgRGF0ZSgpKSkge1xuICAgICAgICByZXR1cm4gc3Rha2luZ19iYWxhbmNlXzEuU3Rha2luZ0JhbGFuY2UubGlzdChjb2luYmFzZV8xLkNvaW5iYXNlLm5vcm1hbGl6ZU5ldHdvcmsodGhpcy5nZXROZXR3b3JrSWQoKSksIGFzc2V0SWQsIHRoaXMuZ2V0SWQoKSwgc3RhcnRUaW1lLCBlbmRUaW1lKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBzdGFrZWFibGUgYmFsYW5jZSBmb3IgdGhlIHN1cHBsaWVkIGFzc2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGFzc2V0X2lkIC0gVGhlIGFzc2V0IHRvIGNoZWNrIHRoZSBzdGFrZWFibGUgYmFsYW5jZSBmb3IuXG4gICAgICogQHBhcmFtIG1vZGUgLSBUaGUgc3Rha2luZyBtb2RlLiBEZWZhdWx0cyB0byBERUZBVUxULlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gQWRkaXRpb25hbCBvcHRpb25zIGZvciBnZXR0aW5nIHRoZSBzdGFrZWFibGUgYmFsYW5jZS5cbiAgICAgKiBAcmV0dXJucyBUaGUgc3Rha2VhYmxlIGJhbGFuY2UuXG4gICAgICovXG4gICAgYXN5bmMgc3Rha2VhYmxlQmFsYW5jZShhc3NldF9pZCwgbW9kZSA9IHR5cGVzXzEuU3Rha2VPcHRpb25zTW9kZS5ERUZBVUxULCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3QgYmFsYW5jZXMgPSBhd2FpdCB0aGlzLmdldFN0YWtpbmdCYWxhbmNlcyhhc3NldF9pZCwgbW9kZSwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBiYWxhbmNlcy5zdGFrZWFibGVCYWxhbmNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHVuc3Rha2VhYmxlIGJhbGFuY2UgZm9yIHRoZSBzdXBwbGllZCBhc3NldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhc3NldF9pZCAtIFRoZSBhc3NldCB0byBjaGVjayB0aGUgdW5zdGFrZWFibGUgYmFsYW5jZSBmb3IuXG4gICAgICogQHBhcmFtIG1vZGUgLSBUaGUgc3Rha2luZyBtb2RlLiBEZWZhdWx0cyB0byBERUZBVUxULlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gQWRkaXRpb25hbCBvcHRpb25zIGZvciBnZXR0aW5nIHRoZSB1bnN0YWtlYWJsZSBiYWxhbmNlLlxuICAgICAqIEEuIERlZGljYXRlZCBFVEggU3Rha2luZ1xuICAgICAqICAtIGB2YWxpZGF0b3JfcHViX2tleXNgIChvcHRpb25hbCk6IExpc3Qgb2YgY29tbWEgc2VwYXJhdGVkIHZhbGlkYXRvciBwdWJsaWMga2V5cyB0byByZXRyaWV2ZSB1bnN0YWtlYWJsZSBiYWxhbmNlIGZvci4gRGVmYXVsdHMgdG8gYWxsIHZhbGlkYXRvcnMuXG4gICAgICogQHJldHVybnMgVGhlIHVuc3Rha2VhYmxlIGJhbGFuY2UuXG4gICAgICovXG4gICAgYXN5bmMgdW5zdGFrZWFibGVCYWxhbmNlKGFzc2V0X2lkLCBtb2RlID0gdHlwZXNfMS5TdGFrZU9wdGlvbnNNb2RlLkRFRkFVTFQsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCBiYWxhbmNlcyA9IGF3YWl0IHRoaXMuZ2V0U3Rha2luZ0JhbGFuY2VzKGFzc2V0X2lkLCBtb2RlLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIGJhbGFuY2VzLnVuc3Rha2VhYmxlQmFsYW5jZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjbGFpbWFibGUgYmFsYW5jZSBmb3IgdGhlIHN1cHBsaWVkIGFzc2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGFzc2V0X2lkIC0gVGhlIGFzc2V0IHRvIGNoZWNrIGNsYWltYWJsZSBiYWxhbmNlIGZvci5cbiAgICAgKiBAcGFyYW0gbW9kZSAtIFRoZSBzdGFraW5nIG1vZGUuIERlZmF1bHRzIHRvIERFRkFVTFQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBBZGRpdGlvbmFsIG9wdGlvbnMgZm9yIGdldHRpbmcgdGhlIGNsYWltYWJsZSBiYWxhbmNlLlxuICAgICAqIEByZXR1cm5zIFRoZSBjbGFpbWFibGUgYmFsYW5jZS5cbiAgICAgKi9cbiAgICBhc3luYyBjbGFpbWFibGVCYWxhbmNlKGFzc2V0X2lkLCBtb2RlID0gdHlwZXNfMS5TdGFrZU9wdGlvbnNNb2RlLkRFRkFVTFQsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCBiYWxhbmNlcyA9IGF3YWl0IHRoaXMuZ2V0U3Rha2luZ0JhbGFuY2VzKGFzc2V0X2lkLCBtb2RlLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIGJhbGFuY2VzLmNsYWltYWJsZUJhbGFuY2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgcGVuZGluZyBjbGFpbWFibGUgYmFsYW5jZSBmb3IgdGhlIHN1cHBsaWVkIGFzc2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGFzc2V0X2lkIC0gVGhlIGFzc2V0IHRvIGNoZWNrIHBlbmRpbmcgY2xhaW1hYmxlIGJhbGFuY2UgZm9yLlxuICAgICAqIEBwYXJhbSBtb2RlIC0gVGhlIHN0YWtpbmcgbW9kZS4gRGVmYXVsdHMgdG8gREVGQVVMVC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFkZGl0aW9uYWwgb3B0aW9ucyBmb3IgZ2V0dGluZyB0aGUgcGVuZGluZyBjbGFpbWFibGUgYmFsYW5jZS5cbiAgICAgKiBAcmV0dXJucyBUaGUgcGVuZGluZyBjbGFpbWFibGUgYmFsYW5jZS5cbiAgICAgKi9cbiAgICBhc3luYyBwZW5kaW5nQ2xhaW1hYmxlQmFsYW5jZShhc3NldF9pZCwgbW9kZSA9IHR5cGVzXzEuU3Rha2VPcHRpb25zTW9kZS5ERUZBVUxULCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3QgYmFsYW5jZXMgPSBhd2FpdCB0aGlzLmdldFN0YWtpbmdCYWxhbmNlcyhhc3NldF9pZCwgbW9kZSwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBiYWxhbmNlcy5wZW5kaW5nQ2xhaW1hYmxlQmFsYW5jZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVxdWVzdHMgZmF1Y2V0IGZ1bmRzIGZvciB0aGUgYWRkcmVzcy5cbiAgICAgKiBPbmx5IHN1cHBvcnRlZCBvbiB0ZXN0bmV0IG5ldHdvcmtzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFzc2V0SWQgLSBUaGUgSUQgb2YgdGhlIGFzc2V0IHRvIHRyYW5zZmVyIGZyb20gdGhlIGZhdWNldC5cbiAgICAgKiBAcmV0dXJucyBUaGUgZmF1Y2V0IHRyYW5zYWN0aW9uIG9iamVjdC5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHJlcXVlc3QgZG9lcyBub3QgcmV0dXJuIGEgdHJhbnNhY3Rpb24gaGFzaC5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHJlcXVlc3QgZmFpbHMuXG4gICAgICovXG4gICAgYXN5bmMgZmF1Y2V0KGFzc2V0SWQpIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjb2luYmFzZV8xLkNvaW5iYXNlLmFwaUNsaWVudHMuZXh0ZXJuYWxBZGRyZXNzLnJlcXVlc3RFeHRlcm5hbEZhdWNldEZ1bmRzKHRoaXMuZ2V0TmV0d29ya0lkKCksIHRoaXMuZ2V0SWQoKSwgYXNzZXRJZCwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgZmF1Y2V0X3RyYW5zYWN0aW9uXzEuRmF1Y2V0VHJhbnNhY3Rpb24ocmVzcG9uc2UuZGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHJlcHV0YXRpb24gb2YgdGhlIEFkZHJlc3MuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgcmVwdXRhdGlvbiBvZiB0aGUgQWRkcmVzcy5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlIEFQSSByZXF1ZXN0IHRvIGdldCB0aGUgQWRkcmVzcyByZXB1dGF0aW9uIGZhaWxzLlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBpZiB0aGUgQWRkcmVzcyByZXB1dGF0aW9uIGlzIG5vdCBhdmFpbGFibGUuXG4gICAgICovXG4gICAgYXN5bmMgcmVwdXRhdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX3JlcHV0YXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXB1dGF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY29pbmJhc2VfMS5Db2luYmFzZS5hcGlDbGllbnRzLmFkZHJlc3NSZXB1dGF0aW9uLmdldEFkZHJlc3NSZXB1dGF0aW9uKHRoaXMuZ2V0TmV0d29ya0lkKCksIHRoaXMuZ2V0SWQoKSk7XG4gICAgICAgIHRoaXMuX3JlcHV0YXRpb24gPSBuZXcgYWRkcmVzc19yZXB1dGF0aW9uXzEuQWRkcmVzc1JlcHV0YXRpb24ocmVzcG9uc2UuZGF0YSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZXB1dGF0aW9uO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBhZGRyZXNzLlxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBhZGRyZXNzLlxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gYEFkZHJlc3MgeyBhZGRyZXNzSWQ6ICcke3RoaXMuZ2V0SWQoKX0nLCBuZXR3b3JrSWQ6ICcke3RoaXMuZ2V0TmV0d29ya0lkKCl9JyB9YDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGUgaWYgdGhlIG9wZXJhdGlvbiBpcyBhYmxlIHRvIHN0YWtlIHdpdGggdGhlIHN1cHBsaWVkIGlucHV0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGFtb3VudCAtIFRoZSBhbW91bnQgb2YgdGhlIGFzc2V0IHRvIHN0YWtlLlxuICAgICAqIEBwYXJhbSBhc3NldElkIC0gVGhlIGFzc2V0IHRvIHN0YWtlLlxuICAgICAqIEBwYXJhbSBtb2RlIC0gVGhlIHN0YWtpbmcgbW9kZS4gRGVmYXVsdHMgdG8gREVGQVVMVC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFkZGl0aW9uYWwgb3B0aW9ucyBmb3IgdGhlIHN0YWtlIG9wZXJhdGlvbi5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgc3VwcGxpZWQgaW5wdXQgaXMgbm90IGFibGUgdG8gY3JlYXRlIGEgc3Rha2Ugb3BlcmF0aW9uLlxuICAgICAqL1xuICAgIGFzeW5jIHZhbGlkYXRlQ2FuU3Rha2UoYW1vdW50LCBhc3NldElkLCBtb2RlLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHN0YWtlYWJsZUJhbGFuY2UgPSBhd2FpdCB0aGlzLnN0YWtlYWJsZUJhbGFuY2UoYXNzZXRJZCwgbW9kZSwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChuZXcgZGVjaW1hbF9qc18xLmRlZmF1bHQoc3Rha2VhYmxlQmFsYW5jZSkubGVzc1RoYW4oYW1vdW50LnRvU3RyaW5nKCkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEluc3VmZmljaWVudCBmdW5kcyAke2Ftb3VudH0gcmVxdWVzdGVkIHRvIHN0YWtlLCBvbmx5ICR7c3Rha2VhYmxlQmFsYW5jZX0gYXZhaWxhYmxlLmApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlIGlmIHRoZSBvcGVyYXRpb24gaXMgYWJsZSB0byB1bnN0YWtlIHdpdGggdGhlIHN1cHBsaWVkIGlucHV0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGFtb3VudCAtIFRoZSBhbW91bnQgb2YgdGhlIGFzc2V0IHRvIHVuc3Rha2UuXG4gICAgICogQHBhcmFtIGFzc2V0SWQgLSBUaGUgYXNzZXQgdG8gdW5zdGFrZS5cbiAgICAgKiBAcGFyYW0gbW9kZSAtIFRoZSBzdGFraW5nIG1vZGUuIERlZmF1bHRzIHRvIERFRkFVTFQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBBZGRpdGlvbmFsIG9wdGlvbnMgZm9yIHRoZSB1bnN0YWtlIG9wZXJhdGlvbi5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgc3VwcGxpZWQgaW5wdXQgaXMgbm90IGFibGUgdG8gY3JlYXRlIGFuIHVuc3Rha2Ugb3BlcmF0aW9uLlxuICAgICAqL1xuICAgIGFzeW5jIHZhbGlkYXRlQ2FuVW5zdGFrZShhbW91bnQsIGFzc2V0SWQsIG1vZGUsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgdW5zdGFrZWFibGVCYWxhbmNlID0gbmV3IGRlY2ltYWxfanNfMS5kZWZhdWx0KGF3YWl0IHRoaXMudW5zdGFrZWFibGVCYWxhbmNlKGFzc2V0SWQsIG1vZGUsIG9wdGlvbnMpKTtcbiAgICAgICAgaWYgKHVuc3Rha2VhYmxlQmFsYW5jZS5sZXNzVGhhbihhbW91bnQudG9TdHJpbmcoKSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW5zdWZmaWNpZW50IGZ1bmRzICR7YW1vdW50fSByZXF1ZXN0ZWQgdG8gdW5zdGFrZSwgb25seSAke3Vuc3Rha2VhYmxlQmFsYW5jZX0gYXZhaWxhYmxlLmApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlIGlmIHRoZSBvcGVyYXRpb24gaXMgYWJsZSB0byBjbGFpbSBzdGFrZSB3aXRoIHRoZSBzdXBwbGllZCBpbnB1dC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhbW91bnQgLSBUaGUgYW1vdW50IG9mIHRoZSBhc3NldCB0byBjbGFpbSBzdGFrZS5cbiAgICAgKiBAcGFyYW0gYXNzZXRJZCAtIFRoZSBhc3NldCB0byBjbGFpbSBzdGFrZS5cbiAgICAgKiBAcGFyYW0gbW9kZSAtIFRoZSBzdGFraW5nIG1vZGUuIERlZmF1bHRzIHRvIERFRkFVTFQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBBZGRpdGlvbmFsIG9wdGlvbnMgZm9yIHRoZSBjbGFpbSBzdGFrZSBvcGVyYXRpb24uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHN1cHBsaWVkIGlucHV0IGlzIG5vdCBhYmxlIHRvIGNyZWF0ZSBhIGNsYWltIHN0YWtlIG9wZXJhdGlvbi5cbiAgICAgKi9cbiAgICBhc3luYyB2YWxpZGF0ZUNhbkNsYWltU3Rha2UoYW1vdW50LCBhc3NldElkLCBtb2RlLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChhc3NldElkID09PSBcImV0aFwiICYmIG1vZGUgPT09IHR5cGVzXzEuU3Rha2VPcHRpb25zTW9kZS5OQVRJVkUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2xhaW1pbmcgc3Rha2UgZm9yIEVUSCBpcyBub3Qgc3VwcG9ydGVkIGluIG5hdGl2ZSBtb2RlLmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNsYWltYWJsZUJhbGFuY2UgPSBuZXcgZGVjaW1hbF9qc18xLmRlZmF1bHQoYXdhaXQgdGhpcy5jbGFpbWFibGVCYWxhbmNlKGFzc2V0SWQsIG1vZGUsIG9wdGlvbnMpKTtcbiAgICAgICAgaWYgKGNsYWltYWJsZUJhbGFuY2UubGVzc1RoYW4oYW1vdW50LnRvU3RyaW5nKCkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEluc3VmZmljaWVudCBmdW5kcyAke2Ftb3VudH0gcmVxdWVzdGVkIHRvIGNsYWltIHN0YWtlLCBvbmx5ICR7Y2xhaW1hYmxlQmFsYW5jZX0gYXZhaWxhYmxlLmApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHNoYWxsb3cgY29weSBvZiBnaXZlbiBvcHRpb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgc3VwcGxpZWQgb3B0aW9ucyB0byBiZSBjb3BpZWRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm5zIEEgY29weSBvZiB0aGUgb3B0aW9ucy5cbiAgICAgKi9cbiAgICBjb3B5T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB7IC4uLm9wdGlvbnMgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBkaWZmZXJlbnQgc3Rha2luZyBiYWxhbmNlIHR5cGVzIGZvciB0aGUgc3VwcGxpZWQgYXNzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXNzZXRJZCAtIFRoZSBhc3NldCB0byBsb29rdXAgYmFsYW5jZXMgZm9yLlxuICAgICAqIEBwYXJhbSBtb2RlIC0gVGhlIHN0YWtpbmcgbW9kZS4gRGVmYXVsdHMgdG8gREVGQVVMVC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFkZGl0aW9uYWwgb3B0aW9ucyBmb3IgdGhlIGJhbGFuY2UgbG9va3VwLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnMgVGhlIGRpZmZlcmVudCBiYWxhbmNlIHR5cGVzLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFN0YWtpbmdCYWxhbmNlcyhhc3NldElkLCBtb2RlLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IG5ld09wdGlvbnMgPSB0aGlzLmNvcHlPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICBpZiAobW9kZSkge1xuICAgICAgICAgICAgbmV3T3B0aW9ucy5tb2RlID0gbW9kZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgbmV0d29ya19pZDogdGhpcy5nZXROZXR3b3JrSWQoKSxcbiAgICAgICAgICAgIGFzc2V0X2lkOiBhc3NldF8xLkFzc2V0LnByaW1hcnlEZW5vbWluYXRpb24oYXNzZXRJZCksXG4gICAgICAgICAgICBhZGRyZXNzX2lkOiB0aGlzLmdldElkKCksXG4gICAgICAgICAgICBvcHRpb25zOiBuZXdPcHRpb25zLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNvaW5iYXNlXzEuQ29pbmJhc2UuYXBpQ2xpZW50cy5zdGFrZS5nZXRTdGFraW5nQ29udGV4dChyZXF1ZXN0KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0YWtlYWJsZUJhbGFuY2U6IGJhbGFuY2VfMS5CYWxhbmNlLmZyb21Nb2RlbEFuZEFzc2V0SWQocmVzcG9uc2UuZGF0YS5jb250ZXh0LnN0YWtlYWJsZV9iYWxhbmNlLCBhc3NldElkKS5hbW91bnQsXG4gICAgICAgICAgICB1bnN0YWtlYWJsZUJhbGFuY2U6IGJhbGFuY2VfMS5CYWxhbmNlLmZyb21Nb2RlbEFuZEFzc2V0SWQocmVzcG9uc2UuZGF0YS5jb250ZXh0LnVuc3Rha2VhYmxlX2JhbGFuY2UsIGFzc2V0SWQpLmFtb3VudCxcbiAgICAgICAgICAgIHBlbmRpbmdDbGFpbWFibGVCYWxhbmNlOiBiYWxhbmNlXzEuQmFsYW5jZS5mcm9tTW9kZWxBbmRBc3NldElkKHJlc3BvbnNlLmRhdGEuY29udGV4dC5wZW5kaW5nX2NsYWltYWJsZV9iYWxhbmNlLCBhc3NldElkKS5hbW91bnQsXG4gICAgICAgICAgICBjbGFpbWFibGVCYWxhbmNlOiBiYWxhbmNlXzEuQmFsYW5jZS5mcm9tTW9kZWxBbmRBc3NldElkKHJlc3BvbnNlLmRhdGEuY29udGV4dC5jbGFpbWFibGVfYmFsYW5jZSwgYXNzZXRJZCkuYW1vdW50LFxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuQWRkcmVzcyA9IEFkZHJlc3M7XG5BZGRyZXNzLk1BWF9ISVNUT1JJQ0FMX0JBTEFOQ0UgPSAxMDAwO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/address.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/address/external_address.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/address/external_address.js ***!
  \***************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ExternalAddress = void 0;\nconst address_1 = __webpack_require__(/*! ../address */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/address.js\");\nconst types_1 = __webpack_require__(/*! ../types */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/types.js\");\nconst coinbase_1 = __webpack_require__(/*! ../coinbase */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/coinbase.js\");\nconst decimal_js_1 = __importDefault(__webpack_require__(/*! decimal.js */ \"(rsc)/./node_modules/decimal.js/decimal.js\"));\nconst asset_1 = __webpack_require__(/*! ../asset */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/asset.js\");\nconst staking_operation_1 = __webpack_require__(/*! ../staking_operation */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/staking_operation.js\");\n/**\n * A representation of a blockchain Address, which is a user-controlled account on a Network. Addresses are used to\n * send and receive Assets. An ExternalAddress is an Address that is not controlled by the developer, but is instead\n * controlled by the user.\n */\nclass ExternalAddress extends address_1.Address {\n    /**\n     * Builds a stake operation for the supplied asset. The stake operation\n     * may take a few minutes to complete in the case when infrastructure is spun up.\n     *\n     * @param amount - The amount of the asset to stake.\n     * @param assetId - The asset to stake.\n     * @param mode - The staking mode. Defaults to DEFAULT.\n     * @param options - Additional options for the stake operation:\n     *\n     * A. Shared ETH Staking\n     *  - `integrator_contract_address` (optional): The contract address to which the stake operation is directed to. Defaults to the integrator contract address associated with CDP account (if available) or else defaults to a shared integrator contract address for that network.\n     *\n     * B. Dedicated ETH Staking\n     *  - `funding_address` (optional): Ethereum address for funding the stake operation. Defaults to the address initiating the stake operation.\n     *  - `withdrawal_address` (optional): Ethereum address for receiving rewards and withdrawal funds. Defaults to the address initiating the stake operation.\n     *  - `fee_recipient_address` (optional): Ethereum address for receiving transaction fees. Defaults to the address initiating the stake operation.\n     *\n     * @returns The stake operation.\n     */\n    async buildStakeOperation(amount, assetId, mode = types_1.StakeOptionsMode.DEFAULT, options = {}) {\n        await this.validateCanStake(amount, assetId, mode, options);\n        return this.buildStakingOperation(amount, assetId, \"stake\", mode, options);\n    }\n    /**\n     * Builds an unstake operation for the supplied asset.\n     *\n     * @param amount - The amount of the asset to unstake.\n     * @param assetId - The asset to unstake.\n     * @param mode - The staking mode. Defaults to DEFAULT.\n     * @param options - Additional options for the unstake operation:\n     *\n     * A. Shared ETH Staking\n     *  - `integrator_contract_address` (optional): The contract address to which the unstake operation is directed to. Defaults to the integrator contract address associated with CDP account (if available) or else defaults to a shared integrator contract address for that network.\n     *\n     * B. Dedicated ETH Staking\n     *  - `immediate` (optional): Set this to \"true\" to unstake immediately i.e. leverage \"Coinbase managed unstake\" process . Defaults to \"false\" i.e. \"User managed unstake\" process.\n     *  - `validator_pub_keys` (optional): List of comma separated validator public keys to unstake. Defaults to validators being picked up on your behalf corresponding to the unstake amount.\n     *\n     * @returns The unstake operation.\n     */\n    async buildUnstakeOperation(amount, assetId, mode = types_1.StakeOptionsMode.DEFAULT, options = {}) {\n        await this.validateCanUnstake(amount, assetId, mode, options);\n        return this.buildStakingOperation(amount, assetId, \"unstake\", mode, options);\n    }\n    /**\n     * Builds a claim stake operation for the supplied asset.\n     *\n     * @param amount - The amount of the asset to claim stake.\n     * @param assetId - The asset to claim stake.\n     * @param mode - The staking mode. Defaults to DEFAULT.\n     * @param options - Additional options for the claim stake operation.\n     *\n     * A. Shared ETH Staking\n     *  - `integrator_contract_address` (optional): The contract address to which the claim stake operation is directed to. Defaults to the integrator contract address associated with CDP account (if available) or else defaults to a shared integrator contract address for that network.\n     *\n     * @returns The claim stake operation.\n     */\n    async buildClaimStakeOperation(amount, assetId, mode = types_1.StakeOptionsMode.DEFAULT, options = {}) {\n        await this.validateCanClaimStake(amount, assetId, mode, options);\n        return this.buildStakingOperation(amount, assetId, \"claim_stake\", mode, options);\n    }\n    /**\n     * Builds the staking operation based on the supplied input.\n     *\n     * @param amount - The amount for the staking operation.\n     * @param assetId - The asset for the staking operation.\n     * @param action - The specific action for the staking operation. e.g. stake, unstake, claim_stake\n     * @param mode - The staking mode. Defaults to DEFAULT.\n     * @param options - Additional options to build a stake operation.\n     * @private\n     * @returns The staking operation.\n     * @throws {Error} If the supplied input cannot build a valid staking operation.\n     */\n    async buildStakingOperation(amount, assetId, action, mode, options) {\n        const stakingAmount = new decimal_js_1.default(amount.toString());\n        if (stakingAmount.lessThanOrEqualTo(0)) {\n            throw new Error(`Amount required greater than zero.`);\n        }\n        const asset = await asset_1.Asset.fetch(this.getNetworkId(), assetId);\n        const newOptions = this.copyOptions(options);\n        newOptions.mode = mode;\n        newOptions.amount = asset.toAtomicAmount(new decimal_js_1.default(amount.toString())).toString();\n        const request = {\n            network_id: this.getNetworkId(),\n            asset_id: asset_1.Asset.primaryDenomination(assetId),\n            address_id: this.getId(),\n            action: action,\n            options: newOptions,\n        };\n        const response = await coinbase_1.Coinbase.apiClients.stake.buildStakingOperation(request);\n        return new staking_operation_1.StakingOperation(response.data);\n    }\n    /**\n     * Broadcast an external transaction\n     *\n     * @param signedPayload - The signed payload of the transaction to broadcast\n     * @returns The broadcasted transaction\n     */\n    async broadcastExternalTransaction(signedPayload) {\n        const response = await coinbase_1.Coinbase.apiClients.externalAddress.broadcastExternalTransaction(this.getNetworkId(), this.getId(), {\n            signed_payload: signedPayload,\n        });\n        return {\n            transactionHash: response.data.transaction_hash,\n            transactionLink: response.data.transaction_link,\n        };\n    }\n}\nexports.ExternalAddress = ExternalAddress;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL2FkZHJlc3MvZXh0ZXJuYWxfYWRkcmVzcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHVCQUF1QjtBQUN2QixrQkFBa0IsbUJBQU8sQ0FBQyx3RkFBWTtBQUN0QyxnQkFBZ0IsbUJBQU8sQ0FBQyxvRkFBVTtBQUNsQyxtQkFBbUIsbUJBQU8sQ0FBQywwRkFBYTtBQUN4QyxxQ0FBcUMsbUJBQU8sQ0FBQyw4REFBWTtBQUN6RCxnQkFBZ0IsbUJBQU8sQ0FBQyxvRkFBVTtBQUNsQyw0QkFBNEIsbUJBQU8sQ0FBQyw0R0FBc0I7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvR0FBb0c7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRztBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlHQUF5RztBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3Vydml2YWwtZnVuLy4vbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9jb2luYmFzZS1zZGsvZGlzdC9jb2luYmFzZS9hZGRyZXNzL2V4dGVybmFsX2FkZHJlc3MuanM/ZjRkNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRXh0ZXJuYWxBZGRyZXNzID0gdm9pZCAwO1xuY29uc3QgYWRkcmVzc18xID0gcmVxdWlyZShcIi4uL2FkZHJlc3NcIik7XG5jb25zdCB0eXBlc18xID0gcmVxdWlyZShcIi4uL3R5cGVzXCIpO1xuY29uc3QgY29pbmJhc2VfMSA9IHJlcXVpcmUoXCIuLi9jb2luYmFzZVwiKTtcbmNvbnN0IGRlY2ltYWxfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZGVjaW1hbC5qc1wiKSk7XG5jb25zdCBhc3NldF8xID0gcmVxdWlyZShcIi4uL2Fzc2V0XCIpO1xuY29uc3Qgc3Rha2luZ19vcGVyYXRpb25fMSA9IHJlcXVpcmUoXCIuLi9zdGFraW5nX29wZXJhdGlvblwiKTtcbi8qKlxuICogQSByZXByZXNlbnRhdGlvbiBvZiBhIGJsb2NrY2hhaW4gQWRkcmVzcywgd2hpY2ggaXMgYSB1c2VyLWNvbnRyb2xsZWQgYWNjb3VudCBvbiBhIE5ldHdvcmsuIEFkZHJlc3NlcyBhcmUgdXNlZCB0b1xuICogc2VuZCBhbmQgcmVjZWl2ZSBBc3NldHMuIEFuIEV4dGVybmFsQWRkcmVzcyBpcyBhbiBBZGRyZXNzIHRoYXQgaXMgbm90IGNvbnRyb2xsZWQgYnkgdGhlIGRldmVsb3BlciwgYnV0IGlzIGluc3RlYWRcbiAqIGNvbnRyb2xsZWQgYnkgdGhlIHVzZXIuXG4gKi9cbmNsYXNzIEV4dGVybmFsQWRkcmVzcyBleHRlbmRzIGFkZHJlc3NfMS5BZGRyZXNzIHtcbiAgICAvKipcbiAgICAgKiBCdWlsZHMgYSBzdGFrZSBvcGVyYXRpb24gZm9yIHRoZSBzdXBwbGllZCBhc3NldC4gVGhlIHN0YWtlIG9wZXJhdGlvblxuICAgICAqIG1heSB0YWtlIGEgZmV3IG1pbnV0ZXMgdG8gY29tcGxldGUgaW4gdGhlIGNhc2Ugd2hlbiBpbmZyYXN0cnVjdHVyZSBpcyBzcHVuIHVwLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFtb3VudCAtIFRoZSBhbW91bnQgb2YgdGhlIGFzc2V0IHRvIHN0YWtlLlxuICAgICAqIEBwYXJhbSBhc3NldElkIC0gVGhlIGFzc2V0IHRvIHN0YWtlLlxuICAgICAqIEBwYXJhbSBtb2RlIC0gVGhlIHN0YWtpbmcgbW9kZS4gRGVmYXVsdHMgdG8gREVGQVVMVC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFkZGl0aW9uYWwgb3B0aW9ucyBmb3IgdGhlIHN0YWtlIG9wZXJhdGlvbjpcbiAgICAgKlxuICAgICAqIEEuIFNoYXJlZCBFVEggU3Rha2luZ1xuICAgICAqICAtIGBpbnRlZ3JhdG9yX2NvbnRyYWN0X2FkZHJlc3NgIChvcHRpb25hbCk6IFRoZSBjb250cmFjdCBhZGRyZXNzIHRvIHdoaWNoIHRoZSBzdGFrZSBvcGVyYXRpb24gaXMgZGlyZWN0ZWQgdG8uIERlZmF1bHRzIHRvIHRoZSBpbnRlZ3JhdG9yIGNvbnRyYWN0IGFkZHJlc3MgYXNzb2NpYXRlZCB3aXRoIENEUCBhY2NvdW50IChpZiBhdmFpbGFibGUpIG9yIGVsc2UgZGVmYXVsdHMgdG8gYSBzaGFyZWQgaW50ZWdyYXRvciBjb250cmFjdCBhZGRyZXNzIGZvciB0aGF0IG5ldHdvcmsuXG4gICAgICpcbiAgICAgKiBCLiBEZWRpY2F0ZWQgRVRIIFN0YWtpbmdcbiAgICAgKiAgLSBgZnVuZGluZ19hZGRyZXNzYCAob3B0aW9uYWwpOiBFdGhlcmV1bSBhZGRyZXNzIGZvciBmdW5kaW5nIHRoZSBzdGFrZSBvcGVyYXRpb24uIERlZmF1bHRzIHRvIHRoZSBhZGRyZXNzIGluaXRpYXRpbmcgdGhlIHN0YWtlIG9wZXJhdGlvbi5cbiAgICAgKiAgLSBgd2l0aGRyYXdhbF9hZGRyZXNzYCAob3B0aW9uYWwpOiBFdGhlcmV1bSBhZGRyZXNzIGZvciByZWNlaXZpbmcgcmV3YXJkcyBhbmQgd2l0aGRyYXdhbCBmdW5kcy4gRGVmYXVsdHMgdG8gdGhlIGFkZHJlc3MgaW5pdGlhdGluZyB0aGUgc3Rha2Ugb3BlcmF0aW9uLlxuICAgICAqICAtIGBmZWVfcmVjaXBpZW50X2FkZHJlc3NgIChvcHRpb25hbCk6IEV0aGVyZXVtIGFkZHJlc3MgZm9yIHJlY2VpdmluZyB0cmFuc2FjdGlvbiBmZWVzLiBEZWZhdWx0cyB0byB0aGUgYWRkcmVzcyBpbml0aWF0aW5nIHRoZSBzdGFrZSBvcGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgc3Rha2Ugb3BlcmF0aW9uLlxuICAgICAqL1xuICAgIGFzeW5jIGJ1aWxkU3Rha2VPcGVyYXRpb24oYW1vdW50LCBhc3NldElkLCBtb2RlID0gdHlwZXNfMS5TdGFrZU9wdGlvbnNNb2RlLkRFRkFVTFQsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLnZhbGlkYXRlQ2FuU3Rha2UoYW1vdW50LCBhc3NldElkLCBtb2RlLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVpbGRTdGFraW5nT3BlcmF0aW9uKGFtb3VudCwgYXNzZXRJZCwgXCJzdGFrZVwiLCBtb2RlLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQnVpbGRzIGFuIHVuc3Rha2Ugb3BlcmF0aW9uIGZvciB0aGUgc3VwcGxpZWQgYXNzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYW1vdW50IC0gVGhlIGFtb3VudCBvZiB0aGUgYXNzZXQgdG8gdW5zdGFrZS5cbiAgICAgKiBAcGFyYW0gYXNzZXRJZCAtIFRoZSBhc3NldCB0byB1bnN0YWtlLlxuICAgICAqIEBwYXJhbSBtb2RlIC0gVGhlIHN0YWtpbmcgbW9kZS4gRGVmYXVsdHMgdG8gREVGQVVMVC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFkZGl0aW9uYWwgb3B0aW9ucyBmb3IgdGhlIHVuc3Rha2Ugb3BlcmF0aW9uOlxuICAgICAqXG4gICAgICogQS4gU2hhcmVkIEVUSCBTdGFraW5nXG4gICAgICogIC0gYGludGVncmF0b3JfY29udHJhY3RfYWRkcmVzc2AgKG9wdGlvbmFsKTogVGhlIGNvbnRyYWN0IGFkZHJlc3MgdG8gd2hpY2ggdGhlIHVuc3Rha2Ugb3BlcmF0aW9uIGlzIGRpcmVjdGVkIHRvLiBEZWZhdWx0cyB0byB0aGUgaW50ZWdyYXRvciBjb250cmFjdCBhZGRyZXNzIGFzc29jaWF0ZWQgd2l0aCBDRFAgYWNjb3VudCAoaWYgYXZhaWxhYmxlKSBvciBlbHNlIGRlZmF1bHRzIHRvIGEgc2hhcmVkIGludGVncmF0b3IgY29udHJhY3QgYWRkcmVzcyBmb3IgdGhhdCBuZXR3b3JrLlxuICAgICAqXG4gICAgICogQi4gRGVkaWNhdGVkIEVUSCBTdGFraW5nXG4gICAgICogIC0gYGltbWVkaWF0ZWAgKG9wdGlvbmFsKTogU2V0IHRoaXMgdG8gXCJ0cnVlXCIgdG8gdW5zdGFrZSBpbW1lZGlhdGVseSBpLmUuIGxldmVyYWdlIFwiQ29pbmJhc2UgbWFuYWdlZCB1bnN0YWtlXCIgcHJvY2VzcyAuIERlZmF1bHRzIHRvIFwiZmFsc2VcIiBpLmUuIFwiVXNlciBtYW5hZ2VkIHVuc3Rha2VcIiBwcm9jZXNzLlxuICAgICAqICAtIGB2YWxpZGF0b3JfcHViX2tleXNgIChvcHRpb25hbCk6IExpc3Qgb2YgY29tbWEgc2VwYXJhdGVkIHZhbGlkYXRvciBwdWJsaWMga2V5cyB0byB1bnN0YWtlLiBEZWZhdWx0cyB0byB2YWxpZGF0b3JzIGJlaW5nIHBpY2tlZCB1cCBvbiB5b3VyIGJlaGFsZiBjb3JyZXNwb25kaW5nIHRvIHRoZSB1bnN0YWtlIGFtb3VudC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSB1bnN0YWtlIG9wZXJhdGlvbi5cbiAgICAgKi9cbiAgICBhc3luYyBidWlsZFVuc3Rha2VPcGVyYXRpb24oYW1vdW50LCBhc3NldElkLCBtb2RlID0gdHlwZXNfMS5TdGFrZU9wdGlvbnNNb2RlLkRFRkFVTFQsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLnZhbGlkYXRlQ2FuVW5zdGFrZShhbW91bnQsIGFzc2V0SWQsIG1vZGUsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdGhpcy5idWlsZFN0YWtpbmdPcGVyYXRpb24oYW1vdW50LCBhc3NldElkLCBcInVuc3Rha2VcIiwgbW9kZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJ1aWxkcyBhIGNsYWltIHN0YWtlIG9wZXJhdGlvbiBmb3IgdGhlIHN1cHBsaWVkIGFzc2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGFtb3VudCAtIFRoZSBhbW91bnQgb2YgdGhlIGFzc2V0IHRvIGNsYWltIHN0YWtlLlxuICAgICAqIEBwYXJhbSBhc3NldElkIC0gVGhlIGFzc2V0IHRvIGNsYWltIHN0YWtlLlxuICAgICAqIEBwYXJhbSBtb2RlIC0gVGhlIHN0YWtpbmcgbW9kZS4gRGVmYXVsdHMgdG8gREVGQVVMVC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFkZGl0aW9uYWwgb3B0aW9ucyBmb3IgdGhlIGNsYWltIHN0YWtlIG9wZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEEuIFNoYXJlZCBFVEggU3Rha2luZ1xuICAgICAqICAtIGBpbnRlZ3JhdG9yX2NvbnRyYWN0X2FkZHJlc3NgIChvcHRpb25hbCk6IFRoZSBjb250cmFjdCBhZGRyZXNzIHRvIHdoaWNoIHRoZSBjbGFpbSBzdGFrZSBvcGVyYXRpb24gaXMgZGlyZWN0ZWQgdG8uIERlZmF1bHRzIHRvIHRoZSBpbnRlZ3JhdG9yIGNvbnRyYWN0IGFkZHJlc3MgYXNzb2NpYXRlZCB3aXRoIENEUCBhY2NvdW50IChpZiBhdmFpbGFibGUpIG9yIGVsc2UgZGVmYXVsdHMgdG8gYSBzaGFyZWQgaW50ZWdyYXRvciBjb250cmFjdCBhZGRyZXNzIGZvciB0aGF0IG5ldHdvcmsuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgY2xhaW0gc3Rha2Ugb3BlcmF0aW9uLlxuICAgICAqL1xuICAgIGFzeW5jIGJ1aWxkQ2xhaW1TdGFrZU9wZXJhdGlvbihhbW91bnQsIGFzc2V0SWQsIG1vZGUgPSB0eXBlc18xLlN0YWtlT3B0aW9uc01vZGUuREVGQVVMVCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMudmFsaWRhdGVDYW5DbGFpbVN0YWtlKGFtb3VudCwgYXNzZXRJZCwgbW9kZSwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1aWxkU3Rha2luZ09wZXJhdGlvbihhbW91bnQsIGFzc2V0SWQsIFwiY2xhaW1fc3Rha2VcIiwgbW9kZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJ1aWxkcyB0aGUgc3Rha2luZyBvcGVyYXRpb24gYmFzZWQgb24gdGhlIHN1cHBsaWVkIGlucHV0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGFtb3VudCAtIFRoZSBhbW91bnQgZm9yIHRoZSBzdGFraW5nIG9wZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0gYXNzZXRJZCAtIFRoZSBhc3NldCBmb3IgdGhlIHN0YWtpbmcgb3BlcmF0aW9uLlxuICAgICAqIEBwYXJhbSBhY3Rpb24gLSBUaGUgc3BlY2lmaWMgYWN0aW9uIGZvciB0aGUgc3Rha2luZyBvcGVyYXRpb24uIGUuZy4gc3Rha2UsIHVuc3Rha2UsIGNsYWltX3N0YWtlXG4gICAgICogQHBhcmFtIG1vZGUgLSBUaGUgc3Rha2luZyBtb2RlLiBEZWZhdWx0cyB0byBERUZBVUxULlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gQWRkaXRpb25hbCBvcHRpb25zIHRvIGJ1aWxkIGEgc3Rha2Ugb3BlcmF0aW9uLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnMgVGhlIHN0YWtpbmcgb3BlcmF0aW9uLlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgc3VwcGxpZWQgaW5wdXQgY2Fubm90IGJ1aWxkIGEgdmFsaWQgc3Rha2luZyBvcGVyYXRpb24uXG4gICAgICovXG4gICAgYXN5bmMgYnVpbGRTdGFraW5nT3BlcmF0aW9uKGFtb3VudCwgYXNzZXRJZCwgYWN0aW9uLCBtb2RlLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHN0YWtpbmdBbW91bnQgPSBuZXcgZGVjaW1hbF9qc18xLmRlZmF1bHQoYW1vdW50LnRvU3RyaW5nKCkpO1xuICAgICAgICBpZiAoc3Rha2luZ0Ftb3VudC5sZXNzVGhhbk9yRXF1YWxUbygwKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBbW91bnQgcmVxdWlyZWQgZ3JlYXRlciB0aGFuIHplcm8uYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXNzZXQgPSBhd2FpdCBhc3NldF8xLkFzc2V0LmZldGNoKHRoaXMuZ2V0TmV0d29ya0lkKCksIGFzc2V0SWQpO1xuICAgICAgICBjb25zdCBuZXdPcHRpb25zID0gdGhpcy5jb3B5T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgbmV3T3B0aW9ucy5tb2RlID0gbW9kZTtcbiAgICAgICAgbmV3T3B0aW9ucy5hbW91bnQgPSBhc3NldC50b0F0b21pY0Ftb3VudChuZXcgZGVjaW1hbF9qc18xLmRlZmF1bHQoYW1vdW50LnRvU3RyaW5nKCkpKS50b1N0cmluZygpO1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgbmV0d29ya19pZDogdGhpcy5nZXROZXR3b3JrSWQoKSxcbiAgICAgICAgICAgIGFzc2V0X2lkOiBhc3NldF8xLkFzc2V0LnByaW1hcnlEZW5vbWluYXRpb24oYXNzZXRJZCksXG4gICAgICAgICAgICBhZGRyZXNzX2lkOiB0aGlzLmdldElkKCksXG4gICAgICAgICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgICAgICAgIG9wdGlvbnM6IG5ld09wdGlvbnMsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY29pbmJhc2VfMS5Db2luYmFzZS5hcGlDbGllbnRzLnN0YWtlLmJ1aWxkU3Rha2luZ09wZXJhdGlvbihyZXF1ZXN0KTtcbiAgICAgICAgcmV0dXJuIG5ldyBzdGFraW5nX29wZXJhdGlvbl8xLlN0YWtpbmdPcGVyYXRpb24ocmVzcG9uc2UuZGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJyb2FkY2FzdCBhbiBleHRlcm5hbCB0cmFuc2FjdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIHNpZ25lZFBheWxvYWQgLSBUaGUgc2lnbmVkIHBheWxvYWQgb2YgdGhlIHRyYW5zYWN0aW9uIHRvIGJyb2FkY2FzdFxuICAgICAqIEByZXR1cm5zIFRoZSBicm9hZGNhc3RlZCB0cmFuc2FjdGlvblxuICAgICAqL1xuICAgIGFzeW5jIGJyb2FkY2FzdEV4dGVybmFsVHJhbnNhY3Rpb24oc2lnbmVkUGF5bG9hZCkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNvaW5iYXNlXzEuQ29pbmJhc2UuYXBpQ2xpZW50cy5leHRlcm5hbEFkZHJlc3MuYnJvYWRjYXN0RXh0ZXJuYWxUcmFuc2FjdGlvbih0aGlzLmdldE5ldHdvcmtJZCgpLCB0aGlzLmdldElkKCksIHtcbiAgICAgICAgICAgIHNpZ25lZF9wYXlsb2FkOiBzaWduZWRQYXlsb2FkLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uSGFzaDogcmVzcG9uc2UuZGF0YS50cmFuc2FjdGlvbl9oYXNoLFxuICAgICAgICAgICAgdHJhbnNhY3Rpb25MaW5rOiByZXNwb25zZS5kYXRhLnRyYW5zYWN0aW9uX2xpbmssXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5FeHRlcm5hbEFkZHJlc3MgPSBFeHRlcm5hbEFkZHJlc3M7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/address/external_address.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/address/wallet_address.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/address/wallet_address.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.WalletAddress = void 0;\nconst decimal_js_1 = __webpack_require__(/*! decimal.js */ \"(rsc)/./node_modules/decimal.js/decimal.js\");\nconst ethers_1 = __webpack_require__(/*! ethers */ \"(rsc)/./node_modules/ethers/lib.commonjs/index.js\");\nconst client_1 = __webpack_require__(/*! ../../client */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/client/index.js\");\nconst address_1 = __webpack_require__(/*! ../address */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/address.js\");\nconst asset_1 = __webpack_require__(/*! ../asset */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/asset.js\");\nconst coinbase_1 = __webpack_require__(/*! ../coinbase */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/coinbase.js\");\nconst errors_1 = __webpack_require__(/*! ../errors */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/errors.js\");\nconst trade_1 = __webpack_require__(/*! ../trade */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/trade.js\");\nconst transfer_1 = __webpack_require__(/*! ../transfer */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/transfer.js\");\nconst contract_invocation_1 = __webpack_require__(/*! ../contract_invocation */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/contract_invocation.js\");\nconst types_1 = __webpack_require__(/*! ../types */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/types.js\");\nconst utils_1 = __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/utils.js\");\nconst wallet_1 = __webpack_require__(/*! ../wallet */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/wallet.js\");\nconst staking_operation_1 = __webpack_require__(/*! ../staking_operation */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/staking_operation.js\");\nconst payload_signature_1 = __webpack_require__(/*! ../payload_signature */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/payload_signature.js\");\nconst smart_contract_1 = __webpack_require__(/*! ../smart_contract */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/smart_contract.js\");\nconst fund_operation_1 = __webpack_require__(/*! ../fund_operation */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/fund_operation.js\");\nconst fund_quote_1 = __webpack_require__(/*! ../fund_quote */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/fund_quote.js\");\n/**\n * A representation of a blockchain address, which is a wallet-controlled account on a network.\n */\nclass WalletAddress extends address_1.Address {\n    /**\n     * Initializes a new Wallet Address instance.\n     *\n     * @param model - The address model data.\n     * @param key - The ethers.js SigningKey the Address uses to sign data.\n     * @throws {Error} If the address model is empty.\n     */\n    constructor(model, key) {\n        if (!model) {\n            throw new Error(\"Address model cannot be empty\");\n        }\n        super(model.network_id, model.address_id);\n        this.model = model;\n        this.key = key;\n    }\n    /**\n     * Returns a string representation of the wallet address.\n     *\n     * @returns A string representing the wallet address.\n     */\n    toString() {\n        return `WalletAddress{ addressId: '${this.getId()}', networkId: '${this.getNetworkId()}', walletId: '${this.getWalletId()}' }`;\n    }\n    /**\n     * Returns the wallet ID.\n     *\n     * @returns The wallet ID.\n     */\n    getWalletId() {\n        return this.model.wallet_id;\n    }\n    /**\n     * Sets the private key.\n     *\n     * @param key - The ethers.js SigningKey the Address uses to sign data.\n     * @throws {Error} If the private key is already set.\n     */\n    setKey(key) {\n        if (this.key !== undefined) {\n            throw new Error(\"Private key is already set\");\n        }\n        this.key = key;\n    }\n    /**\n     * Exports the Address's private key to a hex string.\n     *\n     * @returns The Address's private key as a hex string.\n     */\n    export() {\n        if (this.key === undefined) {\n            throw new Error(\"Private key is not set\");\n        }\n        return this.key.privateKey;\n    }\n    /**\n     * Returns whether the Address has a private key backing it to sign transactions.\n     *\n     * @returns Whether the Address has a private key backing it to sign transactions.\n     */\n    canSign() {\n        return !!this.key;\n    }\n    /**\n     * Returns all the trades associated with the address.\n     *\n     * @param options - The pagination options.\n     * @param options.limit - The maximum number of Trades to return. Limit can range between 1 and 100.\n     * @param options.page - The cursor for pagination across multiple pages of Trades. Don\\&#39;t include this parameter on the first call. Use the next page value returned in a previous response to request subsequent results.\n     *\n     * @returns The paginated list response of trades.\n     */\n    async listTrades({ limit = coinbase_1.Coinbase.defaultPageLimit, page = undefined, } = {}) {\n        const data = [];\n        let nextPage;\n        const response = await coinbase_1.Coinbase.apiClients.trade.listTrades(this.model.wallet_id, this.model.address_id, limit, page);\n        response.data.data.forEach(tradeModel => {\n            data.push(new trade_1.Trade(tradeModel));\n        });\n        const hasMore = response.data.has_more;\n        if (hasMore) {\n            if (response.data.next_page) {\n                nextPage = response.data.next_page;\n            }\n        }\n        return {\n            data,\n            hasMore,\n            nextPage,\n        };\n    }\n    /**\n     * Returns all the transfers associated with the address.\n     *\n     * @param options - The pagination options.\n     * @param options.limit - The maximum number of Transfers to return. Limit can range between 1 and 100.\n     * @param options.page - The cursor for pagination across multiple pages of Transfers. Don\\&#39;t include this parameter on the first call. Use the next page value returned in a previous response to request subsequent results.\n     *\n     * @returns The paginated list response of transfers.\n     */\n    async listTransfers({ limit = coinbase_1.Coinbase.defaultPageLimit, page = undefined, } = {}) {\n        const data = [];\n        let nextPage;\n        const response = await coinbase_1.Coinbase.apiClients.transfer.listTransfers(this.model.wallet_id, this.model.address_id, limit, page);\n        response.data.data.forEach(transferModel => {\n            data.push(transfer_1.Transfer.fromModel(transferModel));\n        });\n        const hasMore = response.data.has_more;\n        if (hasMore) {\n            if (response.data.next_page) {\n                nextPage = response.data.next_page;\n            }\n        }\n        return {\n            data,\n            hasMore,\n            nextPage,\n        };\n    }\n    /**\n     * Transfers the given amount of the given Asset to the given address.\n     * Only same-Network Transfers are supported.\n     * This returns a `Transfer` object that has been signed and broadcasted, you\n     * can wait for this to land on-chain (or fail) by calling `transfer.wait()`.\n     *\n     * @param options - The options to create the Transfer.\n     * @param options.amount - The amount of the Asset to send.\n     * @param options.assetId - The ID of the Asset to send. For Ether, Coinbase.assets.Eth, Coinbase.assets.Gwei, and Coinbase.assets.Wei supported.\n     * @param options.destination - The destination of the transfer. If a Wallet, sends to the Wallet's default address. If a String, interprets it as the address ID.\n     * @param options.gasless - Whether the Transfer should be gasless. Defaults to false.\n     * @param options.skipBatching - When true, the Transfer will be submitted immediately. Otherwise, the Transfer will be batched. Defaults to false. Note: requires gasless option to be set to true.\n     * @returns The transfer object.\n     * @throws {APIError} if the API request to create a Transfer fails.\n     * @throws {APIError} if the API request to broadcast a Transfer fails.\n     */\n    async createTransfer({ amount, assetId, destination, gasless = false, skipBatching = false, }) {\n        if (!coinbase_1.Coinbase.useServerSigner && !this.key) {\n            throw new Error(\"Cannot transfer from address without private key loaded\");\n        }\n        const asset = await asset_1.Asset.fetch(this.getNetworkId(), assetId);\n        const [destinationAddress, destinationNetworkId] = await this.getDestinationAddressAndNetwork(destination);\n        const normalizedAmount = new decimal_js_1.Decimal(amount.toString());\n        const currentBalance = await this.getBalance(assetId);\n        if (currentBalance.lessThan(normalizedAmount)) {\n            throw new errors_1.ArgumentError(`Insufficient funds: ${normalizedAmount} requested, but only ${currentBalance} available`);\n        }\n        if (skipBatching && !gasless) {\n            throw new errors_1.ArgumentError(\"skipBatching requires gasless to be true\");\n        }\n        const createTransferRequest = {\n            amount: asset.toAtomicAmount(normalizedAmount).toString(),\n            network_id: destinationNetworkId,\n            asset_id: asset.primaryDenomination(),\n            destination: destinationAddress,\n            gasless: gasless,\n            skip_batching: skipBatching,\n        };\n        const response = await coinbase_1.Coinbase.apiClients.transfer.createTransfer(this.getWalletId(), this.getId(), createTransferRequest);\n        const transfer = transfer_1.Transfer.fromModel(response.data);\n        if (coinbase_1.Coinbase.useServerSigner) {\n            return transfer;\n        }\n        await transfer.sign(this.getSigner());\n        await transfer.broadcast();\n        return transfer;\n    }\n    /**\n     * Gets a signer for the private key.\n     *\n     * @returns The signer for the private key.\n     * @throws {Error} If the private key is not loaded.\n     */\n    getSigner() {\n        if (!this.key) {\n            throw new Error(\"Cannot sign without a private key\");\n        }\n        return new ethers_1.ethers.Wallet(this.key.privateKey);\n    }\n    /**\n     * Trades the given amount of the given Asset for another Asset. Only same-network Trades are supported.\n     *\n     * @param options - The options to create the Trade.\n     * @param options.amount - The amount of the From Asset to send.\n     * @param options.fromAssetId - The ID of the Asset to trade from.\n     * @param options.toAssetId - The ID of the Asset to trade to.\n     * @returns The Trade object.\n     * @throws {APIError} if the API request to create or broadcast a Trade fails.\n     * @throws {Error} if the Trade times out.\n     */\n    async createTrade({ amount, fromAssetId, toAssetId }) {\n        const fromAsset = await asset_1.Asset.fetch(this.getNetworkId(), fromAssetId);\n        const toAsset = await asset_1.Asset.fetch(this.getNetworkId(), toAssetId);\n        await this.validateCanTrade(amount, fromAssetId);\n        const trade = await this.createTradeRequest(amount, fromAsset, toAsset);\n        if (coinbase_1.Coinbase.useServerSigner) {\n            return trade;\n        }\n        await trade.sign(this.getSigner());\n        await trade.broadcast();\n        return trade;\n    }\n    /**\n     * Invokes a contract with the given data.\n     *\n     * @param options - The options to invoke the contract\n     * @param options.contractAddress - The address of the contract the method will be invoked on.\n     * @param options.method - The method to invoke on the contract.\n     * @param options.abi - The ABI of the contract.\n     * @param options.args - The arguments to pass to the contract method invocation.\n     *   The keys should be the argument names and the values should be the argument values.\n     * @param options.amount - The amount of the asset to send to a payable contract method.\n     * @param options.assetId - The ID of the asset to send to a payable contract method.\n     *   The asset must be a denomination of the native asset. (Ex. \"wei\", \"gwei\", or \"eth\").\n     * @returns The ContractInvocation object.\n     * @throws {APIError} if the API request to create a contract invocation fails.\n     * @throws {Error} if the address cannot sign.\n     * @throws {ArgumentError} if the address does not have sufficient balance.\n     */\n    async invokeContract({ contractAddress, method, abi, args, amount, assetId, }) {\n        if (!coinbase_1.Coinbase.useServerSigner && !this.key) {\n            throw new Error(\"Cannot invoke contract from address without private key loaded\");\n        }\n        if (amount && !assetId) {\n            throw new errors_1.ArgumentError(\"Asset ID is required for contract ivocation if an amount is provided\");\n        }\n        let atomicAmount;\n        if (assetId && amount) {\n            const asset = await asset_1.Asset.fetch(this.getNetworkId(), assetId);\n            const normalizedAmount = new decimal_js_1.Decimal(amount.toString());\n            const currentBalance = await this.getBalance(assetId);\n            if (currentBalance.lessThan(normalizedAmount)) {\n                throw new errors_1.ArgumentError(`Insufficient funds: ${normalizedAmount} requested, but only ${currentBalance} available`);\n            }\n            atomicAmount = asset.toAtomicAmount(normalizedAmount).toString();\n        }\n        const contractInvocation = await this.createContractInvocation(contractAddress, method, abi, args, atomicAmount);\n        if (coinbase_1.Coinbase.useServerSigner) {\n            return contractInvocation;\n        }\n        await contractInvocation.sign(this.getSigner());\n        await contractInvocation.broadcast();\n        return contractInvocation;\n    }\n    /**\n     * Deploys an ERC20 token contract.\n     *\n     * @param options - The options for creating the ERC20 token.\n     * @param options.name - The name of the ERC20 token.\n     * @param options.symbol - The symbol of the ERC20 token.\n     * @param options.totalSupply - The total supply of the ERC20 token.\n     * @returns A Promise that resolves to the deployed SmartContract object.\n     * @throws {APIError} If the API request to create a smart contract fails.\n     */\n    async deployToken({ name, symbol, totalSupply, }) {\n        if (!coinbase_1.Coinbase.useServerSigner && !this.key) {\n            throw new Error(\"Cannot deploy ERC20 without private key loaded\");\n        }\n        const smartContract = await this.createERC20({ name, symbol, totalSupply });\n        if (coinbase_1.Coinbase.useServerSigner) {\n            return smartContract;\n        }\n        await smartContract.sign(this.getSigner());\n        await smartContract.broadcast();\n        return smartContract;\n    }\n    /**\n     * Deploys an ERC721 token contract.\n     *\n     * @param options - The options for creating the ERC721 token.\n     * @param options.name - The name of the ERC721 token.\n     * @param options.symbol - The symbol of the ERC721 token.\n     * @param options.baseURI - The base URI of the ERC721 token.\n     * @returns A Promise that resolves to the deployed SmartContract object.\n     * @throws {APIError} If the API request to create a smart contract fails.\n     */\n    async deployNFT({ name, symbol, baseURI }) {\n        if (!coinbase_1.Coinbase.useServerSigner && !this.key) {\n            throw new Error(\"Cannot deploy ERC721 without private key loaded\");\n        }\n        const smartContract = await this.createERC721({ name, symbol, baseURI });\n        if (coinbase_1.Coinbase.useServerSigner) {\n            return smartContract;\n        }\n        await smartContract.sign(this.getSigner());\n        await smartContract.broadcast();\n        return smartContract;\n    }\n    /**\n     * Deploys an ERC1155 multi-token contract.\n     *\n     * @param options - The options for creating the ERC1155 token.\n     * @param options.uri - The URI for all token metadata.\n     * @returns A Promise that resolves to the deployed SmartContract object.\n     * @throws {APIError} If the API request to create a smart contract fails.\n     */\n    async deployMultiToken({ uri }) {\n        if (!coinbase_1.Coinbase.useServerSigner && !this.key) {\n            throw new Error(\"Cannot deploy ERC1155 without private key loaded\");\n        }\n        const smartContract = await this.createERC1155({ uri });\n        if (coinbase_1.Coinbase.useServerSigner) {\n            return smartContract;\n        }\n        await smartContract.sign(this.getSigner());\n        await smartContract.broadcast();\n        return smartContract;\n    }\n    /**\n     * Deploys a custom contract.\n     *\n     * @param options - The options for creating the custom contract.\n     * @param options.solidityVersion - The version of the solidity compiler, must be 0.8.+, such as \"0.8.28+commit.7893614a\". See https://binaries.soliditylang.org/bin/list.json\n     * @param options.solidityInputJson - The input json for the solidity compiler. See https://docs.soliditylang.org/en/latest/using-the-compiler.html#input-description for more details.\n     * @param options.contractName - The name of the contract class to be deployed.\n     * @param options.constructorArgs - The arguments for the constructor.\n     * @returns A Promise that resolves to the deployed SmartContract object.\n     * @throws {APIError} If the API request to create a smart contract fails.\n     */\n    async deployContract({ solidityVersion, solidityInputJson, contractName, constructorArgs, }) {\n        if (!coinbase_1.Coinbase.useServerSigner && !this.key) {\n            throw new Error(\"Cannot deploy custom contract without private key loaded\");\n        }\n        const smartContract = await this.createCustomContract({\n            solidityVersion,\n            solidityInputJson,\n            contractName,\n            constructorArgs,\n        });\n        if (coinbase_1.Coinbase.useServerSigner) {\n            return smartContract;\n        }\n        await smartContract.sign(this.getSigner());\n        await smartContract.broadcast();\n        return smartContract;\n    }\n    /**\n     * Creates an ERC20 token contract.\n     *\n     * @private\n     * @param {CreateERC20Options} options - The options for creating the ERC20 token.\n     * @param {string} options.name - The name of the ERC20 token.\n     * @param {string} options.symbol - The symbol of the ERC20 token.\n     * @param {BigNumber} options.totalSupply - The total supply of the ERC20 token.\n     * @returns {Promise<SmartContract>} A Promise that resolves to the created SmartContract.\n     * @throws {APIError} If the API request to create a smart contract fails.\n     */\n    async createERC20({ name, symbol, totalSupply, }) {\n        const resp = await coinbase_1.Coinbase.apiClients.smartContract.createSmartContract(this.getWalletId(), this.getId(), {\n            type: client_1.SmartContractType.Erc20,\n            options: {\n                name,\n                symbol,\n                total_supply: totalSupply.toString(),\n            },\n        });\n        return smart_contract_1.SmartContract.fromModel(resp?.data);\n    }\n    /**\n     * Creates an ERC721 token contract.\n     *\n     * @param options - The options for creating the ERC721 token.\n     * @param options.name - The name of the ERC721 token.\n     * @param options.symbol - The symbol of the ERC721 token.\n     * @param options.baseURI - The base URI of the ERC721 token.\n     * @returns A Promise that resolves to the deployed SmartContract object.\n     * @throws {APIError} If the private key is not loaded when not using server signer.\n     */\n    async createERC721({ name, symbol, baseURI, }) {\n        const resp = await coinbase_1.Coinbase.apiClients.smartContract.createSmartContract(this.getWalletId(), this.getId(), {\n            type: client_1.SmartContractType.Erc721,\n            options: {\n                name,\n                symbol,\n                base_uri: baseURI,\n            },\n        });\n        return smart_contract_1.SmartContract.fromModel(resp?.data);\n    }\n    /**\n     * Creates an ERC1155 multi-token contract.\n     *\n     * @private\n     * @param {CreateERC1155Options} options - The options for creating the ERC1155 token.\n     * @param {string} options.uri - The URI for all token metadata.\n     * @returns {Promise<SmartContract>} A Promise that resolves to the created SmartContract.\n     * @throws {APIError} If the API request to create a smart contract fails.\n     */\n    async createERC1155({ uri }) {\n        const resp = await coinbase_1.Coinbase.apiClients.smartContract.createSmartContract(this.getWalletId(), this.getId(), {\n            type: client_1.SmartContractType.Erc1155,\n            options: {\n                uri,\n            },\n        });\n        return smart_contract_1.SmartContract.fromModel(resp?.data);\n    }\n    /**\n     * Creates a custom contract.\n     *\n     * @private\n     * @param {CreateCustomContractOptions} options - The options for creating the custom contract.\n     * @param {string} options.solidityVersion - The version of the solidity compiler, must be 0.8.+, such as \"0.8.28+commit.7893614a\". See https://binaries.soliditylang.org/bin/list.json\n     * @param {string} options.solidityInputJson - The input json for the solidity compiler. See https://docs.soliditylang.org/en/latest/using-the-compiler.html#input-description for more details.\n     * @param {string} options.contractName - The name of the contract class.\n     * @param {Record<string, any>} options.constructorArgs - The arguments for the constructor.\n     * @returns {Promise<SmartContract>} A Promise that resolves to the created SmartContract.\n     * @throws {APIError} If the API request to compile or subsequently create a smart contract fails.\n     */\n    async createCustomContract({ solidityVersion, solidityInputJson, contractName, constructorArgs, }) {\n        const compileContractResp = await coinbase_1.Coinbase.apiClients.smartContract.compileSmartContract({\n            solidity_compiler_version: solidityVersion,\n            solidity_input_json: solidityInputJson,\n            contract_name: contractName,\n        });\n        const compiledContract = compileContractResp.data;\n        const compiledContractId = compiledContract.compiled_smart_contract_id;\n        const createContractResp = await coinbase_1.Coinbase.apiClients.smartContract.createSmartContract(this.getWalletId(), this.getId(), {\n            type: client_1.SmartContractType.Custom,\n            options: JSON.stringify(constructorArgs),\n            compiled_smart_contract_id: compiledContractId,\n        });\n        return smart_contract_1.SmartContract.fromModel(createContractResp?.data);\n    }\n    /**\n     * Creates a contract invocation with the given data.\n     *\n     * @param contractAddress - The address of the contract the method will be invoked on.\n     * @param method - The method to invoke on the contract.\n     * @param abi - The ABI of the contract.\n     * @param args - The arguments to pass to the contract method invocation.\n     *   The keys should be the argument names and the values should be the argument values.\n     * @param atomicAmount - The atomic amount of the native asset to send to a payable contract method.\n     * @returns The ContractInvocation object.\n     * @throws {APIError} if the API request to create a contract invocation fails.\n     */\n    async createContractInvocation(contractAddress, method, abi, args, atomicAmount) {\n        const resp = await coinbase_1.Coinbase.apiClients.contractInvocation.createContractInvocation(this.getWalletId(), this.getId(), {\n            method: method,\n            abi: JSON.stringify(abi),\n            contract_address: contractAddress,\n            args: JSON.stringify(args),\n            amount: atomicAmount,\n        });\n        return contract_invocation_1.ContractInvocation.fromModel(resp?.data);\n    }\n    /**\n     * Creates a staking operation to stake.\n     *\n     * @param amount - The amount to stake.\n     * @param assetId - The asset to stake.\n     * @param mode - The staking mode. Defaults to DEFAULT.\n     * @param options - Additional options for the stake operation:\n     *\n     * A. Shared ETH Staking\n     *  - `integrator_contract_address` (optional): The contract address to which the stake operation is directed to. Defaults to the integrator contract address associated with CDP account (if available) or else defaults to a shared integrator contract address for that network.\n     *\n     * B. Dedicated ETH Staking\n     *  - `funding_address` (optional): Ethereum address for funding the stake operation. Defaults to the address initiating the stake operation.\n     *  - `withdrawal_address` (optional): Ethereum address for receiving rewards and withdrawal funds. Defaults to the address initiating the stake operation.\n     *  - `fee_recipient_address` (optional): Ethereum address for receiving transaction fees. Defaults to the address initiating the stake operation.\n     *\n     * @param timeoutSeconds - The amount to wait for the transaction to complete when broadcasted.\n     * @param intervalSeconds - The amount to check each time for a successful broadcast.\n     * @returns The staking operation after it's completed successfully.\n     */\n    async createStake(amount, assetId, mode = types_1.StakeOptionsMode.DEFAULT, options = {}, timeoutSeconds = 600, intervalSeconds = 0.2) {\n        await this.validateCanStake(amount, assetId, mode, options);\n        return this.createStakingOperation(amount, assetId, \"stake\", mode, options, timeoutSeconds, intervalSeconds);\n    }\n    /**\n     * Creates a staking operation to unstake.\n     *\n     * @param amount - The amount to unstake.\n     * @param assetId - The asset to unstake.\n     * @param mode - The staking mode. Defaults to DEFAULT.\n     * @param options - Additional options for the unstake operation:\n     *\n     * A. Shared ETH Staking\n     *  - `integrator_contract_address` (optional): The contract address to which the unstake operation is directed to. Defaults to the integrator contract address associated with CDP account (if available) or else defaults to a shared integrator contract address for that network.\n     *\n     * B. Dedicated ETH Staking\n     *  - `immediate` (optional): Set this to \"true\" to unstake immediately i.e. leverage \"Coinbase managed unstake\" process . Defaults to \"false\" i.e. \"User managed unstake\" process.\n     *  - `validator_pub_keys` (optional): List of comma separated validator public keys to unstake. Defaults to validators being picked up on your behalf corresponding to the unstake amount.\n     *\n     * @param timeoutSeconds - The amount to wait for the transaction to complete when broadcasted.\n     * @param intervalSeconds - The amount to check each time for a successful broadcast.\n     * @returns The staking operation after it's completed successfully.\n     */\n    async createUnstake(amount, assetId, mode = types_1.StakeOptionsMode.DEFAULT, options = {}, timeoutSeconds = 600, intervalSeconds = 0.2) {\n        await this.validateCanUnstake(amount, assetId, mode, options);\n        return this.createStakingOperation(amount, assetId, \"unstake\", mode, options, timeoutSeconds, intervalSeconds);\n    }\n    /**\n     * Creates a staking operation to claim stake.\n     *\n     * @param amount - The amount to claim stake.\n     * @param assetId - The asset to claim stake.\n     * @param mode - The staking mode. Defaults to DEFAULT.\n     * @param options - Additional options for the claim stake operation.\n     *\n     * A. Shared ETH Staking\n     *  - `integrator_contract_address` (optional): The contract address to which the claim stake operation is directed to. Defaults to the integrator contract address associated with CDP account (if available) or else defaults to a shared integrator contract address for that network.\n     *\n     * @param timeoutSeconds - The amount to wait for the transaction to complete when broadcasted.\n     * @param intervalSeconds - The amount to check each time for a successful broadcast.\n     * @returns The staking operation after it's completed successfully.\n     */\n    async createClaimStake(amount, assetId, mode = types_1.StakeOptionsMode.DEFAULT, options = {}, timeoutSeconds = 600, intervalSeconds = 0.2) {\n        await this.validateCanClaimStake(amount, assetId, mode, options);\n        return this.createStakingOperation(amount, assetId, \"claim_stake\", mode, options, timeoutSeconds, intervalSeconds);\n    }\n    /**\n     * Creates a Payload Signature.\n     *\n     * @param unsignedPayload - The Unsigned Payload to sign.\n     * @returns A promise that resolves to the Payload Signature object.\n     * @throws {APIError} if the API request to create a Payload Signature fails.\n     * @throws {Error} if the address does not have a private key loaded or an associated Server-Signer.\n     */\n    async createPayloadSignature(unsignedPayload) {\n        if (!coinbase_1.Coinbase.useServerSigner && !this.key) {\n            throw new Error(\"Cannot sign payload with address without private key loaded\");\n        }\n        let signature = undefined;\n        if (!coinbase_1.Coinbase.useServerSigner) {\n            signature = this.key.signingKey.sign(unsignedPayload).serialized;\n        }\n        const createPayloadSignatureRequest = {\n            unsigned_payload: unsignedPayload,\n            signature,\n        };\n        const response = await coinbase_1.Coinbase.apiClients.address.createPayloadSignature(this.getWalletId(), this.getId(), createPayloadSignatureRequest);\n        const payloadSignature = new payload_signature_1.PayloadSignature(response.data);\n        return payloadSignature;\n    }\n    /**\n     * Gets a Payload Signature.\n     *\n     * @param payloadSignatureId - The ID of the Payload Signature to fetch.\n     * @returns A promise that resolves to the Payload Signature object.\n     * @throws {APIError} if the API request to get the Payload Signature fails.\n     */\n    async getPayloadSignature(payloadSignatureId) {\n        const response = await coinbase_1.Coinbase.apiClients.address.getPayloadSignature(this.getWalletId(), this.getId(), payloadSignatureId);\n        const payloadSignature = new payload_signature_1.PayloadSignature(response.data);\n        return payloadSignature;\n    }\n    /**\n     * Lists all the Payload Signatures associated with the Address.\n     *\n     * @param options - The pagination options.\n     * @param options.limit - The maximum number of Payload Signatures to return. Limit can range between 1 and 100.\n     * @param options.page - The cursor for pagination across multiple pages of Payload Signatures. Don\\&#39;t include this parameter on the first call. Use the next page value returned in a previous response to request subsequent results.\n     *\n     * @returns A promise that resolves to the paginated list response of Payload Signatures.\n     * @throws {APIError} if the API request to list the Payload Signatures fails.\n     */\n    async listPayloadSignatures({ limit = coinbase_1.Coinbase.defaultPageLimit, page = undefined, } = {}) {\n        const data = [];\n        let nextPage;\n        const response = await coinbase_1.Coinbase.apiClients.address.listPayloadSignatures(this.model.wallet_id, this.model.address_id, 100, page?.length ? page : undefined);\n        response.data.data.forEach(payloadSignatureModel => {\n            data.push(new payload_signature_1.PayloadSignature(payloadSignatureModel));\n        });\n        const hasMore = response.data.has_more;\n        if (hasMore) {\n            if (response.data.next_page) {\n                nextPage = response.data.next_page;\n            }\n        }\n        return {\n            data,\n            hasMore,\n            nextPage,\n        };\n    }\n    /**\n     * Fund the address from your account on the Coinbase Platform.\n     *\n     * @param options - The options to create the fund operation\n     * @param options.amount - The amount of the Asset to fund the wallet with\n     * @param options.assetId - The ID of the Asset to fund with. For Ether, eth, gwei, and wei are supported.\n     * @returns The created fund operation object\n     */\n    async fund({ amount, assetId }) {\n        const normalizedAmount = new decimal_js_1.Decimal(amount.toString());\n        return fund_operation_1.FundOperation.create(this.getWalletId(), this.getId(), normalizedAmount, assetId, this.getNetworkId());\n    }\n    /**\n     * Get a quote for funding the address from your Coinbase platform account.\n     *\n     * @param options - The options to create the fund quote\n     * @param options.amount - The amount to fund\n     * @param options.assetId - The ID of the Asset to fund with. For Ether, eth, gwei, and wei are supported.\n     * @returns The fund quote object\n     */\n    async quoteFund({ amount, assetId }) {\n        const normalizedAmount = new decimal_js_1.Decimal(amount.toString());\n        return fund_quote_1.FundQuote.create(this.getWalletId(), this.getId(), normalizedAmount, assetId, this.getNetworkId());\n    }\n    /**\n     * Returns all the fund operations associated with the address.\n     *\n     * @param options - The pagination options.\n     * @param options.limit - The maximum number of Fund Operations to return. Limit can range between 1 and 100.\n     * @param options.page - The cursor for pagination across multiple pages of Fund Operations. Don't include this parameter on the first call. Use the next page value returned in a previous response to request subsequent results.\n     *\n     * @returns The paginated list response of fund operations.\n     */\n    async listFundOperations({ limit = coinbase_1.Coinbase.defaultPageLimit, page = undefined, } = {}) {\n        return fund_operation_1.FundOperation.listFundOperations(this.model.wallet_id, this.model.address_id, {\n            limit,\n            page,\n        });\n    }\n    /**\n     * Returns the address and network ID of the given destination.\n     *\n     * @param destination - The destination to get the address and network ID of.\n     * @returns The address and network ID of the destination.\n     */\n    async getDestinationAddressAndNetwork(destination) {\n        if (typeof destination !== \"string\" && destination.getNetworkId() !== this.getNetworkId()) {\n            throw new errors_1.ArgumentError(\"Transfer must be on the same Network\");\n        }\n        if (destination instanceof wallet_1.Wallet) {\n            return [(await destination.getDefaultAddress()).getId(), destination.getNetworkId()];\n        }\n        if (destination instanceof address_1.Address) {\n            return [destination.getId(), destination.getNetworkId()];\n        }\n        return [destination, this.getNetworkId()];\n    }\n    /**\n     * Creates a trade model for the specified amount and assets.\n     *\n     * @param amount - The amount of the Asset to send.\n     * @param fromAsset - The Asset to trade from.\n     * @param toAsset - The Asset to trade to.\n     * @returns A promise that resolves to a Trade object representing the new trade.\n     */\n    async createTradeRequest(amount, fromAsset, toAsset) {\n        const tradeRequestPayload = {\n            amount: fromAsset.toAtomicAmount(new decimal_js_1.Decimal(amount.toString())).toString(),\n            from_asset_id: fromAsset.primaryDenomination(),\n            to_asset_id: toAsset.primaryDenomination(),\n        };\n        const tradeModel = await coinbase_1.Coinbase.apiClients.trade.createTrade(this.getWalletId(), this.getId(), tradeRequestPayload);\n        return new trade_1.Trade(tradeModel?.data);\n    }\n    /**\n     * Checks if trading is possible and raises an error if not.\n     *\n     * @param amount - The amount of the Asset to send.\n     * @param fromAssetId - The ID of the Asset to trade from. For Ether, eth, gwei, and wei are supported.\n     * @throws {Error} If the private key is not loaded, or if the asset IDs are unsupported, or if there are insufficient funds.\n     */\n    async validateCanTrade(amount, fromAssetId) {\n        if (!coinbase_1.Coinbase.useServerSigner && !this.key) {\n            throw new Error(\"Cannot trade from address without private key loaded\");\n        }\n        const currentBalance = await this.getBalance(fromAssetId);\n        amount = new decimal_js_1.Decimal(amount.toString());\n        if (currentBalance.lessThan(amount)) {\n            throw new Error(`Insufficient funds: ${amount} requested, but only ${currentBalance} available`);\n        }\n    }\n    /**\n     * Creates a staking operation to stake, signs it, and broadcasts it on the blockchain.\n     *\n     * @param amount - The amount for the staking operation.\n     * @param assetId - The asset to the staking operation.\n     * @param action - The type of staking action to perform.\n     * @param mode - The staking mode. Defaults to DEFAULT.\n     * @param options - Additional options such as setting the mode for the staking action.\n     * @param timeoutSeconds - The amount to wait for the transaction to complete when broadcasted.\n     * @param intervalSeconds - The amount to check each time for a successful broadcast.\n     * @throws {APIError} if the API request to create or broadcast staking operation fails.\n     * @throws {Error} if the amount is less than zero.\n     * @returns The staking operation after it's completed fully.\n     */\n    async createStakingOperation(amount, assetId, action, mode, options, timeoutSeconds, intervalSeconds) {\n        if (new decimal_js_1.Decimal(amount.toString()).lessThanOrEqualTo(0)) {\n            throw new Error(\"Amount required greater than zero.\");\n        }\n        let stakingOperation = await this.createStakingOperationRequest(amount, assetId, action, mode, options);\n        const startTime = Date.now();\n        // Loop until the timeout is reached.\n        while (Date.now() - startTime < timeoutSeconds * 1000) {\n            // Loop through any unsigned transactions that are available, sign and broadcast them.\n            for (let i = 0; i < stakingOperation.getTransactions().length; i++) {\n                const transaction = stakingOperation.getTransactions()[i];\n                if (!transaction.isSigned()) {\n                    await transaction.sign(this.key);\n                    stakingOperation = await this.broadcastStakingOperationRequest(stakingOperation.getID(), transaction.getSignedPayload().slice(2), i);\n                }\n            }\n            await stakingOperation.reload();\n            if (stakingOperation.isTerminalState()) {\n                return stakingOperation;\n            }\n            await (0, utils_1.delay)(intervalSeconds);\n        }\n        throw new Error(\"Staking Operation timed out\");\n    }\n    /**\n     * A helper function that creates the staking operation.\n     *\n     * @param amount - The amount for the staking operation.\n     * @param assetId - The asset for the staking operation.\n     * @param action - The type of staking action to perform.\n     * @param mode - The staking mode. Defaults to DEFAULT.\n     * @param options - Additional options such as setting the mode for the staking action.\n     * @private\n     * @throws {APIError} if the API request to create staking operation fails.\n     * @returns The created staking operation.\n     */\n    async createStakingOperationRequest(amount, assetId, action, mode = types_1.StakeOptionsMode.DEFAULT, options = {}) {\n        const asset = await asset_1.Asset.fetch(this.getNetworkId(), assetId);\n        options.amount = asset.toAtomicAmount(new decimal_js_1.Decimal(amount.toString())).toString();\n        options.mode = mode ? mode : types_1.StakeOptionsMode.DEFAULT;\n        const stakingOperationRequest = {\n            network_id: this.getNetworkId(),\n            asset_id: asset_1.Asset.primaryDenomination(assetId),\n            action: action,\n            options: options,\n        };\n        const response = await coinbase_1.Coinbase.apiClients.walletStake.createStakingOperation(this.getWalletId(), this.getId(), stakingOperationRequest);\n        return new staking_operation_1.StakingOperation(response.data);\n    }\n    /**\n     * A helper function that broadcasts the signed payload.\n     *\n     * @param stakingOperationID - The staking operation id related to the signed payload.\n     * @param signedPayload - The payload that's being broadcasted.\n     * @param transactionIndex - The index of the transaction in the array from the staking operation.\n     * @private\n     * @returns An updated staking operation with the broadcasted transaction.\n     */\n    async broadcastStakingOperationRequest(stakingOperationID, signedPayload, transactionIndex) {\n        const broadcastStakingOperationRequest = {\n            signed_payload: signedPayload,\n            transaction_index: transactionIndex,\n        };\n        const response = await coinbase_1.Coinbase.apiClients.walletStake.broadcastStakingOperation(this.getWalletId(), this.getId(), stakingOperationID, broadcastStakingOperationRequest);\n        return new staking_operation_1.StakingOperation(response.data);\n    }\n}\nexports.WalletAddress = WalletAddress;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL2FkZHJlc3Mvd2FsbGV0X2FkZHJlc3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCO0FBQ3JCLHFCQUFxQixtQkFBTyxDQUFDLDhEQUFZO0FBQ3pDLGlCQUFpQixtQkFBTyxDQUFDLGlFQUFRO0FBQ2pDLGlCQUFpQixtQkFBTyxDQUFDLHNGQUFjO0FBQ3ZDLGtCQUFrQixtQkFBTyxDQUFDLHdGQUFZO0FBQ3RDLGdCQUFnQixtQkFBTyxDQUFDLG9GQUFVO0FBQ2xDLG1CQUFtQixtQkFBTyxDQUFDLDBGQUFhO0FBQ3hDLGlCQUFpQixtQkFBTyxDQUFDLHNGQUFXO0FBQ3BDLGdCQUFnQixtQkFBTyxDQUFDLG9GQUFVO0FBQ2xDLG1CQUFtQixtQkFBTyxDQUFDLDBGQUFhO0FBQ3hDLDhCQUE4QixtQkFBTyxDQUFDLGdIQUF3QjtBQUM5RCxnQkFBZ0IsbUJBQU8sQ0FBQyxvRkFBVTtBQUNsQyxnQkFBZ0IsbUJBQU8sQ0FBQyxvRkFBVTtBQUNsQyxpQkFBaUIsbUJBQU8sQ0FBQyxzRkFBVztBQUNwQyw0QkFBNEIsbUJBQU8sQ0FBQyw0R0FBc0I7QUFDMUQsNEJBQTRCLG1CQUFPLENBQUMsNEdBQXNCO0FBQzFELHlCQUF5QixtQkFBTyxDQUFDLHNHQUFtQjtBQUNwRCx5QkFBeUIsbUJBQU8sQ0FBQyxzR0FBbUI7QUFDcEQscUJBQXFCLG1CQUFPLENBQUMsOEZBQWU7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGNBQWMsYUFBYSxpQkFBaUIsb0JBQW9CLGdCQUFnQixtQkFBbUIsR0FBRztBQUNySTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUdBQWlHO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixrRUFBa0UsSUFBSTtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvR0FBb0c7QUFDcEc7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGtFQUFrRSxJQUFJO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQixnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBLDJCQUEyQixzRUFBc0U7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxrQkFBa0Isc0JBQXNCLGdCQUFnQjtBQUM1SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixVQUFVO0FBQzFCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0Esd0JBQXdCLGdDQUFnQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsZUFBZTtBQUMvQjtBQUNBLDJCQUEyQixzREFBc0Q7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLGtCQUFrQixzQkFBc0IsZ0JBQWdCO0FBQ2hJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQSx3QkFBd0IsNEJBQTRCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCwyQkFBMkI7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQSxzQkFBc0IsdUJBQXVCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCx1QkFBdUI7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBLDZCQUE2QixLQUFLO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxLQUFLO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQSwyQkFBMkIsb0VBQW9FO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0JBQW9CO0FBQ25DLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxXQUFXO0FBQzFCLGlCQUFpQix3QkFBd0I7QUFDekMsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQSx3QkFBd0IsNEJBQTRCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBLHlCQUF5Qix3QkFBd0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHNCQUFzQjtBQUNyQyxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLHdCQUF3QjtBQUN6QyxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBLDBCQUEwQixLQUFLO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDZCQUE2QjtBQUM1QyxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLHFCQUFxQjtBQUNwQyxpQkFBaUIsd0JBQXdCO0FBQ3pDLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0EsaUNBQWlDLG9FQUFvRTtBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRGQUE0RjtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhGQUE4RjtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpR0FBaUc7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixVQUFVO0FBQzFCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZHQUE2RztBQUM3RztBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQSxrQ0FBa0Msa0VBQWtFLElBQUk7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isa0VBQWtFLElBQUk7QUFDckc7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFFBQVEsc0JBQXNCLGdCQUFnQjtBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLCtDQUErQztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBLHNIQUFzSDtBQUN0SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXJ2aXZhbC1mdW4vLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL2FkZHJlc3Mvd2FsbGV0X2FkZHJlc3MuanM/OWJmNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuV2FsbGV0QWRkcmVzcyA9IHZvaWQgMDtcbmNvbnN0IGRlY2ltYWxfanNfMSA9IHJlcXVpcmUoXCJkZWNpbWFsLmpzXCIpO1xuY29uc3QgZXRoZXJzXzEgPSByZXF1aXJlKFwiZXRoZXJzXCIpO1xuY29uc3QgY2xpZW50XzEgPSByZXF1aXJlKFwiLi4vLi4vY2xpZW50XCIpO1xuY29uc3QgYWRkcmVzc18xID0gcmVxdWlyZShcIi4uL2FkZHJlc3NcIik7XG5jb25zdCBhc3NldF8xID0gcmVxdWlyZShcIi4uL2Fzc2V0XCIpO1xuY29uc3QgY29pbmJhc2VfMSA9IHJlcXVpcmUoXCIuLi9jb2luYmFzZVwiKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4uL2Vycm9yc1wiKTtcbmNvbnN0IHRyYWRlXzEgPSByZXF1aXJlKFwiLi4vdHJhZGVcIik7XG5jb25zdCB0cmFuc2Zlcl8xID0gcmVxdWlyZShcIi4uL3RyYW5zZmVyXCIpO1xuY29uc3QgY29udHJhY3RfaW52b2NhdGlvbl8xID0gcmVxdWlyZShcIi4uL2NvbnRyYWN0X2ludm9jYXRpb25cIik7XG5jb25zdCB0eXBlc18xID0gcmVxdWlyZShcIi4uL3R5cGVzXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcbmNvbnN0IHdhbGxldF8xID0gcmVxdWlyZShcIi4uL3dhbGxldFwiKTtcbmNvbnN0IHN0YWtpbmdfb3BlcmF0aW9uXzEgPSByZXF1aXJlKFwiLi4vc3Rha2luZ19vcGVyYXRpb25cIik7XG5jb25zdCBwYXlsb2FkX3NpZ25hdHVyZV8xID0gcmVxdWlyZShcIi4uL3BheWxvYWRfc2lnbmF0dXJlXCIpO1xuY29uc3Qgc21hcnRfY29udHJhY3RfMSA9IHJlcXVpcmUoXCIuLi9zbWFydF9jb250cmFjdFwiKTtcbmNvbnN0IGZ1bmRfb3BlcmF0aW9uXzEgPSByZXF1aXJlKFwiLi4vZnVuZF9vcGVyYXRpb25cIik7XG5jb25zdCBmdW5kX3F1b3RlXzEgPSByZXF1aXJlKFwiLi4vZnVuZF9xdW90ZVwiKTtcbi8qKlxuICogQSByZXByZXNlbnRhdGlvbiBvZiBhIGJsb2NrY2hhaW4gYWRkcmVzcywgd2hpY2ggaXMgYSB3YWxsZXQtY29udHJvbGxlZCBhY2NvdW50IG9uIGEgbmV0d29yay5cbiAqL1xuY2xhc3MgV2FsbGV0QWRkcmVzcyBleHRlbmRzIGFkZHJlc3NfMS5BZGRyZXNzIHtcbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhIG5ldyBXYWxsZXQgQWRkcmVzcyBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBtb2RlbCAtIFRoZSBhZGRyZXNzIG1vZGVsIGRhdGEuXG4gICAgICogQHBhcmFtIGtleSAtIFRoZSBldGhlcnMuanMgU2lnbmluZ0tleSB0aGUgQWRkcmVzcyB1c2VzIHRvIHNpZ24gZGF0YS5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGFkZHJlc3MgbW9kZWwgaXMgZW1wdHkuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobW9kZWwsIGtleSkge1xuICAgICAgICBpZiAoIW1vZGVsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBZGRyZXNzIG1vZGVsIGNhbm5vdCBiZSBlbXB0eVwiKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcihtb2RlbC5uZXR3b3JrX2lkLCBtb2RlbC5hZGRyZXNzX2lkKTtcbiAgICAgICAgdGhpcy5tb2RlbCA9IG1vZGVsO1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgd2FsbGV0IGFkZHJlc3MuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHdhbGxldCBhZGRyZXNzLlxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gYFdhbGxldEFkZHJlc3N7IGFkZHJlc3NJZDogJyR7dGhpcy5nZXRJZCgpfScsIG5ldHdvcmtJZDogJyR7dGhpcy5nZXROZXR3b3JrSWQoKX0nLCB3YWxsZXRJZDogJyR7dGhpcy5nZXRXYWxsZXRJZCgpfScgfWA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHdhbGxldCBJRC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSB3YWxsZXQgSUQuXG4gICAgICovXG4gICAgZ2V0V2FsbGV0SWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLndhbGxldF9pZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgcHJpdmF0ZSBrZXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ga2V5IC0gVGhlIGV0aGVycy5qcyBTaWduaW5nS2V5IHRoZSBBZGRyZXNzIHVzZXMgdG8gc2lnbiBkYXRhLlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcHJpdmF0ZSBrZXkgaXMgYWxyZWFkeSBzZXQuXG4gICAgICovXG4gICAgc2V0S2V5KGtleSkge1xuICAgICAgICBpZiAodGhpcy5rZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUHJpdmF0ZSBrZXkgaXMgYWxyZWFkeSBzZXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4cG9ydHMgdGhlIEFkZHJlc3MncyBwcml2YXRlIGtleSB0byBhIGhleCBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgQWRkcmVzcydzIHByaXZhdGUga2V5IGFzIGEgaGV4IHN0cmluZy5cbiAgICAgKi9cbiAgICBleHBvcnQoKSB7XG4gICAgICAgIGlmICh0aGlzLmtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQcml2YXRlIGtleSBpcyBub3Qgc2V0XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmtleS5wcml2YXRlS2V5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIEFkZHJlc3MgaGFzIGEgcHJpdmF0ZSBrZXkgYmFja2luZyBpdCB0byBzaWduIHRyYW5zYWN0aW9ucy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIEFkZHJlc3MgaGFzIGEgcHJpdmF0ZSBrZXkgYmFja2luZyBpdCB0byBzaWduIHRyYW5zYWN0aW9ucy5cbiAgICAgKi9cbiAgICBjYW5TaWduKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLmtleTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbGwgdGhlIHRyYWRlcyBhc3NvY2lhdGVkIHdpdGggdGhlIGFkZHJlc3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBwYWdpbmF0aW9uIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIG9wdGlvbnMubGltaXQgLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgVHJhZGVzIHRvIHJldHVybi4gTGltaXQgY2FuIHJhbmdlIGJldHdlZW4gMSBhbmQgMTAwLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnBhZ2UgLSBUaGUgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiBUcmFkZXMuIERvblxcJiMzOTt0IGluY2x1ZGUgdGhpcyBwYXJhbWV0ZXIgb24gdGhlIGZpcnN0IGNhbGwuIFVzZSB0aGUgbmV4dCBwYWdlIHZhbHVlIHJldHVybmVkIGluIGEgcHJldmlvdXMgcmVzcG9uc2UgdG8gcmVxdWVzdCBzdWJzZXF1ZW50IHJlc3VsdHMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgcGFnaW5hdGVkIGxpc3QgcmVzcG9uc2Ugb2YgdHJhZGVzLlxuICAgICAqL1xuICAgIGFzeW5jIGxpc3RUcmFkZXMoeyBsaW1pdCA9IGNvaW5iYXNlXzEuQ29pbmJhc2UuZGVmYXVsdFBhZ2VMaW1pdCwgcGFnZSA9IHVuZGVmaW5lZCwgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBbXTtcbiAgICAgICAgbGV0IG5leHRQYWdlO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNvaW5iYXNlXzEuQ29pbmJhc2UuYXBpQ2xpZW50cy50cmFkZS5saXN0VHJhZGVzKHRoaXMubW9kZWwud2FsbGV0X2lkLCB0aGlzLm1vZGVsLmFkZHJlc3NfaWQsIGxpbWl0LCBwYWdlKTtcbiAgICAgICAgcmVzcG9uc2UuZGF0YS5kYXRhLmZvckVhY2godHJhZGVNb2RlbCA9PiB7XG4gICAgICAgICAgICBkYXRhLnB1c2gobmV3IHRyYWRlXzEuVHJhZGUodHJhZGVNb2RlbCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgaGFzTW9yZSA9IHJlc3BvbnNlLmRhdGEuaGFzX21vcmU7XG4gICAgICAgIGlmIChoYXNNb3JlKSB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UuZGF0YS5uZXh0X3BhZ2UpIHtcbiAgICAgICAgICAgICAgICBuZXh0UGFnZSA9IHJlc3BvbnNlLmRhdGEubmV4dF9wYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgaGFzTW9yZSxcbiAgICAgICAgICAgIG5leHRQYWdlLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFsbCB0aGUgdHJhbnNmZXJzIGFzc29jaWF0ZWQgd2l0aCB0aGUgYWRkcmVzcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIHBhZ2luYXRpb24gb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5saW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBUcmFuc2ZlcnMgdG8gcmV0dXJuLiBMaW1pdCBjYW4gcmFuZ2UgYmV0d2VlbiAxIGFuZCAxMDAuXG4gICAgICogQHBhcmFtIG9wdGlvbnMucGFnZSAtIFRoZSBjdXJzb3IgZm9yIHBhZ2luYXRpb24gYWNyb3NzIG11bHRpcGxlIHBhZ2VzIG9mIFRyYW5zZmVycy4gRG9uXFwmIzM5O3QgaW5jbHVkZSB0aGlzIHBhcmFtZXRlciBvbiB0aGUgZmlyc3QgY2FsbC4gVXNlIHRoZSBuZXh0IHBhZ2UgdmFsdWUgcmV0dXJuZWQgaW4gYSBwcmV2aW91cyByZXNwb25zZSB0byByZXF1ZXN0IHN1YnNlcXVlbnQgcmVzdWx0cy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBwYWdpbmF0ZWQgbGlzdCByZXNwb25zZSBvZiB0cmFuc2ZlcnMuXG4gICAgICovXG4gICAgYXN5bmMgbGlzdFRyYW5zZmVycyh7IGxpbWl0ID0gY29pbmJhc2VfMS5Db2luYmFzZS5kZWZhdWx0UGFnZUxpbWl0LCBwYWdlID0gdW5kZWZpbmVkLCB9ID0ge30pIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IFtdO1xuICAgICAgICBsZXQgbmV4dFBhZ2U7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY29pbmJhc2VfMS5Db2luYmFzZS5hcGlDbGllbnRzLnRyYW5zZmVyLmxpc3RUcmFuc2ZlcnModGhpcy5tb2RlbC53YWxsZXRfaWQsIHRoaXMubW9kZWwuYWRkcmVzc19pZCwgbGltaXQsIHBhZ2UpO1xuICAgICAgICByZXNwb25zZS5kYXRhLmRhdGEuZm9yRWFjaCh0cmFuc2Zlck1vZGVsID0+IHtcbiAgICAgICAgICAgIGRhdGEucHVzaCh0cmFuc2Zlcl8xLlRyYW5zZmVyLmZyb21Nb2RlbCh0cmFuc2Zlck1vZGVsKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBoYXNNb3JlID0gcmVzcG9uc2UuZGF0YS5oYXNfbW9yZTtcbiAgICAgICAgaWYgKGhhc01vcmUpIHtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5kYXRhLm5leHRfcGFnZSkge1xuICAgICAgICAgICAgICAgIG5leHRQYWdlID0gcmVzcG9uc2UuZGF0YS5uZXh0X3BhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBoYXNNb3JlLFxuICAgICAgICAgICAgbmV4dFBhZ2UsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyYW5zZmVycyB0aGUgZ2l2ZW4gYW1vdW50IG9mIHRoZSBnaXZlbiBBc3NldCB0byB0aGUgZ2l2ZW4gYWRkcmVzcy5cbiAgICAgKiBPbmx5IHNhbWUtTmV0d29yayBUcmFuc2ZlcnMgYXJlIHN1cHBvcnRlZC5cbiAgICAgKiBUaGlzIHJldHVybnMgYSBgVHJhbnNmZXJgIG9iamVjdCB0aGF0IGhhcyBiZWVuIHNpZ25lZCBhbmQgYnJvYWRjYXN0ZWQsIHlvdVxuICAgICAqIGNhbiB3YWl0IGZvciB0aGlzIHRvIGxhbmQgb24tY2hhaW4gKG9yIGZhaWwpIGJ5IGNhbGxpbmcgYHRyYW5zZmVyLndhaXQoKWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIHRvIGNyZWF0ZSB0aGUgVHJhbnNmZXIuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuYW1vdW50IC0gVGhlIGFtb3VudCBvZiB0aGUgQXNzZXQgdG8gc2VuZC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5hc3NldElkIC0gVGhlIElEIG9mIHRoZSBBc3NldCB0byBzZW5kLiBGb3IgRXRoZXIsIENvaW5iYXNlLmFzc2V0cy5FdGgsIENvaW5iYXNlLmFzc2V0cy5Hd2VpLCBhbmQgQ29pbmJhc2UuYXNzZXRzLldlaSBzdXBwb3J0ZWQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZGVzdGluYXRpb24gLSBUaGUgZGVzdGluYXRpb24gb2YgdGhlIHRyYW5zZmVyLiBJZiBhIFdhbGxldCwgc2VuZHMgdG8gdGhlIFdhbGxldCdzIGRlZmF1bHQgYWRkcmVzcy4gSWYgYSBTdHJpbmcsIGludGVycHJldHMgaXQgYXMgdGhlIGFkZHJlc3MgSUQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZ2FzbGVzcyAtIFdoZXRoZXIgdGhlIFRyYW5zZmVyIHNob3VsZCBiZSBnYXNsZXNzLiBEZWZhdWx0cyB0byBmYWxzZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5za2lwQmF0Y2hpbmcgLSBXaGVuIHRydWUsIHRoZSBUcmFuc2ZlciB3aWxsIGJlIHN1Ym1pdHRlZCBpbW1lZGlhdGVseS4gT3RoZXJ3aXNlLCB0aGUgVHJhbnNmZXIgd2lsbCBiZSBiYXRjaGVkLiBEZWZhdWx0cyB0byBmYWxzZS4gTm90ZTogcmVxdWlyZXMgZ2FzbGVzcyBvcHRpb24gdG8gYmUgc2V0IHRvIHRydWUuXG4gICAgICogQHJldHVybnMgVGhlIHRyYW5zZmVyIG9iamVjdC5cbiAgICAgKiBAdGhyb3dzIHtBUElFcnJvcn0gaWYgdGhlIEFQSSByZXF1ZXN0IHRvIGNyZWF0ZSBhIFRyYW5zZmVyIGZhaWxzLlxuICAgICAqIEB0aHJvd3Mge0FQSUVycm9yfSBpZiB0aGUgQVBJIHJlcXVlc3QgdG8gYnJvYWRjYXN0IGEgVHJhbnNmZXIgZmFpbHMuXG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlVHJhbnNmZXIoeyBhbW91bnQsIGFzc2V0SWQsIGRlc3RpbmF0aW9uLCBnYXNsZXNzID0gZmFsc2UsIHNraXBCYXRjaGluZyA9IGZhbHNlLCB9KSB7XG4gICAgICAgIGlmICghY29pbmJhc2VfMS5Db2luYmFzZS51c2VTZXJ2ZXJTaWduZXIgJiYgIXRoaXMua2V5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgdHJhbnNmZXIgZnJvbSBhZGRyZXNzIHdpdGhvdXQgcHJpdmF0ZSBrZXkgbG9hZGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFzc2V0ID0gYXdhaXQgYXNzZXRfMS5Bc3NldC5mZXRjaCh0aGlzLmdldE5ldHdvcmtJZCgpLCBhc3NldElkKTtcbiAgICAgICAgY29uc3QgW2Rlc3RpbmF0aW9uQWRkcmVzcywgZGVzdGluYXRpb25OZXR3b3JrSWRdID0gYXdhaXQgdGhpcy5nZXREZXN0aW5hdGlvbkFkZHJlc3NBbmROZXR3b3JrKGRlc3RpbmF0aW9uKTtcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZEFtb3VudCA9IG5ldyBkZWNpbWFsX2pzXzEuRGVjaW1hbChhbW91bnQudG9TdHJpbmcoKSk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRCYWxhbmNlID0gYXdhaXQgdGhpcy5nZXRCYWxhbmNlKGFzc2V0SWQpO1xuICAgICAgICBpZiAoY3VycmVudEJhbGFuY2UubGVzc1RoYW4obm9ybWFsaXplZEFtb3VudCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Bcmd1bWVudEVycm9yKGBJbnN1ZmZpY2llbnQgZnVuZHM6ICR7bm9ybWFsaXplZEFtb3VudH0gcmVxdWVzdGVkLCBidXQgb25seSAke2N1cnJlbnRCYWxhbmNlfSBhdmFpbGFibGVgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2tpcEJhdGNoaW5nICYmICFnYXNsZXNzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuQXJndW1lbnRFcnJvcihcInNraXBCYXRjaGluZyByZXF1aXJlcyBnYXNsZXNzIHRvIGJlIHRydWVcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3JlYXRlVHJhbnNmZXJSZXF1ZXN0ID0ge1xuICAgICAgICAgICAgYW1vdW50OiBhc3NldC50b0F0b21pY0Ftb3VudChub3JtYWxpemVkQW1vdW50KS50b1N0cmluZygpLFxuICAgICAgICAgICAgbmV0d29ya19pZDogZGVzdGluYXRpb25OZXR3b3JrSWQsXG4gICAgICAgICAgICBhc3NldF9pZDogYXNzZXQucHJpbWFyeURlbm9taW5hdGlvbigpLFxuICAgICAgICAgICAgZGVzdGluYXRpb246IGRlc3RpbmF0aW9uQWRkcmVzcyxcbiAgICAgICAgICAgIGdhc2xlc3M6IGdhc2xlc3MsXG4gICAgICAgICAgICBza2lwX2JhdGNoaW5nOiBza2lwQmF0Y2hpbmcsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY29pbmJhc2VfMS5Db2luYmFzZS5hcGlDbGllbnRzLnRyYW5zZmVyLmNyZWF0ZVRyYW5zZmVyKHRoaXMuZ2V0V2FsbGV0SWQoKSwgdGhpcy5nZXRJZCgpLCBjcmVhdGVUcmFuc2ZlclJlcXVlc3QpO1xuICAgICAgICBjb25zdCB0cmFuc2ZlciA9IHRyYW5zZmVyXzEuVHJhbnNmZXIuZnJvbU1vZGVsKHJlc3BvbnNlLmRhdGEpO1xuICAgICAgICBpZiAoY29pbmJhc2VfMS5Db2luYmFzZS51c2VTZXJ2ZXJTaWduZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cmFuc2ZlcjtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0cmFuc2Zlci5zaWduKHRoaXMuZ2V0U2lnbmVyKCkpO1xuICAgICAgICBhd2FpdCB0cmFuc2Zlci5icm9hZGNhc3QoKTtcbiAgICAgICAgcmV0dXJuIHRyYW5zZmVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgc2lnbmVyIGZvciB0aGUgcHJpdmF0ZSBrZXkuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgc2lnbmVyIGZvciB0aGUgcHJpdmF0ZSBrZXkuXG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwcml2YXRlIGtleSBpcyBub3QgbG9hZGVkLlxuICAgICAqL1xuICAgIGdldFNpZ25lcigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmtleSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNpZ24gd2l0aG91dCBhIHByaXZhdGUga2V5XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgZXRoZXJzXzEuZXRoZXJzLldhbGxldCh0aGlzLmtleS5wcml2YXRlS2V5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhZGVzIHRoZSBnaXZlbiBhbW91bnQgb2YgdGhlIGdpdmVuIEFzc2V0IGZvciBhbm90aGVyIEFzc2V0LiBPbmx5IHNhbWUtbmV0d29yayBUcmFkZXMgYXJlIHN1cHBvcnRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgdG8gY3JlYXRlIHRoZSBUcmFkZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5hbW91bnQgLSBUaGUgYW1vdW50IG9mIHRoZSBGcm9tIEFzc2V0IHRvIHNlbmQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZnJvbUFzc2V0SWQgLSBUaGUgSUQgb2YgdGhlIEFzc2V0IHRvIHRyYWRlIGZyb20uXG4gICAgICogQHBhcmFtIG9wdGlvbnMudG9Bc3NldElkIC0gVGhlIElEIG9mIHRoZSBBc3NldCB0byB0cmFkZSB0by5cbiAgICAgKiBAcmV0dXJucyBUaGUgVHJhZGUgb2JqZWN0LlxuICAgICAqIEB0aHJvd3Mge0FQSUVycm9yfSBpZiB0aGUgQVBJIHJlcXVlc3QgdG8gY3JlYXRlIG9yIGJyb2FkY2FzdCBhIFRyYWRlIGZhaWxzLlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBpZiB0aGUgVHJhZGUgdGltZXMgb3V0LlxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZVRyYWRlKHsgYW1vdW50LCBmcm9tQXNzZXRJZCwgdG9Bc3NldElkIH0pIHtcbiAgICAgICAgY29uc3QgZnJvbUFzc2V0ID0gYXdhaXQgYXNzZXRfMS5Bc3NldC5mZXRjaCh0aGlzLmdldE5ldHdvcmtJZCgpLCBmcm9tQXNzZXRJZCk7XG4gICAgICAgIGNvbnN0IHRvQXNzZXQgPSBhd2FpdCBhc3NldF8xLkFzc2V0LmZldGNoKHRoaXMuZ2V0TmV0d29ya0lkKCksIHRvQXNzZXRJZCk7XG4gICAgICAgIGF3YWl0IHRoaXMudmFsaWRhdGVDYW5UcmFkZShhbW91bnQsIGZyb21Bc3NldElkKTtcbiAgICAgICAgY29uc3QgdHJhZGUgPSBhd2FpdCB0aGlzLmNyZWF0ZVRyYWRlUmVxdWVzdChhbW91bnQsIGZyb21Bc3NldCwgdG9Bc3NldCk7XG4gICAgICAgIGlmIChjb2luYmFzZV8xLkNvaW5iYXNlLnVzZVNlcnZlclNpZ25lcikge1xuICAgICAgICAgICAgcmV0dXJuIHRyYWRlO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRyYWRlLnNpZ24odGhpcy5nZXRTaWduZXIoKSk7XG4gICAgICAgIGF3YWl0IHRyYWRlLmJyb2FkY2FzdCgpO1xuICAgICAgICByZXR1cm4gdHJhZGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludm9rZXMgYSBjb250cmFjdCB3aXRoIHRoZSBnaXZlbiBkYXRhLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyB0byBpbnZva2UgdGhlIGNvbnRyYWN0XG4gICAgICogQHBhcmFtIG9wdGlvbnMuY29udHJhY3RBZGRyZXNzIC0gVGhlIGFkZHJlc3Mgb2YgdGhlIGNvbnRyYWN0IHRoZSBtZXRob2Qgd2lsbCBiZSBpbnZva2VkIG9uLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLm1ldGhvZCAtIFRoZSBtZXRob2QgdG8gaW52b2tlIG9uIHRoZSBjb250cmFjdC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5hYmkgLSBUaGUgQUJJIG9mIHRoZSBjb250cmFjdC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5hcmdzIC0gVGhlIGFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSBjb250cmFjdCBtZXRob2QgaW52b2NhdGlvbi5cbiAgICAgKiAgIFRoZSBrZXlzIHNob3VsZCBiZSB0aGUgYXJndW1lbnQgbmFtZXMgYW5kIHRoZSB2YWx1ZXMgc2hvdWxkIGJlIHRoZSBhcmd1bWVudCB2YWx1ZXMuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuYW1vdW50IC0gVGhlIGFtb3VudCBvZiB0aGUgYXNzZXQgdG8gc2VuZCB0byBhIHBheWFibGUgY29udHJhY3QgbWV0aG9kLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmFzc2V0SWQgLSBUaGUgSUQgb2YgdGhlIGFzc2V0IHRvIHNlbmQgdG8gYSBwYXlhYmxlIGNvbnRyYWN0IG1ldGhvZC5cbiAgICAgKiAgIFRoZSBhc3NldCBtdXN0IGJlIGEgZGVub21pbmF0aW9uIG9mIHRoZSBuYXRpdmUgYXNzZXQuIChFeC4gXCJ3ZWlcIiwgXCJnd2VpXCIsIG9yIFwiZXRoXCIpLlxuICAgICAqIEByZXR1cm5zIFRoZSBDb250cmFjdEludm9jYXRpb24gb2JqZWN0LlxuICAgICAqIEB0aHJvd3Mge0FQSUVycm9yfSBpZiB0aGUgQVBJIHJlcXVlc3QgdG8gY3JlYXRlIGEgY29udHJhY3QgaW52b2NhdGlvbiBmYWlscy5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlIGFkZHJlc3MgY2Fubm90IHNpZ24uXG4gICAgICogQHRocm93cyB7QXJndW1lbnRFcnJvcn0gaWYgdGhlIGFkZHJlc3MgZG9lcyBub3QgaGF2ZSBzdWZmaWNpZW50IGJhbGFuY2UuXG4gICAgICovXG4gICAgYXN5bmMgaW52b2tlQ29udHJhY3QoeyBjb250cmFjdEFkZHJlc3MsIG1ldGhvZCwgYWJpLCBhcmdzLCBhbW91bnQsIGFzc2V0SWQsIH0pIHtcbiAgICAgICAgaWYgKCFjb2luYmFzZV8xLkNvaW5iYXNlLnVzZVNlcnZlclNpZ25lciAmJiAhdGhpcy5rZXkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBpbnZva2UgY29udHJhY3QgZnJvbSBhZGRyZXNzIHdpdGhvdXQgcHJpdmF0ZSBrZXkgbG9hZGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbW91bnQgJiYgIWFzc2V0SWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Bcmd1bWVudEVycm9yKFwiQXNzZXQgSUQgaXMgcmVxdWlyZWQgZm9yIGNvbnRyYWN0IGl2b2NhdGlvbiBpZiBhbiBhbW91bnQgaXMgcHJvdmlkZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGF0b21pY0Ftb3VudDtcbiAgICAgICAgaWYgKGFzc2V0SWQgJiYgYW1vdW50KSB7XG4gICAgICAgICAgICBjb25zdCBhc3NldCA9IGF3YWl0IGFzc2V0XzEuQXNzZXQuZmV0Y2godGhpcy5nZXROZXR3b3JrSWQoKSwgYXNzZXRJZCk7XG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemVkQW1vdW50ID0gbmV3IGRlY2ltYWxfanNfMS5EZWNpbWFsKGFtb3VudC50b1N0cmluZygpKTtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRCYWxhbmNlID0gYXdhaXQgdGhpcy5nZXRCYWxhbmNlKGFzc2V0SWQpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRCYWxhbmNlLmxlc3NUaGFuKG5vcm1hbGl6ZWRBbW91bnQpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkFyZ3VtZW50RXJyb3IoYEluc3VmZmljaWVudCBmdW5kczogJHtub3JtYWxpemVkQW1vdW50fSByZXF1ZXN0ZWQsIGJ1dCBvbmx5ICR7Y3VycmVudEJhbGFuY2V9IGF2YWlsYWJsZWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXRvbWljQW1vdW50ID0gYXNzZXQudG9BdG9taWNBbW91bnQobm9ybWFsaXplZEFtb3VudCkudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb250cmFjdEludm9jYXRpb24gPSBhd2FpdCB0aGlzLmNyZWF0ZUNvbnRyYWN0SW52b2NhdGlvbihjb250cmFjdEFkZHJlc3MsIG1ldGhvZCwgYWJpLCBhcmdzLCBhdG9taWNBbW91bnQpO1xuICAgICAgICBpZiAoY29pbmJhc2VfMS5Db2luYmFzZS51c2VTZXJ2ZXJTaWduZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250cmFjdEludm9jYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgY29udHJhY3RJbnZvY2F0aW9uLnNpZ24odGhpcy5nZXRTaWduZXIoKSk7XG4gICAgICAgIGF3YWl0IGNvbnRyYWN0SW52b2NhdGlvbi5icm9hZGNhc3QoKTtcbiAgICAgICAgcmV0dXJuIGNvbnRyYWN0SW52b2NhdGlvbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVwbG95cyBhbiBFUkMyMCB0b2tlbiBjb250cmFjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIGNyZWF0aW5nIHRoZSBFUkMyMCB0b2tlbi5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5uYW1lIC0gVGhlIG5hbWUgb2YgdGhlIEVSQzIwIHRva2VuLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnN5bWJvbCAtIFRoZSBzeW1ib2wgb2YgdGhlIEVSQzIwIHRva2VuLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnRvdGFsU3VwcGx5IC0gVGhlIHRvdGFsIHN1cHBseSBvZiB0aGUgRVJDMjAgdG9rZW4uXG4gICAgICogQHJldHVybnMgQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGRlcGxveWVkIFNtYXJ0Q29udHJhY3Qgb2JqZWN0LlxuICAgICAqIEB0aHJvd3Mge0FQSUVycm9yfSBJZiB0aGUgQVBJIHJlcXVlc3QgdG8gY3JlYXRlIGEgc21hcnQgY29udHJhY3QgZmFpbHMuXG4gICAgICovXG4gICAgYXN5bmMgZGVwbG95VG9rZW4oeyBuYW1lLCBzeW1ib2wsIHRvdGFsU3VwcGx5LCB9KSB7XG4gICAgICAgIGlmICghY29pbmJhc2VfMS5Db2luYmFzZS51c2VTZXJ2ZXJTaWduZXIgJiYgIXRoaXMua2V5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZGVwbG95IEVSQzIwIHdpdGhvdXQgcHJpdmF0ZSBrZXkgbG9hZGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNtYXJ0Q29udHJhY3QgPSBhd2FpdCB0aGlzLmNyZWF0ZUVSQzIwKHsgbmFtZSwgc3ltYm9sLCB0b3RhbFN1cHBseSB9KTtcbiAgICAgICAgaWYgKGNvaW5iYXNlXzEuQ29pbmJhc2UudXNlU2VydmVyU2lnbmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gc21hcnRDb250cmFjdDtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBzbWFydENvbnRyYWN0LnNpZ24odGhpcy5nZXRTaWduZXIoKSk7XG4gICAgICAgIGF3YWl0IHNtYXJ0Q29udHJhY3QuYnJvYWRjYXN0KCk7XG4gICAgICAgIHJldHVybiBzbWFydENvbnRyYWN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXBsb3lzIGFuIEVSQzcyMSB0b2tlbiBjb250cmFjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIGNyZWF0aW5nIHRoZSBFUkM3MjEgdG9rZW4uXG4gICAgICogQHBhcmFtIG9wdGlvbnMubmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBFUkM3MjEgdG9rZW4uXG4gICAgICogQHBhcmFtIG9wdGlvbnMuc3ltYm9sIC0gVGhlIHN5bWJvbCBvZiB0aGUgRVJDNzIxIHRva2VuLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmJhc2VVUkkgLSBUaGUgYmFzZSBVUkkgb2YgdGhlIEVSQzcyMSB0b2tlbi5cbiAgICAgKiBAcmV0dXJucyBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgZGVwbG95ZWQgU21hcnRDb250cmFjdCBvYmplY3QuXG4gICAgICogQHRocm93cyB7QVBJRXJyb3J9IElmIHRoZSBBUEkgcmVxdWVzdCB0byBjcmVhdGUgYSBzbWFydCBjb250cmFjdCBmYWlscy5cbiAgICAgKi9cbiAgICBhc3luYyBkZXBsb3lORlQoeyBuYW1lLCBzeW1ib2wsIGJhc2VVUkkgfSkge1xuICAgICAgICBpZiAoIWNvaW5iYXNlXzEuQ29pbmJhc2UudXNlU2VydmVyU2lnbmVyICYmICF0aGlzLmtleSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGRlcGxveSBFUkM3MjEgd2l0aG91dCBwcml2YXRlIGtleSBsb2FkZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc21hcnRDb250cmFjdCA9IGF3YWl0IHRoaXMuY3JlYXRlRVJDNzIxKHsgbmFtZSwgc3ltYm9sLCBiYXNlVVJJIH0pO1xuICAgICAgICBpZiAoY29pbmJhc2VfMS5Db2luYmFzZS51c2VTZXJ2ZXJTaWduZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBzbWFydENvbnRyYWN0O1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHNtYXJ0Q29udHJhY3Quc2lnbih0aGlzLmdldFNpZ25lcigpKTtcbiAgICAgICAgYXdhaXQgc21hcnRDb250cmFjdC5icm9hZGNhc3QoKTtcbiAgICAgICAgcmV0dXJuIHNtYXJ0Q29udHJhY3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlcGxveXMgYW4gRVJDMTE1NSBtdWx0aS10b2tlbiBjb250cmFjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIGNyZWF0aW5nIHRoZSBFUkMxMTU1IHRva2VuLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnVyaSAtIFRoZSBVUkkgZm9yIGFsbCB0b2tlbiBtZXRhZGF0YS5cbiAgICAgKiBAcmV0dXJucyBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgZGVwbG95ZWQgU21hcnRDb250cmFjdCBvYmplY3QuXG4gICAgICogQHRocm93cyB7QVBJRXJyb3J9IElmIHRoZSBBUEkgcmVxdWVzdCB0byBjcmVhdGUgYSBzbWFydCBjb250cmFjdCBmYWlscy5cbiAgICAgKi9cbiAgICBhc3luYyBkZXBsb3lNdWx0aVRva2VuKHsgdXJpIH0pIHtcbiAgICAgICAgaWYgKCFjb2luYmFzZV8xLkNvaW5iYXNlLnVzZVNlcnZlclNpZ25lciAmJiAhdGhpcy5rZXkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBkZXBsb3kgRVJDMTE1NSB3aXRob3V0IHByaXZhdGUga2V5IGxvYWRlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzbWFydENvbnRyYWN0ID0gYXdhaXQgdGhpcy5jcmVhdGVFUkMxMTU1KHsgdXJpIH0pO1xuICAgICAgICBpZiAoY29pbmJhc2VfMS5Db2luYmFzZS51c2VTZXJ2ZXJTaWduZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBzbWFydENvbnRyYWN0O1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHNtYXJ0Q29udHJhY3Quc2lnbih0aGlzLmdldFNpZ25lcigpKTtcbiAgICAgICAgYXdhaXQgc21hcnRDb250cmFjdC5icm9hZGNhc3QoKTtcbiAgICAgICAgcmV0dXJuIHNtYXJ0Q29udHJhY3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlcGxveXMgYSBjdXN0b20gY29udHJhY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIGZvciBjcmVhdGluZyB0aGUgY3VzdG9tIGNvbnRyYWN0LlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnNvbGlkaXR5VmVyc2lvbiAtIFRoZSB2ZXJzaW9uIG9mIHRoZSBzb2xpZGl0eSBjb21waWxlciwgbXVzdCBiZSAwLjguKywgc3VjaCBhcyBcIjAuOC4yOCtjb21taXQuNzg5MzYxNGFcIi4gU2VlIGh0dHBzOi8vYmluYXJpZXMuc29saWRpdHlsYW5nLm9yZy9iaW4vbGlzdC5qc29uXG4gICAgICogQHBhcmFtIG9wdGlvbnMuc29saWRpdHlJbnB1dEpzb24gLSBUaGUgaW5wdXQganNvbiBmb3IgdGhlIHNvbGlkaXR5IGNvbXBpbGVyLiBTZWUgaHR0cHM6Ly9kb2NzLnNvbGlkaXR5bGFuZy5vcmcvZW4vbGF0ZXN0L3VzaW5nLXRoZS1jb21waWxlci5odG1sI2lucHV0LWRlc2NyaXB0aW9uIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuY29udHJhY3ROYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGNvbnRyYWN0IGNsYXNzIHRvIGJlIGRlcGxveWVkLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmNvbnN0cnVjdG9yQXJncyAtIFRoZSBhcmd1bWVudHMgZm9yIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgKiBAcmV0dXJucyBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgZGVwbG95ZWQgU21hcnRDb250cmFjdCBvYmplY3QuXG4gICAgICogQHRocm93cyB7QVBJRXJyb3J9IElmIHRoZSBBUEkgcmVxdWVzdCB0byBjcmVhdGUgYSBzbWFydCBjb250cmFjdCBmYWlscy5cbiAgICAgKi9cbiAgICBhc3luYyBkZXBsb3lDb250cmFjdCh7IHNvbGlkaXR5VmVyc2lvbiwgc29saWRpdHlJbnB1dEpzb24sIGNvbnRyYWN0TmFtZSwgY29uc3RydWN0b3JBcmdzLCB9KSB7XG4gICAgICAgIGlmICghY29pbmJhc2VfMS5Db2luYmFzZS51c2VTZXJ2ZXJTaWduZXIgJiYgIXRoaXMua2V5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZGVwbG95IGN1c3RvbSBjb250cmFjdCB3aXRob3V0IHByaXZhdGUga2V5IGxvYWRlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzbWFydENvbnRyYWN0ID0gYXdhaXQgdGhpcy5jcmVhdGVDdXN0b21Db250cmFjdCh7XG4gICAgICAgICAgICBzb2xpZGl0eVZlcnNpb24sXG4gICAgICAgICAgICBzb2xpZGl0eUlucHV0SnNvbixcbiAgICAgICAgICAgIGNvbnRyYWN0TmFtZSxcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yQXJncyxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChjb2luYmFzZV8xLkNvaW5iYXNlLnVzZVNlcnZlclNpZ25lcikge1xuICAgICAgICAgICAgcmV0dXJuIHNtYXJ0Q29udHJhY3Q7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgc21hcnRDb250cmFjdC5zaWduKHRoaXMuZ2V0U2lnbmVyKCkpO1xuICAgICAgICBhd2FpdCBzbWFydENvbnRyYWN0LmJyb2FkY2FzdCgpO1xuICAgICAgICByZXR1cm4gc21hcnRDb250cmFjdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBFUkMyMCB0b2tlbiBjb250cmFjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDcmVhdGVFUkMyME9wdGlvbnN9IG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBmb3IgY3JlYXRpbmcgdGhlIEVSQzIwIHRva2VuLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLm5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgRVJDMjAgdG9rZW4uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuc3ltYm9sIC0gVGhlIHN5bWJvbCBvZiB0aGUgRVJDMjAgdG9rZW4uXG4gICAgICogQHBhcmFtIHtCaWdOdW1iZXJ9IG9wdGlvbnMudG90YWxTdXBwbHkgLSBUaGUgdG90YWwgc3VwcGx5IG9mIHRoZSBFUkMyMCB0b2tlbi5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxTbWFydENvbnRyYWN0Pn0gQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGNyZWF0ZWQgU21hcnRDb250cmFjdC5cbiAgICAgKiBAdGhyb3dzIHtBUElFcnJvcn0gSWYgdGhlIEFQSSByZXF1ZXN0IHRvIGNyZWF0ZSBhIHNtYXJ0IGNvbnRyYWN0IGZhaWxzLlxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZUVSQzIwKHsgbmFtZSwgc3ltYm9sLCB0b3RhbFN1cHBseSwgfSkge1xuICAgICAgICBjb25zdCByZXNwID0gYXdhaXQgY29pbmJhc2VfMS5Db2luYmFzZS5hcGlDbGllbnRzLnNtYXJ0Q29udHJhY3QuY3JlYXRlU21hcnRDb250cmFjdCh0aGlzLmdldFdhbGxldElkKCksIHRoaXMuZ2V0SWQoKSwge1xuICAgICAgICAgICAgdHlwZTogY2xpZW50XzEuU21hcnRDb250cmFjdFR5cGUuRXJjMjAsXG4gICAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICBzeW1ib2wsXG4gICAgICAgICAgICAgICAgdG90YWxfc3VwcGx5OiB0b3RhbFN1cHBseS50b1N0cmluZygpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzbWFydF9jb250cmFjdF8xLlNtYXJ0Q29udHJhY3QuZnJvbU1vZGVsKHJlc3A/LmRhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIEVSQzcyMSB0b2tlbiBjb250cmFjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIGNyZWF0aW5nIHRoZSBFUkM3MjEgdG9rZW4uXG4gICAgICogQHBhcmFtIG9wdGlvbnMubmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBFUkM3MjEgdG9rZW4uXG4gICAgICogQHBhcmFtIG9wdGlvbnMuc3ltYm9sIC0gVGhlIHN5bWJvbCBvZiB0aGUgRVJDNzIxIHRva2VuLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmJhc2VVUkkgLSBUaGUgYmFzZSBVUkkgb2YgdGhlIEVSQzcyMSB0b2tlbi5cbiAgICAgKiBAcmV0dXJucyBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgZGVwbG95ZWQgU21hcnRDb250cmFjdCBvYmplY3QuXG4gICAgICogQHRocm93cyB7QVBJRXJyb3J9IElmIHRoZSBwcml2YXRlIGtleSBpcyBub3QgbG9hZGVkIHdoZW4gbm90IHVzaW5nIHNlcnZlciBzaWduZXIuXG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlRVJDNzIxKHsgbmFtZSwgc3ltYm9sLCBiYXNlVVJJLCB9KSB7XG4gICAgICAgIGNvbnN0IHJlc3AgPSBhd2FpdCBjb2luYmFzZV8xLkNvaW5iYXNlLmFwaUNsaWVudHMuc21hcnRDb250cmFjdC5jcmVhdGVTbWFydENvbnRyYWN0KHRoaXMuZ2V0V2FsbGV0SWQoKSwgdGhpcy5nZXRJZCgpLCB7XG4gICAgICAgICAgICB0eXBlOiBjbGllbnRfMS5TbWFydENvbnRyYWN0VHlwZS5FcmM3MjEsXG4gICAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICBzeW1ib2wsXG4gICAgICAgICAgICAgICAgYmFzZV91cmk6IGJhc2VVUkksXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHNtYXJ0X2NvbnRyYWN0XzEuU21hcnRDb250cmFjdC5mcm9tTW9kZWwocmVzcD8uZGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gRVJDMTE1NSBtdWx0aS10b2tlbiBjb250cmFjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDcmVhdGVFUkMxMTU1T3B0aW9uc30gb3B0aW9ucyAtIFRoZSBvcHRpb25zIGZvciBjcmVhdGluZyB0aGUgRVJDMTE1NSB0b2tlbi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy51cmkgLSBUaGUgVVJJIGZvciBhbGwgdG9rZW4gbWV0YWRhdGEuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8U21hcnRDb250cmFjdD59IEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBjcmVhdGVkIFNtYXJ0Q29udHJhY3QuXG4gICAgICogQHRocm93cyB7QVBJRXJyb3J9IElmIHRoZSBBUEkgcmVxdWVzdCB0byBjcmVhdGUgYSBzbWFydCBjb250cmFjdCBmYWlscy5cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVFUkMxMTU1KHsgdXJpIH0pIHtcbiAgICAgICAgY29uc3QgcmVzcCA9IGF3YWl0IGNvaW5iYXNlXzEuQ29pbmJhc2UuYXBpQ2xpZW50cy5zbWFydENvbnRyYWN0LmNyZWF0ZVNtYXJ0Q29udHJhY3QodGhpcy5nZXRXYWxsZXRJZCgpLCB0aGlzLmdldElkKCksIHtcbiAgICAgICAgICAgIHR5cGU6IGNsaWVudF8xLlNtYXJ0Q29udHJhY3RUeXBlLkVyYzExNTUsXG4gICAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgdXJpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzbWFydF9jb250cmFjdF8xLlNtYXJ0Q29udHJhY3QuZnJvbU1vZGVsKHJlc3A/LmRhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY3VzdG9tIGNvbnRyYWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NyZWF0ZUN1c3RvbUNvbnRyYWN0T3B0aW9uc30gb3B0aW9ucyAtIFRoZSBvcHRpb25zIGZvciBjcmVhdGluZyB0aGUgY3VzdG9tIGNvbnRyYWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnNvbGlkaXR5VmVyc2lvbiAtIFRoZSB2ZXJzaW9uIG9mIHRoZSBzb2xpZGl0eSBjb21waWxlciwgbXVzdCBiZSAwLjguKywgc3VjaCBhcyBcIjAuOC4yOCtjb21taXQuNzg5MzYxNGFcIi4gU2VlIGh0dHBzOi8vYmluYXJpZXMuc29saWRpdHlsYW5nLm9yZy9iaW4vbGlzdC5qc29uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuc29saWRpdHlJbnB1dEpzb24gLSBUaGUgaW5wdXQganNvbiBmb3IgdGhlIHNvbGlkaXR5IGNvbXBpbGVyLiBTZWUgaHR0cHM6Ly9kb2NzLnNvbGlkaXR5bGFuZy5vcmcvZW4vbGF0ZXN0L3VzaW5nLXRoZS1jb21waWxlci5odG1sI2lucHV0LWRlc2NyaXB0aW9uIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuY29udHJhY3ROYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGNvbnRyYWN0IGNsYXNzLlxuICAgICAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgYW55Pn0gb3B0aW9ucy5jb25zdHJ1Y3RvckFyZ3MgLSBUaGUgYXJndW1lbnRzIGZvciB0aGUgY29uc3RydWN0b3IuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8U21hcnRDb250cmFjdD59IEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBjcmVhdGVkIFNtYXJ0Q29udHJhY3QuXG4gICAgICogQHRocm93cyB7QVBJRXJyb3J9IElmIHRoZSBBUEkgcmVxdWVzdCB0byBjb21waWxlIG9yIHN1YnNlcXVlbnRseSBjcmVhdGUgYSBzbWFydCBjb250cmFjdCBmYWlscy5cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVDdXN0b21Db250cmFjdCh7IHNvbGlkaXR5VmVyc2lvbiwgc29saWRpdHlJbnB1dEpzb24sIGNvbnRyYWN0TmFtZSwgY29uc3RydWN0b3JBcmdzLCB9KSB7XG4gICAgICAgIGNvbnN0IGNvbXBpbGVDb250cmFjdFJlc3AgPSBhd2FpdCBjb2luYmFzZV8xLkNvaW5iYXNlLmFwaUNsaWVudHMuc21hcnRDb250cmFjdC5jb21waWxlU21hcnRDb250cmFjdCh7XG4gICAgICAgICAgICBzb2xpZGl0eV9jb21waWxlcl92ZXJzaW9uOiBzb2xpZGl0eVZlcnNpb24sXG4gICAgICAgICAgICBzb2xpZGl0eV9pbnB1dF9qc29uOiBzb2xpZGl0eUlucHV0SnNvbixcbiAgICAgICAgICAgIGNvbnRyYWN0X25hbWU6IGNvbnRyYWN0TmFtZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGNvbXBpbGVkQ29udHJhY3QgPSBjb21waWxlQ29udHJhY3RSZXNwLmRhdGE7XG4gICAgICAgIGNvbnN0IGNvbXBpbGVkQ29udHJhY3RJZCA9IGNvbXBpbGVkQ29udHJhY3QuY29tcGlsZWRfc21hcnRfY29udHJhY3RfaWQ7XG4gICAgICAgIGNvbnN0IGNyZWF0ZUNvbnRyYWN0UmVzcCA9IGF3YWl0IGNvaW5iYXNlXzEuQ29pbmJhc2UuYXBpQ2xpZW50cy5zbWFydENvbnRyYWN0LmNyZWF0ZVNtYXJ0Q29udHJhY3QodGhpcy5nZXRXYWxsZXRJZCgpLCB0aGlzLmdldElkKCksIHtcbiAgICAgICAgICAgIHR5cGU6IGNsaWVudF8xLlNtYXJ0Q29udHJhY3RUeXBlLkN1c3RvbSxcbiAgICAgICAgICAgIG9wdGlvbnM6IEpTT04uc3RyaW5naWZ5KGNvbnN0cnVjdG9yQXJncyksXG4gICAgICAgICAgICBjb21waWxlZF9zbWFydF9jb250cmFjdF9pZDogY29tcGlsZWRDb250cmFjdElkLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHNtYXJ0X2NvbnRyYWN0XzEuU21hcnRDb250cmFjdC5mcm9tTW9kZWwoY3JlYXRlQ29udHJhY3RSZXNwPy5kYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNvbnRyYWN0IGludm9jYXRpb24gd2l0aCB0aGUgZ2l2ZW4gZGF0YS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb250cmFjdEFkZHJlc3MgLSBUaGUgYWRkcmVzcyBvZiB0aGUgY29udHJhY3QgdGhlIG1ldGhvZCB3aWxsIGJlIGludm9rZWQgb24uXG4gICAgICogQHBhcmFtIG1ldGhvZCAtIFRoZSBtZXRob2QgdG8gaW52b2tlIG9uIHRoZSBjb250cmFjdC5cbiAgICAgKiBAcGFyYW0gYWJpIC0gVGhlIEFCSSBvZiB0aGUgY29udHJhY3QuXG4gICAgICogQHBhcmFtIGFyZ3MgLSBUaGUgYXJndW1lbnRzIHRvIHBhc3MgdG8gdGhlIGNvbnRyYWN0IG1ldGhvZCBpbnZvY2F0aW9uLlxuICAgICAqICAgVGhlIGtleXMgc2hvdWxkIGJlIHRoZSBhcmd1bWVudCBuYW1lcyBhbmQgdGhlIHZhbHVlcyBzaG91bGQgYmUgdGhlIGFyZ3VtZW50IHZhbHVlcy5cbiAgICAgKiBAcGFyYW0gYXRvbWljQW1vdW50IC0gVGhlIGF0b21pYyBhbW91bnQgb2YgdGhlIG5hdGl2ZSBhc3NldCB0byBzZW5kIHRvIGEgcGF5YWJsZSBjb250cmFjdCBtZXRob2QuXG4gICAgICogQHJldHVybnMgVGhlIENvbnRyYWN0SW52b2NhdGlvbiBvYmplY3QuXG4gICAgICogQHRocm93cyB7QVBJRXJyb3J9IGlmIHRoZSBBUEkgcmVxdWVzdCB0byBjcmVhdGUgYSBjb250cmFjdCBpbnZvY2F0aW9uIGZhaWxzLlxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZUNvbnRyYWN0SW52b2NhdGlvbihjb250cmFjdEFkZHJlc3MsIG1ldGhvZCwgYWJpLCBhcmdzLCBhdG9taWNBbW91bnQpIHtcbiAgICAgICAgY29uc3QgcmVzcCA9IGF3YWl0IGNvaW5iYXNlXzEuQ29pbmJhc2UuYXBpQ2xpZW50cy5jb250cmFjdEludm9jYXRpb24uY3JlYXRlQ29udHJhY3RJbnZvY2F0aW9uKHRoaXMuZ2V0V2FsbGV0SWQoKSwgdGhpcy5nZXRJZCgpLCB7XG4gICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgICAgIGFiaTogSlNPTi5zdHJpbmdpZnkoYWJpKSxcbiAgICAgICAgICAgIGNvbnRyYWN0X2FkZHJlc3M6IGNvbnRyYWN0QWRkcmVzcyxcbiAgICAgICAgICAgIGFyZ3M6IEpTT04uc3RyaW5naWZ5KGFyZ3MpLFxuICAgICAgICAgICAgYW1vdW50OiBhdG9taWNBbW91bnQsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY29udHJhY3RfaW52b2NhdGlvbl8xLkNvbnRyYWN0SW52b2NhdGlvbi5mcm9tTW9kZWwocmVzcD8uZGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzdGFraW5nIG9wZXJhdGlvbiB0byBzdGFrZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhbW91bnQgLSBUaGUgYW1vdW50IHRvIHN0YWtlLlxuICAgICAqIEBwYXJhbSBhc3NldElkIC0gVGhlIGFzc2V0IHRvIHN0YWtlLlxuICAgICAqIEBwYXJhbSBtb2RlIC0gVGhlIHN0YWtpbmcgbW9kZS4gRGVmYXVsdHMgdG8gREVGQVVMVC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFkZGl0aW9uYWwgb3B0aW9ucyBmb3IgdGhlIHN0YWtlIG9wZXJhdGlvbjpcbiAgICAgKlxuICAgICAqIEEuIFNoYXJlZCBFVEggU3Rha2luZ1xuICAgICAqICAtIGBpbnRlZ3JhdG9yX2NvbnRyYWN0X2FkZHJlc3NgIChvcHRpb25hbCk6IFRoZSBjb250cmFjdCBhZGRyZXNzIHRvIHdoaWNoIHRoZSBzdGFrZSBvcGVyYXRpb24gaXMgZGlyZWN0ZWQgdG8uIERlZmF1bHRzIHRvIHRoZSBpbnRlZ3JhdG9yIGNvbnRyYWN0IGFkZHJlc3MgYXNzb2NpYXRlZCB3aXRoIENEUCBhY2NvdW50IChpZiBhdmFpbGFibGUpIG9yIGVsc2UgZGVmYXVsdHMgdG8gYSBzaGFyZWQgaW50ZWdyYXRvciBjb250cmFjdCBhZGRyZXNzIGZvciB0aGF0IG5ldHdvcmsuXG4gICAgICpcbiAgICAgKiBCLiBEZWRpY2F0ZWQgRVRIIFN0YWtpbmdcbiAgICAgKiAgLSBgZnVuZGluZ19hZGRyZXNzYCAob3B0aW9uYWwpOiBFdGhlcmV1bSBhZGRyZXNzIGZvciBmdW5kaW5nIHRoZSBzdGFrZSBvcGVyYXRpb24uIERlZmF1bHRzIHRvIHRoZSBhZGRyZXNzIGluaXRpYXRpbmcgdGhlIHN0YWtlIG9wZXJhdGlvbi5cbiAgICAgKiAgLSBgd2l0aGRyYXdhbF9hZGRyZXNzYCAob3B0aW9uYWwpOiBFdGhlcmV1bSBhZGRyZXNzIGZvciByZWNlaXZpbmcgcmV3YXJkcyBhbmQgd2l0aGRyYXdhbCBmdW5kcy4gRGVmYXVsdHMgdG8gdGhlIGFkZHJlc3MgaW5pdGlhdGluZyB0aGUgc3Rha2Ugb3BlcmF0aW9uLlxuICAgICAqICAtIGBmZWVfcmVjaXBpZW50X2FkZHJlc3NgIChvcHRpb25hbCk6IEV0aGVyZXVtIGFkZHJlc3MgZm9yIHJlY2VpdmluZyB0cmFuc2FjdGlvbiBmZWVzLiBEZWZhdWx0cyB0byB0aGUgYWRkcmVzcyBpbml0aWF0aW5nIHRoZSBzdGFrZSBvcGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGltZW91dFNlY29uZHMgLSBUaGUgYW1vdW50IHRvIHdhaXQgZm9yIHRoZSB0cmFuc2FjdGlvbiB0byBjb21wbGV0ZSB3aGVuIGJyb2FkY2FzdGVkLlxuICAgICAqIEBwYXJhbSBpbnRlcnZhbFNlY29uZHMgLSBUaGUgYW1vdW50IHRvIGNoZWNrIGVhY2ggdGltZSBmb3IgYSBzdWNjZXNzZnVsIGJyb2FkY2FzdC5cbiAgICAgKiBAcmV0dXJucyBUaGUgc3Rha2luZyBvcGVyYXRpb24gYWZ0ZXIgaXQncyBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5LlxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZVN0YWtlKGFtb3VudCwgYXNzZXRJZCwgbW9kZSA9IHR5cGVzXzEuU3Rha2VPcHRpb25zTW9kZS5ERUZBVUxULCBvcHRpb25zID0ge30sIHRpbWVvdXRTZWNvbmRzID0gNjAwLCBpbnRlcnZhbFNlY29uZHMgPSAwLjIpIHtcbiAgICAgICAgYXdhaXQgdGhpcy52YWxpZGF0ZUNhblN0YWtlKGFtb3VudCwgYXNzZXRJZCwgbW9kZSwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVN0YWtpbmdPcGVyYXRpb24oYW1vdW50LCBhc3NldElkLCBcInN0YWtlXCIsIG1vZGUsIG9wdGlvbnMsIHRpbWVvdXRTZWNvbmRzLCBpbnRlcnZhbFNlY29uZHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc3Rha2luZyBvcGVyYXRpb24gdG8gdW5zdGFrZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhbW91bnQgLSBUaGUgYW1vdW50IHRvIHVuc3Rha2UuXG4gICAgICogQHBhcmFtIGFzc2V0SWQgLSBUaGUgYXNzZXQgdG8gdW5zdGFrZS5cbiAgICAgKiBAcGFyYW0gbW9kZSAtIFRoZSBzdGFraW5nIG1vZGUuIERlZmF1bHRzIHRvIERFRkFVTFQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBBZGRpdGlvbmFsIG9wdGlvbnMgZm9yIHRoZSB1bnN0YWtlIG9wZXJhdGlvbjpcbiAgICAgKlxuICAgICAqIEEuIFNoYXJlZCBFVEggU3Rha2luZ1xuICAgICAqICAtIGBpbnRlZ3JhdG9yX2NvbnRyYWN0X2FkZHJlc3NgIChvcHRpb25hbCk6IFRoZSBjb250cmFjdCBhZGRyZXNzIHRvIHdoaWNoIHRoZSB1bnN0YWtlIG9wZXJhdGlvbiBpcyBkaXJlY3RlZCB0by4gRGVmYXVsdHMgdG8gdGhlIGludGVncmF0b3IgY29udHJhY3QgYWRkcmVzcyBhc3NvY2lhdGVkIHdpdGggQ0RQIGFjY291bnQgKGlmIGF2YWlsYWJsZSkgb3IgZWxzZSBkZWZhdWx0cyB0byBhIHNoYXJlZCBpbnRlZ3JhdG9yIGNvbnRyYWN0IGFkZHJlc3MgZm9yIHRoYXQgbmV0d29yay5cbiAgICAgKlxuICAgICAqIEIuIERlZGljYXRlZCBFVEggU3Rha2luZ1xuICAgICAqICAtIGBpbW1lZGlhdGVgIChvcHRpb25hbCk6IFNldCB0aGlzIHRvIFwidHJ1ZVwiIHRvIHVuc3Rha2UgaW1tZWRpYXRlbHkgaS5lLiBsZXZlcmFnZSBcIkNvaW5iYXNlIG1hbmFnZWQgdW5zdGFrZVwiIHByb2Nlc3MgLiBEZWZhdWx0cyB0byBcImZhbHNlXCIgaS5lLiBcIlVzZXIgbWFuYWdlZCB1bnN0YWtlXCIgcHJvY2Vzcy5cbiAgICAgKiAgLSBgdmFsaWRhdG9yX3B1Yl9rZXlzYCAob3B0aW9uYWwpOiBMaXN0IG9mIGNvbW1hIHNlcGFyYXRlZCB2YWxpZGF0b3IgcHVibGljIGtleXMgdG8gdW5zdGFrZS4gRGVmYXVsdHMgdG8gdmFsaWRhdG9ycyBiZWluZyBwaWNrZWQgdXAgb24geW91ciBiZWhhbGYgY29ycmVzcG9uZGluZyB0byB0aGUgdW5zdGFrZSBhbW91bnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGltZW91dFNlY29uZHMgLSBUaGUgYW1vdW50IHRvIHdhaXQgZm9yIHRoZSB0cmFuc2FjdGlvbiB0byBjb21wbGV0ZSB3aGVuIGJyb2FkY2FzdGVkLlxuICAgICAqIEBwYXJhbSBpbnRlcnZhbFNlY29uZHMgLSBUaGUgYW1vdW50IHRvIGNoZWNrIGVhY2ggdGltZSBmb3IgYSBzdWNjZXNzZnVsIGJyb2FkY2FzdC5cbiAgICAgKiBAcmV0dXJucyBUaGUgc3Rha2luZyBvcGVyYXRpb24gYWZ0ZXIgaXQncyBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5LlxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZVVuc3Rha2UoYW1vdW50LCBhc3NldElkLCBtb2RlID0gdHlwZXNfMS5TdGFrZU9wdGlvbnNNb2RlLkRFRkFVTFQsIG9wdGlvbnMgPSB7fSwgdGltZW91dFNlY29uZHMgPSA2MDAsIGludGVydmFsU2Vjb25kcyA9IDAuMikge1xuICAgICAgICBhd2FpdCB0aGlzLnZhbGlkYXRlQ2FuVW5zdGFrZShhbW91bnQsIGFzc2V0SWQsIG1vZGUsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVTdGFraW5nT3BlcmF0aW9uKGFtb3VudCwgYXNzZXRJZCwgXCJ1bnN0YWtlXCIsIG1vZGUsIG9wdGlvbnMsIHRpbWVvdXRTZWNvbmRzLCBpbnRlcnZhbFNlY29uZHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc3Rha2luZyBvcGVyYXRpb24gdG8gY2xhaW0gc3Rha2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYW1vdW50IC0gVGhlIGFtb3VudCB0byBjbGFpbSBzdGFrZS5cbiAgICAgKiBAcGFyYW0gYXNzZXRJZCAtIFRoZSBhc3NldCB0byBjbGFpbSBzdGFrZS5cbiAgICAgKiBAcGFyYW0gbW9kZSAtIFRoZSBzdGFraW5nIG1vZGUuIERlZmF1bHRzIHRvIERFRkFVTFQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBBZGRpdGlvbmFsIG9wdGlvbnMgZm9yIHRoZSBjbGFpbSBzdGFrZSBvcGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBBLiBTaGFyZWQgRVRIIFN0YWtpbmdcbiAgICAgKiAgLSBgaW50ZWdyYXRvcl9jb250cmFjdF9hZGRyZXNzYCAob3B0aW9uYWwpOiBUaGUgY29udHJhY3QgYWRkcmVzcyB0byB3aGljaCB0aGUgY2xhaW0gc3Rha2Ugb3BlcmF0aW9uIGlzIGRpcmVjdGVkIHRvLiBEZWZhdWx0cyB0byB0aGUgaW50ZWdyYXRvciBjb250cmFjdCBhZGRyZXNzIGFzc29jaWF0ZWQgd2l0aCBDRFAgYWNjb3VudCAoaWYgYXZhaWxhYmxlKSBvciBlbHNlIGRlZmF1bHRzIHRvIGEgc2hhcmVkIGludGVncmF0b3IgY29udHJhY3QgYWRkcmVzcyBmb3IgdGhhdCBuZXR3b3JrLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRpbWVvdXRTZWNvbmRzIC0gVGhlIGFtb3VudCB0byB3YWl0IGZvciB0aGUgdHJhbnNhY3Rpb24gdG8gY29tcGxldGUgd2hlbiBicm9hZGNhc3RlZC5cbiAgICAgKiBAcGFyYW0gaW50ZXJ2YWxTZWNvbmRzIC0gVGhlIGFtb3VudCB0byBjaGVjayBlYWNoIHRpbWUgZm9yIGEgc3VjY2Vzc2Z1bCBicm9hZGNhc3QuXG4gICAgICogQHJldHVybnMgVGhlIHN0YWtpbmcgb3BlcmF0aW9uIGFmdGVyIGl0J3MgY29tcGxldGVkIHN1Y2Nlc3NmdWxseS5cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVDbGFpbVN0YWtlKGFtb3VudCwgYXNzZXRJZCwgbW9kZSA9IHR5cGVzXzEuU3Rha2VPcHRpb25zTW9kZS5ERUZBVUxULCBvcHRpb25zID0ge30sIHRpbWVvdXRTZWNvbmRzID0gNjAwLCBpbnRlcnZhbFNlY29uZHMgPSAwLjIpIHtcbiAgICAgICAgYXdhaXQgdGhpcy52YWxpZGF0ZUNhbkNsYWltU3Rha2UoYW1vdW50LCBhc3NldElkLCBtb2RlLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlU3Rha2luZ09wZXJhdGlvbihhbW91bnQsIGFzc2V0SWQsIFwiY2xhaW1fc3Rha2VcIiwgbW9kZSwgb3B0aW9ucywgdGltZW91dFNlY29uZHMsIGludGVydmFsU2Vjb25kcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBQYXlsb2FkIFNpZ25hdHVyZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1bnNpZ25lZFBheWxvYWQgLSBUaGUgVW5zaWduZWQgUGF5bG9hZCB0byBzaWduLlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBQYXlsb2FkIFNpZ25hdHVyZSBvYmplY3QuXG4gICAgICogQHRocm93cyB7QVBJRXJyb3J9IGlmIHRoZSBBUEkgcmVxdWVzdCB0byBjcmVhdGUgYSBQYXlsb2FkIFNpZ25hdHVyZSBmYWlscy5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlIGFkZHJlc3MgZG9lcyBub3QgaGF2ZSBhIHByaXZhdGUga2V5IGxvYWRlZCBvciBhbiBhc3NvY2lhdGVkIFNlcnZlci1TaWduZXIuXG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlUGF5bG9hZFNpZ25hdHVyZSh1bnNpZ25lZFBheWxvYWQpIHtcbiAgICAgICAgaWYgKCFjb2luYmFzZV8xLkNvaW5iYXNlLnVzZVNlcnZlclNpZ25lciAmJiAhdGhpcy5rZXkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzaWduIHBheWxvYWQgd2l0aCBhZGRyZXNzIHdpdGhvdXQgcHJpdmF0ZSBrZXkgbG9hZGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzaWduYXR1cmUgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICghY29pbmJhc2VfMS5Db2luYmFzZS51c2VTZXJ2ZXJTaWduZXIpIHtcbiAgICAgICAgICAgIHNpZ25hdHVyZSA9IHRoaXMua2V5LnNpZ25pbmdLZXkuc2lnbih1bnNpZ25lZFBheWxvYWQpLnNlcmlhbGl6ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3JlYXRlUGF5bG9hZFNpZ25hdHVyZVJlcXVlc3QgPSB7XG4gICAgICAgICAgICB1bnNpZ25lZF9wYXlsb2FkOiB1bnNpZ25lZFBheWxvYWQsXG4gICAgICAgICAgICBzaWduYXR1cmUsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY29pbmJhc2VfMS5Db2luYmFzZS5hcGlDbGllbnRzLmFkZHJlc3MuY3JlYXRlUGF5bG9hZFNpZ25hdHVyZSh0aGlzLmdldFdhbGxldElkKCksIHRoaXMuZ2V0SWQoKSwgY3JlYXRlUGF5bG9hZFNpZ25hdHVyZVJlcXVlc3QpO1xuICAgICAgICBjb25zdCBwYXlsb2FkU2lnbmF0dXJlID0gbmV3IHBheWxvYWRfc2lnbmF0dXJlXzEuUGF5bG9hZFNpZ25hdHVyZShyZXNwb25zZS5kYXRhKTtcbiAgICAgICAgcmV0dXJuIHBheWxvYWRTaWduYXR1cmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgYSBQYXlsb2FkIFNpZ25hdHVyZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXlsb2FkU2lnbmF0dXJlSWQgLSBUaGUgSUQgb2YgdGhlIFBheWxvYWQgU2lnbmF0dXJlIHRvIGZldGNoLlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBQYXlsb2FkIFNpZ25hdHVyZSBvYmplY3QuXG4gICAgICogQHRocm93cyB7QVBJRXJyb3J9IGlmIHRoZSBBUEkgcmVxdWVzdCB0byBnZXQgdGhlIFBheWxvYWQgU2lnbmF0dXJlIGZhaWxzLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFBheWxvYWRTaWduYXR1cmUocGF5bG9hZFNpZ25hdHVyZUlkKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY29pbmJhc2VfMS5Db2luYmFzZS5hcGlDbGllbnRzLmFkZHJlc3MuZ2V0UGF5bG9hZFNpZ25hdHVyZSh0aGlzLmdldFdhbGxldElkKCksIHRoaXMuZ2V0SWQoKSwgcGF5bG9hZFNpZ25hdHVyZUlkKTtcbiAgICAgICAgY29uc3QgcGF5bG9hZFNpZ25hdHVyZSA9IG5ldyBwYXlsb2FkX3NpZ25hdHVyZV8xLlBheWxvYWRTaWduYXR1cmUocmVzcG9uc2UuZGF0YSk7XG4gICAgICAgIHJldHVybiBwYXlsb2FkU2lnbmF0dXJlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0cyBhbGwgdGhlIFBheWxvYWQgU2lnbmF0dXJlcyBhc3NvY2lhdGVkIHdpdGggdGhlIEFkZHJlc3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBwYWdpbmF0aW9uIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIG9wdGlvbnMubGltaXQgLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgUGF5bG9hZCBTaWduYXR1cmVzIHRvIHJldHVybi4gTGltaXQgY2FuIHJhbmdlIGJldHdlZW4gMSBhbmQgMTAwLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnBhZ2UgLSBUaGUgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiBQYXlsb2FkIFNpZ25hdHVyZXMuIERvblxcJiMzOTt0IGluY2x1ZGUgdGhpcyBwYXJhbWV0ZXIgb24gdGhlIGZpcnN0IGNhbGwuIFVzZSB0aGUgbmV4dCBwYWdlIHZhbHVlIHJldHVybmVkIGluIGEgcHJldmlvdXMgcmVzcG9uc2UgdG8gcmVxdWVzdCBzdWJzZXF1ZW50IHJlc3VsdHMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgcGFnaW5hdGVkIGxpc3QgcmVzcG9uc2Ugb2YgUGF5bG9hZCBTaWduYXR1cmVzLlxuICAgICAqIEB0aHJvd3Mge0FQSUVycm9yfSBpZiB0aGUgQVBJIHJlcXVlc3QgdG8gbGlzdCB0aGUgUGF5bG9hZCBTaWduYXR1cmVzIGZhaWxzLlxuICAgICAqL1xuICAgIGFzeW5jIGxpc3RQYXlsb2FkU2lnbmF0dXJlcyh7IGxpbWl0ID0gY29pbmJhc2VfMS5Db2luYmFzZS5kZWZhdWx0UGFnZUxpbWl0LCBwYWdlID0gdW5kZWZpbmVkLCB9ID0ge30pIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IFtdO1xuICAgICAgICBsZXQgbmV4dFBhZ2U7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY29pbmJhc2VfMS5Db2luYmFzZS5hcGlDbGllbnRzLmFkZHJlc3MubGlzdFBheWxvYWRTaWduYXR1cmVzKHRoaXMubW9kZWwud2FsbGV0X2lkLCB0aGlzLm1vZGVsLmFkZHJlc3NfaWQsIDEwMCwgcGFnZT8ubGVuZ3RoID8gcGFnZSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHJlc3BvbnNlLmRhdGEuZGF0YS5mb3JFYWNoKHBheWxvYWRTaWduYXR1cmVNb2RlbCA9PiB7XG4gICAgICAgICAgICBkYXRhLnB1c2gobmV3IHBheWxvYWRfc2lnbmF0dXJlXzEuUGF5bG9hZFNpZ25hdHVyZShwYXlsb2FkU2lnbmF0dXJlTW9kZWwpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGhhc01vcmUgPSByZXNwb25zZS5kYXRhLmhhc19tb3JlO1xuICAgICAgICBpZiAoaGFzTW9yZSkge1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLmRhdGEubmV4dF9wYWdlKSB7XG4gICAgICAgICAgICAgICAgbmV4dFBhZ2UgPSByZXNwb25zZS5kYXRhLm5leHRfcGFnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIGhhc01vcmUsXG4gICAgICAgICAgICBuZXh0UGFnZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRnVuZCB0aGUgYWRkcmVzcyBmcm9tIHlvdXIgYWNjb3VudCBvbiB0aGUgQ29pbmJhc2UgUGxhdGZvcm0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIHRvIGNyZWF0ZSB0aGUgZnVuZCBvcGVyYXRpb25cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5hbW91bnQgLSBUaGUgYW1vdW50IG9mIHRoZSBBc3NldCB0byBmdW5kIHRoZSB3YWxsZXQgd2l0aFxuICAgICAqIEBwYXJhbSBvcHRpb25zLmFzc2V0SWQgLSBUaGUgSUQgb2YgdGhlIEFzc2V0IHRvIGZ1bmQgd2l0aC4gRm9yIEV0aGVyLCBldGgsIGd3ZWksIGFuZCB3ZWkgYXJlIHN1cHBvcnRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgY3JlYXRlZCBmdW5kIG9wZXJhdGlvbiBvYmplY3RcbiAgICAgKi9cbiAgICBhc3luYyBmdW5kKHsgYW1vdW50LCBhc3NldElkIH0pIHtcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZEFtb3VudCA9IG5ldyBkZWNpbWFsX2pzXzEuRGVjaW1hbChhbW91bnQudG9TdHJpbmcoKSk7XG4gICAgICAgIHJldHVybiBmdW5kX29wZXJhdGlvbl8xLkZ1bmRPcGVyYXRpb24uY3JlYXRlKHRoaXMuZ2V0V2FsbGV0SWQoKSwgdGhpcy5nZXRJZCgpLCBub3JtYWxpemVkQW1vdW50LCBhc3NldElkLCB0aGlzLmdldE5ldHdvcmtJZCgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGEgcXVvdGUgZm9yIGZ1bmRpbmcgdGhlIGFkZHJlc3MgZnJvbSB5b3VyIENvaW5iYXNlIHBsYXRmb3JtIGFjY291bnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIHRvIGNyZWF0ZSB0aGUgZnVuZCBxdW90ZVxuICAgICAqIEBwYXJhbSBvcHRpb25zLmFtb3VudCAtIFRoZSBhbW91bnQgdG8gZnVuZFxuICAgICAqIEBwYXJhbSBvcHRpb25zLmFzc2V0SWQgLSBUaGUgSUQgb2YgdGhlIEFzc2V0IHRvIGZ1bmQgd2l0aC4gRm9yIEV0aGVyLCBldGgsIGd3ZWksIGFuZCB3ZWkgYXJlIHN1cHBvcnRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgZnVuZCBxdW90ZSBvYmplY3RcbiAgICAgKi9cbiAgICBhc3luYyBxdW90ZUZ1bmQoeyBhbW91bnQsIGFzc2V0SWQgfSkge1xuICAgICAgICBjb25zdCBub3JtYWxpemVkQW1vdW50ID0gbmV3IGRlY2ltYWxfanNfMS5EZWNpbWFsKGFtb3VudC50b1N0cmluZygpKTtcbiAgICAgICAgcmV0dXJuIGZ1bmRfcXVvdGVfMS5GdW5kUXVvdGUuY3JlYXRlKHRoaXMuZ2V0V2FsbGV0SWQoKSwgdGhpcy5nZXRJZCgpLCBub3JtYWxpemVkQW1vdW50LCBhc3NldElkLCB0aGlzLmdldE5ldHdvcmtJZCgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbGwgdGhlIGZ1bmQgb3BlcmF0aW9ucyBhc3NvY2lhdGVkIHdpdGggdGhlIGFkZHJlc3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBwYWdpbmF0aW9uIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIG9wdGlvbnMubGltaXQgLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgRnVuZCBPcGVyYXRpb25zIHRvIHJldHVybi4gTGltaXQgY2FuIHJhbmdlIGJldHdlZW4gMSBhbmQgMTAwLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnBhZ2UgLSBUaGUgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiBGdW5kIE9wZXJhdGlvbnMuIERvbid0IGluY2x1ZGUgdGhpcyBwYXJhbWV0ZXIgb24gdGhlIGZpcnN0IGNhbGwuIFVzZSB0aGUgbmV4dCBwYWdlIHZhbHVlIHJldHVybmVkIGluIGEgcHJldmlvdXMgcmVzcG9uc2UgdG8gcmVxdWVzdCBzdWJzZXF1ZW50IHJlc3VsdHMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgcGFnaW5hdGVkIGxpc3QgcmVzcG9uc2Ugb2YgZnVuZCBvcGVyYXRpb25zLlxuICAgICAqL1xuICAgIGFzeW5jIGxpc3RGdW5kT3BlcmF0aW9ucyh7IGxpbWl0ID0gY29pbmJhc2VfMS5Db2luYmFzZS5kZWZhdWx0UGFnZUxpbWl0LCBwYWdlID0gdW5kZWZpbmVkLCB9ID0ge30pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmRfb3BlcmF0aW9uXzEuRnVuZE9wZXJhdGlvbi5saXN0RnVuZE9wZXJhdGlvbnModGhpcy5tb2RlbC53YWxsZXRfaWQsIHRoaXMubW9kZWwuYWRkcmVzc19pZCwge1xuICAgICAgICAgICAgbGltaXQsXG4gICAgICAgICAgICBwYWdlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYWRkcmVzcyBhbmQgbmV0d29yayBJRCBvZiB0aGUgZ2l2ZW4gZGVzdGluYXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGVzdGluYXRpb24gLSBUaGUgZGVzdGluYXRpb24gdG8gZ2V0IHRoZSBhZGRyZXNzIGFuZCBuZXR3b3JrIElEIG9mLlxuICAgICAqIEByZXR1cm5zIFRoZSBhZGRyZXNzIGFuZCBuZXR3b3JrIElEIG9mIHRoZSBkZXN0aW5hdGlvbi5cbiAgICAgKi9cbiAgICBhc3luYyBnZXREZXN0aW5hdGlvbkFkZHJlc3NBbmROZXR3b3JrKGRlc3RpbmF0aW9uKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZGVzdGluYXRpb24gIT09IFwic3RyaW5nXCIgJiYgZGVzdGluYXRpb24uZ2V0TmV0d29ya0lkKCkgIT09IHRoaXMuZ2V0TmV0d29ya0lkKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Bcmd1bWVudEVycm9yKFwiVHJhbnNmZXIgbXVzdCBiZSBvbiB0aGUgc2FtZSBOZXR3b3JrXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZXN0aW5hdGlvbiBpbnN0YW5jZW9mIHdhbGxldF8xLldhbGxldCkge1xuICAgICAgICAgICAgcmV0dXJuIFsoYXdhaXQgZGVzdGluYXRpb24uZ2V0RGVmYXVsdEFkZHJlc3MoKSkuZ2V0SWQoKSwgZGVzdGluYXRpb24uZ2V0TmV0d29ya0lkKCldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZXN0aW5hdGlvbiBpbnN0YW5jZW9mIGFkZHJlc3NfMS5BZGRyZXNzKSB7XG4gICAgICAgICAgICByZXR1cm4gW2Rlc3RpbmF0aW9uLmdldElkKCksIGRlc3RpbmF0aW9uLmdldE5ldHdvcmtJZCgpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2Rlc3RpbmF0aW9uLCB0aGlzLmdldE5ldHdvcmtJZCgpXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHRyYWRlIG1vZGVsIGZvciB0aGUgc3BlY2lmaWVkIGFtb3VudCBhbmQgYXNzZXRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFtb3VudCAtIFRoZSBhbW91bnQgb2YgdGhlIEFzc2V0IHRvIHNlbmQuXG4gICAgICogQHBhcmFtIGZyb21Bc3NldCAtIFRoZSBBc3NldCB0byB0cmFkZSBmcm9tLlxuICAgICAqIEBwYXJhbSB0b0Fzc2V0IC0gVGhlIEFzc2V0IHRvIHRyYWRlIHRvLlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgVHJhZGUgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgbmV3IHRyYWRlLlxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZVRyYWRlUmVxdWVzdChhbW91bnQsIGZyb21Bc3NldCwgdG9Bc3NldCkge1xuICAgICAgICBjb25zdCB0cmFkZVJlcXVlc3RQYXlsb2FkID0ge1xuICAgICAgICAgICAgYW1vdW50OiBmcm9tQXNzZXQudG9BdG9taWNBbW91bnQobmV3IGRlY2ltYWxfanNfMS5EZWNpbWFsKGFtb3VudC50b1N0cmluZygpKSkudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIGZyb21fYXNzZXRfaWQ6IGZyb21Bc3NldC5wcmltYXJ5RGVub21pbmF0aW9uKCksXG4gICAgICAgICAgICB0b19hc3NldF9pZDogdG9Bc3NldC5wcmltYXJ5RGVub21pbmF0aW9uKCksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHRyYWRlTW9kZWwgPSBhd2FpdCBjb2luYmFzZV8xLkNvaW5iYXNlLmFwaUNsaWVudHMudHJhZGUuY3JlYXRlVHJhZGUodGhpcy5nZXRXYWxsZXRJZCgpLCB0aGlzLmdldElkKCksIHRyYWRlUmVxdWVzdFBheWxvYWQpO1xuICAgICAgICByZXR1cm4gbmV3IHRyYWRlXzEuVHJhZGUodHJhZGVNb2RlbD8uZGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0cmFkaW5nIGlzIHBvc3NpYmxlIGFuZCByYWlzZXMgYW4gZXJyb3IgaWYgbm90LlxuICAgICAqXG4gICAgICogQHBhcmFtIGFtb3VudCAtIFRoZSBhbW91bnQgb2YgdGhlIEFzc2V0IHRvIHNlbmQuXG4gICAgICogQHBhcmFtIGZyb21Bc3NldElkIC0gVGhlIElEIG9mIHRoZSBBc3NldCB0byB0cmFkZSBmcm9tLiBGb3IgRXRoZXIsIGV0aCwgZ3dlaSwgYW5kIHdlaSBhcmUgc3VwcG9ydGVkLlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcHJpdmF0ZSBrZXkgaXMgbm90IGxvYWRlZCwgb3IgaWYgdGhlIGFzc2V0IElEcyBhcmUgdW5zdXBwb3J0ZWQsIG9yIGlmIHRoZXJlIGFyZSBpbnN1ZmZpY2llbnQgZnVuZHMuXG4gICAgICovXG4gICAgYXN5bmMgdmFsaWRhdGVDYW5UcmFkZShhbW91bnQsIGZyb21Bc3NldElkKSB7XG4gICAgICAgIGlmICghY29pbmJhc2VfMS5Db2luYmFzZS51c2VTZXJ2ZXJTaWduZXIgJiYgIXRoaXMua2V5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgdHJhZGUgZnJvbSBhZGRyZXNzIHdpdGhvdXQgcHJpdmF0ZSBrZXkgbG9hZGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGN1cnJlbnRCYWxhbmNlID0gYXdhaXQgdGhpcy5nZXRCYWxhbmNlKGZyb21Bc3NldElkKTtcbiAgICAgICAgYW1vdW50ID0gbmV3IGRlY2ltYWxfanNfMS5EZWNpbWFsKGFtb3VudC50b1N0cmluZygpKTtcbiAgICAgICAgaWYgKGN1cnJlbnRCYWxhbmNlLmxlc3NUaGFuKGFtb3VudCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW5zdWZmaWNpZW50IGZ1bmRzOiAke2Ftb3VudH0gcmVxdWVzdGVkLCBidXQgb25seSAke2N1cnJlbnRCYWxhbmNlfSBhdmFpbGFibGVgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc3Rha2luZyBvcGVyYXRpb24gdG8gc3Rha2UsIHNpZ25zIGl0LCBhbmQgYnJvYWRjYXN0cyBpdCBvbiB0aGUgYmxvY2tjaGFpbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhbW91bnQgLSBUaGUgYW1vdW50IGZvciB0aGUgc3Rha2luZyBvcGVyYXRpb24uXG4gICAgICogQHBhcmFtIGFzc2V0SWQgLSBUaGUgYXNzZXQgdG8gdGhlIHN0YWtpbmcgb3BlcmF0aW9uLlxuICAgICAqIEBwYXJhbSBhY3Rpb24gLSBUaGUgdHlwZSBvZiBzdGFraW5nIGFjdGlvbiB0byBwZXJmb3JtLlxuICAgICAqIEBwYXJhbSBtb2RlIC0gVGhlIHN0YWtpbmcgbW9kZS4gRGVmYXVsdHMgdG8gREVGQVVMVC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFkZGl0aW9uYWwgb3B0aW9ucyBzdWNoIGFzIHNldHRpbmcgdGhlIG1vZGUgZm9yIHRoZSBzdGFraW5nIGFjdGlvbi5cbiAgICAgKiBAcGFyYW0gdGltZW91dFNlY29uZHMgLSBUaGUgYW1vdW50IHRvIHdhaXQgZm9yIHRoZSB0cmFuc2FjdGlvbiB0byBjb21wbGV0ZSB3aGVuIGJyb2FkY2FzdGVkLlxuICAgICAqIEBwYXJhbSBpbnRlcnZhbFNlY29uZHMgLSBUaGUgYW1vdW50IHRvIGNoZWNrIGVhY2ggdGltZSBmb3IgYSBzdWNjZXNzZnVsIGJyb2FkY2FzdC5cbiAgICAgKiBAdGhyb3dzIHtBUElFcnJvcn0gaWYgdGhlIEFQSSByZXF1ZXN0IHRvIGNyZWF0ZSBvciBicm9hZGNhc3Qgc3Rha2luZyBvcGVyYXRpb24gZmFpbHMuXG4gICAgICogQHRocm93cyB7RXJyb3J9IGlmIHRoZSBhbW91bnQgaXMgbGVzcyB0aGFuIHplcm8uXG4gICAgICogQHJldHVybnMgVGhlIHN0YWtpbmcgb3BlcmF0aW9uIGFmdGVyIGl0J3MgY29tcGxldGVkIGZ1bGx5LlxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZVN0YWtpbmdPcGVyYXRpb24oYW1vdW50LCBhc3NldElkLCBhY3Rpb24sIG1vZGUsIG9wdGlvbnMsIHRpbWVvdXRTZWNvbmRzLCBpbnRlcnZhbFNlY29uZHMpIHtcbiAgICAgICAgaWYgKG5ldyBkZWNpbWFsX2pzXzEuRGVjaW1hbChhbW91bnQudG9TdHJpbmcoKSkubGVzc1RoYW5PckVxdWFsVG8oMCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFtb3VudCByZXF1aXJlZCBncmVhdGVyIHRoYW4gemVyby5cIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0YWtpbmdPcGVyYXRpb24gPSBhd2FpdCB0aGlzLmNyZWF0ZVN0YWtpbmdPcGVyYXRpb25SZXF1ZXN0KGFtb3VudCwgYXNzZXRJZCwgYWN0aW9uLCBtb2RlLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgLy8gTG9vcCB1bnRpbCB0aGUgdGltZW91dCBpcyByZWFjaGVkLlxuICAgICAgICB3aGlsZSAoRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSA8IHRpbWVvdXRTZWNvbmRzICogMTAwMCkge1xuICAgICAgICAgICAgLy8gTG9vcCB0aHJvdWdoIGFueSB1bnNpZ25lZCB0cmFuc2FjdGlvbnMgdGhhdCBhcmUgYXZhaWxhYmxlLCBzaWduIGFuZCBicm9hZGNhc3QgdGhlbS5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3Rha2luZ09wZXJhdGlvbi5nZXRUcmFuc2FjdGlvbnMoKS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gc3Rha2luZ09wZXJhdGlvbi5nZXRUcmFuc2FjdGlvbnMoKVtpXTtcbiAgICAgICAgICAgICAgICBpZiAoIXRyYW5zYWN0aW9uLmlzU2lnbmVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdHJhbnNhY3Rpb24uc2lnbih0aGlzLmtleSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YWtpbmdPcGVyYXRpb24gPSBhd2FpdCB0aGlzLmJyb2FkY2FzdFN0YWtpbmdPcGVyYXRpb25SZXF1ZXN0KHN0YWtpbmdPcGVyYXRpb24uZ2V0SUQoKSwgdHJhbnNhY3Rpb24uZ2V0U2lnbmVkUGF5bG9hZCgpLnNsaWNlKDIpLCBpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCBzdGFraW5nT3BlcmF0aW9uLnJlbG9hZCgpO1xuICAgICAgICAgICAgaWYgKHN0YWtpbmdPcGVyYXRpb24uaXNUZXJtaW5hbFN0YXRlKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3Rha2luZ09wZXJhdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0ICgwLCB1dGlsc18xLmRlbGF5KShpbnRlcnZhbFNlY29uZHMpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlN0YWtpbmcgT3BlcmF0aW9uIHRpbWVkIG91dFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBoZWxwZXIgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIHRoZSBzdGFraW5nIG9wZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhbW91bnQgLSBUaGUgYW1vdW50IGZvciB0aGUgc3Rha2luZyBvcGVyYXRpb24uXG4gICAgICogQHBhcmFtIGFzc2V0SWQgLSBUaGUgYXNzZXQgZm9yIHRoZSBzdGFraW5nIG9wZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0gYWN0aW9uIC0gVGhlIHR5cGUgb2Ygc3Rha2luZyBhY3Rpb24gdG8gcGVyZm9ybS5cbiAgICAgKiBAcGFyYW0gbW9kZSAtIFRoZSBzdGFraW5nIG1vZGUuIERlZmF1bHRzIHRvIERFRkFVTFQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBBZGRpdGlvbmFsIG9wdGlvbnMgc3VjaCBhcyBzZXR0aW5nIHRoZSBtb2RlIGZvciB0aGUgc3Rha2luZyBhY3Rpb24uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdGhyb3dzIHtBUElFcnJvcn0gaWYgdGhlIEFQSSByZXF1ZXN0IHRvIGNyZWF0ZSBzdGFraW5nIG9wZXJhdGlvbiBmYWlscy5cbiAgICAgKiBAcmV0dXJucyBUaGUgY3JlYXRlZCBzdGFraW5nIG9wZXJhdGlvbi5cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVTdGFraW5nT3BlcmF0aW9uUmVxdWVzdChhbW91bnQsIGFzc2V0SWQsIGFjdGlvbiwgbW9kZSA9IHR5cGVzXzEuU3Rha2VPcHRpb25zTW9kZS5ERUZBVUxULCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3QgYXNzZXQgPSBhd2FpdCBhc3NldF8xLkFzc2V0LmZldGNoKHRoaXMuZ2V0TmV0d29ya0lkKCksIGFzc2V0SWQpO1xuICAgICAgICBvcHRpb25zLmFtb3VudCA9IGFzc2V0LnRvQXRvbWljQW1vdW50KG5ldyBkZWNpbWFsX2pzXzEuRGVjaW1hbChhbW91bnQudG9TdHJpbmcoKSkpLnRvU3RyaW5nKCk7XG4gICAgICAgIG9wdGlvbnMubW9kZSA9IG1vZGUgPyBtb2RlIDogdHlwZXNfMS5TdGFrZU9wdGlvbnNNb2RlLkRFRkFVTFQ7XG4gICAgICAgIGNvbnN0IHN0YWtpbmdPcGVyYXRpb25SZXF1ZXN0ID0ge1xuICAgICAgICAgICAgbmV0d29ya19pZDogdGhpcy5nZXROZXR3b3JrSWQoKSxcbiAgICAgICAgICAgIGFzc2V0X2lkOiBhc3NldF8xLkFzc2V0LnByaW1hcnlEZW5vbWluYXRpb24oYXNzZXRJZCksXG4gICAgICAgICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY29pbmJhc2VfMS5Db2luYmFzZS5hcGlDbGllbnRzLndhbGxldFN0YWtlLmNyZWF0ZVN0YWtpbmdPcGVyYXRpb24odGhpcy5nZXRXYWxsZXRJZCgpLCB0aGlzLmdldElkKCksIHN0YWtpbmdPcGVyYXRpb25SZXF1ZXN0KTtcbiAgICAgICAgcmV0dXJuIG5ldyBzdGFraW5nX29wZXJhdGlvbl8xLlN0YWtpbmdPcGVyYXRpb24ocmVzcG9uc2UuZGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgaGVscGVyIGZ1bmN0aW9uIHRoYXQgYnJvYWRjYXN0cyB0aGUgc2lnbmVkIHBheWxvYWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3Rha2luZ09wZXJhdGlvbklEIC0gVGhlIHN0YWtpbmcgb3BlcmF0aW9uIGlkIHJlbGF0ZWQgdG8gdGhlIHNpZ25lZCBwYXlsb2FkLlxuICAgICAqIEBwYXJhbSBzaWduZWRQYXlsb2FkIC0gVGhlIHBheWxvYWQgdGhhdCdzIGJlaW5nIGJyb2FkY2FzdGVkLlxuICAgICAqIEBwYXJhbSB0cmFuc2FjdGlvbkluZGV4IC0gVGhlIGluZGV4IG9mIHRoZSB0cmFuc2FjdGlvbiBpbiB0aGUgYXJyYXkgZnJvbSB0aGUgc3Rha2luZyBvcGVyYXRpb24uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJucyBBbiB1cGRhdGVkIHN0YWtpbmcgb3BlcmF0aW9uIHdpdGggdGhlIGJyb2FkY2FzdGVkIHRyYW5zYWN0aW9uLlxuICAgICAqL1xuICAgIGFzeW5jIGJyb2FkY2FzdFN0YWtpbmdPcGVyYXRpb25SZXF1ZXN0KHN0YWtpbmdPcGVyYXRpb25JRCwgc2lnbmVkUGF5bG9hZCwgdHJhbnNhY3Rpb25JbmRleCkge1xuICAgICAgICBjb25zdCBicm9hZGNhc3RTdGFraW5nT3BlcmF0aW9uUmVxdWVzdCA9IHtcbiAgICAgICAgICAgIHNpZ25lZF9wYXlsb2FkOiBzaWduZWRQYXlsb2FkLFxuICAgICAgICAgICAgdHJhbnNhY3Rpb25faW5kZXg6IHRyYW5zYWN0aW9uSW5kZXgsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY29pbmJhc2VfMS5Db2luYmFzZS5hcGlDbGllbnRzLndhbGxldFN0YWtlLmJyb2FkY2FzdFN0YWtpbmdPcGVyYXRpb24odGhpcy5nZXRXYWxsZXRJZCgpLCB0aGlzLmdldElkKCksIHN0YWtpbmdPcGVyYXRpb25JRCwgYnJvYWRjYXN0U3Rha2luZ09wZXJhdGlvblJlcXVlc3QpO1xuICAgICAgICByZXR1cm4gbmV3IHN0YWtpbmdfb3BlcmF0aW9uXzEuU3Rha2luZ09wZXJhdGlvbihyZXNwb25zZS5kYXRhKTtcbiAgICB9XG59XG5leHBvcnRzLldhbGxldEFkZHJlc3MgPSBXYWxsZXRBZGRyZXNzO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/address/wallet_address.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/address_reputation.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/address_reputation.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AddressReputation = void 0;\n/**\n * A representation of the reputation of a blockchain address.\n */\nclass AddressReputation {\n    /**\n     * A representation of the reputation of a blockchain address.\n     *\n     * @param {AddressReputationModel} model - The reputation model instance.\n     */\n    constructor(model) {\n        if (!model) {\n            throw new Error(\"Address reputation model cannot be empty\");\n        }\n        this.model = model;\n    }\n    /**\n     * Returns the address ID.\n     *\n     * @returns {string} The address ID.\n     */\n    get risky() {\n        return this.model.score < 0;\n    }\n    /**\n     * Returns the score of the address.\n     * The score is a number between -100 and 100.\n     *\n     * @returns {number} The score of the address.\n     */\n    get score() {\n        return this.model.score;\n    }\n    /**\n     * Returns the metadata of the address reputation.\n     * The metadata contains additional information about the address reputation.\n     *\n     * @returns {AddressReputationMetadata} The metadata of the address reputation.\n     */\n    get metadata() {\n        return this.model.metadata;\n    }\n    /**\n     * Returns the address ID.\n     *\n     * @returns {string} The address ID.\n     */\n    toString() {\n        const metadata = Object.entries(this.model.metadata).map(([key, value]) => {\n            return `${key}: ${value}`;\n        });\n        return `AddressReputation(score: ${this.score}, metadata: {${metadata.join(\", \")}})`;\n    }\n}\nexports.AddressReputation = AddressReputation;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL2FkZHJlc3NfcmVwdXRhdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHdCQUF3QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDJCQUEyQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixJQUFJLElBQUksTUFBTTtBQUNwQyxTQUFTO0FBQ1QsMkNBQTJDLFdBQVcsYUFBYSxFQUFFLHFCQUFxQjtBQUMxRjtBQUNBO0FBQ0EseUJBQXlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3Vydml2YWwtZnVuLy4vbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9jb2luYmFzZS1zZGsvZGlzdC9jb2luYmFzZS9hZGRyZXNzX3JlcHV0YXRpb24uanM/NGVkMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQWRkcmVzc1JlcHV0YXRpb24gPSB2b2lkIDA7XG4vKipcbiAqIEEgcmVwcmVzZW50YXRpb24gb2YgdGhlIHJlcHV0YXRpb24gb2YgYSBibG9ja2NoYWluIGFkZHJlc3MuXG4gKi9cbmNsYXNzIEFkZHJlc3NSZXB1dGF0aW9uIHtcbiAgICAvKipcbiAgICAgKiBBIHJlcHJlc2VudGF0aW9uIG9mIHRoZSByZXB1dGF0aW9uIG9mIGEgYmxvY2tjaGFpbiBhZGRyZXNzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBZGRyZXNzUmVwdXRhdGlvbk1vZGVsfSBtb2RlbCAtIFRoZSByZXB1dGF0aW9uIG1vZGVsIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG1vZGVsKSB7XG4gICAgICAgIGlmICghbW9kZWwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFkZHJlc3MgcmVwdXRhdGlvbiBtb2RlbCBjYW5ub3QgYmUgZW1wdHlcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb2RlbCA9IG1vZGVsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBhZGRyZXNzIElELlxuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGFkZHJlc3MgSUQuXG4gICAgICovXG4gICAgZ2V0IHJpc2t5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5zY29yZSA8IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHNjb3JlIG9mIHRoZSBhZGRyZXNzLlxuICAgICAqIFRoZSBzY29yZSBpcyBhIG51bWJlciBiZXR3ZWVuIC0xMDAgYW5kIDEwMC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBzY29yZSBvZiB0aGUgYWRkcmVzcy5cbiAgICAgKi9cbiAgICBnZXQgc2NvcmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLnNjb3JlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtZXRhZGF0YSBvZiB0aGUgYWRkcmVzcyByZXB1dGF0aW9uLlxuICAgICAqIFRoZSBtZXRhZGF0YSBjb250YWlucyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IHRoZSBhZGRyZXNzIHJlcHV0YXRpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7QWRkcmVzc1JlcHV0YXRpb25NZXRhZGF0YX0gVGhlIG1ldGFkYXRhIG9mIHRoZSBhZGRyZXNzIHJlcHV0YXRpb24uXG4gICAgICovXG4gICAgZ2V0IG1ldGFkYXRhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5tZXRhZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYWRkcmVzcyBJRC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBhZGRyZXNzIElELlxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBjb25zdCBtZXRhZGF0YSA9IE9iamVjdC5lbnRyaWVzKHRoaXMubW9kZWwubWV0YWRhdGEpLm1hcCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gYCR7a2V5fTogJHt2YWx1ZX1gO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGBBZGRyZXNzUmVwdXRhdGlvbihzY29yZTogJHt0aGlzLnNjb3JlfSwgbWV0YWRhdGE6IHske21ldGFkYXRhLmpvaW4oXCIsIFwiKX19KWA7XG4gICAgfVxufVxuZXhwb3J0cy5BZGRyZXNzUmVwdXRhdGlvbiA9IEFkZHJlc3NSZXB1dGF0aW9uO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/address_reputation.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/api_error.js":
/*!************************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/api_error.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.NetworkFeatureUnsupportedError = exports.InvalidTransferStatusError = exports.InvalidSignedPayloadError = exports.FaucetLimitReachedError = exports.ResourceExhaustedError = exports.InvalidNetworkIDError = exports.InvalidDestinationError = exports.InvalidAssetIDError = exports.UnsupportedAssetError = exports.MalformedRequestError = exports.AlreadyExistsError = exports.InvalidLimitError = exports.InvalidPageError = exports.InvalidTransferIDError = exports.InvalidAmountError = exports.InvalidAddressError = exports.InvalidWalletError = exports.InvalidAddressIDError = exports.InvalidWalletIDError = exports.NotFoundError = exports.UnauthorizedError = exports.UnimplementedError = exports.InternalError = exports.APIError = void 0;\n/* eslint-disable jsdoc/require-jsdoc */\nconst axios_1 = __webpack_require__(/*! axios */ \"(rsc)/./node_modules/axios/dist/node/axios.cjs\");\n/**\n * A wrapper for API errors to provide more context.\n */\nclass APIError extends axios_1.AxiosError {\n    /**\n     * Initializes a new APIError object.\n     *\n     * @class\n     * @param {AxiosError} error - The Axios error.\n     */\n    constructor(error) {\n        super();\n        this.name = this.constructor.name;\n        this.httpCode = error.response ? error.response.status : null;\n        this.apiCode = null;\n        this.apiMessage = null;\n        this.correlationId = null;\n        if (error.response && error.response.data) {\n            const body = error.response.data;\n            this.apiCode = body.code;\n            this.apiMessage = body.message;\n            this.correlationId = body.correlation_id;\n        }\n    }\n    /**\n     * Creates a specific APIError based on the API error code.\n     *\n     * @param {AxiosError} error - The underlying error object.\n     * @returns {APIError} A specific APIError instance.\n     */\n    static fromError(error) {\n        const apiError = new APIError(error);\n        if (!error.response || !error.response.data) {\n            return apiError;\n        }\n        const body = error?.response?.data;\n        switch (body?.code) {\n            case \"unimplemented\":\n                return new UnimplementedError(error);\n            case \"unauthorized\":\n                return new UnauthorizedError(error);\n            case \"internal\":\n                return new InternalError(error);\n            case \"not_found\":\n                return new NotFoundError(error);\n            case \"invalid_wallet_id\":\n                return new InvalidWalletIDError(error);\n            case \"invalid_address_id\":\n                return new InvalidAddressIDError(error);\n            case \"invalid_wallet\":\n                return new InvalidWalletError(error);\n            case \"invalid_address\":\n                return new InvalidAddressError(error);\n            case \"invalid_amount\":\n                return new InvalidAmountError(error);\n            case \"invalid_transfer_id\":\n                return new InvalidTransferIDError(error);\n            case \"invalid_page_token\":\n                return new InvalidPageError(error);\n            case \"invalid_page_limit\":\n                return new InvalidLimitError(error);\n            case \"already_exists\":\n                return new AlreadyExistsError(error);\n            case \"malformed_request\":\n                return new MalformedRequestError(error);\n            case \"unsupported_asset\":\n                return new UnsupportedAssetError(error);\n            case \"invalid_asset_id\":\n                return new InvalidAssetIDError(error);\n            case \"invalid_destination\":\n                return new InvalidDestinationError(error);\n            case \"invalid_network_id\":\n                return new InvalidNetworkIDError(error);\n            case \"resource_exhausted\":\n                return new ResourceExhaustedError(error);\n            case \"faucet_limit_reached\":\n                return new FaucetLimitReachedError(error);\n            case \"invalid_signed_payload\":\n                return new InvalidSignedPayloadError(error);\n            case \"invalid_transfer_status\":\n                return new InvalidTransferStatusError(error);\n            case \"network_feature_unsupported\":\n                return new NetworkFeatureUnsupportedError(error);\n            default:\n                return apiError;\n        }\n    }\n    /**\n     * Returns a String representation of the APIError.\n     *\n     * @returns {string} a String representation of the APIError\n     */\n    toString() {\n        const payload = {};\n        if (this.httpCode)\n            payload.httpCode = this.httpCode;\n        if (this.apiCode)\n            payload.apiCode = this.apiCode;\n        if (this.apiMessage)\n            payload.apiMessage = this.apiMessage;\n        if (this.correlationId)\n            payload.correlationId = this.correlationId;\n        return `${this.name}{${Object.entries(payload)\n            .map(([key, value]) => `${key}: ${value}`)\n            .join(\", \")}}`;\n    }\n}\nexports.APIError = APIError;\nclass InternalError extends APIError {\n}\nexports.InternalError = InternalError;\nclass UnimplementedError extends APIError {\n}\nexports.UnimplementedError = UnimplementedError;\nclass UnauthorizedError extends APIError {\n}\nexports.UnauthorizedError = UnauthorizedError;\nclass NotFoundError extends APIError {\n}\nexports.NotFoundError = NotFoundError;\nclass InvalidWalletIDError extends APIError {\n}\nexports.InvalidWalletIDError = InvalidWalletIDError;\nclass InvalidAddressIDError extends APIError {\n}\nexports.InvalidAddressIDError = InvalidAddressIDError;\nclass InvalidWalletError extends APIError {\n}\nexports.InvalidWalletError = InvalidWalletError;\nclass InvalidAddressError extends APIError {\n}\nexports.InvalidAddressError = InvalidAddressError;\nclass InvalidAmountError extends APIError {\n}\nexports.InvalidAmountError = InvalidAmountError;\nclass InvalidTransferIDError extends APIError {\n}\nexports.InvalidTransferIDError = InvalidTransferIDError;\nclass InvalidPageError extends APIError {\n}\nexports.InvalidPageError = InvalidPageError;\nclass InvalidLimitError extends APIError {\n}\nexports.InvalidLimitError = InvalidLimitError;\nclass AlreadyExistsError extends APIError {\n}\nexports.AlreadyExistsError = AlreadyExistsError;\nclass MalformedRequestError extends APIError {\n}\nexports.MalformedRequestError = MalformedRequestError;\nclass UnsupportedAssetError extends APIError {\n}\nexports.UnsupportedAssetError = UnsupportedAssetError;\nclass InvalidAssetIDError extends APIError {\n}\nexports.InvalidAssetIDError = InvalidAssetIDError;\nclass InvalidDestinationError extends APIError {\n}\nexports.InvalidDestinationError = InvalidDestinationError;\nclass InvalidNetworkIDError extends APIError {\n}\nexports.InvalidNetworkIDError = InvalidNetworkIDError;\nclass ResourceExhaustedError extends APIError {\n}\nexports.ResourceExhaustedError = ResourceExhaustedError;\nclass FaucetLimitReachedError extends APIError {\n}\nexports.FaucetLimitReachedError = FaucetLimitReachedError;\nclass InvalidSignedPayloadError extends APIError {\n}\nexports.InvalidSignedPayloadError = InvalidSignedPayloadError;\nclass InvalidTransferStatusError extends APIError {\n}\nexports.InvalidTransferStatusError = InvalidTransferStatusError;\nclass NetworkFeatureUnsupportedError extends APIError {\n}\nexports.NetworkFeatureUnsupportedError = NetworkFeatureUnsupportedError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL2FwaV9lcnJvci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQ0FBc0MsR0FBRyxrQ0FBa0MsR0FBRyxpQ0FBaUMsR0FBRywrQkFBK0IsR0FBRyw4QkFBOEIsR0FBRyw2QkFBNkIsR0FBRywrQkFBK0IsR0FBRywyQkFBMkIsR0FBRyw2QkFBNkIsR0FBRyw2QkFBNkIsR0FBRywwQkFBMEIsR0FBRyx5QkFBeUIsR0FBRyx3QkFBd0IsR0FBRyw4QkFBOEIsR0FBRywwQkFBMEIsR0FBRywyQkFBMkIsR0FBRywwQkFBMEIsR0FBRyw2QkFBNkIsR0FBRyw0QkFBNEIsR0FBRyxxQkFBcUIsR0FBRyx5QkFBeUIsR0FBRywwQkFBMEIsR0FBRyxxQkFBcUIsR0FBRyxnQkFBZ0I7QUFDMXRCO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsNkRBQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0IsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFdBQVcsRUFBRTtBQUMvQixzQ0FBc0MsSUFBSSxJQUFJLE1BQU07QUFDcEQseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0Esc0NBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3Vydml2YWwtZnVuLy4vbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9jb2luYmFzZS1zZGsvZGlzdC9jb2luYmFzZS9hcGlfZXJyb3IuanM/Mjc4OSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTmV0d29ya0ZlYXR1cmVVbnN1cHBvcnRlZEVycm9yID0gZXhwb3J0cy5JbnZhbGlkVHJhbnNmZXJTdGF0dXNFcnJvciA9IGV4cG9ydHMuSW52YWxpZFNpZ25lZFBheWxvYWRFcnJvciA9IGV4cG9ydHMuRmF1Y2V0TGltaXRSZWFjaGVkRXJyb3IgPSBleHBvcnRzLlJlc291cmNlRXhoYXVzdGVkRXJyb3IgPSBleHBvcnRzLkludmFsaWROZXR3b3JrSURFcnJvciA9IGV4cG9ydHMuSW52YWxpZERlc3RpbmF0aW9uRXJyb3IgPSBleHBvcnRzLkludmFsaWRBc3NldElERXJyb3IgPSBleHBvcnRzLlVuc3VwcG9ydGVkQXNzZXRFcnJvciA9IGV4cG9ydHMuTWFsZm9ybWVkUmVxdWVzdEVycm9yID0gZXhwb3J0cy5BbHJlYWR5RXhpc3RzRXJyb3IgPSBleHBvcnRzLkludmFsaWRMaW1pdEVycm9yID0gZXhwb3J0cy5JbnZhbGlkUGFnZUVycm9yID0gZXhwb3J0cy5JbnZhbGlkVHJhbnNmZXJJREVycm9yID0gZXhwb3J0cy5JbnZhbGlkQW1vdW50RXJyb3IgPSBleHBvcnRzLkludmFsaWRBZGRyZXNzRXJyb3IgPSBleHBvcnRzLkludmFsaWRXYWxsZXRFcnJvciA9IGV4cG9ydHMuSW52YWxpZEFkZHJlc3NJREVycm9yID0gZXhwb3J0cy5JbnZhbGlkV2FsbGV0SURFcnJvciA9IGV4cG9ydHMuTm90Rm91bmRFcnJvciA9IGV4cG9ydHMuVW5hdXRob3JpemVkRXJyb3IgPSBleHBvcnRzLlVuaW1wbGVtZW50ZWRFcnJvciA9IGV4cG9ydHMuSW50ZXJuYWxFcnJvciA9IGV4cG9ydHMuQVBJRXJyb3IgPSB2b2lkIDA7XG4vKiBlc2xpbnQtZGlzYWJsZSBqc2RvYy9yZXF1aXJlLWpzZG9jICovXG5jb25zdCBheGlvc18xID0gcmVxdWlyZShcImF4aW9zXCIpO1xuLyoqXG4gKiBBIHdyYXBwZXIgZm9yIEFQSSBlcnJvcnMgdG8gcHJvdmlkZSBtb3JlIGNvbnRleHQuXG4gKi9cbmNsYXNzIEFQSUVycm9yIGV4dGVuZHMgYXhpb3NfMS5BeGlvc0Vycm9yIHtcbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhIG5ldyBBUElFcnJvciBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAY2xhc3NcbiAgICAgKiBAcGFyYW0ge0F4aW9zRXJyb3J9IGVycm9yIC0gVGhlIEF4aW9zIGVycm9yLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGVycm9yKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubmFtZSA9IHRoaXMuY29uc3RydWN0b3IubmFtZTtcbiAgICAgICAgdGhpcy5odHRwQ29kZSA9IGVycm9yLnJlc3BvbnNlID8gZXJyb3IucmVzcG9uc2Uuc3RhdHVzIDogbnVsbDtcbiAgICAgICAgdGhpcy5hcGlDb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5hcGlNZXNzYWdlID0gbnVsbDtcbiAgICAgICAgdGhpcy5jb3JyZWxhdGlvbklkID0gbnVsbDtcbiAgICAgICAgaWYgKGVycm9yLnJlc3BvbnNlICYmIGVycm9yLnJlc3BvbnNlLmRhdGEpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBlcnJvci5yZXNwb25zZS5kYXRhO1xuICAgICAgICAgICAgdGhpcy5hcGlDb2RlID0gYm9keS5jb2RlO1xuICAgICAgICAgICAgdGhpcy5hcGlNZXNzYWdlID0gYm9keS5tZXNzYWdlO1xuICAgICAgICAgICAgdGhpcy5jb3JyZWxhdGlvbklkID0gYm9keS5jb3JyZWxhdGlvbl9pZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc3BlY2lmaWMgQVBJRXJyb3IgYmFzZWQgb24gdGhlIEFQSSBlcnJvciBjb2RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBeGlvc0Vycm9yfSBlcnJvciAtIFRoZSB1bmRlcmx5aW5nIGVycm9yIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7QVBJRXJyb3J9IEEgc3BlY2lmaWMgQVBJRXJyb3IgaW5zdGFuY2UuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21FcnJvcihlcnJvcikge1xuICAgICAgICBjb25zdCBhcGlFcnJvciA9IG5ldyBBUElFcnJvcihlcnJvcik7XG4gICAgICAgIGlmICghZXJyb3IucmVzcG9uc2UgfHwgIWVycm9yLnJlc3BvbnNlLmRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBhcGlFcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBib2R5ID0gZXJyb3I/LnJlc3BvbnNlPy5kYXRhO1xuICAgICAgICBzd2l0Y2ggKGJvZHk/LmNvZGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ1bmltcGxlbWVudGVkXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVbmltcGxlbWVudGVkRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgY2FzZSBcInVuYXV0aG9yaXplZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVW5hdXRob3JpemVkRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgY2FzZSBcImludGVybmFsXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnRlcm5hbEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIGNhc2UgXCJub3RfZm91bmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE5vdEZvdW5kRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgY2FzZSBcImludmFsaWRfd2FsbGV0X2lkXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnZhbGlkV2FsbGV0SURFcnJvcihlcnJvcik7XG4gICAgICAgICAgICBjYXNlIFwiaW52YWxpZF9hZGRyZXNzX2lkXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnZhbGlkQWRkcmVzc0lERXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgY2FzZSBcImludmFsaWRfd2FsbGV0XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnZhbGlkV2FsbGV0RXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgY2FzZSBcImludmFsaWRfYWRkcmVzc1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSW52YWxpZEFkZHJlc3NFcnJvcihlcnJvcik7XG4gICAgICAgICAgICBjYXNlIFwiaW52YWxpZF9hbW91bnRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEludmFsaWRBbW91bnRFcnJvcihlcnJvcik7XG4gICAgICAgICAgICBjYXNlIFwiaW52YWxpZF90cmFuc2Zlcl9pZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSW52YWxpZFRyYW5zZmVySURFcnJvcihlcnJvcik7XG4gICAgICAgICAgICBjYXNlIFwiaW52YWxpZF9wYWdlX3Rva2VuXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnZhbGlkUGFnZUVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIGNhc2UgXCJpbnZhbGlkX3BhZ2VfbGltaXRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEludmFsaWRMaW1pdEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIGNhc2UgXCJhbHJlYWR5X2V4aXN0c1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQWxyZWFkeUV4aXN0c0Vycm9yKGVycm9yKTtcbiAgICAgICAgICAgIGNhc2UgXCJtYWxmb3JtZWRfcmVxdWVzdFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTWFsZm9ybWVkUmVxdWVzdEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIGNhc2UgXCJ1bnN1cHBvcnRlZF9hc3NldFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVW5zdXBwb3J0ZWRBc3NldEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIGNhc2UgXCJpbnZhbGlkX2Fzc2V0X2lkXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnZhbGlkQXNzZXRJREVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIGNhc2UgXCJpbnZhbGlkX2Rlc3RpbmF0aW9uXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnZhbGlkRGVzdGluYXRpb25FcnJvcihlcnJvcik7XG4gICAgICAgICAgICBjYXNlIFwiaW52YWxpZF9uZXR3b3JrX2lkXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnZhbGlkTmV0d29ya0lERXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgY2FzZSBcInJlc291cmNlX2V4aGF1c3RlZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUmVzb3VyY2VFeGhhdXN0ZWRFcnJvcihlcnJvcik7XG4gICAgICAgICAgICBjYXNlIFwiZmF1Y2V0X2xpbWl0X3JlYWNoZWRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEZhdWNldExpbWl0UmVhY2hlZEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIGNhc2UgXCJpbnZhbGlkX3NpZ25lZF9wYXlsb2FkXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnZhbGlkU2lnbmVkUGF5bG9hZEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIGNhc2UgXCJpbnZhbGlkX3RyYW5zZmVyX3N0YXR1c1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSW52YWxpZFRyYW5zZmVyU3RhdHVzRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgY2FzZSBcIm5ldHdvcmtfZmVhdHVyZV91bnN1cHBvcnRlZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTmV0d29ya0ZlYXR1cmVVbnN1cHBvcnRlZEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwaUVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIEFQSUVycm9yLlxuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ30gYSBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIEFQSUVycm9yXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuaHR0cENvZGUpXG4gICAgICAgICAgICBwYXlsb2FkLmh0dHBDb2RlID0gdGhpcy5odHRwQ29kZTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ29kZSlcbiAgICAgICAgICAgIHBheWxvYWQuYXBpQ29kZSA9IHRoaXMuYXBpQ29kZTtcbiAgICAgICAgaWYgKHRoaXMuYXBpTWVzc2FnZSlcbiAgICAgICAgICAgIHBheWxvYWQuYXBpTWVzc2FnZSA9IHRoaXMuYXBpTWVzc2FnZTtcbiAgICAgICAgaWYgKHRoaXMuY29ycmVsYXRpb25JZClcbiAgICAgICAgICAgIHBheWxvYWQuY29ycmVsYXRpb25JZCA9IHRoaXMuY29ycmVsYXRpb25JZDtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMubmFtZX17JHtPYmplY3QuZW50cmllcyhwYXlsb2FkKVxuICAgICAgICAgICAgLm1hcCgoW2tleSwgdmFsdWVdKSA9PiBgJHtrZXl9OiAke3ZhbHVlfWApXG4gICAgICAgICAgICAuam9pbihcIiwgXCIpfX1gO1xuICAgIH1cbn1cbmV4cG9ydHMuQVBJRXJyb3IgPSBBUElFcnJvcjtcbmNsYXNzIEludGVybmFsRXJyb3IgZXh0ZW5kcyBBUElFcnJvciB7XG59XG5leHBvcnRzLkludGVybmFsRXJyb3IgPSBJbnRlcm5hbEVycm9yO1xuY2xhc3MgVW5pbXBsZW1lbnRlZEVycm9yIGV4dGVuZHMgQVBJRXJyb3Ige1xufVxuZXhwb3J0cy5VbmltcGxlbWVudGVkRXJyb3IgPSBVbmltcGxlbWVudGVkRXJyb3I7XG5jbGFzcyBVbmF1dGhvcml6ZWRFcnJvciBleHRlbmRzIEFQSUVycm9yIHtcbn1cbmV4cG9ydHMuVW5hdXRob3JpemVkRXJyb3IgPSBVbmF1dGhvcml6ZWRFcnJvcjtcbmNsYXNzIE5vdEZvdW5kRXJyb3IgZXh0ZW5kcyBBUElFcnJvciB7XG59XG5leHBvcnRzLk5vdEZvdW5kRXJyb3IgPSBOb3RGb3VuZEVycm9yO1xuY2xhc3MgSW52YWxpZFdhbGxldElERXJyb3IgZXh0ZW5kcyBBUElFcnJvciB7XG59XG5leHBvcnRzLkludmFsaWRXYWxsZXRJREVycm9yID0gSW52YWxpZFdhbGxldElERXJyb3I7XG5jbGFzcyBJbnZhbGlkQWRkcmVzc0lERXJyb3IgZXh0ZW5kcyBBUElFcnJvciB7XG59XG5leHBvcnRzLkludmFsaWRBZGRyZXNzSURFcnJvciA9IEludmFsaWRBZGRyZXNzSURFcnJvcjtcbmNsYXNzIEludmFsaWRXYWxsZXRFcnJvciBleHRlbmRzIEFQSUVycm9yIHtcbn1cbmV4cG9ydHMuSW52YWxpZFdhbGxldEVycm9yID0gSW52YWxpZFdhbGxldEVycm9yO1xuY2xhc3MgSW52YWxpZEFkZHJlc3NFcnJvciBleHRlbmRzIEFQSUVycm9yIHtcbn1cbmV4cG9ydHMuSW52YWxpZEFkZHJlc3NFcnJvciA9IEludmFsaWRBZGRyZXNzRXJyb3I7XG5jbGFzcyBJbnZhbGlkQW1vdW50RXJyb3IgZXh0ZW5kcyBBUElFcnJvciB7XG59XG5leHBvcnRzLkludmFsaWRBbW91bnRFcnJvciA9IEludmFsaWRBbW91bnRFcnJvcjtcbmNsYXNzIEludmFsaWRUcmFuc2ZlcklERXJyb3IgZXh0ZW5kcyBBUElFcnJvciB7XG59XG5leHBvcnRzLkludmFsaWRUcmFuc2ZlcklERXJyb3IgPSBJbnZhbGlkVHJhbnNmZXJJREVycm9yO1xuY2xhc3MgSW52YWxpZFBhZ2VFcnJvciBleHRlbmRzIEFQSUVycm9yIHtcbn1cbmV4cG9ydHMuSW52YWxpZFBhZ2VFcnJvciA9IEludmFsaWRQYWdlRXJyb3I7XG5jbGFzcyBJbnZhbGlkTGltaXRFcnJvciBleHRlbmRzIEFQSUVycm9yIHtcbn1cbmV4cG9ydHMuSW52YWxpZExpbWl0RXJyb3IgPSBJbnZhbGlkTGltaXRFcnJvcjtcbmNsYXNzIEFscmVhZHlFeGlzdHNFcnJvciBleHRlbmRzIEFQSUVycm9yIHtcbn1cbmV4cG9ydHMuQWxyZWFkeUV4aXN0c0Vycm9yID0gQWxyZWFkeUV4aXN0c0Vycm9yO1xuY2xhc3MgTWFsZm9ybWVkUmVxdWVzdEVycm9yIGV4dGVuZHMgQVBJRXJyb3Ige1xufVxuZXhwb3J0cy5NYWxmb3JtZWRSZXF1ZXN0RXJyb3IgPSBNYWxmb3JtZWRSZXF1ZXN0RXJyb3I7XG5jbGFzcyBVbnN1cHBvcnRlZEFzc2V0RXJyb3IgZXh0ZW5kcyBBUElFcnJvciB7XG59XG5leHBvcnRzLlVuc3VwcG9ydGVkQXNzZXRFcnJvciA9IFVuc3VwcG9ydGVkQXNzZXRFcnJvcjtcbmNsYXNzIEludmFsaWRBc3NldElERXJyb3IgZXh0ZW5kcyBBUElFcnJvciB7XG59XG5leHBvcnRzLkludmFsaWRBc3NldElERXJyb3IgPSBJbnZhbGlkQXNzZXRJREVycm9yO1xuY2xhc3MgSW52YWxpZERlc3RpbmF0aW9uRXJyb3IgZXh0ZW5kcyBBUElFcnJvciB7XG59XG5leHBvcnRzLkludmFsaWREZXN0aW5hdGlvbkVycm9yID0gSW52YWxpZERlc3RpbmF0aW9uRXJyb3I7XG5jbGFzcyBJbnZhbGlkTmV0d29ya0lERXJyb3IgZXh0ZW5kcyBBUElFcnJvciB7XG59XG5leHBvcnRzLkludmFsaWROZXR3b3JrSURFcnJvciA9IEludmFsaWROZXR3b3JrSURFcnJvcjtcbmNsYXNzIFJlc291cmNlRXhoYXVzdGVkRXJyb3IgZXh0ZW5kcyBBUElFcnJvciB7XG59XG5leHBvcnRzLlJlc291cmNlRXhoYXVzdGVkRXJyb3IgPSBSZXNvdXJjZUV4aGF1c3RlZEVycm9yO1xuY2xhc3MgRmF1Y2V0TGltaXRSZWFjaGVkRXJyb3IgZXh0ZW5kcyBBUElFcnJvciB7XG59XG5leHBvcnRzLkZhdWNldExpbWl0UmVhY2hlZEVycm9yID0gRmF1Y2V0TGltaXRSZWFjaGVkRXJyb3I7XG5jbGFzcyBJbnZhbGlkU2lnbmVkUGF5bG9hZEVycm9yIGV4dGVuZHMgQVBJRXJyb3Ige1xufVxuZXhwb3J0cy5JbnZhbGlkU2lnbmVkUGF5bG9hZEVycm9yID0gSW52YWxpZFNpZ25lZFBheWxvYWRFcnJvcjtcbmNsYXNzIEludmFsaWRUcmFuc2ZlclN0YXR1c0Vycm9yIGV4dGVuZHMgQVBJRXJyb3Ige1xufVxuZXhwb3J0cy5JbnZhbGlkVHJhbnNmZXJTdGF0dXNFcnJvciA9IEludmFsaWRUcmFuc2ZlclN0YXR1c0Vycm9yO1xuY2xhc3MgTmV0d29ya0ZlYXR1cmVVbnN1cHBvcnRlZEVycm9yIGV4dGVuZHMgQVBJRXJyb3Ige1xufVxuZXhwb3J0cy5OZXR3b3JrRmVhdHVyZVVuc3VwcG9ydGVkRXJyb3IgPSBOZXR3b3JrRmVhdHVyZVVuc3VwcG9ydGVkRXJyb3I7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/api_error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/asset.js":
/*!********************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/asset.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Asset = void 0;\nconst decimal_js_1 = __importDefault(__webpack_require__(/*! decimal.js */ \"(rsc)/./node_modules/decimal.js/decimal.js\"));\nconst coinbase_1 = __webpack_require__(/*! ./coinbase */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/coinbase.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/constants.js\");\nconst errors_1 = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/errors.js\");\n/** A representation of an Asset. */\nclass Asset {\n    /**\n     * Private constructor for the Asset class.\n     *\n     * @param networkId - The network ID.\n     * @param assetId - The asset ID.\n     * @param contractAddress - The address ID.\n     * @param decimals - The number of decimals.\n     */\n    constructor(networkId, assetId, contractAddress, decimals) {\n        this.networkId = networkId;\n        this.assetId = assetId;\n        this.contractAddress = contractAddress;\n        this.decimals = decimals;\n    }\n    /**\n     * Creates an Asset from an Asset Model.\n     *\n     * @param model - The Asset Model.\n     * @param assetId - The Asset ID.\n     * @throws If the Asset Model is invalid.\n     * @returns The Asset Class.\n     */\n    static fromModel(model, assetId) {\n        if (!model) {\n            throw new Error(\"Invalid asset model\");\n        }\n        let decimals = model.decimals;\n        // TODO: Push this logic down to the backend.\n        if (assetId && model.asset_id) {\n            const normalizedModelAssetId = model.asset_id.toLowerCase();\n            const normalizedAssetId = assetId.toLowerCase();\n            if (coinbase_1.Coinbase.toAssetId(normalizedModelAssetId) !== coinbase_1.Coinbase.toAssetId(normalizedAssetId)) {\n                switch (normalizedAssetId) {\n                    case \"gwei\":\n                        decimals = constants_1.GWEI_DECIMALS;\n                        break;\n                    case \"wei\":\n                        decimals = 0;\n                        break;\n                    case \"eth\":\n                        break;\n                    default:\n                        throw new errors_1.ArgumentError(`Invalid asset ID: ${assetId}`);\n                }\n            }\n        }\n        return new Asset(model.network_id, assetId ?? model.asset_id, model.contract_address, decimals);\n    }\n    /**\n     * Fetches the Asset with the provided Asset ID.\n     *\n     * @param networkId - The network ID.\n     * @param assetId - The asset ID.\n     * @throws If the Asset cannot be fetched.\n     * @returns The Asset Class.\n     */\n    static async fetch(networkId, assetId) {\n        const asset = await coinbase_1.Coinbase.apiClients.asset.getAsset(coinbase_1.Coinbase.normalizeNetwork(networkId), Asset.primaryDenomination(assetId));\n        return Asset.fromModel(asset?.data, assetId);\n    }\n    /**\n     * Returns the primary denomination for the provided Asset ID.\n     * For `gwei` and `wei` the primary denomination is `eth`.\n     * For all other assets, the primary denomination is the same asset ID.\n     *\n     * @param assetId - The Asset ID.\n     * @returns The primary denomination for the Asset ID.\n     */\n    static primaryDenomination(assetId) {\n        return [coinbase_1.Coinbase.assets.Gwei, coinbase_1.Coinbase.assets.Wei].includes(assetId)\n            ? coinbase_1.Coinbase.assets.Eth\n            : assetId;\n    }\n    /**\n     * Returns the primary denomination for the Asset.\n     *\n     * @returns The primary denomination for the Asset.\n     */\n    primaryDenomination() {\n        return Asset.primaryDenomination(this.assetId);\n    }\n    /**\n     * Converts the amount of the Asset from whole to atomic units.\n     *\n     * @param wholeAmount - The whole amount to convert to atomic units.\n     * @returns The amount in atomic units\n     */\n    toAtomicAmount(wholeAmount) {\n        const atomicAmount = wholeAmount.times(new decimal_js_1.default(10).pow(this.decimals));\n        return BigInt(atomicAmount.toFixed());\n    }\n    /**\n     * Converts the amount of the Asset from atomic to whole units.\n     *\n     * @param atomicAmount - The atomic amount to convert to whole units.\n     * @returns The amount in atomic units\n     */\n    fromAtomicAmount(atomicAmount) {\n        return atomicAmount.dividedBy(new decimal_js_1.default(10).pow(this.decimals));\n    }\n    /**\n     * Returns a string representation of the Asset.\n     *\n     * @returns a string representation of the Asset\n     */\n    toString() {\n        return `Asset{ networkId: ${this.networkId}, assetId: ${this.assetId}, contractAddress: ${this.contractAddress}, decimals: ${this.decimals} }`;\n    }\n    /**\n     * Returns the Asset ID.\n     *\n     * @returns The Asset ID.\n     */\n    getAssetId() {\n        return this.assetId;\n    }\n}\nexports.Asset = Asset;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL2Fzc2V0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYTtBQUNiLHFDQUFxQyxtQkFBTyxDQUFDLDhEQUFZO0FBQ3pELG1CQUFtQixtQkFBTyxDQUFDLHlGQUFZO0FBQ3ZDLG9CQUFvQixtQkFBTyxDQUFDLDJGQUFhO0FBQ3pDLGlCQUFpQixtQkFBTyxDQUFDLHFGQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsUUFBUTtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsYUFBYSxlQUFlLGFBQWEsYUFBYSxxQkFBcUIscUJBQXFCLGNBQWMsZ0JBQWdCO0FBQ3JKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cnZpdmFsLWZ1bi8uL25vZGVfbW9kdWxlcy9AY29pbmJhc2UvY29pbmJhc2Utc2RrL2Rpc3QvY29pbmJhc2UvYXNzZXQuanM/ZDI2ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQXNzZXQgPSB2b2lkIDA7XG5jb25zdCBkZWNpbWFsX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImRlY2ltYWwuanNcIikpO1xuY29uc3QgY29pbmJhc2VfMSA9IHJlcXVpcmUoXCIuL2NvaW5iYXNlXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuL2Vycm9yc1wiKTtcbi8qKiBBIHJlcHJlc2VudGF0aW9uIG9mIGFuIEFzc2V0LiAqL1xuY2xhc3MgQXNzZXQge1xuICAgIC8qKlxuICAgICAqIFByaXZhdGUgY29uc3RydWN0b3IgZm9yIHRoZSBBc3NldCBjbGFzcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuZXR3b3JrSWQgLSBUaGUgbmV0d29yayBJRC5cbiAgICAgKiBAcGFyYW0gYXNzZXRJZCAtIFRoZSBhc3NldCBJRC5cbiAgICAgKiBAcGFyYW0gY29udHJhY3RBZGRyZXNzIC0gVGhlIGFkZHJlc3MgSUQuXG4gICAgICogQHBhcmFtIGRlY2ltYWxzIC0gVGhlIG51bWJlciBvZiBkZWNpbWFscy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihuZXR3b3JrSWQsIGFzc2V0SWQsIGNvbnRyYWN0QWRkcmVzcywgZGVjaW1hbHMpIHtcbiAgICAgICAgdGhpcy5uZXR3b3JrSWQgPSBuZXR3b3JrSWQ7XG4gICAgICAgIHRoaXMuYXNzZXRJZCA9IGFzc2V0SWQ7XG4gICAgICAgIHRoaXMuY29udHJhY3RBZGRyZXNzID0gY29udHJhY3RBZGRyZXNzO1xuICAgICAgICB0aGlzLmRlY2ltYWxzID0gZGVjaW1hbHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gQXNzZXQgZnJvbSBhbiBBc3NldCBNb2RlbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBtb2RlbCAtIFRoZSBBc3NldCBNb2RlbC5cbiAgICAgKiBAcGFyYW0gYXNzZXRJZCAtIFRoZSBBc3NldCBJRC5cbiAgICAgKiBAdGhyb3dzIElmIHRoZSBBc3NldCBNb2RlbCBpcyBpbnZhbGlkLlxuICAgICAqIEByZXR1cm5zIFRoZSBBc3NldCBDbGFzcy5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbU1vZGVsKG1vZGVsLCBhc3NldElkKSB7XG4gICAgICAgIGlmICghbW9kZWwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYXNzZXQgbW9kZWxcIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRlY2ltYWxzID0gbW9kZWwuZGVjaW1hbHM7XG4gICAgICAgIC8vIFRPRE86IFB1c2ggdGhpcyBsb2dpYyBkb3duIHRvIHRoZSBiYWNrZW5kLlxuICAgICAgICBpZiAoYXNzZXRJZCAmJiBtb2RlbC5hc3NldF9pZCkge1xuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZE1vZGVsQXNzZXRJZCA9IG1vZGVsLmFzc2V0X2lkLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemVkQXNzZXRJZCA9IGFzc2V0SWQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGlmIChjb2luYmFzZV8xLkNvaW5iYXNlLnRvQXNzZXRJZChub3JtYWxpemVkTW9kZWxBc3NldElkKSAhPT0gY29pbmJhc2VfMS5Db2luYmFzZS50b0Fzc2V0SWQobm9ybWFsaXplZEFzc2V0SWQpKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChub3JtYWxpemVkQXNzZXRJZCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZ3dlaVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgZGVjaW1hbHMgPSBjb25zdGFudHNfMS5HV0VJX0RFQ0lNQUxTO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ3ZWlcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlY2ltYWxzID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZXRoXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Bcmd1bWVudEVycm9yKGBJbnZhbGlkIGFzc2V0IElEOiAke2Fzc2V0SWR9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQXNzZXQobW9kZWwubmV0d29ya19pZCwgYXNzZXRJZCA/PyBtb2RlbC5hc3NldF9pZCwgbW9kZWwuY29udHJhY3RfYWRkcmVzcywgZGVjaW1hbHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGZXRjaGVzIHRoZSBBc3NldCB3aXRoIHRoZSBwcm92aWRlZCBBc3NldCBJRC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuZXR3b3JrSWQgLSBUaGUgbmV0d29yayBJRC5cbiAgICAgKiBAcGFyYW0gYXNzZXRJZCAtIFRoZSBhc3NldCBJRC5cbiAgICAgKiBAdGhyb3dzIElmIHRoZSBBc3NldCBjYW5ub3QgYmUgZmV0Y2hlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgQXNzZXQgQ2xhc3MuXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIGZldGNoKG5ldHdvcmtJZCwgYXNzZXRJZCkge1xuICAgICAgICBjb25zdCBhc3NldCA9IGF3YWl0IGNvaW5iYXNlXzEuQ29pbmJhc2UuYXBpQ2xpZW50cy5hc3NldC5nZXRBc3NldChjb2luYmFzZV8xLkNvaW5iYXNlLm5vcm1hbGl6ZU5ldHdvcmsobmV0d29ya0lkKSwgQXNzZXQucHJpbWFyeURlbm9taW5hdGlvbihhc3NldElkKSk7XG4gICAgICAgIHJldHVybiBBc3NldC5mcm9tTW9kZWwoYXNzZXQ/LmRhdGEsIGFzc2V0SWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwcmltYXJ5IGRlbm9taW5hdGlvbiBmb3IgdGhlIHByb3ZpZGVkIEFzc2V0IElELlxuICAgICAqIEZvciBgZ3dlaWAgYW5kIGB3ZWlgIHRoZSBwcmltYXJ5IGRlbm9taW5hdGlvbiBpcyBgZXRoYC5cbiAgICAgKiBGb3IgYWxsIG90aGVyIGFzc2V0cywgdGhlIHByaW1hcnkgZGVub21pbmF0aW9uIGlzIHRoZSBzYW1lIGFzc2V0IElELlxuICAgICAqXG4gICAgICogQHBhcmFtIGFzc2V0SWQgLSBUaGUgQXNzZXQgSUQuXG4gICAgICogQHJldHVybnMgVGhlIHByaW1hcnkgZGVub21pbmF0aW9uIGZvciB0aGUgQXNzZXQgSUQuXG4gICAgICovXG4gICAgc3RhdGljIHByaW1hcnlEZW5vbWluYXRpb24oYXNzZXRJZCkge1xuICAgICAgICByZXR1cm4gW2NvaW5iYXNlXzEuQ29pbmJhc2UuYXNzZXRzLkd3ZWksIGNvaW5iYXNlXzEuQ29pbmJhc2UuYXNzZXRzLldlaV0uaW5jbHVkZXMoYXNzZXRJZClcbiAgICAgICAgICAgID8gY29pbmJhc2VfMS5Db2luYmFzZS5hc3NldHMuRXRoXG4gICAgICAgICAgICA6IGFzc2V0SWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHByaW1hcnkgZGVub21pbmF0aW9uIGZvciB0aGUgQXNzZXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgcHJpbWFyeSBkZW5vbWluYXRpb24gZm9yIHRoZSBBc3NldC5cbiAgICAgKi9cbiAgICBwcmltYXJ5RGVub21pbmF0aW9uKCkge1xuICAgICAgICByZXR1cm4gQXNzZXQucHJpbWFyeURlbm9taW5hdGlvbih0aGlzLmFzc2V0SWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgYW1vdW50IG9mIHRoZSBBc3NldCBmcm9tIHdob2xlIHRvIGF0b21pYyB1bml0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB3aG9sZUFtb3VudCAtIFRoZSB3aG9sZSBhbW91bnQgdG8gY29udmVydCB0byBhdG9taWMgdW5pdHMuXG4gICAgICogQHJldHVybnMgVGhlIGFtb3VudCBpbiBhdG9taWMgdW5pdHNcbiAgICAgKi9cbiAgICB0b0F0b21pY0Ftb3VudCh3aG9sZUFtb3VudCkge1xuICAgICAgICBjb25zdCBhdG9taWNBbW91bnQgPSB3aG9sZUFtb3VudC50aW1lcyhuZXcgZGVjaW1hbF9qc18xLmRlZmF1bHQoMTApLnBvdyh0aGlzLmRlY2ltYWxzKSk7XG4gICAgICAgIHJldHVybiBCaWdJbnQoYXRvbWljQW1vdW50LnRvRml4ZWQoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoZSBhbW91bnQgb2YgdGhlIEFzc2V0IGZyb20gYXRvbWljIHRvIHdob2xlIHVuaXRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGF0b21pY0Ftb3VudCAtIFRoZSBhdG9taWMgYW1vdW50IHRvIGNvbnZlcnQgdG8gd2hvbGUgdW5pdHMuXG4gICAgICogQHJldHVybnMgVGhlIGFtb3VudCBpbiBhdG9taWMgdW5pdHNcbiAgICAgKi9cbiAgICBmcm9tQXRvbWljQW1vdW50KGF0b21pY0Ftb3VudCkge1xuICAgICAgICByZXR1cm4gYXRvbWljQW1vdW50LmRpdmlkZWRCeShuZXcgZGVjaW1hbF9qc18xLmRlZmF1bHQoMTApLnBvdyh0aGlzLmRlY2ltYWxzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIEFzc2V0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIEFzc2V0XG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBgQXNzZXR7IG5ldHdvcmtJZDogJHt0aGlzLm5ldHdvcmtJZH0sIGFzc2V0SWQ6ICR7dGhpcy5hc3NldElkfSwgY29udHJhY3RBZGRyZXNzOiAke3RoaXMuY29udHJhY3RBZGRyZXNzfSwgZGVjaW1hbHM6ICR7dGhpcy5kZWNpbWFsc30gfWA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIEFzc2V0IElELlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIEFzc2V0IElELlxuICAgICAqL1xuICAgIGdldEFzc2V0SWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFzc2V0SWQ7XG4gICAgfVxufVxuZXhwb3J0cy5Bc3NldCA9IEFzc2V0O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/asset.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/authenticator.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/authenticator.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CoinbaseAuthenticator = void 0;\nconst crypto_1 = __webpack_require__(/*! crypto */ \"crypto\");\nconst jose_1 = __webpack_require__(/*! jose */ \"(rsc)/./node_modules/jose/dist/node/cjs/index.js\");\nconst errors_1 = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/errors.js\");\nconst package_json_1 = __webpack_require__(/*! ../../package.json */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/package.json\");\nconst pemFooter = \"-----END EC PRIVATE KEY-----\";\n/**\n * A class that builds JWTs for authenticating with the Coinbase Platform APIs.\n */\nclass CoinbaseAuthenticator {\n    /**\n     * Initializes the Authenticator.\n     *\n     * @param {string} apiKey - The API key name.\n     * @param {string} privateKey - The private key associated with the API key.\n     * @param {string} source - The source of the request.\n     * @param {string} [sourceVersion] - The version of the source.\n     */\n    constructor(apiKey, privateKey, source, sourceVersion) {\n        this.apiKey = apiKey;\n        this.privateKey = privateKey;\n        this.source = source;\n        this.sourceVersion = sourceVersion;\n    }\n    /**\n     * Middleware to intercept requests and add JWT to the Authorization header.\n     *\n     * @param {InternalAxiosRequestConfig} config - The request configuration.\n     * @param {boolean} [debugging] - Flag to enable debugging.\n     * @returns {Promise<InternalAxiosRequestConfig>} The modified request configuration with the Authorization header added.\n     * @throws {InvalidAPIKeyFormatError} If JWT could not be built.\n     */\n    async authenticateRequest(config, debugging = false) {\n        const method = config.method?.toString().toUpperCase();\n        const token = await this.buildJWT(config.url || \"\", method);\n        if (debugging) {\n            console.log(`API REQUEST: ${method} ${config.url}`);\n        }\n        config.headers[\"Authorization\"] = `Bearer ${token}`;\n        config.headers[\"Content-Type\"] = \"application/json\";\n        config.headers[\"Correlation-Context\"] = this.getCorrelationData();\n        return config;\n    }\n    /**\n     * Builds the JWT for the given API endpoint URL.\n     *\n     * @param {string} url - URL of the API endpoint.\n     * @param {string} [method] - HTTP method of the request.\n     * @returns {Promise<string>} A JWT token.\n     * @throws {InvalidAPIKeyFormatError} If the private key is not in the correct format or signing fails.\n     */\n    async buildJWT(url, method = \"GET\") {\n        const urlObject = new URL(url);\n        const uri = `${method} ${urlObject.host}${urlObject.pathname}`;\n        const now = Math.floor(Date.now() / 1000);\n        const claims = {\n            sub: this.apiKey,\n            iss: \"cdp\",\n            aud: [\"cdp_service\"],\n            uris: [uri],\n        };\n        if (this.privateKey.startsWith(\"-----BEGIN\")) {\n            return this.buildECJWT(claims, now);\n        }\n        else {\n            return this.buildEdwardsJWT(claims, now);\n        }\n    }\n    /**\n     * Builds a JWT using an EC key.\n     *\n     * @param {JWTPayload} claims - The JWT claims.\n     * @param {number} now - The current timestamp (in seconds).\n     * @returns {Promise<string>} A JWT token signed with an EC key.\n     * @throws {InvalidAPIKeyFormatError} If the key conversion, import, or signing fails.\n     */\n    async buildECJWT(claims, now) {\n        // Ensure the PEM is valid and let jose import it.\n        const pemPrivateKey = this.extractPemKey(this.privateKey);\n        let pkcs8Key;\n        try {\n            const keyObj = (0, crypto_1.createPrivateKey)(pemPrivateKey);\n            pkcs8Key = keyObj.export({ type: \"pkcs8\", format: \"pem\" }).toString();\n        }\n        catch (error) {\n            throw new errors_1.InvalidAPIKeyFormatError(\"Could not convert the EC private key to PKCS8 format\");\n        }\n        let ecKey;\n        try {\n            ecKey = await (0, jose_1.importPKCS8)(pkcs8Key, \"ES256\");\n        }\n        catch (error) {\n            throw new errors_1.InvalidAPIKeyFormatError(\"Could not import the EC private key\");\n        }\n        try {\n            return await new jose_1.SignJWT(claims)\n                .setProtectedHeader({ alg: \"ES256\", kid: this.apiKey, typ: \"JWT\", nonce: this.nonce() })\n                .setIssuedAt(now)\n                .setNotBefore(now)\n                .setExpirationTime(now + 60)\n                .sign(ecKey);\n        }\n        catch (err) {\n            throw new errors_1.InvalidAPIKeyFormatError(\"Could not sign the JWT with the EC key\");\n        }\n    }\n    /**\n     * Builds a JWT using an Ed25519 key.\n     *\n     * @param {JWTPayload} claims - The JWT claims.\n     * @param {number} now - The current timestamp (in seconds).\n     * @returns {Promise<string>} A JWT token signed with an Ed25519 key.\n     * @throws {InvalidAPIKeyFormatError} If the key parsing, import, or signing fails.\n     */\n    async buildEdwardsJWT(claims, now) {\n        // Expect a base64 encoded 64-byte string (32 bytes seed + 32 bytes public key)\n        const decoded = Buffer.from(this.privateKey, \"base64\");\n        if (decoded.length !== 64) {\n            throw new errors_1.InvalidAPIKeyFormatError(\"Could not parse the private key\");\n        }\n        const seed = decoded.subarray(0, 32);\n        const publicKey = decoded.subarray(32);\n        const jwk = {\n            kty: \"OKP\",\n            crv: \"Ed25519\",\n            d: seed.toString(\"base64url\"),\n            x: publicKey.toString(\"base64url\"),\n        };\n        let key;\n        try {\n            key = await (0, jose_1.importJWK)(jwk, \"EdDSA\");\n        }\n        catch (error) {\n            throw new errors_1.InvalidAPIKeyFormatError(\"Could not import the Ed25519 private key\");\n        }\n        try {\n            return await new jose_1.SignJWT(claims)\n                .setProtectedHeader({ alg: \"EdDSA\", kid: this.apiKey, typ: \"JWT\", nonce: this.nonce() })\n                .setIssuedAt(now)\n                .setNotBefore(now)\n                .setExpirationTime(now + 60)\n                .sign(key);\n        }\n        catch (err) {\n            throw new errors_1.InvalidAPIKeyFormatError(\"Could not sign the JWT with the Ed25519 key\");\n        }\n    }\n    /**\n     * Extracts and verifies the PEM key from the given private key string.\n     *\n     * @param {string} privateKeyString - The private key string.\n     * @returns {string} The original PEM key string if valid.\n     * @throws {InvalidAPIKeyFormatError} If the private key string is not in the correct PEM format.\n     */\n    extractPemKey(privateKeyString) {\n        if (privateKeyString.includes(\"-----BEGIN EC PRIVATE KEY-----\") &&\n            privateKeyString.includes(pemFooter)) {\n            return privateKeyString;\n        }\n        throw new errors_1.InvalidAPIKeyFormatError(\"Invalid private key format\");\n    }\n    /**\n     * Generates a random nonce for the JWT.\n     *\n     * @returns {string} The generated nonce.\n     */\n    nonce() {\n        const range = \"0123456789\";\n        let result = \"\";\n        for (let i = 0; i < 16; i++) {\n            result += range.charAt(Math.floor(Math.random() * range.length));\n        }\n        return result;\n    }\n    /**\n     * Returns encoded correlation data including the SDK version and language.\n     *\n     * @returns {string} Encoded correlation data as a query string.\n     */\n    getCorrelationData() {\n        const data = {\n            sdk_version: package_json_1.version,\n            sdk_language: \"typescript\",\n            source: this.source,\n        };\n        if (this.sourceVersion) {\n            data[\"source_version\"] = this.sourceVersion;\n        }\n        return Object.keys(data)\n            .map(key => `${key}=${encodeURIComponent(data[key])}`)\n            .join(\",\");\n    }\n}\nexports.CoinbaseAuthenticator = CoinbaseAuthenticator;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL2F1dGhlbnRpY2F0b3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNkJBQTZCO0FBQzdCLGlCQUFpQixtQkFBTyxDQUFDLHNCQUFRO0FBQ2pDLGVBQWUsbUJBQU8sQ0FBQyw4REFBTTtBQUM3QixpQkFBaUIsbUJBQU8sQ0FBQyxxRkFBVTtBQUNuQyx1QkFBdUIsbUJBQU8sQ0FBQyxvRkFBb0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNEJBQTRCO0FBQzNDLGVBQWUsU0FBUztBQUN4QixpQkFBaUIscUNBQXFDO0FBQ3RELGdCQUFnQiwwQkFBMEI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxRQUFRLEVBQUUsV0FBVztBQUM3RDtBQUNBLG9EQUFvRCxNQUFNO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsaUJBQWlCO0FBQ2xDLGdCQUFnQiwwQkFBMEI7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFFBQVEsRUFBRSxlQUFlLEVBQUUsbUJBQW1CO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0IsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixpQkFBaUI7QUFDbEMsZ0JBQWdCLDBCQUEwQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyw4QkFBOEI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsaUVBQWlFO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLGlCQUFpQjtBQUNsQyxnQkFBZ0IsMEJBQTBCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxpRUFBaUU7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixRQUFRO0FBQ3pCLGdCQUFnQiwwQkFBMEI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLElBQUksR0FBRyw4QkFBOEI7QUFDaEU7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3Vydml2YWwtZnVuLy4vbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9jb2luYmFzZS1zZGsvZGlzdC9jb2luYmFzZS9hdXRoZW50aWNhdG9yLmpzPzQ4MzQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvaW5iYXNlQXV0aGVudGljYXRvciA9IHZvaWQgMDtcbmNvbnN0IGNyeXB0b18xID0gcmVxdWlyZShcImNyeXB0b1wiKTtcbmNvbnN0IGpvc2VfMSA9IHJlcXVpcmUoXCJqb3NlXCIpO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi9lcnJvcnNcIik7XG5jb25zdCBwYWNrYWdlX2pzb25fMSA9IHJlcXVpcmUoXCIuLi8uLi9wYWNrYWdlLmpzb25cIik7XG5jb25zdCBwZW1Gb290ZXIgPSBcIi0tLS0tRU5EIEVDIFBSSVZBVEUgS0VZLS0tLS1cIjtcbi8qKlxuICogQSBjbGFzcyB0aGF0IGJ1aWxkcyBKV1RzIGZvciBhdXRoZW50aWNhdGluZyB3aXRoIHRoZSBDb2luYmFzZSBQbGF0Zm9ybSBBUElzLlxuICovXG5jbGFzcyBDb2luYmFzZUF1dGhlbnRpY2F0b3Ige1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSBBdXRoZW50aWNhdG9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFwaUtleSAtIFRoZSBBUEkga2V5IG5hbWUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByaXZhdGVLZXkgLSBUaGUgcHJpdmF0ZSBrZXkgYXNzb2NpYXRlZCB3aXRoIHRoZSBBUEkga2V5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2UgLSBUaGUgc291cmNlIG9mIHRoZSByZXF1ZXN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc291cmNlVmVyc2lvbl0gLSBUaGUgdmVyc2lvbiBvZiB0aGUgc291cmNlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGFwaUtleSwgcHJpdmF0ZUtleSwgc291cmNlLCBzb3VyY2VWZXJzaW9uKSB7XG4gICAgICAgIHRoaXMuYXBpS2V5ID0gYXBpS2V5O1xuICAgICAgICB0aGlzLnByaXZhdGVLZXkgPSBwcml2YXRlS2V5O1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgdGhpcy5zb3VyY2VWZXJzaW9uID0gc291cmNlVmVyc2lvbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWlkZGxld2FyZSB0byBpbnRlcmNlcHQgcmVxdWVzdHMgYW5kIGFkZCBKV1QgdG8gdGhlIEF1dGhvcml6YXRpb24gaGVhZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtJbnRlcm5hbEF4aW9zUmVxdWVzdENvbmZpZ30gY29uZmlnIC0gVGhlIHJlcXVlc3QgY29uZmlndXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtkZWJ1Z2dpbmddIC0gRmxhZyB0byBlbmFibGUgZGVidWdnaW5nLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEludGVybmFsQXhpb3NSZXF1ZXN0Q29uZmlnPn0gVGhlIG1vZGlmaWVkIHJlcXVlc3QgY29uZmlndXJhdGlvbiB3aXRoIHRoZSBBdXRob3JpemF0aW9uIGhlYWRlciBhZGRlZC5cbiAgICAgKiBAdGhyb3dzIHtJbnZhbGlkQVBJS2V5Rm9ybWF0RXJyb3J9IElmIEpXVCBjb3VsZCBub3QgYmUgYnVpbHQuXG4gICAgICovXG4gICAgYXN5bmMgYXV0aGVudGljYXRlUmVxdWVzdChjb25maWcsIGRlYnVnZ2luZyA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9IGNvbmZpZy5tZXRob2Q/LnRvU3RyaW5nKCkudG9VcHBlckNhc2UoKTtcbiAgICAgICAgY29uc3QgdG9rZW4gPSBhd2FpdCB0aGlzLmJ1aWxkSldUKGNvbmZpZy51cmwgfHwgXCJcIiwgbWV0aG9kKTtcbiAgICAgICAgaWYgKGRlYnVnZ2luZykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYEFQSSBSRVFVRVNUOiAke21ldGhvZH0gJHtjb25maWcudXJsfWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbmZpZy5oZWFkZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IGBCZWFyZXIgJHt0b2tlbn1gO1xuICAgICAgICBjb25maWcuaGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXSA9IFwiYXBwbGljYXRpb24vanNvblwiO1xuICAgICAgICBjb25maWcuaGVhZGVyc1tcIkNvcnJlbGF0aW9uLUNvbnRleHRcIl0gPSB0aGlzLmdldENvcnJlbGF0aW9uRGF0YSgpO1xuICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCdWlsZHMgdGhlIEpXVCBmb3IgdGhlIGdpdmVuIEFQSSBlbmRwb2ludCBVUkwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIC0gVVJMIG9mIHRoZSBBUEkgZW5kcG9pbnQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFttZXRob2RdIC0gSFRUUCBtZXRob2Qgb2YgdGhlIHJlcXVlc3QuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn0gQSBKV1QgdG9rZW4uXG4gICAgICogQHRocm93cyB7SW52YWxpZEFQSUtleUZvcm1hdEVycm9yfSBJZiB0aGUgcHJpdmF0ZSBrZXkgaXMgbm90IGluIHRoZSBjb3JyZWN0IGZvcm1hdCBvciBzaWduaW5nIGZhaWxzLlxuICAgICAqL1xuICAgIGFzeW5jIGJ1aWxkSldUKHVybCwgbWV0aG9kID0gXCJHRVRcIikge1xuICAgICAgICBjb25zdCB1cmxPYmplY3QgPSBuZXcgVVJMKHVybCk7XG4gICAgICAgIGNvbnN0IHVyaSA9IGAke21ldGhvZH0gJHt1cmxPYmplY3QuaG9zdH0ke3VybE9iamVjdC5wYXRobmFtZX1gO1xuICAgICAgICBjb25zdCBub3cgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKTtcbiAgICAgICAgY29uc3QgY2xhaW1zID0ge1xuICAgICAgICAgICAgc3ViOiB0aGlzLmFwaUtleSxcbiAgICAgICAgICAgIGlzczogXCJjZHBcIixcbiAgICAgICAgICAgIGF1ZDogW1wiY2RwX3NlcnZpY2VcIl0sXG4gICAgICAgICAgICB1cmlzOiBbdXJpXSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMucHJpdmF0ZUtleS5zdGFydHNXaXRoKFwiLS0tLS1CRUdJTlwiKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnVpbGRFQ0pXVChjbGFpbXMsIG5vdyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5idWlsZEVkd2FyZHNKV1QoY2xhaW1zLCBub3cpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJ1aWxkcyBhIEpXVCB1c2luZyBhbiBFQyBrZXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0pXVFBheWxvYWR9IGNsYWltcyAtIFRoZSBKV1QgY2xhaW1zLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBub3cgLSBUaGUgY3VycmVudCB0aW1lc3RhbXAgKGluIHNlY29uZHMpLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59IEEgSldUIHRva2VuIHNpZ25lZCB3aXRoIGFuIEVDIGtleS5cbiAgICAgKiBAdGhyb3dzIHtJbnZhbGlkQVBJS2V5Rm9ybWF0RXJyb3J9IElmIHRoZSBrZXkgY29udmVyc2lvbiwgaW1wb3J0LCBvciBzaWduaW5nIGZhaWxzLlxuICAgICAqL1xuICAgIGFzeW5jIGJ1aWxkRUNKV1QoY2xhaW1zLCBub3cpIHtcbiAgICAgICAgLy8gRW5zdXJlIHRoZSBQRU0gaXMgdmFsaWQgYW5kIGxldCBqb3NlIGltcG9ydCBpdC5cbiAgICAgICAgY29uc3QgcGVtUHJpdmF0ZUtleSA9IHRoaXMuZXh0cmFjdFBlbUtleSh0aGlzLnByaXZhdGVLZXkpO1xuICAgICAgICBsZXQgcGtjczhLZXk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBrZXlPYmogPSAoMCwgY3J5cHRvXzEuY3JlYXRlUHJpdmF0ZUtleSkocGVtUHJpdmF0ZUtleSk7XG4gICAgICAgICAgICBwa2NzOEtleSA9IGtleU9iai5leHBvcnQoeyB0eXBlOiBcInBrY3M4XCIsIGZvcm1hdDogXCJwZW1cIiB9KS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkludmFsaWRBUElLZXlGb3JtYXRFcnJvcihcIkNvdWxkIG5vdCBjb252ZXJ0IHRoZSBFQyBwcml2YXRlIGtleSB0byBQS0NTOCBmb3JtYXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGVjS2V5O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZWNLZXkgPSBhd2FpdCAoMCwgam9zZV8xLmltcG9ydFBLQ1M4KShwa2NzOEtleSwgXCJFUzI1NlwiKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5JbnZhbGlkQVBJS2V5Rm9ybWF0RXJyb3IoXCJDb3VsZCBub3QgaW1wb3J0IHRoZSBFQyBwcml2YXRlIGtleVwiKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IG5ldyBqb3NlXzEuU2lnbkpXVChjbGFpbXMpXG4gICAgICAgICAgICAgICAgLnNldFByb3RlY3RlZEhlYWRlcih7IGFsZzogXCJFUzI1NlwiLCBraWQ6IHRoaXMuYXBpS2V5LCB0eXA6IFwiSldUXCIsIG5vbmNlOiB0aGlzLm5vbmNlKCkgfSlcbiAgICAgICAgICAgICAgICAuc2V0SXNzdWVkQXQobm93KVxuICAgICAgICAgICAgICAgIC5zZXROb3RCZWZvcmUobm93KVxuICAgICAgICAgICAgICAgIC5zZXRFeHBpcmF0aW9uVGltZShub3cgKyA2MClcbiAgICAgICAgICAgICAgICAuc2lnbihlY0tleSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkludmFsaWRBUElLZXlGb3JtYXRFcnJvcihcIkNvdWxkIG5vdCBzaWduIHRoZSBKV1Qgd2l0aCB0aGUgRUMga2V5XCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJ1aWxkcyBhIEpXVCB1c2luZyBhbiBFZDI1NTE5IGtleS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SldUUGF5bG9hZH0gY2xhaW1zIC0gVGhlIEpXVCBjbGFpbXMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG5vdyAtIFRoZSBjdXJyZW50IHRpbWVzdGFtcCAoaW4gc2Vjb25kcykuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn0gQSBKV1QgdG9rZW4gc2lnbmVkIHdpdGggYW4gRWQyNTUxOSBrZXkuXG4gICAgICogQHRocm93cyB7SW52YWxpZEFQSUtleUZvcm1hdEVycm9yfSBJZiB0aGUga2V5IHBhcnNpbmcsIGltcG9ydCwgb3Igc2lnbmluZyBmYWlscy5cbiAgICAgKi9cbiAgICBhc3luYyBidWlsZEVkd2FyZHNKV1QoY2xhaW1zLCBub3cpIHtcbiAgICAgICAgLy8gRXhwZWN0IGEgYmFzZTY0IGVuY29kZWQgNjQtYnl0ZSBzdHJpbmcgKDMyIGJ5dGVzIHNlZWQgKyAzMiBieXRlcyBwdWJsaWMga2V5KVxuICAgICAgICBjb25zdCBkZWNvZGVkID0gQnVmZmVyLmZyb20odGhpcy5wcml2YXRlS2V5LCBcImJhc2U2NFwiKTtcbiAgICAgICAgaWYgKGRlY29kZWQubGVuZ3RoICE9PSA2NCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkludmFsaWRBUElLZXlGb3JtYXRFcnJvcihcIkNvdWxkIG5vdCBwYXJzZSB0aGUgcHJpdmF0ZSBrZXlcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VlZCA9IGRlY29kZWQuc3ViYXJyYXkoMCwgMzIpO1xuICAgICAgICBjb25zdCBwdWJsaWNLZXkgPSBkZWNvZGVkLnN1YmFycmF5KDMyKTtcbiAgICAgICAgY29uc3QgandrID0ge1xuICAgICAgICAgICAga3R5OiBcIk9LUFwiLFxuICAgICAgICAgICAgY3J2OiBcIkVkMjU1MTlcIixcbiAgICAgICAgICAgIGQ6IHNlZWQudG9TdHJpbmcoXCJiYXNlNjR1cmxcIiksXG4gICAgICAgICAgICB4OiBwdWJsaWNLZXkudG9TdHJpbmcoXCJiYXNlNjR1cmxcIiksXG4gICAgICAgIH07XG4gICAgICAgIGxldCBrZXk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBrZXkgPSBhd2FpdCAoMCwgam9zZV8xLmltcG9ydEpXSykoandrLCBcIkVkRFNBXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkludmFsaWRBUElLZXlGb3JtYXRFcnJvcihcIkNvdWxkIG5vdCBpbXBvcnQgdGhlIEVkMjU1MTkgcHJpdmF0ZSBrZXlcIik7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBuZXcgam9zZV8xLlNpZ25KV1QoY2xhaW1zKVxuICAgICAgICAgICAgICAgIC5zZXRQcm90ZWN0ZWRIZWFkZXIoeyBhbGc6IFwiRWREU0FcIiwga2lkOiB0aGlzLmFwaUtleSwgdHlwOiBcIkpXVFwiLCBub25jZTogdGhpcy5ub25jZSgpIH0pXG4gICAgICAgICAgICAgICAgLnNldElzc3VlZEF0KG5vdylcbiAgICAgICAgICAgICAgICAuc2V0Tm90QmVmb3JlKG5vdylcbiAgICAgICAgICAgICAgICAuc2V0RXhwaXJhdGlvblRpbWUobm93ICsgNjApXG4gICAgICAgICAgICAgICAgLnNpZ24oa2V5KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuSW52YWxpZEFQSUtleUZvcm1hdEVycm9yKFwiQ291bGQgbm90IHNpZ24gdGhlIEpXVCB3aXRoIHRoZSBFZDI1NTE5IGtleVwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeHRyYWN0cyBhbmQgdmVyaWZpZXMgdGhlIFBFTSBrZXkgZnJvbSB0aGUgZ2l2ZW4gcHJpdmF0ZSBrZXkgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByaXZhdGVLZXlTdHJpbmcgLSBUaGUgcHJpdmF0ZSBrZXkgc3RyaW5nLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBvcmlnaW5hbCBQRU0ga2V5IHN0cmluZyBpZiB2YWxpZC5cbiAgICAgKiBAdGhyb3dzIHtJbnZhbGlkQVBJS2V5Rm9ybWF0RXJyb3J9IElmIHRoZSBwcml2YXRlIGtleSBzdHJpbmcgaXMgbm90IGluIHRoZSBjb3JyZWN0IFBFTSBmb3JtYXQuXG4gICAgICovXG4gICAgZXh0cmFjdFBlbUtleShwcml2YXRlS2V5U3RyaW5nKSB7XG4gICAgICAgIGlmIChwcml2YXRlS2V5U3RyaW5nLmluY2x1ZGVzKFwiLS0tLS1CRUdJTiBFQyBQUklWQVRFIEtFWS0tLS0tXCIpICYmXG4gICAgICAgICAgICBwcml2YXRlS2V5U3RyaW5nLmluY2x1ZGVzKHBlbUZvb3RlcikpIHtcbiAgICAgICAgICAgIHJldHVybiBwcml2YXRlS2V5U3RyaW5nO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5JbnZhbGlkQVBJS2V5Rm9ybWF0RXJyb3IoXCJJbnZhbGlkIHByaXZhdGUga2V5IGZvcm1hdFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgcmFuZG9tIG5vbmNlIGZvciB0aGUgSldULlxuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGdlbmVyYXRlZCBub25jZS5cbiAgICAgKi9cbiAgICBub25jZSgpIHtcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBcIjAxMjM0NTY3ODlcIjtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0ICs9IHJhbmdlLmNoYXJBdChNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiByYW5nZS5sZW5ndGgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGVuY29kZWQgY29ycmVsYXRpb24gZGF0YSBpbmNsdWRpbmcgdGhlIFNESyB2ZXJzaW9uIGFuZCBsYW5ndWFnZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IEVuY29kZWQgY29ycmVsYXRpb24gZGF0YSBhcyBhIHF1ZXJ5IHN0cmluZy5cbiAgICAgKi9cbiAgICBnZXRDb3JyZWxhdGlvbkRhdGEoKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgICAgICBzZGtfdmVyc2lvbjogcGFja2FnZV9qc29uXzEudmVyc2lvbixcbiAgICAgICAgICAgIHNka19sYW5ndWFnZTogXCJ0eXBlc2NyaXB0XCIsXG4gICAgICAgICAgICBzb3VyY2U6IHRoaXMuc291cmNlLFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5zb3VyY2VWZXJzaW9uKSB7XG4gICAgICAgICAgICBkYXRhW1wic291cmNlX3ZlcnNpb25cIl0gPSB0aGlzLnNvdXJjZVZlcnNpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGRhdGEpXG4gICAgICAgICAgICAubWFwKGtleSA9PiBgJHtrZXl9PSR7ZW5jb2RlVVJJQ29tcG9uZW50KGRhdGFba2V5XSl9YClcbiAgICAgICAgICAgIC5qb2luKFwiLFwiKTtcbiAgICB9XG59XG5leHBvcnRzLkNvaW5iYXNlQXV0aGVudGljYXRvciA9IENvaW5iYXNlQXV0aGVudGljYXRvcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/authenticator.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/balance.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/balance.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Balance = void 0;\nconst decimal_js_1 = __importDefault(__webpack_require__(/*! decimal.js */ \"(rsc)/./node_modules/decimal.js/decimal.js\"));\nconst asset_1 = __webpack_require__(/*! ./asset */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/asset.js\");\n/** A representation of a balance. */\nclass Balance {\n    /**\n     * Private constructor to prevent direct instantiation outside of the factory methods.\n     *\n     * @ignore\n     * @param {Decimal} amount - The amount of the balance.\n     * @param {string} assetId - The asset ID.\n     * @hideconstructor\n     */\n    constructor(amount, assetId, asset) {\n        this.amount = amount;\n        this.assetId = assetId;\n        this.asset = asset;\n    }\n    /**\n     * Converts a BalanceModel into a Balance object.\n     *\n     * @param {BalanceModel} model - The balance model object.\n     * @returns {Balance} The Balance object.\n     */\n    static fromModel(model) {\n        const asset = asset_1.Asset.fromModel(model.asset);\n        return new Balance(asset.fromAtomicAmount(new decimal_js_1.default(model.amount)), asset.getAssetId(), asset);\n    }\n    /**\n     * Converts a BalanceModel and asset ID into a Balance object.\n     *\n     * @param {BalanceModel} model - The balance model object.\n     * @param {string} assetId - The asset ID.\n     * @returns {Balance} The Balance object.\n     */\n    static fromModelAndAssetId(model, assetId) {\n        const asset = asset_1.Asset.fromModel(model.asset, assetId);\n        return new Balance(asset.fromAtomicAmount(new decimal_js_1.default(model.amount)), asset.getAssetId(), asset);\n    }\n}\nexports.Balance = Balance;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL2JhbGFuY2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxlQUFlO0FBQ2YscUNBQXFDLG1CQUFPLENBQUMsOERBQVk7QUFDekQsZ0JBQWdCLG1CQUFPLENBQUMsbUZBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3Vydml2YWwtZnVuLy4vbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9jb2luYmFzZS1zZGsvZGlzdC9jb2luYmFzZS9iYWxhbmNlLmpzPzQ0NTEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJhbGFuY2UgPSB2b2lkIDA7XG5jb25zdCBkZWNpbWFsX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImRlY2ltYWwuanNcIikpO1xuY29uc3QgYXNzZXRfMSA9IHJlcXVpcmUoXCIuL2Fzc2V0XCIpO1xuLyoqIEEgcmVwcmVzZW50YXRpb24gb2YgYSBiYWxhbmNlLiAqL1xuY2xhc3MgQmFsYW5jZSB7XG4gICAgLyoqXG4gICAgICogUHJpdmF0ZSBjb25zdHJ1Y3RvciB0byBwcmV2ZW50IGRpcmVjdCBpbnN0YW50aWF0aW9uIG91dHNpZGUgb2YgdGhlIGZhY3RvcnkgbWV0aG9kcy5cbiAgICAgKlxuICAgICAqIEBpZ25vcmVcbiAgICAgKiBAcGFyYW0ge0RlY2ltYWx9IGFtb3VudCAtIFRoZSBhbW91bnQgb2YgdGhlIGJhbGFuY2UuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFzc2V0SWQgLSBUaGUgYXNzZXQgSUQuXG4gICAgICogQGhpZGVjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGFtb3VudCwgYXNzZXRJZCwgYXNzZXQpIHtcbiAgICAgICAgdGhpcy5hbW91bnQgPSBhbW91bnQ7XG4gICAgICAgIHRoaXMuYXNzZXRJZCA9IGFzc2V0SWQ7XG4gICAgICAgIHRoaXMuYXNzZXQgPSBhc3NldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBCYWxhbmNlTW9kZWwgaW50byBhIEJhbGFuY2Ugb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtCYWxhbmNlTW9kZWx9IG1vZGVsIC0gVGhlIGJhbGFuY2UgbW9kZWwgb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtCYWxhbmNlfSBUaGUgQmFsYW5jZSBvYmplY3QuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21Nb2RlbChtb2RlbCkge1xuICAgICAgICBjb25zdCBhc3NldCA9IGFzc2V0XzEuQXNzZXQuZnJvbU1vZGVsKG1vZGVsLmFzc2V0KTtcbiAgICAgICAgcmV0dXJuIG5ldyBCYWxhbmNlKGFzc2V0LmZyb21BdG9taWNBbW91bnQobmV3IGRlY2ltYWxfanNfMS5kZWZhdWx0KG1vZGVsLmFtb3VudCkpLCBhc3NldC5nZXRBc3NldElkKCksIGFzc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBCYWxhbmNlTW9kZWwgYW5kIGFzc2V0IElEIGludG8gYSBCYWxhbmNlIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QmFsYW5jZU1vZGVsfSBtb2RlbCAtIFRoZSBiYWxhbmNlIG1vZGVsIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXNzZXRJZCAtIFRoZSBhc3NldCBJRC5cbiAgICAgKiBAcmV0dXJucyB7QmFsYW5jZX0gVGhlIEJhbGFuY2Ugb2JqZWN0LlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tTW9kZWxBbmRBc3NldElkKG1vZGVsLCBhc3NldElkKSB7XG4gICAgICAgIGNvbnN0IGFzc2V0ID0gYXNzZXRfMS5Bc3NldC5mcm9tTW9kZWwobW9kZWwuYXNzZXQsIGFzc2V0SWQpO1xuICAgICAgICByZXR1cm4gbmV3IEJhbGFuY2UoYXNzZXQuZnJvbUF0b21pY0Ftb3VudChuZXcgZGVjaW1hbF9qc18xLmRlZmF1bHQobW9kZWwuYW1vdW50KSksIGFzc2V0LmdldEFzc2V0SWQoKSwgYXNzZXQpO1xuICAgIH1cbn1cbmV4cG9ydHMuQmFsYW5jZSA9IEJhbGFuY2U7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/balance.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/balance_map.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/balance_map.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BalanceMap = void 0;\nconst balance_1 = __webpack_require__(/*! ./balance */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/balance.js\");\n/**\n * A convenience class for storing and manipulating Asset balances in a human-readable format.\n */\nclass BalanceMap extends Map {\n    /**\n     * Converts a list of Balance models to a BalanceMap.\n     *\n     * @param {BalanceModel[]} balances - The list of balances fetched from the API.\n     * @returns {BalanceMap} The converted BalanceMap object.\n     */\n    static fromBalances(balances) {\n        const balanceMap = new BalanceMap();\n        balances.forEach(balanceModel => {\n            const balance = balance_1.Balance.fromModel(balanceModel);\n            balanceMap.add(balance);\n        });\n        return balanceMap;\n    }\n    /**\n     * Adds a balance to the map.\n     *\n     * @param {Balance} balance - The balance to add to the map.\n     */\n    add(balance) {\n        if (!(balance instanceof balance_1.Balance)) {\n            throw new Error(\"balance must be a Balance\");\n        }\n        this.set(balance.assetId, balance.amount);\n    }\n    /**\n     * Returns a string representation of the balance map.\n     *\n     * @returns The string representation of the balance map.\n     */\n    toString() {\n        const result = {};\n        this.forEach((value, key) => {\n            let str = value.toString();\n            if (value.isInteger()) {\n                str = value.toNumber().toString();\n            }\n            result[key] = str;\n        });\n        return `BalanceMap${JSON.stringify(result)}`;\n    }\n}\nexports.BalanceMap = BalanceMap;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL2JhbGFuY2VfbWFwLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQjtBQUNsQixrQkFBa0IsbUJBQU8sQ0FBQyx1RkFBVztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCO0FBQy9CLGlCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsNEJBQTRCLHVCQUF1QjtBQUNuRDtBQUNBO0FBQ0Esa0JBQWtCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3Vydml2YWwtZnVuLy4vbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9jb2luYmFzZS1zZGsvZGlzdC9jb2luYmFzZS9iYWxhbmNlX21hcC5qcz9jMzAxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CYWxhbmNlTWFwID0gdm9pZCAwO1xuY29uc3QgYmFsYW5jZV8xID0gcmVxdWlyZShcIi4vYmFsYW5jZVwiKTtcbi8qKlxuICogQSBjb252ZW5pZW5jZSBjbGFzcyBmb3Igc3RvcmluZyBhbmQgbWFuaXB1bGF0aW5nIEFzc2V0IGJhbGFuY2VzIGluIGEgaHVtYW4tcmVhZGFibGUgZm9ybWF0LlxuICovXG5jbGFzcyBCYWxhbmNlTWFwIGV4dGVuZHMgTWFwIHtcbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIGxpc3Qgb2YgQmFsYW5jZSBtb2RlbHMgdG8gYSBCYWxhbmNlTWFwLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtCYWxhbmNlTW9kZWxbXX0gYmFsYW5jZXMgLSBUaGUgbGlzdCBvZiBiYWxhbmNlcyBmZXRjaGVkIGZyb20gdGhlIEFQSS5cbiAgICAgKiBAcmV0dXJucyB7QmFsYW5jZU1hcH0gVGhlIGNvbnZlcnRlZCBCYWxhbmNlTWFwIG9iamVjdC5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUJhbGFuY2VzKGJhbGFuY2VzKSB7XG4gICAgICAgIGNvbnN0IGJhbGFuY2VNYXAgPSBuZXcgQmFsYW5jZU1hcCgpO1xuICAgICAgICBiYWxhbmNlcy5mb3JFYWNoKGJhbGFuY2VNb2RlbCA9PiB7XG4gICAgICAgICAgICBjb25zdCBiYWxhbmNlID0gYmFsYW5jZV8xLkJhbGFuY2UuZnJvbU1vZGVsKGJhbGFuY2VNb2RlbCk7XG4gICAgICAgICAgICBiYWxhbmNlTWFwLmFkZChiYWxhbmNlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBiYWxhbmNlTWFwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgYmFsYW5jZSB0byB0aGUgbWFwLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtCYWxhbmNlfSBiYWxhbmNlIC0gVGhlIGJhbGFuY2UgdG8gYWRkIHRvIHRoZSBtYXAuXG4gICAgICovXG4gICAgYWRkKGJhbGFuY2UpIHtcbiAgICAgICAgaWYgKCEoYmFsYW5jZSBpbnN0YW5jZW9mIGJhbGFuY2VfMS5CYWxhbmNlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYmFsYW5jZSBtdXN0IGJlIGEgQmFsYW5jZVwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldChiYWxhbmNlLmFzc2V0SWQsIGJhbGFuY2UuYW1vdW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgYmFsYW5jZSBtYXAuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBiYWxhbmNlIG1hcC5cbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICAgIHRoaXMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgICAgbGV0IHN0ciA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBpZiAodmFsdWUuaXNJbnRlZ2VyKCkpIHtcbiAgICAgICAgICAgICAgICBzdHIgPSB2YWx1ZS50b051bWJlcigpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IHN0cjtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBgQmFsYW5jZU1hcCR7SlNPTi5zdHJpbmdpZnkocmVzdWx0KX1gO1xuICAgIH1cbn1cbmV4cG9ydHMuQmFsYW5jZU1hcCA9IEJhbGFuY2VNYXA7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/balance_map.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/coinbase.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/coinbase.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Coinbase = void 0;\nconst axios_1 = __importDefault(__webpack_require__(/*! axios */ \"(rsc)/./node_modules/axios/dist/node/axios.cjs\"));\nconst axios_retry_1 = __importDefault(__webpack_require__(/*! axios-retry */ \"(rsc)/./node_modules/axios-retry/dist/cjs/index.js\"));\nconst fs = __importStar(__webpack_require__(/*! fs */ \"fs\"));\nconst client_1 = __webpack_require__(/*! ../client */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/client/index.js\");\nconst base_1 = __webpack_require__(/*! ./../client/base */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/client/base.js\");\nconst configuration_1 = __webpack_require__(/*! ./../client/configuration */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/client/configuration.js\");\nconst authenticator_1 = __webpack_require__(/*! ./authenticator */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/authenticator.js\");\nconst errors_1 = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/errors.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/utils.js\");\nconst os = __importStar(__webpack_require__(/*! os */ \"os\"));\n/**\n * The Coinbase SDK.\n */\nclass Coinbase {\n    /**\n     * Initializes the Coinbase SDK.\n     *\n     * @deprecated as of v0.5.0, use `configure` or `configureFromJson` instead.\n     *\n     * @class\n     * @param options - The constructor options.\n     * @param options.apiKeyName - The API key name.\n     * @param options.privateKey - The private key associated with the API key.\n     * @param options.useServerSigner - Whether to use a Server-Signer or not.\n     * @param options.debugging - If true, logs API requests and responses to the console.\n     * @param options.basePath - The base path for the API.\n     * @param options.maxNetworkRetries - The maximum number of network retries for the API GET requests.\n     * @param options.source - Optional source string to be sent with the API requests. Defaults to `sdk`.\n     * @param options.sourceVersion - Optional source version string to be sent with the API requests.\n     * @throws {InvalidConfigurationError} If the configuration is invalid.\n     * @throws {InvalidAPIKeyFormatError} If not able to create JWT token.\n     */\n    constructor({ apiKeyName, privateKey, useServerSigner = false, debugging = false, basePath = base_1.BASE_PATH, maxNetworkRetries = 3, source = \"sdk\", sourceVersion = undefined, }) {\n        if (apiKeyName === \"\") {\n            throw new errors_1.InvalidConfigurationError(\"Invalid configuration: apiKeyName is empty\");\n        }\n        if (privateKey === \"\") {\n            throw new errors_1.InvalidConfigurationError(\"Invalid configuration: privateKey is empty\");\n        }\n        const coinbaseAuthenticator = new authenticator_1.CoinbaseAuthenticator(apiKeyName, privateKey, source, sourceVersion);\n        const config = new configuration_1.Configuration({\n            basePath: basePath,\n        });\n        const axiosInstance = axios_1.default.create();\n        (0, axios_retry_1.default)(axiosInstance, {\n            retries: maxNetworkRetries,\n            retryCondition: (error) => {\n                return (error.config?.method?.toUpperCase() === \"GET\" &&\n                    (error.response?.status || 0) in [500, 502, 503, 504]);\n            },\n        });\n        (0, utils_1.registerAxiosInterceptors)(axiosInstance, config => coinbaseAuthenticator.authenticateRequest(config, debugging), \n        /* istanbul ignore file */\n        response => (0, utils_1.logApiResponse)(response, debugging));\n        Coinbase.apiClients.wallet = (0, client_1.WalletsApiFactory)(config, basePath, axiosInstance);\n        Coinbase.apiClients.smartWallet = (0, client_1.SmartWalletsApiFactory)(config, basePath, axiosInstance);\n        Coinbase.apiClients.address = (0, client_1.AddressesApiFactory)(config, basePath, axiosInstance);\n        Coinbase.apiClients.transfer = (0, client_1.TransfersApiFactory)(config, basePath, axiosInstance);\n        Coinbase.apiClients.trade = (0, client_1.TradesApiFactory)(config, basePath, axiosInstance);\n        Coinbase.apiClients.serverSigner = (0, client_1.ServerSignersApiFactory)(config, basePath, axiosInstance);\n        Coinbase.apiClients.stake = (0, client_1.StakeApiFactory)(config, basePath, axiosInstance);\n        Coinbase.apiClients.walletStake = (0, client_1.MPCWalletStakeApiFactory)(config, basePath, axiosInstance);\n        Coinbase.apiClients.asset = (0, client_1.AssetsApiFactory)(config, basePath, axiosInstance);\n        Coinbase.apiClients.webhook = (0, client_1.WebhooksApiFactory)(config, basePath, axiosInstance);\n        Coinbase.apiClients.contractInvocation = (0, client_1.ContractInvocationsApiFactory)(config, basePath, axiosInstance);\n        Coinbase.apiClients.externalAddress = (0, client_1.ExternalAddressesApiFactory)(config, basePath, axiosInstance);\n        Coinbase.apiClients.balanceHistory = (0, client_1.BalanceHistoryApiFactory)(config, basePath, axiosInstance);\n        Coinbase.apiClients.contractEvent = (0, client_1.ContractEventsApiFactory)(config, basePath, axiosInstance);\n        Coinbase.apiClients.smartContract = (0, client_1.SmartContractsApiFactory)(config, basePath, axiosInstance);\n        Coinbase.apiClients.fund = (0, client_1.FundApiFactory)(config, basePath, axiosInstance);\n        Coinbase.apiClients.transactionHistory = (0, client_1.TransactionHistoryApiFactory)(config, basePath, axiosInstance);\n        Coinbase.apiKeyPrivateKey = privateKey;\n        Coinbase.useServerSigner = useServerSigner;\n        Coinbase.apiClients.addressReputation = (0, client_1.ReputationApiFactory)(config, basePath, axiosInstance);\n    }\n    /**\n     * Configures the Coinbase SDK with the provided options.\n     *\n     * @param options - The configuration options.\n     * @param options.apiKeyName - The name of the API key.\n     * @param options.privateKey - The private key associated with the API key.\n     * @param options.useServerSigner - Whether to use a Server-Signer or not. Defaults to false.\n     * @param options.debugging - If true, logs API requests and responses to the console. Defaults to false.\n     * @param options.basePath - The base path for the API. Defaults to BASE_PATH.\n     * @param options.source - Optional source string to be sent with the API requests. Defaults to `sdk`.\n     * @param options.sourceVersion - Optional source version string to be sent with the API requests.\n     * @returns A new instance of the Coinbase SDK.\n     */\n    static configure({ apiKeyName, privateKey, useServerSigner = false, debugging = false, basePath = base_1.BASE_PATH, source = \"sdk\", sourceVersion = undefined, }) {\n        return new Coinbase({\n            apiKeyName,\n            privateKey,\n            useServerSigner,\n            debugging,\n            basePath,\n            source,\n            sourceVersion,\n        });\n    }\n    /**\n     * Reads the API key and private key from a JSON file and initializes the Coinbase SDK.\n     *\n     * @param options - The configuration options.\n     * @param options.filePath - The path to the JSON file containing the API key and private key.\n     * @param options.useServerSigner - Whether to use a Server-Signer or not.\n     * @param options.debugging - If true, logs API requests and responses to the console.\n     * @param options.basePath - The base path for the API.\n     * @param options.source - Optional source string to be sent with the API requests. Defaults to `sdk`.\n     * @param options.sourceVersion - Optional source version string to be sent with the API requests.\n     * @returns A new instance of the Coinbase SDK.\n     * @throws {InvalidAPIKeyFormat} If the file does not exist or the configuration values are missing/invalid.\n     * @throws {InvalidConfiguration} If the configuration is invalid.\n     * @throws {InvalidAPIKeyFormat} If not able to create JWT token.\n     */\n    static configureFromJson({ filePath = \"coinbase_cloud_api_key.json\", useServerSigner = false, debugging = false, basePath = base_1.BASE_PATH, source = \"sdk\", sourceVersion = undefined, } = {}) {\n        filePath = filePath.startsWith(\"~\") ? filePath.replace(\"~\", os.homedir()) : filePath;\n        if (!fs.existsSync(filePath)) {\n            throw new errors_1.InvalidConfigurationError(`Invalid configuration: file not found at ${filePath}`);\n        }\n        try {\n            const data = fs.readFileSync(filePath, \"utf8\");\n            // Support both \"name\" and \"id\" for the API key identifier.\n            const config = JSON.parse(data);\n            const apiKeyIdentifier = config.name || config.id;\n            if (!apiKeyIdentifier || !config.privateKey) {\n                throw new errors_1.InvalidAPIKeyFormatError(\"Invalid configuration: missing API key identifier or privateKey\");\n            }\n            return new Coinbase({\n                apiKeyName: apiKeyIdentifier,\n                privateKey: config.privateKey,\n                useServerSigner: useServerSigner,\n                debugging: debugging,\n                basePath: basePath,\n                source,\n                sourceVersion,\n            });\n        }\n        catch (e) {\n            if (e instanceof SyntaxError) {\n                throw new errors_1.InvalidAPIKeyFormatError(\"Not able to parse the configuration file\");\n            }\n            else {\n                throw new errors_1.InvalidAPIKeyFormatError(`An error occurred while reading the configuration file: ${e.message}`);\n            }\n        }\n    }\n    /**\n     * Converts a network symbol to a string, replacing underscores with hyphens.\n     *\n     * @param network - The network symbol to convert\n     * @returns the converted string\n     */\n    static normalizeNetwork(network) {\n        return network.replace(/_/g, \"-\");\n    }\n    /**\n     * Converts a string to a symbol, replacing hyphens with underscores.\n     *\n     * @param asset - The string to convert\n     * @returns the converted symbol\n     */\n    static toAssetId(asset) {\n        return asset.replace(/-/g, \"_\");\n    }\n}\nexports.Coinbase = Coinbase;\n/**\n * The map of supported networks to network ID. Generated from the OpenAPI spec.\n *\n * @constant\n *\n * @example\n * ```typescript\n * Coinbase.networks.BaseMainnet\n * ```\n */\nCoinbase.networks = client_1.NetworkIdentifier;\n/**\n * The list of supported assets.\n *\n * @constant\n */\nCoinbase.assets = {\n    Eth: \"eth\",\n    Wei: \"wei\",\n    Gwei: \"gwei\",\n    Usdc: \"usdc\",\n    Weth: \"weth\",\n    Sol: \"sol\",\n    Lamport: \"lamport\",\n    Eurc: \"eurc\",\n    Cbbtc: \"cbbtc\",\n};\nCoinbase.apiClients = {};\n/**\n * The default page limit for list methods.\n *\n * @constant\n */\nCoinbase.defaultPageLimit = 100;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL2NvaW5iYXNlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQjtBQUNoQixnQ0FBZ0MsbUJBQU8sQ0FBQyw2REFBTztBQUMvQyxzQ0FBc0MsbUJBQU8sQ0FBQyx1RUFBYTtBQUMzRCx3QkFBd0IsbUJBQU8sQ0FBQyxjQUFJO0FBQ3BDLGlCQUFpQixtQkFBTyxDQUFDLG1GQUFXO0FBQ3BDLGVBQWUsbUJBQU8sQ0FBQyx5RkFBa0I7QUFDekMsd0JBQXdCLG1CQUFPLENBQUMsMkdBQTJCO0FBQzNELHdCQUF3QixtQkFBTyxDQUFDLG1HQUFpQjtBQUNqRCxpQkFBaUIsbUJBQU8sQ0FBQyxxRkFBVTtBQUNuQyxnQkFBZ0IsbUJBQU8sQ0FBQyxtRkFBUztBQUNqQyx3QkFBd0IsbUJBQU8sQ0FBQyxjQUFJO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDJCQUEyQjtBQUMzQyxnQkFBZ0IsMEJBQTBCO0FBQzFDO0FBQ0Esa0JBQWtCLG9LQUFvSztBQUN0TDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw2SUFBNkk7QUFDcEs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscUJBQXFCO0FBQ3JDLGdCQUFnQixzQkFBc0I7QUFDdEMsZ0JBQWdCLHFCQUFxQjtBQUNyQztBQUNBLCtCQUErQixnS0FBZ0ssSUFBSTtBQUNuTTtBQUNBO0FBQ0EscUdBQXFHLFNBQVM7QUFDOUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1SEFBdUgsVUFBVTtBQUNqSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cnZpdmFsLWZ1bi8uL25vZGVfbW9kdWxlcy9AY29pbmJhc2UvY29pbmJhc2Utc2RrL2Rpc3QvY29pbmJhc2UvY29pbmJhc2UuanM/Mzc3ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db2luYmFzZSA9IHZvaWQgMDtcbmNvbnN0IGF4aW9zXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImF4aW9zXCIpKTtcbmNvbnN0IGF4aW9zX3JldHJ5XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImF4aW9zLXJldHJ5XCIpKTtcbmNvbnN0IGZzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJmc1wiKSk7XG5jb25zdCBjbGllbnRfMSA9IHJlcXVpcmUoXCIuLi9jbGllbnRcIik7XG5jb25zdCBiYXNlXzEgPSByZXF1aXJlKFwiLi8uLi9jbGllbnQvYmFzZVwiKTtcbmNvbnN0IGNvbmZpZ3VyYXRpb25fMSA9IHJlcXVpcmUoXCIuLy4uL2NsaWVudC9jb25maWd1cmF0aW9uXCIpO1xuY29uc3QgYXV0aGVudGljYXRvcl8xID0gcmVxdWlyZShcIi4vYXV0aGVudGljYXRvclwiKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4vZXJyb3JzXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuY29uc3Qgb3MgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIm9zXCIpKTtcbi8qKlxuICogVGhlIENvaW5iYXNlIFNESy5cbiAqL1xuY2xhc3MgQ29pbmJhc2Uge1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSBDb2luYmFzZSBTREsuXG4gICAgICpcbiAgICAgKiBAZGVwcmVjYXRlZCBhcyBvZiB2MC41LjAsIHVzZSBgY29uZmlndXJlYCBvciBgY29uZmlndXJlRnJvbUpzb25gIGluc3RlYWQuXG4gICAgICpcbiAgICAgKiBAY2xhc3NcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBjb25zdHJ1Y3RvciBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmFwaUtleU5hbWUgLSBUaGUgQVBJIGtleSBuYW1lLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnByaXZhdGVLZXkgLSBUaGUgcHJpdmF0ZSBrZXkgYXNzb2NpYXRlZCB3aXRoIHRoZSBBUEkga2V5LlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnVzZVNlcnZlclNpZ25lciAtIFdoZXRoZXIgdG8gdXNlIGEgU2VydmVyLVNpZ25lciBvciBub3QuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZGVidWdnaW5nIC0gSWYgdHJ1ZSwgbG9ncyBBUEkgcmVxdWVzdHMgYW5kIHJlc3BvbnNlcyB0byB0aGUgY29uc29sZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5iYXNlUGF0aCAtIFRoZSBiYXNlIHBhdGggZm9yIHRoZSBBUEkuXG4gICAgICogQHBhcmFtIG9wdGlvbnMubWF4TmV0d29ya1JldHJpZXMgLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgbmV0d29yayByZXRyaWVzIGZvciB0aGUgQVBJIEdFVCByZXF1ZXN0cy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5zb3VyY2UgLSBPcHRpb25hbCBzb3VyY2Ugc3RyaW5nIHRvIGJlIHNlbnQgd2l0aCB0aGUgQVBJIHJlcXVlc3RzLiBEZWZhdWx0cyB0byBgc2RrYC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5zb3VyY2VWZXJzaW9uIC0gT3B0aW9uYWwgc291cmNlIHZlcnNpb24gc3RyaW5nIHRvIGJlIHNlbnQgd2l0aCB0aGUgQVBJIHJlcXVlc3RzLlxuICAgICAqIEB0aHJvd3Mge0ludmFsaWRDb25maWd1cmF0aW9uRXJyb3J9IElmIHRoZSBjb25maWd1cmF0aW9uIGlzIGludmFsaWQuXG4gICAgICogQHRocm93cyB7SW52YWxpZEFQSUtleUZvcm1hdEVycm9yfSBJZiBub3QgYWJsZSB0byBjcmVhdGUgSldUIHRva2VuLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHsgYXBpS2V5TmFtZSwgcHJpdmF0ZUtleSwgdXNlU2VydmVyU2lnbmVyID0gZmFsc2UsIGRlYnVnZ2luZyA9IGZhbHNlLCBiYXNlUGF0aCA9IGJhc2VfMS5CQVNFX1BBVEgsIG1heE5ldHdvcmtSZXRyaWVzID0gMywgc291cmNlID0gXCJzZGtcIiwgc291cmNlVmVyc2lvbiA9IHVuZGVmaW5lZCwgfSkge1xuICAgICAgICBpZiAoYXBpS2V5TmFtZSA9PT0gXCJcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkludmFsaWRDb25maWd1cmF0aW9uRXJyb3IoXCJJbnZhbGlkIGNvbmZpZ3VyYXRpb246IGFwaUtleU5hbWUgaXMgZW1wdHlcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByaXZhdGVLZXkgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5JbnZhbGlkQ29uZmlndXJhdGlvbkVycm9yKFwiSW52YWxpZCBjb25maWd1cmF0aW9uOiBwcml2YXRlS2V5IGlzIGVtcHR5XCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvaW5iYXNlQXV0aGVudGljYXRvciA9IG5ldyBhdXRoZW50aWNhdG9yXzEuQ29pbmJhc2VBdXRoZW50aWNhdG9yKGFwaUtleU5hbWUsIHByaXZhdGVLZXksIHNvdXJjZSwgc291cmNlVmVyc2lvbik7XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IG5ldyBjb25maWd1cmF0aW9uXzEuQ29uZmlndXJhdGlvbih7XG4gICAgICAgICAgICBiYXNlUGF0aDogYmFzZVBhdGgsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBheGlvc0luc3RhbmNlID0gYXhpb3NfMS5kZWZhdWx0LmNyZWF0ZSgpO1xuICAgICAgICAoMCwgYXhpb3NfcmV0cnlfMS5kZWZhdWx0KShheGlvc0luc3RhbmNlLCB7XG4gICAgICAgICAgICByZXRyaWVzOiBtYXhOZXR3b3JrUmV0cmllcyxcbiAgICAgICAgICAgIHJldHJ5Q29uZGl0aW9uOiAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGVycm9yLmNvbmZpZz8ubWV0aG9kPy50b1VwcGVyQ2FzZSgpID09PSBcIkdFVFwiICYmXG4gICAgICAgICAgICAgICAgICAgIChlcnJvci5yZXNwb25zZT8uc3RhdHVzIHx8IDApIGluIFs1MDAsIDUwMiwgNTAzLCA1MDRdKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICAoMCwgdXRpbHNfMS5yZWdpc3RlckF4aW9zSW50ZXJjZXB0b3JzKShheGlvc0luc3RhbmNlLCBjb25maWcgPT4gY29pbmJhc2VBdXRoZW50aWNhdG9yLmF1dGhlbnRpY2F0ZVJlcXVlc3QoY29uZmlnLCBkZWJ1Z2dpbmcpLCBcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGZpbGUgKi9cbiAgICAgICAgcmVzcG9uc2UgPT4gKDAsIHV0aWxzXzEubG9nQXBpUmVzcG9uc2UpKHJlc3BvbnNlLCBkZWJ1Z2dpbmcpKTtcbiAgICAgICAgQ29pbmJhc2UuYXBpQ2xpZW50cy53YWxsZXQgPSAoMCwgY2xpZW50XzEuV2FsbGV0c0FwaUZhY3RvcnkpKGNvbmZpZywgYmFzZVBhdGgsIGF4aW9zSW5zdGFuY2UpO1xuICAgICAgICBDb2luYmFzZS5hcGlDbGllbnRzLnNtYXJ0V2FsbGV0ID0gKDAsIGNsaWVudF8xLlNtYXJ0V2FsbGV0c0FwaUZhY3RvcnkpKGNvbmZpZywgYmFzZVBhdGgsIGF4aW9zSW5zdGFuY2UpO1xuICAgICAgICBDb2luYmFzZS5hcGlDbGllbnRzLmFkZHJlc3MgPSAoMCwgY2xpZW50XzEuQWRkcmVzc2VzQXBpRmFjdG9yeSkoY29uZmlnLCBiYXNlUGF0aCwgYXhpb3NJbnN0YW5jZSk7XG4gICAgICAgIENvaW5iYXNlLmFwaUNsaWVudHMudHJhbnNmZXIgPSAoMCwgY2xpZW50XzEuVHJhbnNmZXJzQXBpRmFjdG9yeSkoY29uZmlnLCBiYXNlUGF0aCwgYXhpb3NJbnN0YW5jZSk7XG4gICAgICAgIENvaW5iYXNlLmFwaUNsaWVudHMudHJhZGUgPSAoMCwgY2xpZW50XzEuVHJhZGVzQXBpRmFjdG9yeSkoY29uZmlnLCBiYXNlUGF0aCwgYXhpb3NJbnN0YW5jZSk7XG4gICAgICAgIENvaW5iYXNlLmFwaUNsaWVudHMuc2VydmVyU2lnbmVyID0gKDAsIGNsaWVudF8xLlNlcnZlclNpZ25lcnNBcGlGYWN0b3J5KShjb25maWcsIGJhc2VQYXRoLCBheGlvc0luc3RhbmNlKTtcbiAgICAgICAgQ29pbmJhc2UuYXBpQ2xpZW50cy5zdGFrZSA9ICgwLCBjbGllbnRfMS5TdGFrZUFwaUZhY3RvcnkpKGNvbmZpZywgYmFzZVBhdGgsIGF4aW9zSW5zdGFuY2UpO1xuICAgICAgICBDb2luYmFzZS5hcGlDbGllbnRzLndhbGxldFN0YWtlID0gKDAsIGNsaWVudF8xLk1QQ1dhbGxldFN0YWtlQXBpRmFjdG9yeSkoY29uZmlnLCBiYXNlUGF0aCwgYXhpb3NJbnN0YW5jZSk7XG4gICAgICAgIENvaW5iYXNlLmFwaUNsaWVudHMuYXNzZXQgPSAoMCwgY2xpZW50XzEuQXNzZXRzQXBpRmFjdG9yeSkoY29uZmlnLCBiYXNlUGF0aCwgYXhpb3NJbnN0YW5jZSk7XG4gICAgICAgIENvaW5iYXNlLmFwaUNsaWVudHMud2ViaG9vayA9ICgwLCBjbGllbnRfMS5XZWJob29rc0FwaUZhY3RvcnkpKGNvbmZpZywgYmFzZVBhdGgsIGF4aW9zSW5zdGFuY2UpO1xuICAgICAgICBDb2luYmFzZS5hcGlDbGllbnRzLmNvbnRyYWN0SW52b2NhdGlvbiA9ICgwLCBjbGllbnRfMS5Db250cmFjdEludm9jYXRpb25zQXBpRmFjdG9yeSkoY29uZmlnLCBiYXNlUGF0aCwgYXhpb3NJbnN0YW5jZSk7XG4gICAgICAgIENvaW5iYXNlLmFwaUNsaWVudHMuZXh0ZXJuYWxBZGRyZXNzID0gKDAsIGNsaWVudF8xLkV4dGVybmFsQWRkcmVzc2VzQXBpRmFjdG9yeSkoY29uZmlnLCBiYXNlUGF0aCwgYXhpb3NJbnN0YW5jZSk7XG4gICAgICAgIENvaW5iYXNlLmFwaUNsaWVudHMuYmFsYW5jZUhpc3RvcnkgPSAoMCwgY2xpZW50XzEuQmFsYW5jZUhpc3RvcnlBcGlGYWN0b3J5KShjb25maWcsIGJhc2VQYXRoLCBheGlvc0luc3RhbmNlKTtcbiAgICAgICAgQ29pbmJhc2UuYXBpQ2xpZW50cy5jb250cmFjdEV2ZW50ID0gKDAsIGNsaWVudF8xLkNvbnRyYWN0RXZlbnRzQXBpRmFjdG9yeSkoY29uZmlnLCBiYXNlUGF0aCwgYXhpb3NJbnN0YW5jZSk7XG4gICAgICAgIENvaW5iYXNlLmFwaUNsaWVudHMuc21hcnRDb250cmFjdCA9ICgwLCBjbGllbnRfMS5TbWFydENvbnRyYWN0c0FwaUZhY3RvcnkpKGNvbmZpZywgYmFzZVBhdGgsIGF4aW9zSW5zdGFuY2UpO1xuICAgICAgICBDb2luYmFzZS5hcGlDbGllbnRzLmZ1bmQgPSAoMCwgY2xpZW50XzEuRnVuZEFwaUZhY3RvcnkpKGNvbmZpZywgYmFzZVBhdGgsIGF4aW9zSW5zdGFuY2UpO1xuICAgICAgICBDb2luYmFzZS5hcGlDbGllbnRzLnRyYW5zYWN0aW9uSGlzdG9yeSA9ICgwLCBjbGllbnRfMS5UcmFuc2FjdGlvbkhpc3RvcnlBcGlGYWN0b3J5KShjb25maWcsIGJhc2VQYXRoLCBheGlvc0luc3RhbmNlKTtcbiAgICAgICAgQ29pbmJhc2UuYXBpS2V5UHJpdmF0ZUtleSA9IHByaXZhdGVLZXk7XG4gICAgICAgIENvaW5iYXNlLnVzZVNlcnZlclNpZ25lciA9IHVzZVNlcnZlclNpZ25lcjtcbiAgICAgICAgQ29pbmJhc2UuYXBpQ2xpZW50cy5hZGRyZXNzUmVwdXRhdGlvbiA9ICgwLCBjbGllbnRfMS5SZXB1dGF0aW9uQXBpRmFjdG9yeSkoY29uZmlnLCBiYXNlUGF0aCwgYXhpb3NJbnN0YW5jZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbmZpZ3VyZXMgdGhlIENvaW5iYXNlIFNESyB3aXRoIHRoZSBwcm92aWRlZCBvcHRpb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmFwaUtleU5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgQVBJIGtleS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5wcml2YXRlS2V5IC0gVGhlIHByaXZhdGUga2V5IGFzc29jaWF0ZWQgd2l0aCB0aGUgQVBJIGtleS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy51c2VTZXJ2ZXJTaWduZXIgLSBXaGV0aGVyIHRvIHVzZSBhIFNlcnZlci1TaWduZXIgb3Igbm90LiBEZWZhdWx0cyB0byBmYWxzZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5kZWJ1Z2dpbmcgLSBJZiB0cnVlLCBsb2dzIEFQSSByZXF1ZXN0cyBhbmQgcmVzcG9uc2VzIHRvIHRoZSBjb25zb2xlLiBEZWZhdWx0cyB0byBmYWxzZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5iYXNlUGF0aCAtIFRoZSBiYXNlIHBhdGggZm9yIHRoZSBBUEkuIERlZmF1bHRzIHRvIEJBU0VfUEFUSC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5zb3VyY2UgLSBPcHRpb25hbCBzb3VyY2Ugc3RyaW5nIHRvIGJlIHNlbnQgd2l0aCB0aGUgQVBJIHJlcXVlc3RzLiBEZWZhdWx0cyB0byBgc2RrYC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5zb3VyY2VWZXJzaW9uIC0gT3B0aW9uYWwgc291cmNlIHZlcnNpb24gc3RyaW5nIHRvIGJlIHNlbnQgd2l0aCB0aGUgQVBJIHJlcXVlc3RzLlxuICAgICAqIEByZXR1cm5zIEEgbmV3IGluc3RhbmNlIG9mIHRoZSBDb2luYmFzZSBTREsuXG4gICAgICovXG4gICAgc3RhdGljIGNvbmZpZ3VyZSh7IGFwaUtleU5hbWUsIHByaXZhdGVLZXksIHVzZVNlcnZlclNpZ25lciA9IGZhbHNlLCBkZWJ1Z2dpbmcgPSBmYWxzZSwgYmFzZVBhdGggPSBiYXNlXzEuQkFTRV9QQVRILCBzb3VyY2UgPSBcInNka1wiLCBzb3VyY2VWZXJzaW9uID0gdW5kZWZpbmVkLCB9KSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29pbmJhc2Uoe1xuICAgICAgICAgICAgYXBpS2V5TmFtZSxcbiAgICAgICAgICAgIHByaXZhdGVLZXksXG4gICAgICAgICAgICB1c2VTZXJ2ZXJTaWduZXIsXG4gICAgICAgICAgICBkZWJ1Z2dpbmcsXG4gICAgICAgICAgICBiYXNlUGF0aCxcbiAgICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICAgIHNvdXJjZVZlcnNpb24sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkcyB0aGUgQVBJIGtleSBhbmQgcHJpdmF0ZSBrZXkgZnJvbSBhIEpTT04gZmlsZSBhbmQgaW5pdGlhbGl6ZXMgdGhlIENvaW5iYXNlIFNESy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5maWxlUGF0aCAtIFRoZSBwYXRoIHRvIHRoZSBKU09OIGZpbGUgY29udGFpbmluZyB0aGUgQVBJIGtleSBhbmQgcHJpdmF0ZSBrZXkuXG4gICAgICogQHBhcmFtIG9wdGlvbnMudXNlU2VydmVyU2lnbmVyIC0gV2hldGhlciB0byB1c2UgYSBTZXJ2ZXItU2lnbmVyIG9yIG5vdC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5kZWJ1Z2dpbmcgLSBJZiB0cnVlLCBsb2dzIEFQSSByZXF1ZXN0cyBhbmQgcmVzcG9uc2VzIHRvIHRoZSBjb25zb2xlLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmJhc2VQYXRoIC0gVGhlIGJhc2UgcGF0aCBmb3IgdGhlIEFQSS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5zb3VyY2UgLSBPcHRpb25hbCBzb3VyY2Ugc3RyaW5nIHRvIGJlIHNlbnQgd2l0aCB0aGUgQVBJIHJlcXVlc3RzLiBEZWZhdWx0cyB0byBgc2RrYC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5zb3VyY2VWZXJzaW9uIC0gT3B0aW9uYWwgc291cmNlIHZlcnNpb24gc3RyaW5nIHRvIGJlIHNlbnQgd2l0aCB0aGUgQVBJIHJlcXVlc3RzLlxuICAgICAqIEByZXR1cm5zIEEgbmV3IGluc3RhbmNlIG9mIHRoZSBDb2luYmFzZSBTREsuXG4gICAgICogQHRocm93cyB7SW52YWxpZEFQSUtleUZvcm1hdH0gSWYgdGhlIGZpbGUgZG9lcyBub3QgZXhpc3Qgb3IgdGhlIGNvbmZpZ3VyYXRpb24gdmFsdWVzIGFyZSBtaXNzaW5nL2ludmFsaWQuXG4gICAgICogQHRocm93cyB7SW52YWxpZENvbmZpZ3VyYXRpb259IElmIHRoZSBjb25maWd1cmF0aW9uIGlzIGludmFsaWQuXG4gICAgICogQHRocm93cyB7SW52YWxpZEFQSUtleUZvcm1hdH0gSWYgbm90IGFibGUgdG8gY3JlYXRlIEpXVCB0b2tlbi5cbiAgICAgKi9cbiAgICBzdGF0aWMgY29uZmlndXJlRnJvbUpzb24oeyBmaWxlUGF0aCA9IFwiY29pbmJhc2VfY2xvdWRfYXBpX2tleS5qc29uXCIsIHVzZVNlcnZlclNpZ25lciA9IGZhbHNlLCBkZWJ1Z2dpbmcgPSBmYWxzZSwgYmFzZVBhdGggPSBiYXNlXzEuQkFTRV9QQVRILCBzb3VyY2UgPSBcInNka1wiLCBzb3VyY2VWZXJzaW9uID0gdW5kZWZpbmVkLCB9ID0ge30pIHtcbiAgICAgICAgZmlsZVBhdGggPSBmaWxlUGF0aC5zdGFydHNXaXRoKFwiflwiKSA/IGZpbGVQYXRoLnJlcGxhY2UoXCJ+XCIsIG9zLmhvbWVkaXIoKSkgOiBmaWxlUGF0aDtcbiAgICAgICAgaWYgKCFmcy5leGlzdHNTeW5jKGZpbGVQYXRoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkludmFsaWRDb25maWd1cmF0aW9uRXJyb3IoYEludmFsaWQgY29uZmlndXJhdGlvbjogZmlsZSBub3QgZm91bmQgYXQgJHtmaWxlUGF0aH1gKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGZzLnJlYWRGaWxlU3luYyhmaWxlUGF0aCwgXCJ1dGY4XCIpO1xuICAgICAgICAgICAgLy8gU3VwcG9ydCBib3RoIFwibmFtZVwiIGFuZCBcImlkXCIgZm9yIHRoZSBBUEkga2V5IGlkZW50aWZpZXIuXG4gICAgICAgICAgICBjb25zdCBjb25maWcgPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgICAgICAgY29uc3QgYXBpS2V5SWRlbnRpZmllciA9IGNvbmZpZy5uYW1lIHx8IGNvbmZpZy5pZDtcbiAgICAgICAgICAgIGlmICghYXBpS2V5SWRlbnRpZmllciB8fCAhY29uZmlnLnByaXZhdGVLZXkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuSW52YWxpZEFQSUtleUZvcm1hdEVycm9yKFwiSW52YWxpZCBjb25maWd1cmF0aW9uOiBtaXNzaW5nIEFQSSBrZXkgaWRlbnRpZmllciBvciBwcml2YXRlS2V5XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2luYmFzZSh7XG4gICAgICAgICAgICAgICAgYXBpS2V5TmFtZTogYXBpS2V5SWRlbnRpZmllcixcbiAgICAgICAgICAgICAgICBwcml2YXRlS2V5OiBjb25maWcucHJpdmF0ZUtleSxcbiAgICAgICAgICAgICAgICB1c2VTZXJ2ZXJTaWduZXI6IHVzZVNlcnZlclNpZ25lcixcbiAgICAgICAgICAgICAgICBkZWJ1Z2dpbmc6IGRlYnVnZ2luZyxcbiAgICAgICAgICAgICAgICBiYXNlUGF0aDogYmFzZVBhdGgsXG4gICAgICAgICAgICAgICAgc291cmNlLFxuICAgICAgICAgICAgICAgIHNvdXJjZVZlcnNpb24sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBTeW50YXhFcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5JbnZhbGlkQVBJS2V5Rm9ybWF0RXJyb3IoXCJOb3QgYWJsZSB0byBwYXJzZSB0aGUgY29uZmlndXJhdGlvbiBmaWxlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkludmFsaWRBUElLZXlGb3JtYXRFcnJvcihgQW4gZXJyb3Igb2NjdXJyZWQgd2hpbGUgcmVhZGluZyB0aGUgY29uZmlndXJhdGlvbiBmaWxlOiAke2UubWVzc2FnZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIG5ldHdvcmsgc3ltYm9sIHRvIGEgc3RyaW5nLCByZXBsYWNpbmcgdW5kZXJzY29yZXMgd2l0aCBoeXBoZW5zLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5ldHdvcmsgLSBUaGUgbmV0d29yayBzeW1ib2wgdG8gY29udmVydFxuICAgICAqIEByZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nXG4gICAgICovXG4gICAgc3RhdGljIG5vcm1hbGl6ZU5ldHdvcmsobmV0d29yaykge1xuICAgICAgICByZXR1cm4gbmV0d29yay5yZXBsYWNlKC9fL2csIFwiLVwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBzdHJpbmcgdG8gYSBzeW1ib2wsIHJlcGxhY2luZyBoeXBoZW5zIHdpdGggdW5kZXJzY29yZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXNzZXQgLSBUaGUgc3RyaW5nIHRvIGNvbnZlcnRcbiAgICAgKiBAcmV0dXJucyB0aGUgY29udmVydGVkIHN5bWJvbFxuICAgICAqL1xuICAgIHN0YXRpYyB0b0Fzc2V0SWQoYXNzZXQpIHtcbiAgICAgICAgcmV0dXJuIGFzc2V0LnJlcGxhY2UoLy0vZywgXCJfXCIpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29pbmJhc2UgPSBDb2luYmFzZTtcbi8qKlxuICogVGhlIG1hcCBvZiBzdXBwb3J0ZWQgbmV0d29ya3MgdG8gbmV0d29yayBJRC4gR2VuZXJhdGVkIGZyb20gdGhlIE9wZW5BUEkgc3BlYy5cbiAqXG4gKiBAY29uc3RhbnRcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogQ29pbmJhc2UubmV0d29ya3MuQmFzZU1haW5uZXRcbiAqIGBgYFxuICovXG5Db2luYmFzZS5uZXR3b3JrcyA9IGNsaWVudF8xLk5ldHdvcmtJZGVudGlmaWVyO1xuLyoqXG4gKiBUaGUgbGlzdCBvZiBzdXBwb3J0ZWQgYXNzZXRzLlxuICpcbiAqIEBjb25zdGFudFxuICovXG5Db2luYmFzZS5hc3NldHMgPSB7XG4gICAgRXRoOiBcImV0aFwiLFxuICAgIFdlaTogXCJ3ZWlcIixcbiAgICBHd2VpOiBcImd3ZWlcIixcbiAgICBVc2RjOiBcInVzZGNcIixcbiAgICBXZXRoOiBcIndldGhcIixcbiAgICBTb2w6IFwic29sXCIsXG4gICAgTGFtcG9ydDogXCJsYW1wb3J0XCIsXG4gICAgRXVyYzogXCJldXJjXCIsXG4gICAgQ2JidGM6IFwiY2JidGNcIixcbn07XG5Db2luYmFzZS5hcGlDbGllbnRzID0ge307XG4vKipcbiAqIFRoZSBkZWZhdWx0IHBhZ2UgbGltaXQgZm9yIGxpc3QgbWV0aG9kcy5cbiAqXG4gKiBAY29uc3RhbnRcbiAqL1xuQ29pbmJhc2UuZGVmYXVsdFBhZ2VMaW1pdCA9IDEwMDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/coinbase.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/constants.js":
/*!************************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/constants.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GWEI_DECIMALS = void 0;\nexports.GWEI_DECIMALS = 9;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUI7QUFDckIscUJBQXFCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3Vydml2YWwtZnVuLy4vbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9jb2luYmFzZS1zZGsvZGlzdC9jb2luYmFzZS9jb25zdGFudHMuanM/NjY0YSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuR1dFSV9ERUNJTUFMUyA9IHZvaWQgMDtcbmV4cG9ydHMuR1dFSV9ERUNJTUFMUyA9IDk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/contract_event.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/contract_event.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ContractEvent = void 0;\n/**\n * A representation of a single contract event.\n */\nclass ContractEvent {\n    /**\n     * Creates the ContractEvent object.\n     *\n     * @param model - The underlying contract event object.\n     */\n    constructor(model) {\n        this.model = model;\n    }\n    /**\n     * Returns the network ID of the ContractEvent.\n     *\n     * @returns The network ID.\n     */\n    networkId() {\n        return this.model.network_id;\n    }\n    /**\n     * Returns the protocol name of the ContractEvent.\n     *\n     * @returns The protocol name.\n     */\n    protocolName() {\n        return this.model.protocol_name;\n    }\n    /**\n     * Returns the contract name of the ContractEvent.\n     *\n     * @returns The contract name.\n     */\n    contractName() {\n        return this.model.contract_name;\n    }\n    /**\n     * Returns the event name of the ContractEvent.\n     *\n     * @returns The event name.\n     */\n    eventName() {\n        return this.model.event_name;\n    }\n    /**\n     * Returns the signature of the ContractEvent.\n     *\n     * @returns The event signature.\n     */\n    sig() {\n        return this.model.sig;\n    }\n    /**\n     * Returns the four bytes of the Keccak hash of the event signature.\n     *\n     * @returns The four bytes of the event signature hash.\n     */\n    fourBytes() {\n        return this.model.four_bytes;\n    }\n    /**\n     * Returns the contract address of the ContractEvent.\n     *\n     * @returns The contract address.\n     */\n    contractAddress() {\n        return this.model.contract_address;\n    }\n    /**\n     * Returns the block time of the ContractEvent.\n     *\n     * @returns The block time.\n     */\n    blockTime() {\n        return new Date(this.model.block_time);\n    }\n    /**\n     * Returns the block height of the ContractEvent.\n     *\n     * @returns The block height.\n     */\n    blockHeight() {\n        return this.model.block_height;\n    }\n    /**\n     * Returns the transaction hash of the ContractEvent.\n     *\n     * @returns The transaction hash.\n     */\n    txHash() {\n        return this.model.tx_hash;\n    }\n    /**\n     * Returns the transaction index of the ContractEvent.\n     *\n     * @returns The transaction index.\n     */\n    txIndex() {\n        return this.model.tx_index;\n    }\n    /**\n     * Returns the event index of the ContractEvent.\n     *\n     * @returns The event index.\n     */\n    eventIndex() {\n        return this.model.event_index;\n    }\n    /**\n     * Returns the event data of the ContractEvent.\n     *\n     * @returns The event data.\n     */\n    data() {\n        return this.model.data;\n    }\n    /**\n     * Print the ContractEvent as a string.\n     *\n     * @returns The string representation of the ContractEvent.\n     */\n    toString() {\n        return `ContractEvent { networkId: '${this.networkId()}' protocolName: '${this.protocolName()}' contractName: '${this.contractName()}' eventName: '${this.eventName()}' contractAddress: '${this.contractAddress()}' blockHeight: ${this.blockHeight()} txHash: '${this.txHash()}' }`;\n    }\n}\nexports.ContractEvent = ContractEvent;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL2NvbnRyYWN0X2V2ZW50LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGNBQWMsaUJBQWlCLG1CQUFtQixvQkFBb0IsbUJBQW1CLG9CQUFvQixnQkFBZ0IsaUJBQWlCLHNCQUFzQix1QkFBdUIsaUJBQWlCLG9CQUFvQixXQUFXLGNBQWMsR0FBRztBQUM1UjtBQUNBO0FBQ0EscUJBQXFCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3Vydml2YWwtZnVuLy4vbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9jb2luYmFzZS1zZGsvZGlzdC9jb2luYmFzZS9jb250cmFjdF9ldmVudC5qcz80MTY4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db250cmFjdEV2ZW50ID0gdm9pZCAwO1xuLyoqXG4gKiBBIHJlcHJlc2VudGF0aW9uIG9mIGEgc2luZ2xlIGNvbnRyYWN0IGV2ZW50LlxuICovXG5jbGFzcyBDb250cmFjdEV2ZW50IHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHRoZSBDb250cmFjdEV2ZW50IG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBtb2RlbCAtIFRoZSB1bmRlcmx5aW5nIGNvbnRyYWN0IGV2ZW50IG9iamVjdC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihtb2RlbCkge1xuICAgICAgICB0aGlzLm1vZGVsID0gbW9kZWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG5ldHdvcmsgSUQgb2YgdGhlIENvbnRyYWN0RXZlbnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgbmV0d29yayBJRC5cbiAgICAgKi9cbiAgICBuZXR3b3JrSWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLm5ldHdvcmtfaWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHByb3RvY29sIG5hbWUgb2YgdGhlIENvbnRyYWN0RXZlbnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgcHJvdG9jb2wgbmFtZS5cbiAgICAgKi9cbiAgICBwcm90b2NvbE5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLnByb3RvY29sX25hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNvbnRyYWN0IG5hbWUgb2YgdGhlIENvbnRyYWN0RXZlbnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgY29udHJhY3QgbmFtZS5cbiAgICAgKi9cbiAgICBjb250cmFjdE5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLmNvbnRyYWN0X25hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGV2ZW50IG5hbWUgb2YgdGhlIENvbnRyYWN0RXZlbnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgZXZlbnQgbmFtZS5cbiAgICAgKi9cbiAgICBldmVudE5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLmV2ZW50X25hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHNpZ25hdHVyZSBvZiB0aGUgQ29udHJhY3RFdmVudC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBldmVudCBzaWduYXR1cmUuXG4gICAgICovXG4gICAgc2lnKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5zaWc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGZvdXIgYnl0ZXMgb2YgdGhlIEtlY2NhayBoYXNoIG9mIHRoZSBldmVudCBzaWduYXR1cmUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgZm91ciBieXRlcyBvZiB0aGUgZXZlbnQgc2lnbmF0dXJlIGhhc2guXG4gICAgICovXG4gICAgZm91ckJ5dGVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5mb3VyX2J5dGVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjb250cmFjdCBhZGRyZXNzIG9mIHRoZSBDb250cmFjdEV2ZW50LlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGNvbnRyYWN0IGFkZHJlc3MuXG4gICAgICovXG4gICAgY29udHJhY3RBZGRyZXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5jb250cmFjdF9hZGRyZXNzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBibG9jayB0aW1lIG9mIHRoZSBDb250cmFjdEV2ZW50LlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGJsb2NrIHRpbWUuXG4gICAgICovXG4gICAgYmxvY2tUaW1lKCkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUodGhpcy5tb2RlbC5ibG9ja190aW1lKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYmxvY2sgaGVpZ2h0IG9mIHRoZSBDb250cmFjdEV2ZW50LlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGJsb2NrIGhlaWdodC5cbiAgICAgKi9cbiAgICBibG9ja0hlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwuYmxvY2tfaGVpZ2h0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB0cmFuc2FjdGlvbiBoYXNoIG9mIHRoZSBDb250cmFjdEV2ZW50LlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHRyYW5zYWN0aW9uIGhhc2guXG4gICAgICovXG4gICAgdHhIYXNoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC50eF9oYXNoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB0cmFuc2FjdGlvbiBpbmRleCBvZiB0aGUgQ29udHJhY3RFdmVudC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSB0cmFuc2FjdGlvbiBpbmRleC5cbiAgICAgKi9cbiAgICB0eEluZGV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC50eF9pbmRleDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZXZlbnQgaW5kZXggb2YgdGhlIENvbnRyYWN0RXZlbnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgZXZlbnQgaW5kZXguXG4gICAgICovXG4gICAgZXZlbnRJbmRleCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwuZXZlbnRfaW5kZXg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGV2ZW50IGRhdGEgb2YgdGhlIENvbnRyYWN0RXZlbnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgZXZlbnQgZGF0YS5cbiAgICAgKi9cbiAgICBkYXRhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5kYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcmludCB0aGUgQ29udHJhY3RFdmVudCBhcyBhIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIENvbnRyYWN0RXZlbnQuXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBgQ29udHJhY3RFdmVudCB7IG5ldHdvcmtJZDogJyR7dGhpcy5uZXR3b3JrSWQoKX0nIHByb3RvY29sTmFtZTogJyR7dGhpcy5wcm90b2NvbE5hbWUoKX0nIGNvbnRyYWN0TmFtZTogJyR7dGhpcy5jb250cmFjdE5hbWUoKX0nIGV2ZW50TmFtZTogJyR7dGhpcy5ldmVudE5hbWUoKX0nIGNvbnRyYWN0QWRkcmVzczogJyR7dGhpcy5jb250cmFjdEFkZHJlc3MoKX0nIGJsb2NrSGVpZ2h0OiAke3RoaXMuYmxvY2tIZWlnaHQoKX0gdHhIYXNoOiAnJHt0aGlzLnR4SGFzaCgpfScgfWA7XG4gICAgfVxufVxuZXhwb3J0cy5Db250cmFjdEV2ZW50ID0gQ29udHJhY3RFdmVudDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/contract_event.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/contract_invocation.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/contract_invocation.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ContractInvocation = void 0;\nconst decimal_js_1 = __webpack_require__(/*! decimal.js */ \"(rsc)/./node_modules/decimal.js/decimal.js\");\nconst types_1 = __webpack_require__(/*! ./types */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/types.js\");\nconst transaction_1 = __webpack_require__(/*! ./transaction */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/transaction.js\");\nconst coinbase_1 = __webpack_require__(/*! ./coinbase */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/coinbase.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/utils.js\");\nconst errors_1 = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/errors.js\");\n/**\n * A representation of a ContractInvocation, which calls a smart contract method\n * onchain. The fee is assumed to be paid in the native Asset of the Network.\n */\nclass ContractInvocation {\n    /**\n     * Private constructor to prevent direct instantiation outside of the factory methods.\n     *\n     * @ignore\n     * @param contractInvocationModel - The ContractInvocation model.\n     * @hideconstructor\n     */\n    constructor(contractInvocationModel) {\n        if (!contractInvocationModel) {\n            throw new Error(\"ContractInvocation model cannot be empty\");\n        }\n        this.model = contractInvocationModel;\n    }\n    /**\n     * Converts a ContractInvocationModel into a ContractInvocation object.\n     *\n     * @param contractInvocationModel - The ContractInvocation model object.\n     * @returns The ContractInvocation object.\n     */\n    static fromModel(contractInvocationModel) {\n        return new ContractInvocation(contractInvocationModel);\n    }\n    /**\n     * Returns the ID of the ContractInvocation.\n     *\n     * @returns The ContractInvocation ID.\n     */\n    getId() {\n        return this.model.contract_invocation_id;\n    }\n    /**\n     * Returns the Network ID of the ContractInvocation.\n     *\n     * @returns The Network ID.\n     */\n    getNetworkId() {\n        return this.model.network_id;\n    }\n    /**\n     * Returns the Wallet ID of the ContractInvocation.\n     *\n     * @returns The Wallet ID.\n     */\n    getWalletId() {\n        return this.model.wallet_id;\n    }\n    /**\n     * Returns the From Address ID of the ContractInvocation.\n     *\n     * @returns The From Address ID.\n     */\n    getFromAddressId() {\n        return this.model.address_id;\n    }\n    /**\n     * Returns the Destination Address ID of the ContractInvocation.\n     *\n     * @returns The Destination Address ID.\n     */\n    getContractAddressId() {\n        return this.model.contract_address;\n    }\n    /**\n     * Returns the Method of the ContractInvocation.\n     *\n     * @returns The Method.\n     */\n    getMethod() {\n        return this.model.method;\n    }\n    /**\n     * Returns the Arguments of the ContractInvocation.\n     *\n     * @returns {object} The arguments object passed to the contract invocation.\n     * The key is the argument name and the value is the argument value.\n     */\n    getArgs() {\n        return JSON.parse(this.model.args);\n    }\n    /**\n     * Returns the ABI of the ContractInvocation, if specified.\n     *\n     * @returns The ABI as an object, or undefined if not available.\n     */\n    getAbi() {\n        if (!this.model.abi)\n            return undefined;\n        return JSON.parse(this.model.abi);\n    }\n    /**\n     * Returns the amount of the native asset sent to a payable contract method, if applicable.\n     *\n     * @returns The amount in atomic units of the native asset.\n     */\n    getAmount() {\n        return new decimal_js_1.Decimal(this.model.amount);\n    }\n    /**\n     * Returns the Transaction Hash of the ContractInvocation.\n     *\n     * @returns The Transaction Hash as a Hex string, or undefined if not yet available.\n     */\n    getTransactionHash() {\n        return this.getTransaction().getTransactionHash();\n    }\n    /**\n     * Returns the Transaction of the ContractInvocation.\n     *\n     * @returns The ethers.js Transaction object.\n     * @throws (InvalidUnsignedPayload) If the Unsigned Payload is invalid.\n     */\n    getRawTransaction() {\n        return this.getTransaction().rawTransaction();\n    }\n    /**\n     * Signs the ContractInvocation with the provided key and returns the hex signature\n     * required for broadcasting the ContractInvocation.\n     *\n     * @param key - The key to sign the ContractInvocation with\n     * @returns The hex-encoded signed payload\n     */\n    async sign(key) {\n        return this.getTransaction().sign(key);\n    }\n    /**\n     * Returns the Status of the ContractInvocation.\n     *\n     * @returns The Status of the ContractInvocation.\n     */\n    getStatus() {\n        return this.getTransaction().getStatus();\n    }\n    /**\n     * Returns the Transaction of the ContractInvocation.\n     *\n     * @returns The Transaction\n     */\n    getTransaction() {\n        return new transaction_1.Transaction(this.model.transaction);\n    }\n    /**\n     * Returns the link to the Transaction on the blockchain explorer.\n     *\n     * @returns The link to the Transaction on the blockchain explorer.\n     */\n    getTransactionLink() {\n        return this.getTransaction().getTransactionLink();\n    }\n    /**\n     * Broadcasts the ContractInvocation to the Network.\n     *\n     * @returns The ContractInvocation object\n     * @throws {APIError} if the API request to broadcast a ContractInvocation fails.\n     */\n    async broadcast() {\n        if (!this.getTransaction()?.isSigned())\n            throw new Error(\"Cannot broadcast unsigned ContractInvocation\");\n        const broadcastContractInvocationRequest = {\n            signed_payload: this.getTransaction().getSignature(),\n        };\n        const response = await coinbase_1.Coinbase.apiClients.contractInvocation.broadcastContractInvocation(this.getWalletId(), this.getFromAddressId(), this.getId(), broadcastContractInvocationRequest);\n        return ContractInvocation.fromModel(response.data);\n    }\n    /**\n     * Waits for the ContractInvocation to be confirmed on the Network or fail on chain.\n     * Waits until the ContractInvocation is completed or failed on-chain by polling at the given interval.\n     * Raises an error if the ContractInvocation takes longer than the given timeout.\n     *\n     * @param options - The options to configure the wait function.\n     * @param options.intervalSeconds - The interval to check the status of the ContractInvocation.\n     * @param options.timeoutSeconds - The maximum time to wait for the ContractInvocation to be confirmed.\n     *\n     * @returns The ContractInvocation object in a terminal state.\n     * @throws {Error} if the ContractInvocation times out.\n     */\n    async wait({ intervalSeconds = 0.2, timeoutSeconds = 10, } = {}) {\n        const startTime = Date.now();\n        while (Date.now() - startTime < timeoutSeconds * 1000) {\n            await this.reload();\n            // If the ContractInvocation is in a terminal state, return the ContractInvocation.\n            const status = this.getStatus();\n            if (status === types_1.TransactionStatus.COMPLETE || status === types_1.TransactionStatus.FAILED) {\n                return this;\n            }\n            await (0, utils_1.delay)(intervalSeconds);\n        }\n        throw new errors_1.TimeoutError(\"ContractInvocation timed out\");\n    }\n    /**\n     * Reloads the ContractInvocation model with the latest data from the server.\n     *\n     * @throws {APIError} if the API request to get a ContractInvocation fails.\n     */\n    async reload() {\n        const result = await coinbase_1.Coinbase.apiClients.contractInvocation.getContractInvocation(this.getWalletId(), this.getFromAddressId(), this.getId());\n        this.model = result?.data;\n    }\n    /**\n     * Returns a string representation of the ContractInvocation.\n     *\n     * @returns The string representation of the ContractInvocation.\n     */\n    toString() {\n        return (`ContractInvocation{contractInvocationId: '${this.getId()}', networkId: '${this.getNetworkId()}', ` +\n            `fromAddressId: '${this.getFromAddressId()}', contractAddressId: '${this.getContractAddressId()}', ` +\n            `method: '${this.getMethod()}', args: '${this.getArgs()}', transactionHash: '${this.getTransactionHash()}', ` +\n            `transactionLink: '${this.getTransactionLink()}', status: '${this.getStatus()}'}`);\n    }\n}\nexports.ContractInvocation = ContractInvocation;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL2NvbnRyYWN0X2ludm9jYXRpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMEJBQTBCO0FBQzFCLHFCQUFxQixtQkFBTyxDQUFDLDhEQUFZO0FBQ3pDLGdCQUFnQixtQkFBTyxDQUFDLG1GQUFTO0FBQ2pDLHNCQUFzQixtQkFBTyxDQUFDLCtGQUFlO0FBQzdDLG1CQUFtQixtQkFBTyxDQUFDLHlGQUFZO0FBQ3ZDLGdCQUFnQixtQkFBTyxDQUFDLG1GQUFTO0FBQ2pDLGlCQUFpQixtQkFBTyxDQUFDLHFGQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBLGlCQUFpQiw4Q0FBOEMsSUFBSTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHlCQUF5QixhQUFhLGlCQUFpQixvQkFBb0I7QUFDL0csK0JBQStCLHdCQUF3Qix5QkFBeUIsNEJBQTRCO0FBQzVHLHdCQUF3QixpQkFBaUIsWUFBWSxlQUFlLHVCQUF1QiwwQkFBMEI7QUFDckgsaUNBQWlDLDBCQUEwQixjQUFjLGlCQUFpQixFQUFFO0FBQzVGO0FBQ0E7QUFDQSwwQkFBMEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXJ2aXZhbC1mdW4vLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL2NvbnRyYWN0X2ludm9jYXRpb24uanM/ZTQ5OSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29udHJhY3RJbnZvY2F0aW9uID0gdm9pZCAwO1xuY29uc3QgZGVjaW1hbF9qc18xID0gcmVxdWlyZShcImRlY2ltYWwuanNcIik7XG5jb25zdCB0eXBlc18xID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG5jb25zdCB0cmFuc2FjdGlvbl8xID0gcmVxdWlyZShcIi4vdHJhbnNhY3Rpb25cIik7XG5jb25zdCBjb2luYmFzZV8xID0gcmVxdWlyZShcIi4vY29pbmJhc2VcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuL2Vycm9yc1wiKTtcbi8qKlxuICogQSByZXByZXNlbnRhdGlvbiBvZiBhIENvbnRyYWN0SW52b2NhdGlvbiwgd2hpY2ggY2FsbHMgYSBzbWFydCBjb250cmFjdCBtZXRob2RcbiAqIG9uY2hhaW4uIFRoZSBmZWUgaXMgYXNzdW1lZCB0byBiZSBwYWlkIGluIHRoZSBuYXRpdmUgQXNzZXQgb2YgdGhlIE5ldHdvcmsuXG4gKi9cbmNsYXNzIENvbnRyYWN0SW52b2NhdGlvbiB7XG4gICAgLyoqXG4gICAgICogUHJpdmF0ZSBjb25zdHJ1Y3RvciB0byBwcmV2ZW50IGRpcmVjdCBpbnN0YW50aWF0aW9uIG91dHNpZGUgb2YgdGhlIGZhY3RvcnkgbWV0aG9kcy5cbiAgICAgKlxuICAgICAqIEBpZ25vcmVcbiAgICAgKiBAcGFyYW0gY29udHJhY3RJbnZvY2F0aW9uTW9kZWwgLSBUaGUgQ29udHJhY3RJbnZvY2F0aW9uIG1vZGVsLlxuICAgICAqIEBoaWRlY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb250cmFjdEludm9jYXRpb25Nb2RlbCkge1xuICAgICAgICBpZiAoIWNvbnRyYWN0SW52b2NhdGlvbk1vZGVsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb250cmFjdEludm9jYXRpb24gbW9kZWwgY2Fubm90IGJlIGVtcHR5XCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW9kZWwgPSBjb250cmFjdEludm9jYXRpb25Nb2RlbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBDb250cmFjdEludm9jYXRpb25Nb2RlbCBpbnRvIGEgQ29udHJhY3RJbnZvY2F0aW9uIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb250cmFjdEludm9jYXRpb25Nb2RlbCAtIFRoZSBDb250cmFjdEludm9jYXRpb24gbW9kZWwgb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIFRoZSBDb250cmFjdEludm9jYXRpb24gb2JqZWN0LlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tTW9kZWwoY29udHJhY3RJbnZvY2F0aW9uTW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb250cmFjdEludm9jYXRpb24oY29udHJhY3RJbnZvY2F0aW9uTW9kZWwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBJRCBvZiB0aGUgQ29udHJhY3RJbnZvY2F0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIENvbnRyYWN0SW52b2NhdGlvbiBJRC5cbiAgICAgKi9cbiAgICBnZXRJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwuY29udHJhY3RfaW52b2NhdGlvbl9pZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgTmV0d29yayBJRCBvZiB0aGUgQ29udHJhY3RJbnZvY2F0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIE5ldHdvcmsgSUQuXG4gICAgICovXG4gICAgZ2V0TmV0d29ya0lkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5uZXR3b3JrX2lkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBXYWxsZXQgSUQgb2YgdGhlIENvbnRyYWN0SW52b2NhdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBXYWxsZXQgSUQuXG4gICAgICovXG4gICAgZ2V0V2FsbGV0SWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLndhbGxldF9pZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgRnJvbSBBZGRyZXNzIElEIG9mIHRoZSBDb250cmFjdEludm9jYXRpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgRnJvbSBBZGRyZXNzIElELlxuICAgICAqL1xuICAgIGdldEZyb21BZGRyZXNzSWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLmFkZHJlc3NfaWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIERlc3RpbmF0aW9uIEFkZHJlc3MgSUQgb2YgdGhlIENvbnRyYWN0SW52b2NhdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBEZXN0aW5hdGlvbiBBZGRyZXNzIElELlxuICAgICAqL1xuICAgIGdldENvbnRyYWN0QWRkcmVzc0lkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5jb250cmFjdF9hZGRyZXNzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBNZXRob2Qgb2YgdGhlIENvbnRyYWN0SW52b2NhdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBNZXRob2QuXG4gICAgICovXG4gICAgZ2V0TWV0aG9kKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5tZXRob2Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIEFyZ3VtZW50cyBvZiB0aGUgQ29udHJhY3RJbnZvY2F0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybnMge29iamVjdH0gVGhlIGFyZ3VtZW50cyBvYmplY3QgcGFzc2VkIHRvIHRoZSBjb250cmFjdCBpbnZvY2F0aW9uLlxuICAgICAqIFRoZSBrZXkgaXMgdGhlIGFyZ3VtZW50IG5hbWUgYW5kIHRoZSB2YWx1ZSBpcyB0aGUgYXJndW1lbnQgdmFsdWUuXG4gICAgICovXG4gICAgZ2V0QXJncygpIHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UodGhpcy5tb2RlbC5hcmdzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgQUJJIG9mIHRoZSBDb250cmFjdEludm9jYXRpb24sIGlmIHNwZWNpZmllZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBBQkkgYXMgYW4gb2JqZWN0LCBvciB1bmRlZmluZWQgaWYgbm90IGF2YWlsYWJsZS5cbiAgICAgKi9cbiAgICBnZXRBYmkoKSB7XG4gICAgICAgIGlmICghdGhpcy5tb2RlbC5hYmkpXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZSh0aGlzLm1vZGVsLmFiaSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGFtb3VudCBvZiB0aGUgbmF0aXZlIGFzc2V0IHNlbnQgdG8gYSBwYXlhYmxlIGNvbnRyYWN0IG1ldGhvZCwgaWYgYXBwbGljYWJsZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBhbW91bnQgaW4gYXRvbWljIHVuaXRzIG9mIHRoZSBuYXRpdmUgYXNzZXQuXG4gICAgICovXG4gICAgZ2V0QW1vdW50KCkge1xuICAgICAgICByZXR1cm4gbmV3IGRlY2ltYWxfanNfMS5EZWNpbWFsKHRoaXMubW9kZWwuYW1vdW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgVHJhbnNhY3Rpb24gSGFzaCBvZiB0aGUgQ29udHJhY3RJbnZvY2F0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIFRyYW5zYWN0aW9uIEhhc2ggYXMgYSBIZXggc3RyaW5nLCBvciB1bmRlZmluZWQgaWYgbm90IHlldCBhdmFpbGFibGUuXG4gICAgICovXG4gICAgZ2V0VHJhbnNhY3Rpb25IYXNoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRUcmFuc2FjdGlvbigpLmdldFRyYW5zYWN0aW9uSGFzaCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBUcmFuc2FjdGlvbiBvZiB0aGUgQ29udHJhY3RJbnZvY2F0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGV0aGVycy5qcyBUcmFuc2FjdGlvbiBvYmplY3QuXG4gICAgICogQHRocm93cyAoSW52YWxpZFVuc2lnbmVkUGF5bG9hZCkgSWYgdGhlIFVuc2lnbmVkIFBheWxvYWQgaXMgaW52YWxpZC5cbiAgICAgKi9cbiAgICBnZXRSYXdUcmFuc2FjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHJhbnNhY3Rpb24oKS5yYXdUcmFuc2FjdGlvbigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaWducyB0aGUgQ29udHJhY3RJbnZvY2F0aW9uIHdpdGggdGhlIHByb3ZpZGVkIGtleSBhbmQgcmV0dXJucyB0aGUgaGV4IHNpZ25hdHVyZVxuICAgICAqIHJlcXVpcmVkIGZvciBicm9hZGNhc3RpbmcgdGhlIENvbnRyYWN0SW52b2NhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBrZXkgLSBUaGUga2V5IHRvIHNpZ24gdGhlIENvbnRyYWN0SW52b2NhdGlvbiB3aXRoXG4gICAgICogQHJldHVybnMgVGhlIGhleC1lbmNvZGVkIHNpZ25lZCBwYXlsb2FkXG4gICAgICovXG4gICAgYXN5bmMgc2lnbihrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHJhbnNhY3Rpb24oKS5zaWduKGtleSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIFN0YXR1cyBvZiB0aGUgQ29udHJhY3RJbnZvY2F0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIFN0YXR1cyBvZiB0aGUgQ29udHJhY3RJbnZvY2F0aW9uLlxuICAgICAqL1xuICAgIGdldFN0YXR1cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHJhbnNhY3Rpb24oKS5nZXRTdGF0dXMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgVHJhbnNhY3Rpb24gb2YgdGhlIENvbnRyYWN0SW52b2NhdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBUcmFuc2FjdGlvblxuICAgICAqL1xuICAgIGdldFRyYW5zYWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbmV3IHRyYW5zYWN0aW9uXzEuVHJhbnNhY3Rpb24odGhpcy5tb2RlbC50cmFuc2FjdGlvbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxpbmsgdG8gdGhlIFRyYW5zYWN0aW9uIG9uIHRoZSBibG9ja2NoYWluIGV4cGxvcmVyLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGxpbmsgdG8gdGhlIFRyYW5zYWN0aW9uIG9uIHRoZSBibG9ja2NoYWluIGV4cGxvcmVyLlxuICAgICAqL1xuICAgIGdldFRyYW5zYWN0aW9uTGluaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHJhbnNhY3Rpb24oKS5nZXRUcmFuc2FjdGlvbkxpbmsoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQnJvYWRjYXN0cyB0aGUgQ29udHJhY3RJbnZvY2F0aW9uIHRvIHRoZSBOZXR3b3JrLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIENvbnRyYWN0SW52b2NhdGlvbiBvYmplY3RcbiAgICAgKiBAdGhyb3dzIHtBUElFcnJvcn0gaWYgdGhlIEFQSSByZXF1ZXN0IHRvIGJyb2FkY2FzdCBhIENvbnRyYWN0SW52b2NhdGlvbiBmYWlscy5cbiAgICAgKi9cbiAgICBhc3luYyBicm9hZGNhc3QoKSB7XG4gICAgICAgIGlmICghdGhpcy5nZXRUcmFuc2FjdGlvbigpPy5pc1NpZ25lZCgpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGJyb2FkY2FzdCB1bnNpZ25lZCBDb250cmFjdEludm9jYXRpb25cIik7XG4gICAgICAgIGNvbnN0IGJyb2FkY2FzdENvbnRyYWN0SW52b2NhdGlvblJlcXVlc3QgPSB7XG4gICAgICAgICAgICBzaWduZWRfcGF5bG9hZDogdGhpcy5nZXRUcmFuc2FjdGlvbigpLmdldFNpZ25hdHVyZSgpLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNvaW5iYXNlXzEuQ29pbmJhc2UuYXBpQ2xpZW50cy5jb250cmFjdEludm9jYXRpb24uYnJvYWRjYXN0Q29udHJhY3RJbnZvY2F0aW9uKHRoaXMuZ2V0V2FsbGV0SWQoKSwgdGhpcy5nZXRGcm9tQWRkcmVzc0lkKCksIHRoaXMuZ2V0SWQoKSwgYnJvYWRjYXN0Q29udHJhY3RJbnZvY2F0aW9uUmVxdWVzdCk7XG4gICAgICAgIHJldHVybiBDb250cmFjdEludm9jYXRpb24uZnJvbU1vZGVsKHJlc3BvbnNlLmRhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXYWl0cyBmb3IgdGhlIENvbnRyYWN0SW52b2NhdGlvbiB0byBiZSBjb25maXJtZWQgb24gdGhlIE5ldHdvcmsgb3IgZmFpbCBvbiBjaGFpbi5cbiAgICAgKiBXYWl0cyB1bnRpbCB0aGUgQ29udHJhY3RJbnZvY2F0aW9uIGlzIGNvbXBsZXRlZCBvciBmYWlsZWQgb24tY2hhaW4gYnkgcG9sbGluZyBhdCB0aGUgZ2l2ZW4gaW50ZXJ2YWwuXG4gICAgICogUmFpc2VzIGFuIGVycm9yIGlmIHRoZSBDb250cmFjdEludm9jYXRpb24gdGFrZXMgbG9uZ2VyIHRoYW4gdGhlIGdpdmVuIHRpbWVvdXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIHRvIGNvbmZpZ3VyZSB0aGUgd2FpdCBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5pbnRlcnZhbFNlY29uZHMgLSBUaGUgaW50ZXJ2YWwgdG8gY2hlY2sgdGhlIHN0YXR1cyBvZiB0aGUgQ29udHJhY3RJbnZvY2F0aW9uLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnRpbWVvdXRTZWNvbmRzIC0gVGhlIG1heGltdW0gdGltZSB0byB3YWl0IGZvciB0aGUgQ29udHJhY3RJbnZvY2F0aW9uIHRvIGJlIGNvbmZpcm1lZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBDb250cmFjdEludm9jYXRpb24gb2JqZWN0IGluIGEgdGVybWluYWwgc3RhdGUuXG4gICAgICogQHRocm93cyB7RXJyb3J9IGlmIHRoZSBDb250cmFjdEludm9jYXRpb24gdGltZXMgb3V0LlxuICAgICAqL1xuICAgIGFzeW5jIHdhaXQoeyBpbnRlcnZhbFNlY29uZHMgPSAwLjIsIHRpbWVvdXRTZWNvbmRzID0gMTAsIH0gPSB7fSkge1xuICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICB3aGlsZSAoRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSA8IHRpbWVvdXRTZWNvbmRzICogMTAwMCkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5yZWxvYWQoKTtcbiAgICAgICAgICAgIC8vIElmIHRoZSBDb250cmFjdEludm9jYXRpb24gaXMgaW4gYSB0ZXJtaW5hbCBzdGF0ZSwgcmV0dXJuIHRoZSBDb250cmFjdEludm9jYXRpb24uXG4gICAgICAgICAgICBjb25zdCBzdGF0dXMgPSB0aGlzLmdldFN0YXR1cygpO1xuICAgICAgICAgICAgaWYgKHN0YXR1cyA9PT0gdHlwZXNfMS5UcmFuc2FjdGlvblN0YXR1cy5DT01QTEVURSB8fCBzdGF0dXMgPT09IHR5cGVzXzEuVHJhbnNhY3Rpb25TdGF0dXMuRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCAoMCwgdXRpbHNfMS5kZWxheSkoaW50ZXJ2YWxTZWNvbmRzKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVGltZW91dEVycm9yKFwiQ29udHJhY3RJbnZvY2F0aW9uIHRpbWVkIG91dFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVsb2FkcyB0aGUgQ29udHJhY3RJbnZvY2F0aW9uIG1vZGVsIHdpdGggdGhlIGxhdGVzdCBkYXRhIGZyb20gdGhlIHNlcnZlci5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0FQSUVycm9yfSBpZiB0aGUgQVBJIHJlcXVlc3QgdG8gZ2V0IGEgQ29udHJhY3RJbnZvY2F0aW9uIGZhaWxzLlxuICAgICAqL1xuICAgIGFzeW5jIHJlbG9hZCgpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29pbmJhc2VfMS5Db2luYmFzZS5hcGlDbGllbnRzLmNvbnRyYWN0SW52b2NhdGlvbi5nZXRDb250cmFjdEludm9jYXRpb24odGhpcy5nZXRXYWxsZXRJZCgpLCB0aGlzLmdldEZyb21BZGRyZXNzSWQoKSwgdGhpcy5nZXRJZCgpKTtcbiAgICAgICAgdGhpcy5tb2RlbCA9IHJlc3VsdD8uZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgQ29udHJhY3RJbnZvY2F0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgQ29udHJhY3RJbnZvY2F0aW9uLlxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gKGBDb250cmFjdEludm9jYXRpb257Y29udHJhY3RJbnZvY2F0aW9uSWQ6ICcke3RoaXMuZ2V0SWQoKX0nLCBuZXR3b3JrSWQ6ICcke3RoaXMuZ2V0TmV0d29ya0lkKCl9JywgYCArXG4gICAgICAgICAgICBgZnJvbUFkZHJlc3NJZDogJyR7dGhpcy5nZXRGcm9tQWRkcmVzc0lkKCl9JywgY29udHJhY3RBZGRyZXNzSWQ6ICcke3RoaXMuZ2V0Q29udHJhY3RBZGRyZXNzSWQoKX0nLCBgICtcbiAgICAgICAgICAgIGBtZXRob2Q6ICcke3RoaXMuZ2V0TWV0aG9kKCl9JywgYXJnczogJyR7dGhpcy5nZXRBcmdzKCl9JywgdHJhbnNhY3Rpb25IYXNoOiAnJHt0aGlzLmdldFRyYW5zYWN0aW9uSGFzaCgpfScsIGAgK1xuICAgICAgICAgICAgYHRyYW5zYWN0aW9uTGluazogJyR7dGhpcy5nZXRUcmFuc2FjdGlvbkxpbmsoKX0nLCBzdGF0dXM6ICcke3RoaXMuZ2V0U3RhdHVzKCl9J31gKTtcbiAgICB9XG59XG5leHBvcnRzLkNvbnRyYWN0SW52b2NhdGlvbiA9IENvbnRyYWN0SW52b2NhdGlvbjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/contract_invocation.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/crypto_amount.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/crypto_amount.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CryptoAmount = void 0;\nconst decimal_js_1 = __importDefault(__webpack_require__(/*! decimal.js */ \"(rsc)/./node_modules/decimal.js/decimal.js\"));\nconst asset_1 = __webpack_require__(/*! ./asset */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/asset.js\");\n/**\n * A representation of a CryptoAmount that includes the amount and asset.\n */\nclass CryptoAmount {\n    /**\n     * Creates a new CryptoAmount instance.\n     *\n     * @param amount - The amount of the Asset\n     * @param asset - The Asset\n     * @param assetId - Optional Asset ID override\n     */\n    constructor(amount, asset, assetId) {\n        this.amount = amount;\n        this.assetObj = asset;\n        this.assetId = assetId || asset.getAssetId();\n    }\n    /**\n     * Converts a CryptoAmount model to a CryptoAmount.\n     *\n     * @param amountModel - The crypto amount from the API\n     * @returns The converted CryptoAmount object\n     */\n    static fromModel(amountModel) {\n        const asset = asset_1.Asset.fromModel(amountModel.asset);\n        return new CryptoAmount(asset.fromAtomicAmount(new decimal_js_1.default(amountModel.amount)), asset);\n    }\n    /**\n     * Converts a CryptoAmount model and asset ID to a CryptoAmount.\n     * This can be used to specify a non-primary denomination that we want the amount\n     * to be converted to.\n     *\n     * @param amountModel - The crypto amount from the API\n     * @param assetId - The Asset ID of the denomination we want returned\n     * @returns The converted CryptoAmount object\n     */\n    static fromModelAndAssetId(amountModel, assetId) {\n        const asset = asset_1.Asset.fromModel(amountModel.asset, assetId);\n        return new CryptoAmount(asset.fromAtomicAmount(new decimal_js_1.default(amountModel.amount)), asset, assetId);\n    }\n    /**\n     * Gets the amount of the Asset.\n     *\n     * @returns The amount of the Asset\n     */\n    getAmount() {\n        return this.amount;\n    }\n    /**\n     * Gets the Asset.\n     *\n     * @returns The Asset\n     */\n    getAsset() {\n        return this.assetObj;\n    }\n    /**\n     * Gets the Asset ID.\n     *\n     * @returns The Asset ID\n     */\n    getAssetId() {\n        return this.assetId;\n    }\n    /**\n     * Converts the amount to atomic units.\n     *\n     * @returns The amount in atomic units\n     */\n    toAtomicAmount() {\n        return this.assetObj.toAtomicAmount(this.amount);\n    }\n    /**\n     * Returns a string representation of the CryptoAmount.\n     *\n     * @returns A string representation of the CryptoAmount\n     */\n    toString() {\n        return `CryptoAmount{amount: '${this.amount}', assetId: '${this.assetId}'}`;\n    }\n}\nexports.CryptoAmount = CryptoAmount;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL2NyeXB0b19hbW91bnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0I7QUFDcEIscUNBQXFDLG1CQUFPLENBQUMsOERBQVk7QUFDekQsZ0JBQWdCLG1CQUFPLENBQUMsbUZBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixXQUFXLFlBQVksZUFBZSxhQUFhLEVBQUU7QUFDbEY7QUFDQTtBQUNBLG9CQUFvQiIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cnZpdmFsLWZ1bi8uL25vZGVfbW9kdWxlcy9AY29pbmJhc2UvY29pbmJhc2Utc2RrL2Rpc3QvY29pbmJhc2UvY3J5cHRvX2Ftb3VudC5qcz80NjNkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DcnlwdG9BbW91bnQgPSB2b2lkIDA7XG5jb25zdCBkZWNpbWFsX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImRlY2ltYWwuanNcIikpO1xuY29uc3QgYXNzZXRfMSA9IHJlcXVpcmUoXCIuL2Fzc2V0XCIpO1xuLyoqXG4gKiBBIHJlcHJlc2VudGF0aW9uIG9mIGEgQ3J5cHRvQW1vdW50IHRoYXQgaW5jbHVkZXMgdGhlIGFtb3VudCBhbmQgYXNzZXQuXG4gKi9cbmNsYXNzIENyeXB0b0Ftb3VudCB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBDcnlwdG9BbW91bnQgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYW1vdW50IC0gVGhlIGFtb3VudCBvZiB0aGUgQXNzZXRcbiAgICAgKiBAcGFyYW0gYXNzZXQgLSBUaGUgQXNzZXRcbiAgICAgKiBAcGFyYW0gYXNzZXRJZCAtIE9wdGlvbmFsIEFzc2V0IElEIG92ZXJyaWRlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoYW1vdW50LCBhc3NldCwgYXNzZXRJZCkge1xuICAgICAgICB0aGlzLmFtb3VudCA9IGFtb3VudDtcbiAgICAgICAgdGhpcy5hc3NldE9iaiA9IGFzc2V0O1xuICAgICAgICB0aGlzLmFzc2V0SWQgPSBhc3NldElkIHx8IGFzc2V0LmdldEFzc2V0SWQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBDcnlwdG9BbW91bnQgbW9kZWwgdG8gYSBDcnlwdG9BbW91bnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYW1vdW50TW9kZWwgLSBUaGUgY3J5cHRvIGFtb3VudCBmcm9tIHRoZSBBUElcbiAgICAgKiBAcmV0dXJucyBUaGUgY29udmVydGVkIENyeXB0b0Ftb3VudCBvYmplY3RcbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbU1vZGVsKGFtb3VudE1vZGVsKSB7XG4gICAgICAgIGNvbnN0IGFzc2V0ID0gYXNzZXRfMS5Bc3NldC5mcm9tTW9kZWwoYW1vdW50TW9kZWwuYXNzZXQpO1xuICAgICAgICByZXR1cm4gbmV3IENyeXB0b0Ftb3VudChhc3NldC5mcm9tQXRvbWljQW1vdW50KG5ldyBkZWNpbWFsX2pzXzEuZGVmYXVsdChhbW91bnRNb2RlbC5hbW91bnQpKSwgYXNzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIENyeXB0b0Ftb3VudCBtb2RlbCBhbmQgYXNzZXQgSUQgdG8gYSBDcnlwdG9BbW91bnQuXG4gICAgICogVGhpcyBjYW4gYmUgdXNlZCB0byBzcGVjaWZ5IGEgbm9uLXByaW1hcnkgZGVub21pbmF0aW9uIHRoYXQgd2Ugd2FudCB0aGUgYW1vdW50XG4gICAgICogdG8gYmUgY29udmVydGVkIHRvLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFtb3VudE1vZGVsIC0gVGhlIGNyeXB0byBhbW91bnQgZnJvbSB0aGUgQVBJXG4gICAgICogQHBhcmFtIGFzc2V0SWQgLSBUaGUgQXNzZXQgSUQgb2YgdGhlIGRlbm9taW5hdGlvbiB3ZSB3YW50IHJldHVybmVkXG4gICAgICogQHJldHVybnMgVGhlIGNvbnZlcnRlZCBDcnlwdG9BbW91bnQgb2JqZWN0XG4gICAgICovXG4gICAgc3RhdGljIGZyb21Nb2RlbEFuZEFzc2V0SWQoYW1vdW50TW9kZWwsIGFzc2V0SWQpIHtcbiAgICAgICAgY29uc3QgYXNzZXQgPSBhc3NldF8xLkFzc2V0LmZyb21Nb2RlbChhbW91bnRNb2RlbC5hc3NldCwgYXNzZXRJZCk7XG4gICAgICAgIHJldHVybiBuZXcgQ3J5cHRvQW1vdW50KGFzc2V0LmZyb21BdG9taWNBbW91bnQobmV3IGRlY2ltYWxfanNfMS5kZWZhdWx0KGFtb3VudE1vZGVsLmFtb3VudCkpLCBhc3NldCwgYXNzZXRJZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGFtb3VudCBvZiB0aGUgQXNzZXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgYW1vdW50IG9mIHRoZSBBc3NldFxuICAgICAqL1xuICAgIGdldEFtb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYW1vdW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBBc3NldC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBBc3NldFxuICAgICAqL1xuICAgIGdldEFzc2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hc3NldE9iajtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgQXNzZXQgSUQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgQXNzZXQgSURcbiAgICAgKi9cbiAgICBnZXRBc3NldElkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hc3NldElkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgYW1vdW50IHRvIGF0b21pYyB1bml0cy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBhbW91bnQgaW4gYXRvbWljIHVuaXRzXG4gICAgICovXG4gICAgdG9BdG9taWNBbW91bnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFzc2V0T2JqLnRvQXRvbWljQW1vdW50KHRoaXMuYW1vdW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgQ3J5cHRvQW1vdW50LlxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIENyeXB0b0Ftb3VudFxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gYENyeXB0b0Ftb3VudHthbW91bnQ6ICcke3RoaXMuYW1vdW50fScsIGFzc2V0SWQ6ICcke3RoaXMuYXNzZXRJZH0nfWA7XG4gICAgfVxufVxuZXhwb3J0cy5DcnlwdG9BbW91bnQgPSBDcnlwdG9BbW91bnQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/crypto_amount.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/errors.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/errors.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AlreadySignedError = exports.NotSignedError = exports.InvalidUnsignedPayloadError = exports.InvalidConfigurationError = exports.ArgumentError = exports.TimeoutError = exports.InvalidAPIKeyFormatError = void 0;\n/**\n * InvalidAPIKeyFormatError error is thrown when the API key format is invalid.\n */\nclass InvalidAPIKeyFormatError extends Error {\n    /**\n     * Initializes a new InvalidAPIKeyFormat instance.\n     *\n     * @param message - The error message.\n     */\n    constructor(message = InvalidAPIKeyFormatError.DEFAULT_MESSAGE) {\n        super(message);\n        this.name = \"InvalidAPIKeyFormatError\";\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, InvalidAPIKeyFormatError);\n        }\n    }\n}\nexports.InvalidAPIKeyFormatError = InvalidAPIKeyFormatError;\nInvalidAPIKeyFormatError.DEFAULT_MESSAGE = \"Invalid API key format\";\n/**\n * TimeoutError is thrown when an operation times out.\n */\nclass TimeoutError extends Error {\n    /**\n     * Initializes a new TimeoutError instance.\n     *\n     * @param message - The error message.\n     */\n    constructor(message = \"Timeout Error\") {\n        super(message);\n        this.name = \"TimeoutError\";\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, TimeoutError);\n        }\n    }\n}\nexports.TimeoutError = TimeoutError;\n/**\n * ArgumentError is thrown when an argument is invalid.\n */\nclass ArgumentError extends Error {\n    /**\n     * Initializes a new ArgumentError instance.\n     *\n     * @param message - The error message.\n     */\n    constructor(message = ArgumentError.DEFAULT_MESSAGE) {\n        super(message);\n        this.name = \"ArgumentError\";\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, ArgumentError);\n        }\n    }\n}\nexports.ArgumentError = ArgumentError;\nArgumentError.DEFAULT_MESSAGE = \"Argument Error\";\n/**\n * InvalidConfigurationError error is thrown when apikey/privateKey configuration is invalid.\n */\nclass InvalidConfigurationError extends Error {\n    /**\n     * Initializes a new InvalidConfiguration instance.\n     *\n     * @param message - The error message.\n     */\n    constructor(message = InvalidConfigurationError.DEFAULT_MESSAGE) {\n        super(message);\n        this.name = \"InvalidConfigurationError\";\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, InvalidConfigurationError);\n        }\n    }\n}\nexports.InvalidConfigurationError = InvalidConfigurationError;\nInvalidConfigurationError.DEFAULT_MESSAGE = \"Invalid configuration\";\n/**\n * InvalidUnsignedPayload error is thrown when the unsigned payload is invalid.\n */\nclass InvalidUnsignedPayloadError extends Error {\n    /**\n     * Initializes a new InvalidUnsignedPayload instance.\n     *\n     * @param message - The error message.\n     */\n    constructor(message = InvalidUnsignedPayloadError.DEFAULT_MESSAGE) {\n        super(message);\n        this.name = \"InvalidUnsignedPayloadError\";\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, InvalidUnsignedPayloadError);\n        }\n    }\n}\nexports.InvalidUnsignedPayloadError = InvalidUnsignedPayloadError;\nInvalidUnsignedPayloadError.DEFAULT_MESSAGE = \"Invalid unsigned payload\";\n/**\n * NotSignedError is thrown when a resource is not signed.\n */\nclass NotSignedError extends Error {\n    /**\n     * Initializes a new NotSignedError instance.\n     *\n     * @param message - The error message.\n     */\n    constructor(message = \"Resource not signed\") {\n        super(message);\n        this.name = \"NotSignedError\";\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, NotSignedError);\n        }\n    }\n}\nexports.NotSignedError = NotSignedError;\n/**\n * AlreadySignedError is thrown when a resource is already signed.\n */\nclass AlreadySignedError extends Error {\n    /**\n     * Initializes a new AlreadySignedError instance.\n     *\n     * @param message - The error message.\n     */\n    constructor(message = AlreadySignedError.DEFAULT_MESSAGE) {\n        super(message);\n        this.name = \"AlreadySignedError\";\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, AlreadySignedError);\n        }\n    }\n}\nexports.AlreadySignedError = AlreadySignedError;\nAlreadySignedError.DEFAULT_MESSAGE = \"Resource already signed\";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL2Vycm9ycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwwQkFBMEIsR0FBRyxzQkFBc0IsR0FBRyxtQ0FBbUMsR0FBRyxpQ0FBaUMsR0FBRyxxQkFBcUIsR0FBRyxvQkFBb0IsR0FBRyxnQ0FBZ0M7QUFDL007QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3Vydml2YWwtZnVuLy4vbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9jb2luYmFzZS1zZGsvZGlzdC9jb2luYmFzZS9lcnJvcnMuanM/NzYzMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQWxyZWFkeVNpZ25lZEVycm9yID0gZXhwb3J0cy5Ob3RTaWduZWRFcnJvciA9IGV4cG9ydHMuSW52YWxpZFVuc2lnbmVkUGF5bG9hZEVycm9yID0gZXhwb3J0cy5JbnZhbGlkQ29uZmlndXJhdGlvbkVycm9yID0gZXhwb3J0cy5Bcmd1bWVudEVycm9yID0gZXhwb3J0cy5UaW1lb3V0RXJyb3IgPSBleHBvcnRzLkludmFsaWRBUElLZXlGb3JtYXRFcnJvciA9IHZvaWQgMDtcbi8qKlxuICogSW52YWxpZEFQSUtleUZvcm1hdEVycm9yIGVycm9yIGlzIHRocm93biB3aGVuIHRoZSBBUEkga2V5IGZvcm1hdCBpcyBpbnZhbGlkLlxuICovXG5jbGFzcyBJbnZhbGlkQVBJS2V5Rm9ybWF0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYSBuZXcgSW52YWxpZEFQSUtleUZvcm1hdCBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBtZXNzYWdlIC0gVGhlIGVycm9yIG1lc3NhZ2UuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobWVzc2FnZSA9IEludmFsaWRBUElLZXlGb3JtYXRFcnJvci5ERUZBVUxUX01FU1NBR0UpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiSW52YWxpZEFQSUtleUZvcm1hdEVycm9yXCI7XG4gICAgICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgSW52YWxpZEFQSUtleUZvcm1hdEVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuSW52YWxpZEFQSUtleUZvcm1hdEVycm9yID0gSW52YWxpZEFQSUtleUZvcm1hdEVycm9yO1xuSW52YWxpZEFQSUtleUZvcm1hdEVycm9yLkRFRkFVTFRfTUVTU0FHRSA9IFwiSW52YWxpZCBBUEkga2V5IGZvcm1hdFwiO1xuLyoqXG4gKiBUaW1lb3V0RXJyb3IgaXMgdGhyb3duIHdoZW4gYW4gb3BlcmF0aW9uIHRpbWVzIG91dC5cbiAqL1xuY2xhc3MgVGltZW91dEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGEgbmV3IFRpbWVvdXRFcnJvciBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBtZXNzYWdlIC0gVGhlIGVycm9yIG1lc3NhZ2UuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobWVzc2FnZSA9IFwiVGltZW91dCBFcnJvclwiKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIlRpbWVvdXRFcnJvclwiO1xuICAgICAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAgICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIFRpbWVvdXRFcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLlRpbWVvdXRFcnJvciA9IFRpbWVvdXRFcnJvcjtcbi8qKlxuICogQXJndW1lbnRFcnJvciBpcyB0aHJvd24gd2hlbiBhbiBhcmd1bWVudCBpcyBpbnZhbGlkLlxuICovXG5jbGFzcyBBcmd1bWVudEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGEgbmV3IEFyZ3VtZW50RXJyb3IgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWVzc2FnZSAtIFRoZSBlcnJvciBtZXNzYWdlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UgPSBBcmd1bWVudEVycm9yLkRFRkFVTFRfTUVTU0FHRSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJBcmd1bWVudEVycm9yXCI7XG4gICAgICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgQXJndW1lbnRFcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkFyZ3VtZW50RXJyb3IgPSBBcmd1bWVudEVycm9yO1xuQXJndW1lbnRFcnJvci5ERUZBVUxUX01FU1NBR0UgPSBcIkFyZ3VtZW50IEVycm9yXCI7XG4vKipcbiAqIEludmFsaWRDb25maWd1cmF0aW9uRXJyb3IgZXJyb3IgaXMgdGhyb3duIHdoZW4gYXBpa2V5L3ByaXZhdGVLZXkgY29uZmlndXJhdGlvbiBpcyBpbnZhbGlkLlxuICovXG5jbGFzcyBJbnZhbGlkQ29uZmlndXJhdGlvbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGEgbmV3IEludmFsaWRDb25maWd1cmF0aW9uIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgLSBUaGUgZXJyb3IgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlID0gSW52YWxpZENvbmZpZ3VyYXRpb25FcnJvci5ERUZBVUxUX01FU1NBR0UpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiSW52YWxpZENvbmZpZ3VyYXRpb25FcnJvclwiO1xuICAgICAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAgICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIEludmFsaWRDb25maWd1cmF0aW9uRXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5JbnZhbGlkQ29uZmlndXJhdGlvbkVycm9yID0gSW52YWxpZENvbmZpZ3VyYXRpb25FcnJvcjtcbkludmFsaWRDb25maWd1cmF0aW9uRXJyb3IuREVGQVVMVF9NRVNTQUdFID0gXCJJbnZhbGlkIGNvbmZpZ3VyYXRpb25cIjtcbi8qKlxuICogSW52YWxpZFVuc2lnbmVkUGF5bG9hZCBlcnJvciBpcyB0aHJvd24gd2hlbiB0aGUgdW5zaWduZWQgcGF5bG9hZCBpcyBpbnZhbGlkLlxuICovXG5jbGFzcyBJbnZhbGlkVW5zaWduZWRQYXlsb2FkRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYSBuZXcgSW52YWxpZFVuc2lnbmVkUGF5bG9hZCBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBtZXNzYWdlIC0gVGhlIGVycm9yIG1lc3NhZ2UuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobWVzc2FnZSA9IEludmFsaWRVbnNpZ25lZFBheWxvYWRFcnJvci5ERUZBVUxUX01FU1NBR0UpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiSW52YWxpZFVuc2lnbmVkUGF5bG9hZEVycm9yXCI7XG4gICAgICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgSW52YWxpZFVuc2lnbmVkUGF5bG9hZEVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuSW52YWxpZFVuc2lnbmVkUGF5bG9hZEVycm9yID0gSW52YWxpZFVuc2lnbmVkUGF5bG9hZEVycm9yO1xuSW52YWxpZFVuc2lnbmVkUGF5bG9hZEVycm9yLkRFRkFVTFRfTUVTU0FHRSA9IFwiSW52YWxpZCB1bnNpZ25lZCBwYXlsb2FkXCI7XG4vKipcbiAqIE5vdFNpZ25lZEVycm9yIGlzIHRocm93biB3aGVuIGEgcmVzb3VyY2UgaXMgbm90IHNpZ25lZC5cbiAqL1xuY2xhc3MgTm90U2lnbmVkRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYSBuZXcgTm90U2lnbmVkRXJyb3IgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWVzc2FnZSAtIFRoZSBlcnJvciBtZXNzYWdlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UgPSBcIlJlc291cmNlIG5vdCBzaWduZWRcIikge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJOb3RTaWduZWRFcnJvclwiO1xuICAgICAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAgICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIE5vdFNpZ25lZEVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuTm90U2lnbmVkRXJyb3IgPSBOb3RTaWduZWRFcnJvcjtcbi8qKlxuICogQWxyZWFkeVNpZ25lZEVycm9yIGlzIHRocm93biB3aGVuIGEgcmVzb3VyY2UgaXMgYWxyZWFkeSBzaWduZWQuXG4gKi9cbmNsYXNzIEFscmVhZHlTaWduZWRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhIG5ldyBBbHJlYWR5U2lnbmVkRXJyb3IgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWVzc2FnZSAtIFRoZSBlcnJvciBtZXNzYWdlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UgPSBBbHJlYWR5U2lnbmVkRXJyb3IuREVGQVVMVF9NRVNTQUdFKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIkFscmVhZHlTaWduZWRFcnJvclwiO1xuICAgICAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAgICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIEFscmVhZHlTaWduZWRFcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkFscmVhZHlTaWduZWRFcnJvciA9IEFscmVhZHlTaWduZWRFcnJvcjtcbkFscmVhZHlTaWduZWRFcnJvci5ERUZBVUxUX01FU1NBR0UgPSBcIlJlc291cmNlIGFscmVhZHkgc2lnbmVkXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/errors.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/faucet_transaction.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/faucet_transaction.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FaucetTransaction = void 0;\nconst coinbase_1 = __webpack_require__(/*! ./coinbase */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/coinbase.js\");\nconst transaction_1 = __webpack_require__(/*! ./transaction */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/transaction.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/utils.js\");\nconst errors_1 = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/errors.js\");\n/**\n * Represents a transaction from a faucet.\n */\nclass FaucetTransaction {\n    /**\n     * Creates a new FaucetTransaction instance.\n     * Do not use this method directly - instead, use Address.faucet().\n     *\n     * @class\n     * @param {FaucetTransactionModel} model - The FaucetTransaction model.\n     * @throws {Error} If the model does not exist.\n     */\n    constructor(model) {\n        if (!model?.transaction) {\n            throw new Error(\"FaucetTransaction model cannot be empty\");\n        }\n        this.model = model;\n        this._transaction = new transaction_1.Transaction(this.model.transaction);\n    }\n    /**\n     * Returns the Transaction of the FaucetTransaction.\n     *\n     * @returns The Faucet Transaction\n     */\n    get transaction() {\n        return this._transaction;\n    }\n    /**\n     * Returns the transaction hash.\n     *\n     * @returns {string} The transaction hash.\n     */\n    getTransactionHash() {\n        return this.transaction.getTransactionHash();\n    }\n    /**\n     * Returns the link to the transaction on the blockchain explorer.\n     *\n     * @returns {string} The link to the transaction on the blockchain explorer\n     */\n    getTransactionLink() {\n        return this.transaction.getTransactionLink();\n    }\n    /**\n     * Returns the Status of the FaucetTransaction.\n     *\n     * @returns The Status of the FaucetTransaction.\n     */\n    getStatus() {\n        return this.transaction.getStatus();\n    }\n    /**\n     * Returns the network ID of the FaucetTransaction.\n     *\n     * @returns {string} The network ID.\n     */\n    getNetworkId() {\n        return this.transaction.getNetworkId();\n    }\n    /**\n     * Returns the address that is being funded by the faucet.\n     *\n     * @returns {string} The address ID.\n     */\n    getAddressId() {\n        return this.transaction.toAddressId();\n    }\n    /**\n     * Waits for the FaucetTransaction to be confirmed on the Network or fail on chain.\n     * Waits until the FaucetTransaction is completed or failed on-chain by polling at the given interval.\n     * Raises an error if the FaucetTransaction takes longer than the given timeout.\n     *\n     * @param options - The options to configure the wait function.\n     * @param options.intervalSeconds - The interval to check the status of the FaucetTransaction.\n     * @param options.timeoutSeconds - The maximum time to wait for the FaucetTransaction to be confirmed.\n     *\n     * @returns The FaucetTransaction object in a terminal state.\n     * @throws {Error} if the FaucetTransaction times out.\n     */\n    async wait({ intervalSeconds = 0.2, timeoutSeconds = 10, } = {}) {\n        const startTime = Date.now();\n        while (Date.now() - startTime < timeoutSeconds * 1000) {\n            await this.reload();\n            // If the FaucetTransaction is in a terminal state, return the FaucetTransaction.\n            if (this.transaction.isTerminalState()) {\n                return this;\n            }\n            await (0, utils_1.delay)(intervalSeconds);\n        }\n        throw new errors_1.TimeoutError(\"FaucetTransaction timed out\");\n    }\n    /**\n     * Reloads the FaucetTransaction model with the latest data from the server.\n     *\n     * @returns {FaucetTransaction} The reloaded FaucetTransaction object.\n     * @throws {APIError} if the API request to get a FaucetTransaction fails.\n     */\n    async reload() {\n        const result = await coinbase_1.Coinbase.apiClients.externalAddress.getFaucetTransaction(this.transaction.getNetworkId(), this.getAddressId(), this.getTransactionHash());\n        this.model = result?.data;\n        if (!this.model?.transaction) {\n            throw new Error(\"FaucetTransaction model cannot be empty\");\n        }\n        this._transaction = new transaction_1.Transaction(this.model.transaction);\n        return this;\n    }\n    /**\n     * Returns a string representation of the FaucetTransaction.\n     *\n     * @returns {string} A string representation of the FaucetTransaction.\n     */\n    toString() {\n        return `Coinbase::FaucetTransaction{transaction_hash: '${this.getTransactionHash()}', transaction_link: '${this.getTransactionLink()}'}`;\n    }\n}\nexports.FaucetTransaction = FaucetTransaction;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL2ZhdWNldF90cmFuc2FjdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx5QkFBeUI7QUFDekIsbUJBQW1CLG1CQUFPLENBQUMseUZBQVk7QUFDdkMsc0JBQXNCLG1CQUFPLENBQUMsK0ZBQWU7QUFDN0MsZ0JBQWdCLG1CQUFPLENBQUMsbUZBQVM7QUFDakMsaUJBQWlCLG1CQUFPLENBQUMscUZBQVU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx3QkFBd0I7QUFDdkMsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0EsaUJBQWlCLDhDQUE4QyxJQUFJO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQW1CO0FBQ3BDLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBLDRDQUE0QyxxQkFBcUIsMEJBQTBCLHdCQUF3QiwwQkFBMEIsRUFBRTtBQUMvSTtBQUNBO0FBQ0EseUJBQXlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3Vydml2YWwtZnVuLy4vbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9jb2luYmFzZS1zZGsvZGlzdC9jb2luYmFzZS9mYXVjZXRfdHJhbnNhY3Rpb24uanM/MDM0YiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRmF1Y2V0VHJhbnNhY3Rpb24gPSB2b2lkIDA7XG5jb25zdCBjb2luYmFzZV8xID0gcmVxdWlyZShcIi4vY29pbmJhc2VcIik7XG5jb25zdCB0cmFuc2FjdGlvbl8xID0gcmVxdWlyZShcIi4vdHJhbnNhY3Rpb25cIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuL2Vycm9yc1wiKTtcbi8qKlxuICogUmVwcmVzZW50cyBhIHRyYW5zYWN0aW9uIGZyb20gYSBmYXVjZXQuXG4gKi9cbmNsYXNzIEZhdWNldFRyYW5zYWN0aW9uIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IEZhdWNldFRyYW5zYWN0aW9uIGluc3RhbmNlLlxuICAgICAqIERvIG5vdCB1c2UgdGhpcyBtZXRob2QgZGlyZWN0bHkgLSBpbnN0ZWFkLCB1c2UgQWRkcmVzcy5mYXVjZXQoKS5cbiAgICAgKlxuICAgICAqIEBjbGFzc1xuICAgICAqIEBwYXJhbSB7RmF1Y2V0VHJhbnNhY3Rpb25Nb2RlbH0gbW9kZWwgLSBUaGUgRmF1Y2V0VHJhbnNhY3Rpb24gbW9kZWwuXG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBtb2RlbCBkb2VzIG5vdCBleGlzdC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihtb2RlbCkge1xuICAgICAgICBpZiAoIW1vZGVsPy50cmFuc2FjdGlvbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmF1Y2V0VHJhbnNhY3Rpb24gbW9kZWwgY2Fubm90IGJlIGVtcHR5XCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW9kZWwgPSBtb2RlbDtcbiAgICAgICAgdGhpcy5fdHJhbnNhY3Rpb24gPSBuZXcgdHJhbnNhY3Rpb25fMS5UcmFuc2FjdGlvbih0aGlzLm1vZGVsLnRyYW5zYWN0aW9uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgVHJhbnNhY3Rpb24gb2YgdGhlIEZhdWNldFRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIEZhdWNldCBUcmFuc2FjdGlvblxuICAgICAqL1xuICAgIGdldCB0cmFuc2FjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zYWN0aW9uO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB0cmFuc2FjdGlvbiBoYXNoLlxuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIHRyYW5zYWN0aW9uIGhhc2guXG4gICAgICovXG4gICAgZ2V0VHJhbnNhY3Rpb25IYXNoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2FjdGlvbi5nZXRUcmFuc2FjdGlvbkhhc2goKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbGluayB0byB0aGUgdHJhbnNhY3Rpb24gb24gdGhlIGJsb2NrY2hhaW4gZXhwbG9yZXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgbGluayB0byB0aGUgdHJhbnNhY3Rpb24gb24gdGhlIGJsb2NrY2hhaW4gZXhwbG9yZXJcbiAgICAgKi9cbiAgICBnZXRUcmFuc2FjdGlvbkxpbmsoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zYWN0aW9uLmdldFRyYW5zYWN0aW9uTGluaygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBTdGF0dXMgb2YgdGhlIEZhdWNldFRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIFN0YXR1cyBvZiB0aGUgRmF1Y2V0VHJhbnNhY3Rpb24uXG4gICAgICovXG4gICAgZ2V0U3RhdHVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2FjdGlvbi5nZXRTdGF0dXMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbmV0d29yayBJRCBvZiB0aGUgRmF1Y2V0VHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgbmV0d29yayBJRC5cbiAgICAgKi9cbiAgICBnZXROZXR3b3JrSWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zYWN0aW9uLmdldE5ldHdvcmtJZCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBhZGRyZXNzIHRoYXQgaXMgYmVpbmcgZnVuZGVkIGJ5IHRoZSBmYXVjZXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgYWRkcmVzcyBJRC5cbiAgICAgKi9cbiAgICBnZXRBZGRyZXNzSWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zYWN0aW9uLnRvQWRkcmVzc0lkKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdhaXRzIGZvciB0aGUgRmF1Y2V0VHJhbnNhY3Rpb24gdG8gYmUgY29uZmlybWVkIG9uIHRoZSBOZXR3b3JrIG9yIGZhaWwgb24gY2hhaW4uXG4gICAgICogV2FpdHMgdW50aWwgdGhlIEZhdWNldFRyYW5zYWN0aW9uIGlzIGNvbXBsZXRlZCBvciBmYWlsZWQgb24tY2hhaW4gYnkgcG9sbGluZyBhdCB0aGUgZ2l2ZW4gaW50ZXJ2YWwuXG4gICAgICogUmFpc2VzIGFuIGVycm9yIGlmIHRoZSBGYXVjZXRUcmFuc2FjdGlvbiB0YWtlcyBsb25nZXIgdGhhbiB0aGUgZ2l2ZW4gdGltZW91dC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgdG8gY29uZmlndXJlIHRoZSB3YWl0IGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmludGVydmFsU2Vjb25kcyAtIFRoZSBpbnRlcnZhbCB0byBjaGVjayB0aGUgc3RhdHVzIG9mIHRoZSBGYXVjZXRUcmFuc2FjdGlvbi5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy50aW1lb3V0U2Vjb25kcyAtIFRoZSBtYXhpbXVtIHRpbWUgdG8gd2FpdCBmb3IgdGhlIEZhdWNldFRyYW5zYWN0aW9uIHRvIGJlIGNvbmZpcm1lZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBGYXVjZXRUcmFuc2FjdGlvbiBvYmplY3QgaW4gYSB0ZXJtaW5hbCBzdGF0ZS5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlIEZhdWNldFRyYW5zYWN0aW9uIHRpbWVzIG91dC5cbiAgICAgKi9cbiAgICBhc3luYyB3YWl0KHsgaW50ZXJ2YWxTZWNvbmRzID0gMC4yLCB0aW1lb3V0U2Vjb25kcyA9IDEwLCB9ID0ge30pIHtcbiAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgd2hpbGUgKERhdGUubm93KCkgLSBzdGFydFRpbWUgPCB0aW1lb3V0U2Vjb25kcyAqIDEwMDApIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucmVsb2FkKCk7XG4gICAgICAgICAgICAvLyBJZiB0aGUgRmF1Y2V0VHJhbnNhY3Rpb24gaXMgaW4gYSB0ZXJtaW5hbCBzdGF0ZSwgcmV0dXJuIHRoZSBGYXVjZXRUcmFuc2FjdGlvbi5cbiAgICAgICAgICAgIGlmICh0aGlzLnRyYW5zYWN0aW9uLmlzVGVybWluYWxTdGF0ZSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCAoMCwgdXRpbHNfMS5kZWxheSkoaW50ZXJ2YWxTZWNvbmRzKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVGltZW91dEVycm9yKFwiRmF1Y2V0VHJhbnNhY3Rpb24gdGltZWQgb3V0XCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWxvYWRzIHRoZSBGYXVjZXRUcmFuc2FjdGlvbiBtb2RlbCB3aXRoIHRoZSBsYXRlc3QgZGF0YSBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7RmF1Y2V0VHJhbnNhY3Rpb259IFRoZSByZWxvYWRlZCBGYXVjZXRUcmFuc2FjdGlvbiBvYmplY3QuXG4gICAgICogQHRocm93cyB7QVBJRXJyb3J9IGlmIHRoZSBBUEkgcmVxdWVzdCB0byBnZXQgYSBGYXVjZXRUcmFuc2FjdGlvbiBmYWlscy5cbiAgICAgKi9cbiAgICBhc3luYyByZWxvYWQoKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNvaW5iYXNlXzEuQ29pbmJhc2UuYXBpQ2xpZW50cy5leHRlcm5hbEFkZHJlc3MuZ2V0RmF1Y2V0VHJhbnNhY3Rpb24odGhpcy50cmFuc2FjdGlvbi5nZXROZXR3b3JrSWQoKSwgdGhpcy5nZXRBZGRyZXNzSWQoKSwgdGhpcy5nZXRUcmFuc2FjdGlvbkhhc2goKSk7XG4gICAgICAgIHRoaXMubW9kZWwgPSByZXN1bHQ/LmRhdGE7XG4gICAgICAgIGlmICghdGhpcy5tb2RlbD8udHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhdWNldFRyYW5zYWN0aW9uIG1vZGVsIGNhbm5vdCBiZSBlbXB0eVwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90cmFuc2FjdGlvbiA9IG5ldyB0cmFuc2FjdGlvbl8xLlRyYW5zYWN0aW9uKHRoaXMubW9kZWwudHJhbnNhY3Rpb24pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgRmF1Y2V0VHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBBIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgRmF1Y2V0VHJhbnNhY3Rpb24uXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBgQ29pbmJhc2U6OkZhdWNldFRyYW5zYWN0aW9ue3RyYW5zYWN0aW9uX2hhc2g6ICcke3RoaXMuZ2V0VHJhbnNhY3Rpb25IYXNoKCl9JywgdHJhbnNhY3Rpb25fbGluazogJyR7dGhpcy5nZXRUcmFuc2FjdGlvbkxpbmsoKX0nfWA7XG4gICAgfVxufVxuZXhwb3J0cy5GYXVjZXRUcmFuc2FjdGlvbiA9IEZhdWNldFRyYW5zYWN0aW9uO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/faucet_transaction.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/fiat_amount.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/fiat_amount.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FiatAmount = void 0;\n/**\n * A representation of a FiatAmount that includes the amount and currency.\n */\nclass FiatAmount {\n    /**\n     * Initialize a new FiatAmount. Do not use this directly, use the fromModel method instead.\n     *\n     * @param amount - The amount in the fiat currency\n     * @param currency - The currency code (e.g. 'USD')\n     */\n    constructor(amount, currency) {\n        this.amount = amount;\n        this.currency = currency;\n    }\n    /**\n     * Convert a FiatAmount model to a FiatAmount.\n     *\n     * @param fiatAmountModel - The fiat amount from the API.\n     * @returns The converted FiatAmount object.\n     */\n    static fromModel(fiatAmountModel) {\n        return new FiatAmount(fiatAmountModel.amount, fiatAmountModel.currency);\n    }\n    /**\n     * Get the amount in the fiat currency.\n     *\n     * @returns The amount in the fiat currency.\n     */\n    getAmount() {\n        return this.amount;\n    }\n    /**\n     * Get the currency code.\n     *\n     * @returns The currency code.\n     */\n    getCurrency() {\n        return this.currency;\n    }\n    /**\n     * Get a string representation of the FiatAmount.\n     *\n     * @returns A string representation of the FiatAmount.\n     */\n    toString() {\n        return `FiatAmount(amount: '${this.amount}', currency: '${this.currency}')`;\n    }\n}\nexports.FiatAmount = FiatAmount;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL2ZpYXRfYW1vdW50LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsWUFBWSxnQkFBZ0IsY0FBYztBQUNoRjtBQUNBO0FBQ0Esa0JBQWtCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3Vydml2YWwtZnVuLy4vbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9jb2luYmFzZS1zZGsvZGlzdC9jb2luYmFzZS9maWF0X2Ftb3VudC5qcz8wNTk5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5GaWF0QW1vdW50ID0gdm9pZCAwO1xuLyoqXG4gKiBBIHJlcHJlc2VudGF0aW9uIG9mIGEgRmlhdEFtb3VudCB0aGF0IGluY2x1ZGVzIHRoZSBhbW91bnQgYW5kIGN1cnJlbmN5LlxuICovXG5jbGFzcyBGaWF0QW1vdW50IHtcbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIGEgbmV3IEZpYXRBbW91bnQuIERvIG5vdCB1c2UgdGhpcyBkaXJlY3RseSwgdXNlIHRoZSBmcm9tTW9kZWwgbWV0aG9kIGluc3RlYWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYW1vdW50IC0gVGhlIGFtb3VudCBpbiB0aGUgZmlhdCBjdXJyZW5jeVxuICAgICAqIEBwYXJhbSBjdXJyZW5jeSAtIFRoZSBjdXJyZW5jeSBjb2RlIChlLmcuICdVU0QnKVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGFtb3VudCwgY3VycmVuY3kpIHtcbiAgICAgICAgdGhpcy5hbW91bnQgPSBhbW91bnQ7XG4gICAgICAgIHRoaXMuY3VycmVuY3kgPSBjdXJyZW5jeTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydCBhIEZpYXRBbW91bnQgbW9kZWwgdG8gYSBGaWF0QW1vdW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIGZpYXRBbW91bnRNb2RlbCAtIFRoZSBmaWF0IGFtb3VudCBmcm9tIHRoZSBBUEkuXG4gICAgICogQHJldHVybnMgVGhlIGNvbnZlcnRlZCBGaWF0QW1vdW50IG9iamVjdC5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbU1vZGVsKGZpYXRBbW91bnRNb2RlbCkge1xuICAgICAgICByZXR1cm4gbmV3IEZpYXRBbW91bnQoZmlhdEFtb3VudE1vZGVsLmFtb3VudCwgZmlhdEFtb3VudE1vZGVsLmN1cnJlbmN5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBhbW91bnQgaW4gdGhlIGZpYXQgY3VycmVuY3kuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgYW1vdW50IGluIHRoZSBmaWF0IGN1cnJlbmN5LlxuICAgICAqL1xuICAgIGdldEFtb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYW1vdW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGN1cnJlbmN5IGNvZGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgY3VycmVuY3kgY29kZS5cbiAgICAgKi9cbiAgICBnZXRDdXJyZW5jeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVuY3k7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgRmlhdEFtb3VudC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBGaWF0QW1vdW50LlxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gYEZpYXRBbW91bnQoYW1vdW50OiAnJHt0aGlzLmFtb3VudH0nLCBjdXJyZW5jeTogJyR7dGhpcy5jdXJyZW5jeX0nKWA7XG4gICAgfVxufVxuZXhwb3J0cy5GaWF0QW1vdW50ID0gRmlhdEFtb3VudDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/fiat_amount.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/fund_operation.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/fund_operation.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FundOperation = void 0;\nconst decimal_js_1 = __webpack_require__(/*! decimal.js */ \"(rsc)/./node_modules/decimal.js/decimal.js\");\nconst asset_1 = __webpack_require__(/*! ./asset */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/asset.js\");\nconst coinbase_1 = __webpack_require__(/*! ./coinbase */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/coinbase.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/utils.js\");\nconst errors_1 = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/errors.js\");\nconst types_1 = __webpack_require__(/*! ./types */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/types.js\");\nconst crypto_amount_1 = __webpack_require__(/*! ./crypto_amount */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/crypto_amount.js\");\n/**\n * A representation of a Fund Operation.\n */\nclass FundOperation {\n    /**\n     * Creates a new FundOperation instance.\n     *\n     * @param model - The model representing the fund operation\n     */\n    constructor(model) {\n        this.asset = null;\n        this.model = model;\n    }\n    /**\n     * Converts a FundOperationModel into a FundOperation object.\n     *\n     * @param fundOperationModel - The FundOperation model object.\n     * @returns The FundOperation object.\n     */\n    static fromModel(fundOperationModel) {\n        return new FundOperation(fundOperationModel);\n    }\n    /**\n     * Create a new Fund Operation.\n     *\n     * @param walletId - The Wallet ID\n     * @param addressId - The Address ID\n     * @param amount - The amount of the Asset\n     * @param assetId - The Asset ID\n     * @param networkId - The Network ID\n     * @param quote - Optional Fund Quote\n     * @returns The new FundOperation object\n     */\n    static async create(walletId, addressId, amount, assetId, networkId, quote) {\n        const asset = await asset_1.Asset.fetch(networkId, assetId);\n        const createRequest = {\n            amount: asset.toAtomicAmount(amount).toString(),\n            asset_id: asset_1.Asset.primaryDenomination(assetId),\n        };\n        if (quote) {\n            Object.assign(createRequest, { fund_quote_id: quote.getId() });\n        }\n        const response = await coinbase_1.Coinbase.apiClients.fund.createFundOperation(walletId, addressId, createRequest);\n        return FundOperation.fromModel(response.data);\n    }\n    /**\n     * List fund operations.\n     *\n     * @param walletId - The wallet ID\n     * @param addressId - The address ID\n     * @param options - The pagination options\n     * @param options.limit - The maximum number of Fund Operations to return. Limit can range between 1 and 100.\n     * @param options.page - The cursor for pagination across multiple pages of Fund Operations. Don't include this parameter on the first call. Use the next page value returned in a previous response to request subsequent results.\n     * @returns The paginated list response of fund operations\n     */\n    static async listFundOperations(walletId, addressId, { limit = coinbase_1.Coinbase.defaultPageLimit, page = undefined } = {}) {\n        const data = [];\n        let nextPage;\n        const response = await coinbase_1.Coinbase.apiClients.fund.listFundOperations(walletId, addressId, limit, page);\n        response.data.data.forEach(operationModel => {\n            data.push(FundOperation.fromModel(operationModel));\n        });\n        const hasMore = response.data.has_more;\n        if (hasMore) {\n            if (response.data.next_page) {\n                nextPage = response.data.next_page;\n            }\n        }\n        return {\n            data,\n            hasMore,\n            nextPage,\n        };\n    }\n    /**\n     * Gets the Fund Operation ID.\n     *\n     * @returns {string} The unique identifier of the fund operation\n     */\n    getId() {\n        return this.model.fund_operation_id;\n    }\n    /**\n     * Gets the Network ID.\n     *\n     * @returns {string} The network identifier\n     */\n    getNetworkId() {\n        return this.model.network_id;\n    }\n    /**\n     * Gets the Wallet ID.\n     *\n     * @returns {string} The wallet identifier\n     */\n    getWalletId() {\n        return this.model.wallet_id;\n    }\n    /**\n     * Gets the Address ID.\n     *\n     * @returns {string} The address identifier\n     */\n    getAddressId() {\n        return this.model.address_id;\n    }\n    /**\n     * Gets the Asset.\n     *\n     * @returns {Asset} The asset associated with this operation\n     */\n    getAsset() {\n        if (!this.asset) {\n            this.asset = asset_1.Asset.fromModel(this.model.crypto_amount.asset);\n        }\n        return this.asset;\n    }\n    /**\n     * Gets the amount.\n     *\n     * @returns {CryptoAmount} The crypto amount\n     */\n    getAmount() {\n        return crypto_amount_1.CryptoAmount.fromModel(this.model.crypto_amount);\n    }\n    /**\n     * Gets the fiat amount.\n     *\n     * @returns {Decimal} The fiat amount in decimal format\n     */\n    getFiatAmount() {\n        return new decimal_js_1.Decimal(this.model.fiat_amount.amount);\n    }\n    /**\n     * Gets the fiat currency.\n     *\n     * @returns {string} The fiat currency code\n     */\n    getFiatCurrency() {\n        return this.model.fiat_amount.currency;\n    }\n    /**\n     * Returns the Status of the Transfer.\n     *\n     * @returns The Status of the Transfer.\n     */\n    getStatus() {\n        switch (this.model.status) {\n            case types_1.FundOperationStatus.PENDING:\n                return types_1.FundOperationStatus.PENDING;\n            case types_1.FundOperationStatus.COMPLETE:\n                return types_1.FundOperationStatus.COMPLETE;\n            case types_1.FundOperationStatus.FAILED:\n                return types_1.FundOperationStatus.FAILED;\n            default:\n                throw new Error(`Unknown fund operation status: ${this.model.status}`);\n        }\n    }\n    /**\n     * Reloads the fund operation from the server.\n     *\n     * @returns {Promise<FundOperation>} A promise that resolves to the updated fund operation\n     */\n    async reload() {\n        const response = await coinbase_1.Coinbase.apiClients.fund.getFundOperation(this.getWalletId(), this.getAddressId(), this.getId());\n        this.model = response.data;\n        return this;\n    }\n    /**\n     * Wait for the fund operation to complete.\n     *\n     * @param options - Options for waiting\n     * @param options.intervalSeconds - The interval between checks in seconds\n     * @param options.timeoutSeconds - The timeout in seconds\n     * @returns The completed fund operation\n     * @throws {TimeoutError} If the operation takes too long\n     */\n    async wait({ intervalSeconds = 0.2, timeoutSeconds = 20 } = {}) {\n        const startTime = Date.now();\n        while (Date.now() - startTime < timeoutSeconds * 1000) {\n            await this.reload();\n            if (this.isTerminalState()) {\n                return this;\n            }\n            await (0, utils_1.delay)(intervalSeconds);\n        }\n        throw new errors_1.TimeoutError(\"Fund operation timed out\");\n    }\n    /**\n     * Check if the operation is in a terminal state.\n     *\n     * @returns {boolean} True if the operation is in a terminal state, false otherwise\n     */\n    isTerminalState() {\n        return FundOperation.Status.TERMINAL_STATES.has(this.getStatus());\n    }\n}\nexports.FundOperation = FundOperation;\n/**\n * Fund Operation status constants.\n */\nFundOperation.Status = {\n    TERMINAL_STATES: new Set([\"complete\", \"failed\"]),\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL2Z1bmRfb3BlcmF0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQjtBQUNyQixxQkFBcUIsbUJBQU8sQ0FBQyw4REFBWTtBQUN6QyxnQkFBZ0IsbUJBQU8sQ0FBQyxtRkFBUztBQUNqQyxtQkFBbUIsbUJBQU8sQ0FBQyx5RkFBWTtBQUN2QyxnQkFBZ0IsbUJBQU8sQ0FBQyxtRkFBUztBQUNqQyxpQkFBaUIsbUJBQU8sQ0FBQyxxRkFBVTtBQUNuQyxnQkFBZ0IsbUJBQU8sQ0FBQyxtRkFBUztBQUNqQyx3QkFBd0IsbUJBQU8sQ0FBQyxtR0FBaUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsOEJBQThCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsaUVBQWlFLElBQUk7QUFDaEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGNBQWM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxrQkFBa0I7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix3QkFBd0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QjtBQUNBLGlCQUFpQiw2Q0FBNkMsSUFBSTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3Vydml2YWwtZnVuLy4vbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9jb2luYmFzZS1zZGsvZGlzdC9jb2luYmFzZS9mdW5kX29wZXJhdGlvbi5qcz9jMzViIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5GdW5kT3BlcmF0aW9uID0gdm9pZCAwO1xuY29uc3QgZGVjaW1hbF9qc18xID0gcmVxdWlyZShcImRlY2ltYWwuanNcIik7XG5jb25zdCBhc3NldF8xID0gcmVxdWlyZShcIi4vYXNzZXRcIik7XG5jb25zdCBjb2luYmFzZV8xID0gcmVxdWlyZShcIi4vY29pbmJhc2VcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuL2Vycm9yc1wiKTtcbmNvbnN0IHR5cGVzXzEgPSByZXF1aXJlKFwiLi90eXBlc1wiKTtcbmNvbnN0IGNyeXB0b19hbW91bnRfMSA9IHJlcXVpcmUoXCIuL2NyeXB0b19hbW91bnRcIik7XG4vKipcbiAqIEEgcmVwcmVzZW50YXRpb24gb2YgYSBGdW5kIE9wZXJhdGlvbi5cbiAqL1xuY2xhc3MgRnVuZE9wZXJhdGlvbiB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBGdW5kT3BlcmF0aW9uIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG1vZGVsIC0gVGhlIG1vZGVsIHJlcHJlc2VudGluZyB0aGUgZnVuZCBvcGVyYXRpb25cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihtb2RlbCkge1xuICAgICAgICB0aGlzLmFzc2V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5tb2RlbCA9IG1vZGVsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIEZ1bmRPcGVyYXRpb25Nb2RlbCBpbnRvIGEgRnVuZE9wZXJhdGlvbiBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZnVuZE9wZXJhdGlvbk1vZGVsIC0gVGhlIEZ1bmRPcGVyYXRpb24gbW9kZWwgb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIFRoZSBGdW5kT3BlcmF0aW9uIG9iamVjdC5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbU1vZGVsKGZ1bmRPcGVyYXRpb25Nb2RlbCkge1xuICAgICAgICByZXR1cm4gbmV3IEZ1bmRPcGVyYXRpb24oZnVuZE9wZXJhdGlvbk1vZGVsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IEZ1bmQgT3BlcmF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHdhbGxldElkIC0gVGhlIFdhbGxldCBJRFxuICAgICAqIEBwYXJhbSBhZGRyZXNzSWQgLSBUaGUgQWRkcmVzcyBJRFxuICAgICAqIEBwYXJhbSBhbW91bnQgLSBUaGUgYW1vdW50IG9mIHRoZSBBc3NldFxuICAgICAqIEBwYXJhbSBhc3NldElkIC0gVGhlIEFzc2V0IElEXG4gICAgICogQHBhcmFtIG5ldHdvcmtJZCAtIFRoZSBOZXR3b3JrIElEXG4gICAgICogQHBhcmFtIHF1b3RlIC0gT3B0aW9uYWwgRnVuZCBRdW90ZVxuICAgICAqIEByZXR1cm5zIFRoZSBuZXcgRnVuZE9wZXJhdGlvbiBvYmplY3RcbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgY3JlYXRlKHdhbGxldElkLCBhZGRyZXNzSWQsIGFtb3VudCwgYXNzZXRJZCwgbmV0d29ya0lkLCBxdW90ZSkge1xuICAgICAgICBjb25zdCBhc3NldCA9IGF3YWl0IGFzc2V0XzEuQXNzZXQuZmV0Y2gobmV0d29ya0lkLCBhc3NldElkKTtcbiAgICAgICAgY29uc3QgY3JlYXRlUmVxdWVzdCA9IHtcbiAgICAgICAgICAgIGFtb3VudDogYXNzZXQudG9BdG9taWNBbW91bnQoYW1vdW50KS50b1N0cmluZygpLFxuICAgICAgICAgICAgYXNzZXRfaWQ6IGFzc2V0XzEuQXNzZXQucHJpbWFyeURlbm9taW5hdGlvbihhc3NldElkKSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHF1b3RlKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGNyZWF0ZVJlcXVlc3QsIHsgZnVuZF9xdW90ZV9pZDogcXVvdGUuZ2V0SWQoKSB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNvaW5iYXNlXzEuQ29pbmJhc2UuYXBpQ2xpZW50cy5mdW5kLmNyZWF0ZUZ1bmRPcGVyYXRpb24od2FsbGV0SWQsIGFkZHJlc3NJZCwgY3JlYXRlUmVxdWVzdCk7XG4gICAgICAgIHJldHVybiBGdW5kT3BlcmF0aW9uLmZyb21Nb2RlbChyZXNwb25zZS5kYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdCBmdW5kIG9wZXJhdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gd2FsbGV0SWQgLSBUaGUgd2FsbGV0IElEXG4gICAgICogQHBhcmFtIGFkZHJlc3NJZCAtIFRoZSBhZGRyZXNzIElEXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgcGFnaW5hdGlvbiBvcHRpb25zXG4gICAgICogQHBhcmFtIG9wdGlvbnMubGltaXQgLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgRnVuZCBPcGVyYXRpb25zIHRvIHJldHVybi4gTGltaXQgY2FuIHJhbmdlIGJldHdlZW4gMSBhbmQgMTAwLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnBhZ2UgLSBUaGUgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiBGdW5kIE9wZXJhdGlvbnMuIERvbid0IGluY2x1ZGUgdGhpcyBwYXJhbWV0ZXIgb24gdGhlIGZpcnN0IGNhbGwuIFVzZSB0aGUgbmV4dCBwYWdlIHZhbHVlIHJldHVybmVkIGluIGEgcHJldmlvdXMgcmVzcG9uc2UgdG8gcmVxdWVzdCBzdWJzZXF1ZW50IHJlc3VsdHMuXG4gICAgICogQHJldHVybnMgVGhlIHBhZ2luYXRlZCBsaXN0IHJlc3BvbnNlIG9mIGZ1bmQgb3BlcmF0aW9uc1xuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyBsaXN0RnVuZE9wZXJhdGlvbnMod2FsbGV0SWQsIGFkZHJlc3NJZCwgeyBsaW1pdCA9IGNvaW5iYXNlXzEuQ29pbmJhc2UuZGVmYXVsdFBhZ2VMaW1pdCwgcGFnZSA9IHVuZGVmaW5lZCB9ID0ge30pIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IFtdO1xuICAgICAgICBsZXQgbmV4dFBhZ2U7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY29pbmJhc2VfMS5Db2luYmFzZS5hcGlDbGllbnRzLmZ1bmQubGlzdEZ1bmRPcGVyYXRpb25zKHdhbGxldElkLCBhZGRyZXNzSWQsIGxpbWl0LCBwYWdlKTtcbiAgICAgICAgcmVzcG9uc2UuZGF0YS5kYXRhLmZvckVhY2gob3BlcmF0aW9uTW9kZWwgPT4ge1xuICAgICAgICAgICAgZGF0YS5wdXNoKEZ1bmRPcGVyYXRpb24uZnJvbU1vZGVsKG9wZXJhdGlvbk1vZGVsKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBoYXNNb3JlID0gcmVzcG9uc2UuZGF0YS5oYXNfbW9yZTtcbiAgICAgICAgaWYgKGhhc01vcmUpIHtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5kYXRhLm5leHRfcGFnZSkge1xuICAgICAgICAgICAgICAgIG5leHRQYWdlID0gcmVzcG9uc2UuZGF0YS5uZXh0X3BhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBoYXNNb3JlLFxuICAgICAgICAgICAgbmV4dFBhZ2UsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIEZ1bmQgT3BlcmF0aW9uIElELlxuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSBmdW5kIG9wZXJhdGlvblxuICAgICAqL1xuICAgIGdldElkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5mdW5kX29wZXJhdGlvbl9pZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgTmV0d29yayBJRC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBuZXR3b3JrIGlkZW50aWZpZXJcbiAgICAgKi9cbiAgICBnZXROZXR3b3JrSWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLm5ldHdvcmtfaWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIFdhbGxldCBJRC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSB3YWxsZXQgaWRlbnRpZmllclxuICAgICAqL1xuICAgIGdldFdhbGxldElkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC53YWxsZXRfaWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIEFkZHJlc3MgSUQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgYWRkcmVzcyBpZGVudGlmaWVyXG4gICAgICovXG4gICAgZ2V0QWRkcmVzc0lkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5hZGRyZXNzX2lkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBBc3NldC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtBc3NldH0gVGhlIGFzc2V0IGFzc29jaWF0ZWQgd2l0aCB0aGlzIG9wZXJhdGlvblxuICAgICAqL1xuICAgIGdldEFzc2V0KCkge1xuICAgICAgICBpZiAoIXRoaXMuYXNzZXQpIHtcbiAgICAgICAgICAgIHRoaXMuYXNzZXQgPSBhc3NldF8xLkFzc2V0LmZyb21Nb2RlbCh0aGlzLm1vZGVsLmNyeXB0b19hbW91bnQuYXNzZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmFzc2V0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBhbW91bnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Q3J5cHRvQW1vdW50fSBUaGUgY3J5cHRvIGFtb3VudFxuICAgICAqL1xuICAgIGdldEFtb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIGNyeXB0b19hbW91bnRfMS5DcnlwdG9BbW91bnQuZnJvbU1vZGVsKHRoaXMubW9kZWwuY3J5cHRvX2Ftb3VudCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGZpYXQgYW1vdW50LlxuICAgICAqXG4gICAgICogQHJldHVybnMge0RlY2ltYWx9IFRoZSBmaWF0IGFtb3VudCBpbiBkZWNpbWFsIGZvcm1hdFxuICAgICAqL1xuICAgIGdldEZpYXRBbW91bnQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgZGVjaW1hbF9qc18xLkRlY2ltYWwodGhpcy5tb2RlbC5maWF0X2Ftb3VudC5hbW91bnQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBmaWF0IGN1cnJlbmN5LlxuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGZpYXQgY3VycmVuY3kgY29kZVxuICAgICAqL1xuICAgIGdldEZpYXRDdXJyZW5jeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwuZmlhdF9hbW91bnQuY3VycmVuY3k7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIFN0YXR1cyBvZiB0aGUgVHJhbnNmZXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgU3RhdHVzIG9mIHRoZSBUcmFuc2Zlci5cbiAgICAgKi9cbiAgICBnZXRTdGF0dXMoKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5tb2RlbC5zdGF0dXMpIHtcbiAgICAgICAgICAgIGNhc2UgdHlwZXNfMS5GdW5kT3BlcmF0aW9uU3RhdHVzLlBFTkRJTkc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVzXzEuRnVuZE9wZXJhdGlvblN0YXR1cy5QRU5ESU5HO1xuICAgICAgICAgICAgY2FzZSB0eXBlc18xLkZ1bmRPcGVyYXRpb25TdGF0dXMuQ09NUExFVEU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVzXzEuRnVuZE9wZXJhdGlvblN0YXR1cy5DT01QTEVURTtcbiAgICAgICAgICAgIGNhc2UgdHlwZXNfMS5GdW5kT3BlcmF0aW9uU3RhdHVzLkZBSUxFRDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZXNfMS5GdW5kT3BlcmF0aW9uU3RhdHVzLkZBSUxFRDtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGZ1bmQgb3BlcmF0aW9uIHN0YXR1czogJHt0aGlzLm1vZGVsLnN0YXR1c31gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWxvYWRzIHRoZSBmdW5kIG9wZXJhdGlvbiBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxGdW5kT3BlcmF0aW9uPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHVwZGF0ZWQgZnVuZCBvcGVyYXRpb25cbiAgICAgKi9cbiAgICBhc3luYyByZWxvYWQoKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY29pbmJhc2VfMS5Db2luYmFzZS5hcGlDbGllbnRzLmZ1bmQuZ2V0RnVuZE9wZXJhdGlvbih0aGlzLmdldFdhbGxldElkKCksIHRoaXMuZ2V0QWRkcmVzc0lkKCksIHRoaXMuZ2V0SWQoKSk7XG4gICAgICAgIHRoaXMubW9kZWwgPSByZXNwb25zZS5kYXRhO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2FpdCBmb3IgdGhlIGZ1bmQgb3BlcmF0aW9uIHRvIGNvbXBsZXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGZvciB3YWl0aW5nXG4gICAgICogQHBhcmFtIG9wdGlvbnMuaW50ZXJ2YWxTZWNvbmRzIC0gVGhlIGludGVydmFsIGJldHdlZW4gY2hlY2tzIGluIHNlY29uZHNcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy50aW1lb3V0U2Vjb25kcyAtIFRoZSB0aW1lb3V0IGluIHNlY29uZHNcbiAgICAgKiBAcmV0dXJucyBUaGUgY29tcGxldGVkIGZ1bmQgb3BlcmF0aW9uXG4gICAgICogQHRocm93cyB7VGltZW91dEVycm9yfSBJZiB0aGUgb3BlcmF0aW9uIHRha2VzIHRvbyBsb25nXG4gICAgICovXG4gICAgYXN5bmMgd2FpdCh7IGludGVydmFsU2Vjb25kcyA9IDAuMiwgdGltZW91dFNlY29uZHMgPSAyMCB9ID0ge30pIHtcbiAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgd2hpbGUgKERhdGUubm93KCkgLSBzdGFydFRpbWUgPCB0aW1lb3V0U2Vjb25kcyAqIDEwMDApIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucmVsb2FkKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1Rlcm1pbmFsU3RhdGUoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgKDAsIHV0aWxzXzEuZGVsYXkpKGludGVydmFsU2Vjb25kcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlRpbWVvdXRFcnJvcihcIkZ1bmQgb3BlcmF0aW9uIHRpbWVkIG91dFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlIG9wZXJhdGlvbiBpcyBpbiBhIHRlcm1pbmFsIHN0YXRlLlxuICAgICAqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIG9wZXJhdGlvbiBpcyBpbiBhIHRlcm1pbmFsIHN0YXRlLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBpc1Rlcm1pbmFsU3RhdGUoKSB7XG4gICAgICAgIHJldHVybiBGdW5kT3BlcmF0aW9uLlN0YXR1cy5URVJNSU5BTF9TVEFURVMuaGFzKHRoaXMuZ2V0U3RhdHVzKCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuRnVuZE9wZXJhdGlvbiA9IEZ1bmRPcGVyYXRpb247XG4vKipcbiAqIEZ1bmQgT3BlcmF0aW9uIHN0YXR1cyBjb25zdGFudHMuXG4gKi9cbkZ1bmRPcGVyYXRpb24uU3RhdHVzID0ge1xuICAgIFRFUk1JTkFMX1NUQVRFUzogbmV3IFNldChbXCJjb21wbGV0ZVwiLCBcImZhaWxlZFwiXSksXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/fund_operation.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/fund_quote.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/fund_quote.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FundQuote = void 0;\nconst decimal_js_1 = __webpack_require__(/*! decimal.js */ \"(rsc)/./node_modules/decimal.js/decimal.js\");\nconst asset_1 = __webpack_require__(/*! ./asset */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/asset.js\");\nconst crypto_amount_1 = __webpack_require__(/*! ./crypto_amount */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/crypto_amount.js\");\nconst coinbase_1 = __webpack_require__(/*! ./coinbase */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/coinbase.js\");\nconst fund_operation_1 = __webpack_require__(/*! ./fund_operation */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/fund_operation.js\");\n/**\n * A representation of a Fund Operation Quote.\n */\nclass FundQuote {\n    /**\n     * Creates a new FundQuote instance.\n     *\n     * @param model - The model representing the fund quote\n     */\n    constructor(model) {\n        this.asset = null;\n        this.model = model;\n    }\n    /**\n     * Converts a FundQuoteModel into a FundQuote object.\n     *\n     * @param fundQuoteModel - The FundQuote model object.\n     * @returns The FundQuote object.\n     */\n    static fromModel(fundQuoteModel) {\n        return new FundQuote(fundQuoteModel);\n    }\n    /**\n     * Create a new Fund Operation Quote.\n     *\n     * @param walletId - The Wallet ID\n     * @param addressId - The Address ID\n     * @param amount - The amount of the Asset\n     * @param assetId - The Asset ID\n     * @param networkId - The Network ID\n     * @returns The new FundQuote object\n     */\n    static async create(walletId, addressId, amount, assetId, networkId) {\n        const asset = await asset_1.Asset.fetch(networkId, assetId);\n        const response = await coinbase_1.Coinbase.apiClients.fund.createFundQuote(walletId, addressId, {\n            asset_id: asset_1.Asset.primaryDenomination(assetId),\n            amount: asset.toAtomicAmount(amount).toString(),\n        });\n        return FundQuote.fromModel(response.data);\n    }\n    /**\n     * Gets the Fund Quote ID.\n     *\n     * @returns {string} The unique identifier of the fund quote\n     */\n    getId() {\n        return this.model.fund_quote_id;\n    }\n    /**\n     * Gets the Network ID.\n     *\n     * @returns {string} The network identifier\n     */\n    getNetworkId() {\n        return this.model.network_id;\n    }\n    /**\n     * Gets the Wallet ID.\n     *\n     * @returns {string} The wallet identifier\n     */\n    getWalletId() {\n        return this.model.wallet_id;\n    }\n    /**\n     * Gets the Address ID.\n     *\n     * @returns {string} The address identifier\n     */\n    getAddressId() {\n        return this.model.address_id;\n    }\n    /**\n     * Gets the Asset.\n     *\n     * @returns {Asset} The asset associated with this quote\n     */\n    getAsset() {\n        if (!this.asset) {\n            this.asset = asset_1.Asset.fromModel(this.model.crypto_amount.asset);\n        }\n        return this.asset;\n    }\n    /**\n     * Gets the crypto amount.\n     *\n     * @returns {CryptoAmount} The cryptocurrency amount\n     */\n    getAmount() {\n        return crypto_amount_1.CryptoAmount.fromModel(this.model.crypto_amount);\n    }\n    /**\n     * Gets the fiat amount.\n     *\n     * @returns {Decimal} The fiat amount in decimal format\n     */\n    getFiatAmount() {\n        return new decimal_js_1.Decimal(this.model.fiat_amount.amount);\n    }\n    /**\n     * Gets the fiat currency.\n     *\n     * @returns {string} The fiat currency code\n     */\n    getFiatCurrency() {\n        return this.model.fiat_amount.currency;\n    }\n    /**\n     * Gets the buy fee.\n     *\n     * @returns {{ amount: string; currency: string }} The buy fee amount and currency\n     */\n    getBuyFee() {\n        return {\n            amount: this.model.fees.buy_fee.amount,\n            currency: this.model.fees.buy_fee.currency,\n        };\n    }\n    /**\n     * Gets the transfer fee.\n     *\n     * @returns {CryptoAmount} The transfer fee as a crypto amount\n     */\n    getTransferFee() {\n        return crypto_amount_1.CryptoAmount.fromModel(this.model.fees.transfer_fee);\n    }\n    /**\n     * Execute the fund quote to create a fund operation.\n     *\n     * @returns {Promise<FundOperation>} A promise that resolves to the created fund operation\n     */\n    async execute() {\n        return fund_operation_1.FundOperation.create(this.getWalletId(), this.getAddressId(), this.getAmount().getAmount(), this.getAsset().getAssetId(), this.getNetworkId(), this);\n    }\n}\nexports.FundQuote = FundQuote;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL2Z1bmRfcXVvdGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCO0FBQ2pCLHFCQUFxQixtQkFBTyxDQUFDLDhEQUFZO0FBQ3pDLGdCQUFnQixtQkFBTyxDQUFDLG1GQUFTO0FBQ2pDLHdCQUF3QixtQkFBTyxDQUFDLG1HQUFpQjtBQUNqRCxtQkFBbUIsbUJBQU8sQ0FBQyx5RkFBWTtBQUN2Qyx5QkFBeUIsbUJBQU8sQ0FBQyxxR0FBa0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsY0FBYztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZ0JBQWdCLG9CQUFvQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixjQUFjO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHdCQUF3QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3Vydml2YWwtZnVuLy4vbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9jb2luYmFzZS1zZGsvZGlzdC9jb2luYmFzZS9mdW5kX3F1b3RlLmpzPzgyOTAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkZ1bmRRdW90ZSA9IHZvaWQgMDtcbmNvbnN0IGRlY2ltYWxfanNfMSA9IHJlcXVpcmUoXCJkZWNpbWFsLmpzXCIpO1xuY29uc3QgYXNzZXRfMSA9IHJlcXVpcmUoXCIuL2Fzc2V0XCIpO1xuY29uc3QgY3J5cHRvX2Ftb3VudF8xID0gcmVxdWlyZShcIi4vY3J5cHRvX2Ftb3VudFwiKTtcbmNvbnN0IGNvaW5iYXNlXzEgPSByZXF1aXJlKFwiLi9jb2luYmFzZVwiKTtcbmNvbnN0IGZ1bmRfb3BlcmF0aW9uXzEgPSByZXF1aXJlKFwiLi9mdW5kX29wZXJhdGlvblwiKTtcbi8qKlxuICogQSByZXByZXNlbnRhdGlvbiBvZiBhIEZ1bmQgT3BlcmF0aW9uIFF1b3RlLlxuICovXG5jbGFzcyBGdW5kUXVvdGUge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgRnVuZFF1b3RlIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG1vZGVsIC0gVGhlIG1vZGVsIHJlcHJlc2VudGluZyB0aGUgZnVuZCBxdW90ZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG1vZGVsKSB7XG4gICAgICAgIHRoaXMuYXNzZXQgPSBudWxsO1xuICAgICAgICB0aGlzLm1vZGVsID0gbW9kZWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgRnVuZFF1b3RlTW9kZWwgaW50byBhIEZ1bmRRdW90ZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZnVuZFF1b3RlTW9kZWwgLSBUaGUgRnVuZFF1b3RlIG1vZGVsIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyBUaGUgRnVuZFF1b3RlIG9iamVjdC5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbU1vZGVsKGZ1bmRRdW90ZU1vZGVsKSB7XG4gICAgICAgIHJldHVybiBuZXcgRnVuZFF1b3RlKGZ1bmRRdW90ZU1vZGVsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IEZ1bmQgT3BlcmF0aW9uIFF1b3RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHdhbGxldElkIC0gVGhlIFdhbGxldCBJRFxuICAgICAqIEBwYXJhbSBhZGRyZXNzSWQgLSBUaGUgQWRkcmVzcyBJRFxuICAgICAqIEBwYXJhbSBhbW91bnQgLSBUaGUgYW1vdW50IG9mIHRoZSBBc3NldFxuICAgICAqIEBwYXJhbSBhc3NldElkIC0gVGhlIEFzc2V0IElEXG4gICAgICogQHBhcmFtIG5ldHdvcmtJZCAtIFRoZSBOZXR3b3JrIElEXG4gICAgICogQHJldHVybnMgVGhlIG5ldyBGdW5kUXVvdGUgb2JqZWN0XG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIGNyZWF0ZSh3YWxsZXRJZCwgYWRkcmVzc0lkLCBhbW91bnQsIGFzc2V0SWQsIG5ldHdvcmtJZCkge1xuICAgICAgICBjb25zdCBhc3NldCA9IGF3YWl0IGFzc2V0XzEuQXNzZXQuZmV0Y2gobmV0d29ya0lkLCBhc3NldElkKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjb2luYmFzZV8xLkNvaW5iYXNlLmFwaUNsaWVudHMuZnVuZC5jcmVhdGVGdW5kUXVvdGUod2FsbGV0SWQsIGFkZHJlc3NJZCwge1xuICAgICAgICAgICAgYXNzZXRfaWQ6IGFzc2V0XzEuQXNzZXQucHJpbWFyeURlbm9taW5hdGlvbihhc3NldElkKSxcbiAgICAgICAgICAgIGFtb3VudDogYXNzZXQudG9BdG9taWNBbW91bnQoYW1vdW50KS50b1N0cmluZygpLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIEZ1bmRRdW90ZS5mcm9tTW9kZWwocmVzcG9uc2UuZGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIEZ1bmQgUXVvdGUgSUQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIGZ1bmQgcXVvdGVcbiAgICAgKi9cbiAgICBnZXRJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwuZnVuZF9xdW90ZV9pZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgTmV0d29yayBJRC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBuZXR3b3JrIGlkZW50aWZpZXJcbiAgICAgKi9cbiAgICBnZXROZXR3b3JrSWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLm5ldHdvcmtfaWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIFdhbGxldCBJRC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSB3YWxsZXQgaWRlbnRpZmllclxuICAgICAqL1xuICAgIGdldFdhbGxldElkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC53YWxsZXRfaWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIEFkZHJlc3MgSUQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgYWRkcmVzcyBpZGVudGlmaWVyXG4gICAgICovXG4gICAgZ2V0QWRkcmVzc0lkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5hZGRyZXNzX2lkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBBc3NldC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtBc3NldH0gVGhlIGFzc2V0IGFzc29jaWF0ZWQgd2l0aCB0aGlzIHF1b3RlXG4gICAgICovXG4gICAgZ2V0QXNzZXQoKSB7XG4gICAgICAgIGlmICghdGhpcy5hc3NldCkge1xuICAgICAgICAgICAgdGhpcy5hc3NldCA9IGFzc2V0XzEuQXNzZXQuZnJvbU1vZGVsKHRoaXMubW9kZWwuY3J5cHRvX2Ftb3VudC5hc3NldCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYXNzZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGNyeXB0byBhbW91bnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Q3J5cHRvQW1vdW50fSBUaGUgY3J5cHRvY3VycmVuY3kgYW1vdW50XG4gICAgICovXG4gICAgZ2V0QW1vdW50KCkge1xuICAgICAgICByZXR1cm4gY3J5cHRvX2Ftb3VudF8xLkNyeXB0b0Ftb3VudC5mcm9tTW9kZWwodGhpcy5tb2RlbC5jcnlwdG9fYW1vdW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZmlhdCBhbW91bnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7RGVjaW1hbH0gVGhlIGZpYXQgYW1vdW50IGluIGRlY2ltYWwgZm9ybWF0XG4gICAgICovXG4gICAgZ2V0RmlhdEFtb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBkZWNpbWFsX2pzXzEuRGVjaW1hbCh0aGlzLm1vZGVsLmZpYXRfYW1vdW50LmFtb3VudCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGZpYXQgY3VycmVuY3kuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZmlhdCBjdXJyZW5jeSBjb2RlXG4gICAgICovXG4gICAgZ2V0RmlhdEN1cnJlbmN5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5maWF0X2Ftb3VudC5jdXJyZW5jeTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgYnV5IGZlZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHt7IGFtb3VudDogc3RyaW5nOyBjdXJyZW5jeTogc3RyaW5nIH19IFRoZSBidXkgZmVlIGFtb3VudCBhbmQgY3VycmVuY3lcbiAgICAgKi9cbiAgICBnZXRCdXlGZWUoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhbW91bnQ6IHRoaXMubW9kZWwuZmVlcy5idXlfZmVlLmFtb3VudCxcbiAgICAgICAgICAgIGN1cnJlbmN5OiB0aGlzLm1vZGVsLmZlZXMuYnV5X2ZlZS5jdXJyZW5jeSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgdHJhbnNmZXIgZmVlLlxuICAgICAqXG4gICAgICogQHJldHVybnMge0NyeXB0b0Ftb3VudH0gVGhlIHRyYW5zZmVyIGZlZSBhcyBhIGNyeXB0byBhbW91bnRcbiAgICAgKi9cbiAgICBnZXRUcmFuc2ZlckZlZSgpIHtcbiAgICAgICAgcmV0dXJuIGNyeXB0b19hbW91bnRfMS5DcnlwdG9BbW91bnQuZnJvbU1vZGVsKHRoaXMubW9kZWwuZmVlcy50cmFuc2Zlcl9mZWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlIHRoZSBmdW5kIHF1b3RlIHRvIGNyZWF0ZSBhIGZ1bmQgb3BlcmF0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8RnVuZE9wZXJhdGlvbj59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBjcmVhdGVkIGZ1bmQgb3BlcmF0aW9uXG4gICAgICovXG4gICAgYXN5bmMgZXhlY3V0ZSgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmRfb3BlcmF0aW9uXzEuRnVuZE9wZXJhdGlvbi5jcmVhdGUodGhpcy5nZXRXYWxsZXRJZCgpLCB0aGlzLmdldEFkZHJlc3NJZCgpLCB0aGlzLmdldEFtb3VudCgpLmdldEFtb3VudCgpLCB0aGlzLmdldEFzc2V0KCkuZ2V0QXNzZXRJZCgpLCB0aGlzLmdldE5ldHdvcmtJZCgpLCB0aGlzKTtcbiAgICB9XG59XG5leHBvcnRzLkZ1bmRRdW90ZSA9IEZ1bmRRdW90ZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/fund_quote.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/hash.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/hash.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.hashTypedDataMessage = exports.hashMessage = void 0;\nconst ethers_1 = __webpack_require__(/*! ethers */ \"(rsc)/./node_modules/ethers/lib.commonjs/index.js\");\n/**\n * Computes the EIP-191 personal-sign message digest to sign.\n *\n * @returns The EIP-191 hash of the message as a string.\n * @throws {Error} if the message cannot be hashed.\n * @param message - The message to hash.\n */\nconst hashMessage = (message) => {\n    return ethers_1.ethers.hashMessage(message);\n};\nexports.hashMessage = hashMessage;\n/**\n * Computes the hash of the EIP-712 compliant typed data message.\n *\n * @param domain - The domain parameters for the EIP-712 message, including the name, version, chainId, and verifying contract.\n * @param types - The types definitions for the EIP-712 message, represented as a record of type names to their fields.\n * @param value - The actual data object to hash, conforming to the types defined.\n *\n * @returns The EIP-712 hash of the typed data as a hex-encoded string.\n * @throws {Error} if the typed data cannot be hashed.\n */\nconst hashTypedDataMessage = (domain, types, \n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nvalue) => {\n    return ethers_1.ethers.TypedDataEncoder.hash(domain, types, value);\n};\nexports.hashTypedDataMessage = hashTypedDataMessage;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL2hhc2guanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNEJBQTRCLEdBQUcsbUJBQW1CO0FBQ2xELGlCQUFpQixtQkFBTyxDQUFDLGlFQUFRO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXJ2aXZhbC1mdW4vLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL2hhc2guanM/OGIyZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaGFzaFR5cGVkRGF0YU1lc3NhZ2UgPSBleHBvcnRzLmhhc2hNZXNzYWdlID0gdm9pZCAwO1xuY29uc3QgZXRoZXJzXzEgPSByZXF1aXJlKFwiZXRoZXJzXCIpO1xuLyoqXG4gKiBDb21wdXRlcyB0aGUgRUlQLTE5MSBwZXJzb25hbC1zaWduIG1lc3NhZ2UgZGlnZXN0IHRvIHNpZ24uXG4gKlxuICogQHJldHVybnMgVGhlIEVJUC0xOTEgaGFzaCBvZiB0aGUgbWVzc2FnZSBhcyBhIHN0cmluZy5cbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiB0aGUgbWVzc2FnZSBjYW5ub3QgYmUgaGFzaGVkLlxuICogQHBhcmFtIG1lc3NhZ2UgLSBUaGUgbWVzc2FnZSB0byBoYXNoLlxuICovXG5jb25zdCBoYXNoTWVzc2FnZSA9IChtZXNzYWdlKSA9PiB7XG4gICAgcmV0dXJuIGV0aGVyc18xLmV0aGVycy5oYXNoTWVzc2FnZShtZXNzYWdlKTtcbn07XG5leHBvcnRzLmhhc2hNZXNzYWdlID0gaGFzaE1lc3NhZ2U7XG4vKipcbiAqIENvbXB1dGVzIHRoZSBoYXNoIG9mIHRoZSBFSVAtNzEyIGNvbXBsaWFudCB0eXBlZCBkYXRhIG1lc3NhZ2UuXG4gKlxuICogQHBhcmFtIGRvbWFpbiAtIFRoZSBkb21haW4gcGFyYW1ldGVycyBmb3IgdGhlIEVJUC03MTIgbWVzc2FnZSwgaW5jbHVkaW5nIHRoZSBuYW1lLCB2ZXJzaW9uLCBjaGFpbklkLCBhbmQgdmVyaWZ5aW5nIGNvbnRyYWN0LlxuICogQHBhcmFtIHR5cGVzIC0gVGhlIHR5cGVzIGRlZmluaXRpb25zIGZvciB0aGUgRUlQLTcxMiBtZXNzYWdlLCByZXByZXNlbnRlZCBhcyBhIHJlY29yZCBvZiB0eXBlIG5hbWVzIHRvIHRoZWlyIGZpZWxkcy5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBhY3R1YWwgZGF0YSBvYmplY3QgdG8gaGFzaCwgY29uZm9ybWluZyB0byB0aGUgdHlwZXMgZGVmaW5lZC5cbiAqXG4gKiBAcmV0dXJucyBUaGUgRUlQLTcxMiBoYXNoIG9mIHRoZSB0eXBlZCBkYXRhIGFzIGEgaGV4LWVuY29kZWQgc3RyaW5nLlxuICogQHRocm93cyB7RXJyb3J9IGlmIHRoZSB0eXBlZCBkYXRhIGNhbm5vdCBiZSBoYXNoZWQuXG4gKi9cbmNvbnN0IGhhc2hUeXBlZERhdGFNZXNzYWdlID0gKGRvbWFpbiwgdHlwZXMsIFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbnZhbHVlKSA9PiB7XG4gICAgcmV0dXJuIGV0aGVyc18xLmV0aGVycy5UeXBlZERhdGFFbmNvZGVyLmhhc2goZG9tYWluLCB0eXBlcywgdmFsdWUpO1xufTtcbmV4cG9ydHMuaGFzaFR5cGVkRGF0YU1lc3NhZ2UgPSBoYXNoVHlwZWREYXRhTWVzc2FnZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/hash.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/historical_balance.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/historical_balance.js ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.HistoricalBalance = void 0;\nconst decimal_js_1 = __importDefault(__webpack_require__(/*! decimal.js */ \"(rsc)/./node_modules/decimal.js/decimal.js\"));\nconst asset_1 = __webpack_require__(/*! ./asset */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/asset.js\");\n/** A representation of historical balance. */\nclass HistoricalBalance {\n    /**\n     * Private constructor to prevent direct instantiation outside of the factory methods.\n     *\n     * @ignore\n     * @param {Decimal} amount - The amount of the balance.\n     * @param {Decimal} blockHeight - The block height at which the balance was recorded.\n     * @param {string} blockHash - The block hash at which the balance was recorded\n     * @param {string} asset - The asset we want to fetch.\n     * @hideconstructor\n     */\n    constructor(amount, blockHeight, blockHash, asset) {\n        this.amount = amount;\n        this.blockHeight = blockHeight;\n        this.blockHash = blockHash;\n        this.asset = asset;\n    }\n    /**\n     * Converts a HistoricalBalanceModel into a HistoricalBalance object.\n     *\n     * @param {HistoricalBalanceModel} model - The historical balance model object.\n     * @returns {HistoricalBalance} The HistoricalBalance object.\n     */\n    static fromModel(model) {\n        const asset = asset_1.Asset.fromModel(model.asset);\n        return new HistoricalBalance(asset.fromAtomicAmount(new decimal_js_1.default(model.amount)), new decimal_js_1.default(model.block_height), model.block_hash, asset);\n    }\n}\nexports.HistoricalBalance = HistoricalBalance;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL2hpc3RvcmljYWxfYmFsYW5jZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHlCQUF5QjtBQUN6QixxQ0FBcUMsbUJBQU8sQ0FBQyw4REFBWTtBQUN6RCxnQkFBZ0IsbUJBQU8sQ0FBQyxtRkFBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsd0JBQXdCO0FBQ3ZDLGlCQUFpQixtQkFBbUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3Vydml2YWwtZnVuLy4vbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9jb2luYmFzZS1zZGsvZGlzdC9jb2luYmFzZS9oaXN0b3JpY2FsX2JhbGFuY2UuanM/OWM1MiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSGlzdG9yaWNhbEJhbGFuY2UgPSB2b2lkIDA7XG5jb25zdCBkZWNpbWFsX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImRlY2ltYWwuanNcIikpO1xuY29uc3QgYXNzZXRfMSA9IHJlcXVpcmUoXCIuL2Fzc2V0XCIpO1xuLyoqIEEgcmVwcmVzZW50YXRpb24gb2YgaGlzdG9yaWNhbCBiYWxhbmNlLiAqL1xuY2xhc3MgSGlzdG9yaWNhbEJhbGFuY2Uge1xuICAgIC8qKlxuICAgICAqIFByaXZhdGUgY29uc3RydWN0b3IgdG8gcHJldmVudCBkaXJlY3QgaW5zdGFudGlhdGlvbiBvdXRzaWRlIG9mIHRoZSBmYWN0b3J5IG1ldGhvZHMuXG4gICAgICpcbiAgICAgKiBAaWdub3JlXG4gICAgICogQHBhcmFtIHtEZWNpbWFsfSBhbW91bnQgLSBUaGUgYW1vdW50IG9mIHRoZSBiYWxhbmNlLlxuICAgICAqIEBwYXJhbSB7RGVjaW1hbH0gYmxvY2tIZWlnaHQgLSBUaGUgYmxvY2sgaGVpZ2h0IGF0IHdoaWNoIHRoZSBiYWxhbmNlIHdhcyByZWNvcmRlZC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYmxvY2tIYXNoIC0gVGhlIGJsb2NrIGhhc2ggYXQgd2hpY2ggdGhlIGJhbGFuY2Ugd2FzIHJlY29yZGVkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFzc2V0IC0gVGhlIGFzc2V0IHdlIHdhbnQgdG8gZmV0Y2guXG4gICAgICogQGhpZGVjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGFtb3VudCwgYmxvY2tIZWlnaHQsIGJsb2NrSGFzaCwgYXNzZXQpIHtcbiAgICAgICAgdGhpcy5hbW91bnQgPSBhbW91bnQ7XG4gICAgICAgIHRoaXMuYmxvY2tIZWlnaHQgPSBibG9ja0hlaWdodDtcbiAgICAgICAgdGhpcy5ibG9ja0hhc2ggPSBibG9ja0hhc2g7XG4gICAgICAgIHRoaXMuYXNzZXQgPSBhc3NldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBIaXN0b3JpY2FsQmFsYW5jZU1vZGVsIGludG8gYSBIaXN0b3JpY2FsQmFsYW5jZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0hpc3RvcmljYWxCYWxhbmNlTW9kZWx9IG1vZGVsIC0gVGhlIGhpc3RvcmljYWwgYmFsYW5jZSBtb2RlbCBvYmplY3QuXG4gICAgICogQHJldHVybnMge0hpc3RvcmljYWxCYWxhbmNlfSBUaGUgSGlzdG9yaWNhbEJhbGFuY2Ugb2JqZWN0LlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tTW9kZWwobW9kZWwpIHtcbiAgICAgICAgY29uc3QgYXNzZXQgPSBhc3NldF8xLkFzc2V0LmZyb21Nb2RlbChtb2RlbC5hc3NldCk7XG4gICAgICAgIHJldHVybiBuZXcgSGlzdG9yaWNhbEJhbGFuY2UoYXNzZXQuZnJvbUF0b21pY0Ftb3VudChuZXcgZGVjaW1hbF9qc18xLmRlZmF1bHQobW9kZWwuYW1vdW50KSksIG5ldyBkZWNpbWFsX2pzXzEuZGVmYXVsdChtb2RlbC5ibG9ja19oZWlnaHQpLCBtb2RlbC5ibG9ja19oYXNoLCBhc3NldCk7XG4gICAgfVxufVxuZXhwb3J0cy5IaXN0b3JpY2FsQmFsYW5jZSA9IEhpc3RvcmljYWxCYWxhbmNlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/historical_balance.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/payload_signature.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/payload_signature.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PayloadSignature = void 0;\nconst types_1 = __webpack_require__(/*! ./types */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/types.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/utils.js\");\nconst errors_1 = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/errors.js\");\nconst coinbase_1 = __webpack_require__(/*! ./coinbase */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/coinbase.js\");\n/**\n * A representation of a Payload Signature.\n */\nclass PayloadSignature {\n    /**\n     * Constructs a Payload Signature.\n     *\n     * @class\n     * @param model - The underlying Payload Signature object.\n     */\n    constructor(model) {\n        if (!model) {\n            throw new Error(\"Invalid model type\");\n        }\n        this.model = model;\n    }\n    /**\n     * Returns the ID of the Payload Signature.\n     *\n     * @returns The ID of the Payload Signature\n     */\n    getId() {\n        return this.model.payload_signature_id;\n    }\n    /**\n     * Returns the Wallet ID of the Payload Signature.\n     *\n     * @returns The Wallet ID\n     */\n    getWalletId() {\n        return this.model.wallet_id;\n    }\n    /**\n     * Returns the Address ID of the Payload Signature.\n     *\n     * @returns The Address ID\n     */\n    getAddressId() {\n        return this.model.address_id;\n    }\n    /**\n     * Returns the Unsigned Payload of the Payload Signature.\n     *\n     * @returns The Unsigned Payload\n     */\n    getUnsignedPayload() {\n        return this.model.unsigned_payload;\n    }\n    /**\n     * Returns the Signature of the Payload Signature.\n     *\n     * @returns The Signature\n     */\n    getSignature() {\n        return this.model.signature;\n    }\n    /**\n     * Returns the Status of the Payload Signature.\n     *\n     * @returns The Status\n     */\n    getStatus() {\n        switch (this.model.status) {\n            case types_1.PayloadSignatureStatus.PENDING:\n                return types_1.PayloadSignatureStatus.PENDING;\n            case types_1.PayloadSignatureStatus.SIGNED:\n                return types_1.PayloadSignatureStatus.SIGNED;\n            case types_1.PayloadSignatureStatus.FAILED:\n                return types_1.PayloadSignatureStatus.FAILED;\n            default:\n                return undefined;\n        }\n    }\n    /**\n     * Returns whether the Payload Signature is in a terminal State.\n     *\n     * @returns Whether the Payload Signature is in a terminal State\n     */\n    isTerminalState() {\n        const status = this.getStatus();\n        if (!status)\n            return false;\n        return [types_1.PayloadSignatureStatus.SIGNED, types_1.PayloadSignatureStatus.FAILED].includes(status);\n    }\n    /**\n     * Waits for the Payload Signature to be signed or for the signature operation to fail.\n     *\n     * @param options - The options to configure the wait function.\n     * @param options.intervalSeconds - The interval to check the status of the Payload Signature.\n     * @param options.timeoutSeconds - The maximum time to wait for the Payload Signature to be confirmed.\n     *\n     * @returns The Payload Signature object in a terminal state.\n     * @throws {Error} if the Payload Signature times out.\n     */\n    async wait({ intervalSeconds = 0.2, timeoutSeconds = 10, } = {}) {\n        const startTime = Date.now();\n        while (Date.now() - startTime < timeoutSeconds * 1000) {\n            await this.reload();\n            // If the Payload Signature is in a terminal state, return the Payload Signature.\n            if (this.isTerminalState()) {\n                return this;\n            }\n            await (0, utils_1.delay)(intervalSeconds);\n        }\n        throw new errors_1.TimeoutError(\"Payload Signature timed out\");\n    }\n    /**\n     * Reloads the Payload Signature model with the latest data from the server.\n     *\n     * @throws {APIError} if the API request to get a Payload Signature fails.\n     */\n    async reload() {\n        const result = await coinbase_1.Coinbase.apiClients.address.getPayloadSignature(this.getWalletId(), this.getAddressId(), this.getId());\n        this.model = result?.data;\n    }\n    /**\n     * Returns a string representation of the Payload Signature.\n     *\n     * @returns A string representation of the Payload Signature.\n     */\n    toString() {\n        return `PayloadSignature { status: '${this.getStatus()}', unsignedPayload: '${this.getUnsignedPayload()}', signature: ${this.getSignature()} }`;\n    }\n}\nexports.PayloadSignature = PayloadSignature;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL3BheWxvYWRfc2lnbmF0dXJlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHdCQUF3QjtBQUN4QixnQkFBZ0IsbUJBQU8sQ0FBQyxtRkFBUztBQUNqQyxnQkFBZ0IsbUJBQU8sQ0FBQyxtRkFBUztBQUNqQyxpQkFBaUIsbUJBQU8sQ0FBQyxxRkFBVTtBQUNuQyxtQkFBbUIsbUJBQU8sQ0FBQyx5RkFBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQSxpQkFBaUIsOENBQThDLElBQUk7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsV0FBVyxpQkFBaUIsdUJBQXVCLDBCQUEwQixnQkFBZ0Isc0JBQXNCO0FBQ3RKO0FBQ0E7QUFDQSx3QkFBd0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXJ2aXZhbC1mdW4vLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL3BheWxvYWRfc2lnbmF0dXJlLmpzPzA3NmMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlBheWxvYWRTaWduYXR1cmUgPSB2b2lkIDA7XG5jb25zdCB0eXBlc18xID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuL2Vycm9yc1wiKTtcbmNvbnN0IGNvaW5iYXNlXzEgPSByZXF1aXJlKFwiLi9jb2luYmFzZVwiKTtcbi8qKlxuICogQSByZXByZXNlbnRhdGlvbiBvZiBhIFBheWxvYWQgU2lnbmF0dXJlLlxuICovXG5jbGFzcyBQYXlsb2FkU2lnbmF0dXJlIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIGEgUGF5bG9hZCBTaWduYXR1cmUuXG4gICAgICpcbiAgICAgKiBAY2xhc3NcbiAgICAgKiBAcGFyYW0gbW9kZWwgLSBUaGUgdW5kZXJseWluZyBQYXlsb2FkIFNpZ25hdHVyZSBvYmplY3QuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobW9kZWwpIHtcbiAgICAgICAgaWYgKCFtb2RlbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBtb2RlbCB0eXBlXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW9kZWwgPSBtb2RlbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgSUQgb2YgdGhlIFBheWxvYWQgU2lnbmF0dXJlLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIElEIG9mIHRoZSBQYXlsb2FkIFNpZ25hdHVyZVxuICAgICAqL1xuICAgIGdldElkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5wYXlsb2FkX3NpZ25hdHVyZV9pZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgV2FsbGV0IElEIG9mIHRoZSBQYXlsb2FkIFNpZ25hdHVyZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBXYWxsZXQgSURcbiAgICAgKi9cbiAgICBnZXRXYWxsZXRJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwud2FsbGV0X2lkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBBZGRyZXNzIElEIG9mIHRoZSBQYXlsb2FkIFNpZ25hdHVyZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBBZGRyZXNzIElEXG4gICAgICovXG4gICAgZ2V0QWRkcmVzc0lkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5hZGRyZXNzX2lkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBVbnNpZ25lZCBQYXlsb2FkIG9mIHRoZSBQYXlsb2FkIFNpZ25hdHVyZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBVbnNpZ25lZCBQYXlsb2FkXG4gICAgICovXG4gICAgZ2V0VW5zaWduZWRQYXlsb2FkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC51bnNpZ25lZF9wYXlsb2FkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBTaWduYXR1cmUgb2YgdGhlIFBheWxvYWQgU2lnbmF0dXJlLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIFNpZ25hdHVyZVxuICAgICAqL1xuICAgIGdldFNpZ25hdHVyZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwuc2lnbmF0dXJlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBTdGF0dXMgb2YgdGhlIFBheWxvYWQgU2lnbmF0dXJlLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIFN0YXR1c1xuICAgICAqL1xuICAgIGdldFN0YXR1cygpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLm1vZGVsLnN0YXR1cykge1xuICAgICAgICAgICAgY2FzZSB0eXBlc18xLlBheWxvYWRTaWduYXR1cmVTdGF0dXMuUEVORElORzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZXNfMS5QYXlsb2FkU2lnbmF0dXJlU3RhdHVzLlBFTkRJTkc7XG4gICAgICAgICAgICBjYXNlIHR5cGVzXzEuUGF5bG9hZFNpZ25hdHVyZVN0YXR1cy5TSUdORUQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVzXzEuUGF5bG9hZFNpZ25hdHVyZVN0YXR1cy5TSUdORUQ7XG4gICAgICAgICAgICBjYXNlIHR5cGVzXzEuUGF5bG9hZFNpZ25hdHVyZVN0YXR1cy5GQUlMRUQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVzXzEuUGF5bG9hZFNpZ25hdHVyZVN0YXR1cy5GQUlMRUQ7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBQYXlsb2FkIFNpZ25hdHVyZSBpcyBpbiBhIHRlcm1pbmFsIFN0YXRlLlxuICAgICAqXG4gICAgICogQHJldHVybnMgV2hldGhlciB0aGUgUGF5bG9hZCBTaWduYXR1cmUgaXMgaW4gYSB0ZXJtaW5hbCBTdGF0ZVxuICAgICAqL1xuICAgIGlzVGVybWluYWxTdGF0ZSgpIHtcbiAgICAgICAgY29uc3Qgc3RhdHVzID0gdGhpcy5nZXRTdGF0dXMoKTtcbiAgICAgICAgaWYgKCFzdGF0dXMpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiBbdHlwZXNfMS5QYXlsb2FkU2lnbmF0dXJlU3RhdHVzLlNJR05FRCwgdHlwZXNfMS5QYXlsb2FkU2lnbmF0dXJlU3RhdHVzLkZBSUxFRF0uaW5jbHVkZXMoc3RhdHVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2FpdHMgZm9yIHRoZSBQYXlsb2FkIFNpZ25hdHVyZSB0byBiZSBzaWduZWQgb3IgZm9yIHRoZSBzaWduYXR1cmUgb3BlcmF0aW9uIHRvIGZhaWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIHRvIGNvbmZpZ3VyZSB0aGUgd2FpdCBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5pbnRlcnZhbFNlY29uZHMgLSBUaGUgaW50ZXJ2YWwgdG8gY2hlY2sgdGhlIHN0YXR1cyBvZiB0aGUgUGF5bG9hZCBTaWduYXR1cmUuXG4gICAgICogQHBhcmFtIG9wdGlvbnMudGltZW91dFNlY29uZHMgLSBUaGUgbWF4aW11bSB0aW1lIHRvIHdhaXQgZm9yIHRoZSBQYXlsb2FkIFNpZ25hdHVyZSB0byBiZSBjb25maXJtZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgUGF5bG9hZCBTaWduYXR1cmUgb2JqZWN0IGluIGEgdGVybWluYWwgc3RhdGUuXG4gICAgICogQHRocm93cyB7RXJyb3J9IGlmIHRoZSBQYXlsb2FkIFNpZ25hdHVyZSB0aW1lcyBvdXQuXG4gICAgICovXG4gICAgYXN5bmMgd2FpdCh7IGludGVydmFsU2Vjb25kcyA9IDAuMiwgdGltZW91dFNlY29uZHMgPSAxMCwgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIHdoaWxlIChEYXRlLm5vdygpIC0gc3RhcnRUaW1lIDwgdGltZW91dFNlY29uZHMgKiAxMDAwKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnJlbG9hZCgpO1xuICAgICAgICAgICAgLy8gSWYgdGhlIFBheWxvYWQgU2lnbmF0dXJlIGlzIGluIGEgdGVybWluYWwgc3RhdGUsIHJldHVybiB0aGUgUGF5bG9hZCBTaWduYXR1cmUuXG4gICAgICAgICAgICBpZiAodGhpcy5pc1Rlcm1pbmFsU3RhdGUoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgKDAsIHV0aWxzXzEuZGVsYXkpKGludGVydmFsU2Vjb25kcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlRpbWVvdXRFcnJvcihcIlBheWxvYWQgU2lnbmF0dXJlIHRpbWVkIG91dFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVsb2FkcyB0aGUgUGF5bG9hZCBTaWduYXR1cmUgbW9kZWwgd2l0aCB0aGUgbGF0ZXN0IGRhdGEgZnJvbSB0aGUgc2VydmVyLlxuICAgICAqXG4gICAgICogQHRocm93cyB7QVBJRXJyb3J9IGlmIHRoZSBBUEkgcmVxdWVzdCB0byBnZXQgYSBQYXlsb2FkIFNpZ25hdHVyZSBmYWlscy5cbiAgICAgKi9cbiAgICBhc3luYyByZWxvYWQoKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNvaW5iYXNlXzEuQ29pbmJhc2UuYXBpQ2xpZW50cy5hZGRyZXNzLmdldFBheWxvYWRTaWduYXR1cmUodGhpcy5nZXRXYWxsZXRJZCgpLCB0aGlzLmdldEFkZHJlc3NJZCgpLCB0aGlzLmdldElkKCkpO1xuICAgICAgICB0aGlzLm1vZGVsID0gcmVzdWx0Py5kYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBQYXlsb2FkIFNpZ25hdHVyZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBQYXlsb2FkIFNpZ25hdHVyZS5cbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGBQYXlsb2FkU2lnbmF0dXJlIHsgc3RhdHVzOiAnJHt0aGlzLmdldFN0YXR1cygpfScsIHVuc2lnbmVkUGF5bG9hZDogJyR7dGhpcy5nZXRVbnNpZ25lZFBheWxvYWQoKX0nLCBzaWduYXR1cmU6ICR7dGhpcy5nZXRTaWduYXR1cmUoKX0gfWA7XG4gICAgfVxufVxuZXhwb3J0cy5QYXlsb2FkU2lnbmF0dXJlID0gUGF5bG9hZFNpZ25hdHVyZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/payload_signature.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/read_contract.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/read_contract.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.readContract = void 0;\nconst coinbase_1 = __webpack_require__(/*! ./coinbase */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/coinbase.js\");\n/**\n * Converts a SolidityValue to its corresponding JavaScript type.\n *\n * @param {SolidityValue} solidityValue - The Solidity value to convert.\n * @returns {unknown} The converted JavaScript value.\n */\nfunction convertSolidityValue(solidityValue) {\n    const { type, value, values } = solidityValue;\n    switch (type) {\n        case \"uint8\":\n        case \"uint16\":\n        case \"uint32\":\n        case \"int8\":\n        case \"int16\":\n        case \"int32\":\n            return Number(value);\n        case \"uint64\":\n        case \"uint128\":\n        case \"uint256\":\n        case \"int64\":\n        case \"int128\":\n        case \"int256\":\n            return BigInt(value);\n        case \"address\":\n            return value;\n        case \"bool\":\n            return value === \"true\";\n        case \"string\":\n            return value;\n        case \"bytes\":\n        case \"bytes1\":\n        case \"bytes2\":\n        case \"bytes3\":\n        case \"bytes4\":\n        case \"bytes5\":\n        case \"bytes6\":\n        case \"bytes7\":\n        case \"bytes8\":\n        case \"bytes9\":\n        case \"bytes10\":\n        case \"bytes11\":\n        case \"bytes12\":\n        case \"bytes13\":\n        case \"bytes14\":\n        case \"bytes15\":\n        case \"bytes16\":\n        case \"bytes17\":\n        case \"bytes18\":\n        case \"bytes19\":\n        case \"bytes20\":\n        case \"bytes21\":\n        case \"bytes22\":\n        case \"bytes23\":\n        case \"bytes24\":\n        case \"bytes25\":\n        case \"bytes26\":\n        case \"bytes27\":\n        case \"bytes28\":\n        case \"bytes29\":\n        case \"bytes30\":\n        case \"bytes31\":\n        case \"bytes32\":\n            return value;\n        case \"array\":\n            return values.map(convertSolidityValue);\n        case \"tuple\":\n            return values.reduce((acc, val) => {\n                if (!val.name) {\n                    throw new Error(\"Tuple field missing name\");\n                }\n                acc[val.name] = convertSolidityValue(val);\n                return acc;\n            }, {});\n        default:\n            throw new Error(`Unsupported Solidity type: ${type}`);\n    }\n}\n/**\n * Parses a SolidityValue to a specific type T.\n *\n * @template T\n * @param {SolidityValue} solidityValue - The Solidity value to parse.\n * @returns {T} The parsed value of type T.\n */\nfunction parseSolidityValue(solidityValue) {\n    return convertSolidityValue(solidityValue);\n}\n/**\n * Reads data from a smart contract using the Coinbase API.\n *\n * @template TAbi - The ABI type.\n * @template TFunctionName - The contract function name type.\n * @template TArgs - The function arguments type.\n * @param {object} params - The parameters for reading the contract.\n * @param {string} params.networkId - The network ID.\n * @param {string} params.contractAddress - The contract address (as a hexadecimal string).\n * @param {TFunctionName} params.method - The contract method to call.\n * @param {TArgs} params.args - The arguments for the contract method.\n * @param {TAbi} [params.abi] - The contract ABI (optional).\n * @returns {Promise<any>} The result of the contract call.\n */\nasync function readContract(params) {\n    const response = await coinbase_1.Coinbase.apiClients.smartContract.readContract(params.networkId, params.contractAddress, {\n        method: params.method,\n        args: JSON.stringify(params.args || {}),\n        abi: params.abi ? JSON.stringify(params.abi) : undefined,\n    });\n    return parseSolidityValue(response.data);\n}\nexports.readContract = readContract;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL3JlYWRfY29udHJhY3QuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsb0JBQW9CO0FBQ3BCLG1CQUFtQixtQkFBTyxDQUFDLHlGQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBLFlBQVksc0JBQXNCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxJQUFJO0FBQ2pCO0FBQ0EsMERBQTBELEtBQUs7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLGFBQWEsR0FBRztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsZUFBZTtBQUMxQixXQUFXLE9BQU87QUFDbEIsV0FBVyxNQUFNO0FBQ2pCLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esb0JBQW9CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3Vydml2YWwtZnVuLy4vbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9jb2luYmFzZS1zZGsvZGlzdC9jb2luYmFzZS9yZWFkX2NvbnRyYWN0LmpzP2ExYWYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJlYWRDb250cmFjdCA9IHZvaWQgMDtcbmNvbnN0IGNvaW5iYXNlXzEgPSByZXF1aXJlKFwiLi9jb2luYmFzZVwiKTtcbi8qKlxuICogQ29udmVydHMgYSBTb2xpZGl0eVZhbHVlIHRvIGl0cyBjb3JyZXNwb25kaW5nIEphdmFTY3JpcHQgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge1NvbGlkaXR5VmFsdWV9IHNvbGlkaXR5VmFsdWUgLSBUaGUgU29saWRpdHkgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHt1bmtub3dufSBUaGUgY29udmVydGVkIEphdmFTY3JpcHQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRTb2xpZGl0eVZhbHVlKHNvbGlkaXR5VmFsdWUpIHtcbiAgICBjb25zdCB7IHR5cGUsIHZhbHVlLCB2YWx1ZXMgfSA9IHNvbGlkaXR5VmFsdWU7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJ1aW50OFwiOlxuICAgICAgICBjYXNlIFwidWludDE2XCI6XG4gICAgICAgIGNhc2UgXCJ1aW50MzJcIjpcbiAgICAgICAgY2FzZSBcImludDhcIjpcbiAgICAgICAgY2FzZSBcImludDE2XCI6XG4gICAgICAgIGNhc2UgXCJpbnQzMlwiOlxuICAgICAgICAgICAgcmV0dXJuIE51bWJlcih2YWx1ZSk7XG4gICAgICAgIGNhc2UgXCJ1aW50NjRcIjpcbiAgICAgICAgY2FzZSBcInVpbnQxMjhcIjpcbiAgICAgICAgY2FzZSBcInVpbnQyNTZcIjpcbiAgICAgICAgY2FzZSBcImludDY0XCI6XG4gICAgICAgIGNhc2UgXCJpbnQxMjhcIjpcbiAgICAgICAgY2FzZSBcImludDI1NlwiOlxuICAgICAgICAgICAgcmV0dXJuIEJpZ0ludCh2YWx1ZSk7XG4gICAgICAgIGNhc2UgXCJhZGRyZXNzXCI6XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIGNhc2UgXCJib29sXCI6XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgPT09IFwidHJ1ZVwiO1xuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIGNhc2UgXCJieXRlc1wiOlxuICAgICAgICBjYXNlIFwiYnl0ZXMxXCI6XG4gICAgICAgIGNhc2UgXCJieXRlczJcIjpcbiAgICAgICAgY2FzZSBcImJ5dGVzM1wiOlxuICAgICAgICBjYXNlIFwiYnl0ZXM0XCI6XG4gICAgICAgIGNhc2UgXCJieXRlczVcIjpcbiAgICAgICAgY2FzZSBcImJ5dGVzNlwiOlxuICAgICAgICBjYXNlIFwiYnl0ZXM3XCI6XG4gICAgICAgIGNhc2UgXCJieXRlczhcIjpcbiAgICAgICAgY2FzZSBcImJ5dGVzOVwiOlxuICAgICAgICBjYXNlIFwiYnl0ZXMxMFwiOlxuICAgICAgICBjYXNlIFwiYnl0ZXMxMVwiOlxuICAgICAgICBjYXNlIFwiYnl0ZXMxMlwiOlxuICAgICAgICBjYXNlIFwiYnl0ZXMxM1wiOlxuICAgICAgICBjYXNlIFwiYnl0ZXMxNFwiOlxuICAgICAgICBjYXNlIFwiYnl0ZXMxNVwiOlxuICAgICAgICBjYXNlIFwiYnl0ZXMxNlwiOlxuICAgICAgICBjYXNlIFwiYnl0ZXMxN1wiOlxuICAgICAgICBjYXNlIFwiYnl0ZXMxOFwiOlxuICAgICAgICBjYXNlIFwiYnl0ZXMxOVwiOlxuICAgICAgICBjYXNlIFwiYnl0ZXMyMFwiOlxuICAgICAgICBjYXNlIFwiYnl0ZXMyMVwiOlxuICAgICAgICBjYXNlIFwiYnl0ZXMyMlwiOlxuICAgICAgICBjYXNlIFwiYnl0ZXMyM1wiOlxuICAgICAgICBjYXNlIFwiYnl0ZXMyNFwiOlxuICAgICAgICBjYXNlIFwiYnl0ZXMyNVwiOlxuICAgICAgICBjYXNlIFwiYnl0ZXMyNlwiOlxuICAgICAgICBjYXNlIFwiYnl0ZXMyN1wiOlxuICAgICAgICBjYXNlIFwiYnl0ZXMyOFwiOlxuICAgICAgICBjYXNlIFwiYnl0ZXMyOVwiOlxuICAgICAgICBjYXNlIFwiYnl0ZXMzMFwiOlxuICAgICAgICBjYXNlIFwiYnl0ZXMzMVwiOlxuICAgICAgICBjYXNlIFwiYnl0ZXMzMlwiOlxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICBjYXNlIFwiYXJyYXlcIjpcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZXMubWFwKGNvbnZlcnRTb2xpZGl0eVZhbHVlKTtcbiAgICAgICAgY2FzZSBcInR1cGxlXCI6XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVzLnJlZHVjZSgoYWNjLCB2YWwpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXZhbC5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlR1cGxlIGZpZWxkIG1pc3NpbmcgbmFtZVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWNjW3ZhbC5uYW1lXSA9IGNvbnZlcnRTb2xpZGl0eVZhbHVlKHZhbCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgU29saWRpdHkgdHlwZTogJHt0eXBlfWApO1xuICAgIH1cbn1cbi8qKlxuICogUGFyc2VzIGEgU29saWRpdHlWYWx1ZSB0byBhIHNwZWNpZmljIHR5cGUgVC5cbiAqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtTb2xpZGl0eVZhbHVlfSBzb2xpZGl0eVZhbHVlIC0gVGhlIFNvbGlkaXR5IHZhbHVlIHRvIHBhcnNlLlxuICogQHJldHVybnMge1R9IFRoZSBwYXJzZWQgdmFsdWUgb2YgdHlwZSBULlxuICovXG5mdW5jdGlvbiBwYXJzZVNvbGlkaXR5VmFsdWUoc29saWRpdHlWYWx1ZSkge1xuICAgIHJldHVybiBjb252ZXJ0U29saWRpdHlWYWx1ZShzb2xpZGl0eVZhbHVlKTtcbn1cbi8qKlxuICogUmVhZHMgZGF0YSBmcm9tIGEgc21hcnQgY29udHJhY3QgdXNpbmcgdGhlIENvaW5iYXNlIEFQSS5cbiAqXG4gKiBAdGVtcGxhdGUgVEFiaSAtIFRoZSBBQkkgdHlwZS5cbiAqIEB0ZW1wbGF0ZSBURnVuY3Rpb25OYW1lIC0gVGhlIGNvbnRyYWN0IGZ1bmN0aW9uIG5hbWUgdHlwZS5cbiAqIEB0ZW1wbGF0ZSBUQXJncyAtIFRoZSBmdW5jdGlvbiBhcmd1bWVudHMgdHlwZS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgcmVhZGluZyB0aGUgY29udHJhY3QuXG4gKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLm5ldHdvcmtJZCAtIFRoZSBuZXR3b3JrIElELlxuICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5jb250cmFjdEFkZHJlc3MgLSBUaGUgY29udHJhY3QgYWRkcmVzcyAoYXMgYSBoZXhhZGVjaW1hbCBzdHJpbmcpLlxuICogQHBhcmFtIHtURnVuY3Rpb25OYW1lfSBwYXJhbXMubWV0aG9kIC0gVGhlIGNvbnRyYWN0IG1ldGhvZCB0byBjYWxsLlxuICogQHBhcmFtIHtUQXJnc30gcGFyYW1zLmFyZ3MgLSBUaGUgYXJndW1lbnRzIGZvciB0aGUgY29udHJhY3QgbWV0aG9kLlxuICogQHBhcmFtIHtUQWJpfSBbcGFyYW1zLmFiaV0gLSBUaGUgY29udHJhY3QgQUJJIChvcHRpb25hbCkuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fSBUaGUgcmVzdWx0IG9mIHRoZSBjb250cmFjdCBjYWxsLlxuICovXG5hc3luYyBmdW5jdGlvbiByZWFkQ29udHJhY3QocGFyYW1zKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjb2luYmFzZV8xLkNvaW5iYXNlLmFwaUNsaWVudHMuc21hcnRDb250cmFjdC5yZWFkQ29udHJhY3QocGFyYW1zLm5ldHdvcmtJZCwgcGFyYW1zLmNvbnRyYWN0QWRkcmVzcywge1xuICAgICAgICBtZXRob2Q6IHBhcmFtcy5tZXRob2QsXG4gICAgICAgIGFyZ3M6IEpTT04uc3RyaW5naWZ5KHBhcmFtcy5hcmdzIHx8IHt9KSxcbiAgICAgICAgYWJpOiBwYXJhbXMuYWJpID8gSlNPTi5zdHJpbmdpZnkocGFyYW1zLmFiaSkgOiB1bmRlZmluZWQsXG4gICAgfSk7XG4gICAgcmV0dXJuIHBhcnNlU29saWRpdHlWYWx1ZShyZXNwb25zZS5kYXRhKTtcbn1cbmV4cG9ydHMucmVhZENvbnRyYWN0ID0gcmVhZENvbnRyYWN0O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/read_contract.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/server_signer.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/server_signer.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ServerSigner = void 0;\nconst coinbase_1 = __webpack_require__(/*! ./coinbase */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/coinbase.js\");\n/**\n * A representation of a Server-Signer. Server-Signers are assigned to sign transactions for a Wallet.\n */\nclass ServerSigner {\n    /**\n     * Private constructor to prevent direct instantiation outside of factory method.\n     * Creates a new ServerSigner instance.\n     * Do not use this method directly. Instead, use ServerSigner.getDefault().\n     *\n     * @ignore\n     * @param serverSignerModel - The Server-Signer model.\n     * @hideconstructor\n     */\n    constructor(serverSignerModel) {\n        this.model = serverSignerModel;\n    }\n    /**\n     * Returns the default Server-Signer for the CDP Project.\n     *\n     * @returns The default Server-Signer.\n     * @throws {APIError} if the API request to list Server-Signers fails.\n     * @throws {Error} if there is no Server-Signer associated with the CDP Project.\n     */\n    static async getDefault() {\n        const response = await coinbase_1.Coinbase.apiClients.serverSigner.listServerSigners();\n        if (response.data.data.length === 0) {\n            throw new Error(\"No Server-Signer is associated with the project\");\n        }\n        return new ServerSigner(response.data.data[0]);\n    }\n    /**\n     * Returns the ID of the Server-Signer.\n     *\n     * @returns The Server-Signer ID.\n     */\n    getId() {\n        return this.model.server_signer_id;\n    }\n    /**\n     * Returns the IDs of the Wallet's the Server-Signer can sign for.\n     *\n     * @returns The Wallet IDs.\n     */\n    getWallets() {\n        return this.model.wallets;\n    }\n    /**\n     * Returns a String representation of the Server-Signer.\n     *\n     * @returns a String representation of the Server-Signer.\n     */\n    toString() {\n        return `ServerSigner{id: '${this.getId()}', wallets: '${this.getWallets()}'}`;\n    }\n}\nexports.ServerSigner = ServerSigner;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL3NlcnZlcl9zaWduZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsb0JBQW9CO0FBQ3BCLG1CQUFtQixtQkFBTyxDQUFDLHlGQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsT0FBTyxhQUFhLGVBQWUsa0JBQWtCLEVBQUU7QUFDcEY7QUFDQTtBQUNBLG9CQUFvQiIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cnZpdmFsLWZ1bi8uL25vZGVfbW9kdWxlcy9AY29pbmJhc2UvY29pbmJhc2Utc2RrL2Rpc3QvY29pbmJhc2Uvc2VydmVyX3NpZ25lci5qcz82NGY2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TZXJ2ZXJTaWduZXIgPSB2b2lkIDA7XG5jb25zdCBjb2luYmFzZV8xID0gcmVxdWlyZShcIi4vY29pbmJhc2VcIik7XG4vKipcbiAqIEEgcmVwcmVzZW50YXRpb24gb2YgYSBTZXJ2ZXItU2lnbmVyLiBTZXJ2ZXItU2lnbmVycyBhcmUgYXNzaWduZWQgdG8gc2lnbiB0cmFuc2FjdGlvbnMgZm9yIGEgV2FsbGV0LlxuICovXG5jbGFzcyBTZXJ2ZXJTaWduZXIge1xuICAgIC8qKlxuICAgICAqIFByaXZhdGUgY29uc3RydWN0b3IgdG8gcHJldmVudCBkaXJlY3QgaW5zdGFudGlhdGlvbiBvdXRzaWRlIG9mIGZhY3RvcnkgbWV0aG9kLlxuICAgICAqIENyZWF0ZXMgYSBuZXcgU2VydmVyU2lnbmVyIGluc3RhbmNlLlxuICAgICAqIERvIG5vdCB1c2UgdGhpcyBtZXRob2QgZGlyZWN0bHkuIEluc3RlYWQsIHVzZSBTZXJ2ZXJTaWduZXIuZ2V0RGVmYXVsdCgpLlxuICAgICAqXG4gICAgICogQGlnbm9yZVxuICAgICAqIEBwYXJhbSBzZXJ2ZXJTaWduZXJNb2RlbCAtIFRoZSBTZXJ2ZXItU2lnbmVyIG1vZGVsLlxuICAgICAqIEBoaWRlY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihzZXJ2ZXJTaWduZXJNb2RlbCkge1xuICAgICAgICB0aGlzLm1vZGVsID0gc2VydmVyU2lnbmVyTW9kZWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGRlZmF1bHQgU2VydmVyLVNpZ25lciBmb3IgdGhlIENEUCBQcm9qZWN0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGRlZmF1bHQgU2VydmVyLVNpZ25lci5cbiAgICAgKiBAdGhyb3dzIHtBUElFcnJvcn0gaWYgdGhlIEFQSSByZXF1ZXN0IHRvIGxpc3QgU2VydmVyLVNpZ25lcnMgZmFpbHMuXG4gICAgICogQHRocm93cyB7RXJyb3J9IGlmIHRoZXJlIGlzIG5vIFNlcnZlci1TaWduZXIgYXNzb2NpYXRlZCB3aXRoIHRoZSBDRFAgUHJvamVjdC5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgZ2V0RGVmYXVsdCgpIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjb2luYmFzZV8xLkNvaW5iYXNlLmFwaUNsaWVudHMuc2VydmVyU2lnbmVyLmxpc3RTZXJ2ZXJTaWduZXJzKCk7XG4gICAgICAgIGlmIChyZXNwb25zZS5kYXRhLmRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBTZXJ2ZXItU2lnbmVyIGlzIGFzc29jaWF0ZWQgd2l0aCB0aGUgcHJvamVjdFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFNlcnZlclNpZ25lcihyZXNwb25zZS5kYXRhLmRhdGFbMF0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBJRCBvZiB0aGUgU2VydmVyLVNpZ25lci5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBTZXJ2ZXItU2lnbmVyIElELlxuICAgICAqL1xuICAgIGdldElkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5zZXJ2ZXJfc2lnbmVyX2lkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBJRHMgb2YgdGhlIFdhbGxldCdzIHRoZSBTZXJ2ZXItU2lnbmVyIGNhbiBzaWduIGZvci5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBXYWxsZXQgSURzLlxuICAgICAqL1xuICAgIGdldFdhbGxldHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLndhbGxldHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIFNlcnZlci1TaWduZXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBhIFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgU2VydmVyLVNpZ25lci5cbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGBTZXJ2ZXJTaWduZXJ7aWQ6ICcke3RoaXMuZ2V0SWQoKX0nLCB3YWxsZXRzOiAnJHt0aGlzLmdldFdhbGxldHMoKX0nfWA7XG4gICAgfVxufVxuZXhwb3J0cy5TZXJ2ZXJTaWduZXIgPSBTZXJ2ZXJTaWduZXI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/server_signer.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/smart_contract.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/smart_contract.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SmartContract = void 0;\nconst api_1 = __webpack_require__(/*! ../client/api */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/client/api.js\");\nconst transaction_1 = __webpack_require__(/*! ./transaction */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/transaction.js\");\nconst types_1 = __webpack_require__(/*! ./types */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/types.js\");\nconst coinbase_1 = __webpack_require__(/*! ./coinbase */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/coinbase.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/utils.js\");\nconst errors_1 = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/errors.js\");\nconst contract_event_1 = __webpack_require__(/*! ./contract_event */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/contract_event.js\");\n/**\n * A representation of a SmartContract on the blockchain.\n */\nclass SmartContract {\n    /**\n     * Creates a new SmartContract instance.\n     *\n     * @param contractModel - The SmartContract model from the API.\n     */\n    constructor(contractModel) {\n        if (!contractModel) {\n            throw new Error(\"SmartContract model cannot be empty\");\n        }\n        this.model = contractModel;\n    }\n    /**\n     * Returns whether the SmartContract is external.\n     *\n     * @returns True if the SmartContract is external, false otherwise.\n     */\n    get isExternal() {\n        return this.model.is_external;\n    }\n    /**\n     * Returns a list of ContractEvents for the provided network, contract, and event details.\n     *\n     * @param networkId - The network ID.\n     * @param protocolName - The protocol name.\n     * @param contractAddress - The contract address.\n     * @param contractName - The contract name.\n     * @param eventName - The event name.\n     * @param fromBlockHeight - The start block height.\n     * @param toBlockHeight - The end block height.\n     * @returns The contract events.\n     */\n    static async listEvents(networkId, protocolName, contractAddress, contractName, eventName, fromBlockHeight, toBlockHeight) {\n        const contractEvents = [];\n        const queue = [\"\"];\n        while (queue.length > 0) {\n            const page = queue.shift();\n            const response = await coinbase_1.Coinbase.apiClients.contractEvent.listContractEvents(networkId, protocolName, contractAddress, contractName, eventName, fromBlockHeight, toBlockHeight, page?.length ? page : undefined);\n            response.data.data.forEach(contractEvent => {\n                contractEvents.push(new contract_event_1.ContractEvent(contractEvent));\n            });\n            if (response.data.has_more) {\n                if (response.data.next_page) {\n                    queue.push(response.data.next_page);\n                }\n            }\n        }\n        return contractEvents;\n    }\n    /**\n     * Register a smart contract.\n     *\n     * @param options - The options to register a smart contract.\n     * @param options.networkId - The network ID.\n     * @param options.contractAddress - The contract address.\n     * @param options.abi - The ABI of the contract.\n     * @param options.contractName - The contract name.\n     * @returns The smart contract.\n     */\n    static async register({ networkId, contractAddress, abi, contractName, }) {\n        const response = await coinbase_1.Coinbase.apiClients.smartContract.registerSmartContract(networkId, contractAddress, {\n            abi: JSON.stringify(abi),\n            contract_name: contractName,\n        });\n        return SmartContract.fromModel(response.data);\n    }\n    /**\n     * Lists Smart Contracts.\n     *\n     * @param options - The pagination options.\n     * @param options.page - The cursor for pagination across multiple pages of Smart Contract. Don\\&#39;t include this parameter on the first call. Use the next page value returned in a previous response to request subsequent results.\n     *\n     * @returns The paginated list response of Smart Contracts.\n     */\n    static async list({ page = undefined } = {}) {\n        const data = [];\n        let nextPage;\n        const response = await coinbase_1.Coinbase.apiClients.smartContract.listSmartContracts(page);\n        const smartContracts = response.data.data;\n        for (const sc of smartContracts) {\n            data.push(new SmartContract(sc));\n        }\n        const hasMore = response.data.has_more ? response.data.has_more : false;\n        if (hasMore) {\n            if (response.data.next_page) {\n                nextPage = response.data.next_page;\n            }\n        }\n        return {\n            data,\n            hasMore,\n            nextPage,\n        };\n    }\n    /**\n     * Converts a SmartContractModel into a SmartContract object.\n     *\n     * @param contractModel - The SmartContract model object.\n     * @returns The SmartContract object.\n     */\n    static fromModel(contractModel) {\n        return new SmartContract(contractModel);\n    }\n    /**\n     * Returns the ID of the SmartContract.\n     *\n     * @returns The SmartContract ID.\n     */\n    getId() {\n        return this.model.smart_contract_id;\n    }\n    /**\n     * Returns the Network ID of the SmartContract.\n     *\n     * @returns The Network ID.\n     */\n    getNetworkId() {\n        return this.model.network_id;\n    }\n    /**\n     * Returns the Wallet ID that deployed the smart contract.\n     *\n     * @returns The Wallet ID.\n     */\n    getWalletId() {\n        if (!this.model.wallet_id)\n            return undefined;\n        return this.model.wallet_id;\n    }\n    /**\n     * Returns the name of the smart contract.\n     *\n     * @returns The contract name.\n     */\n    getContractName() {\n        return this.model.contract_name;\n    }\n    /**\n     * Returns the Contract Address of the smart contract.\n     *\n     * @returns The Contract Address.\n     */\n    getContractAddress() {\n        return this.model.contract_address;\n    }\n    /**\n     * Returns the Deployer Address of the smart contract.\n     *\n     * @returns The Deployer Address.\n     */\n    getDeployerAddress() {\n        if (!this.model.deployer_address)\n            return undefined;\n        return this.model.deployer_address;\n    }\n    /**\n     * Returns the Type of the smart contract.\n     *\n     * @returns The Smart Contract Type.\n     */\n    getType() {\n        switch (this.model.type) {\n            case api_1.SmartContractType.Erc20:\n                return types_1.SmartContractType.ERC20;\n            case api_1.SmartContractType.Erc721:\n                return types_1.SmartContractType.ERC721;\n            case api_1.SmartContractType.Erc1155:\n                return types_1.SmartContractType.ERC1155;\n            case api_1.SmartContractType.Custom:\n                return types_1.SmartContractType.CUSTOM;\n            default:\n                throw new Error(`Unknown smart contract type: ${this.model.type}`);\n        }\n    }\n    /**\n     * Returns the Options of the smart contract.\n     *\n     * @returns The Smart Contract Options.\n     */\n    getOptions() {\n        if (this.isExternal)\n            throw new Error(\"SmartContract options cannot be returned for external SmartContract\");\n        const options = this.model.options;\n        if (this.isERC20(this.getType(), options)) {\n            return {\n                name: options.name,\n                symbol: options.symbol,\n                totalSupply: options.total_supply,\n            };\n        }\n        else if (this.isERC721(this.getType(), options)) {\n            return {\n                name: options.name,\n                symbol: options.symbol,\n                baseURI: options.base_uri,\n            };\n        }\n        else if (this.isERC1155(this.getType(), options)) {\n            return {\n                uri: options.uri,\n            };\n        }\n        else {\n            return options;\n        }\n    }\n    /**\n     * Returns the ABI of the smart contract.\n     *\n     * @returns The ABI as a JSON-encoded string.\n     */\n    getAbi() {\n        return JSON.parse(this.model.abi);\n    }\n    /**\n     * Returns the Transaction of the smart contract deployment.\n     *\n     * @returns The Transaction.\n     */\n    getTransaction() {\n        if (this.isExternal)\n            return undefined;\n        return new transaction_1.Transaction(this.model.transaction);\n    }\n    /**\n     * Signs the SmartContract deployment with the provided key and returns the hex signature\n     * required for broadcasting the SmartContract deployment.\n     *\n     * @param key - The key to sign the SmartContract deployment with\n     * @returns The hex-encoded signed payload\n     */\n    async sign(key) {\n        if (this.isExternal)\n            throw new Error(\"Cannot sign an external SmartContract\");\n        return this.getTransaction().sign(key);\n    }\n    /**\n     * Update a smart contract.\n     *\n     * @param options - The options to update a smart contract.\n     * @param options.abi - The new ABI of the contract.\n     * @param options.contractName - The new contract name.\n     * @returns The smart contract.\n     */\n    async update({ abi, contractName }) {\n        const response = await coinbase_1.Coinbase.apiClients.smartContract.updateSmartContract(this.getNetworkId(), this.getContractAddress(), {\n            abi: JSON.stringify(abi),\n            contract_name: contractName,\n        });\n        return SmartContract.fromModel(response.data);\n    }\n    /**\n     * Broadcasts the SmartContract deployment to the Network.\n     *\n     * @returns The SmartContract object\n     * @throws {APIError} if the API request to broadcast a SmartContract deployment fails.\n     */\n    async broadcast() {\n        if (this.isExternal)\n            throw new Error(\"Cannot broadcast an external SmartContract\");\n        if (!this.getTransaction().isSigned())\n            throw new Error(\"Cannot broadcast unsigned SmartContract deployment\");\n        const deploySmartContractRequest = {\n            signed_payload: this.getTransaction().getSignature(),\n        };\n        const response = await coinbase_1.Coinbase.apiClients.smartContract.deploySmartContract(this.getWalletId(), this.getDeployerAddress(), this.getId(), deploySmartContractRequest);\n        return SmartContract.fromModel(response.data);\n    }\n    /**\n     * Waits for the SmartContract deployment to be confirmed on the Network or fail on chain.\n     * Waits until the SmartContract deployment is completed or failed on-chain by polling at the given interval.\n     * Raises an error if the SmartContract deployment takes longer than the given timeout.\n     *\n     * @param options - The options to configure the wait function.\n     * @param options.intervalSeconds - The interval to check the status of the SmartContract deployment.\n     * @param options.timeoutSeconds - The maximum time to wait for the SmartContract deployment to be confirmed.\n     *\n     * @returns The SmartContract object in a terminal state.\n     * @throws {Error} if the SmartContract deployment times out.\n     */\n    async wait({ intervalSeconds = 0.2, timeoutSeconds = 10 } = {}) {\n        if (this.isExternal)\n            throw new Error(\"Cannot wait for an external SmartContract\");\n        const startTime = Date.now();\n        while (Date.now() - startTime < timeoutSeconds * 1000) {\n            await this.reload();\n            // If the SmartContract deployment is in a terminal state, return the SmartContract.\n            const status = this.getTransaction().getStatus();\n            if (status === types_1.TransactionStatus.COMPLETE || status === types_1.TransactionStatus.FAILED) {\n                return this;\n            }\n            await (0, utils_1.delay)(intervalSeconds);\n        }\n        throw new errors_1.TimeoutError(\"SmartContract deployment timed out\");\n    }\n    /**\n     * Reloads the SmartContract model with the latest data from the server.\n     *\n     * @throws {APIError} if the API request to get a SmartContract fails.\n     */\n    async reload() {\n        if (this.isExternal)\n            throw new Error(\"Cannot reload an external SmartContract\");\n        const result = await coinbase_1.Coinbase.apiClients.smartContract.getSmartContract(this.getWalletId(), this.getDeployerAddress(), this.getId());\n        this.model = result?.data;\n    }\n    /**\n     * Returns a string representation of the SmartContract.\n     *\n     * @returns The string representation of the SmartContract.\n     */\n    toString() {\n        return (`SmartContract{id: '${this.getId()}', networkId: '${this.getNetworkId()}', ` +\n            `contractAddress: '${this.getContractAddress()}', deployerAddress: '${this.getDeployerAddress()}', ` +\n            `type: '${this.getType()}'}`);\n    }\n    /**\n     * Type guard for checking if the smart contract is an ERC20.\n     *\n     * @param type - The type of the smart contract.\n     * @param options - The options of the smart contract.\n     * @returns True if the smart contract is an ERC20, false otherwise.\n     */\n    isERC20(type, options) {\n        return type === types_1.SmartContractType.ERC20;\n    }\n    /**\n     * Type guard for checking if the smart contract is an ERC721.\n     *\n     * @param type - The type of the smart contract.\n     * @param options - The options of the smart contract.\n     * @returns True if the smart contract is an ERC721, false otherwise.\n     */\n    isERC721(type, options) {\n        return type === types_1.SmartContractType.ERC721;\n    }\n    /**\n     * Type guard for checking if the smart contract is an ERC1155.\n     *\n     * @param type - The type of the smart contract.\n     * @param options - The options of the smart contract.\n     * @returns True if the smart contract is an ERC1155, false otherwise.\n     */\n    isERC1155(type, options) {\n        return type === types_1.SmartContractType.ERC1155;\n    }\n}\nexports.SmartContract = SmartContract;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL3NtYXJ0X2NvbnRyYWN0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQjtBQUNyQixjQUFjLG1CQUFPLENBQUMscUZBQWU7QUFDckMsc0JBQXNCLG1CQUFPLENBQUMsK0ZBQWU7QUFDN0MsZ0JBQWdCLG1CQUFPLENBQUMsbUZBQVM7QUFDakMsbUJBQW1CLG1CQUFPLENBQUMseUZBQVk7QUFDdkMsZ0JBQWdCLG1CQUFPLENBQUMsbUZBQVM7QUFDakMsaUJBQWlCLG1CQUFPLENBQUMscUZBQVU7QUFDbkMseUJBQXlCLG1CQUFPLENBQUMscUdBQWtCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixnREFBZ0Q7QUFDNUU7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlHQUF5RztBQUN6RztBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CLElBQUk7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLGdCQUFnQjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0EsaUJBQWlCLDZDQUE2QyxJQUFJO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixPQUFPLGFBQWEsaUJBQWlCLG9CQUFvQjtBQUN4RixpQ0FBaUMsMEJBQTBCLHVCQUF1QiwwQkFBMEI7QUFDNUcsc0JBQXNCLGVBQWUsRUFBRTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3Vydml2YWwtZnVuLy4vbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9jb2luYmFzZS1zZGsvZGlzdC9jb2luYmFzZS9zbWFydF9jb250cmFjdC5qcz80NDE3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TbWFydENvbnRyYWN0ID0gdm9pZCAwO1xuY29uc3QgYXBpXzEgPSByZXF1aXJlKFwiLi4vY2xpZW50L2FwaVwiKTtcbmNvbnN0IHRyYW5zYWN0aW9uXzEgPSByZXF1aXJlKFwiLi90cmFuc2FjdGlvblwiKTtcbmNvbnN0IHR5cGVzXzEgPSByZXF1aXJlKFwiLi90eXBlc1wiKTtcbmNvbnN0IGNvaW5iYXNlXzEgPSByZXF1aXJlKFwiLi9jb2luYmFzZVwiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4vZXJyb3JzXCIpO1xuY29uc3QgY29udHJhY3RfZXZlbnRfMSA9IHJlcXVpcmUoXCIuL2NvbnRyYWN0X2V2ZW50XCIpO1xuLyoqXG4gKiBBIHJlcHJlc2VudGF0aW9uIG9mIGEgU21hcnRDb250cmFjdCBvbiB0aGUgYmxvY2tjaGFpbi5cbiAqL1xuY2xhc3MgU21hcnRDb250cmFjdCB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBTbWFydENvbnRyYWN0IGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbnRyYWN0TW9kZWwgLSBUaGUgU21hcnRDb250cmFjdCBtb2RlbCBmcm9tIHRoZSBBUEkuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29udHJhY3RNb2RlbCkge1xuICAgICAgICBpZiAoIWNvbnRyYWN0TW9kZWwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNtYXJ0Q29udHJhY3QgbW9kZWwgY2Fubm90IGJlIGVtcHR5XCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW9kZWwgPSBjb250cmFjdE1vZGVsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIFNtYXJ0Q29udHJhY3QgaXMgZXh0ZXJuYWwuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBTbWFydENvbnRyYWN0IGlzIGV4dGVybmFsLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgZ2V0IGlzRXh0ZXJuYWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLmlzX2V4dGVybmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBDb250cmFjdEV2ZW50cyBmb3IgdGhlIHByb3ZpZGVkIG5ldHdvcmssIGNvbnRyYWN0LCBhbmQgZXZlbnQgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuZXR3b3JrSWQgLSBUaGUgbmV0d29yayBJRC5cbiAgICAgKiBAcGFyYW0gcHJvdG9jb2xOYW1lIC0gVGhlIHByb3RvY29sIG5hbWUuXG4gICAgICogQHBhcmFtIGNvbnRyYWN0QWRkcmVzcyAtIFRoZSBjb250cmFjdCBhZGRyZXNzLlxuICAgICAqIEBwYXJhbSBjb250cmFjdE5hbWUgLSBUaGUgY29udHJhY3QgbmFtZS5cbiAgICAgKiBAcGFyYW0gZXZlbnROYW1lIC0gVGhlIGV2ZW50IG5hbWUuXG4gICAgICogQHBhcmFtIGZyb21CbG9ja0hlaWdodCAtIFRoZSBzdGFydCBibG9jayBoZWlnaHQuXG4gICAgICogQHBhcmFtIHRvQmxvY2tIZWlnaHQgLSBUaGUgZW5kIGJsb2NrIGhlaWdodC5cbiAgICAgKiBAcmV0dXJucyBUaGUgY29udHJhY3QgZXZlbnRzLlxuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyBsaXN0RXZlbnRzKG5ldHdvcmtJZCwgcHJvdG9jb2xOYW1lLCBjb250cmFjdEFkZHJlc3MsIGNvbnRyYWN0TmFtZSwgZXZlbnROYW1lLCBmcm9tQmxvY2tIZWlnaHQsIHRvQmxvY2tIZWlnaHQpIHtcbiAgICAgICAgY29uc3QgY29udHJhY3RFdmVudHMgPSBbXTtcbiAgICAgICAgY29uc3QgcXVldWUgPSBbXCJcIl07XG4gICAgICAgIHdoaWxlIChxdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBwYWdlID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY29pbmJhc2VfMS5Db2luYmFzZS5hcGlDbGllbnRzLmNvbnRyYWN0RXZlbnQubGlzdENvbnRyYWN0RXZlbnRzKG5ldHdvcmtJZCwgcHJvdG9jb2xOYW1lLCBjb250cmFjdEFkZHJlc3MsIGNvbnRyYWN0TmFtZSwgZXZlbnROYW1lLCBmcm9tQmxvY2tIZWlnaHQsIHRvQmxvY2tIZWlnaHQsIHBhZ2U/Lmxlbmd0aCA/IHBhZ2UgOiB1bmRlZmluZWQpO1xuICAgICAgICAgICAgcmVzcG9uc2UuZGF0YS5kYXRhLmZvckVhY2goY29udHJhY3RFdmVudCA9PiB7XG4gICAgICAgICAgICAgICAgY29udHJhY3RFdmVudHMucHVzaChuZXcgY29udHJhY3RfZXZlbnRfMS5Db250cmFjdEV2ZW50KGNvbnRyYWN0RXZlbnQpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLmRhdGEuaGFzX21vcmUpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UuZGF0YS5uZXh0X3BhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcXVldWUucHVzaChyZXNwb25zZS5kYXRhLm5leHRfcGFnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb250cmFjdEV2ZW50cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgYSBzbWFydCBjb250cmFjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgdG8gcmVnaXN0ZXIgYSBzbWFydCBjb250cmFjdC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5uZXR3b3JrSWQgLSBUaGUgbmV0d29yayBJRC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5jb250cmFjdEFkZHJlc3MgLSBUaGUgY29udHJhY3QgYWRkcmVzcy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5hYmkgLSBUaGUgQUJJIG9mIHRoZSBjb250cmFjdC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5jb250cmFjdE5hbWUgLSBUaGUgY29udHJhY3QgbmFtZS5cbiAgICAgKiBAcmV0dXJucyBUaGUgc21hcnQgY29udHJhY3QuXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIHJlZ2lzdGVyKHsgbmV0d29ya0lkLCBjb250cmFjdEFkZHJlc3MsIGFiaSwgY29udHJhY3ROYW1lLCB9KSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY29pbmJhc2VfMS5Db2luYmFzZS5hcGlDbGllbnRzLnNtYXJ0Q29udHJhY3QucmVnaXN0ZXJTbWFydENvbnRyYWN0KG5ldHdvcmtJZCwgY29udHJhY3RBZGRyZXNzLCB7XG4gICAgICAgICAgICBhYmk6IEpTT04uc3RyaW5naWZ5KGFiaSksXG4gICAgICAgICAgICBjb250cmFjdF9uYW1lOiBjb250cmFjdE5hbWUsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gU21hcnRDb250cmFjdC5mcm9tTW9kZWwocmVzcG9uc2UuZGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3RzIFNtYXJ0IENvbnRyYWN0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIHBhZ2luYXRpb24gb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5wYWdlIC0gVGhlIGN1cnNvciBmb3IgcGFnaW5hdGlvbiBhY3Jvc3MgbXVsdGlwbGUgcGFnZXMgb2YgU21hcnQgQ29udHJhY3QuIERvblxcJiMzOTt0IGluY2x1ZGUgdGhpcyBwYXJhbWV0ZXIgb24gdGhlIGZpcnN0IGNhbGwuIFVzZSB0aGUgbmV4dCBwYWdlIHZhbHVlIHJldHVybmVkIGluIGEgcHJldmlvdXMgcmVzcG9uc2UgdG8gcmVxdWVzdCBzdWJzZXF1ZW50IHJlc3VsdHMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgcGFnaW5hdGVkIGxpc3QgcmVzcG9uc2Ugb2YgU21hcnQgQ29udHJhY3RzLlxuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyBsaXN0KHsgcGFnZSA9IHVuZGVmaW5lZCB9ID0ge30pIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IFtdO1xuICAgICAgICBsZXQgbmV4dFBhZ2U7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY29pbmJhc2VfMS5Db2luYmFzZS5hcGlDbGllbnRzLnNtYXJ0Q29udHJhY3QubGlzdFNtYXJ0Q29udHJhY3RzKHBhZ2UpO1xuICAgICAgICBjb25zdCBzbWFydENvbnRyYWN0cyA9IHJlc3BvbnNlLmRhdGEuZGF0YTtcbiAgICAgICAgZm9yIChjb25zdCBzYyBvZiBzbWFydENvbnRyYWN0cykge1xuICAgICAgICAgICAgZGF0YS5wdXNoKG5ldyBTbWFydENvbnRyYWN0KHNjKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGFzTW9yZSA9IHJlc3BvbnNlLmRhdGEuaGFzX21vcmUgPyByZXNwb25zZS5kYXRhLmhhc19tb3JlIDogZmFsc2U7XG4gICAgICAgIGlmIChoYXNNb3JlKSB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UuZGF0YS5uZXh0X3BhZ2UpIHtcbiAgICAgICAgICAgICAgICBuZXh0UGFnZSA9IHJlc3BvbnNlLmRhdGEubmV4dF9wYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgaGFzTW9yZSxcbiAgICAgICAgICAgIG5leHRQYWdlLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIFNtYXJ0Q29udHJhY3RNb2RlbCBpbnRvIGEgU21hcnRDb250cmFjdCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29udHJhY3RNb2RlbCAtIFRoZSBTbWFydENvbnRyYWN0IG1vZGVsIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyBUaGUgU21hcnRDb250cmFjdCBvYmplY3QuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21Nb2RlbChjb250cmFjdE1vZGVsKSB7XG4gICAgICAgIHJldHVybiBuZXcgU21hcnRDb250cmFjdChjb250cmFjdE1vZGVsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgSUQgb2YgdGhlIFNtYXJ0Q29udHJhY3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgU21hcnRDb250cmFjdCBJRC5cbiAgICAgKi9cbiAgICBnZXRJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwuc21hcnRfY29udHJhY3RfaWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIE5ldHdvcmsgSUQgb2YgdGhlIFNtYXJ0Q29udHJhY3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgTmV0d29yayBJRC5cbiAgICAgKi9cbiAgICBnZXROZXR3b3JrSWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLm5ldHdvcmtfaWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIFdhbGxldCBJRCB0aGF0IGRlcGxveWVkIHRoZSBzbWFydCBjb250cmFjdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBXYWxsZXQgSUQuXG4gICAgICovXG4gICAgZ2V0V2FsbGV0SWQoKSB7XG4gICAgICAgIGlmICghdGhpcy5tb2RlbC53YWxsZXRfaWQpXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC53YWxsZXRfaWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG5hbWUgb2YgdGhlIHNtYXJ0IGNvbnRyYWN0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGNvbnRyYWN0IG5hbWUuXG4gICAgICovXG4gICAgZ2V0Q29udHJhY3ROYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5jb250cmFjdF9uYW1lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBDb250cmFjdCBBZGRyZXNzIG9mIHRoZSBzbWFydCBjb250cmFjdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBDb250cmFjdCBBZGRyZXNzLlxuICAgICAqL1xuICAgIGdldENvbnRyYWN0QWRkcmVzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwuY29udHJhY3RfYWRkcmVzcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgRGVwbG95ZXIgQWRkcmVzcyBvZiB0aGUgc21hcnQgY29udHJhY3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgRGVwbG95ZXIgQWRkcmVzcy5cbiAgICAgKi9cbiAgICBnZXREZXBsb3llckFkZHJlc3MoKSB7XG4gICAgICAgIGlmICghdGhpcy5tb2RlbC5kZXBsb3llcl9hZGRyZXNzKVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwuZGVwbG95ZXJfYWRkcmVzcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgVHlwZSBvZiB0aGUgc21hcnQgY29udHJhY3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgU21hcnQgQ29udHJhY3QgVHlwZS5cbiAgICAgKi9cbiAgICBnZXRUeXBlKCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMubW9kZWwudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBhcGlfMS5TbWFydENvbnRyYWN0VHlwZS5FcmMyMDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZXNfMS5TbWFydENvbnRyYWN0VHlwZS5FUkMyMDtcbiAgICAgICAgICAgIGNhc2UgYXBpXzEuU21hcnRDb250cmFjdFR5cGUuRXJjNzIxOlxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlc18xLlNtYXJ0Q29udHJhY3RUeXBlLkVSQzcyMTtcbiAgICAgICAgICAgIGNhc2UgYXBpXzEuU21hcnRDb250cmFjdFR5cGUuRXJjMTE1NTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZXNfMS5TbWFydENvbnRyYWN0VHlwZS5FUkMxMTU1O1xuICAgICAgICAgICAgY2FzZSBhcGlfMS5TbWFydENvbnRyYWN0VHlwZS5DdXN0b206XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVzXzEuU21hcnRDb250cmFjdFR5cGUuQ1VTVE9NO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gc21hcnQgY29udHJhY3QgdHlwZTogJHt0aGlzLm1vZGVsLnR5cGV9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgT3B0aW9ucyBvZiB0aGUgc21hcnQgY29udHJhY3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgU21hcnQgQ29udHJhY3QgT3B0aW9ucy5cbiAgICAgKi9cbiAgICBnZXRPcHRpb25zKCkge1xuICAgICAgICBpZiAodGhpcy5pc0V4dGVybmFsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU21hcnRDb250cmFjdCBvcHRpb25zIGNhbm5vdCBiZSByZXR1cm5lZCBmb3IgZXh0ZXJuYWwgU21hcnRDb250cmFjdFwiKTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMubW9kZWwub3B0aW9ucztcbiAgICAgICAgaWYgKHRoaXMuaXNFUkMyMCh0aGlzLmdldFR5cGUoKSwgb3B0aW9ucykpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbmFtZTogb3B0aW9ucy5uYW1lLFxuICAgICAgICAgICAgICAgIHN5bWJvbDogb3B0aW9ucy5zeW1ib2wsXG4gICAgICAgICAgICAgICAgdG90YWxTdXBwbHk6IG9wdGlvbnMudG90YWxfc3VwcGx5LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmlzRVJDNzIxKHRoaXMuZ2V0VHlwZSgpLCBvcHRpb25zKSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBvcHRpb25zLm5hbWUsXG4gICAgICAgICAgICAgICAgc3ltYm9sOiBvcHRpb25zLnN5bWJvbCxcbiAgICAgICAgICAgICAgICBiYXNlVVJJOiBvcHRpb25zLmJhc2VfdXJpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmlzRVJDMTE1NSh0aGlzLmdldFR5cGUoKSwgb3B0aW9ucykpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJpOiBvcHRpb25zLnVyaSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBBQkkgb2YgdGhlIHNtYXJ0IGNvbnRyYWN0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIEFCSSBhcyBhIEpTT04tZW5jb2RlZCBzdHJpbmcuXG4gICAgICovXG4gICAgZ2V0QWJpKCkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZSh0aGlzLm1vZGVsLmFiaSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIFRyYW5zYWN0aW9uIG9mIHRoZSBzbWFydCBjb250cmFjdCBkZXBsb3ltZW50LlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIFRyYW5zYWN0aW9uLlxuICAgICAqL1xuICAgIGdldFRyYW5zYWN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5pc0V4dGVybmFsKVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIG5ldyB0cmFuc2FjdGlvbl8xLlRyYW5zYWN0aW9uKHRoaXMubW9kZWwudHJhbnNhY3Rpb24pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaWducyB0aGUgU21hcnRDb250cmFjdCBkZXBsb3ltZW50IHdpdGggdGhlIHByb3ZpZGVkIGtleSBhbmQgcmV0dXJucyB0aGUgaGV4IHNpZ25hdHVyZVxuICAgICAqIHJlcXVpcmVkIGZvciBicm9hZGNhc3RpbmcgdGhlIFNtYXJ0Q29udHJhY3QgZGVwbG95bWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBrZXkgLSBUaGUga2V5IHRvIHNpZ24gdGhlIFNtYXJ0Q29udHJhY3QgZGVwbG95bWVudCB3aXRoXG4gICAgICogQHJldHVybnMgVGhlIGhleC1lbmNvZGVkIHNpZ25lZCBwYXlsb2FkXG4gICAgICovXG4gICAgYXN5bmMgc2lnbihrZXkpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNFeHRlcm5hbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzaWduIGFuIGV4dGVybmFsIFNtYXJ0Q29udHJhY3RcIik7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFRyYW5zYWN0aW9uKCkuc2lnbihrZXkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgYSBzbWFydCBjb250cmFjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgdG8gdXBkYXRlIGEgc21hcnQgY29udHJhY3QuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuYWJpIC0gVGhlIG5ldyBBQkkgb2YgdGhlIGNvbnRyYWN0LlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmNvbnRyYWN0TmFtZSAtIFRoZSBuZXcgY29udHJhY3QgbmFtZS5cbiAgICAgKiBAcmV0dXJucyBUaGUgc21hcnQgY29udHJhY3QuXG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlKHsgYWJpLCBjb250cmFjdE5hbWUgfSkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNvaW5iYXNlXzEuQ29pbmJhc2UuYXBpQ2xpZW50cy5zbWFydENvbnRyYWN0LnVwZGF0ZVNtYXJ0Q29udHJhY3QodGhpcy5nZXROZXR3b3JrSWQoKSwgdGhpcy5nZXRDb250cmFjdEFkZHJlc3MoKSwge1xuICAgICAgICAgICAgYWJpOiBKU09OLnN0cmluZ2lmeShhYmkpLFxuICAgICAgICAgICAgY29udHJhY3RfbmFtZTogY29udHJhY3ROYW1lLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFNtYXJ0Q29udHJhY3QuZnJvbU1vZGVsKHJlc3BvbnNlLmRhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCcm9hZGNhc3RzIHRoZSBTbWFydENvbnRyYWN0IGRlcGxveW1lbnQgdG8gdGhlIE5ldHdvcmsuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgU21hcnRDb250cmFjdCBvYmplY3RcbiAgICAgKiBAdGhyb3dzIHtBUElFcnJvcn0gaWYgdGhlIEFQSSByZXF1ZXN0IHRvIGJyb2FkY2FzdCBhIFNtYXJ0Q29udHJhY3QgZGVwbG95bWVudCBmYWlscy5cbiAgICAgKi9cbiAgICBhc3luYyBicm9hZGNhc3QoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRXh0ZXJuYWwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgYnJvYWRjYXN0IGFuIGV4dGVybmFsIFNtYXJ0Q29udHJhY3RcIik7XG4gICAgICAgIGlmICghdGhpcy5nZXRUcmFuc2FjdGlvbigpLmlzU2lnbmVkKCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgYnJvYWRjYXN0IHVuc2lnbmVkIFNtYXJ0Q29udHJhY3QgZGVwbG95bWVudFwiKTtcbiAgICAgICAgY29uc3QgZGVwbG95U21hcnRDb250cmFjdFJlcXVlc3QgPSB7XG4gICAgICAgICAgICBzaWduZWRfcGF5bG9hZDogdGhpcy5nZXRUcmFuc2FjdGlvbigpLmdldFNpZ25hdHVyZSgpLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNvaW5iYXNlXzEuQ29pbmJhc2UuYXBpQ2xpZW50cy5zbWFydENvbnRyYWN0LmRlcGxveVNtYXJ0Q29udHJhY3QodGhpcy5nZXRXYWxsZXRJZCgpLCB0aGlzLmdldERlcGxveWVyQWRkcmVzcygpLCB0aGlzLmdldElkKCksIGRlcGxveVNtYXJ0Q29udHJhY3RSZXF1ZXN0KTtcbiAgICAgICAgcmV0dXJuIFNtYXJ0Q29udHJhY3QuZnJvbU1vZGVsKHJlc3BvbnNlLmRhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXYWl0cyBmb3IgdGhlIFNtYXJ0Q29udHJhY3QgZGVwbG95bWVudCB0byBiZSBjb25maXJtZWQgb24gdGhlIE5ldHdvcmsgb3IgZmFpbCBvbiBjaGFpbi5cbiAgICAgKiBXYWl0cyB1bnRpbCB0aGUgU21hcnRDb250cmFjdCBkZXBsb3ltZW50IGlzIGNvbXBsZXRlZCBvciBmYWlsZWQgb24tY2hhaW4gYnkgcG9sbGluZyBhdCB0aGUgZ2l2ZW4gaW50ZXJ2YWwuXG4gICAgICogUmFpc2VzIGFuIGVycm9yIGlmIHRoZSBTbWFydENvbnRyYWN0IGRlcGxveW1lbnQgdGFrZXMgbG9uZ2VyIHRoYW4gdGhlIGdpdmVuIHRpbWVvdXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIHRvIGNvbmZpZ3VyZSB0aGUgd2FpdCBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5pbnRlcnZhbFNlY29uZHMgLSBUaGUgaW50ZXJ2YWwgdG8gY2hlY2sgdGhlIHN0YXR1cyBvZiB0aGUgU21hcnRDb250cmFjdCBkZXBsb3ltZW50LlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnRpbWVvdXRTZWNvbmRzIC0gVGhlIG1heGltdW0gdGltZSB0byB3YWl0IGZvciB0aGUgU21hcnRDb250cmFjdCBkZXBsb3ltZW50IHRvIGJlIGNvbmZpcm1lZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBTbWFydENvbnRyYWN0IG9iamVjdCBpbiBhIHRlcm1pbmFsIHN0YXRlLlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBpZiB0aGUgU21hcnRDb250cmFjdCBkZXBsb3ltZW50IHRpbWVzIG91dC5cbiAgICAgKi9cbiAgICBhc3luYyB3YWl0KHsgaW50ZXJ2YWxTZWNvbmRzID0gMC4yLCB0aW1lb3V0U2Vjb25kcyA9IDEwIH0gPSB7fSkge1xuICAgICAgICBpZiAodGhpcy5pc0V4dGVybmFsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHdhaXQgZm9yIGFuIGV4dGVybmFsIFNtYXJ0Q29udHJhY3RcIik7XG4gICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIHdoaWxlIChEYXRlLm5vdygpIC0gc3RhcnRUaW1lIDwgdGltZW91dFNlY29uZHMgKiAxMDAwKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnJlbG9hZCgpO1xuICAgICAgICAgICAgLy8gSWYgdGhlIFNtYXJ0Q29udHJhY3QgZGVwbG95bWVudCBpcyBpbiBhIHRlcm1pbmFsIHN0YXRlLCByZXR1cm4gdGhlIFNtYXJ0Q29udHJhY3QuXG4gICAgICAgICAgICBjb25zdCBzdGF0dXMgPSB0aGlzLmdldFRyYW5zYWN0aW9uKCkuZ2V0U3RhdHVzKCk7XG4gICAgICAgICAgICBpZiAoc3RhdHVzID09PSB0eXBlc18xLlRyYW5zYWN0aW9uU3RhdHVzLkNPTVBMRVRFIHx8IHN0YXR1cyA9PT0gdHlwZXNfMS5UcmFuc2FjdGlvblN0YXR1cy5GQUlMRUQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0ICgwLCB1dGlsc18xLmRlbGF5KShpbnRlcnZhbFNlY29uZHMpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5UaW1lb3V0RXJyb3IoXCJTbWFydENvbnRyYWN0IGRlcGxveW1lbnQgdGltZWQgb3V0XCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWxvYWRzIHRoZSBTbWFydENvbnRyYWN0IG1vZGVsIHdpdGggdGhlIGxhdGVzdCBkYXRhIGZyb20gdGhlIHNlcnZlci5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0FQSUVycm9yfSBpZiB0aGUgQVBJIHJlcXVlc3QgdG8gZ2V0IGEgU21hcnRDb250cmFjdCBmYWlscy5cbiAgICAgKi9cbiAgICBhc3luYyByZWxvYWQoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRXh0ZXJuYWwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcmVsb2FkIGFuIGV4dGVybmFsIFNtYXJ0Q29udHJhY3RcIik7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNvaW5iYXNlXzEuQ29pbmJhc2UuYXBpQ2xpZW50cy5zbWFydENvbnRyYWN0LmdldFNtYXJ0Q29udHJhY3QodGhpcy5nZXRXYWxsZXRJZCgpLCB0aGlzLmdldERlcGxveWVyQWRkcmVzcygpLCB0aGlzLmdldElkKCkpO1xuICAgICAgICB0aGlzLm1vZGVsID0gcmVzdWx0Py5kYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBTbWFydENvbnRyYWN0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgU21hcnRDb250cmFjdC5cbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIChgU21hcnRDb250cmFjdHtpZDogJyR7dGhpcy5nZXRJZCgpfScsIG5ldHdvcmtJZDogJyR7dGhpcy5nZXROZXR3b3JrSWQoKX0nLCBgICtcbiAgICAgICAgICAgIGBjb250cmFjdEFkZHJlc3M6ICcke3RoaXMuZ2V0Q29udHJhY3RBZGRyZXNzKCl9JywgZGVwbG95ZXJBZGRyZXNzOiAnJHt0aGlzLmdldERlcGxveWVyQWRkcmVzcygpfScsIGAgK1xuICAgICAgICAgICAgYHR5cGU6ICcke3RoaXMuZ2V0VHlwZSgpfSd9YCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFR5cGUgZ3VhcmQgZm9yIGNoZWNraW5nIGlmIHRoZSBzbWFydCBjb250cmFjdCBpcyBhbiBFUkMyMC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0eXBlIC0gVGhlIHR5cGUgb2YgdGhlIHNtYXJ0IGNvbnRyYWN0LlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgb2YgdGhlIHNtYXJ0IGNvbnRyYWN0LlxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIHNtYXJ0IGNvbnRyYWN0IGlzIGFuIEVSQzIwLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgaXNFUkMyMCh0eXBlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0eXBlID09PSB0eXBlc18xLlNtYXJ0Q29udHJhY3RUeXBlLkVSQzIwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUeXBlIGd1YXJkIGZvciBjaGVja2luZyBpZiB0aGUgc21hcnQgY29udHJhY3QgaXMgYW4gRVJDNzIxLlxuICAgICAqXG4gICAgICogQHBhcmFtIHR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgc21hcnQgY29udHJhY3QuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBvZiB0aGUgc21hcnQgY29udHJhY3QuXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgc21hcnQgY29udHJhY3QgaXMgYW4gRVJDNzIxLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgaXNFUkM3MjEodHlwZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdHlwZSA9PT0gdHlwZXNfMS5TbWFydENvbnRyYWN0VHlwZS5FUkM3MjE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFR5cGUgZ3VhcmQgZm9yIGNoZWNraW5nIGlmIHRoZSBzbWFydCBjb250cmFjdCBpcyBhbiBFUkMxMTU1LlxuICAgICAqXG4gICAgICogQHBhcmFtIHR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgc21hcnQgY29udHJhY3QuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBvZiB0aGUgc21hcnQgY29udHJhY3QuXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgc21hcnQgY29udHJhY3QgaXMgYW4gRVJDMTE1NSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGlzRVJDMTE1NSh0eXBlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0eXBlID09PSB0eXBlc18xLlNtYXJ0Q29udHJhY3RUeXBlLkVSQzExNTU7XG4gICAgfVxufVxuZXhwb3J0cy5TbWFydENvbnRyYWN0ID0gU21hcnRDb250cmFjdDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/smart_contract.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/sponsored_send.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/sponsored_send.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SponsoredSend = void 0;\nconst ethers_1 = __webpack_require__(/*! ethers */ \"(rsc)/./node_modules/ethers/lib.commonjs/index.js\");\nconst types_1 = __webpack_require__(/*! ./types */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/types.js\");\n/**\n * A representation of an onchain Sponsored Send.\n */\nclass SponsoredSend {\n    /**\n     * Sponsored Sends should be constructed via higher level abstractions like Transfer.\n     *\n     * @class\n     * @param model - The underlying Sponsored Send object.\n     */\n    constructor(model) {\n        if (!model) {\n            throw new Error(\"Invalid model type\");\n        }\n        this.model = model;\n    }\n    /**\n     * Returns the Keccak256 hash of the typed data. This payload must be signed\n     * by the sender to be used as an approval in the EIP-3009 transaction.\n     *\n     * @returns The Keccak256 hash of the typed data.\n     */\n    getTypedDataHash() {\n        return this.model.typed_data_hash;\n    }\n    /**\n     * Returns the signature of the typed data.\n     *\n     * @returns The hash of the typed data signature.\n     */\n    getSignature() {\n        return this.model.signature;\n    }\n    /**\n     * Signs the Sponsored Send with the provided key and returns the hex signature.\n     *\n     * @param key - The key to sign the Sponsored Send with\n     * @returns The hex-encoded signature\n     */\n    async sign(key) {\n        ethers_1.ethers.toBeArray;\n        const signature = key.signingKey.sign(ethers_1.ethers.getBytes(this.getTypedDataHash())).serialized;\n        this.model.signature = signature;\n        return signature;\n    }\n    /**\n     * Returns whether the Sponsored Send has been signed.\n     *\n     * @returns if the Sponsored Send has been signed.\n     */\n    isSigned() {\n        return !!this.getSignature();\n    }\n    /**\n     * Returns the Status of the Sponsored Send.\n     *\n     * @returns the Status of the Sponsored Send\n     */\n    getStatus() {\n        switch (this.model.status) {\n            case types_1.SponsoredSendStatus.PENDING:\n                return types_1.SponsoredSendStatus.PENDING;\n            case types_1.SponsoredSendStatus.SIGNED:\n                return types_1.SponsoredSendStatus.SIGNED;\n            case types_1.SponsoredSendStatus.SUBMITTED:\n                return types_1.SponsoredSendStatus.SUBMITTED;\n            case types_1.SponsoredSendStatus.COMPLETE:\n                return types_1.SponsoredSendStatus.COMPLETE;\n            case types_1.SponsoredSendStatus.FAILED:\n                return types_1.SponsoredSendStatus.FAILED;\n            default:\n                undefined;\n        }\n    }\n    /**\n     * Returns whether the Sponsored Send is in a terminal State.\n     *\n     * @returns Whether the Sponsored Send is in a terminal State\n     */\n    isTerminalState() {\n        const status = this.getStatus();\n        if (!status)\n            return false;\n        return [types_1.SponsoredSendStatus.COMPLETE, types_1.SponsoredSendStatus.FAILED].includes(status);\n    }\n    /**\n     * Returns the Transaction Hash of the Sponsored Send.\n     *\n     * @returns The Transaction Hash\n     */\n    getTransactionHash() {\n        return this.model.transaction_hash;\n    }\n    /**\n     * Returns the link to the Sponsored Send on the blockchain explorer.\n     *\n     * @returns The link to the Sponsored Send on the blockchain explorer\n     */\n    getTransactionLink() {\n        return this.model.transaction_link;\n    }\n    /**\n     * Returns a string representation of the Sponsored Send.\n     *\n     * @returns A string representation of the Sponsored Send\n     */\n    toString() {\n        return `SponsoredSend { transactionHash: '${this.getTransactionHash()}', status: '${this.getStatus()}', typedDataHash: '${this.getTypedDataHash()}', signature: ${this.getSignature()}, transactionLink: ${this.getTransactionLink()} }`;\n    }\n}\nexports.SponsoredSend = SponsoredSend;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL3Nwb25zb3JlZF9zZW5kLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQjtBQUNyQixpQkFBaUIsbUJBQU8sQ0FBQyxpRUFBUTtBQUNqQyxnQkFBZ0IsbUJBQU8sQ0FBQyxtRkFBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLG9CQUFvQiwwQkFBMEIsY0FBYyxpQkFBaUIscUJBQXFCLHdCQUF3QixnQkFBZ0Isb0JBQW9CLHFCQUFxQiw0QkFBNEI7QUFDL087QUFDQTtBQUNBLHFCQUFxQiIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cnZpdmFsLWZ1bi8uL25vZGVfbW9kdWxlcy9AY29pbmJhc2UvY29pbmJhc2Utc2RrL2Rpc3QvY29pbmJhc2Uvc3BvbnNvcmVkX3NlbmQuanM/MzJlMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU3BvbnNvcmVkU2VuZCA9IHZvaWQgMDtcbmNvbnN0IGV0aGVyc18xID0gcmVxdWlyZShcImV0aGVyc1wiKTtcbmNvbnN0IHR5cGVzXzEgPSByZXF1aXJlKFwiLi90eXBlc1wiKTtcbi8qKlxuICogQSByZXByZXNlbnRhdGlvbiBvZiBhbiBvbmNoYWluIFNwb25zb3JlZCBTZW5kLlxuICovXG5jbGFzcyBTcG9uc29yZWRTZW5kIHtcbiAgICAvKipcbiAgICAgKiBTcG9uc29yZWQgU2VuZHMgc2hvdWxkIGJlIGNvbnN0cnVjdGVkIHZpYSBoaWdoZXIgbGV2ZWwgYWJzdHJhY3Rpb25zIGxpa2UgVHJhbnNmZXIuXG4gICAgICpcbiAgICAgKiBAY2xhc3NcbiAgICAgKiBAcGFyYW0gbW9kZWwgLSBUaGUgdW5kZXJseWluZyBTcG9uc29yZWQgU2VuZCBvYmplY3QuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobW9kZWwpIHtcbiAgICAgICAgaWYgKCFtb2RlbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBtb2RlbCB0eXBlXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW9kZWwgPSBtb2RlbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgS2VjY2FrMjU2IGhhc2ggb2YgdGhlIHR5cGVkIGRhdGEuIFRoaXMgcGF5bG9hZCBtdXN0IGJlIHNpZ25lZFxuICAgICAqIGJ5IHRoZSBzZW5kZXIgdG8gYmUgdXNlZCBhcyBhbiBhcHByb3ZhbCBpbiB0aGUgRUlQLTMwMDkgdHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgS2VjY2FrMjU2IGhhc2ggb2YgdGhlIHR5cGVkIGRhdGEuXG4gICAgICovXG4gICAgZ2V0VHlwZWREYXRhSGFzaCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwudHlwZWRfZGF0YV9oYXNoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzaWduYXR1cmUgb2YgdGhlIHR5cGVkIGRhdGEuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgaGFzaCBvZiB0aGUgdHlwZWQgZGF0YSBzaWduYXR1cmUuXG4gICAgICovXG4gICAgZ2V0U2lnbmF0dXJlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5zaWduYXR1cmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNpZ25zIHRoZSBTcG9uc29yZWQgU2VuZCB3aXRoIHRoZSBwcm92aWRlZCBrZXkgYW5kIHJldHVybnMgdGhlIGhleCBzaWduYXR1cmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ga2V5IC0gVGhlIGtleSB0byBzaWduIHRoZSBTcG9uc29yZWQgU2VuZCB3aXRoXG4gICAgICogQHJldHVybnMgVGhlIGhleC1lbmNvZGVkIHNpZ25hdHVyZVxuICAgICAqL1xuICAgIGFzeW5jIHNpZ24oa2V5KSB7XG4gICAgICAgIGV0aGVyc18xLmV0aGVycy50b0JlQXJyYXk7XG4gICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGtleS5zaWduaW5nS2V5LnNpZ24oZXRoZXJzXzEuZXRoZXJzLmdldEJ5dGVzKHRoaXMuZ2V0VHlwZWREYXRhSGFzaCgpKSkuc2VyaWFsaXplZDtcbiAgICAgICAgdGhpcy5tb2RlbC5zaWduYXR1cmUgPSBzaWduYXR1cmU7XG4gICAgICAgIHJldHVybiBzaWduYXR1cmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgU3BvbnNvcmVkIFNlbmQgaGFzIGJlZW4gc2lnbmVkLlxuICAgICAqXG4gICAgICogQHJldHVybnMgaWYgdGhlIFNwb25zb3JlZCBTZW5kIGhhcyBiZWVuIHNpZ25lZC5cbiAgICAgKi9cbiAgICBpc1NpZ25lZCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5nZXRTaWduYXR1cmUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgU3RhdHVzIG9mIHRoZSBTcG9uc29yZWQgU2VuZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHRoZSBTdGF0dXMgb2YgdGhlIFNwb25zb3JlZCBTZW5kXG4gICAgICovXG4gICAgZ2V0U3RhdHVzKCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMubW9kZWwuc3RhdHVzKSB7XG4gICAgICAgICAgICBjYXNlIHR5cGVzXzEuU3BvbnNvcmVkU2VuZFN0YXR1cy5QRU5ESU5HOlxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlc18xLlNwb25zb3JlZFNlbmRTdGF0dXMuUEVORElORztcbiAgICAgICAgICAgIGNhc2UgdHlwZXNfMS5TcG9uc29yZWRTZW5kU3RhdHVzLlNJR05FRDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZXNfMS5TcG9uc29yZWRTZW5kU3RhdHVzLlNJR05FRDtcbiAgICAgICAgICAgIGNhc2UgdHlwZXNfMS5TcG9uc29yZWRTZW5kU3RhdHVzLlNVQk1JVFRFRDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZXNfMS5TcG9uc29yZWRTZW5kU3RhdHVzLlNVQk1JVFRFRDtcbiAgICAgICAgICAgIGNhc2UgdHlwZXNfMS5TcG9uc29yZWRTZW5kU3RhdHVzLkNPTVBMRVRFOlxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlc18xLlNwb25zb3JlZFNlbmRTdGF0dXMuQ09NUExFVEU7XG4gICAgICAgICAgICBjYXNlIHR5cGVzXzEuU3BvbnNvcmVkU2VuZFN0YXR1cy5GQUlMRUQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVzXzEuU3BvbnNvcmVkU2VuZFN0YXR1cy5GQUlMRUQ7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIFNwb25zb3JlZCBTZW5kIGlzIGluIGEgdGVybWluYWwgU3RhdGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBTcG9uc29yZWQgU2VuZCBpcyBpbiBhIHRlcm1pbmFsIFN0YXRlXG4gICAgICovXG4gICAgaXNUZXJtaW5hbFN0YXRlKCkge1xuICAgICAgICBjb25zdCBzdGF0dXMgPSB0aGlzLmdldFN0YXR1cygpO1xuICAgICAgICBpZiAoIXN0YXR1cylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIFt0eXBlc18xLlNwb25zb3JlZFNlbmRTdGF0dXMuQ09NUExFVEUsIHR5cGVzXzEuU3BvbnNvcmVkU2VuZFN0YXR1cy5GQUlMRURdLmluY2x1ZGVzKHN0YXR1cyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIFRyYW5zYWN0aW9uIEhhc2ggb2YgdGhlIFNwb25zb3JlZCBTZW5kLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIFRyYW5zYWN0aW9uIEhhc2hcbiAgICAgKi9cbiAgICBnZXRUcmFuc2FjdGlvbkhhc2goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLnRyYW5zYWN0aW9uX2hhc2g7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxpbmsgdG8gdGhlIFNwb25zb3JlZCBTZW5kIG9uIHRoZSBibG9ja2NoYWluIGV4cGxvcmVyLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGxpbmsgdG8gdGhlIFNwb25zb3JlZCBTZW5kIG9uIHRoZSBibG9ja2NoYWluIGV4cGxvcmVyXG4gICAgICovXG4gICAgZ2V0VHJhbnNhY3Rpb25MaW5rKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC50cmFuc2FjdGlvbl9saW5rO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBTcG9uc29yZWQgU2VuZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBTcG9uc29yZWQgU2VuZFxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gYFNwb25zb3JlZFNlbmQgeyB0cmFuc2FjdGlvbkhhc2g6ICcke3RoaXMuZ2V0VHJhbnNhY3Rpb25IYXNoKCl9Jywgc3RhdHVzOiAnJHt0aGlzLmdldFN0YXR1cygpfScsIHR5cGVkRGF0YUhhc2g6ICcke3RoaXMuZ2V0VHlwZWREYXRhSGFzaCgpfScsIHNpZ25hdHVyZTogJHt0aGlzLmdldFNpZ25hdHVyZSgpfSwgdHJhbnNhY3Rpb25MaW5rOiAke3RoaXMuZ2V0VHJhbnNhY3Rpb25MaW5rKCl9IH1gO1xuICAgIH1cbn1cbmV4cG9ydHMuU3BvbnNvcmVkU2VuZCA9IFNwb25zb3JlZFNlbmQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/sponsored_send.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/staking_balance.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/staking_balance.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.StakingBalance = void 0;\nconst balance_1 = __webpack_require__(/*! ./balance */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/balance.js\");\nconst coinbase_1 = __webpack_require__(/*! ./coinbase */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/coinbase.js\");\n/**\n * A representation of the staking balance for a given asset on a specific date.\n */\nclass StakingBalance {\n    /**\n     * Creates the StakingBalance object.\n     *\n     * @param model - The underlying staking balance object.\n     */\n    constructor(model) {\n        this.model = model;\n    }\n    /**\n     * Returns a list of StakingBalances for the provided network, asset, and address.\n     *\n     * @param networkId - The network ID.\n     * @param assetId - The asset ID.\n     * @param addressId - The address ID.\n     * @param startTime - The start time.\n     * @param endTime - The end time.\n     * @returns The staking balances.\n     */\n    static async list(networkId, assetId, addressId, startTime, endTime) {\n        const stakingBalances = [];\n        const queue = [\"\"];\n        while (queue.length > 0) {\n            const page = queue.shift();\n            const response = await coinbase_1.Coinbase.apiClients.stake.fetchHistoricalStakingBalances(networkId, assetId, addressId, startTime, endTime, 100, page?.length ? page : undefined);\n            response.data.data.forEach(stakingBalance => {\n                stakingBalances.push(new StakingBalance(stakingBalance));\n            });\n            if (response.data.has_more) {\n                if (response.data.next_page) {\n                    queue.push(response.data.next_page);\n                }\n            }\n        }\n        return stakingBalances;\n    }\n    /**\n     * Returns the bonded stake amount of the StakingBalance.\n     *\n     * @returns The Balance.\n     */\n    bondedStake() {\n        return balance_1.Balance.fromModel(this.model.bonded_stake);\n    }\n    /**\n     * Returns the unbonded stake amount of the StakingBalance.\n     *\n     * @returns The Balance.\n     */\n    unbondedBalance() {\n        return balance_1.Balance.fromModel(this.model.unbonded_balance);\n    }\n    /**\n     * Returns the participant type of the address.\n     *\n     * @returns The participant type.\n     */\n    participantType() {\n        return this.model.participant_type;\n    }\n    /**\n     * Returns the date of the StakingBalance.\n     *\n     * @returns The date.\n     */\n    date() {\n        return new Date(this.model.date);\n    }\n    /**\n     * Returns the onchain address of the StakingBalance.\n     *\n     * @returns The onchain address.\n     */\n    address() {\n        return this.model.address;\n    }\n    /**\n     * Print the Staking Balance as a string.\n     *\n     * @returns The string representation of the Staking Balance.\n     */\n    toString() {\n        return `StakingBalance { date: '${this.date().toISOString()}' address: '${this.address()}' bondedStake: '${this.bondedStake().amount} ${this.bondedStake().asset?.assetId?.toUpperCase()}' unbondedBalance: '${this.unbondedBalance().amount} ${this.unbondedBalance().asset?.assetId?.toUpperCase()}' participantType: '${this.participantType()}' }`;\n    }\n}\nexports.StakingBalance = StakingBalance;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL3N0YWtpbmdfYmFsYW5jZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQkFBc0I7QUFDdEIsa0JBQWtCLG1CQUFPLENBQUMsdUZBQVc7QUFDckMsbUJBQW1CLG1CQUFPLENBQUMseUZBQVk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxTQUFTLDBCQUEwQixjQUFjLGVBQWUsa0JBQWtCLDJCQUEyQixFQUFFLGlEQUFpRCxzQkFBc0IsK0JBQStCLEVBQUUscURBQXFELHNCQUFzQix1QkFBdUIsR0FBRztBQUM3VjtBQUNBO0FBQ0Esc0JBQXNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3Vydml2YWwtZnVuLy4vbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9jb2luYmFzZS1zZGsvZGlzdC9jb2luYmFzZS9zdGFraW5nX2JhbGFuY2UuanM/YmUwNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU3Rha2luZ0JhbGFuY2UgPSB2b2lkIDA7XG5jb25zdCBiYWxhbmNlXzEgPSByZXF1aXJlKFwiLi9iYWxhbmNlXCIpO1xuY29uc3QgY29pbmJhc2VfMSA9IHJlcXVpcmUoXCIuL2NvaW5iYXNlXCIpO1xuLyoqXG4gKiBBIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBzdGFraW5nIGJhbGFuY2UgZm9yIGEgZ2l2ZW4gYXNzZXQgb24gYSBzcGVjaWZpYyBkYXRlLlxuICovXG5jbGFzcyBTdGFraW5nQmFsYW5jZSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0aGUgU3Rha2luZ0JhbGFuY2Ugb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIG1vZGVsIC0gVGhlIHVuZGVybHlpbmcgc3Rha2luZyBiYWxhbmNlIG9iamVjdC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihtb2RlbCkge1xuICAgICAgICB0aGlzLm1vZGVsID0gbW9kZWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBsaXN0IG9mIFN0YWtpbmdCYWxhbmNlcyBmb3IgdGhlIHByb3ZpZGVkIG5ldHdvcmssIGFzc2V0LCBhbmQgYWRkcmVzcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuZXR3b3JrSWQgLSBUaGUgbmV0d29yayBJRC5cbiAgICAgKiBAcGFyYW0gYXNzZXRJZCAtIFRoZSBhc3NldCBJRC5cbiAgICAgKiBAcGFyYW0gYWRkcmVzc0lkIC0gVGhlIGFkZHJlc3MgSUQuXG4gICAgICogQHBhcmFtIHN0YXJ0VGltZSAtIFRoZSBzdGFydCB0aW1lLlxuICAgICAqIEBwYXJhbSBlbmRUaW1lIC0gVGhlIGVuZCB0aW1lLlxuICAgICAqIEByZXR1cm5zIFRoZSBzdGFraW5nIGJhbGFuY2VzLlxuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyBsaXN0KG5ldHdvcmtJZCwgYXNzZXRJZCwgYWRkcmVzc0lkLCBzdGFydFRpbWUsIGVuZFRpbWUpIHtcbiAgICAgICAgY29uc3Qgc3Rha2luZ0JhbGFuY2VzID0gW107XG4gICAgICAgIGNvbnN0IHF1ZXVlID0gW1wiXCJdO1xuICAgICAgICB3aGlsZSAocXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgcGFnZSA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNvaW5iYXNlXzEuQ29pbmJhc2UuYXBpQ2xpZW50cy5zdGFrZS5mZXRjaEhpc3RvcmljYWxTdGFraW5nQmFsYW5jZXMobmV0d29ya0lkLCBhc3NldElkLCBhZGRyZXNzSWQsIHN0YXJ0VGltZSwgZW5kVGltZSwgMTAwLCBwYWdlPy5sZW5ndGggPyBwYWdlIDogdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIHJlc3BvbnNlLmRhdGEuZGF0YS5mb3JFYWNoKHN0YWtpbmdCYWxhbmNlID0+IHtcbiAgICAgICAgICAgICAgICBzdGFraW5nQmFsYW5jZXMucHVzaChuZXcgU3Rha2luZ0JhbGFuY2Uoc3Rha2luZ0JhbGFuY2UpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLmRhdGEuaGFzX21vcmUpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UuZGF0YS5uZXh0X3BhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcXVldWUucHVzaChyZXNwb25zZS5kYXRhLm5leHRfcGFnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGFraW5nQmFsYW5jZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGJvbmRlZCBzdGFrZSBhbW91bnQgb2YgdGhlIFN0YWtpbmdCYWxhbmNlLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIEJhbGFuY2UuXG4gICAgICovXG4gICAgYm9uZGVkU3Rha2UoKSB7XG4gICAgICAgIHJldHVybiBiYWxhbmNlXzEuQmFsYW5jZS5mcm9tTW9kZWwodGhpcy5tb2RlbC5ib25kZWRfc3Rha2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB1bmJvbmRlZCBzdGFrZSBhbW91bnQgb2YgdGhlIFN0YWtpbmdCYWxhbmNlLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIEJhbGFuY2UuXG4gICAgICovXG4gICAgdW5ib25kZWRCYWxhbmNlKCkge1xuICAgICAgICByZXR1cm4gYmFsYW5jZV8xLkJhbGFuY2UuZnJvbU1vZGVsKHRoaXMubW9kZWwudW5ib25kZWRfYmFsYW5jZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHBhcnRpY2lwYW50IHR5cGUgb2YgdGhlIGFkZHJlc3MuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgcGFydGljaXBhbnQgdHlwZS5cbiAgICAgKi9cbiAgICBwYXJ0aWNpcGFudFR5cGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLnBhcnRpY2lwYW50X3R5cGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGRhdGUgb2YgdGhlIFN0YWtpbmdCYWxhbmNlLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGRhdGUuXG4gICAgICovXG4gICAgZGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMubW9kZWwuZGF0ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG9uY2hhaW4gYWRkcmVzcyBvZiB0aGUgU3Rha2luZ0JhbGFuY2UuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgb25jaGFpbiBhZGRyZXNzLlxuICAgICAqL1xuICAgIGFkZHJlc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLmFkZHJlc3M7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByaW50IHRoZSBTdGFraW5nIEJhbGFuY2UgYXMgYSBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBTdGFraW5nIEJhbGFuY2UuXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBgU3Rha2luZ0JhbGFuY2UgeyBkYXRlOiAnJHt0aGlzLmRhdGUoKS50b0lTT1N0cmluZygpfScgYWRkcmVzczogJyR7dGhpcy5hZGRyZXNzKCl9JyBib25kZWRTdGFrZTogJyR7dGhpcy5ib25kZWRTdGFrZSgpLmFtb3VudH0gJHt0aGlzLmJvbmRlZFN0YWtlKCkuYXNzZXQ/LmFzc2V0SWQ/LnRvVXBwZXJDYXNlKCl9JyB1bmJvbmRlZEJhbGFuY2U6ICcke3RoaXMudW5ib25kZWRCYWxhbmNlKCkuYW1vdW50fSAke3RoaXMudW5ib25kZWRCYWxhbmNlKCkuYXNzZXQ/LmFzc2V0SWQ/LnRvVXBwZXJDYXNlKCl9JyBwYXJ0aWNpcGFudFR5cGU6ICcke3RoaXMucGFydGljaXBhbnRUeXBlKCl9JyB9YDtcbiAgICB9XG59XG5leHBvcnRzLlN0YWtpbmdCYWxhbmNlID0gU3Rha2luZ0JhbGFuY2U7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/staking_balance.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/staking_operation.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/staking_operation.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.StakingOperation = void 0;\nconst api_1 = __webpack_require__(/*! ../client/api */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/client/api.js\");\nconst transaction_1 = __webpack_require__(/*! ./transaction */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/transaction.js\");\nconst coinbase_1 = __webpack_require__(/*! ./coinbase */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/coinbase.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/utils.js\");\n/**\n * A representation of a staking operation (stake, unstake, claim stake, etc.). It\n * may have multiple steps with some being transactions to sign, and others to wait.\n */\nclass StakingOperation {\n    /**\n     * Creates a StakingOperation object.\n     *\n     * @class\n     * @param model - The staking operation response from the API call.\n     */\n    constructor(model) {\n        if (!model) {\n            throw new Error(\"Invalid model type\");\n        }\n        this.model = model;\n        this.transactions = [];\n        this.loadTransactionsFromModel();\n    }\n    /**\n     * Get the staking operation for the given ID.\n     *\n     * @param networkId - The network ID.\n     * @param addressId - The address ID.\n     * @param id - The staking operation ID.\n     * @param walletId - The wallet ID of the staking operation.\n     * @throws {Error} If the wallet id is defined but empty.\n     *\n     * @returns The staking operation object.\n     */\n    static async fetch(networkId, addressId, id, walletId) {\n        if (walletId === undefined) {\n            const result = await coinbase_1.Coinbase.apiClients.stake.getExternalStakingOperation(networkId, addressId, id);\n            return new StakingOperation(result.data);\n        }\n        else if (walletId != undefined && walletId != \"\") {\n            const result = await coinbase_1.Coinbase.apiClients.walletStake.getStakingOperation(walletId, addressId, id);\n            return new StakingOperation(result.data);\n        }\n        else {\n            throw new Error(\"Invalid wallet ID\");\n        }\n    }\n    /**\n     * Returns the Staking Operation ID.\n     *\n     * @returns The Staking Operation ID.\n     */\n    getID() {\n        return this.model.id;\n    }\n    /**\n     * Get the status of the staking operation.\n     *\n     * @returns The status of the staking operation.\n     */\n    getStatus() {\n        return this.model.status;\n    }\n    /**\n     * Returns the Wallet ID if it exists.\n     *\n     * @returns The Wallet ID.\n     */\n    getWalletID() {\n        return this.model.wallet_id;\n    }\n    /**\n     * Returns the Address ID.\n     *\n     * @returns The Address ID.\n     */\n    getAddressID() {\n        return this.model.address_id;\n    }\n    /**\n     * Returns the Network ID.\n     *\n     * @returns The Network ID.\n     */\n    getNetworkID() {\n        return this.model.network_id;\n    }\n    /**\n     * Return a human-readable string representation of the StakingOperation object.\n     *\n     * @returns The string representation of the StakingOperation object.\n     */\n    toString() {\n        return `StakingOperation { id: ${this.getID()} status: ${this.getStatus()} network_id: ${this.getNetworkID()} address_id: ${this.getAddressID()} }`;\n    }\n    /**\n     * Returns whether the Staking operation is in a terminal State.\n     *\n     * @returns Whether the Staking operation is in a terminal State\n     */\n    isTerminalState() {\n        return this.isCompleteState() || this.isFailedState();\n    }\n    /**\n     * Returns whether the Staking operation is in a failed state.\n     *\n     * @returns Whether the Staking operation is in a failed state.\n     */\n    isFailedState() {\n        return this.getStatus() === api_1.StakingOperationStatusEnum.Failed;\n    }\n    /**\n     * Returns whether the Staking operation is in a complete state.\n     *\n     * @returns Whether the Staking operation is in a complete state.\n     */\n    isCompleteState() {\n        return this.getStatus() === api_1.StakingOperationStatusEnum.Complete;\n    }\n    /**\n     * Get the transactions associated with this staking operation.\n     *\n     * @returns The array of transactions.\n     */\n    getTransactions() {\n        return this.transactions;\n    }\n    /**\n     * Get signed voluntary exit messages for native eth unstaking\n     *\n     * @returns The signed voluntary exit messages for a native eth unstaking operation.\n     */\n    getSignedVoluntaryExitMessages() {\n        const signedVoluntaryExitMessages = [];\n        if (this.model.metadata) {\n            this.model.metadata.forEach(metadata => {\n                const decodedSignedVoluntaryExitMessage = atob(metadata.signed_voluntary_exit);\n                signedVoluntaryExitMessages.push(decodedSignedVoluntaryExitMessage);\n            });\n        }\n        return signedVoluntaryExitMessages;\n    }\n    /**\n     * Reloads the StakingOperation model with the latest data from the server.\n     * If the StakingOperation object was created by an ExternalAddress then it will\n     * not have a wallet ID.\n     *\n     * @throws {APIError} if the API request to get the StakingOperation fails.\n     * @throws {Error} if this function is called on a StakingOperation without a wallet ID.\n     */\n    async reload() {\n        if (this.getWalletID() === undefined) {\n            const result = await coinbase_1.Coinbase.apiClients.stake.getExternalStakingOperation(this.getNetworkID(), this.getAddressID(), this.getID());\n            this.model = result.data;\n        }\n        else if (this.getWalletID() != undefined && this.getWalletID() != \"\") {\n            const result = await coinbase_1.Coinbase.apiClients.walletStake.getStakingOperation(this.getWalletID(), this.getAddressID(), this.getID());\n            this.model = result.data;\n        }\n        this.loadTransactionsFromModel();\n    }\n    /**\n     * Waits until the Staking Operation is completed or failed by polling its status at the given interval.\n     *\n     * @param options - The options to configure the wait function.\n     * @param options.intervalSeconds - The interval at which to poll, in seconds\n     * @param options.timeoutSeconds - The maximum amount of time to wait for the StakingOperation to complete, in seconds\n     * @throws {Error} If the StakingOperation takes longer than the given timeout.\n     * @returns The completed StakingOperation object.\n     */\n    async wait({ intervalSeconds = 5, timeoutSeconds = 3600, } = {}) {\n        if (this.getWalletID() != undefined) {\n            throw new Error(\"cannot wait on staking operation for wallet address.\");\n        }\n        const startTime = Date.now();\n        while (Date.now() - startTime < timeoutSeconds * 1000) {\n            await this.reload();\n            if (this.isTerminalState()) {\n                return this.model;\n            }\n            if (Date.now() - startTime > timeoutSeconds * 1000) {\n                throw new Error(\"Staking operation timed out\");\n            }\n            await (0, utils_1.delay)(intervalSeconds);\n        }\n        throw new Error(\"Staking operation timed out\");\n    }\n    /**\n     * Sign the transactions in the StakingOperation object.\n     *\n     * @param key - The key used to sign the transactions.\n     */\n    async sign(key) {\n        for (const tx of this.transactions) {\n            if (!tx.isSigned()) {\n                await tx.sign(key);\n            }\n        }\n    }\n    /**\n     * loadTransactionsFromModel loads new unsigned transactions from the model into the transactions array.\n     * Note: For External Address model since tx signing and broadcast status happens by the end user and not our backend\n     * we need to be careful to not overwrite the transactions array with the response from the API. Ex: End user could have used\n     * stakingOperation.sign() method to sign the transactions, and we should not overwrite them with the response from the API.\n     * This however is ok to do so for the Wallet Address model since the transactions states are maintained by our backend.\n     * This method attempts to be safe for both address models, and only adds newly created unsigned transactions that are not\n     *  already in the transactions array.\n     */\n    loadTransactionsFromModel() {\n        // Only overwrite the transactions if the response is populated.\n        if (this.model.transactions && this.model.transactions.length > 0) {\n            // Create a set of existing unsigned payloads to avoid duplicates.\n            const existingUnsignedPayloads = new Set(this.transactions.map(tx => tx.getUnsignedPayload()));\n            // Add transactions that are not already in the transactions array.\n            this.model.transactions.forEach(transaction => {\n                if (!existingUnsignedPayloads.has(transaction.unsigned_payload)) {\n                    this.transactions.push(new transaction_1.Transaction(transaction));\n                }\n            });\n        }\n    }\n}\nexports.StakingOperation = StakingOperation;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL3N0YWtpbmdfb3BlcmF0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHdCQUF3QjtBQUN4QixjQUFjLG1CQUFPLENBQUMscUZBQWU7QUFDckMsc0JBQXNCLG1CQUFPLENBQUMsK0ZBQWU7QUFDN0MsbUJBQW1CLG1CQUFPLENBQUMseUZBQVk7QUFDdkMsZ0JBQWdCLG1CQUFPLENBQUMsbUZBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsTUFBTSxjQUFjLFVBQVUsa0JBQWtCLGNBQWMscUJBQXFCLGNBQWMsc0JBQXNCO0FBQzFKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixVQUFVO0FBQzFCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQSxpQkFBaUIsOENBQThDLElBQUk7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXJ2aXZhbC1mdW4vLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL3N0YWtpbmdfb3BlcmF0aW9uLmpzPzhhOGIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlN0YWtpbmdPcGVyYXRpb24gPSB2b2lkIDA7XG5jb25zdCBhcGlfMSA9IHJlcXVpcmUoXCIuLi9jbGllbnQvYXBpXCIpO1xuY29uc3QgdHJhbnNhY3Rpb25fMSA9IHJlcXVpcmUoXCIuL3RyYW5zYWN0aW9uXCIpO1xuY29uc3QgY29pbmJhc2VfMSA9IHJlcXVpcmUoXCIuL2NvaW5iYXNlXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuLyoqXG4gKiBBIHJlcHJlc2VudGF0aW9uIG9mIGEgc3Rha2luZyBvcGVyYXRpb24gKHN0YWtlLCB1bnN0YWtlLCBjbGFpbSBzdGFrZSwgZXRjLikuIEl0XG4gKiBtYXkgaGF2ZSBtdWx0aXBsZSBzdGVwcyB3aXRoIHNvbWUgYmVpbmcgdHJhbnNhY3Rpb25zIHRvIHNpZ24sIGFuZCBvdGhlcnMgdG8gd2FpdC5cbiAqL1xuY2xhc3MgU3Rha2luZ09wZXJhdGlvbiB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIFN0YWtpbmdPcGVyYXRpb24gb2JqZWN0LlxuICAgICAqXG4gICAgICogQGNsYXNzXG4gICAgICogQHBhcmFtIG1vZGVsIC0gVGhlIHN0YWtpbmcgb3BlcmF0aW9uIHJlc3BvbnNlIGZyb20gdGhlIEFQSSBjYWxsLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG1vZGVsKSB7XG4gICAgICAgIGlmICghbW9kZWwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbW9kZWwgdHlwZVwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1vZGVsID0gbW9kZWw7XG4gICAgICAgIHRoaXMudHJhbnNhY3Rpb25zID0gW107XG4gICAgICAgIHRoaXMubG9hZFRyYW5zYWN0aW9uc0Zyb21Nb2RlbCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHN0YWtpbmcgb3BlcmF0aW9uIGZvciB0aGUgZ2l2ZW4gSUQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmV0d29ya0lkIC0gVGhlIG5ldHdvcmsgSUQuXG4gICAgICogQHBhcmFtIGFkZHJlc3NJZCAtIFRoZSBhZGRyZXNzIElELlxuICAgICAqIEBwYXJhbSBpZCAtIFRoZSBzdGFraW5nIG9wZXJhdGlvbiBJRC5cbiAgICAgKiBAcGFyYW0gd2FsbGV0SWQgLSBUaGUgd2FsbGV0IElEIG9mIHRoZSBzdGFraW5nIG9wZXJhdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHdhbGxldCBpZCBpcyBkZWZpbmVkIGJ1dCBlbXB0eS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBzdGFraW5nIG9wZXJhdGlvbiBvYmplY3QuXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIGZldGNoKG5ldHdvcmtJZCwgYWRkcmVzc0lkLCBpZCwgd2FsbGV0SWQpIHtcbiAgICAgICAgaWYgKHdhbGxldElkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNvaW5iYXNlXzEuQ29pbmJhc2UuYXBpQ2xpZW50cy5zdGFrZS5nZXRFeHRlcm5hbFN0YWtpbmdPcGVyYXRpb24obmV0d29ya0lkLCBhZGRyZXNzSWQsIGlkKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU3Rha2luZ09wZXJhdGlvbihyZXN1bHQuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAod2FsbGV0SWQgIT0gdW5kZWZpbmVkICYmIHdhbGxldElkICE9IFwiXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNvaW5iYXNlXzEuQ29pbmJhc2UuYXBpQ2xpZW50cy53YWxsZXRTdGFrZS5nZXRTdGFraW5nT3BlcmF0aW9uKHdhbGxldElkLCBhZGRyZXNzSWQsIGlkKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU3Rha2luZ09wZXJhdGlvbihyZXN1bHQuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHdhbGxldCBJRFwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBTdGFraW5nIE9wZXJhdGlvbiBJRC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBTdGFraW5nIE9wZXJhdGlvbiBJRC5cbiAgICAgKi9cbiAgICBnZXRJRCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwuaWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgc3RhdHVzIG9mIHRoZSBzdGFraW5nIG9wZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBzdGF0dXMgb2YgdGhlIHN0YWtpbmcgb3BlcmF0aW9uLlxuICAgICAqL1xuICAgIGdldFN0YXR1cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwuc3RhdHVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBXYWxsZXQgSUQgaWYgaXQgZXhpc3RzLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIFdhbGxldCBJRC5cbiAgICAgKi9cbiAgICBnZXRXYWxsZXRJRCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwud2FsbGV0X2lkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBBZGRyZXNzIElELlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIEFkZHJlc3MgSUQuXG4gICAgICovXG4gICAgZ2V0QWRkcmVzc0lEKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5hZGRyZXNzX2lkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBOZXR3b3JrIElELlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIE5ldHdvcmsgSUQuXG4gICAgICovXG4gICAgZ2V0TmV0d29ya0lEKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5uZXR3b3JrX2lkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBodW1hbi1yZWFkYWJsZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIFN0YWtpbmdPcGVyYXRpb24gb2JqZWN0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgU3Rha2luZ09wZXJhdGlvbiBvYmplY3QuXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBgU3Rha2luZ09wZXJhdGlvbiB7IGlkOiAke3RoaXMuZ2V0SUQoKX0gc3RhdHVzOiAke3RoaXMuZ2V0U3RhdHVzKCl9IG5ldHdvcmtfaWQ6ICR7dGhpcy5nZXROZXR3b3JrSUQoKX0gYWRkcmVzc19pZDogJHt0aGlzLmdldEFkZHJlc3NJRCgpfSB9YDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBTdGFraW5nIG9wZXJhdGlvbiBpcyBpbiBhIHRlcm1pbmFsIFN0YXRlLlxuICAgICAqXG4gICAgICogQHJldHVybnMgV2hldGhlciB0aGUgU3Rha2luZyBvcGVyYXRpb24gaXMgaW4gYSB0ZXJtaW5hbCBTdGF0ZVxuICAgICAqL1xuICAgIGlzVGVybWluYWxTdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNDb21wbGV0ZVN0YXRlKCkgfHwgdGhpcy5pc0ZhaWxlZFN0YXRlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgU3Rha2luZyBvcGVyYXRpb24gaXMgaW4gYSBmYWlsZWQgc3RhdGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBTdGFraW5nIG9wZXJhdGlvbiBpcyBpbiBhIGZhaWxlZCBzdGF0ZS5cbiAgICAgKi9cbiAgICBpc0ZhaWxlZFN0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTdGF0dXMoKSA9PT0gYXBpXzEuU3Rha2luZ09wZXJhdGlvblN0YXR1c0VudW0uRmFpbGVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIFN0YWtpbmcgb3BlcmF0aW9uIGlzIGluIGEgY29tcGxldGUgc3RhdGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBTdGFraW5nIG9wZXJhdGlvbiBpcyBpbiBhIGNvbXBsZXRlIHN0YXRlLlxuICAgICAqL1xuICAgIGlzQ29tcGxldGVTdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U3RhdHVzKCkgPT09IGFwaV8xLlN0YWtpbmdPcGVyYXRpb25TdGF0dXNFbnVtLkNvbXBsZXRlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHRyYW5zYWN0aW9ucyBhc3NvY2lhdGVkIHdpdGggdGhpcyBzdGFraW5nIG9wZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBhcnJheSBvZiB0cmFuc2FjdGlvbnMuXG4gICAgICovXG4gICAgZ2V0VHJhbnNhY3Rpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2FjdGlvbnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBzaWduZWQgdm9sdW50YXJ5IGV4aXQgbWVzc2FnZXMgZm9yIG5hdGl2ZSBldGggdW5zdGFraW5nXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgc2lnbmVkIHZvbHVudGFyeSBleGl0IG1lc3NhZ2VzIGZvciBhIG5hdGl2ZSBldGggdW5zdGFraW5nIG9wZXJhdGlvbi5cbiAgICAgKi9cbiAgICBnZXRTaWduZWRWb2x1bnRhcnlFeGl0TWVzc2FnZXMoKSB7XG4gICAgICAgIGNvbnN0IHNpZ25lZFZvbHVudGFyeUV4aXRNZXNzYWdlcyA9IFtdO1xuICAgICAgICBpZiAodGhpcy5tb2RlbC5tZXRhZGF0YSkge1xuICAgICAgICAgICAgdGhpcy5tb2RlbC5tZXRhZGF0YS5mb3JFYWNoKG1ldGFkYXRhID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBkZWNvZGVkU2lnbmVkVm9sdW50YXJ5RXhpdE1lc3NhZ2UgPSBhdG9iKG1ldGFkYXRhLnNpZ25lZF92b2x1bnRhcnlfZXhpdCk7XG4gICAgICAgICAgICAgICAgc2lnbmVkVm9sdW50YXJ5RXhpdE1lc3NhZ2VzLnB1c2goZGVjb2RlZFNpZ25lZFZvbHVudGFyeUV4aXRNZXNzYWdlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaWduZWRWb2x1bnRhcnlFeGl0TWVzc2FnZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbG9hZHMgdGhlIFN0YWtpbmdPcGVyYXRpb24gbW9kZWwgd2l0aCB0aGUgbGF0ZXN0IGRhdGEgZnJvbSB0aGUgc2VydmVyLlxuICAgICAqIElmIHRoZSBTdGFraW5nT3BlcmF0aW9uIG9iamVjdCB3YXMgY3JlYXRlZCBieSBhbiBFeHRlcm5hbEFkZHJlc3MgdGhlbiBpdCB3aWxsXG4gICAgICogbm90IGhhdmUgYSB3YWxsZXQgSUQuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtBUElFcnJvcn0gaWYgdGhlIEFQSSByZXF1ZXN0IHRvIGdldCB0aGUgU3Rha2luZ09wZXJhdGlvbiBmYWlscy5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgb24gYSBTdGFraW5nT3BlcmF0aW9uIHdpdGhvdXQgYSB3YWxsZXQgSUQuXG4gICAgICovXG4gICAgYXN5bmMgcmVsb2FkKCkge1xuICAgICAgICBpZiAodGhpcy5nZXRXYWxsZXRJRCgpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNvaW5iYXNlXzEuQ29pbmJhc2UuYXBpQ2xpZW50cy5zdGFrZS5nZXRFeHRlcm5hbFN0YWtpbmdPcGVyYXRpb24odGhpcy5nZXROZXR3b3JrSUQoKSwgdGhpcy5nZXRBZGRyZXNzSUQoKSwgdGhpcy5nZXRJRCgpKTtcbiAgICAgICAgICAgIHRoaXMubW9kZWwgPSByZXN1bHQuZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmdldFdhbGxldElEKCkgIT0gdW5kZWZpbmVkICYmIHRoaXMuZ2V0V2FsbGV0SUQoKSAhPSBcIlwiKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjb2luYmFzZV8xLkNvaW5iYXNlLmFwaUNsaWVudHMud2FsbGV0U3Rha2UuZ2V0U3Rha2luZ09wZXJhdGlvbih0aGlzLmdldFdhbGxldElEKCksIHRoaXMuZ2V0QWRkcmVzc0lEKCksIHRoaXMuZ2V0SUQoKSk7XG4gICAgICAgICAgICB0aGlzLm1vZGVsID0gcmVzdWx0LmRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sb2FkVHJhbnNhY3Rpb25zRnJvbU1vZGVsKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdhaXRzIHVudGlsIHRoZSBTdGFraW5nIE9wZXJhdGlvbiBpcyBjb21wbGV0ZWQgb3IgZmFpbGVkIGJ5IHBvbGxpbmcgaXRzIHN0YXR1cyBhdCB0aGUgZ2l2ZW4gaW50ZXJ2YWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIHRvIGNvbmZpZ3VyZSB0aGUgd2FpdCBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5pbnRlcnZhbFNlY29uZHMgLSBUaGUgaW50ZXJ2YWwgYXQgd2hpY2ggdG8gcG9sbCwgaW4gc2Vjb25kc1xuICAgICAqIEBwYXJhbSBvcHRpb25zLnRpbWVvdXRTZWNvbmRzIC0gVGhlIG1heGltdW0gYW1vdW50IG9mIHRpbWUgdG8gd2FpdCBmb3IgdGhlIFN0YWtpbmdPcGVyYXRpb24gdG8gY29tcGxldGUsIGluIHNlY29uZHNcbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIFN0YWtpbmdPcGVyYXRpb24gdGFrZXMgbG9uZ2VyIHRoYW4gdGhlIGdpdmVuIHRpbWVvdXQuXG4gICAgICogQHJldHVybnMgVGhlIGNvbXBsZXRlZCBTdGFraW5nT3BlcmF0aW9uIG9iamVjdC5cbiAgICAgKi9cbiAgICBhc3luYyB3YWl0KHsgaW50ZXJ2YWxTZWNvbmRzID0gNSwgdGltZW91dFNlY29uZHMgPSAzNjAwLCB9ID0ge30pIHtcbiAgICAgICAgaWYgKHRoaXMuZ2V0V2FsbGV0SUQoKSAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCB3YWl0IG9uIHN0YWtpbmcgb3BlcmF0aW9uIGZvciB3YWxsZXQgYWRkcmVzcy5cIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgd2hpbGUgKERhdGUubm93KCkgLSBzdGFydFRpbWUgPCB0aW1lb3V0U2Vjb25kcyAqIDEwMDApIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucmVsb2FkKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1Rlcm1pbmFsU3RhdGUoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1vZGVsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKERhdGUubm93KCkgLSBzdGFydFRpbWUgPiB0aW1lb3V0U2Vjb25kcyAqIDEwMDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdGFraW5nIG9wZXJhdGlvbiB0aW1lZCBvdXRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCAoMCwgdXRpbHNfMS5kZWxheSkoaW50ZXJ2YWxTZWNvbmRzKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdGFraW5nIG9wZXJhdGlvbiB0aW1lZCBvdXRcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNpZ24gdGhlIHRyYW5zYWN0aW9ucyBpbiB0aGUgU3Rha2luZ09wZXJhdGlvbiBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ga2V5IC0gVGhlIGtleSB1c2VkIHRvIHNpZ24gdGhlIHRyYW5zYWN0aW9ucy5cbiAgICAgKi9cbiAgICBhc3luYyBzaWduKGtleSkge1xuICAgICAgICBmb3IgKGNvbnN0IHR4IG9mIHRoaXMudHJhbnNhY3Rpb25zKSB7XG4gICAgICAgICAgICBpZiAoIXR4LmlzU2lnbmVkKCkpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0eC5zaWduKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogbG9hZFRyYW5zYWN0aW9uc0Zyb21Nb2RlbCBsb2FkcyBuZXcgdW5zaWduZWQgdHJhbnNhY3Rpb25zIGZyb20gdGhlIG1vZGVsIGludG8gdGhlIHRyYW5zYWN0aW9ucyBhcnJheS5cbiAgICAgKiBOb3RlOiBGb3IgRXh0ZXJuYWwgQWRkcmVzcyBtb2RlbCBzaW5jZSB0eCBzaWduaW5nIGFuZCBicm9hZGNhc3Qgc3RhdHVzIGhhcHBlbnMgYnkgdGhlIGVuZCB1c2VyIGFuZCBub3Qgb3VyIGJhY2tlbmRcbiAgICAgKiB3ZSBuZWVkIHRvIGJlIGNhcmVmdWwgdG8gbm90IG92ZXJ3cml0ZSB0aGUgdHJhbnNhY3Rpb25zIGFycmF5IHdpdGggdGhlIHJlc3BvbnNlIGZyb20gdGhlIEFQSS4gRXg6IEVuZCB1c2VyIGNvdWxkIGhhdmUgdXNlZFxuICAgICAqIHN0YWtpbmdPcGVyYXRpb24uc2lnbigpIG1ldGhvZCB0byBzaWduIHRoZSB0cmFuc2FjdGlvbnMsIGFuZCB3ZSBzaG91bGQgbm90IG92ZXJ3cml0ZSB0aGVtIHdpdGggdGhlIHJlc3BvbnNlIGZyb20gdGhlIEFQSS5cbiAgICAgKiBUaGlzIGhvd2V2ZXIgaXMgb2sgdG8gZG8gc28gZm9yIHRoZSBXYWxsZXQgQWRkcmVzcyBtb2RlbCBzaW5jZSB0aGUgdHJhbnNhY3Rpb25zIHN0YXRlcyBhcmUgbWFpbnRhaW5lZCBieSBvdXIgYmFja2VuZC5cbiAgICAgKiBUaGlzIG1ldGhvZCBhdHRlbXB0cyB0byBiZSBzYWZlIGZvciBib3RoIGFkZHJlc3MgbW9kZWxzLCBhbmQgb25seSBhZGRzIG5ld2x5IGNyZWF0ZWQgdW5zaWduZWQgdHJhbnNhY3Rpb25zIHRoYXQgYXJlIG5vdFxuICAgICAqICBhbHJlYWR5IGluIHRoZSB0cmFuc2FjdGlvbnMgYXJyYXkuXG4gICAgICovXG4gICAgbG9hZFRyYW5zYWN0aW9uc0Zyb21Nb2RlbCgpIHtcbiAgICAgICAgLy8gT25seSBvdmVyd3JpdGUgdGhlIHRyYW5zYWN0aW9ucyBpZiB0aGUgcmVzcG9uc2UgaXMgcG9wdWxhdGVkLlxuICAgICAgICBpZiAodGhpcy5tb2RlbC50cmFuc2FjdGlvbnMgJiYgdGhpcy5tb2RlbC50cmFuc2FjdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgc2V0IG9mIGV4aXN0aW5nIHVuc2lnbmVkIHBheWxvYWRzIHRvIGF2b2lkIGR1cGxpY2F0ZXMuXG4gICAgICAgICAgICBjb25zdCBleGlzdGluZ1Vuc2lnbmVkUGF5bG9hZHMgPSBuZXcgU2V0KHRoaXMudHJhbnNhY3Rpb25zLm1hcCh0eCA9PiB0eC5nZXRVbnNpZ25lZFBheWxvYWQoKSkpO1xuICAgICAgICAgICAgLy8gQWRkIHRyYW5zYWN0aW9ucyB0aGF0IGFyZSBub3QgYWxyZWFkeSBpbiB0aGUgdHJhbnNhY3Rpb25zIGFycmF5LlxuICAgICAgICAgICAgdGhpcy5tb2RlbC50cmFuc2FjdGlvbnMuZm9yRWFjaCh0cmFuc2FjdGlvbiA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFleGlzdGluZ1Vuc2lnbmVkUGF5bG9hZHMuaGFzKHRyYW5zYWN0aW9uLnVuc2lnbmVkX3BheWxvYWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJhbnNhY3Rpb25zLnB1c2gobmV3IHRyYW5zYWN0aW9uXzEuVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuU3Rha2luZ09wZXJhdGlvbiA9IFN0YWtpbmdPcGVyYXRpb247XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/staking_operation.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/staking_reward.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/staking_reward.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.StakingReward = void 0;\nconst decimal_js_1 = __importDefault(__webpack_require__(/*! decimal.js */ \"(rsc)/./node_modules/decimal.js/decimal.js\"));\nconst coinbase_1 = __webpack_require__(/*! ./coinbase */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/coinbase.js\");\nconst asset_1 = __webpack_require__(/*! ./asset */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/asset.js\");\nconst types_1 = __webpack_require__(/*! ./types */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/types.js\");\n/**\n * A representation of a staking reward earned on a network for a given asset.\n */\nclass StakingReward {\n    /**\n     * Creates the StakingReward object.\n     *\n     * @param model - The underlying staking reward object.\n     * @param asset - The asset for the staking reward.\n     * @param format - The format to return the rewards in. (usd, native). Defaults to usd.\n     */\n    constructor(model, asset, format) {\n        this.model = model;\n        this.asset = asset;\n        this.format = format;\n    }\n    /**\n     * Returns a list of StakingRewards for the provided network, asset, and addresses.\n     *\n     * @param networkId - The network ID.\n     * @param assetId - The asset ID.\n     * @param addressIds - The address ID.\n     * @param startTime - The start time.\n     * @param endTime - The end time.\n     * @param format - The format to return the rewards in. (usd, native). Defaults to usd.\n     * @returns The staking rewards.\n     */\n    static async list(networkId, assetId, addressIds, startTime, endTime, format = types_1.StakingRewardFormat.USD) {\n        const stakingRewards = [];\n        const queue = [\"\"];\n        while (queue.length > 0) {\n            const page = queue.shift();\n            const request = {\n                network_id: coinbase_1.Coinbase.normalizeNetwork(networkId),\n                asset_id: assetId,\n                address_ids: addressIds,\n                start_time: startTime,\n                end_time: endTime,\n                format: format,\n            };\n            const response = await coinbase_1.Coinbase.apiClients.stake.fetchStakingRewards(request, 100, page?.length ? page : undefined);\n            const asset = await asset_1.Asset.fetch(networkId, assetId);\n            response.data.data.forEach(stakingReward => {\n                stakingRewards.push(new StakingReward(stakingReward, asset, format));\n            });\n            if (response.data.has_more) {\n                if (response.data.next_page) {\n                    queue.push(response.data.next_page);\n                }\n            }\n        }\n        return stakingRewards;\n    }\n    /**\n     * Returns the amount of the StakingReward.\n     *\n     * @returns The amount.\n     */\n    amount() {\n        if (this.model.amount == \"\")\n            return 0;\n        if (this.format == types_1.StakingRewardFormat.USD) {\n            return new decimal_js_1.default(this.model.amount).div(new decimal_js_1.default(\"100\"));\n        }\n        return this.asset.fromAtomicAmount(new decimal_js_1.default(this.model.amount)).toNumber();\n    }\n    /**\n     * Returns the date of the StakingReward.\n     *\n     * @returns The date.\n     */\n    date() {\n        return new Date(this.model.date);\n    }\n    /**\n     * Returns the onchain address of the StakingReward.\n     *\n     * @returns The onchain address.\n     */\n    addressId() {\n        return this.model.address_id;\n    }\n    /**\n     * Returns the USD value of the StakingReward.\n     *\n     * @returns The USD value.\n     */\n    usdValue() {\n        return new decimal_js_1.default(this.model.usd_value.amount).div(new decimal_js_1.default(\"100\"));\n    }\n    /**\n     * Returns the conversion price of the StakingReward in USD.\n     *\n     * @returns The conversion price.\n     */\n    conversionPrice() {\n        return new decimal_js_1.default(this.model.usd_value.conversion_price);\n    }\n    /**\n     * Returns the time of calculating the conversion price.\n     *\n     * @returns The conversion time.\n     */\n    conversionTime() {\n        return new Date(this.model.usd_value.conversion_time);\n    }\n    /**\n     * Print the Staking Reward as a string.\n     *\n     * @returns The string representation of the Staking Reward.\n     */\n    toString() {\n        return `StakingReward { date: '${this.date().toISOString()}' address: '${this.addressId()}' amount: '${this.amount().toString()}' usd_value: '${this.usdValue().toString()}' conversion_price: '${this.conversionPrice().toString()}' conversion_time: '${this.conversionTime().toISOString()}' }`;\n    }\n}\nexports.StakingReward = StakingReward;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL3N0YWtpbmdfcmV3YXJkLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCO0FBQ3JCLHFDQUFxQyxtQkFBTyxDQUFDLDhEQUFZO0FBQ3pELG1CQUFtQixtQkFBTyxDQUFDLHlGQUFZO0FBQ3ZDLGdCQUFnQixtQkFBTyxDQUFDLG1GQUFTO0FBQ2pDLGdCQUFnQixtQkFBTyxDQUFDLG1GQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsU0FBUywwQkFBMEIsY0FBYyxpQkFBaUIsYUFBYSx5QkFBeUIsZ0JBQWdCLDJCQUEyQix1QkFBdUIsa0NBQWtDLHNCQUFzQixvQ0FBb0MsR0FBRztBQUN6UztBQUNBO0FBQ0EscUJBQXFCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3Vydml2YWwtZnVuLy4vbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9jb2luYmFzZS1zZGsvZGlzdC9jb2luYmFzZS9zdGFraW5nX3Jld2FyZC5qcz85MzVhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TdGFraW5nUmV3YXJkID0gdm9pZCAwO1xuY29uc3QgZGVjaW1hbF9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJkZWNpbWFsLmpzXCIpKTtcbmNvbnN0IGNvaW5iYXNlXzEgPSByZXF1aXJlKFwiLi9jb2luYmFzZVwiKTtcbmNvbnN0IGFzc2V0XzEgPSByZXF1aXJlKFwiLi9hc3NldFwiKTtcbmNvbnN0IHR5cGVzXzEgPSByZXF1aXJlKFwiLi90eXBlc1wiKTtcbi8qKlxuICogQSByZXByZXNlbnRhdGlvbiBvZiBhIHN0YWtpbmcgcmV3YXJkIGVhcm5lZCBvbiBhIG5ldHdvcmsgZm9yIGEgZ2l2ZW4gYXNzZXQuXG4gKi9cbmNsYXNzIFN0YWtpbmdSZXdhcmQge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhlIFN0YWtpbmdSZXdhcmQgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIG1vZGVsIC0gVGhlIHVuZGVybHlpbmcgc3Rha2luZyByZXdhcmQgb2JqZWN0LlxuICAgICAqIEBwYXJhbSBhc3NldCAtIFRoZSBhc3NldCBmb3IgdGhlIHN0YWtpbmcgcmV3YXJkLlxuICAgICAqIEBwYXJhbSBmb3JtYXQgLSBUaGUgZm9ybWF0IHRvIHJldHVybiB0aGUgcmV3YXJkcyBpbi4gKHVzZCwgbmF0aXZlKS4gRGVmYXVsdHMgdG8gdXNkLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG1vZGVsLCBhc3NldCwgZm9ybWF0KSB7XG4gICAgICAgIHRoaXMubW9kZWwgPSBtb2RlbDtcbiAgICAgICAgdGhpcy5hc3NldCA9IGFzc2V0O1xuICAgICAgICB0aGlzLmZvcm1hdCA9IGZvcm1hdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGxpc3Qgb2YgU3Rha2luZ1Jld2FyZHMgZm9yIHRoZSBwcm92aWRlZCBuZXR3b3JrLCBhc3NldCwgYW5kIGFkZHJlc3Nlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuZXR3b3JrSWQgLSBUaGUgbmV0d29yayBJRC5cbiAgICAgKiBAcGFyYW0gYXNzZXRJZCAtIFRoZSBhc3NldCBJRC5cbiAgICAgKiBAcGFyYW0gYWRkcmVzc0lkcyAtIFRoZSBhZGRyZXNzIElELlxuICAgICAqIEBwYXJhbSBzdGFydFRpbWUgLSBUaGUgc3RhcnQgdGltZS5cbiAgICAgKiBAcGFyYW0gZW5kVGltZSAtIFRoZSBlbmQgdGltZS5cbiAgICAgKiBAcGFyYW0gZm9ybWF0IC0gVGhlIGZvcm1hdCB0byByZXR1cm4gdGhlIHJld2FyZHMgaW4uICh1c2QsIG5hdGl2ZSkuIERlZmF1bHRzIHRvIHVzZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgc3Rha2luZyByZXdhcmRzLlxuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyBsaXN0KG5ldHdvcmtJZCwgYXNzZXRJZCwgYWRkcmVzc0lkcywgc3RhcnRUaW1lLCBlbmRUaW1lLCBmb3JtYXQgPSB0eXBlc18xLlN0YWtpbmdSZXdhcmRGb3JtYXQuVVNEKSB7XG4gICAgICAgIGNvbnN0IHN0YWtpbmdSZXdhcmRzID0gW107XG4gICAgICAgIGNvbnN0IHF1ZXVlID0gW1wiXCJdO1xuICAgICAgICB3aGlsZSAocXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgcGFnZSA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgICAgIG5ldHdvcmtfaWQ6IGNvaW5iYXNlXzEuQ29pbmJhc2Uubm9ybWFsaXplTmV0d29yayhuZXR3b3JrSWQpLFxuICAgICAgICAgICAgICAgIGFzc2V0X2lkOiBhc3NldElkLFxuICAgICAgICAgICAgICAgIGFkZHJlc3NfaWRzOiBhZGRyZXNzSWRzLFxuICAgICAgICAgICAgICAgIHN0YXJ0X3RpbWU6IHN0YXJ0VGltZSxcbiAgICAgICAgICAgICAgICBlbmRfdGltZTogZW5kVGltZSxcbiAgICAgICAgICAgICAgICBmb3JtYXQ6IGZvcm1hdCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNvaW5iYXNlXzEuQ29pbmJhc2UuYXBpQ2xpZW50cy5zdGFrZS5mZXRjaFN0YWtpbmdSZXdhcmRzKHJlcXVlc3QsIDEwMCwgcGFnZT8ubGVuZ3RoID8gcGFnZSA6IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICBjb25zdCBhc3NldCA9IGF3YWl0IGFzc2V0XzEuQXNzZXQuZmV0Y2gobmV0d29ya0lkLCBhc3NldElkKTtcbiAgICAgICAgICAgIHJlc3BvbnNlLmRhdGEuZGF0YS5mb3JFYWNoKHN0YWtpbmdSZXdhcmQgPT4ge1xuICAgICAgICAgICAgICAgIHN0YWtpbmdSZXdhcmRzLnB1c2gobmV3IFN0YWtpbmdSZXdhcmQoc3Rha2luZ1Jld2FyZCwgYXNzZXQsIGZvcm1hdCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UuZGF0YS5oYXNfbW9yZSkge1xuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5kYXRhLm5leHRfcGFnZSkge1xuICAgICAgICAgICAgICAgICAgICBxdWV1ZS5wdXNoKHJlc3BvbnNlLmRhdGEubmV4dF9wYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YWtpbmdSZXdhcmRzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBhbW91bnQgb2YgdGhlIFN0YWtpbmdSZXdhcmQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgYW1vdW50LlxuICAgICAqL1xuICAgIGFtb3VudCgpIHtcbiAgICAgICAgaWYgKHRoaXMubW9kZWwuYW1vdW50ID09IFwiXCIpXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgaWYgKHRoaXMuZm9ybWF0ID09IHR5cGVzXzEuU3Rha2luZ1Jld2FyZEZvcm1hdC5VU0QpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgZGVjaW1hbF9qc18xLmRlZmF1bHQodGhpcy5tb2RlbC5hbW91bnQpLmRpdihuZXcgZGVjaW1hbF9qc18xLmRlZmF1bHQoXCIxMDBcIikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmFzc2V0LmZyb21BdG9taWNBbW91bnQobmV3IGRlY2ltYWxfanNfMS5kZWZhdWx0KHRoaXMubW9kZWwuYW1vdW50KSkudG9OdW1iZXIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZGF0ZSBvZiB0aGUgU3Rha2luZ1Jld2FyZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBkYXRlLlxuICAgICAqL1xuICAgIGRhdGUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLm1vZGVsLmRhdGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBvbmNoYWluIGFkZHJlc3Mgb2YgdGhlIFN0YWtpbmdSZXdhcmQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgb25jaGFpbiBhZGRyZXNzLlxuICAgICAqL1xuICAgIGFkZHJlc3NJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwuYWRkcmVzc19pZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgVVNEIHZhbHVlIG9mIHRoZSBTdGFraW5nUmV3YXJkLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIFVTRCB2YWx1ZS5cbiAgICAgKi9cbiAgICB1c2RWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBkZWNpbWFsX2pzXzEuZGVmYXVsdCh0aGlzLm1vZGVsLnVzZF92YWx1ZS5hbW91bnQpLmRpdihuZXcgZGVjaW1hbF9qc18xLmRlZmF1bHQoXCIxMDBcIikpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjb252ZXJzaW9uIHByaWNlIG9mIHRoZSBTdGFraW5nUmV3YXJkIGluIFVTRC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBjb252ZXJzaW9uIHByaWNlLlxuICAgICAqL1xuICAgIGNvbnZlcnNpb25QcmljZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBkZWNpbWFsX2pzXzEuZGVmYXVsdCh0aGlzLm1vZGVsLnVzZF92YWx1ZS5jb252ZXJzaW9uX3ByaWNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdGltZSBvZiBjYWxjdWxhdGluZyB0aGUgY29udmVyc2lvbiBwcmljZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBjb252ZXJzaW9uIHRpbWUuXG4gICAgICovXG4gICAgY29udmVyc2lvblRpbWUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLm1vZGVsLnVzZF92YWx1ZS5jb252ZXJzaW9uX3RpbWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcmludCB0aGUgU3Rha2luZyBSZXdhcmQgYXMgYSBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBTdGFraW5nIFJld2FyZC5cbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGBTdGFraW5nUmV3YXJkIHsgZGF0ZTogJyR7dGhpcy5kYXRlKCkudG9JU09TdHJpbmcoKX0nIGFkZHJlc3M6ICcke3RoaXMuYWRkcmVzc0lkKCl9JyBhbW91bnQ6ICcke3RoaXMuYW1vdW50KCkudG9TdHJpbmcoKX0nIHVzZF92YWx1ZTogJyR7dGhpcy51c2RWYWx1ZSgpLnRvU3RyaW5nKCl9JyBjb252ZXJzaW9uX3ByaWNlOiAnJHt0aGlzLmNvbnZlcnNpb25QcmljZSgpLnRvU3RyaW5nKCl9JyBjb252ZXJzaW9uX3RpbWU6ICcke3RoaXMuY29udmVyc2lvblRpbWUoKS50b0lTT1N0cmluZygpfScgfWA7XG4gICAgfVxufVxuZXhwb3J0cy5TdGFraW5nUmV3YXJkID0gU3Rha2luZ1Jld2FyZDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/staking_reward.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/trade.js":
/*!********************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/trade.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Trade = void 0;\nconst decimal_js_1 = __webpack_require__(/*! decimal.js */ \"(rsc)/./node_modules/decimal.js/decimal.js\");\nconst coinbase_1 = __webpack_require__(/*! ./coinbase */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/coinbase.js\");\nconst errors_1 = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/errors.js\");\nconst transaction_1 = __webpack_require__(/*! ./transaction */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/transaction.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/utils.js\");\n/**\n * A representation of a Trade, which trades an amount of an Asset to another Asset on a Network.\n * The fee is assumed to be paid in the native Asset of the Network.\n */\nclass Trade {\n    /**\n     * Trades should be created through Wallet.trade or Address.trade.\n     *\n     * @class\n     * @param model - The underlying Trade object.\n     * @throws {Error} - If the Trade model is empty.\n     */\n    constructor(model) {\n        if (!model) {\n            throw new Error(\"Trade model cannot be empty\");\n        }\n        this.model = model;\n    }\n    /**\n     * Returns the Trade ID.\n     *\n     * @returns The Trade ID.\n     */\n    getId() {\n        return this.model.trade_id;\n    }\n    /**\n     * Returns the Network ID of the Trade.\n     *\n     * @returns The Network ID.\n     */\n    getNetworkId() {\n        return this.model.network_id;\n    }\n    /**\n     * Returns the Wallet ID of the Trade.\n     *\n     * @returns The Wallet ID.\n     */\n    getWalletId() {\n        return this.model.wallet_id;\n    }\n    /**\n     * Returns the Address ID of the Trade.\n     *\n     * @returns The Address ID.\n     */\n    getAddressId() {\n        return this.model.address_id;\n    }\n    /**\n     * Returns the From Asset ID of the Trade.\n     *\n     * @returns The From Asset ID.\n     */\n    getFromAssetId() {\n        return this.model.from_asset.asset_id;\n    }\n    /**\n     * Returns the amount of the from asset for the Trade.\n     *\n     * @returns The amount of the from asset.\n     */\n    getFromAmount() {\n        const amount = new decimal_js_1.Decimal(this.model.from_amount);\n        return amount.div(decimal_js_1.Decimal.pow(10, this.model.from_asset.decimals));\n    }\n    /**\n     * Returns the To Asset ID of the Trade.\n     *\n     * @returns The To Asset ID.\n     */\n    getToAssetId() {\n        return this.model.to_asset.asset_id;\n    }\n    /**\n     * Returns the amount of the to asset for the Trade.\n     *\n     * @returns The amount of the to asset.\n     */\n    getToAmount() {\n        const amount = new decimal_js_1.Decimal(this.model.to_amount);\n        return amount.div(decimal_js_1.Decimal.pow(10, this.model.to_asset.decimals));\n    }\n    /**\n     * Returns the Trade transaction.\n     *\n     * @returns The Trade transaction.\n     */\n    getTransaction() {\n        this.transaction = new transaction_1.Transaction(this.model.transaction);\n        return this.transaction;\n    }\n    /**\n     * Returns the approve transaction if it exists.\n     *\n     * @returns The approve transaction.\n     */\n    getApproveTransaction() {\n        if (!this.approveTransaction && this.model.approve_transaction) {\n            this.approveTransaction = new transaction_1.Transaction(this.model.approve_transaction);\n        }\n        return this.approveTransaction;\n    }\n    /**\n     * Signs the Trade with the provided key.\n     * This signs the transfer transaction and will sign the approval transaction if present.\n     *\n     * @param key - The key to sign the Transfer with\n     */\n    async sign(key) {\n        if (this.getApproveTransaction()) {\n            await this.getApproveTransaction().sign(key);\n        }\n        await this.getTransaction().sign(key);\n    }\n    /**\n     * Broadcasts the Trade to the Network.\n     *\n     * @returns The Trade object\n     * @throws {APIError} if the API request to broadcast a Trade fails.\n     */\n    async broadcast() {\n        const tx = this.getTransaction();\n        const approveTx = this.getApproveTransaction();\n        if (!tx.isSigned()) {\n            throw new errors_1.NotSignedError(\"Cannot broadcast Trade with unsigned transaction\");\n        }\n        if (approveTx && !approveTx.isSigned()) {\n            throw new errors_1.NotSignedError(\"Cannot broadcast Trade with unsigned approve transaction\");\n        }\n        const response = await coinbase_1.Coinbase.apiClients.trade.broadcastTrade(this.getWalletId(), tx.fromAddressId(), this.getId(), {\n            signed_payload: tx.getSignature(),\n            approve_transaction_signed_payload: approveTx ? approveTx.getSignature() : undefined,\n        });\n        this.resetModel(response.data);\n        return this;\n    }\n    /**\n     * Returns the status of the Trade.\n     *\n     * @returns The status.\n     */\n    getStatus() {\n        return this.getTransaction()?.getStatus();\n    }\n    /**\n     * Waits until the Trade is completed or failed by polling the Network at the given interval.\n     * Raises an error if the Trade takes longer than the given timeout.\n     *\n     * @param options - The options to configure the wait function.\n     * @param options.intervalSeconds - The interval at which to poll the Network, in seconds\n     * @param options.timeoutSeconds - The maximum amount of time to wait for the Trade to complete, in seconds\n     * @throws {Error} If the Trade takes longer than the given timeout.\n     * @throws {APIError} If the request fails.\n     * @returns The completed Trade object.\n     */\n    async wait({ intervalSeconds = 0.2, timeoutSeconds = 10 } = {}) {\n        const startTime = Date.now();\n        while (Date.now() - startTime < timeoutSeconds * 1000) {\n            await this.reload();\n            if (this.getTransaction().isTerminalState()) {\n                return this;\n            }\n            await (0, utils_1.delay)(intervalSeconds);\n        }\n        throw new errors_1.TimeoutError(\"Trade timed out\");\n    }\n    /**\n     * Reloads the Trade model with the latest version from the server side.\n     *\n     * @returns The most recent version of Trade from the server.\n     */\n    async reload() {\n        const result = await coinbase_1.Coinbase.apiClients.trade.getTrade(this.getWalletId(), this.getAddressId(), this.getId());\n        return this.resetModel(result?.data);\n    }\n    /**\n     * Returns a String representation of the Trade.\n     *\n     * @returns A String representation of the Trade.\n     */\n    toString() {\n        return (`Trade { transfer_id: '${this.getId()}', network_id: '${this.getNetworkId()}', ` +\n            `address_id: '${this.getAddressId()}', from_asset_id: '${this.getFromAssetId()}', ` +\n            `to_asset_id: '${this.getToAssetId()}', from_amount: '${this.getFromAmount()}', ` +\n            `to_amount: '${this.getToAmount()}', status: '${this.getStatus()}' }`);\n    }\n    /**\n     * Resets the trade model with the specified data from the server.\n     *\n     * @param model - The Trade model\n     * @returns The updated Trade object\n     */\n    resetModel(model) {\n        this.model = model;\n        this.transaction = new transaction_1.Transaction(this.model.transaction);\n        this.approveTransaction = this.model.approve_transaction\n            ? new transaction_1.Transaction(this.model.approve_transaction)\n            : undefined;\n        return this;\n    }\n}\nexports.Trade = Trade;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL3RyYWRlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWE7QUFDYixxQkFBcUIsbUJBQU8sQ0FBQyw4REFBWTtBQUN6QyxtQkFBbUIsbUJBQU8sQ0FBQyx5RkFBWTtBQUN2QyxpQkFBaUIsbUJBQU8sQ0FBQyxxRkFBVTtBQUNuQyxzQkFBc0IsbUJBQU8sQ0FBQywrRkFBZTtBQUM3QyxnQkFBZ0IsbUJBQU8sQ0FBQyxtRkFBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBLGlCQUFpQiw2Q0FBNkMsSUFBSTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixnQkFBZ0IsYUFBYSxrQkFBa0Isb0JBQW9CO0FBQzVGLDRCQUE0QixvQkFBb0IscUJBQXFCLHNCQUFzQjtBQUMzRiw2QkFBNkIsb0JBQW9CLG1CQUFtQixxQkFBcUI7QUFDekYsMkJBQTJCLG1CQUFtQixjQUFjLGlCQUFpQixHQUFHO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cnZpdmFsLWZ1bi8uL25vZGVfbW9kdWxlcy9AY29pbmJhc2UvY29pbmJhc2Utc2RrL2Rpc3QvY29pbmJhc2UvdHJhZGUuanM/M2Y3MCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVHJhZGUgPSB2b2lkIDA7XG5jb25zdCBkZWNpbWFsX2pzXzEgPSByZXF1aXJlKFwiZGVjaW1hbC5qc1wiKTtcbmNvbnN0IGNvaW5iYXNlXzEgPSByZXF1aXJlKFwiLi9jb2luYmFzZVwiKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4vZXJyb3JzXCIpO1xuY29uc3QgdHJhbnNhY3Rpb25fMSA9IHJlcXVpcmUoXCIuL3RyYW5zYWN0aW9uXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuLyoqXG4gKiBBIHJlcHJlc2VudGF0aW9uIG9mIGEgVHJhZGUsIHdoaWNoIHRyYWRlcyBhbiBhbW91bnQgb2YgYW4gQXNzZXQgdG8gYW5vdGhlciBBc3NldCBvbiBhIE5ldHdvcmsuXG4gKiBUaGUgZmVlIGlzIGFzc3VtZWQgdG8gYmUgcGFpZCBpbiB0aGUgbmF0aXZlIEFzc2V0IG9mIHRoZSBOZXR3b3JrLlxuICovXG5jbGFzcyBUcmFkZSB7XG4gICAgLyoqXG4gICAgICogVHJhZGVzIHNob3VsZCBiZSBjcmVhdGVkIHRocm91Z2ggV2FsbGV0LnRyYWRlIG9yIEFkZHJlc3MudHJhZGUuXG4gICAgICpcbiAgICAgKiBAY2xhc3NcbiAgICAgKiBAcGFyYW0gbW9kZWwgLSBUaGUgdW5kZXJseWluZyBUcmFkZSBvYmplY3QuXG4gICAgICogQHRocm93cyB7RXJyb3J9IC0gSWYgdGhlIFRyYWRlIG1vZGVsIGlzIGVtcHR5LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG1vZGVsKSB7XG4gICAgICAgIGlmICghbW9kZWwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRyYWRlIG1vZGVsIGNhbm5vdCBiZSBlbXB0eVwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1vZGVsID0gbW9kZWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIFRyYWRlIElELlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIFRyYWRlIElELlxuICAgICAqL1xuICAgIGdldElkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC50cmFkZV9pZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgTmV0d29yayBJRCBvZiB0aGUgVHJhZGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgTmV0d29yayBJRC5cbiAgICAgKi9cbiAgICBnZXROZXR3b3JrSWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLm5ldHdvcmtfaWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIFdhbGxldCBJRCBvZiB0aGUgVHJhZGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgV2FsbGV0IElELlxuICAgICAqL1xuICAgIGdldFdhbGxldElkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC53YWxsZXRfaWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIEFkZHJlc3MgSUQgb2YgdGhlIFRyYWRlLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIEFkZHJlc3MgSUQuXG4gICAgICovXG4gICAgZ2V0QWRkcmVzc0lkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5hZGRyZXNzX2lkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBGcm9tIEFzc2V0IElEIG9mIHRoZSBUcmFkZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBGcm9tIEFzc2V0IElELlxuICAgICAqL1xuICAgIGdldEZyb21Bc3NldElkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5mcm9tX2Fzc2V0LmFzc2V0X2lkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBhbW91bnQgb2YgdGhlIGZyb20gYXNzZXQgZm9yIHRoZSBUcmFkZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBhbW91bnQgb2YgdGhlIGZyb20gYXNzZXQuXG4gICAgICovXG4gICAgZ2V0RnJvbUFtb3VudCgpIHtcbiAgICAgICAgY29uc3QgYW1vdW50ID0gbmV3IGRlY2ltYWxfanNfMS5EZWNpbWFsKHRoaXMubW9kZWwuZnJvbV9hbW91bnQpO1xuICAgICAgICByZXR1cm4gYW1vdW50LmRpdihkZWNpbWFsX2pzXzEuRGVjaW1hbC5wb3coMTAsIHRoaXMubW9kZWwuZnJvbV9hc3NldC5kZWNpbWFscykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBUbyBBc3NldCBJRCBvZiB0aGUgVHJhZGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgVG8gQXNzZXQgSUQuXG4gICAgICovXG4gICAgZ2V0VG9Bc3NldElkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC50b19hc3NldC5hc3NldF9pZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYW1vdW50IG9mIHRoZSB0byBhc3NldCBmb3IgdGhlIFRyYWRlLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGFtb3VudCBvZiB0aGUgdG8gYXNzZXQuXG4gICAgICovXG4gICAgZ2V0VG9BbW91bnQoKSB7XG4gICAgICAgIGNvbnN0IGFtb3VudCA9IG5ldyBkZWNpbWFsX2pzXzEuRGVjaW1hbCh0aGlzLm1vZGVsLnRvX2Ftb3VudCk7XG4gICAgICAgIHJldHVybiBhbW91bnQuZGl2KGRlY2ltYWxfanNfMS5EZWNpbWFsLnBvdygxMCwgdGhpcy5tb2RlbC50b19hc3NldC5kZWNpbWFscykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBUcmFkZSB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBUcmFkZSB0cmFuc2FjdGlvbi5cbiAgICAgKi9cbiAgICBnZXRUcmFuc2FjdGlvbigpIHtcbiAgICAgICAgdGhpcy50cmFuc2FjdGlvbiA9IG5ldyB0cmFuc2FjdGlvbl8xLlRyYW5zYWN0aW9uKHRoaXMubW9kZWwudHJhbnNhY3Rpb24pO1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2FjdGlvbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYXBwcm92ZSB0cmFuc2FjdGlvbiBpZiBpdCBleGlzdHMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgYXBwcm92ZSB0cmFuc2FjdGlvbi5cbiAgICAgKi9cbiAgICBnZXRBcHByb3ZlVHJhbnNhY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5hcHByb3ZlVHJhbnNhY3Rpb24gJiYgdGhpcy5tb2RlbC5hcHByb3ZlX3RyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmFwcHJvdmVUcmFuc2FjdGlvbiA9IG5ldyB0cmFuc2FjdGlvbl8xLlRyYW5zYWN0aW9uKHRoaXMubW9kZWwuYXBwcm92ZV90cmFuc2FjdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwcm92ZVRyYW5zYWN0aW9uO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaWducyB0aGUgVHJhZGUgd2l0aCB0aGUgcHJvdmlkZWQga2V5LlxuICAgICAqIFRoaXMgc2lnbnMgdGhlIHRyYW5zZmVyIHRyYW5zYWN0aW9uIGFuZCB3aWxsIHNpZ24gdGhlIGFwcHJvdmFsIHRyYW5zYWN0aW9uIGlmIHByZXNlbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ga2V5IC0gVGhlIGtleSB0byBzaWduIHRoZSBUcmFuc2ZlciB3aXRoXG4gICAgICovXG4gICAgYXN5bmMgc2lnbihrZXkpIHtcbiAgICAgICAgaWYgKHRoaXMuZ2V0QXBwcm92ZVRyYW5zYWN0aW9uKCkpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuZ2V0QXBwcm92ZVRyYW5zYWN0aW9uKCkuc2lnbihrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMuZ2V0VHJhbnNhY3Rpb24oKS5zaWduKGtleSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJyb2FkY2FzdHMgdGhlIFRyYWRlIHRvIHRoZSBOZXR3b3JrLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIFRyYWRlIG9iamVjdFxuICAgICAqIEB0aHJvd3Mge0FQSUVycm9yfSBpZiB0aGUgQVBJIHJlcXVlc3QgdG8gYnJvYWRjYXN0IGEgVHJhZGUgZmFpbHMuXG4gICAgICovXG4gICAgYXN5bmMgYnJvYWRjYXN0KCkge1xuICAgICAgICBjb25zdCB0eCA9IHRoaXMuZ2V0VHJhbnNhY3Rpb24oKTtcbiAgICAgICAgY29uc3QgYXBwcm92ZVR4ID0gdGhpcy5nZXRBcHByb3ZlVHJhbnNhY3Rpb24oKTtcbiAgICAgICAgaWYgKCF0eC5pc1NpZ25lZCgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuTm90U2lnbmVkRXJyb3IoXCJDYW5ub3QgYnJvYWRjYXN0IFRyYWRlIHdpdGggdW5zaWduZWQgdHJhbnNhY3Rpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFwcHJvdmVUeCAmJiAhYXBwcm92ZVR4LmlzU2lnbmVkKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Ob3RTaWduZWRFcnJvcihcIkNhbm5vdCBicm9hZGNhc3QgVHJhZGUgd2l0aCB1bnNpZ25lZCBhcHByb3ZlIHRyYW5zYWN0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY29pbmJhc2VfMS5Db2luYmFzZS5hcGlDbGllbnRzLnRyYWRlLmJyb2FkY2FzdFRyYWRlKHRoaXMuZ2V0V2FsbGV0SWQoKSwgdHguZnJvbUFkZHJlc3NJZCgpLCB0aGlzLmdldElkKCksIHtcbiAgICAgICAgICAgIHNpZ25lZF9wYXlsb2FkOiB0eC5nZXRTaWduYXR1cmUoKSxcbiAgICAgICAgICAgIGFwcHJvdmVfdHJhbnNhY3Rpb25fc2lnbmVkX3BheWxvYWQ6IGFwcHJvdmVUeCA/IGFwcHJvdmVUeC5nZXRTaWduYXR1cmUoKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVzZXRNb2RlbChyZXNwb25zZS5kYXRhKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHN0YXR1cyBvZiB0aGUgVHJhZGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgc3RhdHVzLlxuICAgICAqL1xuICAgIGdldFN0YXR1cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHJhbnNhY3Rpb24oKT8uZ2V0U3RhdHVzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdhaXRzIHVudGlsIHRoZSBUcmFkZSBpcyBjb21wbGV0ZWQgb3IgZmFpbGVkIGJ5IHBvbGxpbmcgdGhlIE5ldHdvcmsgYXQgdGhlIGdpdmVuIGludGVydmFsLlxuICAgICAqIFJhaXNlcyBhbiBlcnJvciBpZiB0aGUgVHJhZGUgdGFrZXMgbG9uZ2VyIHRoYW4gdGhlIGdpdmVuIHRpbWVvdXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIHRvIGNvbmZpZ3VyZSB0aGUgd2FpdCBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5pbnRlcnZhbFNlY29uZHMgLSBUaGUgaW50ZXJ2YWwgYXQgd2hpY2ggdG8gcG9sbCB0aGUgTmV0d29yaywgaW4gc2Vjb25kc1xuICAgICAqIEBwYXJhbSBvcHRpb25zLnRpbWVvdXRTZWNvbmRzIC0gVGhlIG1heGltdW0gYW1vdW50IG9mIHRpbWUgdG8gd2FpdCBmb3IgdGhlIFRyYWRlIHRvIGNvbXBsZXRlLCBpbiBzZWNvbmRzXG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBUcmFkZSB0YWtlcyBsb25nZXIgdGhhbiB0aGUgZ2l2ZW4gdGltZW91dC5cbiAgICAgKiBAdGhyb3dzIHtBUElFcnJvcn0gSWYgdGhlIHJlcXVlc3QgZmFpbHMuXG4gICAgICogQHJldHVybnMgVGhlIGNvbXBsZXRlZCBUcmFkZSBvYmplY3QuXG4gICAgICovXG4gICAgYXN5bmMgd2FpdCh7IGludGVydmFsU2Vjb25kcyA9IDAuMiwgdGltZW91dFNlY29uZHMgPSAxMCB9ID0ge30pIHtcbiAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgd2hpbGUgKERhdGUubm93KCkgLSBzdGFydFRpbWUgPCB0aW1lb3V0U2Vjb25kcyAqIDEwMDApIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucmVsb2FkKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5nZXRUcmFuc2FjdGlvbigpLmlzVGVybWluYWxTdGF0ZSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCAoMCwgdXRpbHNfMS5kZWxheSkoaW50ZXJ2YWxTZWNvbmRzKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVGltZW91dEVycm9yKFwiVHJhZGUgdGltZWQgb3V0XCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWxvYWRzIHRoZSBUcmFkZSBtb2RlbCB3aXRoIHRoZSBsYXRlc3QgdmVyc2lvbiBmcm9tIHRoZSBzZXJ2ZXIgc2lkZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBtb3N0IHJlY2VudCB2ZXJzaW9uIG9mIFRyYWRlIGZyb20gdGhlIHNlcnZlci5cbiAgICAgKi9cbiAgICBhc3luYyByZWxvYWQoKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNvaW5iYXNlXzEuQ29pbmJhc2UuYXBpQ2xpZW50cy50cmFkZS5nZXRUcmFkZSh0aGlzLmdldFdhbGxldElkKCksIHRoaXMuZ2V0QWRkcmVzc0lkKCksIHRoaXMuZ2V0SWQoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc2V0TW9kZWwocmVzdWx0Py5kYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgVHJhZGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgVHJhZGUuXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAoYFRyYWRlIHsgdHJhbnNmZXJfaWQ6ICcke3RoaXMuZ2V0SWQoKX0nLCBuZXR3b3JrX2lkOiAnJHt0aGlzLmdldE5ldHdvcmtJZCgpfScsIGAgK1xuICAgICAgICAgICAgYGFkZHJlc3NfaWQ6ICcke3RoaXMuZ2V0QWRkcmVzc0lkKCl9JywgZnJvbV9hc3NldF9pZDogJyR7dGhpcy5nZXRGcm9tQXNzZXRJZCgpfScsIGAgK1xuICAgICAgICAgICAgYHRvX2Fzc2V0X2lkOiAnJHt0aGlzLmdldFRvQXNzZXRJZCgpfScsIGZyb21fYW1vdW50OiAnJHt0aGlzLmdldEZyb21BbW91bnQoKX0nLCBgICtcbiAgICAgICAgICAgIGB0b19hbW91bnQ6ICcke3RoaXMuZ2V0VG9BbW91bnQoKX0nLCBzdGF0dXM6ICcke3RoaXMuZ2V0U3RhdHVzKCl9JyB9YCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2V0cyB0aGUgdHJhZGUgbW9kZWwgd2l0aCB0aGUgc3BlY2lmaWVkIGRhdGEgZnJvbSB0aGUgc2VydmVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIG1vZGVsIC0gVGhlIFRyYWRlIG1vZGVsXG4gICAgICogQHJldHVybnMgVGhlIHVwZGF0ZWQgVHJhZGUgb2JqZWN0XG4gICAgICovXG4gICAgcmVzZXRNb2RlbChtb2RlbCkge1xuICAgICAgICB0aGlzLm1vZGVsID0gbW9kZWw7XG4gICAgICAgIHRoaXMudHJhbnNhY3Rpb24gPSBuZXcgdHJhbnNhY3Rpb25fMS5UcmFuc2FjdGlvbih0aGlzLm1vZGVsLnRyYW5zYWN0aW9uKTtcbiAgICAgICAgdGhpcy5hcHByb3ZlVHJhbnNhY3Rpb24gPSB0aGlzLm1vZGVsLmFwcHJvdmVfdHJhbnNhY3Rpb25cbiAgICAgICAgICAgID8gbmV3IHRyYW5zYWN0aW9uXzEuVHJhbnNhY3Rpb24odGhpcy5tb2RlbC5hcHByb3ZlX3RyYW5zYWN0aW9uKVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cbmV4cG9ydHMuVHJhZGUgPSBUcmFkZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/trade.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/transaction.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/transaction.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Transaction = void 0;\nconst ethers_1 = __webpack_require__(/*! ethers */ \"(rsc)/./node_modules/ethers/lib.commonjs/index.js\");\nconst types_1 = __webpack_require__(/*! ./types */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/types.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/utils.js\");\n/**\n * A representation of an onchain Transaction.\n */\nclass Transaction {\n    /**\n     * Transactions should be constructed via higher level abstractions like Trade or Transfer.\n     *\n     * @class\n     * @param model - The underlying Transaction object.\n     */\n    constructor(model) {\n        if (!model) {\n            throw new Error(\"Invalid model type\");\n        }\n        this.model = model;\n    }\n    /**\n     * Returns the Unsigned Payload of the Transaction.\n     *\n     * @returns The Unsigned Payload\n     */\n    getUnsignedPayload() {\n        return this.model.unsigned_payload;\n    }\n    /**\n     * Returns the Signed Payload of the Transaction.\n     *\n     * @returns The Signed Payload\n     */\n    getSignedPayload() {\n        return this.model.signed_payload;\n    }\n    /**\n     * Returns the Transaction Hash of the Transaction.\n     *\n     * @returns The Transaction Hash\n     */\n    getTransactionHash() {\n        return this.model.transaction_hash;\n    }\n    /**\n     * Returns the Status of the Transaction.\n     *\n     * @returns The Status\n     */\n    getStatus() {\n        switch (this.model.status) {\n            case types_1.TransactionStatus.PENDING:\n                return types_1.TransactionStatus.PENDING;\n            case types_1.TransactionStatus.BROADCAST:\n                return types_1.TransactionStatus.BROADCAST;\n            case types_1.TransactionStatus.SIGNED:\n                return types_1.TransactionStatus.SIGNED;\n            case types_1.TransactionStatus.COMPLETE:\n                return types_1.TransactionStatus.COMPLETE;\n            case types_1.TransactionStatus.FAILED:\n                return types_1.TransactionStatus.FAILED;\n            default:\n                return types_1.TransactionStatus.UNSPECIFIED;\n        }\n    }\n    /**\n     * Returns whether the Transaction is in a terminal State.\n     *\n     * @returns Whether the Transaction is in a terminal State\n     */\n    isTerminalState() {\n        const status = this.getStatus();\n        return [types_1.TransactionStatus.COMPLETE, types_1.TransactionStatus.FAILED].includes(status);\n    }\n    /**\n     * Returns the From Address ID for the Transaction.\n     *\n     * @returns The From Address ID\n     */\n    fromAddressId() {\n        return this.model.from_address_id;\n    }\n    /**\n     * Returns the To Address ID for the Transaction if it's available.\n     *\n     * @returns The To Address ID\n     */\n    toAddressId() {\n        return this.model.to_address_id;\n    }\n    /**\n     * Returns the Block Height where the Transaction is recorded.\n     *\n     * @returns The Block Height\n     */\n    blockHeight() {\n        return this.model.block_height;\n    }\n    /**\n     * Returns the Block Hash where the Transaction is recorded.\n     *\n     * @returns The Block Hash\n     */\n    blockHash() {\n        return this.model.block_hash;\n    }\n    /**\n     * Returns the Content of the Transaction.\n     *\n     * @returns The transaction content\n     */\n    content() {\n        return this.model.content;\n    }\n    /**\n     * Returns the link to the Transaction on the blockchain explorer.\n     *\n     * @returns The link to the Transaction on the blockchain explorer\n     */\n    getTransactionLink() {\n        return this.model.transaction_link;\n    }\n    /**\n     * Returns the Network ID of the Transaction.\n     *\n     * @returns The Network ID.\n     */\n    getNetworkId() {\n        return this.model.network_id;\n    }\n    /**\n     * Returns the underlying raw transaction.\n     *\n     * @throws {InvalidUnsignedPayload} If the Unsigned Payload is invalid.\n     * @returns The ethers.js Transaction object\n     */\n    rawTransaction() {\n        if (this.raw) {\n            return this.raw;\n        }\n        const parsedPayload = (0, utils_1.parseUnsignedPayload)(this.getUnsignedPayload());\n        const transaction = new ethers_1.ethers.Transaction();\n        transaction.chainId = BigInt(parsedPayload.chainId);\n        transaction.nonce = BigInt(parsedPayload.nonce);\n        transaction.maxPriorityFeePerGas = BigInt(parsedPayload.maxPriorityFeePerGas);\n        transaction.maxFeePerGas = BigInt(parsedPayload.maxFeePerGas);\n        // TODO: Handle multiple currencies.\n        transaction.gasLimit = BigInt(parsedPayload.gas);\n        transaction.to = parsedPayload.to;\n        transaction.value = BigInt(parsedPayload.value);\n        transaction.data = parsedPayload.input;\n        this.raw = transaction;\n        return this.raw;\n    }\n    /**\n     * Signs the Transaction with the provided key and returns the hex signing payload.\n     *\n     * @param key - The key to sign the transaction with\n     * @returns The hex-encoded signed payload\n     */\n    async sign(key) {\n        const signedPayload = await key.signTransaction(this.rawTransaction());\n        this.model.signed_payload = signedPayload;\n        // Removes the '0x' prefix as required by the API.\n        return signedPayload.slice(2);\n    }\n    /**\n     * Returns the Signed Payload of the Transaction.\n     *\n     * @returns The Signed Payload\n     */\n    getSignature() {\n        return this.getSignedPayload()?.slice(2);\n    }\n    /**\n     * Returns whether the transaction has been signed.\n     *\n     * @returns if the transaction has been signed.\n     */\n    isSigned() {\n        return !!this.getSignature();\n    }\n    /**\n     * Returns a string representation of the Transaction.\n     *\n     * @returns A string representation of the Transaction.\n     */\n    toString() {\n        return `Transaction { transactionHash: '${this.getTransactionHash()}', status: '${this.getStatus()}', unsignedPayload: '${this.getUnsignedPayload()}', signedPayload: ${this.getSignedPayload()}, transactionLink: ${this.getTransactionLink()} }`;\n    }\n}\nexports.Transaction = Transaction;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL3RyYW5zYWN0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1CQUFtQjtBQUNuQixpQkFBaUIsbUJBQU8sQ0FBQyxpRUFBUTtBQUNqQyxnQkFBZ0IsbUJBQU8sQ0FBQyxtRkFBUztBQUNqQyxnQkFBZ0IsbUJBQU8sQ0FBQyxtRkFBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isd0JBQXdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixvQkFBb0IsMEJBQTBCLGNBQWMsaUJBQWlCLHVCQUF1QiwwQkFBMEIsb0JBQW9CLHdCQUF3QixxQkFBcUIsNEJBQTRCO0FBQ3pQO0FBQ0E7QUFDQSxtQkFBbUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXJ2aXZhbC1mdW4vLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL3RyYW5zYWN0aW9uLmpzP2E1NTEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlRyYW5zYWN0aW9uID0gdm9pZCAwO1xuY29uc3QgZXRoZXJzXzEgPSByZXF1aXJlKFwiZXRoZXJzXCIpO1xuY29uc3QgdHlwZXNfMSA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuLyoqXG4gKiBBIHJlcHJlc2VudGF0aW9uIG9mIGFuIG9uY2hhaW4gVHJhbnNhY3Rpb24uXG4gKi9cbmNsYXNzIFRyYW5zYWN0aW9uIHtcbiAgICAvKipcbiAgICAgKiBUcmFuc2FjdGlvbnMgc2hvdWxkIGJlIGNvbnN0cnVjdGVkIHZpYSBoaWdoZXIgbGV2ZWwgYWJzdHJhY3Rpb25zIGxpa2UgVHJhZGUgb3IgVHJhbnNmZXIuXG4gICAgICpcbiAgICAgKiBAY2xhc3NcbiAgICAgKiBAcGFyYW0gbW9kZWwgLSBUaGUgdW5kZXJseWluZyBUcmFuc2FjdGlvbiBvYmplY3QuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobW9kZWwpIHtcbiAgICAgICAgaWYgKCFtb2RlbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBtb2RlbCB0eXBlXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW9kZWwgPSBtb2RlbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgVW5zaWduZWQgUGF5bG9hZCBvZiB0aGUgVHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgVW5zaWduZWQgUGF5bG9hZFxuICAgICAqL1xuICAgIGdldFVuc2lnbmVkUGF5bG9hZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwudW5zaWduZWRfcGF5bG9hZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgU2lnbmVkIFBheWxvYWQgb2YgdGhlIFRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIFNpZ25lZCBQYXlsb2FkXG4gICAgICovXG4gICAgZ2V0U2lnbmVkUGF5bG9hZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwuc2lnbmVkX3BheWxvYWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIFRyYW5zYWN0aW9uIEhhc2ggb2YgdGhlIFRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIFRyYW5zYWN0aW9uIEhhc2hcbiAgICAgKi9cbiAgICBnZXRUcmFuc2FjdGlvbkhhc2goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLnRyYW5zYWN0aW9uX2hhc2g7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIFN0YXR1cyBvZiB0aGUgVHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgU3RhdHVzXG4gICAgICovXG4gICAgZ2V0U3RhdHVzKCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMubW9kZWwuc3RhdHVzKSB7XG4gICAgICAgICAgICBjYXNlIHR5cGVzXzEuVHJhbnNhY3Rpb25TdGF0dXMuUEVORElORzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZXNfMS5UcmFuc2FjdGlvblN0YXR1cy5QRU5ESU5HO1xuICAgICAgICAgICAgY2FzZSB0eXBlc18xLlRyYW5zYWN0aW9uU3RhdHVzLkJST0FEQ0FTVDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZXNfMS5UcmFuc2FjdGlvblN0YXR1cy5CUk9BRENBU1Q7XG4gICAgICAgICAgICBjYXNlIHR5cGVzXzEuVHJhbnNhY3Rpb25TdGF0dXMuU0lHTkVEOlxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlc18xLlRyYW5zYWN0aW9uU3RhdHVzLlNJR05FRDtcbiAgICAgICAgICAgIGNhc2UgdHlwZXNfMS5UcmFuc2FjdGlvblN0YXR1cy5DT01QTEVURTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZXNfMS5UcmFuc2FjdGlvblN0YXR1cy5DT01QTEVURTtcbiAgICAgICAgICAgIGNhc2UgdHlwZXNfMS5UcmFuc2FjdGlvblN0YXR1cy5GQUlMRUQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVzXzEuVHJhbnNhY3Rpb25TdGF0dXMuRkFJTEVEO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZXNfMS5UcmFuc2FjdGlvblN0YXR1cy5VTlNQRUNJRklFRDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIFRyYW5zYWN0aW9uIGlzIGluIGEgdGVybWluYWwgU3RhdGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBUcmFuc2FjdGlvbiBpcyBpbiBhIHRlcm1pbmFsIFN0YXRlXG4gICAgICovXG4gICAgaXNUZXJtaW5hbFN0YXRlKCkge1xuICAgICAgICBjb25zdCBzdGF0dXMgPSB0aGlzLmdldFN0YXR1cygpO1xuICAgICAgICByZXR1cm4gW3R5cGVzXzEuVHJhbnNhY3Rpb25TdGF0dXMuQ09NUExFVEUsIHR5cGVzXzEuVHJhbnNhY3Rpb25TdGF0dXMuRkFJTEVEXS5pbmNsdWRlcyhzdGF0dXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBGcm9tIEFkZHJlc3MgSUQgZm9yIHRoZSBUcmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBGcm9tIEFkZHJlc3MgSURcbiAgICAgKi9cbiAgICBmcm9tQWRkcmVzc0lkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5mcm9tX2FkZHJlc3NfaWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIFRvIEFkZHJlc3MgSUQgZm9yIHRoZSBUcmFuc2FjdGlvbiBpZiBpdCdzIGF2YWlsYWJsZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBUbyBBZGRyZXNzIElEXG4gICAgICovXG4gICAgdG9BZGRyZXNzSWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLnRvX2FkZHJlc3NfaWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIEJsb2NrIEhlaWdodCB3aGVyZSB0aGUgVHJhbnNhY3Rpb24gaXMgcmVjb3JkZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgQmxvY2sgSGVpZ2h0XG4gICAgICovXG4gICAgYmxvY2tIZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLmJsb2NrX2hlaWdodDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgQmxvY2sgSGFzaCB3aGVyZSB0aGUgVHJhbnNhY3Rpb24gaXMgcmVjb3JkZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgQmxvY2sgSGFzaFxuICAgICAqL1xuICAgIGJsb2NrSGFzaCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwuYmxvY2tfaGFzaDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgQ29udGVudCBvZiB0aGUgVHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgdHJhbnNhY3Rpb24gY29udGVudFxuICAgICAqL1xuICAgIGNvbnRlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLmNvbnRlbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxpbmsgdG8gdGhlIFRyYW5zYWN0aW9uIG9uIHRoZSBibG9ja2NoYWluIGV4cGxvcmVyLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGxpbmsgdG8gdGhlIFRyYW5zYWN0aW9uIG9uIHRoZSBibG9ja2NoYWluIGV4cGxvcmVyXG4gICAgICovXG4gICAgZ2V0VHJhbnNhY3Rpb25MaW5rKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC50cmFuc2FjdGlvbl9saW5rO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBOZXR3b3JrIElEIG9mIHRoZSBUcmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBOZXR3b3JrIElELlxuICAgICAqL1xuICAgIGdldE5ldHdvcmtJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwubmV0d29ya19pZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdW5kZXJseWluZyByYXcgdHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtJbnZhbGlkVW5zaWduZWRQYXlsb2FkfSBJZiB0aGUgVW5zaWduZWQgUGF5bG9hZCBpcyBpbnZhbGlkLlxuICAgICAqIEByZXR1cm5zIFRoZSBldGhlcnMuanMgVHJhbnNhY3Rpb24gb2JqZWN0XG4gICAgICovXG4gICAgcmF3VHJhbnNhY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLnJhdykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmF3O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnNlZFBheWxvYWQgPSAoMCwgdXRpbHNfMS5wYXJzZVVuc2lnbmVkUGF5bG9hZCkodGhpcy5nZXRVbnNpZ25lZFBheWxvYWQoKSk7XG4gICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gbmV3IGV0aGVyc18xLmV0aGVycy5UcmFuc2FjdGlvbigpO1xuICAgICAgICB0cmFuc2FjdGlvbi5jaGFpbklkID0gQmlnSW50KHBhcnNlZFBheWxvYWQuY2hhaW5JZCk7XG4gICAgICAgIHRyYW5zYWN0aW9uLm5vbmNlID0gQmlnSW50KHBhcnNlZFBheWxvYWQubm9uY2UpO1xuICAgICAgICB0cmFuc2FjdGlvbi5tYXhQcmlvcml0eUZlZVBlckdhcyA9IEJpZ0ludChwYXJzZWRQYXlsb2FkLm1heFByaW9yaXR5RmVlUGVyR2FzKTtcbiAgICAgICAgdHJhbnNhY3Rpb24ubWF4RmVlUGVyR2FzID0gQmlnSW50KHBhcnNlZFBheWxvYWQubWF4RmVlUGVyR2FzKTtcbiAgICAgICAgLy8gVE9ETzogSGFuZGxlIG11bHRpcGxlIGN1cnJlbmNpZXMuXG4gICAgICAgIHRyYW5zYWN0aW9uLmdhc0xpbWl0ID0gQmlnSW50KHBhcnNlZFBheWxvYWQuZ2FzKTtcbiAgICAgICAgdHJhbnNhY3Rpb24udG8gPSBwYXJzZWRQYXlsb2FkLnRvO1xuICAgICAgICB0cmFuc2FjdGlvbi52YWx1ZSA9IEJpZ0ludChwYXJzZWRQYXlsb2FkLnZhbHVlKTtcbiAgICAgICAgdHJhbnNhY3Rpb24uZGF0YSA9IHBhcnNlZFBheWxvYWQuaW5wdXQ7XG4gICAgICAgIHRoaXMucmF3ID0gdHJhbnNhY3Rpb247XG4gICAgICAgIHJldHVybiB0aGlzLnJhdztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2lnbnMgdGhlIFRyYW5zYWN0aW9uIHdpdGggdGhlIHByb3ZpZGVkIGtleSBhbmQgcmV0dXJucyB0aGUgaGV4IHNpZ25pbmcgcGF5bG9hZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBrZXkgLSBUaGUga2V5IHRvIHNpZ24gdGhlIHRyYW5zYWN0aW9uIHdpdGhcbiAgICAgKiBAcmV0dXJucyBUaGUgaGV4LWVuY29kZWQgc2lnbmVkIHBheWxvYWRcbiAgICAgKi9cbiAgICBhc3luYyBzaWduKGtleSkge1xuICAgICAgICBjb25zdCBzaWduZWRQYXlsb2FkID0gYXdhaXQga2V5LnNpZ25UcmFuc2FjdGlvbih0aGlzLnJhd1RyYW5zYWN0aW9uKCkpO1xuICAgICAgICB0aGlzLm1vZGVsLnNpZ25lZF9wYXlsb2FkID0gc2lnbmVkUGF5bG9hZDtcbiAgICAgICAgLy8gUmVtb3ZlcyB0aGUgJzB4JyBwcmVmaXggYXMgcmVxdWlyZWQgYnkgdGhlIEFQSS5cbiAgICAgICAgcmV0dXJuIHNpZ25lZFBheWxvYWQuc2xpY2UoMik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIFNpZ25lZCBQYXlsb2FkIG9mIHRoZSBUcmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBTaWduZWQgUGF5bG9hZFxuICAgICAqL1xuICAgIGdldFNpZ25hdHVyZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2lnbmVkUGF5bG9hZCgpPy5zbGljZSgyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSB0cmFuc2FjdGlvbiBoYXMgYmVlbiBzaWduZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBpZiB0aGUgdHJhbnNhY3Rpb24gaGFzIGJlZW4gc2lnbmVkLlxuICAgICAqL1xuICAgIGlzU2lnbmVkKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLmdldFNpZ25hdHVyZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBUcmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBUcmFuc2FjdGlvbi5cbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGBUcmFuc2FjdGlvbiB7IHRyYW5zYWN0aW9uSGFzaDogJyR7dGhpcy5nZXRUcmFuc2FjdGlvbkhhc2goKX0nLCBzdGF0dXM6ICcke3RoaXMuZ2V0U3RhdHVzKCl9JywgdW5zaWduZWRQYXlsb2FkOiAnJHt0aGlzLmdldFVuc2lnbmVkUGF5bG9hZCgpfScsIHNpZ25lZFBheWxvYWQ6ICR7dGhpcy5nZXRTaWduZWRQYXlsb2FkKCl9LCB0cmFuc2FjdGlvbkxpbms6ICR7dGhpcy5nZXRUcmFuc2FjdGlvbkxpbmsoKX0gfWA7XG4gICAgfVxufVxuZXhwb3J0cy5UcmFuc2FjdGlvbiA9IFRyYW5zYWN0aW9uO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/transaction.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/transfer.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/transfer.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Transfer = void 0;\nconst decimal_js_1 = __webpack_require__(/*! decimal.js */ \"(rsc)/./node_modules/decimal.js/decimal.js\");\nconst types_1 = __webpack_require__(/*! ./types */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/types.js\");\nconst transaction_1 = __webpack_require__(/*! ./transaction */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/transaction.js\");\nconst sponsored_send_1 = __webpack_require__(/*! ./sponsored_send */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/sponsored_send.js\");\nconst coinbase_1 = __webpack_require__(/*! ./coinbase */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/coinbase.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/utils.js\");\nconst errors_1 = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/errors.js\");\n/**\n * A representation of a Transfer, which moves an Amount of an Asset from\n * a user-controlled Wallet to another Address. The fee is assumed to be paid\n * in the native Asset of the Network.\n */\nclass Transfer {\n    /**\n     * Private constructor to prevent direct instantiation outside of the factory methods.\n     *\n     * @ignore\n     * @param transferModel - The Transfer model.\n     * @hideconstructor\n     */\n    constructor(transferModel) {\n        if (!transferModel) {\n            throw new Error(\"Transfer model cannot be empty\");\n        }\n        this.model = transferModel;\n    }\n    /**\n     * Converts a TransferModel into a Transfer object.\n     *\n     * @param transferModel - The Transfer model object.\n     * @returns The Transfer object.\n     */\n    static fromModel(transferModel) {\n        return new Transfer(transferModel);\n    }\n    /**\n     * Returns the ID of the Transfer.\n     *\n     * @returns The Transfer ID.\n     */\n    getId() {\n        return this.model.transfer_id;\n    }\n    /**\n     * Returns the Network ID of the Transfer.\n     *\n     * @returns The Network ID.\n     */\n    getNetworkId() {\n        return this.model.network_id;\n    }\n    /**\n     * Returns the Wallet ID of the Transfer.\n     *\n     * @returns The Wallet ID.\n     */\n    getWalletId() {\n        return this.model.wallet_id;\n    }\n    /**\n     * Returns the From Address ID of the Transfer.\n     *\n     * @returns The From Address ID.\n     */\n    getFromAddressId() {\n        return this.model.address_id;\n    }\n    /**\n     * Returns the Destination Address ID of the Transfer.\n     *\n     * @returns The Destination Address ID.\n     */\n    getDestinationAddressId() {\n        return this.model.destination;\n    }\n    /**\n     * Returns the Asset ID of the Transfer.\n     *\n     * @returns The Asset ID.\n     */\n    getAssetId() {\n        return this.model.asset_id;\n    }\n    /**\n     * Returns the Amount of the Transfer.\n     *\n     * @returns The Amount of the Asset.\n     */\n    getAmount() {\n        const amount = new decimal_js_1.Decimal(this.model.amount);\n        return amount.dividedBy(new decimal_js_1.Decimal(10).pow(this.model.asset.decimals));\n    }\n    /**\n     * Returns the Transaction Hash of the Transfer.\n     *\n     * @returns The Transaction Hash as a Hex string, or undefined if not yet available.\n     */\n    getTransactionHash() {\n        return this.getSendTransactionDelegate()?.getTransactionHash();\n    }\n    /**\n     * Returns the Transaction of the Transfer.\n     *\n     * @returns The ethers.js Transaction object.\n     * @throws (InvalidUnsignedPayload) If the Unsigned Payload is invalid.\n     */\n    getRawTransaction() {\n        if (!this.getTransaction())\n            return undefined;\n        return this.getTransaction().rawTransaction();\n    }\n    /**\n     * Signs the Transfer with the provided key and returns the hex signature\n     * required for broadcasting the Transfer.\n     *\n     * @param key - The key to sign the Transfer with\n     * @returns The hex-encoded signed payload\n     */\n    async sign(key) {\n        return this.getSendTransactionDelegate().sign(key);\n    }\n    /**\n     * Returns the Status of the Transfer.\n     *\n     * @returns The Status of the Transfer.\n     */\n    getStatus() {\n        switch (this.getSendTransactionDelegate().getStatus()) {\n            case types_1.TransactionStatus.PENDING:\n                return types_1.TransferStatus.PENDING;\n            case types_1.SponsoredSendStatus.PENDING:\n                return types_1.TransferStatus.PENDING;\n            case types_1.SponsoredSendStatus.SIGNED:\n                return types_1.TransferStatus.PENDING;\n            case types_1.TransactionStatus.BROADCAST:\n                return types_1.TransferStatus.BROADCAST;\n            case types_1.SponsoredSendStatus.SUBMITTED:\n                return types_1.TransferStatus.BROADCAST;\n            case types_1.TransactionStatus.COMPLETE:\n                return types_1.TransferStatus.COMPLETE;\n            case types_1.SponsoredSendStatus.COMPLETE:\n                return types_1.TransferStatus.COMPLETE;\n            case types_1.TransactionStatus.FAILED:\n                return types_1.TransferStatus.FAILED;\n            case types_1.SponsoredSendStatus.FAILED:\n                return types_1.TransferStatus.FAILED;\n            default:\n                return undefined;\n        }\n    }\n    /**\n     * Returns the Transaction of the Transfer.\n     *\n     * @returns The Transaction\n     */\n    getTransaction() {\n        if (!this.model.transaction)\n            return undefined;\n        return new transaction_1.Transaction(this.model.transaction);\n    }\n    /**\n     * Returns the Sponsored Send of the Transfer.\n     *\n     * @returns The Sponsored Send\n     */\n    getSponsoredSend() {\n        if (!this.model.sponsored_send)\n            return undefined;\n        return new sponsored_send_1.SponsoredSend(this.model.sponsored_send);\n    }\n    /**\n     * Returns the Send Transaction Delegate of the Transfer.\n     *\n     * @returns Either the Transaction or the Sponsored Send\n     */\n    getSendTransactionDelegate() {\n        return !this.getTransaction() ? this.getSponsoredSend() : this.getTransaction();\n    }\n    /**\n     * Returns the link to the Transaction on the blockchain explorer.\n     *\n     * @returns The link to the Transaction on the blockchain explorer.\n     */\n    getTransactionLink() {\n        return this.getSendTransactionDelegate()?.getTransactionLink();\n    }\n    /**\n     * Broadcasts the Transfer to the Network.\n     *\n     * @returns The Transfer object\n     * @throws {APIError} if the API request to broadcast a Transfer fails.\n     */\n    async broadcast() {\n        if (!this.getSendTransactionDelegate()?.isSigned())\n            throw new Error(\"Cannot broadcast unsigned Transfer\");\n        const broadcastTransferRequest = {\n            signed_payload: this.getSendTransactionDelegate().getSignature(),\n        };\n        const response = await coinbase_1.Coinbase.apiClients.transfer.broadcastTransfer(this.getWalletId(), this.getFromAddressId(), this.getId(), broadcastTransferRequest);\n        return Transfer.fromModel(response.data);\n    }\n    /**\n     * Waits for the Transfer to be confirmed on the Network or fail on chain.\n     * Waits until the Transfer is completed or failed on-chain by polling at the given interval.\n     * Raises an error if the Trade takes longer than the given timeout.\n     *\n     * @param options - The options to configure the wait function.\n     * @param options.intervalSeconds - The interval to check the status of the Transfer.\n     * @param options.timeoutSeconds - The maximum time to wait for the Transfer to be confirmed.\n     *\n     * @returns The Transfer object in a terminal state.\n     * @throws {Error} if the Transfer times out.\n     */\n    async wait({ intervalSeconds = 0.2, timeoutSeconds = 10 } = {}) {\n        const startTime = Date.now();\n        while (Date.now() - startTime < timeoutSeconds * 1000) {\n            await this.reload();\n            // If the Transfer is in a terminal state, return the Transfer.\n            const status = this.getStatus();\n            if (status === types_1.TransferStatus.COMPLETE || status === types_1.TransferStatus.FAILED) {\n                return this;\n            }\n            await (0, utils_1.delay)(intervalSeconds);\n        }\n        throw new errors_1.TimeoutError(\"Transfer timed out\");\n    }\n    /**\n     * Reloads the Transfer model with the latest data from the server.\n     *\n     * @throws {APIError} if the API request to get a Transfer fails.\n     */\n    async reload() {\n        const result = await coinbase_1.Coinbase.apiClients.transfer.getTransfer(this.getWalletId(), this.getFromAddressId(), this.getId());\n        this.model = result?.data;\n    }\n    /**\n     * Returns a string representation of the Transfer.\n     *\n     * @returns The string representation of the Transfer.\n     */\n    toString() {\n        return (`Transfer{transferId: '${this.getId()}', networkId: '${this.getNetworkId()}', ` +\n            `fromAddressId: '${this.getFromAddressId()}', destinationAddressId: '${this.getDestinationAddressId()}', ` +\n            `assetId: '${this.getAssetId()}', amount: '${this.getAmount()}', transactionHash: '${this.getTransactionHash()}', ` +\n            `transactionLink: '${this.getTransactionLink()}', status: '${this.getStatus()}'}`);\n    }\n}\nexports.Transfer = Transfer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL3RyYW5zZmVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQjtBQUNoQixxQkFBcUIsbUJBQU8sQ0FBQyw4REFBWTtBQUN6QyxnQkFBZ0IsbUJBQU8sQ0FBQyxtRkFBUztBQUNqQyxzQkFBc0IsbUJBQU8sQ0FBQywrRkFBZTtBQUM3Qyx5QkFBeUIsbUJBQU8sQ0FBQyxxR0FBa0I7QUFDbkQsbUJBQW1CLG1CQUFPLENBQUMseUZBQVk7QUFDdkMsZ0JBQWdCLG1CQUFPLENBQUMsbUZBQVM7QUFDakMsaUJBQWlCLG1CQUFPLENBQUMscUZBQVU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0EsaUJBQWlCLDZDQUE2QyxJQUFJO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsZUFBZSxhQUFhLGlCQUFpQixvQkFBb0I7QUFDM0YsK0JBQStCLHdCQUF3Qiw0QkFBNEIsK0JBQStCO0FBQ2xILHlCQUF5QixrQkFBa0IsY0FBYyxpQkFBaUIsdUJBQXVCLDBCQUEwQjtBQUMzSCxpQ0FBaUMsMEJBQTBCLGNBQWMsaUJBQWlCLEVBQUU7QUFDNUY7QUFDQTtBQUNBLGdCQUFnQiIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cnZpdmFsLWZ1bi8uL25vZGVfbW9kdWxlcy9AY29pbmJhc2UvY29pbmJhc2Utc2RrL2Rpc3QvY29pbmJhc2UvdHJhbnNmZXIuanM/ODI2ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVHJhbnNmZXIgPSB2b2lkIDA7XG5jb25zdCBkZWNpbWFsX2pzXzEgPSByZXF1aXJlKFwiZGVjaW1hbC5qc1wiKTtcbmNvbnN0IHR5cGVzXzEgPSByZXF1aXJlKFwiLi90eXBlc1wiKTtcbmNvbnN0IHRyYW5zYWN0aW9uXzEgPSByZXF1aXJlKFwiLi90cmFuc2FjdGlvblwiKTtcbmNvbnN0IHNwb25zb3JlZF9zZW5kXzEgPSByZXF1aXJlKFwiLi9zcG9uc29yZWRfc2VuZFwiKTtcbmNvbnN0IGNvaW5iYXNlXzEgPSByZXF1aXJlKFwiLi9jb2luYmFzZVwiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4vZXJyb3JzXCIpO1xuLyoqXG4gKiBBIHJlcHJlc2VudGF0aW9uIG9mIGEgVHJhbnNmZXIsIHdoaWNoIG1vdmVzIGFuIEFtb3VudCBvZiBhbiBBc3NldCBmcm9tXG4gKiBhIHVzZXItY29udHJvbGxlZCBXYWxsZXQgdG8gYW5vdGhlciBBZGRyZXNzLiBUaGUgZmVlIGlzIGFzc3VtZWQgdG8gYmUgcGFpZFxuICogaW4gdGhlIG5hdGl2ZSBBc3NldCBvZiB0aGUgTmV0d29yay5cbiAqL1xuY2xhc3MgVHJhbnNmZXIge1xuICAgIC8qKlxuICAgICAqIFByaXZhdGUgY29uc3RydWN0b3IgdG8gcHJldmVudCBkaXJlY3QgaW5zdGFudGlhdGlvbiBvdXRzaWRlIG9mIHRoZSBmYWN0b3J5IG1ldGhvZHMuXG4gICAgICpcbiAgICAgKiBAaWdub3JlXG4gICAgICogQHBhcmFtIHRyYW5zZmVyTW9kZWwgLSBUaGUgVHJhbnNmZXIgbW9kZWwuXG4gICAgICogQGhpZGVjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHRyYW5zZmVyTW9kZWwpIHtcbiAgICAgICAgaWYgKCF0cmFuc2Zlck1vZGVsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUcmFuc2ZlciBtb2RlbCBjYW5ub3QgYmUgZW1wdHlcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb2RlbCA9IHRyYW5zZmVyTW9kZWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgVHJhbnNmZXJNb2RlbCBpbnRvIGEgVHJhbnNmZXIgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHRyYW5zZmVyTW9kZWwgLSBUaGUgVHJhbnNmZXIgbW9kZWwgb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIFRoZSBUcmFuc2ZlciBvYmplY3QuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21Nb2RlbCh0cmFuc2Zlck1vZGVsKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHJhbnNmZXIodHJhbnNmZXJNb2RlbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIElEIG9mIHRoZSBUcmFuc2Zlci5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBUcmFuc2ZlciBJRC5cbiAgICAgKi9cbiAgICBnZXRJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwudHJhbnNmZXJfaWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIE5ldHdvcmsgSUQgb2YgdGhlIFRyYW5zZmVyLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIE5ldHdvcmsgSUQuXG4gICAgICovXG4gICAgZ2V0TmV0d29ya0lkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5uZXR3b3JrX2lkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBXYWxsZXQgSUQgb2YgdGhlIFRyYW5zZmVyLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIFdhbGxldCBJRC5cbiAgICAgKi9cbiAgICBnZXRXYWxsZXRJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwud2FsbGV0X2lkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBGcm9tIEFkZHJlc3MgSUQgb2YgdGhlIFRyYW5zZmVyLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIEZyb20gQWRkcmVzcyBJRC5cbiAgICAgKi9cbiAgICBnZXRGcm9tQWRkcmVzc0lkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5hZGRyZXNzX2lkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBEZXN0aW5hdGlvbiBBZGRyZXNzIElEIG9mIHRoZSBUcmFuc2Zlci5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBEZXN0aW5hdGlvbiBBZGRyZXNzIElELlxuICAgICAqL1xuICAgIGdldERlc3RpbmF0aW9uQWRkcmVzc0lkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5kZXN0aW5hdGlvbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgQXNzZXQgSUQgb2YgdGhlIFRyYW5zZmVyLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIEFzc2V0IElELlxuICAgICAqL1xuICAgIGdldEFzc2V0SWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLmFzc2V0X2lkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBBbW91bnQgb2YgdGhlIFRyYW5zZmVyLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIEFtb3VudCBvZiB0aGUgQXNzZXQuXG4gICAgICovXG4gICAgZ2V0QW1vdW50KCkge1xuICAgICAgICBjb25zdCBhbW91bnQgPSBuZXcgZGVjaW1hbF9qc18xLkRlY2ltYWwodGhpcy5tb2RlbC5hbW91bnQpO1xuICAgICAgICByZXR1cm4gYW1vdW50LmRpdmlkZWRCeShuZXcgZGVjaW1hbF9qc18xLkRlY2ltYWwoMTApLnBvdyh0aGlzLm1vZGVsLmFzc2V0LmRlY2ltYWxzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIFRyYW5zYWN0aW9uIEhhc2ggb2YgdGhlIFRyYW5zZmVyLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIFRyYW5zYWN0aW9uIEhhc2ggYXMgYSBIZXggc3RyaW5nLCBvciB1bmRlZmluZWQgaWYgbm90IHlldCBhdmFpbGFibGUuXG4gICAgICovXG4gICAgZ2V0VHJhbnNhY3Rpb25IYXNoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTZW5kVHJhbnNhY3Rpb25EZWxlZ2F0ZSgpPy5nZXRUcmFuc2FjdGlvbkhhc2goKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgVHJhbnNhY3Rpb24gb2YgdGhlIFRyYW5zZmVyLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGV0aGVycy5qcyBUcmFuc2FjdGlvbiBvYmplY3QuXG4gICAgICogQHRocm93cyAoSW52YWxpZFVuc2lnbmVkUGF5bG9hZCkgSWYgdGhlIFVuc2lnbmVkIFBheWxvYWQgaXMgaW52YWxpZC5cbiAgICAgKi9cbiAgICBnZXRSYXdUcmFuc2FjdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmdldFRyYW5zYWN0aW9uKCkpXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRUcmFuc2FjdGlvbigpLnJhd1RyYW5zYWN0aW9uKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNpZ25zIHRoZSBUcmFuc2ZlciB3aXRoIHRoZSBwcm92aWRlZCBrZXkgYW5kIHJldHVybnMgdGhlIGhleCBzaWduYXR1cmVcbiAgICAgKiByZXF1aXJlZCBmb3IgYnJvYWRjYXN0aW5nIHRoZSBUcmFuc2Zlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBrZXkgLSBUaGUga2V5IHRvIHNpZ24gdGhlIFRyYW5zZmVyIHdpdGhcbiAgICAgKiBAcmV0dXJucyBUaGUgaGV4LWVuY29kZWQgc2lnbmVkIHBheWxvYWRcbiAgICAgKi9cbiAgICBhc3luYyBzaWduKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTZW5kVHJhbnNhY3Rpb25EZWxlZ2F0ZSgpLnNpZ24oa2V5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgU3RhdHVzIG9mIHRoZSBUcmFuc2Zlci5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBTdGF0dXMgb2YgdGhlIFRyYW5zZmVyLlxuICAgICAqL1xuICAgIGdldFN0YXR1cygpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLmdldFNlbmRUcmFuc2FjdGlvbkRlbGVnYXRlKCkuZ2V0U3RhdHVzKCkpIHtcbiAgICAgICAgICAgIGNhc2UgdHlwZXNfMS5UcmFuc2FjdGlvblN0YXR1cy5QRU5ESU5HOlxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlc18xLlRyYW5zZmVyU3RhdHVzLlBFTkRJTkc7XG4gICAgICAgICAgICBjYXNlIHR5cGVzXzEuU3BvbnNvcmVkU2VuZFN0YXR1cy5QRU5ESU5HOlxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlc18xLlRyYW5zZmVyU3RhdHVzLlBFTkRJTkc7XG4gICAgICAgICAgICBjYXNlIHR5cGVzXzEuU3BvbnNvcmVkU2VuZFN0YXR1cy5TSUdORUQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVzXzEuVHJhbnNmZXJTdGF0dXMuUEVORElORztcbiAgICAgICAgICAgIGNhc2UgdHlwZXNfMS5UcmFuc2FjdGlvblN0YXR1cy5CUk9BRENBU1Q6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVzXzEuVHJhbnNmZXJTdGF0dXMuQlJPQURDQVNUO1xuICAgICAgICAgICAgY2FzZSB0eXBlc18xLlNwb25zb3JlZFNlbmRTdGF0dXMuU1VCTUlUVEVEOlxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlc18xLlRyYW5zZmVyU3RhdHVzLkJST0FEQ0FTVDtcbiAgICAgICAgICAgIGNhc2UgdHlwZXNfMS5UcmFuc2FjdGlvblN0YXR1cy5DT01QTEVURTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZXNfMS5UcmFuc2ZlclN0YXR1cy5DT01QTEVURTtcbiAgICAgICAgICAgIGNhc2UgdHlwZXNfMS5TcG9uc29yZWRTZW5kU3RhdHVzLkNPTVBMRVRFOlxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlc18xLlRyYW5zZmVyU3RhdHVzLkNPTVBMRVRFO1xuICAgICAgICAgICAgY2FzZSB0eXBlc18xLlRyYW5zYWN0aW9uU3RhdHVzLkZBSUxFRDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZXNfMS5UcmFuc2ZlclN0YXR1cy5GQUlMRUQ7XG4gICAgICAgICAgICBjYXNlIHR5cGVzXzEuU3BvbnNvcmVkU2VuZFN0YXR1cy5GQUlMRUQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVzXzEuVHJhbnNmZXJTdGF0dXMuRkFJTEVEO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIFRyYW5zYWN0aW9uIG9mIHRoZSBUcmFuc2Zlci5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBUcmFuc2FjdGlvblxuICAgICAqL1xuICAgIGdldFRyYW5zYWN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMubW9kZWwudHJhbnNhY3Rpb24pXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gbmV3IHRyYW5zYWN0aW9uXzEuVHJhbnNhY3Rpb24odGhpcy5tb2RlbC50cmFuc2FjdGlvbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIFNwb25zb3JlZCBTZW5kIG9mIHRoZSBUcmFuc2Zlci5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBTcG9uc29yZWQgU2VuZFxuICAgICAqL1xuICAgIGdldFNwb25zb3JlZFNlbmQoKSB7XG4gICAgICAgIGlmICghdGhpcy5tb2RlbC5zcG9uc29yZWRfc2VuZClcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBuZXcgc3BvbnNvcmVkX3NlbmRfMS5TcG9uc29yZWRTZW5kKHRoaXMubW9kZWwuc3BvbnNvcmVkX3NlbmQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBTZW5kIFRyYW5zYWN0aW9uIERlbGVnYXRlIG9mIHRoZSBUcmFuc2Zlci5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEVpdGhlciB0aGUgVHJhbnNhY3Rpb24gb3IgdGhlIFNwb25zb3JlZCBTZW5kXG4gICAgICovXG4gICAgZ2V0U2VuZFRyYW5zYWN0aW9uRGVsZWdhdGUoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5nZXRUcmFuc2FjdGlvbigpID8gdGhpcy5nZXRTcG9uc29yZWRTZW5kKCkgOiB0aGlzLmdldFRyYW5zYWN0aW9uKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxpbmsgdG8gdGhlIFRyYW5zYWN0aW9uIG9uIHRoZSBibG9ja2NoYWluIGV4cGxvcmVyLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGxpbmsgdG8gdGhlIFRyYW5zYWN0aW9uIG9uIHRoZSBibG9ja2NoYWluIGV4cGxvcmVyLlxuICAgICAqL1xuICAgIGdldFRyYW5zYWN0aW9uTGluaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2VuZFRyYW5zYWN0aW9uRGVsZWdhdGUoKT8uZ2V0VHJhbnNhY3Rpb25MaW5rKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJyb2FkY2FzdHMgdGhlIFRyYW5zZmVyIHRvIHRoZSBOZXR3b3JrLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIFRyYW5zZmVyIG9iamVjdFxuICAgICAqIEB0aHJvd3Mge0FQSUVycm9yfSBpZiB0aGUgQVBJIHJlcXVlc3QgdG8gYnJvYWRjYXN0IGEgVHJhbnNmZXIgZmFpbHMuXG4gICAgICovXG4gICAgYXN5bmMgYnJvYWRjYXN0KCkge1xuICAgICAgICBpZiAoIXRoaXMuZ2V0U2VuZFRyYW5zYWN0aW9uRGVsZWdhdGUoKT8uaXNTaWduZWQoKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBicm9hZGNhc3QgdW5zaWduZWQgVHJhbnNmZXJcIik7XG4gICAgICAgIGNvbnN0IGJyb2FkY2FzdFRyYW5zZmVyUmVxdWVzdCA9IHtcbiAgICAgICAgICAgIHNpZ25lZF9wYXlsb2FkOiB0aGlzLmdldFNlbmRUcmFuc2FjdGlvbkRlbGVnYXRlKCkuZ2V0U2lnbmF0dXJlKCksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY29pbmJhc2VfMS5Db2luYmFzZS5hcGlDbGllbnRzLnRyYW5zZmVyLmJyb2FkY2FzdFRyYW5zZmVyKHRoaXMuZ2V0V2FsbGV0SWQoKSwgdGhpcy5nZXRGcm9tQWRkcmVzc0lkKCksIHRoaXMuZ2V0SWQoKSwgYnJvYWRjYXN0VHJhbnNmZXJSZXF1ZXN0KTtcbiAgICAgICAgcmV0dXJuIFRyYW5zZmVyLmZyb21Nb2RlbChyZXNwb25zZS5kYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2FpdHMgZm9yIHRoZSBUcmFuc2ZlciB0byBiZSBjb25maXJtZWQgb24gdGhlIE5ldHdvcmsgb3IgZmFpbCBvbiBjaGFpbi5cbiAgICAgKiBXYWl0cyB1bnRpbCB0aGUgVHJhbnNmZXIgaXMgY29tcGxldGVkIG9yIGZhaWxlZCBvbi1jaGFpbiBieSBwb2xsaW5nIGF0IHRoZSBnaXZlbiBpbnRlcnZhbC5cbiAgICAgKiBSYWlzZXMgYW4gZXJyb3IgaWYgdGhlIFRyYWRlIHRha2VzIGxvbmdlciB0aGFuIHRoZSBnaXZlbiB0aW1lb3V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyB0byBjb25maWd1cmUgdGhlIHdhaXQgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIG9wdGlvbnMuaW50ZXJ2YWxTZWNvbmRzIC0gVGhlIGludGVydmFsIHRvIGNoZWNrIHRoZSBzdGF0dXMgb2YgdGhlIFRyYW5zZmVyLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnRpbWVvdXRTZWNvbmRzIC0gVGhlIG1heGltdW0gdGltZSB0byB3YWl0IGZvciB0aGUgVHJhbnNmZXIgdG8gYmUgY29uZmlybWVkLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIFRyYW5zZmVyIG9iamVjdCBpbiBhIHRlcm1pbmFsIHN0YXRlLlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBpZiB0aGUgVHJhbnNmZXIgdGltZXMgb3V0LlxuICAgICAqL1xuICAgIGFzeW5jIHdhaXQoeyBpbnRlcnZhbFNlY29uZHMgPSAwLjIsIHRpbWVvdXRTZWNvbmRzID0gMTAgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIHdoaWxlIChEYXRlLm5vdygpIC0gc3RhcnRUaW1lIDwgdGltZW91dFNlY29uZHMgKiAxMDAwKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnJlbG9hZCgpO1xuICAgICAgICAgICAgLy8gSWYgdGhlIFRyYW5zZmVyIGlzIGluIGEgdGVybWluYWwgc3RhdGUsIHJldHVybiB0aGUgVHJhbnNmZXIuXG4gICAgICAgICAgICBjb25zdCBzdGF0dXMgPSB0aGlzLmdldFN0YXR1cygpO1xuICAgICAgICAgICAgaWYgKHN0YXR1cyA9PT0gdHlwZXNfMS5UcmFuc2ZlclN0YXR1cy5DT01QTEVURSB8fCBzdGF0dXMgPT09IHR5cGVzXzEuVHJhbnNmZXJTdGF0dXMuRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCAoMCwgdXRpbHNfMS5kZWxheSkoaW50ZXJ2YWxTZWNvbmRzKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVGltZW91dEVycm9yKFwiVHJhbnNmZXIgdGltZWQgb3V0XCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWxvYWRzIHRoZSBUcmFuc2ZlciBtb2RlbCB3aXRoIHRoZSBsYXRlc3QgZGF0YSBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtBUElFcnJvcn0gaWYgdGhlIEFQSSByZXF1ZXN0IHRvIGdldCBhIFRyYW5zZmVyIGZhaWxzLlxuICAgICAqL1xuICAgIGFzeW5jIHJlbG9hZCgpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29pbmJhc2VfMS5Db2luYmFzZS5hcGlDbGllbnRzLnRyYW5zZmVyLmdldFRyYW5zZmVyKHRoaXMuZ2V0V2FsbGV0SWQoKSwgdGhpcy5nZXRGcm9tQWRkcmVzc0lkKCksIHRoaXMuZ2V0SWQoKSk7XG4gICAgICAgIHRoaXMubW9kZWwgPSByZXN1bHQ/LmRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIFRyYW5zZmVyLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgVHJhbnNmZXIuXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAoYFRyYW5zZmVye3RyYW5zZmVySWQ6ICcke3RoaXMuZ2V0SWQoKX0nLCBuZXR3b3JrSWQ6ICcke3RoaXMuZ2V0TmV0d29ya0lkKCl9JywgYCArXG4gICAgICAgICAgICBgZnJvbUFkZHJlc3NJZDogJyR7dGhpcy5nZXRGcm9tQWRkcmVzc0lkKCl9JywgZGVzdGluYXRpb25BZGRyZXNzSWQ6ICcke3RoaXMuZ2V0RGVzdGluYXRpb25BZGRyZXNzSWQoKX0nLCBgICtcbiAgICAgICAgICAgIGBhc3NldElkOiAnJHt0aGlzLmdldEFzc2V0SWQoKX0nLCBhbW91bnQ6ICcke3RoaXMuZ2V0QW1vdW50KCl9JywgdHJhbnNhY3Rpb25IYXNoOiAnJHt0aGlzLmdldFRyYW5zYWN0aW9uSGFzaCgpfScsIGAgK1xuICAgICAgICAgICAgYHRyYW5zYWN0aW9uTGluazogJyR7dGhpcy5nZXRUcmFuc2FjdGlvbkxpbmsoKX0nLCBzdGF0dXM6ICcke3RoaXMuZ2V0U3RhdHVzKCl9J31gKTtcbiAgICB9XG59XG5leHBvcnRzLlRyYW5zZmVyID0gVHJhbnNmZXI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/transfer.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/types.js":
/*!********************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/types.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SmartContractType = exports.StakeOptionsMode = exports.ServerSignerStatus = exports.isMnemonicSeedPhrase = exports.isWalletData = exports.FundOperationStatus = exports.PayloadSignatureStatus = exports.StakingRewardFormat = exports.ValidatorStatus = exports.SponsoredSendStatus = exports.TransactionStatus = exports.TransferStatus = void 0;\n/**\n * Transfer status type definition.\n */\nvar TransferStatus;\n(function (TransferStatus) {\n    TransferStatus[\"PENDING\"] = \"pending\";\n    TransferStatus[\"BROADCAST\"] = \"broadcast\";\n    TransferStatus[\"COMPLETE\"] = \"complete\";\n    TransferStatus[\"FAILED\"] = \"failed\";\n})(TransferStatus || (exports.TransferStatus = TransferStatus = {}));\n/**\n * Transaction status type definition.\n */\nvar TransactionStatus;\n(function (TransactionStatus) {\n    TransactionStatus[\"PENDING\"] = \"pending\";\n    TransactionStatus[\"SIGNED\"] = \"signed\";\n    TransactionStatus[\"BROADCAST\"] = \"broadcast\";\n    TransactionStatus[\"COMPLETE\"] = \"complete\";\n    TransactionStatus[\"FAILED\"] = \"failed\";\n    TransactionStatus[\"UNSPECIFIED\"] = \"unspecified\";\n})(TransactionStatus || (exports.TransactionStatus = TransactionStatus = {}));\n/**\n * Sponsored Send status type definition.\n */\nvar SponsoredSendStatus;\n(function (SponsoredSendStatus) {\n    SponsoredSendStatus[\"PENDING\"] = \"pending\";\n    SponsoredSendStatus[\"SIGNED\"] = \"signed\";\n    SponsoredSendStatus[\"SUBMITTED\"] = \"submitted\";\n    SponsoredSendStatus[\"COMPLETE\"] = \"complete\";\n    SponsoredSendStatus[\"FAILED\"] = \"failed\";\n})(SponsoredSendStatus || (exports.SponsoredSendStatus = SponsoredSendStatus = {}));\n/**\n * Validator status type definition.\n * Represents the various states a validator can be in.\n */\nvar ValidatorStatus;\n(function (ValidatorStatus) {\n    ValidatorStatus[\"UNKNOWN\"] = \"unknown\";\n    ValidatorStatus[\"PROVISIONING\"] = \"provisioning\";\n    ValidatorStatus[\"PROVISIONED\"] = \"provisioned\";\n    ValidatorStatus[\"DEPOSITED\"] = \"deposited\";\n    ValidatorStatus[\"PENDING_ACTIVATION\"] = \"pending_activation\";\n    ValidatorStatus[\"ACTIVE\"] = \"active\";\n    ValidatorStatus[\"EXITING\"] = \"exiting\";\n    ValidatorStatus[\"EXITED\"] = \"exited\";\n    ValidatorStatus[\"WITHDRAWAL_AVAILABLE\"] = \"withdrawal_available\";\n    ValidatorStatus[\"WITHDRAWAL_COMPLETE\"] = \"withdrawal_complete\";\n    ValidatorStatus[\"ACTIVE_SLASHED\"] = \"active_slashed\";\n    ValidatorStatus[\"EXITED_SLASHED\"] = \"exited_slashed\";\n    ValidatorStatus[\"REAPED\"] = \"reaped\";\n})(ValidatorStatus || (exports.ValidatorStatus = ValidatorStatus = {}));\n/**\n * Staking reward format type definition.\n * Represents the format in which staking rewards can be queried.\n */\nvar StakingRewardFormat;\n(function (StakingRewardFormat) {\n    StakingRewardFormat[\"USD\"] = \"usd\";\n    StakingRewardFormat[\"NATIVE\"] = \"native\";\n})(StakingRewardFormat || (exports.StakingRewardFormat = StakingRewardFormat = {}));\n/**\n * Payload Signature status type definition.\n */\nvar PayloadSignatureStatus;\n(function (PayloadSignatureStatus) {\n    PayloadSignatureStatus[\"PENDING\"] = \"pending\";\n    PayloadSignatureStatus[\"SIGNED\"] = \"signed\";\n    PayloadSignatureStatus[\"FAILED\"] = \"failed\";\n})(PayloadSignatureStatus || (exports.PayloadSignatureStatus = PayloadSignatureStatus = {}));\n/**\n * Fund Operation status type definition.\n */\nvar FundOperationStatus;\n(function (FundOperationStatus) {\n    FundOperationStatus[\"PENDING\"] = \"pending\";\n    FundOperationStatus[\"COMPLETE\"] = \"complete\";\n    FundOperationStatus[\"FAILED\"] = \"failed\";\n})(FundOperationStatus || (exports.FundOperationStatus = FundOperationStatus = {}));\n/**\n * Type guard to check if data matches the appropriate WalletData format.\n * WalletData must have:\n * - exactly one of (walletId or wallet_id)\n * - at most one of (networkId or network_id)\n * - a seed\n *\n * @param data - The data to check\n * @returns True if data matches the appropriate WalletData format\n */\nfunction isWalletData(data) {\n    if (typeof data !== \"object\" || data === null) {\n        return false;\n    }\n    const { walletId, wallet_id, networkId, network_id, seed } = data;\n    // Check that exactly one of walletId or wallet_id is present (but not both)\n    const hasWalletId = typeof walletId === \"string\";\n    const hasWalletSnakeId = typeof wallet_id === \"string\";\n    if (!(hasWalletId !== hasWalletSnakeId)) {\n        return false;\n    }\n    // Check that at most one of networkId or network_id is present (but not both)\n    const hasNetworkId = typeof networkId === \"string\";\n    const hasNetworkSnakeId = typeof network_id === \"string\";\n    if (hasNetworkId && hasNetworkSnakeId) {\n        return false;\n    }\n    // Check that seed is present and is a string\n    return typeof seed === \"string\";\n}\nexports.isWalletData = isWalletData;\n/**\n * Type guard to check if data matches the MnemonicSeedPhrase format.\n *\n * @param data - The data to check\n * @returns True if data matches the MnemonicSeedPhrase format\n */\nfunction isMnemonicSeedPhrase(data) {\n    if (typeof data !== \"object\" || data === null) {\n        return false;\n    }\n    const { mnemonicPhrase } = data;\n    return typeof mnemonicPhrase === \"string\";\n}\nexports.isMnemonicSeedPhrase = isMnemonicSeedPhrase;\n/**\n * ServerSigner status type definition.\n */\nvar ServerSignerStatus;\n(function (ServerSignerStatus) {\n    ServerSignerStatus[\"PENDING\"] = \"pending_seed_creation\";\n    ServerSignerStatus[\"ACTIVE\"] = \"active_seed\";\n})(ServerSignerStatus || (exports.ServerSignerStatus = ServerSignerStatus = {}));\n/**\n * StakeOptionsMode type definition.\n */\nvar StakeOptionsMode;\n(function (StakeOptionsMode) {\n    /**\n     * Defaults to the mode specific to the asset.\n     */\n    StakeOptionsMode[\"DEFAULT\"] = \"default\";\n    /**\n     * Partial represents Partial Ethereum Staking mode.\n     */\n    StakeOptionsMode[\"PARTIAL\"] = \"partial\";\n    /**\n     * Native represents Native Ethereum Staking mode.\n     */\n    StakeOptionsMode[\"NATIVE\"] = \"native\";\n})(StakeOptionsMode || (exports.StakeOptionsMode = StakeOptionsMode = {}));\n/**\n * Smart Contract Type\n */\nvar SmartContractType;\n(function (SmartContractType) {\n    SmartContractType[\"ERC20\"] = \"erc20\";\n    SmartContractType[\"ERC721\"] = \"erc721\";\n    SmartContractType[\"ERC1155\"] = \"erc1155\";\n    SmartContractType[\"CUSTOM\"] = \"custom\";\n})(SmartContractType || (exports.SmartContractType = SmartContractType = {}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL3R5cGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHlCQUF5QixHQUFHLHdCQUF3QixHQUFHLDBCQUEwQixHQUFHLDRCQUE0QixHQUFHLG9CQUFvQixHQUFHLDJCQUEyQixHQUFHLDhCQUE4QixHQUFHLDJCQUEyQixHQUFHLHVCQUF1QixHQUFHLDJCQUEyQixHQUFHLHlCQUF5QixHQUFHLHNCQUFzQjtBQUNqVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHFCQUFxQixzQkFBc0Isc0JBQXNCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdCQUF3Qix5QkFBeUIseUJBQXlCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwQkFBMEIsMkJBQTJCLDJCQUEyQjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0JBQXNCLHVCQUF1Qix1QkFBdUI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMEJBQTBCLDJCQUEyQiwyQkFBMkI7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNkJBQTZCLDhCQUE4Qiw4QkFBOEI7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMEJBQTBCLDJCQUEyQiwyQkFBMkI7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbURBQW1EO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksaUJBQWlCO0FBQzdCO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHlCQUF5QiwwQkFBMEIsMEJBQTBCO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHVCQUF1Qix3QkFBd0Isd0JBQXdCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0JBQXdCLHlCQUF5Qix5QkFBeUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXJ2aXZhbC1mdW4vLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL3R5cGVzLmpzPzhkNWYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNtYXJ0Q29udHJhY3RUeXBlID0gZXhwb3J0cy5TdGFrZU9wdGlvbnNNb2RlID0gZXhwb3J0cy5TZXJ2ZXJTaWduZXJTdGF0dXMgPSBleHBvcnRzLmlzTW5lbW9uaWNTZWVkUGhyYXNlID0gZXhwb3J0cy5pc1dhbGxldERhdGEgPSBleHBvcnRzLkZ1bmRPcGVyYXRpb25TdGF0dXMgPSBleHBvcnRzLlBheWxvYWRTaWduYXR1cmVTdGF0dXMgPSBleHBvcnRzLlN0YWtpbmdSZXdhcmRGb3JtYXQgPSBleHBvcnRzLlZhbGlkYXRvclN0YXR1cyA9IGV4cG9ydHMuU3BvbnNvcmVkU2VuZFN0YXR1cyA9IGV4cG9ydHMuVHJhbnNhY3Rpb25TdGF0dXMgPSBleHBvcnRzLlRyYW5zZmVyU3RhdHVzID0gdm9pZCAwO1xuLyoqXG4gKiBUcmFuc2ZlciBzdGF0dXMgdHlwZSBkZWZpbml0aW9uLlxuICovXG52YXIgVHJhbnNmZXJTdGF0dXM7XG4oZnVuY3Rpb24gKFRyYW5zZmVyU3RhdHVzKSB7XG4gICAgVHJhbnNmZXJTdGF0dXNbXCJQRU5ESU5HXCJdID0gXCJwZW5kaW5nXCI7XG4gICAgVHJhbnNmZXJTdGF0dXNbXCJCUk9BRENBU1RcIl0gPSBcImJyb2FkY2FzdFwiO1xuICAgIFRyYW5zZmVyU3RhdHVzW1wiQ09NUExFVEVcIl0gPSBcImNvbXBsZXRlXCI7XG4gICAgVHJhbnNmZXJTdGF0dXNbXCJGQUlMRURcIl0gPSBcImZhaWxlZFwiO1xufSkoVHJhbnNmZXJTdGF0dXMgfHwgKGV4cG9ydHMuVHJhbnNmZXJTdGF0dXMgPSBUcmFuc2ZlclN0YXR1cyA9IHt9KSk7XG4vKipcbiAqIFRyYW5zYWN0aW9uIHN0YXR1cyB0eXBlIGRlZmluaXRpb24uXG4gKi9cbnZhciBUcmFuc2FjdGlvblN0YXR1cztcbihmdW5jdGlvbiAoVHJhbnNhY3Rpb25TdGF0dXMpIHtcbiAgICBUcmFuc2FjdGlvblN0YXR1c1tcIlBFTkRJTkdcIl0gPSBcInBlbmRpbmdcIjtcbiAgICBUcmFuc2FjdGlvblN0YXR1c1tcIlNJR05FRFwiXSA9IFwic2lnbmVkXCI7XG4gICAgVHJhbnNhY3Rpb25TdGF0dXNbXCJCUk9BRENBU1RcIl0gPSBcImJyb2FkY2FzdFwiO1xuICAgIFRyYW5zYWN0aW9uU3RhdHVzW1wiQ09NUExFVEVcIl0gPSBcImNvbXBsZXRlXCI7XG4gICAgVHJhbnNhY3Rpb25TdGF0dXNbXCJGQUlMRURcIl0gPSBcImZhaWxlZFwiO1xuICAgIFRyYW5zYWN0aW9uU3RhdHVzW1wiVU5TUEVDSUZJRURcIl0gPSBcInVuc3BlY2lmaWVkXCI7XG59KShUcmFuc2FjdGlvblN0YXR1cyB8fCAoZXhwb3J0cy5UcmFuc2FjdGlvblN0YXR1cyA9IFRyYW5zYWN0aW9uU3RhdHVzID0ge30pKTtcbi8qKlxuICogU3BvbnNvcmVkIFNlbmQgc3RhdHVzIHR5cGUgZGVmaW5pdGlvbi5cbiAqL1xudmFyIFNwb25zb3JlZFNlbmRTdGF0dXM7XG4oZnVuY3Rpb24gKFNwb25zb3JlZFNlbmRTdGF0dXMpIHtcbiAgICBTcG9uc29yZWRTZW5kU3RhdHVzW1wiUEVORElOR1wiXSA9IFwicGVuZGluZ1wiO1xuICAgIFNwb25zb3JlZFNlbmRTdGF0dXNbXCJTSUdORURcIl0gPSBcInNpZ25lZFwiO1xuICAgIFNwb25zb3JlZFNlbmRTdGF0dXNbXCJTVUJNSVRURURcIl0gPSBcInN1Ym1pdHRlZFwiO1xuICAgIFNwb25zb3JlZFNlbmRTdGF0dXNbXCJDT01QTEVURVwiXSA9IFwiY29tcGxldGVcIjtcbiAgICBTcG9uc29yZWRTZW5kU3RhdHVzW1wiRkFJTEVEXCJdID0gXCJmYWlsZWRcIjtcbn0pKFNwb25zb3JlZFNlbmRTdGF0dXMgfHwgKGV4cG9ydHMuU3BvbnNvcmVkU2VuZFN0YXR1cyA9IFNwb25zb3JlZFNlbmRTdGF0dXMgPSB7fSkpO1xuLyoqXG4gKiBWYWxpZGF0b3Igc3RhdHVzIHR5cGUgZGVmaW5pdGlvbi5cbiAqIFJlcHJlc2VudHMgdGhlIHZhcmlvdXMgc3RhdGVzIGEgdmFsaWRhdG9yIGNhbiBiZSBpbi5cbiAqL1xudmFyIFZhbGlkYXRvclN0YXR1cztcbihmdW5jdGlvbiAoVmFsaWRhdG9yU3RhdHVzKSB7XG4gICAgVmFsaWRhdG9yU3RhdHVzW1wiVU5LTk9XTlwiXSA9IFwidW5rbm93blwiO1xuICAgIFZhbGlkYXRvclN0YXR1c1tcIlBST1ZJU0lPTklOR1wiXSA9IFwicHJvdmlzaW9uaW5nXCI7XG4gICAgVmFsaWRhdG9yU3RhdHVzW1wiUFJPVklTSU9ORURcIl0gPSBcInByb3Zpc2lvbmVkXCI7XG4gICAgVmFsaWRhdG9yU3RhdHVzW1wiREVQT1NJVEVEXCJdID0gXCJkZXBvc2l0ZWRcIjtcbiAgICBWYWxpZGF0b3JTdGF0dXNbXCJQRU5ESU5HX0FDVElWQVRJT05cIl0gPSBcInBlbmRpbmdfYWN0aXZhdGlvblwiO1xuICAgIFZhbGlkYXRvclN0YXR1c1tcIkFDVElWRVwiXSA9IFwiYWN0aXZlXCI7XG4gICAgVmFsaWRhdG9yU3RhdHVzW1wiRVhJVElOR1wiXSA9IFwiZXhpdGluZ1wiO1xuICAgIFZhbGlkYXRvclN0YXR1c1tcIkVYSVRFRFwiXSA9IFwiZXhpdGVkXCI7XG4gICAgVmFsaWRhdG9yU3RhdHVzW1wiV0lUSERSQVdBTF9BVkFJTEFCTEVcIl0gPSBcIndpdGhkcmF3YWxfYXZhaWxhYmxlXCI7XG4gICAgVmFsaWRhdG9yU3RhdHVzW1wiV0lUSERSQVdBTF9DT01QTEVURVwiXSA9IFwid2l0aGRyYXdhbF9jb21wbGV0ZVwiO1xuICAgIFZhbGlkYXRvclN0YXR1c1tcIkFDVElWRV9TTEFTSEVEXCJdID0gXCJhY3RpdmVfc2xhc2hlZFwiO1xuICAgIFZhbGlkYXRvclN0YXR1c1tcIkVYSVRFRF9TTEFTSEVEXCJdID0gXCJleGl0ZWRfc2xhc2hlZFwiO1xuICAgIFZhbGlkYXRvclN0YXR1c1tcIlJFQVBFRFwiXSA9IFwicmVhcGVkXCI7XG59KShWYWxpZGF0b3JTdGF0dXMgfHwgKGV4cG9ydHMuVmFsaWRhdG9yU3RhdHVzID0gVmFsaWRhdG9yU3RhdHVzID0ge30pKTtcbi8qKlxuICogU3Rha2luZyByZXdhcmQgZm9ybWF0IHR5cGUgZGVmaW5pdGlvbi5cbiAqIFJlcHJlc2VudHMgdGhlIGZvcm1hdCBpbiB3aGljaCBzdGFraW5nIHJld2FyZHMgY2FuIGJlIHF1ZXJpZWQuXG4gKi9cbnZhciBTdGFraW5nUmV3YXJkRm9ybWF0O1xuKGZ1bmN0aW9uIChTdGFraW5nUmV3YXJkRm9ybWF0KSB7XG4gICAgU3Rha2luZ1Jld2FyZEZvcm1hdFtcIlVTRFwiXSA9IFwidXNkXCI7XG4gICAgU3Rha2luZ1Jld2FyZEZvcm1hdFtcIk5BVElWRVwiXSA9IFwibmF0aXZlXCI7XG59KShTdGFraW5nUmV3YXJkRm9ybWF0IHx8IChleHBvcnRzLlN0YWtpbmdSZXdhcmRGb3JtYXQgPSBTdGFraW5nUmV3YXJkRm9ybWF0ID0ge30pKTtcbi8qKlxuICogUGF5bG9hZCBTaWduYXR1cmUgc3RhdHVzIHR5cGUgZGVmaW5pdGlvbi5cbiAqL1xudmFyIFBheWxvYWRTaWduYXR1cmVTdGF0dXM7XG4oZnVuY3Rpb24gKFBheWxvYWRTaWduYXR1cmVTdGF0dXMpIHtcbiAgICBQYXlsb2FkU2lnbmF0dXJlU3RhdHVzW1wiUEVORElOR1wiXSA9IFwicGVuZGluZ1wiO1xuICAgIFBheWxvYWRTaWduYXR1cmVTdGF0dXNbXCJTSUdORURcIl0gPSBcInNpZ25lZFwiO1xuICAgIFBheWxvYWRTaWduYXR1cmVTdGF0dXNbXCJGQUlMRURcIl0gPSBcImZhaWxlZFwiO1xufSkoUGF5bG9hZFNpZ25hdHVyZVN0YXR1cyB8fCAoZXhwb3J0cy5QYXlsb2FkU2lnbmF0dXJlU3RhdHVzID0gUGF5bG9hZFNpZ25hdHVyZVN0YXR1cyA9IHt9KSk7XG4vKipcbiAqIEZ1bmQgT3BlcmF0aW9uIHN0YXR1cyB0eXBlIGRlZmluaXRpb24uXG4gKi9cbnZhciBGdW5kT3BlcmF0aW9uU3RhdHVzO1xuKGZ1bmN0aW9uIChGdW5kT3BlcmF0aW9uU3RhdHVzKSB7XG4gICAgRnVuZE9wZXJhdGlvblN0YXR1c1tcIlBFTkRJTkdcIl0gPSBcInBlbmRpbmdcIjtcbiAgICBGdW5kT3BlcmF0aW9uU3RhdHVzW1wiQ09NUExFVEVcIl0gPSBcImNvbXBsZXRlXCI7XG4gICAgRnVuZE9wZXJhdGlvblN0YXR1c1tcIkZBSUxFRFwiXSA9IFwiZmFpbGVkXCI7XG59KShGdW5kT3BlcmF0aW9uU3RhdHVzIHx8IChleHBvcnRzLkZ1bmRPcGVyYXRpb25TdGF0dXMgPSBGdW5kT3BlcmF0aW9uU3RhdHVzID0ge30pKTtcbi8qKlxuICogVHlwZSBndWFyZCB0byBjaGVjayBpZiBkYXRhIG1hdGNoZXMgdGhlIGFwcHJvcHJpYXRlIFdhbGxldERhdGEgZm9ybWF0LlxuICogV2FsbGV0RGF0YSBtdXN0IGhhdmU6XG4gKiAtIGV4YWN0bHkgb25lIG9mICh3YWxsZXRJZCBvciB3YWxsZXRfaWQpXG4gKiAtIGF0IG1vc3Qgb25lIG9mIChuZXR3b3JrSWQgb3IgbmV0d29ya19pZClcbiAqIC0gYSBzZWVkXG4gKlxuICogQHBhcmFtIGRhdGEgLSBUaGUgZGF0YSB0byBjaGVja1xuICogQHJldHVybnMgVHJ1ZSBpZiBkYXRhIG1hdGNoZXMgdGhlIGFwcHJvcHJpYXRlIFdhbGxldERhdGEgZm9ybWF0XG4gKi9cbmZ1bmN0aW9uIGlzV2FsbGV0RGF0YShkYXRhKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhICE9PSBcIm9iamVjdFwiIHx8IGRhdGEgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCB7IHdhbGxldElkLCB3YWxsZXRfaWQsIG5ldHdvcmtJZCwgbmV0d29ya19pZCwgc2VlZCB9ID0gZGF0YTtcbiAgICAvLyBDaGVjayB0aGF0IGV4YWN0bHkgb25lIG9mIHdhbGxldElkIG9yIHdhbGxldF9pZCBpcyBwcmVzZW50IChidXQgbm90IGJvdGgpXG4gICAgY29uc3QgaGFzV2FsbGV0SWQgPSB0eXBlb2Ygd2FsbGV0SWQgPT09IFwic3RyaW5nXCI7XG4gICAgY29uc3QgaGFzV2FsbGV0U25ha2VJZCA9IHR5cGVvZiB3YWxsZXRfaWQgPT09IFwic3RyaW5nXCI7XG4gICAgaWYgKCEoaGFzV2FsbGV0SWQgIT09IGhhc1dhbGxldFNuYWtlSWQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gQ2hlY2sgdGhhdCBhdCBtb3N0IG9uZSBvZiBuZXR3b3JrSWQgb3IgbmV0d29ya19pZCBpcyBwcmVzZW50IChidXQgbm90IGJvdGgpXG4gICAgY29uc3QgaGFzTmV0d29ya0lkID0gdHlwZW9mIG5ldHdvcmtJZCA9PT0gXCJzdHJpbmdcIjtcbiAgICBjb25zdCBoYXNOZXR3b3JrU25ha2VJZCA9IHR5cGVvZiBuZXR3b3JrX2lkID09PSBcInN0cmluZ1wiO1xuICAgIGlmIChoYXNOZXR3b3JrSWQgJiYgaGFzTmV0d29ya1NuYWtlSWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBDaGVjayB0aGF0IHNlZWQgaXMgcHJlc2VudCBhbmQgaXMgYSBzdHJpbmdcbiAgICByZXR1cm4gdHlwZW9mIHNlZWQgPT09IFwic3RyaW5nXCI7XG59XG5leHBvcnRzLmlzV2FsbGV0RGF0YSA9IGlzV2FsbGV0RGF0YTtcbi8qKlxuICogVHlwZSBndWFyZCB0byBjaGVjayBpZiBkYXRhIG1hdGNoZXMgdGhlIE1uZW1vbmljU2VlZFBocmFzZSBmb3JtYXQuXG4gKlxuICogQHBhcmFtIGRhdGEgLSBUaGUgZGF0YSB0byBjaGVja1xuICogQHJldHVybnMgVHJ1ZSBpZiBkYXRhIG1hdGNoZXMgdGhlIE1uZW1vbmljU2VlZFBocmFzZSBmb3JtYXRcbiAqL1xuZnVuY3Rpb24gaXNNbmVtb25pY1NlZWRQaHJhc2UoZGF0YSkge1xuICAgIGlmICh0eXBlb2YgZGF0YSAhPT0gXCJvYmplY3RcIiB8fCBkYXRhID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgeyBtbmVtb25pY1BocmFzZSB9ID0gZGF0YTtcbiAgICByZXR1cm4gdHlwZW9mIG1uZW1vbmljUGhyYXNlID09PSBcInN0cmluZ1wiO1xufVxuZXhwb3J0cy5pc01uZW1vbmljU2VlZFBocmFzZSA9IGlzTW5lbW9uaWNTZWVkUGhyYXNlO1xuLyoqXG4gKiBTZXJ2ZXJTaWduZXIgc3RhdHVzIHR5cGUgZGVmaW5pdGlvbi5cbiAqL1xudmFyIFNlcnZlclNpZ25lclN0YXR1cztcbihmdW5jdGlvbiAoU2VydmVyU2lnbmVyU3RhdHVzKSB7XG4gICAgU2VydmVyU2lnbmVyU3RhdHVzW1wiUEVORElOR1wiXSA9IFwicGVuZGluZ19zZWVkX2NyZWF0aW9uXCI7XG4gICAgU2VydmVyU2lnbmVyU3RhdHVzW1wiQUNUSVZFXCJdID0gXCJhY3RpdmVfc2VlZFwiO1xufSkoU2VydmVyU2lnbmVyU3RhdHVzIHx8IChleHBvcnRzLlNlcnZlclNpZ25lclN0YXR1cyA9IFNlcnZlclNpZ25lclN0YXR1cyA9IHt9KSk7XG4vKipcbiAqIFN0YWtlT3B0aW9uc01vZGUgdHlwZSBkZWZpbml0aW9uLlxuICovXG52YXIgU3Rha2VPcHRpb25zTW9kZTtcbihmdW5jdGlvbiAoU3Rha2VPcHRpb25zTW9kZSkge1xuICAgIC8qKlxuICAgICAqIERlZmF1bHRzIHRvIHRoZSBtb2RlIHNwZWNpZmljIHRvIHRoZSBhc3NldC5cbiAgICAgKi9cbiAgICBTdGFrZU9wdGlvbnNNb2RlW1wiREVGQVVMVFwiXSA9IFwiZGVmYXVsdFwiO1xuICAgIC8qKlxuICAgICAqIFBhcnRpYWwgcmVwcmVzZW50cyBQYXJ0aWFsIEV0aGVyZXVtIFN0YWtpbmcgbW9kZS5cbiAgICAgKi9cbiAgICBTdGFrZU9wdGlvbnNNb2RlW1wiUEFSVElBTFwiXSA9IFwicGFydGlhbFwiO1xuICAgIC8qKlxuICAgICAqIE5hdGl2ZSByZXByZXNlbnRzIE5hdGl2ZSBFdGhlcmV1bSBTdGFraW5nIG1vZGUuXG4gICAgICovXG4gICAgU3Rha2VPcHRpb25zTW9kZVtcIk5BVElWRVwiXSA9IFwibmF0aXZlXCI7XG59KShTdGFrZU9wdGlvbnNNb2RlIHx8IChleHBvcnRzLlN0YWtlT3B0aW9uc01vZGUgPSBTdGFrZU9wdGlvbnNNb2RlID0ge30pKTtcbi8qKlxuICogU21hcnQgQ29udHJhY3QgVHlwZVxuICovXG52YXIgU21hcnRDb250cmFjdFR5cGU7XG4oZnVuY3Rpb24gKFNtYXJ0Q29udHJhY3RUeXBlKSB7XG4gICAgU21hcnRDb250cmFjdFR5cGVbXCJFUkMyMFwiXSA9IFwiZXJjMjBcIjtcbiAgICBTbWFydENvbnRyYWN0VHlwZVtcIkVSQzcyMVwiXSA9IFwiZXJjNzIxXCI7XG4gICAgU21hcnRDb250cmFjdFR5cGVbXCJFUkMxMTU1XCJdID0gXCJlcmMxMTU1XCI7XG4gICAgU21hcnRDb250cmFjdFR5cGVbXCJDVVNUT01cIl0gPSBcImN1c3RvbVwiO1xufSkoU21hcnRDb250cmFjdFR5cGUgfHwgKGV4cG9ydHMuU21hcnRDb250cmFjdFR5cGUgPSBTbWFydENvbnRyYWN0VHlwZSA9IHt9KSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/types.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/utils.js":
/*!********************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/utils.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getWeekBackDate = exports.formatDate = exports.parseUnsignedPayload = exports.delay = exports.convertStringToHex = exports.registerAxiosInterceptors = exports.logApiResponse = void 0;\nconst api_error_1 = __webpack_require__(/*! ./api_error */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/api_error.js\");\nconst errors_1 = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/errors.js\");\n/**\n * Prints Axios response to the console for debugging purposes.\n *\n * @param response - The Axios response object.\n * @param debugging - Flag to enable or disable logging.\n * @returns The Axios response object.\n */\nconst logApiResponse = (response, debugging = false) => {\n    if (debugging) {\n        let output = typeof response.data === \"string\" ? response.data : \"\";\n        if (typeof response.data === \"object\") {\n            output = JSON.stringify(response.data, null, 4);\n        }\n        console.log(`API RESPONSE: \n      Status: ${response.status} \n      URL: ${response.config.url} \n      Data: ${output}`);\n    }\n    return response;\n};\nexports.logApiResponse = logApiResponse;\n/**\n * Registers request and response interceptors to an Axios instance.\n *\n * @param axiosInstance - The Axios instance to register the interceptors.\n * @param requestFn - The request interceptor function.\n * @param responseFn - The response interceptor function.\n */\nconst registerAxiosInterceptors = (axiosInstance, requestFn, responseFn) => {\n    axiosInstance.interceptors.request.use(requestFn);\n    axiosInstance.interceptors.response.use(responseFn, error => {\n        return Promise.reject(api_error_1.APIError.fromError(error));\n    });\n};\nexports.registerAxiosInterceptors = registerAxiosInterceptors;\n/**\n * Converts a Uint8Array to a hex string.\n *\n * @param key - The key to convert.\n * @returns The converted hex string.\n */\nconst convertStringToHex = (key) => {\n    return Buffer.from(key).toString(\"hex\");\n};\nexports.convertStringToHex = convertStringToHex;\n/**\n * Delays the execution of the function by the specified number of seconds.\n *\n * @param seconds - The number of seconds to delay the execution.\n * @returns A promise that resolves after the specified number of seconds.\n */\nasync function delay(seconds) {\n    return new Promise(resolve => setTimeout(resolve, seconds * 1000));\n}\nexports.delay = delay;\n/**\n * Parses an Unsigned Payload and returns the JSON object.\n *\n * @throws {InvalidUnsignedPayload} If the Unsigned Payload is invalid.\n * @param payload - The Unsigned Payload.\n * @returns The parsed JSON object.\n */\nfunction parseUnsignedPayload(payload) {\n    const rawPayload = payload.match(/../g)?.map(byte => parseInt(byte, 16));\n    if (!rawPayload) {\n        throw new errors_1.InvalidUnsignedPayloadError(\"Unable to parse unsigned payload\");\n    }\n    let parsedPayload;\n    try {\n        const rawPayloadBytes = new Uint8Array(rawPayload);\n        const decoder = new TextDecoder();\n        parsedPayload = JSON.parse(decoder.decode(rawPayloadBytes));\n    }\n    catch (error) {\n        throw new errors_1.InvalidUnsignedPayloadError(\"Unable to decode unsigned payload JSON\");\n    }\n    return parsedPayload;\n}\nexports.parseUnsignedPayload = parseUnsignedPayload;\n/**\n * Formats the input date to 'YYYY-MM-DD'\n *\n * @param date - The date to format.\n *\n * @returns a formated date of 'YYYY-MM-DD'\n */\nfunction formatDate(date) {\n    const year = date.getFullYear();\n    const month = String(date.getMonth() + 1).padStart(2, \"0\"); // Months are zero-based, so add 1\n    const day = String(date.getDate()).padStart(2, \"0\");\n    return `${year}-${month}-${day}T00:00:00Z`;\n}\nexports.formatDate = formatDate;\n/**\n *\n * Takes a date and subtracts a week from it. (7 days)\n *\n * @param date - The date to be formatted.\n *\n * @returns a formatted date that is one week ago.\n */\nfunction getWeekBackDate(date) {\n    date.setDate(date.getDate() - 7);\n    return formatDate(date);\n}\nexports.getWeekBackDate = getWeekBackDate;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL3V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHVCQUF1QixHQUFHLGtCQUFrQixHQUFHLDRCQUE0QixHQUFHLGFBQWEsR0FBRywwQkFBMEIsR0FBRyxpQ0FBaUMsR0FBRyxzQkFBc0I7QUFDckwsb0JBQW9CLG1CQUFPLENBQUMsMkZBQWE7QUFDekMsaUJBQWlCLG1CQUFPLENBQUMscUZBQVU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixhQUFhO0FBQ2IsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsWUFBWSx3QkFBd0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0EsY0FBYyxLQUFLLEdBQUcsTUFBTSxHQUFHLElBQUk7QUFDbkM7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3Vydml2YWwtZnVuLy4vbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9jb2luYmFzZS1zZGsvZGlzdC9jb2luYmFzZS91dGlscy5qcz84ODc3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRXZWVrQmFja0RhdGUgPSBleHBvcnRzLmZvcm1hdERhdGUgPSBleHBvcnRzLnBhcnNlVW5zaWduZWRQYXlsb2FkID0gZXhwb3J0cy5kZWxheSA9IGV4cG9ydHMuY29udmVydFN0cmluZ1RvSGV4ID0gZXhwb3J0cy5yZWdpc3RlckF4aW9zSW50ZXJjZXB0b3JzID0gZXhwb3J0cy5sb2dBcGlSZXNwb25zZSA9IHZvaWQgMDtcbmNvbnN0IGFwaV9lcnJvcl8xID0gcmVxdWlyZShcIi4vYXBpX2Vycm9yXCIpO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi9lcnJvcnNcIik7XG4vKipcbiAqIFByaW50cyBBeGlvcyByZXNwb25zZSB0byB0aGUgY29uc29sZSBmb3IgZGVidWdnaW5nIHB1cnBvc2VzLlxuICpcbiAqIEBwYXJhbSByZXNwb25zZSAtIFRoZSBBeGlvcyByZXNwb25zZSBvYmplY3QuXG4gKiBAcGFyYW0gZGVidWdnaW5nIC0gRmxhZyB0byBlbmFibGUgb3IgZGlzYWJsZSBsb2dnaW5nLlxuICogQHJldHVybnMgVGhlIEF4aW9zIHJlc3BvbnNlIG9iamVjdC5cbiAqL1xuY29uc3QgbG9nQXBpUmVzcG9uc2UgPSAocmVzcG9uc2UsIGRlYnVnZ2luZyA9IGZhbHNlKSA9PiB7XG4gICAgaWYgKGRlYnVnZ2luZykge1xuICAgICAgICBsZXQgb3V0cHV0ID0gdHlwZW9mIHJlc3BvbnNlLmRhdGEgPT09IFwic3RyaW5nXCIgPyByZXNwb25zZS5kYXRhIDogXCJcIjtcbiAgICAgICAgaWYgKHR5cGVvZiByZXNwb25zZS5kYXRhID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBvdXRwdXQgPSBKU09OLnN0cmluZ2lmeShyZXNwb25zZS5kYXRhLCBudWxsLCA0KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmxvZyhgQVBJIFJFU1BPTlNFOiBcbiAgICAgIFN0YXR1czogJHtyZXNwb25zZS5zdGF0dXN9IFxuICAgICAgVVJMOiAke3Jlc3BvbnNlLmNvbmZpZy51cmx9IFxuICAgICAgRGF0YTogJHtvdXRwdXR9YCk7XG4gICAgfVxuICAgIHJldHVybiByZXNwb25zZTtcbn07XG5leHBvcnRzLmxvZ0FwaVJlc3BvbnNlID0gbG9nQXBpUmVzcG9uc2U7XG4vKipcbiAqIFJlZ2lzdGVycyByZXF1ZXN0IGFuZCByZXNwb25zZSBpbnRlcmNlcHRvcnMgdG8gYW4gQXhpb3MgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIGF4aW9zSW5zdGFuY2UgLSBUaGUgQXhpb3MgaW5zdGFuY2UgdG8gcmVnaXN0ZXIgdGhlIGludGVyY2VwdG9ycy5cbiAqIEBwYXJhbSByZXF1ZXN0Rm4gLSBUaGUgcmVxdWVzdCBpbnRlcmNlcHRvciBmdW5jdGlvbi5cbiAqIEBwYXJhbSByZXNwb25zZUZuIC0gVGhlIHJlc3BvbnNlIGludGVyY2VwdG9yIGZ1bmN0aW9uLlxuICovXG5jb25zdCByZWdpc3RlckF4aW9zSW50ZXJjZXB0b3JzID0gKGF4aW9zSW5zdGFuY2UsIHJlcXVlc3RGbiwgcmVzcG9uc2VGbikgPT4ge1xuICAgIGF4aW9zSW5zdGFuY2UuaW50ZXJjZXB0b3JzLnJlcXVlc3QudXNlKHJlcXVlc3RGbik7XG4gICAgYXhpb3NJbnN0YW5jZS5pbnRlcmNlcHRvcnMucmVzcG9uc2UudXNlKHJlc3BvbnNlRm4sIGVycm9yID0+IHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGFwaV9lcnJvcl8xLkFQSUVycm9yLmZyb21FcnJvcihlcnJvcikpO1xuICAgIH0pO1xufTtcbmV4cG9ydHMucmVnaXN0ZXJBeGlvc0ludGVyY2VwdG9ycyA9IHJlZ2lzdGVyQXhpb3NJbnRlcmNlcHRvcnM7XG4vKipcbiAqIENvbnZlcnRzIGEgVWludDhBcnJheSB0byBhIGhleCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIGtleSAtIFRoZSBrZXkgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIFRoZSBjb252ZXJ0ZWQgaGV4IHN0cmluZy5cbiAqL1xuY29uc3QgY29udmVydFN0cmluZ1RvSGV4ID0gKGtleSkgPT4ge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShrZXkpLnRvU3RyaW5nKFwiaGV4XCIpO1xufTtcbmV4cG9ydHMuY29udmVydFN0cmluZ1RvSGV4ID0gY29udmVydFN0cmluZ1RvSGV4O1xuLyoqXG4gKiBEZWxheXMgdGhlIGV4ZWN1dGlvbiBvZiB0aGUgZnVuY3Rpb24gYnkgdGhlIHNwZWNpZmllZCBudW1iZXIgb2Ygc2Vjb25kcy5cbiAqXG4gKiBAcGFyYW0gc2Vjb25kcyAtIFRoZSBudW1iZXIgb2Ygc2Vjb25kcyB0byBkZWxheSB0aGUgZXhlY3V0aW9uLlxuICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgYWZ0ZXIgdGhlIHNwZWNpZmllZCBudW1iZXIgb2Ygc2Vjb25kcy5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZGVsYXkoc2Vjb25kcykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgc2Vjb25kcyAqIDEwMDApKTtcbn1cbmV4cG9ydHMuZGVsYXkgPSBkZWxheTtcbi8qKlxuICogUGFyc2VzIGFuIFVuc2lnbmVkIFBheWxvYWQgYW5kIHJldHVybnMgdGhlIEpTT04gb2JqZWN0LlxuICpcbiAqIEB0aHJvd3Mge0ludmFsaWRVbnNpZ25lZFBheWxvYWR9IElmIHRoZSBVbnNpZ25lZCBQYXlsb2FkIGlzIGludmFsaWQuXG4gKiBAcGFyYW0gcGF5bG9hZCAtIFRoZSBVbnNpZ25lZCBQYXlsb2FkLlxuICogQHJldHVybnMgVGhlIHBhcnNlZCBKU09OIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gcGFyc2VVbnNpZ25lZFBheWxvYWQocGF5bG9hZCkge1xuICAgIGNvbnN0IHJhd1BheWxvYWQgPSBwYXlsb2FkLm1hdGNoKC8uLi9nKT8ubWFwKGJ5dGUgPT4gcGFyc2VJbnQoYnl0ZSwgMTYpKTtcbiAgICBpZiAoIXJhd1BheWxvYWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkludmFsaWRVbnNpZ25lZFBheWxvYWRFcnJvcihcIlVuYWJsZSB0byBwYXJzZSB1bnNpZ25lZCBwYXlsb2FkXCIpO1xuICAgIH1cbiAgICBsZXQgcGFyc2VkUGF5bG9hZDtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByYXdQYXlsb2FkQnl0ZXMgPSBuZXcgVWludDhBcnJheShyYXdQYXlsb2FkKTtcbiAgICAgICAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuICAgICAgICBwYXJzZWRQYXlsb2FkID0gSlNPTi5wYXJzZShkZWNvZGVyLmRlY29kZShyYXdQYXlsb2FkQnl0ZXMpKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5JbnZhbGlkVW5zaWduZWRQYXlsb2FkRXJyb3IoXCJVbmFibGUgdG8gZGVjb2RlIHVuc2lnbmVkIHBheWxvYWQgSlNPTlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZFBheWxvYWQ7XG59XG5leHBvcnRzLnBhcnNlVW5zaWduZWRQYXlsb2FkID0gcGFyc2VVbnNpZ25lZFBheWxvYWQ7XG4vKipcbiAqIEZvcm1hdHMgdGhlIGlucHV0IGRhdGUgdG8gJ1lZWVktTU0tREQnXG4gKlxuICogQHBhcmFtIGRhdGUgLSBUaGUgZGF0ZSB0byBmb3JtYXQuXG4gKlxuICogQHJldHVybnMgYSBmb3JtYXRlZCBkYXRlIG9mICdZWVlZLU1NLUREJ1xuICovXG5mdW5jdGlvbiBmb3JtYXREYXRlKGRhdGUpIHtcbiAgICBjb25zdCB5ZWFyID0gZGF0ZS5nZXRGdWxsWWVhcigpO1xuICAgIGNvbnN0IG1vbnRoID0gU3RyaW5nKGRhdGUuZ2V0TW9udGgoKSArIDEpLnBhZFN0YXJ0KDIsIFwiMFwiKTsgLy8gTW9udGhzIGFyZSB6ZXJvLWJhc2VkLCBzbyBhZGQgMVxuICAgIGNvbnN0IGRheSA9IFN0cmluZyhkYXRlLmdldERhdGUoKSkucGFkU3RhcnQoMiwgXCIwXCIpO1xuICAgIHJldHVybiBgJHt5ZWFyfS0ke21vbnRofS0ke2RheX1UMDA6MDA6MDBaYDtcbn1cbmV4cG9ydHMuZm9ybWF0RGF0ZSA9IGZvcm1hdERhdGU7XG4vKipcbiAqXG4gKiBUYWtlcyBhIGRhdGUgYW5kIHN1YnRyYWN0cyBhIHdlZWsgZnJvbSBpdC4gKDcgZGF5cylcbiAqXG4gKiBAcGFyYW0gZGF0ZSAtIFRoZSBkYXRlIHRvIGJlIGZvcm1hdHRlZC5cbiAqXG4gKiBAcmV0dXJucyBhIGZvcm1hdHRlZCBkYXRlIHRoYXQgaXMgb25lIHdlZWsgYWdvLlxuICovXG5mdW5jdGlvbiBnZXRXZWVrQmFja0RhdGUoZGF0ZSkge1xuICAgIGRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSAtIDcpO1xuICAgIHJldHVybiBmb3JtYXREYXRlKGRhdGUpO1xufVxuZXhwb3J0cy5nZXRXZWVrQmFja0RhdGUgPSBnZXRXZWVrQmFja0RhdGU7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/validator.js":
/*!************************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/validator.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Validator = void 0;\nconst coinbase_1 = __webpack_require__(/*! ./coinbase */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/coinbase.js\");\nconst api_1 = __webpack_require__(/*! ../client/api */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/client/api.js\");\nconst types_1 = __webpack_require__(/*! ./types */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/types.js\");\n/**\n * A representation of a validator onchain.\n */\nclass Validator {\n    /**\n     * Creates a Validator object.\n     *\n     * @class\n     * @param model - The underlying Validator object.\n     * @throws {Error} - If the Validator model is empty.\n     */\n    constructor(model) {\n        if (!model) {\n            throw new Error(\"Invalid model type\");\n        }\n        this.model = model;\n    }\n    /**\n     * Returns the list of Validators.\n     *\n     * @param networkId - The network ID.\n     * @param assetId - The asset ID.\n     * @param status - The status to filter by.\n     * @returns The list of Validators.\n     */\n    static async list(networkId, assetId, status) {\n        const validators = [];\n        const response = await coinbase_1.Coinbase.apiClients.stake.listValidators(networkId, assetId, Validator.getAPIValidatorStatus(status));\n        response.data.data.forEach(validator => {\n            validators.push(new Validator(validator));\n        });\n        return validators;\n    }\n    /**\n     *\n     * Returns the details of a specific validator.\n     *\n     * @param networkId - The network ID.\n     * @param assetId - The asset ID.\n     * @param id - The unique publicly identifiable id of the validator for which to fetch the data.\n     * @returns The requested validator details.\n     */\n    static async fetch(networkId, assetId, id) {\n        const response = await coinbase_1.Coinbase.apiClients.stake.getValidator(networkId, assetId, id);\n        return new Validator(response.data);\n    }\n    /**\n     * Returns the Validator status.\n     *\n     * @param status - The API Validator status.\n     * @returns The Validator status.\n     */\n    static getAPIValidatorStatus(status) {\n        /* istanbul ignore next */\n        switch (status) {\n            case types_1.ValidatorStatus.UNKNOWN:\n                return api_1.ValidatorStatus.Unknown;\n            case types_1.ValidatorStatus.PROVISIONING:\n                return api_1.ValidatorStatus.Provisioning;\n            case types_1.ValidatorStatus.PROVISIONED:\n                return api_1.ValidatorStatus.Provisioned;\n            case types_1.ValidatorStatus.DEPOSITED:\n                return api_1.ValidatorStatus.Deposited;\n            case types_1.ValidatorStatus.PENDING_ACTIVATION:\n                return api_1.ValidatorStatus.PendingActivation;\n            case types_1.ValidatorStatus.ACTIVE:\n                return api_1.ValidatorStatus.Active;\n            case types_1.ValidatorStatus.EXITING:\n                return api_1.ValidatorStatus.Exiting;\n            case types_1.ValidatorStatus.EXITED:\n                return api_1.ValidatorStatus.Exited;\n            case types_1.ValidatorStatus.WITHDRAWAL_AVAILABLE:\n                return api_1.ValidatorStatus.WithdrawalAvailable;\n            case types_1.ValidatorStatus.WITHDRAWAL_COMPLETE:\n                return api_1.ValidatorStatus.WithdrawalComplete;\n            case types_1.ValidatorStatus.ACTIVE_SLASHED:\n                return api_1.ValidatorStatus.ActiveSlashed;\n            case types_1.ValidatorStatus.EXITED_SLASHED:\n                return api_1.ValidatorStatus.ExitedSlashed;\n            case types_1.ValidatorStatus.REAPED:\n                return api_1.ValidatorStatus.Reaped;\n            default:\n                return api_1.ValidatorStatus.Unknown;\n        }\n    }\n    /**\n     * Returns the Validator ID.\n     *\n     * @returns The Validator ID.\n     */\n    getValidatorId() {\n        return this.model.validator_id;\n    }\n    /**\n     * Returns the Validator status.\n     *\n     * @returns The Validator status.\n     */\n    getStatus() {\n        switch (this.model.status) {\n            case api_1.ValidatorStatus.Unknown:\n                return types_1.ValidatorStatus.UNKNOWN;\n            case api_1.ValidatorStatus.Provisioning:\n                return types_1.ValidatorStatus.PROVISIONING;\n            case api_1.ValidatorStatus.Provisioned:\n                return types_1.ValidatorStatus.PROVISIONED;\n            case api_1.ValidatorStatus.Deposited:\n                return types_1.ValidatorStatus.DEPOSITED;\n            case api_1.ValidatorStatus.PendingActivation:\n                return types_1.ValidatorStatus.PENDING_ACTIVATION;\n            case api_1.ValidatorStatus.Active:\n                return types_1.ValidatorStatus.ACTIVE;\n            case api_1.ValidatorStatus.Exiting:\n                return types_1.ValidatorStatus.EXITING;\n            case api_1.ValidatorStatus.Exited:\n                return types_1.ValidatorStatus.EXITED;\n            case api_1.ValidatorStatus.WithdrawalAvailable:\n                return types_1.ValidatorStatus.WITHDRAWAL_AVAILABLE;\n            case api_1.ValidatorStatus.WithdrawalComplete:\n                return types_1.ValidatorStatus.WITHDRAWAL_COMPLETE;\n            case api_1.ValidatorStatus.ActiveSlashed:\n                return types_1.ValidatorStatus.ACTIVE_SLASHED;\n            case api_1.ValidatorStatus.ExitedSlashed:\n                return types_1.ValidatorStatus.EXITED_SLASHED;\n            case api_1.ValidatorStatus.Reaped:\n                return types_1.ValidatorStatus.REAPED;\n            default:\n                return types_1.ValidatorStatus.UNKNOWN;\n        }\n    }\n    /**\n     * Returns the network ID.\n     *\n     * @returns The network ID.\n     */\n    getNetworkId() {\n        return this.model.network_id;\n    }\n    /**\n     * Returns the asset ID.\n     *\n     * @returns The asset ID.\n     */\n    getAssetId() {\n        return this.model.asset_id;\n    }\n    /**\n     * Returns the activation epoch of the validator.\n     *\n     * @returns The activation epoch as a string.\n     */\n    getActivationEpoch() {\n        return this.model.details?.activationEpoch || \"\";\n    }\n    /**\n     * Returns the balance of the validator.\n     *\n     * @returns The balance object.\n     */\n    getBalance() {\n        return this.model.details?.balance;\n    }\n    /**\n     * Returns the effective balance of the validator.\n     *\n     * @returns The effective balance object.\n     */\n    getEffectiveBalance() {\n        return this.model.details?.effective_balance;\n    }\n    /**\n     * Returns the exit epoch of the validator.\n     *\n     * @returns The exit epoch as a string.\n     */\n    getExitEpoch() {\n        return this.model.details?.exitEpoch || \"\";\n    }\n    /**\n     * Returns the index of the validator.\n     *\n     * @returns The validator index as a string.\n     */\n    getIndex() {\n        return this.model.details?.index || \"\";\n    }\n    /**\n     * Returns the public key of the validator.\n     *\n     * @returns The validator's public key as a string.\n     */\n    getPublicKey() {\n        return this.model.details?.public_key || \"\";\n    }\n    /**\n     * Returns whether the validator has been slashed.\n     *\n     * @returns True if the validator has been slashed, false otherwise.\n     */\n    isSlashed() {\n        return this.model.details?.slashed || false;\n    }\n    /**\n     * Returns the withdrawable epoch of the validator.\n     *\n     * @returns The withdrawable epoch as a string.\n     */\n    getWithdrawableEpoch() {\n        return this.model.details?.withdrawableEpoch || \"\";\n    }\n    /**\n     * Returns the withdrawal address of the validator.\n     *\n     * @returns The withdrawal address as a string.\n     */\n    getWithdrawalAddress() {\n        return this.model.details?.withdrawal_address || \"\";\n    }\n    /**\n     * Returns the address for execution layer rewards (MEV & tx fees).If using a reward splitter plan, this is a smart contract\n     * address that splits rewards based on defined commissions and send a portion to the forwarded_fee_recipient_address.\n     *\n     * @returns The fee recipient address as a string.\n     */\n    getFeeRecipientAddress() {\n        return this.model.details?.fee_recipient_address || \"\";\n    }\n    /**\n     * If using a reward splitter plan, this address receives a defined percentage of the total execution layer rewards.\n     *\n     * @returns The forwarded fee recipient address as a string.\n     */\n    getForwardedFeeRecipientAddress() {\n        return this.model.details?.forwarded_fee_recipient_address || \"\";\n    }\n    /**\n     * Returns the string representation of the Validator.\n     *\n     * @returns The string representation of the Validator.\n     */\n    toString() {\n        return `Id: ${this.getValidatorId()} Status: ${this.getStatus()}`;\n    }\n    /**\n     * Returns the JSON representation of the Validator.\n     *\n     * @returns The JSON representation of the Validator.\n     */\n    toJSON() {\n        return JSON.stringify(this.model);\n    }\n}\nexports.Validator = Validator;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL3ZhbGlkYXRvci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUI7QUFDakIsbUJBQW1CLG1CQUFPLENBQUMseUZBQVk7QUFDdkMsY0FBYyxtQkFBTyxDQUFDLHFGQUFlO0FBQ3JDLGdCQUFnQixtQkFBTyxDQUFDLG1GQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHVCQUF1QixVQUFVLGlCQUFpQjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cnZpdmFsLWZ1bi8uL25vZGVfbW9kdWxlcy9AY29pbmJhc2UvY29pbmJhc2Utc2RrL2Rpc3QvY29pbmJhc2UvdmFsaWRhdG9yLmpzPzAxOGQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlZhbGlkYXRvciA9IHZvaWQgMDtcbmNvbnN0IGNvaW5iYXNlXzEgPSByZXF1aXJlKFwiLi9jb2luYmFzZVwiKTtcbmNvbnN0IGFwaV8xID0gcmVxdWlyZShcIi4uL2NsaWVudC9hcGlcIik7XG5jb25zdCB0eXBlc18xID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG4vKipcbiAqIEEgcmVwcmVzZW50YXRpb24gb2YgYSB2YWxpZGF0b3Igb25jaGFpbi5cbiAqL1xuY2xhc3MgVmFsaWRhdG9yIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgVmFsaWRhdG9yIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBjbGFzc1xuICAgICAqIEBwYXJhbSBtb2RlbCAtIFRoZSB1bmRlcmx5aW5nIFZhbGlkYXRvciBvYmplY3QuXG4gICAgICogQHRocm93cyB7RXJyb3J9IC0gSWYgdGhlIFZhbGlkYXRvciBtb2RlbCBpcyBlbXB0eS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihtb2RlbCkge1xuICAgICAgICBpZiAoIW1vZGVsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG1vZGVsIHR5cGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb2RlbCA9IG1vZGVsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsaXN0IG9mIFZhbGlkYXRvcnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmV0d29ya0lkIC0gVGhlIG5ldHdvcmsgSUQuXG4gICAgICogQHBhcmFtIGFzc2V0SWQgLSBUaGUgYXNzZXQgSUQuXG4gICAgICogQHBhcmFtIHN0YXR1cyAtIFRoZSBzdGF0dXMgdG8gZmlsdGVyIGJ5LlxuICAgICAqIEByZXR1cm5zIFRoZSBsaXN0IG9mIFZhbGlkYXRvcnMuXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIGxpc3QobmV0d29ya0lkLCBhc3NldElkLCBzdGF0dXMpIHtcbiAgICAgICAgY29uc3QgdmFsaWRhdG9ycyA9IFtdO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNvaW5iYXNlXzEuQ29pbmJhc2UuYXBpQ2xpZW50cy5zdGFrZS5saXN0VmFsaWRhdG9ycyhuZXR3b3JrSWQsIGFzc2V0SWQsIFZhbGlkYXRvci5nZXRBUElWYWxpZGF0b3JTdGF0dXMoc3RhdHVzKSk7XG4gICAgICAgIHJlc3BvbnNlLmRhdGEuZGF0YS5mb3JFYWNoKHZhbGlkYXRvciA9PiB7XG4gICAgICAgICAgICB2YWxpZGF0b3JzLnB1c2gobmV3IFZhbGlkYXRvcih2YWxpZGF0b3IpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB2YWxpZGF0b3JzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFJldHVybnMgdGhlIGRldGFpbHMgb2YgYSBzcGVjaWZpYyB2YWxpZGF0b3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmV0d29ya0lkIC0gVGhlIG5ldHdvcmsgSUQuXG4gICAgICogQHBhcmFtIGFzc2V0SWQgLSBUaGUgYXNzZXQgSUQuXG4gICAgICogQHBhcmFtIGlkIC0gVGhlIHVuaXF1ZSBwdWJsaWNseSBpZGVudGlmaWFibGUgaWQgb2YgdGhlIHZhbGlkYXRvciBmb3Igd2hpY2ggdG8gZmV0Y2ggdGhlIGRhdGEuXG4gICAgICogQHJldHVybnMgVGhlIHJlcXVlc3RlZCB2YWxpZGF0b3IgZGV0YWlscy5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgZmV0Y2gobmV0d29ya0lkLCBhc3NldElkLCBpZCkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNvaW5iYXNlXzEuQ29pbmJhc2UuYXBpQ2xpZW50cy5zdGFrZS5nZXRWYWxpZGF0b3IobmV0d29ya0lkLCBhc3NldElkLCBpZCk7XG4gICAgICAgIHJldHVybiBuZXcgVmFsaWRhdG9yKHJlc3BvbnNlLmRhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBWYWxpZGF0b3Igc3RhdHVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHN0YXR1cyAtIFRoZSBBUEkgVmFsaWRhdG9yIHN0YXR1cy5cbiAgICAgKiBAcmV0dXJucyBUaGUgVmFsaWRhdG9yIHN0YXR1cy5cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0QVBJVmFsaWRhdG9yU3RhdHVzKHN0YXR1cykge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBzd2l0Y2ggKHN0YXR1cykge1xuICAgICAgICAgICAgY2FzZSB0eXBlc18xLlZhbGlkYXRvclN0YXR1cy5VTktOT1dOOlxuICAgICAgICAgICAgICAgIHJldHVybiBhcGlfMS5WYWxpZGF0b3JTdGF0dXMuVW5rbm93bjtcbiAgICAgICAgICAgIGNhc2UgdHlwZXNfMS5WYWxpZGF0b3JTdGF0dXMuUFJPVklTSU9OSU5HOlxuICAgICAgICAgICAgICAgIHJldHVybiBhcGlfMS5WYWxpZGF0b3JTdGF0dXMuUHJvdmlzaW9uaW5nO1xuICAgICAgICAgICAgY2FzZSB0eXBlc18xLlZhbGlkYXRvclN0YXR1cy5QUk9WSVNJT05FRDpcbiAgICAgICAgICAgICAgICByZXR1cm4gYXBpXzEuVmFsaWRhdG9yU3RhdHVzLlByb3Zpc2lvbmVkO1xuICAgICAgICAgICAgY2FzZSB0eXBlc18xLlZhbGlkYXRvclN0YXR1cy5ERVBPU0lURUQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwaV8xLlZhbGlkYXRvclN0YXR1cy5EZXBvc2l0ZWQ7XG4gICAgICAgICAgICBjYXNlIHR5cGVzXzEuVmFsaWRhdG9yU3RhdHVzLlBFTkRJTkdfQUNUSVZBVElPTjpcbiAgICAgICAgICAgICAgICByZXR1cm4gYXBpXzEuVmFsaWRhdG9yU3RhdHVzLlBlbmRpbmdBY3RpdmF0aW9uO1xuICAgICAgICAgICAgY2FzZSB0eXBlc18xLlZhbGlkYXRvclN0YXR1cy5BQ1RJVkU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwaV8xLlZhbGlkYXRvclN0YXR1cy5BY3RpdmU7XG4gICAgICAgICAgICBjYXNlIHR5cGVzXzEuVmFsaWRhdG9yU3RhdHVzLkVYSVRJTkc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwaV8xLlZhbGlkYXRvclN0YXR1cy5FeGl0aW5nO1xuICAgICAgICAgICAgY2FzZSB0eXBlc18xLlZhbGlkYXRvclN0YXR1cy5FWElURUQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwaV8xLlZhbGlkYXRvclN0YXR1cy5FeGl0ZWQ7XG4gICAgICAgICAgICBjYXNlIHR5cGVzXzEuVmFsaWRhdG9yU3RhdHVzLldJVEhEUkFXQUxfQVZBSUxBQkxFOlxuICAgICAgICAgICAgICAgIHJldHVybiBhcGlfMS5WYWxpZGF0b3JTdGF0dXMuV2l0aGRyYXdhbEF2YWlsYWJsZTtcbiAgICAgICAgICAgIGNhc2UgdHlwZXNfMS5WYWxpZGF0b3JTdGF0dXMuV0lUSERSQVdBTF9DT01QTEVURTpcbiAgICAgICAgICAgICAgICByZXR1cm4gYXBpXzEuVmFsaWRhdG9yU3RhdHVzLldpdGhkcmF3YWxDb21wbGV0ZTtcbiAgICAgICAgICAgIGNhc2UgdHlwZXNfMS5WYWxpZGF0b3JTdGF0dXMuQUNUSVZFX1NMQVNIRUQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwaV8xLlZhbGlkYXRvclN0YXR1cy5BY3RpdmVTbGFzaGVkO1xuICAgICAgICAgICAgY2FzZSB0eXBlc18xLlZhbGlkYXRvclN0YXR1cy5FWElURURfU0xBU0hFRDpcbiAgICAgICAgICAgICAgICByZXR1cm4gYXBpXzEuVmFsaWRhdG9yU3RhdHVzLkV4aXRlZFNsYXNoZWQ7XG4gICAgICAgICAgICBjYXNlIHR5cGVzXzEuVmFsaWRhdG9yU3RhdHVzLlJFQVBFRDpcbiAgICAgICAgICAgICAgICByZXR1cm4gYXBpXzEuVmFsaWRhdG9yU3RhdHVzLlJlYXBlZDtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwaV8xLlZhbGlkYXRvclN0YXR1cy5Vbmtub3duO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIFZhbGlkYXRvciBJRC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBWYWxpZGF0b3IgSUQuXG4gICAgICovXG4gICAgZ2V0VmFsaWRhdG9ySWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLnZhbGlkYXRvcl9pZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgVmFsaWRhdG9yIHN0YXR1cy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBWYWxpZGF0b3Igc3RhdHVzLlxuICAgICAqL1xuICAgIGdldFN0YXR1cygpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLm1vZGVsLnN0YXR1cykge1xuICAgICAgICAgICAgY2FzZSBhcGlfMS5WYWxpZGF0b3JTdGF0dXMuVW5rbm93bjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZXNfMS5WYWxpZGF0b3JTdGF0dXMuVU5LTk9XTjtcbiAgICAgICAgICAgIGNhc2UgYXBpXzEuVmFsaWRhdG9yU3RhdHVzLlByb3Zpc2lvbmluZzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZXNfMS5WYWxpZGF0b3JTdGF0dXMuUFJPVklTSU9OSU5HO1xuICAgICAgICAgICAgY2FzZSBhcGlfMS5WYWxpZGF0b3JTdGF0dXMuUHJvdmlzaW9uZWQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVzXzEuVmFsaWRhdG9yU3RhdHVzLlBST1ZJU0lPTkVEO1xuICAgICAgICAgICAgY2FzZSBhcGlfMS5WYWxpZGF0b3JTdGF0dXMuRGVwb3NpdGVkOlxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlc18xLlZhbGlkYXRvclN0YXR1cy5ERVBPU0lURUQ7XG4gICAgICAgICAgICBjYXNlIGFwaV8xLlZhbGlkYXRvclN0YXR1cy5QZW5kaW5nQWN0aXZhdGlvbjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZXNfMS5WYWxpZGF0b3JTdGF0dXMuUEVORElOR19BQ1RJVkFUSU9OO1xuICAgICAgICAgICAgY2FzZSBhcGlfMS5WYWxpZGF0b3JTdGF0dXMuQWN0aXZlOlxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlc18xLlZhbGlkYXRvclN0YXR1cy5BQ1RJVkU7XG4gICAgICAgICAgICBjYXNlIGFwaV8xLlZhbGlkYXRvclN0YXR1cy5FeGl0aW5nOlxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlc18xLlZhbGlkYXRvclN0YXR1cy5FWElUSU5HO1xuICAgICAgICAgICAgY2FzZSBhcGlfMS5WYWxpZGF0b3JTdGF0dXMuRXhpdGVkOlxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlc18xLlZhbGlkYXRvclN0YXR1cy5FWElURUQ7XG4gICAgICAgICAgICBjYXNlIGFwaV8xLlZhbGlkYXRvclN0YXR1cy5XaXRoZHJhd2FsQXZhaWxhYmxlOlxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlc18xLlZhbGlkYXRvclN0YXR1cy5XSVRIRFJBV0FMX0FWQUlMQUJMRTtcbiAgICAgICAgICAgIGNhc2UgYXBpXzEuVmFsaWRhdG9yU3RhdHVzLldpdGhkcmF3YWxDb21wbGV0ZTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZXNfMS5WYWxpZGF0b3JTdGF0dXMuV0lUSERSQVdBTF9DT01QTEVURTtcbiAgICAgICAgICAgIGNhc2UgYXBpXzEuVmFsaWRhdG9yU3RhdHVzLkFjdGl2ZVNsYXNoZWQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVzXzEuVmFsaWRhdG9yU3RhdHVzLkFDVElWRV9TTEFTSEVEO1xuICAgICAgICAgICAgY2FzZSBhcGlfMS5WYWxpZGF0b3JTdGF0dXMuRXhpdGVkU2xhc2hlZDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZXNfMS5WYWxpZGF0b3JTdGF0dXMuRVhJVEVEX1NMQVNIRUQ7XG4gICAgICAgICAgICBjYXNlIGFwaV8xLlZhbGlkYXRvclN0YXR1cy5SZWFwZWQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVzXzEuVmFsaWRhdG9yU3RhdHVzLlJFQVBFRDtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVzXzEuVmFsaWRhdG9yU3RhdHVzLlVOS05PV047XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbmV0d29yayBJRC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBuZXR3b3JrIElELlxuICAgICAqL1xuICAgIGdldE5ldHdvcmtJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwubmV0d29ya19pZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYXNzZXQgSUQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgYXNzZXQgSUQuXG4gICAgICovXG4gICAgZ2V0QXNzZXRJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwuYXNzZXRfaWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGFjdGl2YXRpb24gZXBvY2ggb2YgdGhlIHZhbGlkYXRvci5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBhY3RpdmF0aW9uIGVwb2NoIGFzIGEgc3RyaW5nLlxuICAgICAqL1xuICAgIGdldEFjdGl2YXRpb25FcG9jaCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwuZGV0YWlscz8uYWN0aXZhdGlvbkVwb2NoIHx8IFwiXCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGJhbGFuY2Ugb2YgdGhlIHZhbGlkYXRvci5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBiYWxhbmNlIG9iamVjdC5cbiAgICAgKi9cbiAgICBnZXRCYWxhbmNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5kZXRhaWxzPy5iYWxhbmNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBlZmZlY3RpdmUgYmFsYW5jZSBvZiB0aGUgdmFsaWRhdG9yLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGVmZmVjdGl2ZSBiYWxhbmNlIG9iamVjdC5cbiAgICAgKi9cbiAgICBnZXRFZmZlY3RpdmVCYWxhbmNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5kZXRhaWxzPy5lZmZlY3RpdmVfYmFsYW5jZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZXhpdCBlcG9jaCBvZiB0aGUgdmFsaWRhdG9yLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGV4aXQgZXBvY2ggYXMgYSBzdHJpbmcuXG4gICAgICovXG4gICAgZ2V0RXhpdEVwb2NoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5kZXRhaWxzPy5leGl0RXBvY2ggfHwgXCJcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIHZhbGlkYXRvci5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSB2YWxpZGF0b3IgaW5kZXggYXMgYSBzdHJpbmcuXG4gICAgICovXG4gICAgZ2V0SW5kZXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLmRldGFpbHM/LmluZGV4IHx8IFwiXCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHB1YmxpYyBrZXkgb2YgdGhlIHZhbGlkYXRvci5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSB2YWxpZGF0b3IncyBwdWJsaWMga2V5IGFzIGEgc3RyaW5nLlxuICAgICAqL1xuICAgIGdldFB1YmxpY0tleSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwuZGV0YWlscz8ucHVibGljX2tleSB8fCBcIlwiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHZhbGlkYXRvciBoYXMgYmVlbiBzbGFzaGVkLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgdmFsaWRhdG9yIGhhcyBiZWVuIHNsYXNoZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBpc1NsYXNoZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLmRldGFpbHM/LnNsYXNoZWQgfHwgZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHdpdGhkcmF3YWJsZSBlcG9jaCBvZiB0aGUgdmFsaWRhdG9yLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHdpdGhkcmF3YWJsZSBlcG9jaCBhcyBhIHN0cmluZy5cbiAgICAgKi9cbiAgICBnZXRXaXRoZHJhd2FibGVFcG9jaCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwuZGV0YWlscz8ud2l0aGRyYXdhYmxlRXBvY2ggfHwgXCJcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgd2l0aGRyYXdhbCBhZGRyZXNzIG9mIHRoZSB2YWxpZGF0b3IuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgd2l0aGRyYXdhbCBhZGRyZXNzIGFzIGEgc3RyaW5nLlxuICAgICAqL1xuICAgIGdldFdpdGhkcmF3YWxBZGRyZXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5kZXRhaWxzPy53aXRoZHJhd2FsX2FkZHJlc3MgfHwgXCJcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYWRkcmVzcyBmb3IgZXhlY3V0aW9uIGxheWVyIHJld2FyZHMgKE1FViAmIHR4IGZlZXMpLklmIHVzaW5nIGEgcmV3YXJkIHNwbGl0dGVyIHBsYW4sIHRoaXMgaXMgYSBzbWFydCBjb250cmFjdFxuICAgICAqIGFkZHJlc3MgdGhhdCBzcGxpdHMgcmV3YXJkcyBiYXNlZCBvbiBkZWZpbmVkIGNvbW1pc3Npb25zIGFuZCBzZW5kIGEgcG9ydGlvbiB0byB0aGUgZm9yd2FyZGVkX2ZlZV9yZWNpcGllbnRfYWRkcmVzcy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBmZWUgcmVjaXBpZW50IGFkZHJlc3MgYXMgYSBzdHJpbmcuXG4gICAgICovXG4gICAgZ2V0RmVlUmVjaXBpZW50QWRkcmVzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwuZGV0YWlscz8uZmVlX3JlY2lwaWVudF9hZGRyZXNzIHx8IFwiXCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIHVzaW5nIGEgcmV3YXJkIHNwbGl0dGVyIHBsYW4sIHRoaXMgYWRkcmVzcyByZWNlaXZlcyBhIGRlZmluZWQgcGVyY2VudGFnZSBvZiB0aGUgdG90YWwgZXhlY3V0aW9uIGxheWVyIHJld2FyZHMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgZm9yd2FyZGVkIGZlZSByZWNpcGllbnQgYWRkcmVzcyBhcyBhIHN0cmluZy5cbiAgICAgKi9cbiAgICBnZXRGb3J3YXJkZWRGZWVSZWNpcGllbnRBZGRyZXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5kZXRhaWxzPy5mb3J3YXJkZWRfZmVlX3JlY2lwaWVudF9hZGRyZXNzIHx8IFwiXCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgVmFsaWRhdG9yLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgVmFsaWRhdG9yLlxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gYElkOiAke3RoaXMuZ2V0VmFsaWRhdG9ySWQoKX0gU3RhdHVzOiAke3RoaXMuZ2V0U3RhdHVzKCl9YDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgSlNPTiByZXByZXNlbnRhdGlvbiBvZiB0aGUgVmFsaWRhdG9yLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIEpTT04gcmVwcmVzZW50YXRpb24gb2YgdGhlIFZhbGlkYXRvci5cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLm1vZGVsKTtcbiAgICB9XG59XG5leHBvcnRzLlZhbGlkYXRvciA9IFZhbGlkYXRvcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/validator.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/wallet.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/wallet.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Wallet = void 0;\nconst bip32_1 = __webpack_require__(/*! @scure/bip32 */ \"(rsc)/./node_modules/@scure/bip32/lib/index.js\");\nconst bip39_1 = __webpack_require__(/*! @scure/bip39 */ \"(rsc)/./node_modules/@scure/bip39/index.js\");\nconst english_1 = __webpack_require__(/*! @scure/bip39/wordlists/english */ \"(rsc)/./node_modules/@scure/bip39/wordlists/english.js\");\nconst ethers_1 = __webpack_require__(/*! ethers */ \"(rsc)/./node_modules/ethers/lib.commonjs/index.js\");\nconst crypto = __importStar(__webpack_require__(/*! crypto */ \"crypto\"));\nconst decimal_js_1 = __importDefault(__webpack_require__(/*! decimal.js */ \"(rsc)/./node_modules/decimal.js/decimal.js\"));\nconst ethers_2 = __webpack_require__(/*! ethers */ \"(rsc)/./node_modules/ethers/lib.commonjs/index.js\");\nconst fs = __importStar(__webpack_require__(/*! fs */ \"fs\"));\nconst ed2curve = __importStar(__webpack_require__(/*! ed2curve */ \"(rsc)/./node_modules/ed2curve/ed2curve.js\"));\nconst secp256k1 = __importStar(__webpack_require__(/*! secp256k1 */ \"(rsc)/./node_modules/secp256k1/index.js\"));\nconst wallet_address_1 = __webpack_require__(/*! ./address/wallet_address */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/address/wallet_address.js\");\nconst asset_1 = __webpack_require__(/*! ./asset */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/asset.js\");\nconst balance_1 = __webpack_require__(/*! ./balance */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/balance.js\");\nconst balance_map_1 = __webpack_require__(/*! ./balance_map */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/balance_map.js\");\nconst coinbase_1 = __webpack_require__(/*! ./coinbase */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/coinbase.js\");\nconst errors_1 = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/errors.js\");\nconst types_1 = __webpack_require__(/*! ./types */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/types.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/utils.js\");\nconst webhook_1 = __webpack_require__(/*! ./webhook */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/webhook.js\");\n/**\n * A representation of a Wallet. Wallets come with a single default Address, but can expand to have a set of Addresses,\n * each of which can hold a balance of one or more Assets. Wallets can create new Addresses, list their addresses,\n * list their balances, and transfer Assets to other Addresses. Wallets should be created through User.createWallet or User.importWallet.\n * Wallets should be created using `Wallet.create`, imported using `Wallet.import`, or fetched using `Wallet.fetch`.\n * Existing wallets can be imported with a seed using `Wallet.import`.\n * Wallets backed by a Server Signer can be fetched with `Wallet.fetch` and used for signing operations immediately.\n */\nclass Wallet {\n    /**\n     * Private constructor to prevent direct instantiation outside of factory method. Use Wallet.init instead.\n     *\n     * @ignore\n     * @param model - The wallet model object.\n     * @param master - The HD master key.\n     * @param seed - The seed to use for the Wallet. Expects a 32-byte hexadecimal with no 0x prefix.\n     * @hideconstructor\n     */\n    constructor(model, master, seed) {\n        this.addresses = [];\n        this.addressPathPrefix = \"m/44'/60'/0'/0\";\n        this.model = model;\n        this.master = master;\n        this.seed = seed;\n    }\n    /**\n     * Lists the Wallets belonging to the CDP Project.\n     *\n     * @param options - The pagination options.\n     * @param options.limit - The maximum number of Wallets to return. Limit can range between 1 and 100.\n     * @param options.page - The cursor for pagination across multiple pages of Wallets. Don\\&#39;t include this parameter on the first call. Use the next page value returned in a previous response to request subsequent results.\n     *\n     * @returns The paginated list response of Wallets.\n     */\n    static async listWallets({ limit = coinbase_1.Coinbase.defaultPageLimit, page = undefined, } = {}) {\n        const data = [];\n        let nextPage;\n        const response = await coinbase_1.Coinbase.apiClients.wallet.listWallets(limit, page);\n        const wallets = response.data.data;\n        for (const wallet of wallets) {\n            data.push(Wallet.init(wallet, \"\"));\n        }\n        const hasMore = response.data.has_more;\n        if (hasMore) {\n            if (response.data.next_page) {\n                nextPage = response.data.next_page;\n            }\n        }\n        return {\n            data,\n            hasMore,\n            nextPage,\n        };\n    }\n    /**\n     * Fetches a Wallet by its ID. The returned wallet can be immediately used for signing operations if backed by a server signer.\n     * If the wallet is not backed by a server signer, the wallet's seed will need to be set before it can be used for signing operations.\n     *\n     * @param wallet_id - The ID of the Wallet to fetch\n     * @returns The fetched Wallet\n     */\n    static async fetch(wallet_id) {\n        const response = await coinbase_1.Coinbase.apiClients.wallet.getWallet(wallet_id);\n        return Wallet.init(response.data, \"\");\n    }\n    /**\n     * Loads an existing CDP Wallet using a wallet data object or mnemonic seed phrase.\n     *\n     * @param data - The data used to import the wallet:\n     *   - If WalletData: Must contain walletId (or wallet_id) and seed.\n     *     Allows for the loading of an existing CDP wallet into CDP.\n     *   - If MnemonicSeedPhrase: Must contain a valid BIP-39 mnemonic phrase (12, 15, 18, 21, or 24 words).\n     *     Allows for the import of an external wallet into CDP as a 1-of-1 wallet.\n     * @param networkId - the ID of the blockchain network. Defaults to 'base-sepolia'.\n     * @returns A Promise that resolves to the loaded Wallet instance\n     * @throws {ArgumentError} If the data format is invalid.\n     * @throws {ArgumentError} If the seed is not provided.\n     * @throws {ArgumentError} If the mnemonic seed phrase is invalid.\n     */\n    static async import(data, networkId = coinbase_1.Coinbase.networks.BaseSepolia) {\n        // Check if data is a mnemonic seed phrase object\n        if ((0, types_1.isMnemonicSeedPhrase)(data)) {\n            // Handle mnemonic seed phrase object import\n            if (!data.mnemonicPhrase) {\n                throw new errors_1.ArgumentError(\"BIP-39 mnemonic seed phrase must be provided\");\n            }\n            if (!(0, bip39_1.validateMnemonic)(data.mnemonicPhrase, english_1.wordlist)) {\n                throw new errors_1.ArgumentError(\"Invalid BIP-39 mnemonic seed phrase\");\n            }\n            // Convert mnemonic phrase to seed\n            const seedBuffer = (0, bip39_1.mnemonicToSeedSync)(data.mnemonicPhrase);\n            const seed = (0, ethers_1.hexlify)(seedBuffer).slice(2); // remove 0x prefix\n            // Create wallet using the provided seed\n            const wallet = await Wallet.createWithSeed({\n                seed: seed,\n                networkId,\n            });\n            // Ensure the wallet is created\n            await wallet.listAddresses();\n            return wallet;\n        }\n        else if ((0, types_1.isWalletData)(data)) {\n            // Handle WalletData object import\n            const walletId = data.walletId || data.wallet_id;\n            if (!walletId) {\n                throw new errors_1.ArgumentError(\"Wallet ID must be provided\");\n            }\n            if (!data.seed) {\n                throw new errors_1.ArgumentError(\"Seed must be provided\");\n            }\n            const walletModel = await coinbase_1.Coinbase.apiClients.wallet.getWallet(walletId);\n            const wallet = Wallet.init(walletModel.data, data.seed);\n            await wallet.listAddresses();\n            return wallet;\n        }\n        else {\n            throw new errors_1.ArgumentError(\"Invalid import data format\");\n        }\n    }\n    /**\n     * Creates a new Wallet with a random seed.\n     *\n     * @constructs Wallet\n     * @param options - The options to create the Wallet.\n     * @param options.networkId - the ID of the blockchain network. Defaults to 'base-sepolia'.\n     * @param options.intervalSeconds - The interval at which to poll the backend, in seconds.\n     * @param options.timeoutSeconds - The maximum amount of time to wait for the ServerSigner to create a seed, in seconds.\n     * @throws {ArgumentError} If the model or client is not provided.\n     * @throws {Error} - If address derivation or caching fails.\n     * @throws {APIError} - If the request fails.\n     * @returns A promise that resolves with the new Wallet object.\n     */\n    static async create({ networkId = coinbase_1.Coinbase.networks.BaseSepolia, timeoutSeconds = 20, intervalSeconds = 0.2, } = {}) {\n        return Wallet.createWithSeed({\n            networkId,\n            timeoutSeconds,\n            intervalSeconds,\n        });\n    }\n    /**\n     * Creates a new Wallet with the given seed.\n     *\n     * @param options - The options to create the Wallet.\n     * @param options.seed - The seed to use for the Wallet. If undefined, a random seed will be generated.\n     * @param options.networkId - the ID of the blockchain network. Defaults to 'base-sepolia'.\n     * @param options.intervalSeconds - The interval at which to poll the backend, in seconds.\n     * @param options.timeoutSeconds - The maximum amount of time to wait for the ServerSigner to create a seed, in seconds.\n     * @throws {ArgumentError} If the model or client is not provided.\n     * @throws {Error} - If address derivation or caching fails.\n     * @throws {APIError} - If the request fails.\n     * @returns A promise that resolves with the new Wallet object.\n     */\n    static async createWithSeed({ seed = undefined, networkId = coinbase_1.Coinbase.networks.BaseSepolia, timeoutSeconds = 20, intervalSeconds = 0.2, } = {}) {\n        const result = await coinbase_1.Coinbase.apiClients.wallet.createWallet({\n            wallet: {\n                network_id: networkId,\n                use_server_signer: coinbase_1.Coinbase.useServerSigner,\n            },\n        });\n        const wallet = Wallet.init(result.data, seed);\n        if (coinbase_1.Coinbase.useServerSigner) {\n            await wallet.waitForSigner(wallet.getId(), intervalSeconds, timeoutSeconds);\n        }\n        await wallet.createAddress();\n        return wallet;\n    }\n    /**\n     * Returns a new Wallet object. Do not use this method directly. Instead, use one of:\n     * - Wallet.create (Create a new Wallet),\n     * - Wallet.import (Import a Wallet with seed),\n     * - Wallet.fetch (fetch a Wallet by ID w/o seed, useful for server signer wallets).\n     *\n     * @constructs Wallet\n     * @param model - The underlying Wallet model object\n     * @param seed - The seed to use for the Wallet. Expects a 32-byte hexadecimal with no 0x prefix. If null or undefined, a new seed will be generated.\n     * If the empty string, no seed is generated, and the Wallet will be instantiated without a seed and its corresponding private keys.\n     * @throws {ArgumentError} If the model or client is not provided.\n     * @throws {Error} - If address derivation or caching fails.\n     * @throws {APIError} - If the request fails.\n     * @returns A promise that resolves with the new Wallet object.\n     */\n    static init(model, seed) {\n        const wallet = new Wallet(model, undefined, seed);\n        if (coinbase_1.Coinbase.useServerSigner) {\n            return wallet;\n        }\n        wallet.setMasterNode(seed);\n        return wallet;\n    }\n    /**\n     * Exports the Wallet's data to a WalletData object.\n     *\n     * @returns The Wallet's data.\n     * @throws {APIError} - If the request fails.\n     */\n    export() {\n        if (!this.seed) {\n            throw new Error(\"Cannot export Wallet without loaded seed\");\n        }\n        return {\n            walletId: this.getId(),\n            seed: this.seed,\n            networkId: this.getNetworkId(),\n        };\n    }\n    /**\n     * Creates a new Address in the Wallet.\n     *\n     * @returns The new Address.\n     * @throws {APIError} - If the address creation fails.\n     */\n    async createAddress() {\n        let payload, key;\n        if (!coinbase_1.Coinbase.useServerSigner) {\n            // TODO: Coordinate this value with concurrent calls to createAddress.\n            const addressIndex = this.addresses.length;\n            const hdKey = this.deriveKey(addressIndex);\n            const attestation = this.createAttestation(hdKey);\n            const publicKey = (0, utils_1.convertStringToHex)(hdKey.publicKey);\n            key = new ethers_2.ethers.Wallet((0, utils_1.convertStringToHex)(hdKey.privateKey));\n            payload = {\n                public_key: publicKey,\n                attestation: attestation,\n                address_index: addressIndex,\n            };\n        }\n        const response = await coinbase_1.Coinbase.apiClients.address.createAddress(this.model.id, payload);\n        if (!this.addresses.length || !coinbase_1.Coinbase.useServerSigner) {\n            await this.reload();\n        }\n        const address = new wallet_address_1.WalletAddress(response.data, key);\n        this.addresses.push(address);\n        return address;\n    }\n    /**\n     * Set the seed for the Wallet.\n     *\n     * @param seed - The seed to use for the Wallet. Expects a 32-byte hexadecimal with no 0x prefix.\n     * @throws {ArgumentError} If the seed is empty.\n     * @throws {Error} If the seed is already set.\n     */\n    setSeed(seed) {\n        if (seed === undefined || seed === \"\") {\n            throw new errors_1.ArgumentError(\"Seed must not be empty\");\n        }\n        if (this.master) {\n            throw new Error(\"Seed is already set\");\n        }\n        this.setMasterNode(seed);\n        if (this.addresses.length < 1) {\n            return;\n        }\n        this.addresses.forEach((address, index) => {\n            const derivedKey = this.deriveKey(index);\n            const etherWallet = new ethers_2.ethers.Wallet((0, utils_1.convertStringToHex)(derivedKey.privateKey));\n            if (etherWallet.address != address.getId()) {\n                throw new Error(`Seed does not match wallet; cannot find address ${etherWallet.address}`);\n            }\n            address.setKey(etherWallet);\n        });\n    }\n    /**\n     * Returns the WalletAddress with the given ID.\n     *\n     * @param addressId - The ID of the WalletAddress to retrieve.\n     * @returns The WalletAddress.\n     */\n    async getAddress(addressId) {\n        if (this.addresses.length < 1) {\n            this.addresses = await this.listAddresses();\n        }\n        return this.addresses.find(address => {\n            return address.getId() === addressId;\n        });\n    }\n    /**\n     * Returns the list of Addresses in the Wallet.\n     *\n     * @returns The list of Addresses.\n     */\n    async listAddresses() {\n        const response = await coinbase_1.Coinbase.apiClients.address.listAddresses(this.getId(), Wallet.MAX_ADDRESSES);\n        const addresses = response.data.data.map(address => {\n            return this.buildWalletAddress(address, address.index);\n        });\n        this.addresses = addresses;\n        return addresses;\n    }\n    /**\n     *  Trades the given amount of the given Asset for another Asset.\n     *  Currently only the default address is used to source the Trade.\n     *\n     * @param options - The options to create the Trade.\n     * @param options.amount - The amount of the Asset to send.\n     * @param options.fromAssetId - The ID of the Asset to trade from.\n     * @param options.toAssetId - The ID of the Asset to trade to.\n     * @throws {Error} If the default address is not found.\n     * @throws {Error} If the private key is not loaded, or if the asset IDs are unsupported, or if there are insufficient funds.\n     * @returns The created Trade object.\n     */\n    async createTrade(options) {\n        return (await this.getDefaultAddress()).createTrade(options);\n    }\n    /**\n     * Get the stakeable balance for the supplied asset.\n     *\n     * @param asset_id - The asset to check the stakeable balance for.\n     * @param mode - The staking mode. Defaults to DEFAULT.\n     * @param options - Additional options for getting the stakeable balance.\n     * @throws {Error} if the default address is not found.\n     * @returns The stakeable balance.\n     */\n    async stakeableBalance(asset_id, mode = types_1.StakeOptionsMode.DEFAULT, options = {}) {\n        return (await this.getDefaultAddress()).stakeableBalance(asset_id, mode, options);\n    }\n    /**\n     * Get the unstakeable balance for the supplied asset.\n     *\n     * @param asset_id - The asset to check the unstakeable balance for.\n     * @param mode - The staking mode. Defaults to DEFAULT.\n     * @param options - Additional options for getting the unstakeable balance.\n     * @throws {Error} if the default address is not found.\n     * @returns The unstakeable balance.\n     */\n    async unstakeableBalance(asset_id, mode = types_1.StakeOptionsMode.DEFAULT, options = {}) {\n        return (await this.getDefaultAddress()).unstakeableBalance(asset_id, mode, options);\n    }\n    /**\n     * Get the pending claimable balance for the supplied asset.\n     *\n     * @param asset_id - The asset to check pending claimable balance for.\n     * @param mode - The staking mode. Defaults to DEFAULT.\n     * @param options - Additional options for getting the pending claimable balance.\n     * @throws {Error} if the default address is not found.\n     * @returns The pending claimable balance.\n     */\n    async pendingClaimableBalance(asset_id, mode = types_1.StakeOptionsMode.DEFAULT, options = {}) {\n        return (await this.getDefaultAddress()).pendingClaimableBalance(asset_id, mode, options);\n    }\n    /**\n     * Get the claimable balance for the supplied asset.\n     *\n     * @param asset_id - The asset to check claimable balance for.\n     * @param mode - The staking mode. Defaults to DEFAULT.\n     * @param options - Additional options for getting the claimable balance.\n     * @throws {Error} if the default address is not found.\n     * @returns The claimable balance.\n     */\n    async claimableBalance(asset_id, mode = types_1.StakeOptionsMode.DEFAULT, options = {}) {\n        return (await this.getDefaultAddress()).claimableBalance(asset_id, mode, options);\n    }\n    /**\n     * Lists the staking rewards for the address.\n     *\n     * @param assetId - The asset ID.\n     * @param startTime - The start time.\n     * @param endTime - The end time.\n     * @param format - The format to return the rewards in. (usd, native). Defaults to usd.\n     * @throws {Error} if the default address is not found.\n     * @returns The staking rewards.\n     */\n    async stakingRewards(assetId, startTime = (0, utils_1.getWeekBackDate)(new Date()), endTime = (0, utils_1.formatDate)(new Date()), format = types_1.StakingRewardFormat.USD) {\n        return (await this.getDefaultAddress()).stakingRewards(assetId, startTime, endTime, format);\n    }\n    /**\n     * Lists the historical staking balances for the address.\n     *\n     * @param assetId - The asset ID.\n     * @param startTime - The start time.\n     * @param endTime - The end time.\n     * @throws {Error} if the default address is not found.\n     * @returns The staking balances.\n     */\n    async historicalStakingBalances(assetId, startTime = (0, utils_1.getWeekBackDate)(new Date()), endTime = (0, utils_1.formatDate)(new Date())) {\n        return (await this.getDefaultAddress()).historicalStakingBalances(assetId, startTime, endTime);\n    }\n    /**\n     * Lists the historical balances for a given asset belonging to the default address of the wallet.\n     *\n     * @param assetId - The asset ID.\n     * @param options - The pagination options.\n     * @param options.limit - The maximum number of Historical Balances to return. Limit can range between 1 and 100.\n     * @param options.page - The cursor for pagination across multiple pages of Historical Balances. Don\\&#39;t include this parameter on the first call. Use the next page value returned in a previous response to request subsequent results.\n     *\n     * @returns The paginated list response of Historical Balances for the given Asset ID.\n     */\n    async listHistoricalBalances(assetId, { limit = coinbase_1.Coinbase.defaultPageLimit, page = undefined } = {}) {\n        return (await this.getDefaultAddress()).listHistoricalBalances(assetId, { limit, page });\n    }\n    /**\n     * Creates a staking operation to stake, signs it, and broadcasts it on the blockchain.\n     *\n     * @param amount - The amount for the staking operation.\n     * @param assetId - The asset for the staking operation.\n     * @param mode - The staking mode. Defaults to DEFAULT.\n     * @param options - Additional options such as setting the mode for the staking action.\n     * @param timeoutSeconds - The amount to wait for the transaction to complete when broadcasted.\n     * @param intervalSeconds - The amount to check each time for a successful broadcast.\n     * @throws {Error} if the default address is not found.\n     * @returns The staking operation after it's completed fully.\n     */\n    async createStake(amount, assetId, mode = types_1.StakeOptionsMode.DEFAULT, options = {}, timeoutSeconds = 60, intervalSeconds = 0.2) {\n        return (await this.getDefaultAddress()).createStake(amount, assetId, mode, options, timeoutSeconds, intervalSeconds);\n    }\n    /**\n     * Creates a staking operation to unstake, signs it, and broadcasts it on the blockchain.\n     *\n     * @param amount - The amount for the staking operation.\n     * @param assetId - The asset for the staking operation.\n     * @param mode - The staking mode. Defaults to DEFAULT.\n     * @param options - Additional options such as setting the mode for the staking action.\n     * @param timeoutSeconds - The amount to wait for the transaction to complete when broadcasted.\n     * @param intervalSeconds - The amount to check each time for a successful broadcast.\n     * @throws {Error} if the default address is not found.\n     * @returns The staking operation after it's completed successfully.\n     */\n    async createUnstake(amount, assetId, mode = types_1.StakeOptionsMode.DEFAULT, options = {}, timeoutSeconds = 60, intervalSeconds = 0.2) {\n        return (await this.getDefaultAddress()).createUnstake(amount, assetId, mode, options, timeoutSeconds, intervalSeconds);\n    }\n    /**\n     * Creates a staking operation to claim stake, signs it, and broadcasts it on the blockchain.\n     *\n     * @param amount - The amount for the staking operation.\n     * @param assetId - The asset for the staking operation.\n     * @param mode - The staking mode. Defaults to DEFAULT.\n     * @param options - Additional options such as setting the mode for the staking action.\n     * @param timeoutSeconds - The amount to wait for the transaction to complete when broadcasted.\n     * @param intervalSeconds - The amount to check each time for a successful broadcast.\n     * @throws {Error} if the default address is not found.\n     * @returns The staking operation after it's completed fully.\n     */\n    async createClaimStake(amount, assetId, mode = types_1.StakeOptionsMode.DEFAULT, options = {}, timeoutSeconds = 60, intervalSeconds = 0.2) {\n        return (await this.getDefaultAddress()).createClaimStake(amount, assetId, mode, options, timeoutSeconds, intervalSeconds);\n    }\n    /**\n     * Returns the list of balances of this Wallet. Balances are aggregated across all Addresses in the Wallet.\n     *\n     * @returns The list of balances. The key is the Asset ID, and the value is the balance.\n     */\n    async listBalances() {\n        const response = await coinbase_1.Coinbase.apiClients.wallet.listWalletBalances(this.model.id);\n        return balance_map_1.BalanceMap.fromBalances(response.data.data);\n    }\n    /**\n     * Returns the balance of the provided Asset. Balances are aggregated across all Addresses in the Wallet.\n     *\n     * @param assetId - The ID of the Asset to retrieve the balance for.\n     * @returns The balance of the Asset.\n     */\n    async getBalance(assetId) {\n        const response = await coinbase_1.Coinbase.apiClients.wallet.getWalletBalance(this.model.id, asset_1.Asset.primaryDenomination(assetId));\n        if (!response.data.amount) {\n            return new decimal_js_1.default(0);\n        }\n        const balance = balance_1.Balance.fromModelAndAssetId(response.data, assetId);\n        return balance.amount;\n    }\n    /**\n     * Returns the Network ID of the Wallet.\n     *\n     * @returns The network ID.\n     */\n    getNetworkId() {\n        return this.model.network_id;\n    }\n    /**\n     * Returns the ServerSigner Status of the Wallet.\n     *\n     * @returns the ServerSigner Status.\n     */\n    getServerSignerStatus() {\n        const status = {\n            pending_seed_creation: types_1.ServerSignerStatus.PENDING,\n            active_seed: types_1.ServerSignerStatus.ACTIVE,\n        };\n        return this.model.server_signer_status ? status[this.model.server_signer_status] : undefined;\n    }\n    /**\n     * Returns the wallet ID.\n     *\n     * @returns The wallet ID.\n     */\n    getId() {\n        return this.model.id;\n    }\n    /**\n     * Saves the seed of the Wallet to the given file.\n     *\n     * @deprecated Use saveSeedToFile() instead\n     * @param filePath - The path of the file to save the seed to\n     * @param encrypt - Whether the seed information persisted to the local file system should be\n     * encrypted or not. Data is unencrypted by default.\n     * @returns A string indicating the success of the operation\n     * @throws {Error} If the Wallet does not have a seed\n     */\n    saveSeed(filePath, encrypt = false) {\n        return this.saveSeedToFile(filePath, encrypt);\n    }\n    /**\n     * Saves the seed of the Wallet to the given file. Wallets whose seeds are saved this way can be\n     * rehydrated using load_seed. A single file can be used for multiple Wallet seeds.\n     * This is an insecure method of storing Wallet seeds and should only be used for development purposes.\n     *\n     * @param filePath - The path of the file to save the seed to\n     * @param encrypt - Whether the seed information persisted to the local file system should be\n     * encrypted or not. Data is unencrypted by default.\n     * @returns A string indicating the success of the operation\n     * @throws {Error} If the Wallet does not have a seed\n     */\n    saveSeedToFile(filePath, encrypt = false) {\n        if (!this.master) {\n            throw new Error(\"Cannot save Wallet without loaded seed\");\n        }\n        const existingSeedsInStore = this.getExistingSeeds(filePath);\n        const data = this.export();\n        let seedToStore = data.seed;\n        let authTag = \"\";\n        let iv = \"\";\n        if (encrypt) {\n            const ivBytes = crypto.randomBytes(12);\n            const sharedSecret = this.getEncryptionKey();\n            const cipher = crypto.createCipheriv(\"aes-256-gcm\", crypto.createHash(\"sha256\").update(sharedSecret).digest(), ivBytes);\n            const encryptedData = Buffer.concat([cipher.update(data.seed, \"utf8\"), cipher.final()]);\n            authTag = cipher.getAuthTag().toString(\"hex\");\n            seedToStore = encryptedData.toString(\"hex\");\n            iv = ivBytes.toString(\"hex\");\n        }\n        existingSeedsInStore[data.walletId] = {\n            seed: seedToStore,\n            encrypted: encrypt,\n            authTag: authTag,\n            iv: iv,\n            networkId: data.networkId,\n        };\n        fs.writeFileSync(filePath, JSON.stringify(existingSeedsInStore, null, 2), \"utf8\");\n        return `Successfully saved seed for ${data.walletId} to ${filePath}.`;\n    }\n    /**\n     * Loads the seed of the Wallet from the given file.\n     *\n     * @deprecated Use loadSeedFromFile() instead\n     * @param filePath - The path of the file to load the seed from\n     * @returns A string indicating the success of the operation\n     */\n    async loadSeed(filePath) {\n        return this.loadSeedFromFile(filePath);\n    }\n    /**\n     * Loads the seed of the Wallet from the given file.\n     *\n     * @param filePath - The path of the file to load the seed from\n     * @returns A string indicating the success of the operation\n     */\n    async loadSeedFromFile(filePath) {\n        const existingSeedsInStore = this.getExistingSeeds(filePath);\n        if (Object.keys(existingSeedsInStore).length === 0) {\n            throw new errors_1.ArgumentError(`File ${filePath} does not contain any seed data`);\n        }\n        if (existingSeedsInStore[this.getId()] === undefined) {\n            throw new errors_1.ArgumentError(`File ${filePath} does not contain seed data for wallet ${this.getId()}`);\n        }\n        const seedData = existingSeedsInStore[this.getId()];\n        let seed = seedData.seed;\n        if (!seed) {\n            /* istanbul ignore next */\n            throw new errors_1.ArgumentError(\"Seed data is malformed\");\n        }\n        if (seedData.encrypted) {\n            const sharedSecret = this.getEncryptionKey();\n            if (!seedData.iv || !seedData.authTag) {\n                /* istanbul ignore next */\n                throw new errors_1.ArgumentError(\"Encrypted seed data is malformed\");\n            }\n            const decipher = crypto.createDecipheriv(\"aes-256-gcm\", crypto.createHash(\"sha256\").update(sharedSecret).digest(), Buffer.from(seedData.iv, \"hex\"));\n            decipher.setAuthTag(Buffer.from(seedData.authTag, \"hex\"));\n            const decryptedData = Buffer.concat([\n                decipher.update(Buffer.from(seed, \"hex\")),\n                decipher.final(),\n            ]);\n            seed = decryptedData.toString(\"utf8\");\n        }\n        this.setSeed(seed);\n        await this.listAddresses();\n        return `Successfully loaded seed for wallet ${this.getId()} from ${filePath}.`;\n    }\n    /**\n     * Returns the default address of the Wallet.\n     *\n     * @returns The default address\n     */\n    async getDefaultAddress() {\n        if (this.model.default_address === undefined) {\n            throw new Error(\"WalletModel default address not set\");\n        }\n        const defaultAddress = await this.getAddress(this.model.default_address.address_id);\n        if (!defaultAddress) {\n            throw new Error(\"Default address not found\");\n        }\n        return defaultAddress;\n    }\n    /**\n     * Returns whether the Wallet has a seed with which to derive keys and sign transactions.\n     *\n     * @returns Whether the Wallet has a seed with which to derive keys and sign transactions.\n     */\n    canSign() {\n        return this.master?.publicKey !== undefined;\n    }\n    /**\n     * Requests funds from the faucet for the Wallet's default address and returns the faucet transaction.\n     * This is only supported on testnet networks.\n     *\n     * @param assetId - The ID of the Asset to request from the faucet.\n     * @throws {Error} If the default address is not found.\n     * @throws {APIError} If the request fails.\n     * @returns The successful faucet transaction\n     */\n    async faucet(assetId) {\n        if (!this.model.default_address) {\n            throw new Error(\"Default address not found\");\n        }\n        const transaction = (await this.getDefaultAddress()).faucet(assetId);\n        return transaction;\n    }\n    /**\n     * Transfers the given amount of the given Asset to the given address. Only same-Network Transfers are supported.\n     * Currently only the default_address is used to source the Transfer.\n     *\n     * @param options - The options to create the Transfer.\n     * @param options.amount - The amount of the Asset to send.\n     * @param options.assetId - The ID of the Asset to send.\n     * @param options.destination - The destination of the transfer. If a Wallet, sends to the Wallet's default address. If a String, interprets it as the address ID.\n     * @param options.gasless - Whether the Transfer should be gasless. Defaults to false.\n     * @param options.skipBatching - When true, the Transfer will be submitted immediately. Otherwise, the Transfer will be batched. Defaults to false. Note: requires gasless option to be set to true.\n     * @returns The created Transfer object.\n     * @throws {APIError} if the API request to create a Transfer fails.\n     * @throws {APIError} if the API request to broadcast a Transfer fails.\n     */\n    async createTransfer(options) {\n        return (await this.getDefaultAddress()).createTransfer(options);\n    }\n    /**\n     * Creates a Payload Signature.\n     *\n     * @param unsignedPayload - The Unsigned Payload to sign.\n     * @returns A promise that resolves to the Payload Signature object.\n     * @throws {APIError} if the API request to create a Payload Signature fails.\n     * @throws {Error} if the default address is not found.\n     */\n    async createPayloadSignature(unsignedPayload) {\n        return (await this.getDefaultAddress()).createPayloadSignature(unsignedPayload);\n    }\n    /**\n     * Creates a Webhook for a wallet, monitors all wallet addresses for onchain events.\n     *\n     * @param notificationUri - The URI to which the webhook notifications will be sent.\n     *\n     * @returns The newly created webhook instance.\n     */\n    async createWebhook(notificationUri) {\n        const result = await coinbase_1.Coinbase.apiClients.webhook.createWalletWebhook(this.getId(), {\n            notification_uri: notificationUri,\n        });\n        return webhook_1.Webhook.init(result.data);\n    }\n    /**\n     * Invokes a contract with the given data.\n     *\n     * @param options - The options to invoke the contract\n     * @param options.contractAddress - The address of the contract the method will be invoked on.\n     * @param options.method - The method to invoke on the contract.\n     * @param options.abi - The ABI of the contract.\n     * @param options.args - The arguments to pass to the contract method invocation.\n     *   The keys should be the argument names and the values should be the argument values.\n     * @param options.amount - The amount of the asset to send to a payable contract method.\n     * @param options.assetId - The ID of the asset to send to a payable contract method.\n     *   The asset must be a denomination of the native asset. (Ex. \"wei\", \"gwei\", or \"eth\").\n     * @returns The ContractInvocation object.\n     * @throws {APIError} if the API request to create a contract invocation fails.\n     */\n    async invokeContract(options) {\n        return (await this.getDefaultAddress()).invokeContract(options);\n    }\n    /**\n     * Deploys an ERC20 token contract.\n     *\n     * @param options - The options for creating the ERC20 token.\n     * @param options.name - The name of the ERC20 token.\n     * @param options.symbol - The symbol of the ERC20 token.\n     * @param options.totalSupply - The total supply of the ERC20 token.\n     * @returns A Promise that resolves to the deployed SmartContract object.\n     * @throws {Error} If the private key is not loaded when not using server signer.\n     */\n    async deployToken(options) {\n        return (await this.getDefaultAddress()).deployToken(options);\n    }\n    /**\n     * Deploys an ERC721 token contract.\n     *\n     * @param options - The options for creating the ERC721 token.\n     * @param options.name - The name of the ERC721 token.\n     * @param options.symbol - The symbol of the ERC721 token.\n     * @param options.baseURI - The base URI of the ERC721 token.\n     * @returns A Promise that resolves to the deployed SmartContract object.\n     * @throws {Error} If the private key is not loaded when not using server signer.\n     */\n    async deployNFT(options) {\n        return (await this.getDefaultAddress()).deployNFT(options);\n    }\n    /**\n     * Deploys an ERC1155 token contract.\n     *\n     * @param options - The options for creating the ERC1155 token.\n     * @param options.name - The name of the ERC1155 token.\n     * @param options.symbol - The symbol of the ERC1155 token.\n     * @param options.baseURI - The base URI of the ERC1155 token.\n     * @returns A Promise that resolves to the deployed SmartContract object.\n     * @throws {Error} If the private key is not loaded when not using server signer.\n     */\n    async deployMultiToken(options) {\n        return (await this.getDefaultAddress()).deployMultiToken(options);\n    }\n    /**\n     * Deploys a custom contract.\n     *\n     * @param options - The options for creating the custom contract.\n     * @param options.solidityVersion - The version of the solidity compiler, must be 0.8.+, such as \"0.8.28+commit.7893614a\". See https://binaries.soliditylang.org/bin/list.json\n     * @param options.solidityInputJson - The input json for the solidity compiler. See https://docs.soliditylang.org/en/latest/using-the-compiler.html#input-description for more details.\n     * @param options.contractName - The name of the contract class to be deployed.\n     * @param options.constructorArgs - The arguments for the constructor.\n     * @returns A Promise that resolves to the deployed SmartContract object.\n     * @throws {Error} If the private key is not loaded when not using server signer.\n     */\n    async deployContract(options) {\n        return (await this.getDefaultAddress()).deployContract(options);\n    }\n    /**\n     * Fund the wallet from your account on the Coinbase Platform.\n     *\n     * @param options - The options to create the fund operation\n     * @param options.amount - The amount of the Asset to fund the wallet with\n     * @param options.assetId - The ID of the Asset to fund with. For Ether, eth, gwei, and wei are supported.\n     * @returns The created fund operation object\n     * @throws {Error} If the default address does not exist\n     */\n    async fund(options) {\n        const defaultAddress = await this.getDefaultAddress();\n        if (!defaultAddress) {\n            throw new Error(\"Default address does not exist\");\n        }\n        return defaultAddress.fund(options);\n    }\n    /**\n     * Get a quote for funding the wallet from your Coinbase platform account.\n     *\n     * @param options - The options to create the fund quote\n     * @param options.amount - The amount to fund\n     * @param options.assetId - The ID of the Asset to fund with. For Ether, eth, gwei, and wei are supported.\n     * @returns The fund quote object\n     * @throws {Error} If the default address does not exist\n     */\n    async quoteFund(options) {\n        const defaultAddress = await this.getDefaultAddress();\n        if (!defaultAddress) {\n            throw new Error(\"Default address does not exist\");\n        }\n        return defaultAddress.quoteFund(options);\n    }\n    /**\n     * Returns all the fund operations associated with the wallet's default address.\n     *\n     * @param options - The pagination options.\n     * @param options.limit - The maximum number of fund operations to return. Limit can range between 1 and 100.\n     * @param options.page - The cursor for pagination across multiple pages of fund operations. Don't include this parameter on the first call. Use the next page value returned in a previous response to request subsequent results.\n     * @returns The paginated list response of fund operations.\n     * @throws {Error} If the default address does not exist\n     */\n    async listFundOperations({ limit = coinbase_1.Coinbase.defaultPageLimit, page = undefined, } = {}) {\n        const defaultAddress = await this.getDefaultAddress();\n        if (!defaultAddress) {\n            throw new Error(\"Default address does not exist\");\n        }\n        return defaultAddress.listFundOperations({ limit, page });\n    }\n    /**\n     * Returns a String representation of the Wallet.\n     *\n     * @returns a String representation of the Wallet\n     */\n    toString() {\n        return `Wallet{id: '${this.model.id}', networkId: '${this.model.network_id}'}`;\n    }\n    /**\n     * Validates the seed and address models passed to the constructor.\n     *\n     * @param seed - The seed to use for the Wallet\n     */\n    validateSeed(seed) {\n        if (seed && seed.length !== 64 && seed.length !== 128) {\n            throw new errors_1.ArgumentError(\"Seed must be 32 or 64 bytes\");\n        }\n    }\n    /**\n     * Loads the seed data from the given file.\n     *\n     * @param filePath - The path of the file to load the seed data from\n     * @returns The seed data\n     */\n    getExistingSeeds(filePath) {\n        try {\n            const data = fs.readFileSync(filePath, \"utf8\");\n            if (!data) {\n                return {};\n            }\n            const seedData = JSON.parse(data);\n            if (!Object.entries(seedData).every(([key, value]) => typeof key === \"string\" &&\n                /* eslint-disable @typescript-eslint/no-explicit-any */\n                typeof value.authTag === \"string\" &&\n                typeof value.encrypted === \"boolean\" &&\n                typeof value.iv === \"string\" &&\n                typeof value.seed === \"string\")) {\n                throw new errors_1.ArgumentError(\"Malformed backup data\");\n            }\n            return seedData;\n        }\n        catch (error) {\n            /* eslint-enable @typescript-eslint/no-explicit-any */\n            if (error.code === \"ENOENT\") {\n                return {};\n            }\n            throw new errors_1.ArgumentError(\"Malformed backup data\");\n        }\n    }\n    /**\n     * Gets the key for encrypting seed data.\n     *\n     * For EC keys (PEM format), it uses crypto.diffieHellman.\n     * For Ed25519 keys (assumed to be a base64-encoded 64-byte string), it converts the secret key\n     * to an X25519 key using ed2curve.\n     *\n     * @returns The encryption key.\n     */\n    getEncryptionKey() {\n        const apiKeyPrivateKey = coinbase_1.Coinbase.apiKeyPrivateKey;\n        if (apiKeyPrivateKey.startsWith(\"-----BEGIN\")) {\n            // Assume EC key in PEM format.\n            const privateKey = crypto.createPrivateKey(apiKeyPrivateKey);\n            const publicKey = crypto.createPublicKey(apiKeyPrivateKey);\n            return crypto.diffieHellman({ privateKey, publicKey });\n        }\n        else {\n            // Assume Ed25519 key: a base64-encoded 64-byte string (first 32 bytes = seed, next 32 = public key)\n            const decoded = Buffer.from(apiKeyPrivateKey, \"base64\");\n            if (decoded.length !== 64) {\n                throw new Error(\"Invalid Ed25519 key format\");\n            }\n            const seed = decoded.slice(0, 32);\n            // Convert the Ed25519 seed to an X25519 key using ed2curve.\n            const x25519 = ed2curve.convertSecretKey(new Uint8Array(seed));\n            if (!x25519) {\n                throw new Error(\"Failed to convert Ed25519 key to X25519\");\n            }\n            return Buffer.from(x25519);\n        }\n    }\n    /**\n     * Returns a WalletAddress object for the given AddressModel.\n     *\n     * @param addressModel - The AddressModel to build the WalletAddress from.\n     * @param index - The index of the AddressModel.\n     * @returns The WalletAddress object.\n     */\n    buildWalletAddress(addressModel, index) {\n        if (!this.master) {\n            return new wallet_address_1.WalletAddress(addressModel);\n        }\n        const key = this.deriveKey(index);\n        const ethWallet = new ethers_2.ethers.Wallet((0, utils_1.convertStringToHex)(key.privateKey));\n        if (ethWallet.address != addressModel.address_id) {\n            throw new Error(`Seed does not match wallet`);\n        }\n        return new wallet_address_1.WalletAddress(addressModel, ethWallet);\n    }\n    /**\n     * Waits until the ServerSigner has created a seed for the Wallet.\n     *\n     * @param walletId - The ID of the Wallet that is awaiting seed creation.\n     * @param intervalSeconds - The interval at which to poll the CDPService, in seconds.\n     * @param timeoutSeconds - The maximum amount of time to wait for the ServerSigner to create a seed, in seconds.\n     * @throws {APIError} if the API request to get a Wallet fails.\n     * @throws {Error} if the ServerSigner times out.\n     */\n    async waitForSigner(walletId, intervalSeconds = 0.2, timeoutSeconds = 20) {\n        const startTime = Date.now();\n        while (Date.now() - startTime < timeoutSeconds * 1000) {\n            const response = await coinbase_1.Coinbase.apiClients.wallet.getWallet(walletId);\n            if (response?.data.server_signer_status === types_1.ServerSignerStatus.ACTIVE) {\n                return;\n            }\n            await (0, utils_1.delay)(intervalSeconds);\n        }\n        throw new Error(\"Wallet creation timed out. Check status of your Server-Signer\");\n    }\n    /**\n     * Sets the master node for the given seed, if valid. If the seed is undefined it will set the master node using a random seed.\n     *\n     * @param seed - The seed to use for the Wallet.\n     * @returns The master node for the given seed.\n     */\n    setMasterNode(seed) {\n        if (seed === \"\") {\n            return undefined;\n        }\n        if (seed === undefined) {\n            seed = ethers_2.ethers.Wallet.createRandom().privateKey.slice(2);\n        }\n        this.validateSeed(seed);\n        this.seed = seed;\n        this.master = bip32_1.HDKey.fromMasterSeed(Buffer.from(seed, \"hex\"));\n    }\n    /**\n     * Derives a key for an already registered Address in the Wallet.\n     *\n     * @param index - The index of the Address to derive.\n     * @throws {Error} - If the key derivation fails.\n     * @returns The derived key.\n     */\n    deriveKey(index) {\n        if (!this.master) {\n            throw new Error(\"Cannot derive key for Wallet without seed loaded\");\n        }\n        const derivedKey = this.master?.derive(this.addressPathPrefix + `/${index}`);\n        if (!derivedKey?.privateKey) {\n            throw new Error(\"Failed to derive key\");\n        }\n        return derivedKey;\n    }\n    /**\n     * Creates an attestation for the Address currently being created.\n     *\n     * @param key - The key of the Wallet.\n     * @returns The attestation.\n     */\n    createAttestation(key) {\n        if (!key.publicKey || !key.privateKey) {\n            /* istanbul ignore next */\n            throw Error;\n        }\n        const publicKey = (0, utils_1.convertStringToHex)(key.publicKey);\n        const payload = JSON.stringify({\n            wallet_id: this.model.id,\n            public_key: publicKey,\n        });\n        const hashedPayload = crypto.createHash(\"sha256\").update(payload).digest();\n        const signature = secp256k1.ecdsaSign(hashedPayload, key.privateKey);\n        const r = signature.signature.slice(0, 32);\n        const s = signature.signature.slice(32, 64);\n        const v = signature.recid + 27 + 4;\n        const newSignatureBuffer = Buffer.concat([Buffer.from([v]), r, s]);\n        const newSignatureHex = newSignatureBuffer.toString(\"hex\");\n        return newSignatureHex;\n    }\n    /**\n     * Reloads the Wallet model with the latest data from the server.\n     *\n     * @throws {APIError} if the API request to get a Wallet fails.\n     */\n    async reload() {\n        const result = await coinbase_1.Coinbase.apiClients.wallet.getWallet(this.model.id);\n        this.model = result?.data;\n    }\n}\nexports.Wallet = Wallet;\nWallet.MAX_ADDRESSES = 20;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL3dhbGxldC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxjQUFjO0FBQ2QsZ0JBQWdCLG1CQUFPLENBQUMsb0VBQWM7QUFDdEMsZ0JBQWdCLG1CQUFPLENBQUMsZ0VBQWM7QUFDdEMsa0JBQWtCLG1CQUFPLENBQUMsOEZBQWdDO0FBQzFELGlCQUFpQixtQkFBTyxDQUFDLGlFQUFRO0FBQ2pDLDRCQUE0QixtQkFBTyxDQUFDLHNCQUFRO0FBQzVDLHFDQUFxQyxtQkFBTyxDQUFDLDhEQUFZO0FBQ3pELGlCQUFpQixtQkFBTyxDQUFDLGlFQUFRO0FBQ2pDLHdCQUF3QixtQkFBTyxDQUFDLGNBQUk7QUFDcEMsOEJBQThCLG1CQUFPLENBQUMsMkRBQVU7QUFDaEQsK0JBQStCLG1CQUFPLENBQUMsMERBQVc7QUFDbEQseUJBQXlCLG1CQUFPLENBQUMscUhBQTBCO0FBQzNELGdCQUFnQixtQkFBTyxDQUFDLG1GQUFTO0FBQ2pDLGtCQUFrQixtQkFBTyxDQUFDLHVGQUFXO0FBQ3JDLHNCQUFzQixtQkFBTyxDQUFDLCtGQUFlO0FBQzdDLG1CQUFtQixtQkFBTyxDQUFDLHlGQUFZO0FBQ3ZDLGlCQUFpQixtQkFBTyxDQUFDLHFGQUFVO0FBQ25DLGdCQUFnQixtQkFBTyxDQUFDLG1GQUFTO0FBQ2pDLGdCQUFnQixtQkFBTyxDQUFDLG1GQUFTO0FBQ2pDLGtCQUFrQixtQkFBTyxDQUFDLHVGQUFXO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtHQUFrRztBQUNsRztBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isa0VBQWtFLElBQUk7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZUFBZTtBQUMvQixnQkFBZ0IsZUFBZTtBQUMvQixnQkFBZ0IsZUFBZTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZUFBZTtBQUMvQixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0EsMEJBQTBCLG9HQUFvRyxJQUFJO0FBQ2xJO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixlQUFlO0FBQy9CLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7QUFDQSxrQ0FBa0Msc0hBQXNILElBQUk7QUFDNUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZUFBZTtBQUMvQixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZUFBZTtBQUMvQixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxzQkFBc0Isb0JBQW9CO0FBQ3ZHO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0EsMEZBQTBGO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0EsNEZBQTRGO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0EsaUdBQWlHO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0EsMEZBQTBGO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEdBQThHO0FBQzlHO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxpRUFBaUUsSUFBSTtBQUNqSCxrRkFBa0YsYUFBYTtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQSw0RkFBNEY7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQSw4RkFBOEY7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQSxpR0FBaUc7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxlQUFlLEtBQUssU0FBUztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELFVBQVU7QUFDL0Q7QUFDQTtBQUNBLHFEQUFxRCxVQUFVLHdDQUF3QyxhQUFhO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsY0FBYyxPQUFPLFNBQVM7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQixnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0EsK0JBQStCLGtFQUFrRSxJQUFJO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGFBQWE7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsT0FBTyxjQUFjLGlCQUFpQixzQkFBc0IsRUFBRTtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsdUJBQXVCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLE1BQU07QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXJ2aXZhbC1mdW4vLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL3dhbGxldC5qcz9mMmI4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLldhbGxldCA9IHZvaWQgMDtcbmNvbnN0IGJpcDMyXzEgPSByZXF1aXJlKFwiQHNjdXJlL2JpcDMyXCIpO1xuY29uc3QgYmlwMzlfMSA9IHJlcXVpcmUoXCJAc2N1cmUvYmlwMzlcIik7XG5jb25zdCBlbmdsaXNoXzEgPSByZXF1aXJlKFwiQHNjdXJlL2JpcDM5L3dvcmRsaXN0cy9lbmdsaXNoXCIpO1xuY29uc3QgZXRoZXJzXzEgPSByZXF1aXJlKFwiZXRoZXJzXCIpO1xuY29uc3QgY3J5cHRvID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJjcnlwdG9cIikpO1xuY29uc3QgZGVjaW1hbF9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJkZWNpbWFsLmpzXCIpKTtcbmNvbnN0IGV0aGVyc18yID0gcmVxdWlyZShcImV0aGVyc1wiKTtcbmNvbnN0IGZzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJmc1wiKSk7XG5jb25zdCBlZDJjdXJ2ZSA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiZWQyY3VydmVcIikpO1xuY29uc3Qgc2VjcDI1NmsxID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJzZWNwMjU2azFcIikpO1xuY29uc3Qgd2FsbGV0X2FkZHJlc3NfMSA9IHJlcXVpcmUoXCIuL2FkZHJlc3Mvd2FsbGV0X2FkZHJlc3NcIik7XG5jb25zdCBhc3NldF8xID0gcmVxdWlyZShcIi4vYXNzZXRcIik7XG5jb25zdCBiYWxhbmNlXzEgPSByZXF1aXJlKFwiLi9iYWxhbmNlXCIpO1xuY29uc3QgYmFsYW5jZV9tYXBfMSA9IHJlcXVpcmUoXCIuL2JhbGFuY2VfbWFwXCIpO1xuY29uc3QgY29pbmJhc2VfMSA9IHJlcXVpcmUoXCIuL2NvaW5iYXNlXCIpO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi9lcnJvcnNcIik7XG5jb25zdCB0eXBlc18xID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5jb25zdCB3ZWJob29rXzEgPSByZXF1aXJlKFwiLi93ZWJob29rXCIpO1xuLyoqXG4gKiBBIHJlcHJlc2VudGF0aW9uIG9mIGEgV2FsbGV0LiBXYWxsZXRzIGNvbWUgd2l0aCBhIHNpbmdsZSBkZWZhdWx0IEFkZHJlc3MsIGJ1dCBjYW4gZXhwYW5kIHRvIGhhdmUgYSBzZXQgb2YgQWRkcmVzc2VzLFxuICogZWFjaCBvZiB3aGljaCBjYW4gaG9sZCBhIGJhbGFuY2Ugb2Ygb25lIG9yIG1vcmUgQXNzZXRzLiBXYWxsZXRzIGNhbiBjcmVhdGUgbmV3IEFkZHJlc3NlcywgbGlzdCB0aGVpciBhZGRyZXNzZXMsXG4gKiBsaXN0IHRoZWlyIGJhbGFuY2VzLCBhbmQgdHJhbnNmZXIgQXNzZXRzIHRvIG90aGVyIEFkZHJlc3Nlcy4gV2FsbGV0cyBzaG91bGQgYmUgY3JlYXRlZCB0aHJvdWdoIFVzZXIuY3JlYXRlV2FsbGV0IG9yIFVzZXIuaW1wb3J0V2FsbGV0LlxuICogV2FsbGV0cyBzaG91bGQgYmUgY3JlYXRlZCB1c2luZyBgV2FsbGV0LmNyZWF0ZWAsIGltcG9ydGVkIHVzaW5nIGBXYWxsZXQuaW1wb3J0YCwgb3IgZmV0Y2hlZCB1c2luZyBgV2FsbGV0LmZldGNoYC5cbiAqIEV4aXN0aW5nIHdhbGxldHMgY2FuIGJlIGltcG9ydGVkIHdpdGggYSBzZWVkIHVzaW5nIGBXYWxsZXQuaW1wb3J0YC5cbiAqIFdhbGxldHMgYmFja2VkIGJ5IGEgU2VydmVyIFNpZ25lciBjYW4gYmUgZmV0Y2hlZCB3aXRoIGBXYWxsZXQuZmV0Y2hgIGFuZCB1c2VkIGZvciBzaWduaW5nIG9wZXJhdGlvbnMgaW1tZWRpYXRlbHkuXG4gKi9cbmNsYXNzIFdhbGxldCB7XG4gICAgLyoqXG4gICAgICogUHJpdmF0ZSBjb25zdHJ1Y3RvciB0byBwcmV2ZW50IGRpcmVjdCBpbnN0YW50aWF0aW9uIG91dHNpZGUgb2YgZmFjdG9yeSBtZXRob2QuIFVzZSBXYWxsZXQuaW5pdCBpbnN0ZWFkLlxuICAgICAqXG4gICAgICogQGlnbm9yZVxuICAgICAqIEBwYXJhbSBtb2RlbCAtIFRoZSB3YWxsZXQgbW9kZWwgb2JqZWN0LlxuICAgICAqIEBwYXJhbSBtYXN0ZXIgLSBUaGUgSEQgbWFzdGVyIGtleS5cbiAgICAgKiBAcGFyYW0gc2VlZCAtIFRoZSBzZWVkIHRvIHVzZSBmb3IgdGhlIFdhbGxldC4gRXhwZWN0cyBhIDMyLWJ5dGUgaGV4YWRlY2ltYWwgd2l0aCBubyAweCBwcmVmaXguXG4gICAgICogQGhpZGVjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG1vZGVsLCBtYXN0ZXIsIHNlZWQpIHtcbiAgICAgICAgdGhpcy5hZGRyZXNzZXMgPSBbXTtcbiAgICAgICAgdGhpcy5hZGRyZXNzUGF0aFByZWZpeCA9IFwibS80NCcvNjAnLzAnLzBcIjtcbiAgICAgICAgdGhpcy5tb2RlbCA9IG1vZGVsO1xuICAgICAgICB0aGlzLm1hc3RlciA9IG1hc3RlcjtcbiAgICAgICAgdGhpcy5zZWVkID0gc2VlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdHMgdGhlIFdhbGxldHMgYmVsb25naW5nIHRvIHRoZSBDRFAgUHJvamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIHBhZ2luYXRpb24gb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5saW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBXYWxsZXRzIHRvIHJldHVybi4gTGltaXQgY2FuIHJhbmdlIGJldHdlZW4gMSBhbmQgMTAwLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnBhZ2UgLSBUaGUgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiBXYWxsZXRzLiBEb25cXCYjMzk7dCBpbmNsdWRlIHRoaXMgcGFyYW1ldGVyIG9uIHRoZSBmaXJzdCBjYWxsLiBVc2UgdGhlIG5leHQgcGFnZSB2YWx1ZSByZXR1cm5lZCBpbiBhIHByZXZpb3VzIHJlc3BvbnNlIHRvIHJlcXVlc3Qgc3Vic2VxdWVudCByZXN1bHRzLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHBhZ2luYXRlZCBsaXN0IHJlc3BvbnNlIG9mIFdhbGxldHMuXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIGxpc3RXYWxsZXRzKHsgbGltaXQgPSBjb2luYmFzZV8xLkNvaW5iYXNlLmRlZmF1bHRQYWdlTGltaXQsIHBhZ2UgPSB1bmRlZmluZWQsIH0gPSB7fSkge1xuICAgICAgICBjb25zdCBkYXRhID0gW107XG4gICAgICAgIGxldCBuZXh0UGFnZTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjb2luYmFzZV8xLkNvaW5iYXNlLmFwaUNsaWVudHMud2FsbGV0Lmxpc3RXYWxsZXRzKGxpbWl0LCBwYWdlKTtcbiAgICAgICAgY29uc3Qgd2FsbGV0cyA9IHJlc3BvbnNlLmRhdGEuZGF0YTtcbiAgICAgICAgZm9yIChjb25zdCB3YWxsZXQgb2Ygd2FsbGV0cykge1xuICAgICAgICAgICAgZGF0YS5wdXNoKFdhbGxldC5pbml0KHdhbGxldCwgXCJcIikpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhhc01vcmUgPSByZXNwb25zZS5kYXRhLmhhc19tb3JlO1xuICAgICAgICBpZiAoaGFzTW9yZSkge1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLmRhdGEubmV4dF9wYWdlKSB7XG4gICAgICAgICAgICAgICAgbmV4dFBhZ2UgPSByZXNwb25zZS5kYXRhLm5leHRfcGFnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIGhhc01vcmUsXG4gICAgICAgICAgICBuZXh0UGFnZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyBhIFdhbGxldCBieSBpdHMgSUQuIFRoZSByZXR1cm5lZCB3YWxsZXQgY2FuIGJlIGltbWVkaWF0ZWx5IHVzZWQgZm9yIHNpZ25pbmcgb3BlcmF0aW9ucyBpZiBiYWNrZWQgYnkgYSBzZXJ2ZXIgc2lnbmVyLlxuICAgICAqIElmIHRoZSB3YWxsZXQgaXMgbm90IGJhY2tlZCBieSBhIHNlcnZlciBzaWduZXIsIHRoZSB3YWxsZXQncyBzZWVkIHdpbGwgbmVlZCB0byBiZSBzZXQgYmVmb3JlIGl0IGNhbiBiZSB1c2VkIGZvciBzaWduaW5nIG9wZXJhdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gd2FsbGV0X2lkIC0gVGhlIElEIG9mIHRoZSBXYWxsZXQgdG8gZmV0Y2hcbiAgICAgKiBAcmV0dXJucyBUaGUgZmV0Y2hlZCBXYWxsZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgZmV0Y2god2FsbGV0X2lkKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY29pbmJhc2VfMS5Db2luYmFzZS5hcGlDbGllbnRzLndhbGxldC5nZXRXYWxsZXQod2FsbGV0X2lkKTtcbiAgICAgICAgcmV0dXJuIFdhbGxldC5pbml0KHJlc3BvbnNlLmRhdGEsIFwiXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2FkcyBhbiBleGlzdGluZyBDRFAgV2FsbGV0IHVzaW5nIGEgd2FsbGV0IGRhdGEgb2JqZWN0IG9yIG1uZW1vbmljIHNlZWQgcGhyYXNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGRhdGEgLSBUaGUgZGF0YSB1c2VkIHRvIGltcG9ydCB0aGUgd2FsbGV0OlxuICAgICAqICAgLSBJZiBXYWxsZXREYXRhOiBNdXN0IGNvbnRhaW4gd2FsbGV0SWQgKG9yIHdhbGxldF9pZCkgYW5kIHNlZWQuXG4gICAgICogICAgIEFsbG93cyBmb3IgdGhlIGxvYWRpbmcgb2YgYW4gZXhpc3RpbmcgQ0RQIHdhbGxldCBpbnRvIENEUC5cbiAgICAgKiAgIC0gSWYgTW5lbW9uaWNTZWVkUGhyYXNlOiBNdXN0IGNvbnRhaW4gYSB2YWxpZCBCSVAtMzkgbW5lbW9uaWMgcGhyYXNlICgxMiwgMTUsIDE4LCAyMSwgb3IgMjQgd29yZHMpLlxuICAgICAqICAgICBBbGxvd3MgZm9yIHRoZSBpbXBvcnQgb2YgYW4gZXh0ZXJuYWwgd2FsbGV0IGludG8gQ0RQIGFzIGEgMS1vZi0xIHdhbGxldC5cbiAgICAgKiBAcGFyYW0gbmV0d29ya0lkIC0gdGhlIElEIG9mIHRoZSBibG9ja2NoYWluIG5ldHdvcmsuIERlZmF1bHRzIHRvICdiYXNlLXNlcG9saWEnLlxuICAgICAqIEByZXR1cm5zIEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBsb2FkZWQgV2FsbGV0IGluc3RhbmNlXG4gICAgICogQHRocm93cyB7QXJndW1lbnRFcnJvcn0gSWYgdGhlIGRhdGEgZm9ybWF0IGlzIGludmFsaWQuXG4gICAgICogQHRocm93cyB7QXJndW1lbnRFcnJvcn0gSWYgdGhlIHNlZWQgaXMgbm90IHByb3ZpZGVkLlxuICAgICAqIEB0aHJvd3Mge0FyZ3VtZW50RXJyb3J9IElmIHRoZSBtbmVtb25pYyBzZWVkIHBocmFzZSBpcyBpbnZhbGlkLlxuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyBpbXBvcnQoZGF0YSwgbmV0d29ya0lkID0gY29pbmJhc2VfMS5Db2luYmFzZS5uZXR3b3Jrcy5CYXNlU2Vwb2xpYSkge1xuICAgICAgICAvLyBDaGVjayBpZiBkYXRhIGlzIGEgbW5lbW9uaWMgc2VlZCBwaHJhc2Ugb2JqZWN0XG4gICAgICAgIGlmICgoMCwgdHlwZXNfMS5pc01uZW1vbmljU2VlZFBocmFzZSkoZGF0YSkpIHtcbiAgICAgICAgICAgIC8vIEhhbmRsZSBtbmVtb25pYyBzZWVkIHBocmFzZSBvYmplY3QgaW1wb3J0XG4gICAgICAgICAgICBpZiAoIWRhdGEubW5lbW9uaWNQaHJhc2UpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuQXJndW1lbnRFcnJvcihcIkJJUC0zOSBtbmVtb25pYyBzZWVkIHBocmFzZSBtdXN0IGJlIHByb3ZpZGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCEoMCwgYmlwMzlfMS52YWxpZGF0ZU1uZW1vbmljKShkYXRhLm1uZW1vbmljUGhyYXNlLCBlbmdsaXNoXzEud29yZGxpc3QpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkFyZ3VtZW50RXJyb3IoXCJJbnZhbGlkIEJJUC0zOSBtbmVtb25pYyBzZWVkIHBocmFzZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENvbnZlcnQgbW5lbW9uaWMgcGhyYXNlIHRvIHNlZWRcbiAgICAgICAgICAgIGNvbnN0IHNlZWRCdWZmZXIgPSAoMCwgYmlwMzlfMS5tbmVtb25pY1RvU2VlZFN5bmMpKGRhdGEubW5lbW9uaWNQaHJhc2UpO1xuICAgICAgICAgICAgY29uc3Qgc2VlZCA9ICgwLCBldGhlcnNfMS5oZXhsaWZ5KShzZWVkQnVmZmVyKS5zbGljZSgyKTsgLy8gcmVtb3ZlIDB4IHByZWZpeFxuICAgICAgICAgICAgLy8gQ3JlYXRlIHdhbGxldCB1c2luZyB0aGUgcHJvdmlkZWQgc2VlZFxuICAgICAgICAgICAgY29uc3Qgd2FsbGV0ID0gYXdhaXQgV2FsbGV0LmNyZWF0ZVdpdGhTZWVkKHtcbiAgICAgICAgICAgICAgICBzZWVkOiBzZWVkLFxuICAgICAgICAgICAgICAgIG5ldHdvcmtJZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gRW5zdXJlIHRoZSB3YWxsZXQgaXMgY3JlYXRlZFxuICAgICAgICAgICAgYXdhaXQgd2FsbGV0Lmxpc3RBZGRyZXNzZXMoKTtcbiAgICAgICAgICAgIHJldHVybiB3YWxsZXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKDAsIHR5cGVzXzEuaXNXYWxsZXREYXRhKShkYXRhKSkge1xuICAgICAgICAgICAgLy8gSGFuZGxlIFdhbGxldERhdGEgb2JqZWN0IGltcG9ydFxuICAgICAgICAgICAgY29uc3Qgd2FsbGV0SWQgPSBkYXRhLndhbGxldElkIHx8IGRhdGEud2FsbGV0X2lkO1xuICAgICAgICAgICAgaWYgKCF3YWxsZXRJZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Bcmd1bWVudEVycm9yKFwiV2FsbGV0IElEIG11c3QgYmUgcHJvdmlkZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWRhdGEuc2VlZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Bcmd1bWVudEVycm9yKFwiU2VlZCBtdXN0IGJlIHByb3ZpZGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgd2FsbGV0TW9kZWwgPSBhd2FpdCBjb2luYmFzZV8xLkNvaW5iYXNlLmFwaUNsaWVudHMud2FsbGV0LmdldFdhbGxldCh3YWxsZXRJZCk7XG4gICAgICAgICAgICBjb25zdCB3YWxsZXQgPSBXYWxsZXQuaW5pdCh3YWxsZXRNb2RlbC5kYXRhLCBkYXRhLnNlZWQpO1xuICAgICAgICAgICAgYXdhaXQgd2FsbGV0Lmxpc3RBZGRyZXNzZXMoKTtcbiAgICAgICAgICAgIHJldHVybiB3YWxsZXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuQXJndW1lbnRFcnJvcihcIkludmFsaWQgaW1wb3J0IGRhdGEgZm9ybWF0XCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgV2FsbGV0IHdpdGggYSByYW5kb20gc2VlZC5cbiAgICAgKlxuICAgICAqIEBjb25zdHJ1Y3RzIFdhbGxldFxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgdG8gY3JlYXRlIHRoZSBXYWxsZXQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMubmV0d29ya0lkIC0gdGhlIElEIG9mIHRoZSBibG9ja2NoYWluIG5ldHdvcmsuIERlZmF1bHRzIHRvICdiYXNlLXNlcG9saWEnLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmludGVydmFsU2Vjb25kcyAtIFRoZSBpbnRlcnZhbCBhdCB3aGljaCB0byBwb2xsIHRoZSBiYWNrZW5kLCBpbiBzZWNvbmRzLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnRpbWVvdXRTZWNvbmRzIC0gVGhlIG1heGltdW0gYW1vdW50IG9mIHRpbWUgdG8gd2FpdCBmb3IgdGhlIFNlcnZlclNpZ25lciB0byBjcmVhdGUgYSBzZWVkLCBpbiBzZWNvbmRzLlxuICAgICAqIEB0aHJvd3Mge0FyZ3VtZW50RXJyb3J9IElmIHRoZSBtb2RlbCBvciBjbGllbnQgaXMgbm90IHByb3ZpZGVkLlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSAtIElmIGFkZHJlc3MgZGVyaXZhdGlvbiBvciBjYWNoaW5nIGZhaWxzLlxuICAgICAqIEB0aHJvd3Mge0FQSUVycm9yfSAtIElmIHRoZSByZXF1ZXN0IGZhaWxzLlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIG5ldyBXYWxsZXQgb2JqZWN0LlxuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyBjcmVhdGUoeyBuZXR3b3JrSWQgPSBjb2luYmFzZV8xLkNvaW5iYXNlLm5ldHdvcmtzLkJhc2VTZXBvbGlhLCB0aW1lb3V0U2Vjb25kcyA9IDIwLCBpbnRlcnZhbFNlY29uZHMgPSAwLjIsIH0gPSB7fSkge1xuICAgICAgICByZXR1cm4gV2FsbGV0LmNyZWF0ZVdpdGhTZWVkKHtcbiAgICAgICAgICAgIG5ldHdvcmtJZCxcbiAgICAgICAgICAgIHRpbWVvdXRTZWNvbmRzLFxuICAgICAgICAgICAgaW50ZXJ2YWxTZWNvbmRzLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBXYWxsZXQgd2l0aCB0aGUgZ2l2ZW4gc2VlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgdG8gY3JlYXRlIHRoZSBXYWxsZXQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuc2VlZCAtIFRoZSBzZWVkIHRvIHVzZSBmb3IgdGhlIFdhbGxldC4gSWYgdW5kZWZpbmVkLCBhIHJhbmRvbSBzZWVkIHdpbGwgYmUgZ2VuZXJhdGVkLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLm5ldHdvcmtJZCAtIHRoZSBJRCBvZiB0aGUgYmxvY2tjaGFpbiBuZXR3b3JrLiBEZWZhdWx0cyB0byAnYmFzZS1zZXBvbGlhJy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5pbnRlcnZhbFNlY29uZHMgLSBUaGUgaW50ZXJ2YWwgYXQgd2hpY2ggdG8gcG9sbCB0aGUgYmFja2VuZCwgaW4gc2Vjb25kcy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy50aW1lb3V0U2Vjb25kcyAtIFRoZSBtYXhpbXVtIGFtb3VudCBvZiB0aW1lIHRvIHdhaXQgZm9yIHRoZSBTZXJ2ZXJTaWduZXIgdG8gY3JlYXRlIGEgc2VlZCwgaW4gc2Vjb25kcy5cbiAgICAgKiBAdGhyb3dzIHtBcmd1bWVudEVycm9yfSBJZiB0aGUgbW9kZWwgb3IgY2xpZW50IGlzIG5vdCBwcm92aWRlZC5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBJZiBhZGRyZXNzIGRlcml2YXRpb24gb3IgY2FjaGluZyBmYWlscy5cbiAgICAgKiBAdGhyb3dzIHtBUElFcnJvcn0gLSBJZiB0aGUgcmVxdWVzdCBmYWlscy5cbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBuZXcgV2FsbGV0IG9iamVjdC5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgY3JlYXRlV2l0aFNlZWQoeyBzZWVkID0gdW5kZWZpbmVkLCBuZXR3b3JrSWQgPSBjb2luYmFzZV8xLkNvaW5iYXNlLm5ldHdvcmtzLkJhc2VTZXBvbGlhLCB0aW1lb3V0U2Vjb25kcyA9IDIwLCBpbnRlcnZhbFNlY29uZHMgPSAwLjIsIH0gPSB7fSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjb2luYmFzZV8xLkNvaW5iYXNlLmFwaUNsaWVudHMud2FsbGV0LmNyZWF0ZVdhbGxldCh7XG4gICAgICAgICAgICB3YWxsZXQ6IHtcbiAgICAgICAgICAgICAgICBuZXR3b3JrX2lkOiBuZXR3b3JrSWQsXG4gICAgICAgICAgICAgICAgdXNlX3NlcnZlcl9zaWduZXI6IGNvaW5iYXNlXzEuQ29pbmJhc2UudXNlU2VydmVyU2lnbmVyLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHdhbGxldCA9IFdhbGxldC5pbml0KHJlc3VsdC5kYXRhLCBzZWVkKTtcbiAgICAgICAgaWYgKGNvaW5iYXNlXzEuQ29pbmJhc2UudXNlU2VydmVyU2lnbmVyKSB7XG4gICAgICAgICAgICBhd2FpdCB3YWxsZXQud2FpdEZvclNpZ25lcih3YWxsZXQuZ2V0SWQoKSwgaW50ZXJ2YWxTZWNvbmRzLCB0aW1lb3V0U2Vjb25kcyk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgd2FsbGV0LmNyZWF0ZUFkZHJlc3MoKTtcbiAgICAgICAgcmV0dXJuIHdhbGxldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBXYWxsZXQgb2JqZWN0LiBEbyBub3QgdXNlIHRoaXMgbWV0aG9kIGRpcmVjdGx5LiBJbnN0ZWFkLCB1c2Ugb25lIG9mOlxuICAgICAqIC0gV2FsbGV0LmNyZWF0ZSAoQ3JlYXRlIGEgbmV3IFdhbGxldCksXG4gICAgICogLSBXYWxsZXQuaW1wb3J0IChJbXBvcnQgYSBXYWxsZXQgd2l0aCBzZWVkKSxcbiAgICAgKiAtIFdhbGxldC5mZXRjaCAoZmV0Y2ggYSBXYWxsZXQgYnkgSUQgdy9vIHNlZWQsIHVzZWZ1bCBmb3Igc2VydmVyIHNpZ25lciB3YWxsZXRzKS5cbiAgICAgKlxuICAgICAqIEBjb25zdHJ1Y3RzIFdhbGxldFxuICAgICAqIEBwYXJhbSBtb2RlbCAtIFRoZSB1bmRlcmx5aW5nIFdhbGxldCBtb2RlbCBvYmplY3RcbiAgICAgKiBAcGFyYW0gc2VlZCAtIFRoZSBzZWVkIHRvIHVzZSBmb3IgdGhlIFdhbGxldC4gRXhwZWN0cyBhIDMyLWJ5dGUgaGV4YWRlY2ltYWwgd2l0aCBubyAweCBwcmVmaXguIElmIG51bGwgb3IgdW5kZWZpbmVkLCBhIG5ldyBzZWVkIHdpbGwgYmUgZ2VuZXJhdGVkLlxuICAgICAqIElmIHRoZSBlbXB0eSBzdHJpbmcsIG5vIHNlZWQgaXMgZ2VuZXJhdGVkLCBhbmQgdGhlIFdhbGxldCB3aWxsIGJlIGluc3RhbnRpYXRlZCB3aXRob3V0IGEgc2VlZCBhbmQgaXRzIGNvcnJlc3BvbmRpbmcgcHJpdmF0ZSBrZXlzLlxuICAgICAqIEB0aHJvd3Mge0FyZ3VtZW50RXJyb3J9IElmIHRoZSBtb2RlbCBvciBjbGllbnQgaXMgbm90IHByb3ZpZGVkLlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSAtIElmIGFkZHJlc3MgZGVyaXZhdGlvbiBvciBjYWNoaW5nIGZhaWxzLlxuICAgICAqIEB0aHJvd3Mge0FQSUVycm9yfSAtIElmIHRoZSByZXF1ZXN0IGZhaWxzLlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIG5ldyBXYWxsZXQgb2JqZWN0LlxuICAgICAqL1xuICAgIHN0YXRpYyBpbml0KG1vZGVsLCBzZWVkKSB7XG4gICAgICAgIGNvbnN0IHdhbGxldCA9IG5ldyBXYWxsZXQobW9kZWwsIHVuZGVmaW5lZCwgc2VlZCk7XG4gICAgICAgIGlmIChjb2luYmFzZV8xLkNvaW5iYXNlLnVzZVNlcnZlclNpZ25lcikge1xuICAgICAgICAgICAgcmV0dXJuIHdhbGxldDtcbiAgICAgICAgfVxuICAgICAgICB3YWxsZXQuc2V0TWFzdGVyTm9kZShzZWVkKTtcbiAgICAgICAgcmV0dXJuIHdhbGxldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhwb3J0cyB0aGUgV2FsbGV0J3MgZGF0YSB0byBhIFdhbGxldERhdGEgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIFdhbGxldCdzIGRhdGEuXG4gICAgICogQHRocm93cyB7QVBJRXJyb3J9IC0gSWYgdGhlIHJlcXVlc3QgZmFpbHMuXG4gICAgICovXG4gICAgZXhwb3J0KCkge1xuICAgICAgICBpZiAoIXRoaXMuc2VlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGV4cG9ydCBXYWxsZXQgd2l0aG91dCBsb2FkZWQgc2VlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2FsbGV0SWQ6IHRoaXMuZ2V0SWQoKSxcbiAgICAgICAgICAgIHNlZWQ6IHRoaXMuc2VlZCxcbiAgICAgICAgICAgIG5ldHdvcmtJZDogdGhpcy5nZXROZXR3b3JrSWQoKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBBZGRyZXNzIGluIHRoZSBXYWxsZXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgbmV3IEFkZHJlc3MuXG4gICAgICogQHRocm93cyB7QVBJRXJyb3J9IC0gSWYgdGhlIGFkZHJlc3MgY3JlYXRpb24gZmFpbHMuXG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlQWRkcmVzcygpIHtcbiAgICAgICAgbGV0IHBheWxvYWQsIGtleTtcbiAgICAgICAgaWYgKCFjb2luYmFzZV8xLkNvaW5iYXNlLnVzZVNlcnZlclNpZ25lcikge1xuICAgICAgICAgICAgLy8gVE9ETzogQ29vcmRpbmF0ZSB0aGlzIHZhbHVlIHdpdGggY29uY3VycmVudCBjYWxscyB0byBjcmVhdGVBZGRyZXNzLlxuICAgICAgICAgICAgY29uc3QgYWRkcmVzc0luZGV4ID0gdGhpcy5hZGRyZXNzZXMubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgaGRLZXkgPSB0aGlzLmRlcml2ZUtleShhZGRyZXNzSW5kZXgpO1xuICAgICAgICAgICAgY29uc3QgYXR0ZXN0YXRpb24gPSB0aGlzLmNyZWF0ZUF0dGVzdGF0aW9uKGhkS2V5KTtcbiAgICAgICAgICAgIGNvbnN0IHB1YmxpY0tleSA9ICgwLCB1dGlsc18xLmNvbnZlcnRTdHJpbmdUb0hleCkoaGRLZXkucHVibGljS2V5KTtcbiAgICAgICAgICAgIGtleSA9IG5ldyBldGhlcnNfMi5ldGhlcnMuV2FsbGV0KCgwLCB1dGlsc18xLmNvbnZlcnRTdHJpbmdUb0hleCkoaGRLZXkucHJpdmF0ZUtleSkpO1xuICAgICAgICAgICAgcGF5bG9hZCA9IHtcbiAgICAgICAgICAgICAgICBwdWJsaWNfa2V5OiBwdWJsaWNLZXksXG4gICAgICAgICAgICAgICAgYXR0ZXN0YXRpb246IGF0dGVzdGF0aW9uLFxuICAgICAgICAgICAgICAgIGFkZHJlc3NfaW5kZXg6IGFkZHJlc3NJbmRleCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjb2luYmFzZV8xLkNvaW5iYXNlLmFwaUNsaWVudHMuYWRkcmVzcy5jcmVhdGVBZGRyZXNzKHRoaXMubW9kZWwuaWQsIHBheWxvYWQpO1xuICAgICAgICBpZiAoIXRoaXMuYWRkcmVzc2VzLmxlbmd0aCB8fCAhY29pbmJhc2VfMS5Db2luYmFzZS51c2VTZXJ2ZXJTaWduZXIpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucmVsb2FkKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IG5ldyB3YWxsZXRfYWRkcmVzc18xLldhbGxldEFkZHJlc3MocmVzcG9uc2UuZGF0YSwga2V5KTtcbiAgICAgICAgdGhpcy5hZGRyZXNzZXMucHVzaChhZGRyZXNzKTtcbiAgICAgICAgcmV0dXJuIGFkZHJlc3M7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgc2VlZCBmb3IgdGhlIFdhbGxldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzZWVkIC0gVGhlIHNlZWQgdG8gdXNlIGZvciB0aGUgV2FsbGV0LiBFeHBlY3RzIGEgMzItYnl0ZSBoZXhhZGVjaW1hbCB3aXRoIG5vIDB4IHByZWZpeC5cbiAgICAgKiBAdGhyb3dzIHtBcmd1bWVudEVycm9yfSBJZiB0aGUgc2VlZCBpcyBlbXB0eS5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHNlZWQgaXMgYWxyZWFkeSBzZXQuXG4gICAgICovXG4gICAgc2V0U2VlZChzZWVkKSB7XG4gICAgICAgIGlmIChzZWVkID09PSB1bmRlZmluZWQgfHwgc2VlZCA9PT0gXCJcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkFyZ3VtZW50RXJyb3IoXCJTZWVkIG11c3Qgbm90IGJlIGVtcHR5XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1hc3Rlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2VlZCBpcyBhbHJlYWR5IHNldFwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldE1hc3Rlck5vZGUoc2VlZCk7XG4gICAgICAgIGlmICh0aGlzLmFkZHJlc3Nlcy5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZGRyZXNzZXMuZm9yRWFjaCgoYWRkcmVzcywgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRlcml2ZWRLZXkgPSB0aGlzLmRlcml2ZUtleShpbmRleCk7XG4gICAgICAgICAgICBjb25zdCBldGhlcldhbGxldCA9IG5ldyBldGhlcnNfMi5ldGhlcnMuV2FsbGV0KCgwLCB1dGlsc18xLmNvbnZlcnRTdHJpbmdUb0hleCkoZGVyaXZlZEtleS5wcml2YXRlS2V5KSk7XG4gICAgICAgICAgICBpZiAoZXRoZXJXYWxsZXQuYWRkcmVzcyAhPSBhZGRyZXNzLmdldElkKCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNlZWQgZG9lcyBub3QgbWF0Y2ggd2FsbGV0OyBjYW5ub3QgZmluZCBhZGRyZXNzICR7ZXRoZXJXYWxsZXQuYWRkcmVzc31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkZHJlc3Muc2V0S2V5KGV0aGVyV2FsbGV0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIFdhbGxldEFkZHJlc3Mgd2l0aCB0aGUgZ2l2ZW4gSUQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWRkcmVzc0lkIC0gVGhlIElEIG9mIHRoZSBXYWxsZXRBZGRyZXNzIHRvIHJldHJpZXZlLlxuICAgICAqIEByZXR1cm5zIFRoZSBXYWxsZXRBZGRyZXNzLlxuICAgICAqL1xuICAgIGFzeW5jIGdldEFkZHJlc3MoYWRkcmVzc0lkKSB7XG4gICAgICAgIGlmICh0aGlzLmFkZHJlc3Nlcy5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICB0aGlzLmFkZHJlc3NlcyA9IGF3YWl0IHRoaXMubGlzdEFkZHJlc3NlcygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmFkZHJlc3Nlcy5maW5kKGFkZHJlc3MgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGFkZHJlc3MuZ2V0SWQoKSA9PT0gYWRkcmVzc0lkO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbGlzdCBvZiBBZGRyZXNzZXMgaW4gdGhlIFdhbGxldC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBsaXN0IG9mIEFkZHJlc3Nlcy5cbiAgICAgKi9cbiAgICBhc3luYyBsaXN0QWRkcmVzc2VzKCkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNvaW5iYXNlXzEuQ29pbmJhc2UuYXBpQ2xpZW50cy5hZGRyZXNzLmxpc3RBZGRyZXNzZXModGhpcy5nZXRJZCgpLCBXYWxsZXQuTUFYX0FERFJFU1NFUyk7XG4gICAgICAgIGNvbnN0IGFkZHJlc3NlcyA9IHJlc3BvbnNlLmRhdGEuZGF0YS5tYXAoYWRkcmVzcyA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5idWlsZFdhbGxldEFkZHJlc3MoYWRkcmVzcywgYWRkcmVzcy5pbmRleCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmFkZHJlc3NlcyA9IGFkZHJlc3NlcztcbiAgICAgICAgcmV0dXJuIGFkZHJlc3NlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFRyYWRlcyB0aGUgZ2l2ZW4gYW1vdW50IG9mIHRoZSBnaXZlbiBBc3NldCBmb3IgYW5vdGhlciBBc3NldC5cbiAgICAgKiAgQ3VycmVudGx5IG9ubHkgdGhlIGRlZmF1bHQgYWRkcmVzcyBpcyB1c2VkIHRvIHNvdXJjZSB0aGUgVHJhZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIHRvIGNyZWF0ZSB0aGUgVHJhZGUuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuYW1vdW50IC0gVGhlIGFtb3VudCBvZiB0aGUgQXNzZXQgdG8gc2VuZC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5mcm9tQXNzZXRJZCAtIFRoZSBJRCBvZiB0aGUgQXNzZXQgdG8gdHJhZGUgZnJvbS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy50b0Fzc2V0SWQgLSBUaGUgSUQgb2YgdGhlIEFzc2V0IHRvIHRyYWRlIHRvLlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgZGVmYXVsdCBhZGRyZXNzIGlzIG5vdCBmb3VuZC5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHByaXZhdGUga2V5IGlzIG5vdCBsb2FkZWQsIG9yIGlmIHRoZSBhc3NldCBJRHMgYXJlIHVuc3VwcG9ydGVkLCBvciBpZiB0aGVyZSBhcmUgaW5zdWZmaWNpZW50IGZ1bmRzLlxuICAgICAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIFRyYWRlIG9iamVjdC5cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVUcmFkZShvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoYXdhaXQgdGhpcy5nZXREZWZhdWx0QWRkcmVzcygpKS5jcmVhdGVUcmFkZShvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBzdGFrZWFibGUgYmFsYW5jZSBmb3IgdGhlIHN1cHBsaWVkIGFzc2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGFzc2V0X2lkIC0gVGhlIGFzc2V0IHRvIGNoZWNrIHRoZSBzdGFrZWFibGUgYmFsYW5jZSBmb3IuXG4gICAgICogQHBhcmFtIG1vZGUgLSBUaGUgc3Rha2luZyBtb2RlLiBEZWZhdWx0cyB0byBERUZBVUxULlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gQWRkaXRpb25hbCBvcHRpb25zIGZvciBnZXR0aW5nIHRoZSBzdGFrZWFibGUgYmFsYW5jZS5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlIGRlZmF1bHQgYWRkcmVzcyBpcyBub3QgZm91bmQuXG4gICAgICogQHJldHVybnMgVGhlIHN0YWtlYWJsZSBiYWxhbmNlLlxuICAgICAqL1xuICAgIGFzeW5jIHN0YWtlYWJsZUJhbGFuY2UoYXNzZXRfaWQsIG1vZGUgPSB0eXBlc18xLlN0YWtlT3B0aW9uc01vZGUuREVGQVVMVCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiAoYXdhaXQgdGhpcy5nZXREZWZhdWx0QWRkcmVzcygpKS5zdGFrZWFibGVCYWxhbmNlKGFzc2V0X2lkLCBtb2RlLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB1bnN0YWtlYWJsZSBiYWxhbmNlIGZvciB0aGUgc3VwcGxpZWQgYXNzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXNzZXRfaWQgLSBUaGUgYXNzZXQgdG8gY2hlY2sgdGhlIHVuc3Rha2VhYmxlIGJhbGFuY2UgZm9yLlxuICAgICAqIEBwYXJhbSBtb2RlIC0gVGhlIHN0YWtpbmcgbW9kZS4gRGVmYXVsdHMgdG8gREVGQVVMVC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFkZGl0aW9uYWwgb3B0aW9ucyBmb3IgZ2V0dGluZyB0aGUgdW5zdGFrZWFibGUgYmFsYW5jZS5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlIGRlZmF1bHQgYWRkcmVzcyBpcyBub3QgZm91bmQuXG4gICAgICogQHJldHVybnMgVGhlIHVuc3Rha2VhYmxlIGJhbGFuY2UuXG4gICAgICovXG4gICAgYXN5bmMgdW5zdGFrZWFibGVCYWxhbmNlKGFzc2V0X2lkLCBtb2RlID0gdHlwZXNfMS5TdGFrZU9wdGlvbnNNb2RlLkRFRkFVTFQsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gKGF3YWl0IHRoaXMuZ2V0RGVmYXVsdEFkZHJlc3MoKSkudW5zdGFrZWFibGVCYWxhbmNlKGFzc2V0X2lkLCBtb2RlLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBwZW5kaW5nIGNsYWltYWJsZSBiYWxhbmNlIGZvciB0aGUgc3VwcGxpZWQgYXNzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXNzZXRfaWQgLSBUaGUgYXNzZXQgdG8gY2hlY2sgcGVuZGluZyBjbGFpbWFibGUgYmFsYW5jZSBmb3IuXG4gICAgICogQHBhcmFtIG1vZGUgLSBUaGUgc3Rha2luZyBtb2RlLiBEZWZhdWx0cyB0byBERUZBVUxULlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gQWRkaXRpb25hbCBvcHRpb25zIGZvciBnZXR0aW5nIHRoZSBwZW5kaW5nIGNsYWltYWJsZSBiYWxhbmNlLlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBpZiB0aGUgZGVmYXVsdCBhZGRyZXNzIGlzIG5vdCBmb3VuZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgcGVuZGluZyBjbGFpbWFibGUgYmFsYW5jZS5cbiAgICAgKi9cbiAgICBhc3luYyBwZW5kaW5nQ2xhaW1hYmxlQmFsYW5jZShhc3NldF9pZCwgbW9kZSA9IHR5cGVzXzEuU3Rha2VPcHRpb25zTW9kZS5ERUZBVUxULCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIChhd2FpdCB0aGlzLmdldERlZmF1bHRBZGRyZXNzKCkpLnBlbmRpbmdDbGFpbWFibGVCYWxhbmNlKGFzc2V0X2lkLCBtb2RlLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjbGFpbWFibGUgYmFsYW5jZSBmb3IgdGhlIHN1cHBsaWVkIGFzc2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGFzc2V0X2lkIC0gVGhlIGFzc2V0IHRvIGNoZWNrIGNsYWltYWJsZSBiYWxhbmNlIGZvci5cbiAgICAgKiBAcGFyYW0gbW9kZSAtIFRoZSBzdGFraW5nIG1vZGUuIERlZmF1bHRzIHRvIERFRkFVTFQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBBZGRpdGlvbmFsIG9wdGlvbnMgZm9yIGdldHRpbmcgdGhlIGNsYWltYWJsZSBiYWxhbmNlLlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBpZiB0aGUgZGVmYXVsdCBhZGRyZXNzIGlzIG5vdCBmb3VuZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgY2xhaW1hYmxlIGJhbGFuY2UuXG4gICAgICovXG4gICAgYXN5bmMgY2xhaW1hYmxlQmFsYW5jZShhc3NldF9pZCwgbW9kZSA9IHR5cGVzXzEuU3Rha2VPcHRpb25zTW9kZS5ERUZBVUxULCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIChhd2FpdCB0aGlzLmdldERlZmF1bHRBZGRyZXNzKCkpLmNsYWltYWJsZUJhbGFuY2UoYXNzZXRfaWQsIG1vZGUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0cyB0aGUgc3Rha2luZyByZXdhcmRzIGZvciB0aGUgYWRkcmVzcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhc3NldElkIC0gVGhlIGFzc2V0IElELlxuICAgICAqIEBwYXJhbSBzdGFydFRpbWUgLSBUaGUgc3RhcnQgdGltZS5cbiAgICAgKiBAcGFyYW0gZW5kVGltZSAtIFRoZSBlbmQgdGltZS5cbiAgICAgKiBAcGFyYW0gZm9ybWF0IC0gVGhlIGZvcm1hdCB0byByZXR1cm4gdGhlIHJld2FyZHMgaW4uICh1c2QsIG5hdGl2ZSkuIERlZmF1bHRzIHRvIHVzZC5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlIGRlZmF1bHQgYWRkcmVzcyBpcyBub3QgZm91bmQuXG4gICAgICogQHJldHVybnMgVGhlIHN0YWtpbmcgcmV3YXJkcy5cbiAgICAgKi9cbiAgICBhc3luYyBzdGFraW5nUmV3YXJkcyhhc3NldElkLCBzdGFydFRpbWUgPSAoMCwgdXRpbHNfMS5nZXRXZWVrQmFja0RhdGUpKG5ldyBEYXRlKCkpLCBlbmRUaW1lID0gKDAsIHV0aWxzXzEuZm9ybWF0RGF0ZSkobmV3IERhdGUoKSksIGZvcm1hdCA9IHR5cGVzXzEuU3Rha2luZ1Jld2FyZEZvcm1hdC5VU0QpIHtcbiAgICAgICAgcmV0dXJuIChhd2FpdCB0aGlzLmdldERlZmF1bHRBZGRyZXNzKCkpLnN0YWtpbmdSZXdhcmRzKGFzc2V0SWQsIHN0YXJ0VGltZSwgZW5kVGltZSwgZm9ybWF0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdHMgdGhlIGhpc3RvcmljYWwgc3Rha2luZyBiYWxhbmNlcyBmb3IgdGhlIGFkZHJlc3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXNzZXRJZCAtIFRoZSBhc3NldCBJRC5cbiAgICAgKiBAcGFyYW0gc3RhcnRUaW1lIC0gVGhlIHN0YXJ0IHRpbWUuXG4gICAgICogQHBhcmFtIGVuZFRpbWUgLSBUaGUgZW5kIHRpbWUuXG4gICAgICogQHRocm93cyB7RXJyb3J9IGlmIHRoZSBkZWZhdWx0IGFkZHJlc3MgaXMgbm90IGZvdW5kLlxuICAgICAqIEByZXR1cm5zIFRoZSBzdGFraW5nIGJhbGFuY2VzLlxuICAgICAqL1xuICAgIGFzeW5jIGhpc3RvcmljYWxTdGFraW5nQmFsYW5jZXMoYXNzZXRJZCwgc3RhcnRUaW1lID0gKDAsIHV0aWxzXzEuZ2V0V2Vla0JhY2tEYXRlKShuZXcgRGF0ZSgpKSwgZW5kVGltZSA9ICgwLCB1dGlsc18xLmZvcm1hdERhdGUpKG5ldyBEYXRlKCkpKSB7XG4gICAgICAgIHJldHVybiAoYXdhaXQgdGhpcy5nZXREZWZhdWx0QWRkcmVzcygpKS5oaXN0b3JpY2FsU3Rha2luZ0JhbGFuY2VzKGFzc2V0SWQsIHN0YXJ0VGltZSwgZW5kVGltZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3RzIHRoZSBoaXN0b3JpY2FsIGJhbGFuY2VzIGZvciBhIGdpdmVuIGFzc2V0IGJlbG9uZ2luZyB0byB0aGUgZGVmYXVsdCBhZGRyZXNzIG9mIHRoZSB3YWxsZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXNzZXRJZCAtIFRoZSBhc3NldCBJRC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBwYWdpbmF0aW9uIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIG9wdGlvbnMubGltaXQgLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgSGlzdG9yaWNhbCBCYWxhbmNlcyB0byByZXR1cm4uIExpbWl0IGNhbiByYW5nZSBiZXR3ZWVuIDEgYW5kIDEwMC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5wYWdlIC0gVGhlIGN1cnNvciBmb3IgcGFnaW5hdGlvbiBhY3Jvc3MgbXVsdGlwbGUgcGFnZXMgb2YgSGlzdG9yaWNhbCBCYWxhbmNlcy4gRG9uXFwmIzM5O3QgaW5jbHVkZSB0aGlzIHBhcmFtZXRlciBvbiB0aGUgZmlyc3QgY2FsbC4gVXNlIHRoZSBuZXh0IHBhZ2UgdmFsdWUgcmV0dXJuZWQgaW4gYSBwcmV2aW91cyByZXNwb25zZSB0byByZXF1ZXN0IHN1YnNlcXVlbnQgcmVzdWx0cy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBwYWdpbmF0ZWQgbGlzdCByZXNwb25zZSBvZiBIaXN0b3JpY2FsIEJhbGFuY2VzIGZvciB0aGUgZ2l2ZW4gQXNzZXQgSUQuXG4gICAgICovXG4gICAgYXN5bmMgbGlzdEhpc3RvcmljYWxCYWxhbmNlcyhhc3NldElkLCB7IGxpbWl0ID0gY29pbmJhc2VfMS5Db2luYmFzZS5kZWZhdWx0UGFnZUxpbWl0LCBwYWdlID0gdW5kZWZpbmVkIH0gPSB7fSkge1xuICAgICAgICByZXR1cm4gKGF3YWl0IHRoaXMuZ2V0RGVmYXVsdEFkZHJlc3MoKSkubGlzdEhpc3RvcmljYWxCYWxhbmNlcyhhc3NldElkLCB7IGxpbWl0LCBwYWdlIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc3Rha2luZyBvcGVyYXRpb24gdG8gc3Rha2UsIHNpZ25zIGl0LCBhbmQgYnJvYWRjYXN0cyBpdCBvbiB0aGUgYmxvY2tjaGFpbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhbW91bnQgLSBUaGUgYW1vdW50IGZvciB0aGUgc3Rha2luZyBvcGVyYXRpb24uXG4gICAgICogQHBhcmFtIGFzc2V0SWQgLSBUaGUgYXNzZXQgZm9yIHRoZSBzdGFraW5nIG9wZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0gbW9kZSAtIFRoZSBzdGFraW5nIG1vZGUuIERlZmF1bHRzIHRvIERFRkFVTFQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBBZGRpdGlvbmFsIG9wdGlvbnMgc3VjaCBhcyBzZXR0aW5nIHRoZSBtb2RlIGZvciB0aGUgc3Rha2luZyBhY3Rpb24uXG4gICAgICogQHBhcmFtIHRpbWVvdXRTZWNvbmRzIC0gVGhlIGFtb3VudCB0byB3YWl0IGZvciB0aGUgdHJhbnNhY3Rpb24gdG8gY29tcGxldGUgd2hlbiBicm9hZGNhc3RlZC5cbiAgICAgKiBAcGFyYW0gaW50ZXJ2YWxTZWNvbmRzIC0gVGhlIGFtb3VudCB0byBjaGVjayBlYWNoIHRpbWUgZm9yIGEgc3VjY2Vzc2Z1bCBicm9hZGNhc3QuXG4gICAgICogQHRocm93cyB7RXJyb3J9IGlmIHRoZSBkZWZhdWx0IGFkZHJlc3MgaXMgbm90IGZvdW5kLlxuICAgICAqIEByZXR1cm5zIFRoZSBzdGFraW5nIG9wZXJhdGlvbiBhZnRlciBpdCdzIGNvbXBsZXRlZCBmdWxseS5cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVTdGFrZShhbW91bnQsIGFzc2V0SWQsIG1vZGUgPSB0eXBlc18xLlN0YWtlT3B0aW9uc01vZGUuREVGQVVMVCwgb3B0aW9ucyA9IHt9LCB0aW1lb3V0U2Vjb25kcyA9IDYwLCBpbnRlcnZhbFNlY29uZHMgPSAwLjIpIHtcbiAgICAgICAgcmV0dXJuIChhd2FpdCB0aGlzLmdldERlZmF1bHRBZGRyZXNzKCkpLmNyZWF0ZVN0YWtlKGFtb3VudCwgYXNzZXRJZCwgbW9kZSwgb3B0aW9ucywgdGltZW91dFNlY29uZHMsIGludGVydmFsU2Vjb25kcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzdGFraW5nIG9wZXJhdGlvbiB0byB1bnN0YWtlLCBzaWducyBpdCwgYW5kIGJyb2FkY2FzdHMgaXQgb24gdGhlIGJsb2NrY2hhaW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYW1vdW50IC0gVGhlIGFtb3VudCBmb3IgdGhlIHN0YWtpbmcgb3BlcmF0aW9uLlxuICAgICAqIEBwYXJhbSBhc3NldElkIC0gVGhlIGFzc2V0IGZvciB0aGUgc3Rha2luZyBvcGVyYXRpb24uXG4gICAgICogQHBhcmFtIG1vZGUgLSBUaGUgc3Rha2luZyBtb2RlLiBEZWZhdWx0cyB0byBERUZBVUxULlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gQWRkaXRpb25hbCBvcHRpb25zIHN1Y2ggYXMgc2V0dGluZyB0aGUgbW9kZSBmb3IgdGhlIHN0YWtpbmcgYWN0aW9uLlxuICAgICAqIEBwYXJhbSB0aW1lb3V0U2Vjb25kcyAtIFRoZSBhbW91bnQgdG8gd2FpdCBmb3IgdGhlIHRyYW5zYWN0aW9uIHRvIGNvbXBsZXRlIHdoZW4gYnJvYWRjYXN0ZWQuXG4gICAgICogQHBhcmFtIGludGVydmFsU2Vjb25kcyAtIFRoZSBhbW91bnQgdG8gY2hlY2sgZWFjaCB0aW1lIGZvciBhIHN1Y2Nlc3NmdWwgYnJvYWRjYXN0LlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBpZiB0aGUgZGVmYXVsdCBhZGRyZXNzIGlzIG5vdCBmb3VuZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgc3Rha2luZyBvcGVyYXRpb24gYWZ0ZXIgaXQncyBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5LlxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZVVuc3Rha2UoYW1vdW50LCBhc3NldElkLCBtb2RlID0gdHlwZXNfMS5TdGFrZU9wdGlvbnNNb2RlLkRFRkFVTFQsIG9wdGlvbnMgPSB7fSwgdGltZW91dFNlY29uZHMgPSA2MCwgaW50ZXJ2YWxTZWNvbmRzID0gMC4yKSB7XG4gICAgICAgIHJldHVybiAoYXdhaXQgdGhpcy5nZXREZWZhdWx0QWRkcmVzcygpKS5jcmVhdGVVbnN0YWtlKGFtb3VudCwgYXNzZXRJZCwgbW9kZSwgb3B0aW9ucywgdGltZW91dFNlY29uZHMsIGludGVydmFsU2Vjb25kcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzdGFraW5nIG9wZXJhdGlvbiB0byBjbGFpbSBzdGFrZSwgc2lnbnMgaXQsIGFuZCBicm9hZGNhc3RzIGl0IG9uIHRoZSBibG9ja2NoYWluLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFtb3VudCAtIFRoZSBhbW91bnQgZm9yIHRoZSBzdGFraW5nIG9wZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0gYXNzZXRJZCAtIFRoZSBhc3NldCBmb3IgdGhlIHN0YWtpbmcgb3BlcmF0aW9uLlxuICAgICAqIEBwYXJhbSBtb2RlIC0gVGhlIHN0YWtpbmcgbW9kZS4gRGVmYXVsdHMgdG8gREVGQVVMVC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFkZGl0aW9uYWwgb3B0aW9ucyBzdWNoIGFzIHNldHRpbmcgdGhlIG1vZGUgZm9yIHRoZSBzdGFraW5nIGFjdGlvbi5cbiAgICAgKiBAcGFyYW0gdGltZW91dFNlY29uZHMgLSBUaGUgYW1vdW50IHRvIHdhaXQgZm9yIHRoZSB0cmFuc2FjdGlvbiB0byBjb21wbGV0ZSB3aGVuIGJyb2FkY2FzdGVkLlxuICAgICAqIEBwYXJhbSBpbnRlcnZhbFNlY29uZHMgLSBUaGUgYW1vdW50IHRvIGNoZWNrIGVhY2ggdGltZSBmb3IgYSBzdWNjZXNzZnVsIGJyb2FkY2FzdC5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlIGRlZmF1bHQgYWRkcmVzcyBpcyBub3QgZm91bmQuXG4gICAgICogQHJldHVybnMgVGhlIHN0YWtpbmcgb3BlcmF0aW9uIGFmdGVyIGl0J3MgY29tcGxldGVkIGZ1bGx5LlxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZUNsYWltU3Rha2UoYW1vdW50LCBhc3NldElkLCBtb2RlID0gdHlwZXNfMS5TdGFrZU9wdGlvbnNNb2RlLkRFRkFVTFQsIG9wdGlvbnMgPSB7fSwgdGltZW91dFNlY29uZHMgPSA2MCwgaW50ZXJ2YWxTZWNvbmRzID0gMC4yKSB7XG4gICAgICAgIHJldHVybiAoYXdhaXQgdGhpcy5nZXREZWZhdWx0QWRkcmVzcygpKS5jcmVhdGVDbGFpbVN0YWtlKGFtb3VudCwgYXNzZXRJZCwgbW9kZSwgb3B0aW9ucywgdGltZW91dFNlY29uZHMsIGludGVydmFsU2Vjb25kcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxpc3Qgb2YgYmFsYW5jZXMgb2YgdGhpcyBXYWxsZXQuIEJhbGFuY2VzIGFyZSBhZ2dyZWdhdGVkIGFjcm9zcyBhbGwgQWRkcmVzc2VzIGluIHRoZSBXYWxsZXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgbGlzdCBvZiBiYWxhbmNlcy4gVGhlIGtleSBpcyB0aGUgQXNzZXQgSUQsIGFuZCB0aGUgdmFsdWUgaXMgdGhlIGJhbGFuY2UuXG4gICAgICovXG4gICAgYXN5bmMgbGlzdEJhbGFuY2VzKCkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNvaW5iYXNlXzEuQ29pbmJhc2UuYXBpQ2xpZW50cy53YWxsZXQubGlzdFdhbGxldEJhbGFuY2VzKHRoaXMubW9kZWwuaWQpO1xuICAgICAgICByZXR1cm4gYmFsYW5jZV9tYXBfMS5CYWxhbmNlTWFwLmZyb21CYWxhbmNlcyhyZXNwb25zZS5kYXRhLmRhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBiYWxhbmNlIG9mIHRoZSBwcm92aWRlZCBBc3NldC4gQmFsYW5jZXMgYXJlIGFnZ3JlZ2F0ZWQgYWNyb3NzIGFsbCBBZGRyZXNzZXMgaW4gdGhlIFdhbGxldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhc3NldElkIC0gVGhlIElEIG9mIHRoZSBBc3NldCB0byByZXRyaWV2ZSB0aGUgYmFsYW5jZSBmb3IuXG4gICAgICogQHJldHVybnMgVGhlIGJhbGFuY2Ugb2YgdGhlIEFzc2V0LlxuICAgICAqL1xuICAgIGFzeW5jIGdldEJhbGFuY2UoYXNzZXRJZCkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNvaW5iYXNlXzEuQ29pbmJhc2UuYXBpQ2xpZW50cy53YWxsZXQuZ2V0V2FsbGV0QmFsYW5jZSh0aGlzLm1vZGVsLmlkLCBhc3NldF8xLkFzc2V0LnByaW1hcnlEZW5vbWluYXRpb24oYXNzZXRJZCkpO1xuICAgICAgICBpZiAoIXJlc3BvbnNlLmRhdGEuYW1vdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGRlY2ltYWxfanNfMS5kZWZhdWx0KDApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJhbGFuY2UgPSBiYWxhbmNlXzEuQmFsYW5jZS5mcm9tTW9kZWxBbmRBc3NldElkKHJlc3BvbnNlLmRhdGEsIGFzc2V0SWQpO1xuICAgICAgICByZXR1cm4gYmFsYW5jZS5hbW91bnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIE5ldHdvcmsgSUQgb2YgdGhlIFdhbGxldC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBuZXR3b3JrIElELlxuICAgICAqL1xuICAgIGdldE5ldHdvcmtJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwubmV0d29ya19pZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgU2VydmVyU2lnbmVyIFN0YXR1cyBvZiB0aGUgV2FsbGV0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgdGhlIFNlcnZlclNpZ25lciBTdGF0dXMuXG4gICAgICovXG4gICAgZ2V0U2VydmVyU2lnbmVyU3RhdHVzKCkge1xuICAgICAgICBjb25zdCBzdGF0dXMgPSB7XG4gICAgICAgICAgICBwZW5kaW5nX3NlZWRfY3JlYXRpb246IHR5cGVzXzEuU2VydmVyU2lnbmVyU3RhdHVzLlBFTkRJTkcsXG4gICAgICAgICAgICBhY3RpdmVfc2VlZDogdHlwZXNfMS5TZXJ2ZXJTaWduZXJTdGF0dXMuQUNUSVZFLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5zZXJ2ZXJfc2lnbmVyX3N0YXR1cyA/IHN0YXR1c1t0aGlzLm1vZGVsLnNlcnZlcl9zaWduZXJfc3RhdHVzXSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgd2FsbGV0IElELlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHdhbGxldCBJRC5cbiAgICAgKi9cbiAgICBnZXRJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwuaWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNhdmVzIHRoZSBzZWVkIG9mIHRoZSBXYWxsZXQgdG8gdGhlIGdpdmVuIGZpbGUuXG4gICAgICpcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2Ugc2F2ZVNlZWRUb0ZpbGUoKSBpbnN0ZWFkXG4gICAgICogQHBhcmFtIGZpbGVQYXRoIC0gVGhlIHBhdGggb2YgdGhlIGZpbGUgdG8gc2F2ZSB0aGUgc2VlZCB0b1xuICAgICAqIEBwYXJhbSBlbmNyeXB0IC0gV2hldGhlciB0aGUgc2VlZCBpbmZvcm1hdGlvbiBwZXJzaXN0ZWQgdG8gdGhlIGxvY2FsIGZpbGUgc3lzdGVtIHNob3VsZCBiZVxuICAgICAqIGVuY3J5cHRlZCBvciBub3QuIERhdGEgaXMgdW5lbmNyeXB0ZWQgYnkgZGVmYXVsdC5cbiAgICAgKiBAcmV0dXJucyBBIHN0cmluZyBpbmRpY2F0aW5nIHRoZSBzdWNjZXNzIG9mIHRoZSBvcGVyYXRpb25cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIFdhbGxldCBkb2VzIG5vdCBoYXZlIGEgc2VlZFxuICAgICAqL1xuICAgIHNhdmVTZWVkKGZpbGVQYXRoLCBlbmNyeXB0ID0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2F2ZVNlZWRUb0ZpbGUoZmlsZVBhdGgsIGVuY3J5cHQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTYXZlcyB0aGUgc2VlZCBvZiB0aGUgV2FsbGV0IHRvIHRoZSBnaXZlbiBmaWxlLiBXYWxsZXRzIHdob3NlIHNlZWRzIGFyZSBzYXZlZCB0aGlzIHdheSBjYW4gYmVcbiAgICAgKiByZWh5ZHJhdGVkIHVzaW5nIGxvYWRfc2VlZC4gQSBzaW5nbGUgZmlsZSBjYW4gYmUgdXNlZCBmb3IgbXVsdGlwbGUgV2FsbGV0IHNlZWRzLlxuICAgICAqIFRoaXMgaXMgYW4gaW5zZWN1cmUgbWV0aG9kIG9mIHN0b3JpbmcgV2FsbGV0IHNlZWRzIGFuZCBzaG91bGQgb25seSBiZSB1c2VkIGZvciBkZXZlbG9wbWVudCBwdXJwb3Nlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmaWxlUGF0aCAtIFRoZSBwYXRoIG9mIHRoZSBmaWxlIHRvIHNhdmUgdGhlIHNlZWQgdG9cbiAgICAgKiBAcGFyYW0gZW5jcnlwdCAtIFdoZXRoZXIgdGhlIHNlZWQgaW5mb3JtYXRpb24gcGVyc2lzdGVkIHRvIHRoZSBsb2NhbCBmaWxlIHN5c3RlbSBzaG91bGQgYmVcbiAgICAgKiBlbmNyeXB0ZWQgb3Igbm90LiBEYXRhIGlzIHVuZW5jcnlwdGVkIGJ5IGRlZmF1bHQuXG4gICAgICogQHJldHVybnMgQSBzdHJpbmcgaW5kaWNhdGluZyB0aGUgc3VjY2VzcyBvZiB0aGUgb3BlcmF0aW9uXG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBXYWxsZXQgZG9lcyBub3QgaGF2ZSBhIHNlZWRcbiAgICAgKi9cbiAgICBzYXZlU2VlZFRvRmlsZShmaWxlUGF0aCwgZW5jcnlwdCA9IGZhbHNlKSB7XG4gICAgICAgIGlmICghdGhpcy5tYXN0ZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzYXZlIFdhbGxldCB3aXRob3V0IGxvYWRlZCBzZWVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nU2VlZHNJblN0b3JlID0gdGhpcy5nZXRFeGlzdGluZ1NlZWRzKGZpbGVQYXRoKTtcbiAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuZXhwb3J0KCk7XG4gICAgICAgIGxldCBzZWVkVG9TdG9yZSA9IGRhdGEuc2VlZDtcbiAgICAgICAgbGV0IGF1dGhUYWcgPSBcIlwiO1xuICAgICAgICBsZXQgaXYgPSBcIlwiO1xuICAgICAgICBpZiAoZW5jcnlwdCkge1xuICAgICAgICAgICAgY29uc3QgaXZCeXRlcyA9IGNyeXB0by5yYW5kb21CeXRlcygxMik7XG4gICAgICAgICAgICBjb25zdCBzaGFyZWRTZWNyZXQgPSB0aGlzLmdldEVuY3J5cHRpb25LZXkoKTtcbiAgICAgICAgICAgIGNvbnN0IGNpcGhlciA9IGNyeXB0by5jcmVhdGVDaXBoZXJpdihcImFlcy0yNTYtZ2NtXCIsIGNyeXB0by5jcmVhdGVIYXNoKFwic2hhMjU2XCIpLnVwZGF0ZShzaGFyZWRTZWNyZXQpLmRpZ2VzdCgpLCBpdkJ5dGVzKTtcbiAgICAgICAgICAgIGNvbnN0IGVuY3J5cHRlZERhdGEgPSBCdWZmZXIuY29uY2F0KFtjaXBoZXIudXBkYXRlKGRhdGEuc2VlZCwgXCJ1dGY4XCIpLCBjaXBoZXIuZmluYWwoKV0pO1xuICAgICAgICAgICAgYXV0aFRhZyA9IGNpcGhlci5nZXRBdXRoVGFnKCkudG9TdHJpbmcoXCJoZXhcIik7XG4gICAgICAgICAgICBzZWVkVG9TdG9yZSA9IGVuY3J5cHRlZERhdGEudG9TdHJpbmcoXCJoZXhcIik7XG4gICAgICAgICAgICBpdiA9IGl2Qnl0ZXMudG9TdHJpbmcoXCJoZXhcIik7XG4gICAgICAgIH1cbiAgICAgICAgZXhpc3RpbmdTZWVkc0luU3RvcmVbZGF0YS53YWxsZXRJZF0gPSB7XG4gICAgICAgICAgICBzZWVkOiBzZWVkVG9TdG9yZSxcbiAgICAgICAgICAgIGVuY3J5cHRlZDogZW5jcnlwdCxcbiAgICAgICAgICAgIGF1dGhUYWc6IGF1dGhUYWcsXG4gICAgICAgICAgICBpdjogaXYsXG4gICAgICAgICAgICBuZXR3b3JrSWQ6IGRhdGEubmV0d29ya0lkLFxuICAgICAgICB9O1xuICAgICAgICBmcy53cml0ZUZpbGVTeW5jKGZpbGVQYXRoLCBKU09OLnN0cmluZ2lmeShleGlzdGluZ1NlZWRzSW5TdG9yZSwgbnVsbCwgMiksIFwidXRmOFwiKTtcbiAgICAgICAgcmV0dXJuIGBTdWNjZXNzZnVsbHkgc2F2ZWQgc2VlZCBmb3IgJHtkYXRhLndhbGxldElkfSB0byAke2ZpbGVQYXRofS5gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2FkcyB0aGUgc2VlZCBvZiB0aGUgV2FsbGV0IGZyb20gdGhlIGdpdmVuIGZpbGUuXG4gICAgICpcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgbG9hZFNlZWRGcm9tRmlsZSgpIGluc3RlYWRcbiAgICAgKiBAcGFyYW0gZmlsZVBhdGggLSBUaGUgcGF0aCBvZiB0aGUgZmlsZSB0byBsb2FkIHRoZSBzZWVkIGZyb21cbiAgICAgKiBAcmV0dXJucyBBIHN0cmluZyBpbmRpY2F0aW5nIHRoZSBzdWNjZXNzIG9mIHRoZSBvcGVyYXRpb25cbiAgICAgKi9cbiAgICBhc3luYyBsb2FkU2VlZChmaWxlUGF0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2FkU2VlZEZyb21GaWxlKGZpbGVQYXRoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9hZHMgdGhlIHNlZWQgb2YgdGhlIFdhbGxldCBmcm9tIHRoZSBnaXZlbiBmaWxlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGZpbGVQYXRoIC0gVGhlIHBhdGggb2YgdGhlIGZpbGUgdG8gbG9hZCB0aGUgc2VlZCBmcm9tXG4gICAgICogQHJldHVybnMgQSBzdHJpbmcgaW5kaWNhdGluZyB0aGUgc3VjY2VzcyBvZiB0aGUgb3BlcmF0aW9uXG4gICAgICovXG4gICAgYXN5bmMgbG9hZFNlZWRGcm9tRmlsZShmaWxlUGF0aCkge1xuICAgICAgICBjb25zdCBleGlzdGluZ1NlZWRzSW5TdG9yZSA9IHRoaXMuZ2V0RXhpc3RpbmdTZWVkcyhmaWxlUGF0aCk7XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhleGlzdGluZ1NlZWRzSW5TdG9yZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuQXJndW1lbnRFcnJvcihgRmlsZSAke2ZpbGVQYXRofSBkb2VzIG5vdCBjb250YWluIGFueSBzZWVkIGRhdGFgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXhpc3RpbmdTZWVkc0luU3RvcmVbdGhpcy5nZXRJZCgpXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuQXJndW1lbnRFcnJvcihgRmlsZSAke2ZpbGVQYXRofSBkb2VzIG5vdCBjb250YWluIHNlZWQgZGF0YSBmb3Igd2FsbGV0ICR7dGhpcy5nZXRJZCgpfWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlZWREYXRhID0gZXhpc3RpbmdTZWVkc0luU3RvcmVbdGhpcy5nZXRJZCgpXTtcbiAgICAgICAgbGV0IHNlZWQgPSBzZWVkRGF0YS5zZWVkO1xuICAgICAgICBpZiAoIXNlZWQpIHtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuQXJndW1lbnRFcnJvcihcIlNlZWQgZGF0YSBpcyBtYWxmb3JtZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlZWREYXRhLmVuY3J5cHRlZCkge1xuICAgICAgICAgICAgY29uc3Qgc2hhcmVkU2VjcmV0ID0gdGhpcy5nZXRFbmNyeXB0aW9uS2V5KCk7XG4gICAgICAgICAgICBpZiAoIXNlZWREYXRhLml2IHx8ICFzZWVkRGF0YS5hdXRoVGFnKSB7XG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuQXJndW1lbnRFcnJvcihcIkVuY3J5cHRlZCBzZWVkIGRhdGEgaXMgbWFsZm9ybWVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGVjaXBoZXIgPSBjcnlwdG8uY3JlYXRlRGVjaXBoZXJpdihcImFlcy0yNTYtZ2NtXCIsIGNyeXB0by5jcmVhdGVIYXNoKFwic2hhMjU2XCIpLnVwZGF0ZShzaGFyZWRTZWNyZXQpLmRpZ2VzdCgpLCBCdWZmZXIuZnJvbShzZWVkRGF0YS5pdiwgXCJoZXhcIikpO1xuICAgICAgICAgICAgZGVjaXBoZXIuc2V0QXV0aFRhZyhCdWZmZXIuZnJvbShzZWVkRGF0YS5hdXRoVGFnLCBcImhleFwiKSk7XG4gICAgICAgICAgICBjb25zdCBkZWNyeXB0ZWREYXRhID0gQnVmZmVyLmNvbmNhdChbXG4gICAgICAgICAgICAgICAgZGVjaXBoZXIudXBkYXRlKEJ1ZmZlci5mcm9tKHNlZWQsIFwiaGV4XCIpKSxcbiAgICAgICAgICAgICAgICBkZWNpcGhlci5maW5hbCgpLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICBzZWVkID0gZGVjcnlwdGVkRGF0YS50b1N0cmluZyhcInV0ZjhcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRTZWVkKHNlZWQpO1xuICAgICAgICBhd2FpdCB0aGlzLmxpc3RBZGRyZXNzZXMoKTtcbiAgICAgICAgcmV0dXJuIGBTdWNjZXNzZnVsbHkgbG9hZGVkIHNlZWQgZm9yIHdhbGxldCAke3RoaXMuZ2V0SWQoKX0gZnJvbSAke2ZpbGVQYXRofS5gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBkZWZhdWx0IGFkZHJlc3Mgb2YgdGhlIFdhbGxldC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBkZWZhdWx0IGFkZHJlc3NcbiAgICAgKi9cbiAgICBhc3luYyBnZXREZWZhdWx0QWRkcmVzcygpIHtcbiAgICAgICAgaWYgKHRoaXMubW9kZWwuZGVmYXVsdF9hZGRyZXNzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIldhbGxldE1vZGVsIGRlZmF1bHQgYWRkcmVzcyBub3Qgc2V0XCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlZmF1bHRBZGRyZXNzID0gYXdhaXQgdGhpcy5nZXRBZGRyZXNzKHRoaXMubW9kZWwuZGVmYXVsdF9hZGRyZXNzLmFkZHJlc3NfaWQpO1xuICAgICAgICBpZiAoIWRlZmF1bHRBZGRyZXNzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEZWZhdWx0IGFkZHJlc3Mgbm90IGZvdW5kXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWZhdWx0QWRkcmVzcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBXYWxsZXQgaGFzIGEgc2VlZCB3aXRoIHdoaWNoIHRvIGRlcml2ZSBrZXlzIGFuZCBzaWduIHRyYW5zYWN0aW9ucy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIFdhbGxldCBoYXMgYSBzZWVkIHdpdGggd2hpY2ggdG8gZGVyaXZlIGtleXMgYW5kIHNpZ24gdHJhbnNhY3Rpb25zLlxuICAgICAqL1xuICAgIGNhblNpZ24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hc3Rlcj8ucHVibGljS2V5ICE9PSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlcXVlc3RzIGZ1bmRzIGZyb20gdGhlIGZhdWNldCBmb3IgdGhlIFdhbGxldCdzIGRlZmF1bHQgYWRkcmVzcyBhbmQgcmV0dXJucyB0aGUgZmF1Y2V0IHRyYW5zYWN0aW9uLlxuICAgICAqIFRoaXMgaXMgb25seSBzdXBwb3J0ZWQgb24gdGVzdG5ldCBuZXR3b3Jrcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhc3NldElkIC0gVGhlIElEIG9mIHRoZSBBc3NldCB0byByZXF1ZXN0IGZyb20gdGhlIGZhdWNldC5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGRlZmF1bHQgYWRkcmVzcyBpcyBub3QgZm91bmQuXG4gICAgICogQHRocm93cyB7QVBJRXJyb3J9IElmIHRoZSByZXF1ZXN0IGZhaWxzLlxuICAgICAqIEByZXR1cm5zIFRoZSBzdWNjZXNzZnVsIGZhdWNldCB0cmFuc2FjdGlvblxuICAgICAqL1xuICAgIGFzeW5jIGZhdWNldChhc3NldElkKSB7XG4gICAgICAgIGlmICghdGhpcy5tb2RlbC5kZWZhdWx0X2FkZHJlc3MpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRlZmF1bHQgYWRkcmVzcyBub3QgZm91bmRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSAoYXdhaXQgdGhpcy5nZXREZWZhdWx0QWRkcmVzcygpKS5mYXVjZXQoYXNzZXRJZCk7XG4gICAgICAgIHJldHVybiB0cmFuc2FjdGlvbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhbnNmZXJzIHRoZSBnaXZlbiBhbW91bnQgb2YgdGhlIGdpdmVuIEFzc2V0IHRvIHRoZSBnaXZlbiBhZGRyZXNzLiBPbmx5IHNhbWUtTmV0d29yayBUcmFuc2ZlcnMgYXJlIHN1cHBvcnRlZC5cbiAgICAgKiBDdXJyZW50bHkgb25seSB0aGUgZGVmYXVsdF9hZGRyZXNzIGlzIHVzZWQgdG8gc291cmNlIHRoZSBUcmFuc2Zlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgdG8gY3JlYXRlIHRoZSBUcmFuc2Zlci5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5hbW91bnQgLSBUaGUgYW1vdW50IG9mIHRoZSBBc3NldCB0byBzZW5kLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmFzc2V0SWQgLSBUaGUgSUQgb2YgdGhlIEFzc2V0IHRvIHNlbmQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZGVzdGluYXRpb24gLSBUaGUgZGVzdGluYXRpb24gb2YgdGhlIHRyYW5zZmVyLiBJZiBhIFdhbGxldCwgc2VuZHMgdG8gdGhlIFdhbGxldCdzIGRlZmF1bHQgYWRkcmVzcy4gSWYgYSBTdHJpbmcsIGludGVycHJldHMgaXQgYXMgdGhlIGFkZHJlc3MgSUQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZ2FzbGVzcyAtIFdoZXRoZXIgdGhlIFRyYW5zZmVyIHNob3VsZCBiZSBnYXNsZXNzLiBEZWZhdWx0cyB0byBmYWxzZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5za2lwQmF0Y2hpbmcgLSBXaGVuIHRydWUsIHRoZSBUcmFuc2ZlciB3aWxsIGJlIHN1Ym1pdHRlZCBpbW1lZGlhdGVseS4gT3RoZXJ3aXNlLCB0aGUgVHJhbnNmZXIgd2lsbCBiZSBiYXRjaGVkLiBEZWZhdWx0cyB0byBmYWxzZS4gTm90ZTogcmVxdWlyZXMgZ2FzbGVzcyBvcHRpb24gdG8gYmUgc2V0IHRvIHRydWUuXG4gICAgICogQHJldHVybnMgVGhlIGNyZWF0ZWQgVHJhbnNmZXIgb2JqZWN0LlxuICAgICAqIEB0aHJvd3Mge0FQSUVycm9yfSBpZiB0aGUgQVBJIHJlcXVlc3QgdG8gY3JlYXRlIGEgVHJhbnNmZXIgZmFpbHMuXG4gICAgICogQHRocm93cyB7QVBJRXJyb3J9IGlmIHRoZSBBUEkgcmVxdWVzdCB0byBicm9hZGNhc3QgYSBUcmFuc2ZlciBmYWlscy5cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVUcmFuc2ZlcihvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoYXdhaXQgdGhpcy5nZXREZWZhdWx0QWRkcmVzcygpKS5jcmVhdGVUcmFuc2ZlcihvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIFBheWxvYWQgU2lnbmF0dXJlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHVuc2lnbmVkUGF5bG9hZCAtIFRoZSBVbnNpZ25lZCBQYXlsb2FkIHRvIHNpZ24uXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIFBheWxvYWQgU2lnbmF0dXJlIG9iamVjdC5cbiAgICAgKiBAdGhyb3dzIHtBUElFcnJvcn0gaWYgdGhlIEFQSSByZXF1ZXN0IHRvIGNyZWF0ZSBhIFBheWxvYWQgU2lnbmF0dXJlIGZhaWxzLlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBpZiB0aGUgZGVmYXVsdCBhZGRyZXNzIGlzIG5vdCBmb3VuZC5cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVQYXlsb2FkU2lnbmF0dXJlKHVuc2lnbmVkUGF5bG9hZCkge1xuICAgICAgICByZXR1cm4gKGF3YWl0IHRoaXMuZ2V0RGVmYXVsdEFkZHJlc3MoKSkuY3JlYXRlUGF5bG9hZFNpZ25hdHVyZSh1bnNpZ25lZFBheWxvYWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgV2ViaG9vayBmb3IgYSB3YWxsZXQsIG1vbml0b3JzIGFsbCB3YWxsZXQgYWRkcmVzc2VzIGZvciBvbmNoYWluIGV2ZW50cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBub3RpZmljYXRpb25VcmkgLSBUaGUgVVJJIHRvIHdoaWNoIHRoZSB3ZWJob29rIG5vdGlmaWNhdGlvbnMgd2lsbCBiZSBzZW50LlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIG5ld2x5IGNyZWF0ZWQgd2ViaG9vayBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVXZWJob29rKG5vdGlmaWNhdGlvblVyaSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjb2luYmFzZV8xLkNvaW5iYXNlLmFwaUNsaWVudHMud2ViaG9vay5jcmVhdGVXYWxsZXRXZWJob29rKHRoaXMuZ2V0SWQoKSwge1xuICAgICAgICAgICAgbm90aWZpY2F0aW9uX3VyaTogbm90aWZpY2F0aW9uVXJpLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHdlYmhvb2tfMS5XZWJob29rLmluaXQocmVzdWx0LmRhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnZva2VzIGEgY29udHJhY3Qgd2l0aCB0aGUgZ2l2ZW4gZGF0YS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgdG8gaW52b2tlIHRoZSBjb250cmFjdFxuICAgICAqIEBwYXJhbSBvcHRpb25zLmNvbnRyYWN0QWRkcmVzcyAtIFRoZSBhZGRyZXNzIG9mIHRoZSBjb250cmFjdCB0aGUgbWV0aG9kIHdpbGwgYmUgaW52b2tlZCBvbi5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5tZXRob2QgLSBUaGUgbWV0aG9kIHRvIGludm9rZSBvbiB0aGUgY29udHJhY3QuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuYWJpIC0gVGhlIEFCSSBvZiB0aGUgY29udHJhY3QuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuYXJncyAtIFRoZSBhcmd1bWVudHMgdG8gcGFzcyB0byB0aGUgY29udHJhY3QgbWV0aG9kIGludm9jYXRpb24uXG4gICAgICogICBUaGUga2V5cyBzaG91bGQgYmUgdGhlIGFyZ3VtZW50IG5hbWVzIGFuZCB0aGUgdmFsdWVzIHNob3VsZCBiZSB0aGUgYXJndW1lbnQgdmFsdWVzLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmFtb3VudCAtIFRoZSBhbW91bnQgb2YgdGhlIGFzc2V0IHRvIHNlbmQgdG8gYSBwYXlhYmxlIGNvbnRyYWN0IG1ldGhvZC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5hc3NldElkIC0gVGhlIElEIG9mIHRoZSBhc3NldCB0byBzZW5kIHRvIGEgcGF5YWJsZSBjb250cmFjdCBtZXRob2QuXG4gICAgICogICBUaGUgYXNzZXQgbXVzdCBiZSBhIGRlbm9taW5hdGlvbiBvZiB0aGUgbmF0aXZlIGFzc2V0LiAoRXguIFwid2VpXCIsIFwiZ3dlaVwiLCBvciBcImV0aFwiKS5cbiAgICAgKiBAcmV0dXJucyBUaGUgQ29udHJhY3RJbnZvY2F0aW9uIG9iamVjdC5cbiAgICAgKiBAdGhyb3dzIHtBUElFcnJvcn0gaWYgdGhlIEFQSSByZXF1ZXN0IHRvIGNyZWF0ZSBhIGNvbnRyYWN0IGludm9jYXRpb24gZmFpbHMuXG4gICAgICovXG4gICAgYXN5bmMgaW52b2tlQ29udHJhY3Qob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKGF3YWl0IHRoaXMuZ2V0RGVmYXVsdEFkZHJlc3MoKSkuaW52b2tlQ29udHJhY3Qob3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlcGxveXMgYW4gRVJDMjAgdG9rZW4gY29udHJhY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIGZvciBjcmVhdGluZyB0aGUgRVJDMjAgdG9rZW4uXG4gICAgICogQHBhcmFtIG9wdGlvbnMubmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBFUkMyMCB0b2tlbi5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5zeW1ib2wgLSBUaGUgc3ltYm9sIG9mIHRoZSBFUkMyMCB0b2tlbi5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy50b3RhbFN1cHBseSAtIFRoZSB0b3RhbCBzdXBwbHkgb2YgdGhlIEVSQzIwIHRva2VuLlxuICAgICAqIEByZXR1cm5zIEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBkZXBsb3llZCBTbWFydENvbnRyYWN0IG9iamVjdC5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHByaXZhdGUga2V5IGlzIG5vdCBsb2FkZWQgd2hlbiBub3QgdXNpbmcgc2VydmVyIHNpZ25lci5cbiAgICAgKi9cbiAgICBhc3luYyBkZXBsb3lUb2tlbihvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoYXdhaXQgdGhpcy5nZXREZWZhdWx0QWRkcmVzcygpKS5kZXBsb3lUb2tlbihvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVwbG95cyBhbiBFUkM3MjEgdG9rZW4gY29udHJhY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIGZvciBjcmVhdGluZyB0aGUgRVJDNzIxIHRva2VuLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLm5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgRVJDNzIxIHRva2VuLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnN5bWJvbCAtIFRoZSBzeW1ib2wgb2YgdGhlIEVSQzcyMSB0b2tlbi5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5iYXNlVVJJIC0gVGhlIGJhc2UgVVJJIG9mIHRoZSBFUkM3MjEgdG9rZW4uXG4gICAgICogQHJldHVybnMgQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGRlcGxveWVkIFNtYXJ0Q29udHJhY3Qgb2JqZWN0LlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcHJpdmF0ZSBrZXkgaXMgbm90IGxvYWRlZCB3aGVuIG5vdCB1c2luZyBzZXJ2ZXIgc2lnbmVyLlxuICAgICAqL1xuICAgIGFzeW5jIGRlcGxveU5GVChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoYXdhaXQgdGhpcy5nZXREZWZhdWx0QWRkcmVzcygpKS5kZXBsb3lORlQob3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlcGxveXMgYW4gRVJDMTE1NSB0b2tlbiBjb250cmFjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIGNyZWF0aW5nIHRoZSBFUkMxMTU1IHRva2VuLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLm5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgRVJDMTE1NSB0b2tlbi5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5zeW1ib2wgLSBUaGUgc3ltYm9sIG9mIHRoZSBFUkMxMTU1IHRva2VuLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmJhc2VVUkkgLSBUaGUgYmFzZSBVUkkgb2YgdGhlIEVSQzExNTUgdG9rZW4uXG4gICAgICogQHJldHVybnMgQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGRlcGxveWVkIFNtYXJ0Q29udHJhY3Qgb2JqZWN0LlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcHJpdmF0ZSBrZXkgaXMgbm90IGxvYWRlZCB3aGVuIG5vdCB1c2luZyBzZXJ2ZXIgc2lnbmVyLlxuICAgICAqL1xuICAgIGFzeW5jIGRlcGxveU11bHRpVG9rZW4ob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKGF3YWl0IHRoaXMuZ2V0RGVmYXVsdEFkZHJlc3MoKSkuZGVwbG95TXVsdGlUb2tlbihvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVwbG95cyBhIGN1c3RvbSBjb250cmFjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIGNyZWF0aW5nIHRoZSBjdXN0b20gY29udHJhY3QuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuc29saWRpdHlWZXJzaW9uIC0gVGhlIHZlcnNpb24gb2YgdGhlIHNvbGlkaXR5IGNvbXBpbGVyLCBtdXN0IGJlIDAuOC4rLCBzdWNoIGFzIFwiMC44LjI4K2NvbW1pdC43ODkzNjE0YVwiLiBTZWUgaHR0cHM6Ly9iaW5hcmllcy5zb2xpZGl0eWxhbmcub3JnL2Jpbi9saXN0Lmpzb25cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5zb2xpZGl0eUlucHV0SnNvbiAtIFRoZSBpbnB1dCBqc29uIGZvciB0aGUgc29saWRpdHkgY29tcGlsZXIuIFNlZSBodHRwczovL2RvY3Muc29saWRpdHlsYW5nLm9yZy9lbi9sYXRlc3QvdXNpbmctdGhlLWNvbXBpbGVyLmh0bWwjaW5wdXQtZGVzY3JpcHRpb24gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5jb250cmFjdE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgY29udHJhY3QgY2xhc3MgdG8gYmUgZGVwbG95ZWQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuY29uc3RydWN0b3JBcmdzIC0gVGhlIGFyZ3VtZW50cyBmb3IgdGhlIGNvbnN0cnVjdG9yLlxuICAgICAqIEByZXR1cm5zIEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBkZXBsb3llZCBTbWFydENvbnRyYWN0IG9iamVjdC5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHByaXZhdGUga2V5IGlzIG5vdCBsb2FkZWQgd2hlbiBub3QgdXNpbmcgc2VydmVyIHNpZ25lci5cbiAgICAgKi9cbiAgICBhc3luYyBkZXBsb3lDb250cmFjdChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoYXdhaXQgdGhpcy5nZXREZWZhdWx0QWRkcmVzcygpKS5kZXBsb3lDb250cmFjdChvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRnVuZCB0aGUgd2FsbGV0IGZyb20geW91ciBhY2NvdW50IG9uIHRoZSBDb2luYmFzZSBQbGF0Zm9ybS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgdG8gY3JlYXRlIHRoZSBmdW5kIG9wZXJhdGlvblxuICAgICAqIEBwYXJhbSBvcHRpb25zLmFtb3VudCAtIFRoZSBhbW91bnQgb2YgdGhlIEFzc2V0IHRvIGZ1bmQgdGhlIHdhbGxldCB3aXRoXG4gICAgICogQHBhcmFtIG9wdGlvbnMuYXNzZXRJZCAtIFRoZSBJRCBvZiB0aGUgQXNzZXQgdG8gZnVuZCB3aXRoLiBGb3IgRXRoZXIsIGV0aCwgZ3dlaSwgYW5kIHdlaSBhcmUgc3VwcG9ydGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIGZ1bmQgb3BlcmF0aW9uIG9iamVjdFxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgZGVmYXVsdCBhZGRyZXNzIGRvZXMgbm90IGV4aXN0XG4gICAgICovXG4gICAgYXN5bmMgZnVuZChvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRBZGRyZXNzID0gYXdhaXQgdGhpcy5nZXREZWZhdWx0QWRkcmVzcygpO1xuICAgICAgICBpZiAoIWRlZmF1bHRBZGRyZXNzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEZWZhdWx0IGFkZHJlc3MgZG9lcyBub3QgZXhpc3RcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlZmF1bHRBZGRyZXNzLmZ1bmQob3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhIHF1b3RlIGZvciBmdW5kaW5nIHRoZSB3YWxsZXQgZnJvbSB5b3VyIENvaW5iYXNlIHBsYXRmb3JtIGFjY291bnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIHRvIGNyZWF0ZSB0aGUgZnVuZCBxdW90ZVxuICAgICAqIEBwYXJhbSBvcHRpb25zLmFtb3VudCAtIFRoZSBhbW91bnQgdG8gZnVuZFxuICAgICAqIEBwYXJhbSBvcHRpb25zLmFzc2V0SWQgLSBUaGUgSUQgb2YgdGhlIEFzc2V0IHRvIGZ1bmQgd2l0aC4gRm9yIEV0aGVyLCBldGgsIGd3ZWksIGFuZCB3ZWkgYXJlIHN1cHBvcnRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgZnVuZCBxdW90ZSBvYmplY3RcbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGRlZmF1bHQgYWRkcmVzcyBkb2VzIG5vdCBleGlzdFxuICAgICAqL1xuICAgIGFzeW5jIHF1b3RlRnVuZChvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRBZGRyZXNzID0gYXdhaXQgdGhpcy5nZXREZWZhdWx0QWRkcmVzcygpO1xuICAgICAgICBpZiAoIWRlZmF1bHRBZGRyZXNzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEZWZhdWx0IGFkZHJlc3MgZG9lcyBub3QgZXhpc3RcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlZmF1bHRBZGRyZXNzLnF1b3RlRnVuZChvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbGwgdGhlIGZ1bmQgb3BlcmF0aW9ucyBhc3NvY2lhdGVkIHdpdGggdGhlIHdhbGxldCdzIGRlZmF1bHQgYWRkcmVzcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIHBhZ2luYXRpb24gb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5saW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBmdW5kIG9wZXJhdGlvbnMgdG8gcmV0dXJuLiBMaW1pdCBjYW4gcmFuZ2UgYmV0d2VlbiAxIGFuZCAxMDAuXG4gICAgICogQHBhcmFtIG9wdGlvbnMucGFnZSAtIFRoZSBjdXJzb3IgZm9yIHBhZ2luYXRpb24gYWNyb3NzIG11bHRpcGxlIHBhZ2VzIG9mIGZ1bmQgb3BlcmF0aW9ucy4gRG9uJ3QgaW5jbHVkZSB0aGlzIHBhcmFtZXRlciBvbiB0aGUgZmlyc3QgY2FsbC4gVXNlIHRoZSBuZXh0IHBhZ2UgdmFsdWUgcmV0dXJuZWQgaW4gYSBwcmV2aW91cyByZXNwb25zZSB0byByZXF1ZXN0IHN1YnNlcXVlbnQgcmVzdWx0cy5cbiAgICAgKiBAcmV0dXJucyBUaGUgcGFnaW5hdGVkIGxpc3QgcmVzcG9uc2Ugb2YgZnVuZCBvcGVyYXRpb25zLlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgZGVmYXVsdCBhZGRyZXNzIGRvZXMgbm90IGV4aXN0XG4gICAgICovXG4gICAgYXN5bmMgbGlzdEZ1bmRPcGVyYXRpb25zKHsgbGltaXQgPSBjb2luYmFzZV8xLkNvaW5iYXNlLmRlZmF1bHRQYWdlTGltaXQsIHBhZ2UgPSB1bmRlZmluZWQsIH0gPSB7fSkge1xuICAgICAgICBjb25zdCBkZWZhdWx0QWRkcmVzcyA9IGF3YWl0IHRoaXMuZ2V0RGVmYXVsdEFkZHJlc3MoKTtcbiAgICAgICAgaWYgKCFkZWZhdWx0QWRkcmVzcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGVmYXVsdCBhZGRyZXNzIGRvZXMgbm90IGV4aXN0XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWZhdWx0QWRkcmVzcy5saXN0RnVuZE9wZXJhdGlvbnMoeyBsaW1pdCwgcGFnZSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgV2FsbGV0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgYSBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIFdhbGxldFxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gYFdhbGxldHtpZDogJyR7dGhpcy5tb2RlbC5pZH0nLCBuZXR3b3JrSWQ6ICcke3RoaXMubW9kZWwubmV0d29ya19pZH0nfWA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlcyB0aGUgc2VlZCBhbmQgYWRkcmVzcyBtb2RlbHMgcGFzc2VkIHRvIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzZWVkIC0gVGhlIHNlZWQgdG8gdXNlIGZvciB0aGUgV2FsbGV0XG4gICAgICovXG4gICAgdmFsaWRhdGVTZWVkKHNlZWQpIHtcbiAgICAgICAgaWYgKHNlZWQgJiYgc2VlZC5sZW5ndGggIT09IDY0ICYmIHNlZWQubGVuZ3RoICE9PSAxMjgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Bcmd1bWVudEVycm9yKFwiU2VlZCBtdXN0IGJlIDMyIG9yIDY0IGJ5dGVzXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvYWRzIHRoZSBzZWVkIGRhdGEgZnJvbSB0aGUgZ2l2ZW4gZmlsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmaWxlUGF0aCAtIFRoZSBwYXRoIG9mIHRoZSBmaWxlIHRvIGxvYWQgdGhlIHNlZWQgZGF0YSBmcm9tXG4gICAgICogQHJldHVybnMgVGhlIHNlZWQgZGF0YVxuICAgICAqL1xuICAgIGdldEV4aXN0aW5nU2VlZHMoZmlsZVBhdGgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBmcy5yZWFkRmlsZVN5bmMoZmlsZVBhdGgsIFwidXRmOFwiKTtcbiAgICAgICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNlZWREYXRhID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgICAgICAgIGlmICghT2JqZWN0LmVudHJpZXMoc2VlZERhdGEpLmV2ZXJ5KChba2V5LCB2YWx1ZV0pID0+IHR5cGVvZiBrZXkgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG4gICAgICAgICAgICAgICAgdHlwZW9mIHZhbHVlLmF1dGhUYWcgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgdmFsdWUuZW5jcnlwdGVkID09PSBcImJvb2xlYW5cIiAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiB2YWx1ZS5pdiA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiB2YWx1ZS5zZWVkID09PSBcInN0cmluZ1wiKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Bcmd1bWVudEVycm9yKFwiTWFsZm9ybWVkIGJhY2t1cCBkYXRhXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNlZWREYXRhO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG4gICAgICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gXCJFTk9FTlRcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Bcmd1bWVudEVycm9yKFwiTWFsZm9ybWVkIGJhY2t1cCBkYXRhXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGtleSBmb3IgZW5jcnlwdGluZyBzZWVkIGRhdGEuXG4gICAgICpcbiAgICAgKiBGb3IgRUMga2V5cyAoUEVNIGZvcm1hdCksIGl0IHVzZXMgY3J5cHRvLmRpZmZpZUhlbGxtYW4uXG4gICAgICogRm9yIEVkMjU1MTkga2V5cyAoYXNzdW1lZCB0byBiZSBhIGJhc2U2NC1lbmNvZGVkIDY0LWJ5dGUgc3RyaW5nKSwgaXQgY29udmVydHMgdGhlIHNlY3JldCBrZXlcbiAgICAgKiB0byBhbiBYMjU1MTkga2V5IHVzaW5nIGVkMmN1cnZlLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGVuY3J5cHRpb24ga2V5LlxuICAgICAqL1xuICAgIGdldEVuY3J5cHRpb25LZXkoKSB7XG4gICAgICAgIGNvbnN0IGFwaUtleVByaXZhdGVLZXkgPSBjb2luYmFzZV8xLkNvaW5iYXNlLmFwaUtleVByaXZhdGVLZXk7XG4gICAgICAgIGlmIChhcGlLZXlQcml2YXRlS2V5LnN0YXJ0c1dpdGgoXCItLS0tLUJFR0lOXCIpKSB7XG4gICAgICAgICAgICAvLyBBc3N1bWUgRUMga2V5IGluIFBFTSBmb3JtYXQuXG4gICAgICAgICAgICBjb25zdCBwcml2YXRlS2V5ID0gY3J5cHRvLmNyZWF0ZVByaXZhdGVLZXkoYXBpS2V5UHJpdmF0ZUtleSk7XG4gICAgICAgICAgICBjb25zdCBwdWJsaWNLZXkgPSBjcnlwdG8uY3JlYXRlUHVibGljS2V5KGFwaUtleVByaXZhdGVLZXkpO1xuICAgICAgICAgICAgcmV0dXJuIGNyeXB0by5kaWZmaWVIZWxsbWFuKHsgcHJpdmF0ZUtleSwgcHVibGljS2V5IH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gQXNzdW1lIEVkMjU1MTkga2V5OiBhIGJhc2U2NC1lbmNvZGVkIDY0LWJ5dGUgc3RyaW5nIChmaXJzdCAzMiBieXRlcyA9IHNlZWQsIG5leHQgMzIgPSBwdWJsaWMga2V5KVxuICAgICAgICAgICAgY29uc3QgZGVjb2RlZCA9IEJ1ZmZlci5mcm9tKGFwaUtleVByaXZhdGVLZXksIFwiYmFzZTY0XCIpO1xuICAgICAgICAgICAgaWYgKGRlY29kZWQubGVuZ3RoICE9PSA2NCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgRWQyNTUxOSBrZXkgZm9ybWF0XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2VlZCA9IGRlY29kZWQuc2xpY2UoMCwgMzIpO1xuICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgRWQyNTUxOSBzZWVkIHRvIGFuIFgyNTUxOSBrZXkgdXNpbmcgZWQyY3VydmUuXG4gICAgICAgICAgICBjb25zdCB4MjU1MTkgPSBlZDJjdXJ2ZS5jb252ZXJ0U2VjcmV0S2V5KG5ldyBVaW50OEFycmF5KHNlZWQpKTtcbiAgICAgICAgICAgIGlmICgheDI1NTE5KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGNvbnZlcnQgRWQyNTUxOSBrZXkgdG8gWDI1NTE5XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHgyNTUxOSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIFdhbGxldEFkZHJlc3Mgb2JqZWN0IGZvciB0aGUgZ2l2ZW4gQWRkcmVzc01vZGVsLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFkZHJlc3NNb2RlbCAtIFRoZSBBZGRyZXNzTW9kZWwgdG8gYnVpbGQgdGhlIFdhbGxldEFkZHJlc3MgZnJvbS5cbiAgICAgKiBAcGFyYW0gaW5kZXggLSBUaGUgaW5kZXggb2YgdGhlIEFkZHJlc3NNb2RlbC5cbiAgICAgKiBAcmV0dXJucyBUaGUgV2FsbGV0QWRkcmVzcyBvYmplY3QuXG4gICAgICovXG4gICAgYnVpbGRXYWxsZXRBZGRyZXNzKGFkZHJlc3NNb2RlbCwgaW5kZXgpIHtcbiAgICAgICAgaWYgKCF0aGlzLm1hc3Rlcikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyB3YWxsZXRfYWRkcmVzc18xLldhbGxldEFkZHJlc3MoYWRkcmVzc01vZGVsKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBrZXkgPSB0aGlzLmRlcml2ZUtleShpbmRleCk7XG4gICAgICAgIGNvbnN0IGV0aFdhbGxldCA9IG5ldyBldGhlcnNfMi5ldGhlcnMuV2FsbGV0KCgwLCB1dGlsc18xLmNvbnZlcnRTdHJpbmdUb0hleCkoa2V5LnByaXZhdGVLZXkpKTtcbiAgICAgICAgaWYgKGV0aFdhbGxldC5hZGRyZXNzICE9IGFkZHJlc3NNb2RlbC5hZGRyZXNzX2lkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNlZWQgZG9lcyBub3QgbWF0Y2ggd2FsbGV0YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyB3YWxsZXRfYWRkcmVzc18xLldhbGxldEFkZHJlc3MoYWRkcmVzc01vZGVsLCBldGhXYWxsZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXYWl0cyB1bnRpbCB0aGUgU2VydmVyU2lnbmVyIGhhcyBjcmVhdGVkIGEgc2VlZCBmb3IgdGhlIFdhbGxldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB3YWxsZXRJZCAtIFRoZSBJRCBvZiB0aGUgV2FsbGV0IHRoYXQgaXMgYXdhaXRpbmcgc2VlZCBjcmVhdGlvbi5cbiAgICAgKiBAcGFyYW0gaW50ZXJ2YWxTZWNvbmRzIC0gVGhlIGludGVydmFsIGF0IHdoaWNoIHRvIHBvbGwgdGhlIENEUFNlcnZpY2UsIGluIHNlY29uZHMuXG4gICAgICogQHBhcmFtIHRpbWVvdXRTZWNvbmRzIC0gVGhlIG1heGltdW0gYW1vdW50IG9mIHRpbWUgdG8gd2FpdCBmb3IgdGhlIFNlcnZlclNpZ25lciB0byBjcmVhdGUgYSBzZWVkLCBpbiBzZWNvbmRzLlxuICAgICAqIEB0aHJvd3Mge0FQSUVycm9yfSBpZiB0aGUgQVBJIHJlcXVlc3QgdG8gZ2V0IGEgV2FsbGV0IGZhaWxzLlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBpZiB0aGUgU2VydmVyU2lnbmVyIHRpbWVzIG91dC5cbiAgICAgKi9cbiAgICBhc3luYyB3YWl0Rm9yU2lnbmVyKHdhbGxldElkLCBpbnRlcnZhbFNlY29uZHMgPSAwLjIsIHRpbWVvdXRTZWNvbmRzID0gMjApIHtcbiAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgd2hpbGUgKERhdGUubm93KCkgLSBzdGFydFRpbWUgPCB0aW1lb3V0U2Vjb25kcyAqIDEwMDApIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY29pbmJhc2VfMS5Db2luYmFzZS5hcGlDbGllbnRzLndhbGxldC5nZXRXYWxsZXQod2FsbGV0SWQpO1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlPy5kYXRhLnNlcnZlcl9zaWduZXJfc3RhdHVzID09PSB0eXBlc18xLlNlcnZlclNpZ25lclN0YXR1cy5BQ1RJVkUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCAoMCwgdXRpbHNfMS5kZWxheSkoaW50ZXJ2YWxTZWNvbmRzKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXYWxsZXQgY3JlYXRpb24gdGltZWQgb3V0LiBDaGVjayBzdGF0dXMgb2YgeW91ciBTZXJ2ZXItU2lnbmVyXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBtYXN0ZXIgbm9kZSBmb3IgdGhlIGdpdmVuIHNlZWQsIGlmIHZhbGlkLiBJZiB0aGUgc2VlZCBpcyB1bmRlZmluZWQgaXQgd2lsbCBzZXQgdGhlIG1hc3RlciBub2RlIHVzaW5nIGEgcmFuZG9tIHNlZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2VlZCAtIFRoZSBzZWVkIHRvIHVzZSBmb3IgdGhlIFdhbGxldC5cbiAgICAgKiBAcmV0dXJucyBUaGUgbWFzdGVyIG5vZGUgZm9yIHRoZSBnaXZlbiBzZWVkLlxuICAgICAqL1xuICAgIHNldE1hc3Rlck5vZGUoc2VlZCkge1xuICAgICAgICBpZiAoc2VlZCA9PT0gXCJcIikge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzZWVkID0gZXRoZXJzXzIuZXRoZXJzLldhbGxldC5jcmVhdGVSYW5kb20oKS5wcml2YXRlS2V5LnNsaWNlKDIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmFsaWRhdGVTZWVkKHNlZWQpO1xuICAgICAgICB0aGlzLnNlZWQgPSBzZWVkO1xuICAgICAgICB0aGlzLm1hc3RlciA9IGJpcDMyXzEuSERLZXkuZnJvbU1hc3RlclNlZWQoQnVmZmVyLmZyb20oc2VlZCwgXCJoZXhcIikpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXJpdmVzIGEga2V5IGZvciBhbiBhbHJlYWR5IHJlZ2lzdGVyZWQgQWRkcmVzcyBpbiB0aGUgV2FsbGV0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGluZGV4IC0gVGhlIGluZGV4IG9mIHRoZSBBZGRyZXNzIHRvIGRlcml2ZS5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBJZiB0aGUga2V5IGRlcml2YXRpb24gZmFpbHMuXG4gICAgICogQHJldHVybnMgVGhlIGRlcml2ZWQga2V5LlxuICAgICAqL1xuICAgIGRlcml2ZUtleShpbmRleCkge1xuICAgICAgICBpZiAoIXRoaXMubWFzdGVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZGVyaXZlIGtleSBmb3IgV2FsbGV0IHdpdGhvdXQgc2VlZCBsb2FkZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVyaXZlZEtleSA9IHRoaXMubWFzdGVyPy5kZXJpdmUodGhpcy5hZGRyZXNzUGF0aFByZWZpeCArIGAvJHtpbmRleH1gKTtcbiAgICAgICAgaWYgKCFkZXJpdmVkS2V5Py5wcml2YXRlS2V5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gZGVyaXZlIGtleVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVyaXZlZEtleTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhdHRlc3RhdGlvbiBmb3IgdGhlIEFkZHJlc3MgY3VycmVudGx5IGJlaW5nIGNyZWF0ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ga2V5IC0gVGhlIGtleSBvZiB0aGUgV2FsbGV0LlxuICAgICAqIEByZXR1cm5zIFRoZSBhdHRlc3RhdGlvbi5cbiAgICAgKi9cbiAgICBjcmVhdGVBdHRlc3RhdGlvbihrZXkpIHtcbiAgICAgICAgaWYgKCFrZXkucHVibGljS2V5IHx8ICFrZXkucHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgIHRocm93IEVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHB1YmxpY0tleSA9ICgwLCB1dGlsc18xLmNvbnZlcnRTdHJpbmdUb0hleCkoa2V5LnB1YmxpY0tleSk7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICB3YWxsZXRfaWQ6IHRoaXMubW9kZWwuaWQsXG4gICAgICAgICAgICBwdWJsaWNfa2V5OiBwdWJsaWNLZXksXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBoYXNoZWRQYXlsb2FkID0gY3J5cHRvLmNyZWF0ZUhhc2goXCJzaGEyNTZcIikudXBkYXRlKHBheWxvYWQpLmRpZ2VzdCgpO1xuICAgICAgICBjb25zdCBzaWduYXR1cmUgPSBzZWNwMjU2azEuZWNkc2FTaWduKGhhc2hlZFBheWxvYWQsIGtleS5wcml2YXRlS2V5KTtcbiAgICAgICAgY29uc3QgciA9IHNpZ25hdHVyZS5zaWduYXR1cmUuc2xpY2UoMCwgMzIpO1xuICAgICAgICBjb25zdCBzID0gc2lnbmF0dXJlLnNpZ25hdHVyZS5zbGljZSgzMiwgNjQpO1xuICAgICAgICBjb25zdCB2ID0gc2lnbmF0dXJlLnJlY2lkICsgMjcgKyA0O1xuICAgICAgICBjb25zdCBuZXdTaWduYXR1cmVCdWZmZXIgPSBCdWZmZXIuY29uY2F0KFtCdWZmZXIuZnJvbShbdl0pLCByLCBzXSk7XG4gICAgICAgIGNvbnN0IG5ld1NpZ25hdHVyZUhleCA9IG5ld1NpZ25hdHVyZUJ1ZmZlci50b1N0cmluZyhcImhleFwiKTtcbiAgICAgICAgcmV0dXJuIG5ld1NpZ25hdHVyZUhleDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVsb2FkcyB0aGUgV2FsbGV0IG1vZGVsIHdpdGggdGhlIGxhdGVzdCBkYXRhIGZyb20gdGhlIHNlcnZlci5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0FQSUVycm9yfSBpZiB0aGUgQVBJIHJlcXVlc3QgdG8gZ2V0IGEgV2FsbGV0IGZhaWxzLlxuICAgICAqL1xuICAgIGFzeW5jIHJlbG9hZCgpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29pbmJhc2VfMS5Db2luYmFzZS5hcGlDbGllbnRzLndhbGxldC5nZXRXYWxsZXQodGhpcy5tb2RlbC5pZCk7XG4gICAgICAgIHRoaXMubW9kZWwgPSByZXN1bHQ/LmRhdGE7XG4gICAgfVxufVxuZXhwb3J0cy5XYWxsZXQgPSBXYWxsZXQ7XG5XYWxsZXQuTUFYX0FERFJFU1NFUyA9IDIwO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/wallet.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/webhook.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/webhook.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Webhook = void 0;\nconst api_1 = __webpack_require__(/*! ../client/api */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/client/api.js\");\nconst coinbase_1 = __webpack_require__(/*! ./coinbase */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/coinbase.js\");\n/**\n * A representation of a Webhook,\n * which provides methods to create, list, update, and delete webhooks that are used to receive notifications of specific events.\n */\nclass Webhook {\n    /**\n     * Initializes a new Webhook object.\n     *\n     * @param model - The underlying Webhook object.\n     * @throws {Error} If the model is not provided.\n     */\n    constructor(model) {\n        if (!model) {\n            throw new Error(\"Webhook model cannot be empty\");\n        }\n        this.model = model;\n    }\n    /**\n     * Returns a new Webhook object. Do not use this method directly. Instead, Webhook.create(...)\n     *\n     * @constructs Webhook\n     * @param model - The underlying Webhook model object\n     * @returns A Webhook object.\n     */\n    static init(model) {\n        return new Webhook(model);\n    }\n    /**\n     * Creates a new webhook for a specified network.\n     *\n     * @param options - The options to create webhook.\n     * @param options.networkId - The network ID for which the webhook is created.\n     * @param options.notificationUri - The URI where notifications should be sent.\n     * @param options.eventType - The type of event for the webhook.\n     * @param options.eventTypeFilter - Filter for wallet or smart contract activity event types.\n     * @param options.eventFilters - Filters applied to the events that determine which specific events trigger the webhook.\n     * @returns A promise that resolves to a new instance of Webhook.\n     */\n    static async create({ networkId, notificationUri, eventType, eventTypeFilter, eventFilters = [], }) {\n        const result = await coinbase_1.Coinbase.apiClients.webhook.createWebhook({\n            network_id: networkId,\n            notification_uri: notificationUri,\n            event_type: eventType,\n            event_type_filter: eventTypeFilter,\n            event_filters: eventFilters,\n        });\n        return new Webhook(result.data);\n    }\n    /**\n     * Lists the Webhooks belonging to the CDP Project.\n     *\n     * @param options - The pagination options.\n     * @param options.limit - The maximum number of Webhooks to return. Limit can range between 1 and 100.\n     * @param options.page - The cursor for pagination across multiple pages of Webhooks. Don\\&#39;t include this parameter on the first call. Use the next page value returned in a previous response to request subsequent results.\n     *\n     * @returns The paginated list response of Webhooks.\n     */\n    static async list({ limit = coinbase_1.Coinbase.defaultPageLimit, page = undefined, } = {}) {\n        const data = [];\n        let nextPage;\n        const response = await coinbase_1.Coinbase.apiClients.webhook.listWebhooks(limit, page);\n        const webhooks = response.data.data;\n        for (const w of webhooks) {\n            data.push(new Webhook(w));\n        }\n        const hasMore = response.data.has_more ? response.data.has_more : false;\n        if (hasMore) {\n            if (response.data.next_page) {\n                nextPage = response.data.next_page;\n            }\n        }\n        return {\n            data,\n            hasMore,\n            nextPage,\n        };\n    }\n    /**\n     * Returns the ID of the webhook.\n     *\n     * @returns The ID of the webhook, or undefined if the model is null.\n     */\n    getId() {\n        return this.model?.id;\n    }\n    /**\n     * Returns the network ID associated with the webhook.\n     *\n     * @returns The network ID of the webhook, or undefined if the model is null.\n     */\n    getNetworkId() {\n        return this.model?.network_id;\n    }\n    /**\n     * Returns the notification URI of the webhook.\n     *\n     * @returns The URI where notifications are sent, or undefined if the model is null.\n     */\n    getNotificationURI() {\n        return this.model?.notification_uri;\n    }\n    /**\n     * Returns the event type of the webhook.\n     *\n     * @returns The type of event the webhook listens for, or undefined if the model is null.\n     */\n    getEventType() {\n        return this.model?.event_type;\n    }\n    /**\n     * Returns the event type filter of the webhook.\n     *\n     * @returns The filter which will be used to filter for events of a certain event type\n     */\n    getEventTypeFilter() {\n        return this.model?.event_type_filter;\n    }\n    /**\n     * Returns the event filters applied to the webhook.\n     *\n     * @returns An array of event filters used by the webhook, or undefined if the model is null.\n     */\n    getEventFilters() {\n        return this.model?.event_filters;\n    }\n    /**\n     * Returns the signature header of the webhook.\n     *\n     * @returns The signature header which will be set on the callback requests, or undefined if the model is null.\n     */\n    getSignatureHeader() {\n        return this.model?.signature_header;\n    }\n    /**\n     * Updates the webhook with a new notification URI, and optionally a new list of addresses to monitor.\n     *\n     * @param options - The options to update webhook.\n     * @param options.notificationUri - The new URI for webhook notifications.\n     * @param options.eventTypeFilter - The new eventTypeFilter that contains a new list (replacement) of addresses to monitor for the webhook.\n     * @returns A promise that resolves to the updated Webhook object.\n     */\n    async update({ notificationUri, eventTypeFilter, }) {\n        const finalNotificationUri = notificationUri ?? this.getNotificationURI();\n        const finalEventTypeFilter = eventTypeFilter ?? this.getEventTypeFilter();\n        // wallet ID is required for wallet activity event type filter, but we do not support updating it just yet, this will be added in the future\n        if (this.getEventType() === api_1.WebhookEventType.WalletActivity) {\n            finalEventTypeFilter.wallet_id = (this.getEventTypeFilter()?.wallet_id);\n        }\n        const result = await coinbase_1.Coinbase.apiClients.webhook.updateWebhook(this.getId(), {\n            notification_uri: finalNotificationUri,\n            event_filters: this.getEventFilters(),\n            event_type_filter: finalEventTypeFilter,\n        });\n        this.model = result.data;\n        return this;\n    }\n    /**\n     * Deletes the webhook.\n     *\n     * @returns A promise that resolves when the webhook is deleted and its attributes are set to null.\n     */\n    async delete() {\n        await coinbase_1.Coinbase.apiClients.webhook.deleteWebhook(this.getId());\n        this.model = null;\n    }\n    /**\n     * Returns a String representation of the Webhook.\n     *\n     * @returns A String representation of the Webhook.\n     */\n    toString() {\n        return (`Webhook { id: '${this.getId()}', networkId: '${this.getNetworkId()}', ` +\n            `eventType: '${this.getEventType()}', eventFilter: ${JSON.stringify(this.getEventFilters())}, ` +\n            `eventTypeFilter: ${JSON.stringify(this.getEventTypeFilter())}, ` +\n            `notificationUri: '${this.getNotificationURI()}', signatureHeader: '${this.getSignatureHeader()}' }`);\n    }\n}\nexports.Webhook = Webhook;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL3dlYmhvb2suanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZUFBZTtBQUNmLGNBQWMsbUJBQU8sQ0FBQyxxRkFBZTtBQUNyQyxtQkFBbUIsbUJBQU8sQ0FBQyx5RkFBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw0RUFBNEU7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HO0FBQ25HO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrRUFBa0UsSUFBSTtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1DQUFtQztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTyxhQUFhLGlCQUFpQixvQkFBb0I7QUFDcEYsMkJBQTJCLG9CQUFvQixrQkFBa0IsdUNBQXVDO0FBQ3hHLGdDQUFnQywwQ0FBMEM7QUFDMUUsaUNBQWlDLDBCQUEwQix1QkFBdUIsMEJBQTBCLEdBQUc7QUFDL0c7QUFDQTtBQUNBLGVBQWUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXJ2aXZhbC1mdW4vLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL3dlYmhvb2suanM/NWI4MCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuV2ViaG9vayA9IHZvaWQgMDtcbmNvbnN0IGFwaV8xID0gcmVxdWlyZShcIi4uL2NsaWVudC9hcGlcIik7XG5jb25zdCBjb2luYmFzZV8xID0gcmVxdWlyZShcIi4vY29pbmJhc2VcIik7XG4vKipcbiAqIEEgcmVwcmVzZW50YXRpb24gb2YgYSBXZWJob29rLFxuICogd2hpY2ggcHJvdmlkZXMgbWV0aG9kcyB0byBjcmVhdGUsIGxpc3QsIHVwZGF0ZSwgYW5kIGRlbGV0ZSB3ZWJob29rcyB0aGF0IGFyZSB1c2VkIHRvIHJlY2VpdmUgbm90aWZpY2F0aW9ucyBvZiBzcGVjaWZpYyBldmVudHMuXG4gKi9cbmNsYXNzIFdlYmhvb2sge1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGEgbmV3IFdlYmhvb2sgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIG1vZGVsIC0gVGhlIHVuZGVybHlpbmcgV2ViaG9vayBvYmplY3QuXG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBtb2RlbCBpcyBub3QgcHJvdmlkZWQuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobW9kZWwpIHtcbiAgICAgICAgaWYgKCFtb2RlbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV2ViaG9vayBtb2RlbCBjYW5ub3QgYmUgZW1wdHlcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb2RlbCA9IG1vZGVsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IFdlYmhvb2sgb2JqZWN0LiBEbyBub3QgdXNlIHRoaXMgbWV0aG9kIGRpcmVjdGx5LiBJbnN0ZWFkLCBXZWJob29rLmNyZWF0ZSguLi4pXG4gICAgICpcbiAgICAgKiBAY29uc3RydWN0cyBXZWJob29rXG4gICAgICogQHBhcmFtIG1vZGVsIC0gVGhlIHVuZGVybHlpbmcgV2ViaG9vayBtb2RlbCBvYmplY3RcbiAgICAgKiBAcmV0dXJucyBBIFdlYmhvb2sgb2JqZWN0LlxuICAgICAqL1xuICAgIHN0YXRpYyBpbml0KG1vZGVsKSB7XG4gICAgICAgIHJldHVybiBuZXcgV2ViaG9vayhtb2RlbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgd2ViaG9vayBmb3IgYSBzcGVjaWZpZWQgbmV0d29yay5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgdG8gY3JlYXRlIHdlYmhvb2suXG4gICAgICogQHBhcmFtIG9wdGlvbnMubmV0d29ya0lkIC0gVGhlIG5ldHdvcmsgSUQgZm9yIHdoaWNoIHRoZSB3ZWJob29rIGlzIGNyZWF0ZWQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMubm90aWZpY2F0aW9uVXJpIC0gVGhlIFVSSSB3aGVyZSBub3RpZmljYXRpb25zIHNob3VsZCBiZSBzZW50LlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmV2ZW50VHlwZSAtIFRoZSB0eXBlIG9mIGV2ZW50IGZvciB0aGUgd2ViaG9vay5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5ldmVudFR5cGVGaWx0ZXIgLSBGaWx0ZXIgZm9yIHdhbGxldCBvciBzbWFydCBjb250cmFjdCBhY3Rpdml0eSBldmVudCB0eXBlcy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5ldmVudEZpbHRlcnMgLSBGaWx0ZXJzIGFwcGxpZWQgdG8gdGhlIGV2ZW50cyB0aGF0IGRldGVybWluZSB3aGljaCBzcGVjaWZpYyBldmVudHMgdHJpZ2dlciB0aGUgd2ViaG9vay5cbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIG5ldyBpbnN0YW5jZSBvZiBXZWJob29rLlxuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyBjcmVhdGUoeyBuZXR3b3JrSWQsIG5vdGlmaWNhdGlvblVyaSwgZXZlbnRUeXBlLCBldmVudFR5cGVGaWx0ZXIsIGV2ZW50RmlsdGVycyA9IFtdLCB9KSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNvaW5iYXNlXzEuQ29pbmJhc2UuYXBpQ2xpZW50cy53ZWJob29rLmNyZWF0ZVdlYmhvb2soe1xuICAgICAgICAgICAgbmV0d29ya19pZDogbmV0d29ya0lkLFxuICAgICAgICAgICAgbm90aWZpY2F0aW9uX3VyaTogbm90aWZpY2F0aW9uVXJpLFxuICAgICAgICAgICAgZXZlbnRfdHlwZTogZXZlbnRUeXBlLFxuICAgICAgICAgICAgZXZlbnRfdHlwZV9maWx0ZXI6IGV2ZW50VHlwZUZpbHRlcixcbiAgICAgICAgICAgIGV2ZW50X2ZpbHRlcnM6IGV2ZW50RmlsdGVycyxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgV2ViaG9vayhyZXN1bHQuZGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3RzIHRoZSBXZWJob29rcyBiZWxvbmdpbmcgdG8gdGhlIENEUCBQcm9qZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgcGFnaW5hdGlvbiBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIFdlYmhvb2tzIHRvIHJldHVybi4gTGltaXQgY2FuIHJhbmdlIGJldHdlZW4gMSBhbmQgMTAwLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnBhZ2UgLSBUaGUgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiBXZWJob29rcy4gRG9uXFwmIzM5O3QgaW5jbHVkZSB0aGlzIHBhcmFtZXRlciBvbiB0aGUgZmlyc3QgY2FsbC4gVXNlIHRoZSBuZXh0IHBhZ2UgdmFsdWUgcmV0dXJuZWQgaW4gYSBwcmV2aW91cyByZXNwb25zZSB0byByZXF1ZXN0IHN1YnNlcXVlbnQgcmVzdWx0cy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBwYWdpbmF0ZWQgbGlzdCByZXNwb25zZSBvZiBXZWJob29rcy5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgbGlzdCh7IGxpbWl0ID0gY29pbmJhc2VfMS5Db2luYmFzZS5kZWZhdWx0UGFnZUxpbWl0LCBwYWdlID0gdW5kZWZpbmVkLCB9ID0ge30pIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IFtdO1xuICAgICAgICBsZXQgbmV4dFBhZ2U7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY29pbmJhc2VfMS5Db2luYmFzZS5hcGlDbGllbnRzLndlYmhvb2subGlzdFdlYmhvb2tzKGxpbWl0LCBwYWdlKTtcbiAgICAgICAgY29uc3Qgd2ViaG9va3MgPSByZXNwb25zZS5kYXRhLmRhdGE7XG4gICAgICAgIGZvciAoY29uc3QgdyBvZiB3ZWJob29rcykge1xuICAgICAgICAgICAgZGF0YS5wdXNoKG5ldyBXZWJob29rKHcpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoYXNNb3JlID0gcmVzcG9uc2UuZGF0YS5oYXNfbW9yZSA/IHJlc3BvbnNlLmRhdGEuaGFzX21vcmUgOiBmYWxzZTtcbiAgICAgICAgaWYgKGhhc01vcmUpIHtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5kYXRhLm5leHRfcGFnZSkge1xuICAgICAgICAgICAgICAgIG5leHRQYWdlID0gcmVzcG9uc2UuZGF0YS5uZXh0X3BhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBoYXNNb3JlLFxuICAgICAgICAgICAgbmV4dFBhZ2UsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIElEIG9mIHRoZSB3ZWJob29rLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIElEIG9mIHRoZSB3ZWJob29rLCBvciB1bmRlZmluZWQgaWYgdGhlIG1vZGVsIGlzIG51bGwuXG4gICAgICovXG4gICAgZ2V0SWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsPy5pZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbmV0d29yayBJRCBhc3NvY2lhdGVkIHdpdGggdGhlIHdlYmhvb2suXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgbmV0d29yayBJRCBvZiB0aGUgd2ViaG9vaywgb3IgdW5kZWZpbmVkIGlmIHRoZSBtb2RlbCBpcyBudWxsLlxuICAgICAqL1xuICAgIGdldE5ldHdvcmtJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWw/Lm5ldHdvcmtfaWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG5vdGlmaWNhdGlvbiBVUkkgb2YgdGhlIHdlYmhvb2suXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgVVJJIHdoZXJlIG5vdGlmaWNhdGlvbnMgYXJlIHNlbnQsIG9yIHVuZGVmaW5lZCBpZiB0aGUgbW9kZWwgaXMgbnVsbC5cbiAgICAgKi9cbiAgICBnZXROb3RpZmljYXRpb25VUkkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsPy5ub3RpZmljYXRpb25fdXJpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBldmVudCB0eXBlIG9mIHRoZSB3ZWJob29rLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHR5cGUgb2YgZXZlbnQgdGhlIHdlYmhvb2sgbGlzdGVucyBmb3IsIG9yIHVuZGVmaW5lZCBpZiB0aGUgbW9kZWwgaXMgbnVsbC5cbiAgICAgKi9cbiAgICBnZXRFdmVudFR5cGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsPy5ldmVudF90eXBlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBldmVudCB0eXBlIGZpbHRlciBvZiB0aGUgd2ViaG9vay5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBmaWx0ZXIgd2hpY2ggd2lsbCBiZSB1c2VkIHRvIGZpbHRlciBmb3IgZXZlbnRzIG9mIGEgY2VydGFpbiBldmVudCB0eXBlXG4gICAgICovXG4gICAgZ2V0RXZlbnRUeXBlRmlsdGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbD8uZXZlbnRfdHlwZV9maWx0ZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGV2ZW50IGZpbHRlcnMgYXBwbGllZCB0byB0aGUgd2ViaG9vay5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEFuIGFycmF5IG9mIGV2ZW50IGZpbHRlcnMgdXNlZCBieSB0aGUgd2ViaG9vaywgb3IgdW5kZWZpbmVkIGlmIHRoZSBtb2RlbCBpcyBudWxsLlxuICAgICAqL1xuICAgIGdldEV2ZW50RmlsdGVycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWw/LmV2ZW50X2ZpbHRlcnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHNpZ25hdHVyZSBoZWFkZXIgb2YgdGhlIHdlYmhvb2suXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgc2lnbmF0dXJlIGhlYWRlciB3aGljaCB3aWxsIGJlIHNldCBvbiB0aGUgY2FsbGJhY2sgcmVxdWVzdHMsIG9yIHVuZGVmaW5lZCBpZiB0aGUgbW9kZWwgaXMgbnVsbC5cbiAgICAgKi9cbiAgICBnZXRTaWduYXR1cmVIZWFkZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsPy5zaWduYXR1cmVfaGVhZGVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSB3ZWJob29rIHdpdGggYSBuZXcgbm90aWZpY2F0aW9uIFVSSSwgYW5kIG9wdGlvbmFsbHkgYSBuZXcgbGlzdCBvZiBhZGRyZXNzZXMgdG8gbW9uaXRvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgdG8gdXBkYXRlIHdlYmhvb2suXG4gICAgICogQHBhcmFtIG9wdGlvbnMubm90aWZpY2F0aW9uVXJpIC0gVGhlIG5ldyBVUkkgZm9yIHdlYmhvb2sgbm90aWZpY2F0aW9ucy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5ldmVudFR5cGVGaWx0ZXIgLSBUaGUgbmV3IGV2ZW50VHlwZUZpbHRlciB0aGF0IGNvbnRhaW5zIGEgbmV3IGxpc3QgKHJlcGxhY2VtZW50KSBvZiBhZGRyZXNzZXMgdG8gbW9uaXRvciBmb3IgdGhlIHdlYmhvb2suXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHVwZGF0ZWQgV2ViaG9vayBvYmplY3QuXG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlKHsgbm90aWZpY2F0aW9uVXJpLCBldmVudFR5cGVGaWx0ZXIsIH0pIHtcbiAgICAgICAgY29uc3QgZmluYWxOb3RpZmljYXRpb25VcmkgPSBub3RpZmljYXRpb25VcmkgPz8gdGhpcy5nZXROb3RpZmljYXRpb25VUkkoKTtcbiAgICAgICAgY29uc3QgZmluYWxFdmVudFR5cGVGaWx0ZXIgPSBldmVudFR5cGVGaWx0ZXIgPz8gdGhpcy5nZXRFdmVudFR5cGVGaWx0ZXIoKTtcbiAgICAgICAgLy8gd2FsbGV0IElEIGlzIHJlcXVpcmVkIGZvciB3YWxsZXQgYWN0aXZpdHkgZXZlbnQgdHlwZSBmaWx0ZXIsIGJ1dCB3ZSBkbyBub3Qgc3VwcG9ydCB1cGRhdGluZyBpdCBqdXN0IHlldCwgdGhpcyB3aWxsIGJlIGFkZGVkIGluIHRoZSBmdXR1cmVcbiAgICAgICAgaWYgKHRoaXMuZ2V0RXZlbnRUeXBlKCkgPT09IGFwaV8xLldlYmhvb2tFdmVudFR5cGUuV2FsbGV0QWN0aXZpdHkpIHtcbiAgICAgICAgICAgIGZpbmFsRXZlbnRUeXBlRmlsdGVyLndhbGxldF9pZCA9ICh0aGlzLmdldEV2ZW50VHlwZUZpbHRlcigpPy53YWxsZXRfaWQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNvaW5iYXNlXzEuQ29pbmJhc2UuYXBpQ2xpZW50cy53ZWJob29rLnVwZGF0ZVdlYmhvb2sodGhpcy5nZXRJZCgpLCB7XG4gICAgICAgICAgICBub3RpZmljYXRpb25fdXJpOiBmaW5hbE5vdGlmaWNhdGlvblVyaSxcbiAgICAgICAgICAgIGV2ZW50X2ZpbHRlcnM6IHRoaXMuZ2V0RXZlbnRGaWx0ZXJzKCksXG4gICAgICAgICAgICBldmVudF90eXBlX2ZpbHRlcjogZmluYWxFdmVudFR5cGVGaWx0ZXIsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1vZGVsID0gcmVzdWx0LmRhdGE7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIHRoZSB3ZWJob29rLlxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgd2ViaG9vayBpcyBkZWxldGVkIGFuZCBpdHMgYXR0cmlidXRlcyBhcmUgc2V0IHRvIG51bGwuXG4gICAgICovXG4gICAgYXN5bmMgZGVsZXRlKCkge1xuICAgICAgICBhd2FpdCBjb2luYmFzZV8xLkNvaW5iYXNlLmFwaUNsaWVudHMud2ViaG9vay5kZWxldGVXZWJob29rKHRoaXMuZ2V0SWQoKSk7XG4gICAgICAgIHRoaXMubW9kZWwgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgU3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBXZWJob29rLlxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIFdlYmhvb2suXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAoYFdlYmhvb2sgeyBpZDogJyR7dGhpcy5nZXRJZCgpfScsIG5ldHdvcmtJZDogJyR7dGhpcy5nZXROZXR3b3JrSWQoKX0nLCBgICtcbiAgICAgICAgICAgIGBldmVudFR5cGU6ICcke3RoaXMuZ2V0RXZlbnRUeXBlKCl9JywgZXZlbnRGaWx0ZXI6ICR7SlNPTi5zdHJpbmdpZnkodGhpcy5nZXRFdmVudEZpbHRlcnMoKSl9LCBgICtcbiAgICAgICAgICAgIGBldmVudFR5cGVGaWx0ZXI6ICR7SlNPTi5zdHJpbmdpZnkodGhpcy5nZXRFdmVudFR5cGVGaWx0ZXIoKSl9LCBgICtcbiAgICAgICAgICAgIGBub3RpZmljYXRpb25Vcmk6ICcke3RoaXMuZ2V0Tm90aWZpY2F0aW9uVVJJKCl9Jywgc2lnbmF0dXJlSGVhZGVyOiAnJHt0aGlzLmdldFNpZ25hdHVyZUhlYWRlcigpfScgfWApO1xuICAgIH1cbn1cbmV4cG9ydHMuV2ViaG9vayA9IFdlYmhvb2s7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/webhook.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/index.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./coinbase/address */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/address.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/address/external_address */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/address/external_address.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/address/wallet_address */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/address/wallet_address.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/api_error */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/api_error.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/asset */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/asset.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/authenticator */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/authenticator.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/balance */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/balance.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/balance_map */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/balance_map.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/coinbase */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/coinbase.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/constants */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/constants.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/contract_event */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/contract_event.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/contract_invocation */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/contract_invocation.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/errors */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/errors.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/faucet_transaction */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/faucet_transaction.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/hash */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/hash.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/historical_balance */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/historical_balance.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/payload_signature */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/payload_signature.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/server_signer */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/server_signer.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/smart_contract */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/smart_contract.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/staking_balance */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/staking_balance.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/staking_operation */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/staking_operation.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/staking_reward */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/staking_reward.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/trade */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/trade.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/transaction */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/transaction.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/transfer */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/transfer.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/types */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/types.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/validator */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/validator.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/wallet */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/wallet.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/webhook */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/webhook.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/read_contract */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/read_contract.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/crypto_amount */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/crypto_amount.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/fiat_amount */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/fiat_amount.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/fund_operation */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/fund_operation.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/fund_quote */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/fund_quote.js\"), exports);\n__exportStar(__webpack_require__(/*! ./types/chain */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/types/chain.js\"), exports);\n__exportStar(__webpack_require__(/*! ./wallets/types */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/wallets/types.js\"), exports);\n__exportStar(__webpack_require__(/*! ./wallets/createSmartWallet */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/wallets/createSmartWallet.js\"), exports);\n__exportStar(__webpack_require__(/*! ./wallets/toSmartWallet */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/wallets/toSmartWallet.js\"), exports);\n__exportStar(__webpack_require__(/*! ./actions/sendUserOperation */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/actions/sendUserOperation.js\"), exports);\n__exportStar(__webpack_require__(/*! ./actions/waitForUserOperation */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/actions/waitForUserOperation.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWEsbUJBQU8sQ0FBQyxnR0FBb0I7QUFDekMsYUFBYSxtQkFBTyxDQUFDLGtJQUFxQztBQUMxRCxhQUFhLG1CQUFPLENBQUMsOEhBQW1DO0FBQ3hELGFBQWEsbUJBQU8sQ0FBQyxvR0FBc0I7QUFDM0MsYUFBYSxtQkFBTyxDQUFDLDRGQUFrQjtBQUN2QyxhQUFhLG1CQUFPLENBQUMsNEdBQTBCO0FBQy9DLGFBQWEsbUJBQU8sQ0FBQyxnR0FBb0I7QUFDekMsYUFBYSxtQkFBTyxDQUFDLHdHQUF3QjtBQUM3QyxhQUFhLG1CQUFPLENBQUMsa0dBQXFCO0FBQzFDLGFBQWEsbUJBQU8sQ0FBQyxvR0FBc0I7QUFDM0MsYUFBYSxtQkFBTyxDQUFDLDhHQUEyQjtBQUNoRCxhQUFhLG1CQUFPLENBQUMsd0hBQWdDO0FBQ3JELGFBQWEsbUJBQU8sQ0FBQyw4RkFBbUI7QUFDeEMsYUFBYSxtQkFBTyxDQUFDLHNIQUErQjtBQUNwRCxhQUFhLG1CQUFPLENBQUMsMEZBQWlCO0FBQ3RDLGFBQWEsbUJBQU8sQ0FBQyxzSEFBK0I7QUFDcEQsYUFBYSxtQkFBTyxDQUFDLG9IQUE4QjtBQUNuRCxhQUFhLG1CQUFPLENBQUMsNEdBQTBCO0FBQy9DLGFBQWEsbUJBQU8sQ0FBQyw4R0FBMkI7QUFDaEQsYUFBYSxtQkFBTyxDQUFDLGdIQUE0QjtBQUNqRCxhQUFhLG1CQUFPLENBQUMsb0hBQThCO0FBQ25ELGFBQWEsbUJBQU8sQ0FBQyw4R0FBMkI7QUFDaEQsYUFBYSxtQkFBTyxDQUFDLDRGQUFrQjtBQUN2QyxhQUFhLG1CQUFPLENBQUMsd0dBQXdCO0FBQzdDLGFBQWEsbUJBQU8sQ0FBQyxrR0FBcUI7QUFDMUMsYUFBYSxtQkFBTyxDQUFDLDRGQUFrQjtBQUN2QyxhQUFhLG1CQUFPLENBQUMsb0dBQXNCO0FBQzNDLGFBQWEsbUJBQU8sQ0FBQyw4RkFBbUI7QUFDeEMsYUFBYSxtQkFBTyxDQUFDLGdHQUFvQjtBQUN6QyxhQUFhLG1CQUFPLENBQUMsNEdBQTBCO0FBQy9DLGFBQWEsbUJBQU8sQ0FBQyw0R0FBMEI7QUFDL0MsYUFBYSxtQkFBTyxDQUFDLHdHQUF3QjtBQUM3QyxhQUFhLG1CQUFPLENBQUMsOEdBQTJCO0FBQ2hELGFBQWEsbUJBQU8sQ0FBQyxzR0FBdUI7QUFDNUMsYUFBYSxtQkFBTyxDQUFDLHNGQUFlO0FBQ3BDLGFBQWEsbUJBQU8sQ0FBQywwRkFBaUI7QUFDdEMsYUFBYSxtQkFBTyxDQUFDLGtIQUE2QjtBQUNsRCxhQUFhLG1CQUFPLENBQUMsMEdBQXlCO0FBQzlDLGFBQWEsbUJBQU8sQ0FBQyxrSEFBNkI7QUFDbEQsYUFBYSxtQkFBTyxDQUFDLHdIQUFnQyIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cnZpdmFsLWZ1bi8uL25vZGVfbW9kdWxlcy9AY29pbmJhc2UvY29pbmJhc2Utc2RrL2Rpc3QvaW5kZXguanM/NDBlMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NvaW5iYXNlL2FkZHJlc3NcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NvaW5iYXNlL2FkZHJlc3MvZXh0ZXJuYWxfYWRkcmVzc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY29pbmJhc2UvYWRkcmVzcy93YWxsZXRfYWRkcmVzc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY29pbmJhc2UvYXBpX2Vycm9yXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jb2luYmFzZS9hc3NldFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY29pbmJhc2UvYXV0aGVudGljYXRvclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY29pbmJhc2UvYmFsYW5jZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY29pbmJhc2UvYmFsYW5jZV9tYXBcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NvaW5iYXNlL2NvaW5iYXNlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jb2luYmFzZS9jb25zdGFudHNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NvaW5iYXNlL2NvbnRyYWN0X2V2ZW50XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jb2luYmFzZS9jb250cmFjdF9pbnZvY2F0aW9uXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jb2luYmFzZS9lcnJvcnNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NvaW5iYXNlL2ZhdWNldF90cmFuc2FjdGlvblwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY29pbmJhc2UvaGFzaFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY29pbmJhc2UvaGlzdG9yaWNhbF9iYWxhbmNlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jb2luYmFzZS9wYXlsb2FkX3NpZ25hdHVyZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY29pbmJhc2Uvc2VydmVyX3NpZ25lclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY29pbmJhc2Uvc21hcnRfY29udHJhY3RcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NvaW5iYXNlL3N0YWtpbmdfYmFsYW5jZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY29pbmJhc2Uvc3Rha2luZ19vcGVyYXRpb25cIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NvaW5iYXNlL3N0YWtpbmdfcmV3YXJkXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jb2luYmFzZS90cmFkZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY29pbmJhc2UvdHJhbnNhY3Rpb25cIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NvaW5iYXNlL3RyYW5zZmVyXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jb2luYmFzZS90eXBlc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY29pbmJhc2UvdmFsaWRhdG9yXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jb2luYmFzZS93YWxsZXRcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NvaW5iYXNlL3dlYmhvb2tcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NvaW5iYXNlL3JlYWRfY29udHJhY3RcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NvaW5iYXNlL2NyeXB0b19hbW91bnRcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NvaW5iYXNlL2ZpYXRfYW1vdW50XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jb2luYmFzZS9mdW5kX29wZXJhdGlvblwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY29pbmJhc2UvZnVuZF9xdW90ZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdHlwZXMvY2hhaW5cIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3dhbGxldHMvdHlwZXNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3dhbGxldHMvY3JlYXRlU21hcnRXYWxsZXRcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3dhbGxldHMvdG9TbWFydFdhbGxldFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYWN0aW9ucy9zZW5kVXNlck9wZXJhdGlvblwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYWN0aW9ucy93YWl0Rm9yVXNlck9wZXJhdGlvblwiKSwgZXhwb3J0cyk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/types/chain.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/types/chain.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CHAIN_ID_TO_NETWORK_ID = void 0;\nconst api_1 = __webpack_require__(/*! ../client/api */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/client/api.js\");\n/**\n * Maps chain IDs to their corresponding Coinbase network IDs. Only SmartWallet related chains are listed here right now.\n */\nexports.CHAIN_ID_TO_NETWORK_ID = {\n    8453: api_1.NetworkIdentifier.BaseMainnet,\n    84532: api_1.NetworkIdentifier.BaseSepolia,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L3R5cGVzL2NoYWluLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDhCQUE4QjtBQUM5QixjQUFjLG1CQUFPLENBQUMscUZBQWU7QUFDckM7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cnZpdmFsLWZ1bi8uL25vZGVfbW9kdWxlcy9AY29pbmJhc2UvY29pbmJhc2Utc2RrL2Rpc3QvdHlwZXMvY2hhaW4uanM/NGFmMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ0hBSU5fSURfVE9fTkVUV09SS19JRCA9IHZvaWQgMDtcbmNvbnN0IGFwaV8xID0gcmVxdWlyZShcIi4uL2NsaWVudC9hcGlcIik7XG4vKipcbiAqIE1hcHMgY2hhaW4gSURzIHRvIHRoZWlyIGNvcnJlc3BvbmRpbmcgQ29pbmJhc2UgbmV0d29yayBJRHMuIE9ubHkgU21hcnRXYWxsZXQgcmVsYXRlZCBjaGFpbnMgYXJlIGxpc3RlZCBoZXJlIHJpZ2h0IG5vdy5cbiAqL1xuZXhwb3J0cy5DSEFJTl9JRF9UT19ORVRXT1JLX0lEID0ge1xuICAgIDg0NTM6IGFwaV8xLk5ldHdvcmtJZGVudGlmaWVyLkJhc2VNYWlubmV0LFxuICAgIDg0NTMyOiBhcGlfMS5OZXR3b3JrSWRlbnRpZmllci5CYXNlU2Vwb2xpYSxcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/types/chain.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/utils/chain.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/utils/chain.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createNetwork = void 0;\nconst chain_1 = __webpack_require__(/*! ../types/chain */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/types/chain.js\");\n/**\n * Creates a network configuration for a given chain ID\n * @param chainId - The chain ID to create a network configuration for\n * @returns The network configuration\n */\nfunction createNetwork(chainId) {\n    return {\n        chainId,\n        networkId: chain_1.CHAIN_ID_TO_NETWORK_ID[chainId],\n    };\n}\nexports.createNetwork = createNetwork;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L3V0aWxzL2NoYWluLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQjtBQUNyQixnQkFBZ0IsbUJBQU8sQ0FBQyx1RkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cnZpdmFsLWZ1bi8uL25vZGVfbW9kdWxlcy9AY29pbmJhc2UvY29pbmJhc2Utc2RrL2Rpc3QvdXRpbHMvY2hhaW4uanM/YWE4NyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlTmV0d29yayA9IHZvaWQgMDtcbmNvbnN0IGNoYWluXzEgPSByZXF1aXJlKFwiLi4vdHlwZXMvY2hhaW5cIik7XG4vKipcbiAqIENyZWF0ZXMgYSBuZXR3b3JrIGNvbmZpZ3VyYXRpb24gZm9yIGEgZ2l2ZW4gY2hhaW4gSURcbiAqIEBwYXJhbSBjaGFpbklkIC0gVGhlIGNoYWluIElEIHRvIGNyZWF0ZSBhIG5ldHdvcmsgY29uZmlndXJhdGlvbiBmb3JcbiAqIEByZXR1cm5zIFRoZSBuZXR3b3JrIGNvbmZpZ3VyYXRpb25cbiAqL1xuZnVuY3Rpb24gY3JlYXRlTmV0d29yayhjaGFpbklkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY2hhaW5JZCxcbiAgICAgICAgbmV0d29ya0lkOiBjaGFpbl8xLkNIQUlOX0lEX1RPX05FVFdPUktfSURbY2hhaW5JZF0sXG4gICAgfTtcbn1cbmV4cG9ydHMuY3JlYXRlTmV0d29yayA9IGNyZWF0ZU5ldHdvcms7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/utils/chain.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/utils/wait.js":
/*!****************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/utils/wait.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.wait = void 0;\nconst errors_1 = __webpack_require__(/*! ../coinbase/errors */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/errors.js\");\n/**\n * Polls a resource until a terminal condition is met or timeout occurs.\n *\n * @param reload - Function that fetches the latest state of the resource\n * @param isTerminal - Function that determines if the current state is terminal\n * @param transform - Function that transforms the resource into a new type\n * @param options - Configuration options for polling behavior\n * @returns The resource in its terminal state\n * @throws {TimeoutError} If the operation exceeds the timeout duration\n *\n * @example\n * const result = await wait(\n *   () => fetchOrderStatus(orderId),\n *   (status) => status === 'completed',\n *   (status) => status === 'completed' ? { status } : undefined,\n *   { timeoutSeconds: 30 }\n * );\n */\nasync function wait(reload, isTerminal, transform = (obj) => obj, options = {}) {\n    const { intervalSeconds = 0.2, timeoutSeconds = 10 } = options;\n    const startTime = Date.now();\n    while (Date.now() - startTime < timeoutSeconds * 1000) {\n        const updatedObject = await reload();\n        if (isTerminal(updatedObject)) {\n            return transform(updatedObject);\n        }\n        await new Promise(resolve => setTimeout(resolve, intervalSeconds * 1000));\n    }\n    throw new errors_1.TimeoutError(`Operation has not reached a terminal state after ${timeoutSeconds} seconds and may still succeed. Retry with a longer timeout using the timeoutSeconds option.`);\n}\nexports.wait = wait;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L3V0aWxzL3dhaXQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsWUFBWTtBQUNaLGlCQUFpQixtQkFBTyxDQUFDLCtGQUFvQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsU0FBUztBQUNyRCxPQUFPO0FBQ1A7QUFDQTtBQUNBLDhFQUE4RTtBQUM5RSxZQUFZLDZDQUE2QztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGLGdCQUFnQjtBQUN4RztBQUNBLFlBQVkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXJ2aXZhbC1mdW4vLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L3V0aWxzL3dhaXQuanM/NjlmNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMud2FpdCA9IHZvaWQgMDtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4uL2NvaW5iYXNlL2Vycm9yc1wiKTtcbi8qKlxuICogUG9sbHMgYSByZXNvdXJjZSB1bnRpbCBhIHRlcm1pbmFsIGNvbmRpdGlvbiBpcyBtZXQgb3IgdGltZW91dCBvY2N1cnMuXG4gKlxuICogQHBhcmFtIHJlbG9hZCAtIEZ1bmN0aW9uIHRoYXQgZmV0Y2hlcyB0aGUgbGF0ZXN0IHN0YXRlIG9mIHRoZSByZXNvdXJjZVxuICogQHBhcmFtIGlzVGVybWluYWwgLSBGdW5jdGlvbiB0aGF0IGRldGVybWluZXMgaWYgdGhlIGN1cnJlbnQgc3RhdGUgaXMgdGVybWluYWxcbiAqIEBwYXJhbSB0cmFuc2Zvcm0gLSBGdW5jdGlvbiB0aGF0IHRyYW5zZm9ybXMgdGhlIHJlc291cmNlIGludG8gYSBuZXcgdHlwZVxuICogQHBhcmFtIG9wdGlvbnMgLSBDb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHBvbGxpbmcgYmVoYXZpb3JcbiAqIEByZXR1cm5zIFRoZSByZXNvdXJjZSBpbiBpdHMgdGVybWluYWwgc3RhdGVcbiAqIEB0aHJvd3Mge1RpbWVvdXRFcnJvcn0gSWYgdGhlIG9wZXJhdGlvbiBleGNlZWRzIHRoZSB0aW1lb3V0IGR1cmF0aW9uXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHdhaXQoXG4gKiAgICgpID0+IGZldGNoT3JkZXJTdGF0dXMob3JkZXJJZCksXG4gKiAgIChzdGF0dXMpID0+IHN0YXR1cyA9PT0gJ2NvbXBsZXRlZCcsXG4gKiAgIChzdGF0dXMpID0+IHN0YXR1cyA9PT0gJ2NvbXBsZXRlZCcgPyB7IHN0YXR1cyB9IDogdW5kZWZpbmVkLFxuICogICB7IHRpbWVvdXRTZWNvbmRzOiAzMCB9XG4gKiApO1xuICovXG5hc3luYyBmdW5jdGlvbiB3YWl0KHJlbG9hZCwgaXNUZXJtaW5hbCwgdHJhbnNmb3JtID0gKG9iaikgPT4gb2JqLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGludGVydmFsU2Vjb25kcyA9IDAuMiwgdGltZW91dFNlY29uZHMgPSAxMCB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIHdoaWxlIChEYXRlLm5vdygpIC0gc3RhcnRUaW1lIDwgdGltZW91dFNlY29uZHMgKiAxMDAwKSB7XG4gICAgICAgIGNvbnN0IHVwZGF0ZWRPYmplY3QgPSBhd2FpdCByZWxvYWQoKTtcbiAgICAgICAgaWYgKGlzVGVybWluYWwodXBkYXRlZE9iamVjdCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cmFuc2Zvcm0odXBkYXRlZE9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIGludGVydmFsU2Vjb25kcyAqIDEwMDApKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IGVycm9yc18xLlRpbWVvdXRFcnJvcihgT3BlcmF0aW9uIGhhcyBub3QgcmVhY2hlZCBhIHRlcm1pbmFsIHN0YXRlIGFmdGVyICR7dGltZW91dFNlY29uZHN9IHNlY29uZHMgYW5kIG1heSBzdGlsbCBzdWNjZWVkLiBSZXRyeSB3aXRoIGEgbG9uZ2VyIHRpbWVvdXQgdXNpbmcgdGhlIHRpbWVvdXRTZWNvbmRzIG9wdGlvbi5gKTtcbn1cbmV4cG9ydHMud2FpdCA9IHdhaXQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/utils/wait.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/wallets/createSmartWallet.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/wallets/createSmartWallet.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createSmartWallet = void 0;\nconst index_1 = __webpack_require__(/*! ../index */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/index.js\");\nconst toSmartWallet_1 = __webpack_require__(/*! ./toSmartWallet */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/wallets/toSmartWallet.js\");\n/**\n * @description Creates a new smart wallet using the Coinbase API\n *\n * @param - {@link CreateSmartWalletOptions} options - Configuration options for creating the smart wallet\n * @returns {Promise<SmartWallet>} A promise that resolves to the newly created smart wallet instance\n * @throws {Error} If the Coinbase API client is not initialized\n *\n * See https://viem.sh/docs/accounts/local/privateKeyToAccount for using a Viem LocalAccount with SmartWallet\n *\n * @example\n * ```ts\n * import { generatePrivateKey, privateKeyToAccount } from \"viem/accounts\";\n * import { createSmartWallet } from \"@coinbase/coinbase-sdk\";\n * import { Coinbase } from \"@coinbase/coinbase-sdk\";\n *\n * Coinbase.configureFromJson({filePath: \"~/.apikeys/prod.json\"});\n *\n * const privateKey = generatePrivateKey();\n * const owner = privateKeyToAccount(privateKey);\n * const wallet = await createSmartWallet({\n *   signer: owner\n * });\n * ```\n *\n */\nasync function createSmartWallet(options) {\n    const result = await index_1.Coinbase.apiClients.smartWallet.createSmartWallet({\n        owner: options.signer.address,\n    });\n    return (0, toSmartWallet_1.toSmartWallet)({\n        smartWalletAddress: result.data.address,\n        signer: options.signer,\n    });\n}\nexports.createSmartWallet = createSmartWallet;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L3dhbGxldHMvY3JlYXRlU21hcnRXYWxsZXQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QseUJBQXlCO0FBQ3pCLGdCQUFnQixtQkFBTyxDQUFDLDJFQUFVO0FBQ2xDLHdCQUF3QixtQkFBTyxDQUFDLGtHQUFpQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQSxhQUFhLGdDQUFnQztBQUM3QyxhQUFhLHNCQUFzQjtBQUNuQyxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMENBQTBDO0FBQ3RELFlBQVksb0JBQW9CO0FBQ2hDLFlBQVksV0FBVztBQUN2QjtBQUNBLCtCQUErQixpQ0FBaUM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EseUJBQXlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3Vydml2YWwtZnVuLy4vbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9jb2luYmFzZS1zZGsvZGlzdC93YWxsZXRzL2NyZWF0ZVNtYXJ0V2FsbGV0LmpzP2Y2NzciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyZWF0ZVNtYXJ0V2FsbGV0ID0gdm9pZCAwO1xuY29uc3QgaW5kZXhfMSA9IHJlcXVpcmUoXCIuLi9pbmRleFwiKTtcbmNvbnN0IHRvU21hcnRXYWxsZXRfMSA9IHJlcXVpcmUoXCIuL3RvU21hcnRXYWxsZXRcIik7XG4vKipcbiAqIEBkZXNjcmlwdGlvbiBDcmVhdGVzIGEgbmV3IHNtYXJ0IHdhbGxldCB1c2luZyB0aGUgQ29pbmJhc2UgQVBJXG4gKlxuICogQHBhcmFtIC0ge0BsaW5rIENyZWF0ZVNtYXJ0V2FsbGV0T3B0aW9uc30gb3B0aW9ucyAtIENvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgY3JlYXRpbmcgdGhlIHNtYXJ0IHdhbGxldFxuICogQHJldHVybnMge1Byb21pc2U8U21hcnRXYWxsZXQ+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgbmV3bHkgY3JlYXRlZCBzbWFydCB3YWxsZXQgaW5zdGFuY2VcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgQ29pbmJhc2UgQVBJIGNsaWVudCBpcyBub3QgaW5pdGlhbGl6ZWRcbiAqXG4gKiBTZWUgaHR0cHM6Ly92aWVtLnNoL2RvY3MvYWNjb3VudHMvbG9jYWwvcHJpdmF0ZUtleVRvQWNjb3VudCBmb3IgdXNpbmcgYSBWaWVtIExvY2FsQWNjb3VudCB3aXRoIFNtYXJ0V2FsbGV0XG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBnZW5lcmF0ZVByaXZhdGVLZXksIHByaXZhdGVLZXlUb0FjY291bnQgfSBmcm9tIFwidmllbS9hY2NvdW50c1wiO1xuICogaW1wb3J0IHsgY3JlYXRlU21hcnRXYWxsZXQgfSBmcm9tIFwiQGNvaW5iYXNlL2NvaW5iYXNlLXNka1wiO1xuICogaW1wb3J0IHsgQ29pbmJhc2UgfSBmcm9tIFwiQGNvaW5iYXNlL2NvaW5iYXNlLXNka1wiO1xuICpcbiAqIENvaW5iYXNlLmNvbmZpZ3VyZUZyb21Kc29uKHtmaWxlUGF0aDogXCJ+Ly5hcGlrZXlzL3Byb2QuanNvblwifSk7XG4gKlxuICogY29uc3QgcHJpdmF0ZUtleSA9IGdlbmVyYXRlUHJpdmF0ZUtleSgpO1xuICogY29uc3Qgb3duZXIgPSBwcml2YXRlS2V5VG9BY2NvdW50KHByaXZhdGVLZXkpO1xuICogY29uc3Qgd2FsbGV0ID0gYXdhaXQgY3JlYXRlU21hcnRXYWxsZXQoe1xuICogICBzaWduZXI6IG93bmVyXG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqL1xuYXN5bmMgZnVuY3Rpb24gY3JlYXRlU21hcnRXYWxsZXQob3B0aW9ucykge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGluZGV4XzEuQ29pbmJhc2UuYXBpQ2xpZW50cy5zbWFydFdhbGxldC5jcmVhdGVTbWFydFdhbGxldCh7XG4gICAgICAgIG93bmVyOiBvcHRpb25zLnNpZ25lci5hZGRyZXNzLFxuICAgIH0pO1xuICAgIHJldHVybiAoMCwgdG9TbWFydFdhbGxldF8xLnRvU21hcnRXYWxsZXQpKHtcbiAgICAgICAgc21hcnRXYWxsZXRBZGRyZXNzOiByZXN1bHQuZGF0YS5hZGRyZXNzLFxuICAgICAgICBzaWduZXI6IG9wdGlvbnMuc2lnbmVyLFxuICAgIH0pO1xufVxuZXhwb3J0cy5jcmVhdGVTbWFydFdhbGxldCA9IGNyZWF0ZVNtYXJ0V2FsbGV0O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/wallets/createSmartWallet.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/wallets/toSmartWallet.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/wallets/toSmartWallet.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.toSmartWallet = void 0;\nconst sendUserOperation_1 = __webpack_require__(/*! ../actions/sendUserOperation */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/actions/sendUserOperation.js\");\nconst chain_1 = __webpack_require__(/*! ../utils/chain */ \"(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/utils/chain.js\");\n/**\n * Creates a SmartWallet instance from an existing smart wallet address and signer.\n * Use this to interact with previously deployed smart wallets, rather than creating new ones.\n *\n * The signer must be the original owner of the smart wallet.\n *\n * @example\n * ```typescript\n * import { toSmartWallet } from \"@coinbase/coinbase-sdk\";\n *\n * // Connect to an existing smart wallet\n * const wallet = toSmartWallet({\n *   smartWalletAddress: \"0x1234567890123456789012345678901234567890\",\n *   signer: localAccount\n * });\n *\n * // Use on a specific network\n * const networkWallet = wallet.useNetwork({\n *   chainId: 8453, // Base Mainnet\n *   paymasterUrl: \"https://paymaster.example.com\"\n * });\n * ```\n *\n * @param {ToSmartWalletOptions} options - Configuration options\n * @param {string} options.smartWalletAddress - The deployed smart wallet's address\n * @param {Signer} options.signer - The owner's signer instance\n * @returns {SmartWallet} A configured SmartWallet instance ready for transaction submission\n * @throws {Error} If the signer is not an original owner of the wallet\n */\nfunction toSmartWallet(options) {\n    const wallet = {\n        address: options.smartWalletAddress,\n        owners: [options.signer],\n        type: \"smart\",\n        sendUserOperation: options => (0, sendUserOperation_1.sendUserOperation)(wallet, options),\n        useNetwork: (options) => {\n            const network = (0, chain_1.createNetwork)(options.chainId);\n            return {\n                ...wallet,\n                network,\n                paymasterUrl: options.paymasterUrl,\n                sendUserOperation: options => (0, sendUserOperation_1.sendUserOperation)(wallet, {\n                    ...options,\n                    chainId: network.chainId,\n                }),\n            };\n        },\n    };\n    return wallet;\n}\nexports.toSmartWallet = toSmartWallet;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L3dhbGxldHMvdG9TbWFydFdhbGxldC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUI7QUFDckIsNEJBQTRCLG1CQUFPLENBQUMsbUhBQThCO0FBQ2xFLGdCQUFnQixtQkFBTyxDQUFDLHVGQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxXQUFXLHNCQUFzQjtBQUNqQyxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsYUFBYTtBQUMxQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EscUJBQXFCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3Vydml2YWwtZnVuLy4vbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9jb2luYmFzZS1zZGsvZGlzdC93YWxsZXRzL3RvU21hcnRXYWxsZXQuanM/YTFiOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudG9TbWFydFdhbGxldCA9IHZvaWQgMDtcbmNvbnN0IHNlbmRVc2VyT3BlcmF0aW9uXzEgPSByZXF1aXJlKFwiLi4vYWN0aW9ucy9zZW5kVXNlck9wZXJhdGlvblwiKTtcbmNvbnN0IGNoYWluXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvY2hhaW5cIik7XG4vKipcbiAqIENyZWF0ZXMgYSBTbWFydFdhbGxldCBpbnN0YW5jZSBmcm9tIGFuIGV4aXN0aW5nIHNtYXJ0IHdhbGxldCBhZGRyZXNzIGFuZCBzaWduZXIuXG4gKiBVc2UgdGhpcyB0byBpbnRlcmFjdCB3aXRoIHByZXZpb3VzbHkgZGVwbG95ZWQgc21hcnQgd2FsbGV0cywgcmF0aGVyIHRoYW4gY3JlYXRpbmcgbmV3IG9uZXMuXG4gKlxuICogVGhlIHNpZ25lciBtdXN0IGJlIHRoZSBvcmlnaW5hbCBvd25lciBvZiB0aGUgc21hcnQgd2FsbGV0LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBpbXBvcnQgeyB0b1NtYXJ0V2FsbGV0IH0gZnJvbSBcIkBjb2luYmFzZS9jb2luYmFzZS1zZGtcIjtcbiAqXG4gKiAvLyBDb25uZWN0IHRvIGFuIGV4aXN0aW5nIHNtYXJ0IHdhbGxldFxuICogY29uc3Qgd2FsbGV0ID0gdG9TbWFydFdhbGxldCh7XG4gKiAgIHNtYXJ0V2FsbGV0QWRkcmVzczogXCIweDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTBcIixcbiAqICAgc2lnbmVyOiBsb2NhbEFjY291bnRcbiAqIH0pO1xuICpcbiAqIC8vIFVzZSBvbiBhIHNwZWNpZmljIG5ldHdvcmtcbiAqIGNvbnN0IG5ldHdvcmtXYWxsZXQgPSB3YWxsZXQudXNlTmV0d29yayh7XG4gKiAgIGNoYWluSWQ6IDg0NTMsIC8vIEJhc2UgTWFpbm5ldFxuICogICBwYXltYXN0ZXJVcmw6IFwiaHR0cHM6Ly9wYXltYXN0ZXIuZXhhbXBsZS5jb21cIlxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge1RvU21hcnRXYWxsZXRPcHRpb25zfSBvcHRpb25zIC0gQ29uZmlndXJhdGlvbiBvcHRpb25zXG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5zbWFydFdhbGxldEFkZHJlc3MgLSBUaGUgZGVwbG95ZWQgc21hcnQgd2FsbGV0J3MgYWRkcmVzc1xuICogQHBhcmFtIHtTaWduZXJ9IG9wdGlvbnMuc2lnbmVyIC0gVGhlIG93bmVyJ3Mgc2lnbmVyIGluc3RhbmNlXG4gKiBAcmV0dXJucyB7U21hcnRXYWxsZXR9IEEgY29uZmlndXJlZCBTbWFydFdhbGxldCBpbnN0YW5jZSByZWFkeSBmb3IgdHJhbnNhY3Rpb24gc3VibWlzc2lvblxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBzaWduZXIgaXMgbm90IGFuIG9yaWdpbmFsIG93bmVyIG9mIHRoZSB3YWxsZXRcbiAqL1xuZnVuY3Rpb24gdG9TbWFydFdhbGxldChvcHRpb25zKSB7XG4gICAgY29uc3Qgd2FsbGV0ID0ge1xuICAgICAgICBhZGRyZXNzOiBvcHRpb25zLnNtYXJ0V2FsbGV0QWRkcmVzcyxcbiAgICAgICAgb3duZXJzOiBbb3B0aW9ucy5zaWduZXJdLFxuICAgICAgICB0eXBlOiBcInNtYXJ0XCIsXG4gICAgICAgIHNlbmRVc2VyT3BlcmF0aW9uOiBvcHRpb25zID0+ICgwLCBzZW5kVXNlck9wZXJhdGlvbl8xLnNlbmRVc2VyT3BlcmF0aW9uKSh3YWxsZXQsIG9wdGlvbnMpLFxuICAgICAgICB1c2VOZXR3b3JrOiAob3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmV0d29yayA9ICgwLCBjaGFpbl8xLmNyZWF0ZU5ldHdvcmspKG9wdGlvbnMuY2hhaW5JZCk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC4uLndhbGxldCxcbiAgICAgICAgICAgICAgICBuZXR3b3JrLFxuICAgICAgICAgICAgICAgIHBheW1hc3RlclVybDogb3B0aW9ucy5wYXltYXN0ZXJVcmwsXG4gICAgICAgICAgICAgICAgc2VuZFVzZXJPcGVyYXRpb246IG9wdGlvbnMgPT4gKDAsIHNlbmRVc2VyT3BlcmF0aW9uXzEuc2VuZFVzZXJPcGVyYXRpb24pKHdhbGxldCwge1xuICAgICAgICAgICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICBjaGFpbklkOiBuZXR3b3JrLmNoYWluSWQsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgIH07XG4gICAgcmV0dXJuIHdhbGxldDtcbn1cbmV4cG9ydHMudG9TbWFydFdhbGxldCA9IHRvU21hcnRXYWxsZXQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/wallets/toSmartWallet.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/wallets/types.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/wallets/types.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L3dhbGxldHMvdHlwZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXJ2aXZhbC1mdW4vLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L3dhbGxldHMvdHlwZXMuanM/NmMyYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@coinbase/coinbase-sdk/dist/wallets/types.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/agentkit/package.json":
/*!******************************************************!*\
  !*** ./node_modules/@coinbase/agentkit/package.json ***!
  \******************************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"name":"@coinbase/agentkit","description":"Coinbase AgentKit core primitives","repository":"https://github.com/coinbase/agentkit","version":"0.6.2","author":"Coinbase Inc.","license":"Apache-2.0","main":"dist/index.js","types":"dist/index.d.ts","files":["dist"],"keywords":["coinbase","sdk","crypto","cdp","agentkit","ai","agent","nodejs","typescript"],"dependencies":{"@across-protocol/app-sdk":"^0.2.0","@alloralabs/allora-sdk":"^0.1.0","@coinbase/coinbase-sdk":"^0.20.0","@jup-ag/api":"^6.0.39","@privy-io/public-api":"^2.18.5","@privy-io/server-auth":"^1.18.4","@solana/spl-token":"^0.4.12","@solana/web3.js":"^1.98.0","bs58":"^4.0.1","canonicalize":"^2.1.0","decimal.js":"^10.5.0","ethers":"^6.13.5","md5":"^2.3.0","opensea-js":"^7.1.18","reflect-metadata":"^0.2.2","twitter-api-v2":"^1.18.2","viem":"^2.22.16","zod":"^3.23.8"},"devDependencies":{"@types/jest":"^29.5.14","@types/nunjucks":"^3.2.6","@types/ora":"^3.2.0","@types/prompts":"^2.4.9","@types/secp256k1":"^4.0.6","abitype":"^1.0.8","http-server":"^14.1.1","jest":"^29.7.0","mock-fs":"^5.2.0","nunjucks":"^3.2.4","ora":"^7.0.1","picocolors":"^1.0.0","prompts":"^2.4.2","ts-jest":"^29.2.5","tsd":"^0.31.2","tsx":"^4.7.1","typescript":"^5.7.2","yargs":"^17.7.2"},"exports":{".":{"types":"./dist/index.d.ts","default":"./dist/index.js"}},"scripts":{"build":"tsc","lint":"eslint -c .eslintrc.json \\"src/**/*.ts\\"","lint:fix":"eslint -c .eslintrc.json \\"src/**/*.ts\\" --fix","format":"prettier -c .prettierrc --write \\"**/*.{ts,js,cjs,json,md}\\"","format:check":"prettier -c .prettierrc --check \\"**/*.{ts,js,cjs,json,md}\\"","check":"tsc --noEmit","test":"jest --no-cache --testMatch=\'**/*.test.ts\'","test:e2e":"jest --no-cache --testMatch=**/e2e.ts --coverageThreshold \'{}\'","test:types":"tsd --files src/tests/types.test-d.ts","clean":"rm -rf dist/*","docs":"typedoc --entryPoints ./src --entryPointStrategy expand --exclude ./src/tests/**/*.ts","docs:serve":"http-server ./docs","dev":"tsc --watch","generate:action-provider":"tsx ./scripts/generate-action-provider/main.ts"}}');

/***/ }),

/***/ "(rsc)/./node_modules/@coinbase/coinbase-sdk/package.json":
/*!**********************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/package.json ***!
  \**********************************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"name":"@coinbase/coinbase-sdk","author":"Coinbase Inc.","license":"ISC","description":"Coinbase Platform SDK","repository":"https://github.com/coinbase/coinbase-sdk-nodejs","version":"0.20.0","main":"dist/index.js","types":"dist/index.d.ts","scripts":{"lint":"eslint -c .eslintrc.json src/coinbase/**.ts","lint-fix":"eslint -c .eslintrc.json src/coinbase/*.ts --fix","format":"prettier -c .prettierrc --write \\"**/*.{ts,js,cjs,json,md}\\"","format-check":"prettier -c .prettierrc --check \\"**/*.{ts,js,cjs,json,md}\\"","check":"tsc --noEmit","test":"jest --config jest.config.js --testPathIgnorePatterns src/tests/e2e.ts src/tests/utils.ts src/tests/types.test-d.ts","test:dry-run":"npm install && npm ci && npm publish --dry-run","test:e2e":"npx jest --no-cache --testMatch=**/e2e.ts --coverageThreshold \'{}\'","test:e2e:stake":"npx jest --no-cache --testMatch=**/e2e.ts --coverageThreshold \'{}\' -t Stake","test:types":"tsd --files src/tests/types.test-d.ts","clean":"rm -rf dist/*","build":"tsc","prepack":"tsc --skipLibCheck","docs":"typedoc --entryPoints ./src --entryPointStrategy expand --exclude ./src/tests/**/*.ts"},"files":["dist"],"dependencies":{"@scure/bip32":"^1.4.0","abitype":"^1.0.6","axios":"^1.6.8","axios-mock-adapter":"^1.22.0","axios-retry":"^4.4.1","bip32":"^4.0.0","bip39":"^3.1.0","decimal.js":"^10.4.3","dotenv":"^16.4.5","ed2curve":"^0.3.0","ethers":"^6.12.1","jose":"^5.10.0","secp256k1":"^5.0.0","viem":"^2.21.26"},"devDependencies":{"@types/jest":"^29.5.12","@types/node":"^20.12.11","@types/secp256k1":"^4.0.6","@typescript-eslint/eslint-plugin":"^7.8.0","@typescript-eslint/parser":"^7.8.0","eslint":"^8.57.0","eslint-config-prettier":"^9.1.0","eslint-plugin-jsdoc":"^48.2.5","eslint-plugin-prettier":"^5.1.3","jest":"^29.7.0","mock-fs":"^5.2.0","prettier":"^3.2.5","ts-jest":"^29.1.2","ts-node":"^10.9.2","tsd":"^0.31.2","typedoc":"^0.25.13","typescript":"^5.4.5"}}');

/***/ })

};
;